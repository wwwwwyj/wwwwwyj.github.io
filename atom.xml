<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuYJ&#39;s Blog</title>
  
  <subtitle>wuyunjie的小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuyunjie.top/"/>
  <updated>2021-05-26T05:51:46.000Z</updated>
  <id>https://wuyunjie.top/</id>
  
  <author>
    <name>wuyunjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer-13-调整数组顺序使奇数位于偶数前面</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ13_the_odd_numbers_come_before_the_even_numbers.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ13_the_odd_numbers_come_before_the_even_numbers.html</id>
    <published>2021-05-26T05:51:46.000Z</published>
    <updated>2021-05-26T05:51:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一问题描述">一、问题描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 <a id="more"></a></p><p><strong>示例1</strong></p><blockquote><p>输入：[1,2,3,4] 返回值：[1,3,2,4]</p></blockquote><p><strong>示例2</strong></p><blockquote><p>输入：[2,4,6,5,7] 返回值：[5,7,2,4,6]</p></blockquote><h3 id="二解题思路">二、解题思路</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一问题描述&quot;&gt;一、问题描述&lt;/h3&gt;
&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-12-数值的整数次方</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ12_Integer_power.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ12_Integer_power.html</id>
    <published>2021-05-26T05:21:51.000Z</published>
    <updated>2021-05-26T05:21:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一问题描述">一、问题描述</h3><p>给定一个<code>double</code>类型的浮点数<code>base</code>和<code>int</code>类型的整数<code>exponent</code>。求<code>base</code>的<code>exponent</code>次方。</p><p>保证<code>base</code>和<code>exponent</code>不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面<code>0</code>的位数。 <a id="more"></a></p><p><strong>示例1</strong></p><blockquote><p>输入：2.00000, 3 返回值：8.00000</p></blockquote><p><strong>示例2</strong></p><blockquote><p>输入：2.10000, 3 返回值：9.26100</p></blockquote><p><strong>示例3</strong></p><blockquote><p>输入：2.00000,-2 返回值：0.25000</p></blockquote><h3 id="二解题思路">二、解题思路</h3><p>根据题意，不需要考虑大数情况，并且<code>exponent</code>是整数，那么直接的方法就是先对<code>exponent</code>的正负判断：</p><ul><li>若为正整数，直接循环<code>exponent</code>次乘法求出结果</li><li>若为负整数，循环<code>-exponent</code>次乘法求出结果，然后对结果求倒数</li></ul><h4 id="快速幂">快速幂</h4><p>假设我们求<span class="math inline">\(x^{8}\)</span>，如果我们知道<span class="math inline">\(x^{4}\)</span>，那么<span class="math inline">\(x^{8} = (x^{4})^{2}\)</span>，<span class="math inline">\(x^{n} = (x^{\frac{n}{2}})^{2}\)</span>。但是还有个小问题，如果n是偶数，那么上述没问题。如果<span class="math inline">\(n\)</span>是奇数，<span class="math inline">\(x^{n} = (x^{\frac{n}{2}})^{2}*x\)</span>，比如<span class="math inline">\(x^{7} = (x^{3})^{2} * x\)</span>。</p><h4 id="非递归的快速幂">非递归的快速幂</h4><p>假设求<span class="math inline">\(x^{6}\)</span>,已知<code>6</code>可以表示成二进制<code>110</code> 可以表示成<span class="math inline">\(6 = 0*2^{0} + 1 * 2^{1} + 1 * 2^{2}\)</span>, 所以<span class="math inline">\(x^{6}\)</span>可以表示成<span class="math inline">\(x^{6} = x^ {0*2^{0} + 1*2^{1} + 1*2^{2}} = x^{0} * x^{1*2^{1}}*x^{1*2^{2}}\)</span>所以，对于二进制数，遇到位数是<code>1</code>的就乘到答案中。</p><h3 id="三代码">三、代码</h3><h4 id="直接法">1. 直接法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exponent; i++)</span><br><span class="line">                result *= base;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; -exponent; i++)</span><br><span class="line">                result *= base;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/result;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速幂递归法">2. 快速幂(递归法)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickPower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> res = quickPower(base, exponent/<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res * res * base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res * res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quickPower(base, exponent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速幂非递归法">3. 快速幂(非递归法)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> x = base;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (exponent != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res *= x; <span class="comment">// 二进制位数是1的，乘进答案。</span></span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            exponent &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一问题描述&quot;&gt;一、问题描述&lt;/h3&gt;
&lt;p&gt;给定一个&lt;code&gt;double&lt;/code&gt;类型的浮点数&lt;code&gt;base&lt;/code&gt;和&lt;code&gt;int&lt;/code&gt;类型的整数&lt;code&gt;exponent&lt;/code&gt;。求&lt;code&gt;base&lt;/code&gt;的&lt;code&gt;exponent&lt;/code&gt;次方。&lt;/p&gt;
&lt;p&gt;保证&lt;code&gt;base&lt;/code&gt;和&lt;code&gt;exponent&lt;/code&gt;不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面&lt;code&gt;0&lt;/code&gt;的位数。
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-11-二进制中1的个数</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ11_Number_of_1s_in_binary.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ11_Number_of_1s_in_binary.html</id>
    <published>2021-05-26T05:01:12.000Z</published>
    <updated>2021-05-26T05:01:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一问题描述">一、问题描述</h3><p>输入一个整数，输出该数<code>32</code>位二进制表示中<code>1</code>的个数。其中负数用补码表示。 <a id="more"></a></p><p><strong>示例1</strong></p><blockquote><p>输入：10 返回值：2</p></blockquote><h3 id="二解题思路">二、解题思路</h3><h4 id="位运算">1. 位运算</h4><p>考查的应该就是位操作吧。实际上要统计<code>1</code>的个数很简单，只需要将整数逐位右移，统计最低位<code>1</code>的出现次数。判断最低为是否为<code>1</code>可以使用等式：<code>n &amp; 1</code>，结果为<code>1</code>即为<code>1</code>，否则为<code>0</code>。</p><p>这里有一个需要注意的点是，由于整数是补码表示，所以在右移的时候，若数字为负数会将高位自动补<code>1</code>。这里刚好之前学到<code>Java</code>里有一个无符号右移的运算符: <code>&gt;&gt;&gt;</code>，可以直接解决这个问题。</p><ul><li><a href="https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html">[Java学习|Head_First_Java]--十大遗珠之憾</a></li></ul><h4 id="技巧法">2. 技巧法</h4><p>考虑二进制数：<code>val :1101000</code>, <code>val-1: 1100111</code> 那么<code>val &amp; （val-1） : 1100000</code>。即：</p><blockquote><p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p></blockquote><p>把一个整数减去<code>1</code>，再和原整数做与运算，会把该整数最右边一个<code>1</code>变成<code>0</code>.那么一个整数的二进制有多少个<code>1</code>，就可以进行多少次这样的操作。</p><h3 id="三代码">三、代码</h3><h4 id="位运算-1">1. 位运算</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfOnes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            numOfOnes += (n &amp; <span class="number">1</span>);</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numOfOnes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="技巧法-1">2. 技巧法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfOnes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            numOfOnes++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numOfOnes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一问题描述&quot;&gt;一、问题描述&lt;/h3&gt;
&lt;p&gt;输入一个整数，输出该数&lt;code&gt;32&lt;/code&gt;位二进制表示中&lt;code&gt;1&lt;/code&gt;的个数。其中负数用补码表示。
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-10-矩形覆盖</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ10_Rectangular_coverage.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ10_Rectangular_coverage.html</id>
    <published>2021-05-26T04:33:52.000Z</published>
    <updated>2021-05-26T04:33:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一问题描述">一、问题描述</h3><p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用<code>n</code>个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，从同一个方向看总共有多少种不同的方法？ <a id="more"></a></p><p>比如<code>n=3</code>时，<code>2*3</code>的矩形块有<code>3</code>种不同的覆盖方法(从同一个方向看)：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ10/JZ10.png" alt="矩形覆盖" /><figcaption aria-hidden="true">矩形覆盖</figcaption></figure><p><strong>示例1</strong></p><blockquote><p>输入：0 返回值：0</p></blockquote><p><strong>示例2</strong></p><blockquote><p>输入：1 返回值：1</p></blockquote><p><strong>示例3</strong></p><blockquote><p>输入：4 返回值：5</p></blockquote><h3 id="二解题思路">二、解题思路</h3><p>实际上还是一个类似于斐波那契数列的问题(连续好几个题了)，初始化两个基本的组合，<code>1</code>个<code>2*1</code>的小矩形只有<code>1</code>种组合方式，<code>2</code>个这样的矩阵有两种组合方式，然后是这两个基本组合之上的不断叠加的组合方法。所以可以写为： <span class="math display">\[F(1)=1\\F(2)=2\\F(n) = F(n-1) + F(n-2) (n \geq 3, n \in N^*)\]</span> 剩下的就是利用之前的递归法，迭代法来实现该算法。</p><h3 id="三代码">三、代码</h3><h4 id="递归法">1. 递归法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;=<span class="number">2</span>) <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rectCover(target-<span class="number">1</span>) + rectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代法">2. 迭代法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;=<span class="number">2</span>) <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum = sum + one;</span><br><span class="line">            one = sum - one;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一问题描述&quot;&gt;一、问题描述&lt;/h3&gt;
&lt;p&gt;我们可以用&lt;code&gt;2*1&lt;/code&gt;的小矩形横着或者竖着去覆盖更大的矩形。请问用&lt;code&gt;n&lt;/code&gt;个&lt;code&gt;2*1&lt;/code&gt;的小矩形无重叠地覆盖一个&lt;code&gt;2*n&lt;/code&gt;的大矩形，从同一个方向看总共有多少种不同的方法？
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-9-跳台阶扩展问题</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ9_Jumping_expanding.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ9_Jumping_expanding.html</id>
    <published>2021-05-26T02:32:29.000Z</published>
    <updated>2021-05-26T02:32:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一问题描述">一、问题描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 <a id="more"></a> &gt; 输入：3 &gt; 返回值：4</p><h3 id="二解题思路">二、解题思路</h3><h4 id="迭代递归法">1. 迭代递归法</h4><p>还是可以转换为递归的形式，只是这里递归的计算需要改进为遍历所有小于等于n的台阶数： <span class="math display">\[F(0)=1\\F(1)=1\\F(n) = F(n-1) + F(n-2) + \cdots + F(n-n) (n \geq 2, n \in N^*)\]</span> 那么将最后的递归改进为一个循环，就可以继续利用递归算法来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">sum += jumpFloorII(target-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等式推导">2. 等式推导</h4><p>可以将该等式化简成一个简单的形式： <span class="math display">\[F(n) = F(n-1) + F(n-2) + \cdots + F(n-n) (n \geq 2, n \in N^*)\]</span> 那么可以继续得到<span class="math inline">\(F(n-1)\)</span>的计算等式： <span class="math display">\[F(n-1) = F(n-2) + F(n-3) + \cdots + F(n-n) (n \geq 3, n \in N^*)\]</span> 可以把上述两式合并得到： <span class="math display">\[F(n) = F(n-1) \times 2\]</span> 利用改等式，可以写出递归，迭代的算法。进一步优化可以将其简化为： <span class="math display">\[F(n) = 2^{(n-1)}\]</span></p><h3 id="三代码">三、代码</h3><h4 id="递归方法">1. 递归方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum += jumpFloorII(target-i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代方法">2. 迭代方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i ; j++)&#123;</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等式推导递归">3. 等式推导(递归)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> jumpFloorII(target-<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等式推导迭代法">4. 等式推导(迭代法)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等式推导最简化形式">5. 等式推导(最简化形式)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一问题描述&quot;&gt;一、问题描述&lt;/h3&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-8-跳台阶</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ8_Step_up.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ8_Step_up.html</id>
    <published>2021-05-26T02:02:02.000Z</published>
    <updated>2021-05-26T02:02:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一问题描述">一、问题描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 <a id="more"></a></p><h3 id="二解题思路">二、解题思路</h3><p>转换一下思路，其实就是在一颗树上不断搜索，其实可以很容易转化位斐波那契数列的形式，依靠递归算法求解： <span class="math display">\[F(1)=1\\F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)\]</span> 那么进一步就可以利用斐波那契数列的优化方法，对该算法从时间复杂度和空间复杂度的角度，不断优化。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ8/JZ8.png" alt="递归树结构" /><figcaption aria-hidden="true">递归树结构</figcaption></figure><h3 id="三代码">三、代码</h3><h4 id="递归方法">1. 递归方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> jumpFloor(target-<span class="number">1</span>) + jumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代方法">2. 迭代方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum = sum + one;</span><br><span class="line">            one = sum - one;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一问题描述&quot;&gt;一、问题描述&lt;/h3&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-7-斐波那契数列</title>
    <link href="https://wuyunjie.top/2021/05/25/JZ7_Fibonacci_sequence.html"/>
    <id>https://wuyunjie.top/2021/05/25/JZ7_Fibonacci_sequence.html</id>
    <published>2021-05-25T09:28:54.000Z</published>
    <updated>2021-05-25T09:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一问题描述">一、问题描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。（<code>n≤39</code>） <a id="more"></a></p><p><strong>示例:</strong></p><blockquote><p>输入: 4 返回值: 3</p></blockquote><h3 id="二解题思路">二、解题思路</h3><p>斐波那契数列的标准公式为： <span class="math display">\[F(1)=1\\F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)\]</span></p><h4 id="递归">1. 递归</h4><p>可以发现很符合递归的定义，所以递归是一种直接的思路。但递归法的时间复杂度过高(<span class="math inline">\(O(2^n)\)</span>)。</p><h4 id="迭代">2. 迭代</h4><ul><li><p>另一种方法是直接利用循环，将<span class="math inline">\(F(n), F(n-1), F(n-2)\)</span>保存在三个临时变量内，不断迭代计算出最终值。时间复杂度位(<span class="math inline">\(O(n)\)</span>)。</p></li><li><p>继续对空间进行优化，因为<span class="math inline">\(F(n)\)</span>只在计算第<span class="math inline">\(n\)</span>项的时候使用，所以可以只存储<span class="math inline">\(F(n)\)</span>和<span class="math inline">\(F(n-2)\)</span>，<span class="math inline">\(F(n-1)\)</span>可以由<span class="math inline">\(F(n)-F(n-2)\)</span>计算得到</p></li></ul><h3 id="三代码">三、代码</h3><h4 id="递归法">1. 递归法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代法">2. 迭代法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            FibArray_n = FibArray_n_1 + FibArray_n_2;</span><br><span class="line">            FibArray_n_2 = FibArray_n_1;</span><br><span class="line">            FibArray_n_1 = FibArray_n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FibArray_n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化的迭代法只使用两个变量">3. 优化的迭代法(只使用两个变量)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            FibArray_n = FibArray_n + FibArray_n_1;</span><br><span class="line">            FibArray_n_1 = FibArray_n - FibArray_n_1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FibArray_n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一问题描述&quot;&gt;一、问题描述&lt;/h3&gt;
&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。（&lt;code&gt;n≤39&lt;/code&gt;）
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-6-旋转数组的最小数字</title>
    <link href="https://wuyunjie.top/2021/05/24/JZ6_rotate_the_smallest_number_of_the_array.html"/>
    <id>https://wuyunjie.top/2021/05/24/JZ6_rotate_the_smallest_number_of_the_array.html</id>
    <published>2021-05-24T12:25:51.000Z</published>
    <updated>2021-05-24T12:25:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一问题描述">一、问题描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 <strong>NOTE</strong>：给出的所有元素都大于0，若数组大小为0，请返回0。 <a id="more"></a></p><p><strong>示例:</strong></p><blockquote><p>输入: [3,4,5,1,2] 返回值: 1</p></blockquote><h3 id="二解题思路">二、解题思路</h3><p>这道题应该是类似于查找的问题，其中数组为非递减序列是一个很关键的信息。</p><h4 id="暴力方法">1. 暴力方法</h4><p>对于查找类型的问题，都存在暴力方法，即将整个数组都遍历一遍，总会找到最小值。</p><h4 id="二分查找">2. 二分查找</h4><p>可以发现，选择数组中要找到的最小元素，即为分界线处的元素。即需要通过二分查找的方法，找到数组中的分界线。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ6/JZ61.png" alt="旋转数组" /><figcaption aria-hidden="true">旋转数组</figcaption></figure><p>在分界线左边的元素一定是要比分界线右边元素大的。所以可以基于二分查找方法，设定<code>low</code>和<code>high</code>的位置，然后判断<code>mid</code>位置是在数组的<code>左半部分</code>还是<code>右半部分</code>，逐渐缩小范围找到最小值。</p><ul><li>处于左半部分，<code>low</code>移到<code>mid</code>处</li><li>处于右半部分，<code>high</code>移到<code>mid</code>处</li><li>其他情况<code>low++</code></li></ul><p>但后来检测发现一个<code>bug</code>，遇到<code>[1, 0, 1, 1, 1]</code>这样的情况会出错：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ6/JZ62.png" alt="错过了最小值0" /><figcaption aria-hidden="true">错过了最小值<code>0</code></figcaption></figure><p>为了解决该问题，只需要在提前检查数列，如果是非递减数列，返回最低位<code>low</code>的值。</p><h3 id="三代码">三、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">1</span>) <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[low] &lt; array[high])</span><br><span class="line">                <span class="keyword">return</span> array[low];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((mid + <span class="number">1</span>) &lt; array.length &amp;&amp; array[mid] &gt; array[mid + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> array[mid + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>((mid - <span class="number">1</span>) &gt; -<span class="number">1</span> &amp;&amp; array[mid] &lt; array[mid - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> array[mid];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[low])</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; array[high])</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更简单的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rotateArray.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = rotateArray.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="comment">// 子数组是非递减的数组，10111</span></span><br><span class="line">        <span class="keyword">if</span> (rotateArray[low] &lt; rotateArray[high]) </span><br><span class="line">            <span class="keyword">return</span> rotateArray[low];</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[low])</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[high])</span><br><span class="line">            high = mid; <span class="comment">// 如果是mid-1，则可能会错过最小值，因为找的就是最小值</span></span><br><span class="line">        <span class="keyword">else</span> low++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rotateArray[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献">参考文献</h3><p>[1] <a href="https://blog.nowcoder.net/n/dcb0f2e6ffd44e1895b7a5297e362778" target="_blank" rel="noopener">【剑指offer T11】旋转数组的最小数字</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一问题描述&quot;&gt;一、问题描述&lt;/h3&gt;
&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 &lt;strong&gt;NOTE&lt;/strong&gt;：给出的所有元素都大于0，若数组大小为0，请返回0。
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-5-用两个栈实现队列</title>
    <link href="https://wuyunjie.top/2021/05/24/JZ5_implement_the_queue_with_two_stacks.html"/>
    <id>https://wuyunjie.top/2021/05/24/JZ5_implement_the_queue_with_two_stacks.html</id>
    <published>2021-05-24T11:43:12.000Z</published>
    <updated>2021-05-24T11:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一问题描述">一、问题描述</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 <a id="more"></a></p><h3 id="二解题思路">二、解题思路</h3><p>队列的特性是先进先出(<code>FIFO</code>)，栈的特点是先进后出(<code>FILO</code>)。很容易想到一个直观的方法：</p><ol type="1"><li>将队列数据先存入一个栈；</li><li>当需要<code>pop</code>出队列的元素时，将该栈元素逐个弹出存入另一个栈，然后弹出栈顶。</li></ol><p>但这样会有冗余操作，比如连续的<code>push</code>和连续的<code>pop</code>可以只在其中一个栈中操作，所以可以优化为：</p><ol type="1"><li>需要插入时，直接<code>push</code>到<code>stack1</code>；</li><li>需要弹出时，若<code>stack2</code>不为空，弹出<code>stack2</code>的栈顶元素；若<code>stack2</code>为空，将 <code>stack1</code> 中的全部数逐个出栈入栈 <code>stack2</code>，再弹出 <code>stack2</code> 栈顶元素</li></ol><h3 id="三代码">三、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一问题描述&quot;&gt;一、问题描述&lt;/h3&gt;
&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--4 虚拟机性能监控、故障处理工具</title>
    <link href="https://wuyunjie.top/2021/05/20/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_4_Performance_monitoring_fault_handling.html"/>
    <id>https://wuyunjie.top/2021/05/20/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_4_Performance_monitoring_fault_handling.html</id>
    <published>2021-05-20T14:41:12.000Z</published>
    <updated>2021-05-20T14:41:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code> <a id="more"></a></p></blockquote><h3 id="基础故障处理工具">1. 基础故障处理工具</h3><p>除了编译和运行Java程序外，打包、部署、签名、调试、监控、运维等各种场景都可能会用到<code>JDK</code>的<code>bin</code>目录下的小工具。根据软件可用性和授权的不同，可以把它们划分成三类：</p><ul><li><strong>商业授权工具</strong>：主要是<code>JMC（Java Mission Control）</code>及它要使用到的<code>JFR（Java Flight Recorder）</code>；</li><li><strong>正式支持工具</strong>：这一类工具属于被长期支持的工具，不同平台、不同版本的<code>JDK</code>之间，这类工具可能会略有差异；</li><li><strong>实验性工具</strong>：这一类工具在它们的使用说明中被声明为“<code>没有技术支持，并且是实验性质的</code>”（<code>Unsupported and Experimental</code>）产品。</li></ul><h4 id="jps虚拟机进程状况工具">1.1 <code>jps</code>：虚拟机进程状况工具</h4><p><code>jps（JVM Process Status Tool）</code>功能和<code>UNIX</code>的<code>ps</code>命令类似：</p><blockquote><p>可以列出<code>正在运行</code>的虚拟机进程，并显示虚拟机<u><strong>执行主类（Main Class，main()函数所在的类）</strong></u>名称以及这些进程的<code>本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）</code>。</p></blockquote><p><code>jps</code>命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/jps.PNG" alt="jps参数" /><figcaption aria-hidden="true">jps参数</figcaption></figure><h4 id="jstat虚拟机统计信息监视工具">1.2 <code>jstat</code>：虚拟机统计信息监视工具</h4><p><code>jstat（JVM Statistics Monitoring Tool）</code>是用于监视虚拟机各种运行状态信息的命令行工具。</p><blockquote><p>可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据</p></blockquote><h4 id="jinfojava配置信息工具">1.3 <code>jinfo</code>：Java配置信息工具</h4><p><code>jinfo（Configuration Info for Java）</code>的作用是实时查看和调整虚拟机各项参数。</p><blockquote><p>使用<code>jps</code>命令的<code>-v</code>参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用<code>jinfo</code>的<code>-flag</code>选项进行查询了</p></blockquote><h4 id="jmapjava内存映像工具">1.4 <code>jmap</code>：Java内存映像工具</h4><p><code>jmap（Memory Map for Java）</code>命令用于生成<strong>堆转储快照</strong>（一般称为<code>heapdump</code>或<code>dump</code>文件）。</p><blockquote><p>还可以查询<u><code>finalize</code>执行队列</u>、<u>Java堆</u>和<u>方法区的详细信息</u>，如空间使用率、当前用的是哪种收集器等。</p></blockquote><h4 id="jhat虚拟机堆转储快照分析工具">1.5 <code>jhat</code>：虚拟机堆转储快照分析工具</h4><p><code>jhat（JVM Heap Analysis Tool）</code>命令与<code>jmap</code>搭配使用，来分析<code>jmap</code>生成的堆转储快照。</p><h4 id="jstackjava堆栈跟踪工具">1.6 <code>jstack</code>：Java堆栈跟踪工具</h4><p><code>jstack（Stack Trace for Java）</code>命令用于生成虚拟机当前时刻的线程快照（一般称为<code>threaddump</code>或者<code>javacore</code>文件）。</p><blockquote><p>线程快照就是当前虚拟机内每一条线程正在执行的<strong>方法堆栈</strong>的集合，生成线程快照的目的通常是<u>定位线程出现长时间停顿的原因</u>，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。</p></blockquote><h4 id="基础工具总结">1.7 基础工具总结</h4><ul><li><strong>基础工具</strong>：用于支持基本的程序创建和运行</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/basicJavaTools.PNG" alt="基础工具" /><figcaption aria-hidden="true">基础工具</figcaption></figure><ul><li><strong>安全</strong>：用于程序签名、设置安全测试等</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/securityJavaTools.PNG" alt="安全工具" /><figcaption aria-hidden="true">安全工具</figcaption></figure><p>还有许多工具，就不一一列举了，需要的时候在查找学习就行。</p><h3 id="可视化故障处理工具">2. 可视化故障处理工具</h3><p>这类工具主要包括<code>JConsole</code>、 <code>JHSDB</code>、<code>VisualVM</code>和<code>JMC</code>四个。</p><h4 id="jhsdb基于服务性代理的调试工具">2.1 <code>JHSDB</code>：基于服务性代理的调试工具</h4><p><code>JHSDB</code>是一款基于<code>服务性代理（Serviceability Agent，SA）</code>实现的进程外调试工具。服务性代理是<code>HotSpot</code>虚拟机中一组用于映射<code>Java</code>虚拟机运行信息的、主要基于<code>Java</code>语言（含少量<code>JNI</code>代码）实现的<code>API</code>集合。</p><p>通过服务性代理的<code>API</code>，可以在一个独立的Java虚拟机的进程里分析其他<code>HotSpot</code>虚拟机的内部数据，或者从<code>HotSpot</code>虚拟机进程内存中<code>dump</code>出来的转储快照里还原出它的运行状态细节。</p><h4 id="jconsolejava监视与管理控制台">2.2 <code>JConsole</code>：Java监视与管理控制台</h4><p><code>JConsole（Java Monitoring and Management Console）</code>是一款基于<code>JMX（Java Manage-ment Extensions）</code>的可视化监视、管理工具。它的主要功能是通过<code>JMX</code>的<code>MBean（Managed Bean）</code>对系统进行信息收集和参数动态调整。</p><h4 id="visualvm多合-故障处理工具">2.3 <code>VisualVM</code>：多合-故障处理工具</h4><p><code>VisualVM（All-in-One Java Troubleshooting Tool）</code>是功能最强大的运行监视和故障处理程序之一，除了常规的运行监视、故障处理外，还将提供其他方面的能力，譬如<code>性能分析（Profiling）</code>。</p><p><code>VisualVM</code>还有一个很大的<strong>优点</strong>：<u><strong>不需要被监视的程序基于特殊<code>Agent</code>去运行</strong></u>，因此它的通用性很强，对应用程序实际性能的影响也较小，使得它可以直接应用在生产环境中。</p><h4 id="java-mission-control可持续在线的监控工具">2.4 <code>Java Mission Control</code>：可持续在线的监控工具</h4><p><code>JMC</code>最初是<code>BEA</code>公司的产品，选择了由<code>IBM</code>捐赠的<code>Eclipse RCP</code>作为基础框架，更常见的是作为Eclipse的插件来使用。</p><p><code>JMC</code>与虚拟机之间同样采取<code>JMX</code>协议进行通信，<code>JMC</code>一方面作为<code>JMX</code>控制台，显示来自虚拟机<code>MBean</code>提供的数据；另一方面作为<code>JFR</code>的分析工具，展示来自<code>JFR</code>的数据。</p><h3 id="hotspot虚拟机插件及工具">3. <code>HotSpot</code>虚拟机插件及工具</h3><p><code>HotSpot</code>的插件及工具存放在HotSpot源码<code>hotspot/src/share/tools</code>目录下，包括：</p><ul><li><code>Ideal Graph Visualizer</code>：用于可视化展示<code>C2</code>即时编译器是如何将字节码转化为理想图，然后转化为机器码的。</li><li><code>Client Compiler Visualizer</code>：用于查看<code>C1</code>即时编译器生成高级中间表示（<code>HIR</code>），转换成低级中间表示（<code>LIR</code>）和做物理寄存器分配的过程。</li><li><code>MakeDeps</code>：帮助处理<code>HotSpot</code>的编译依赖的工具。</li><li><code>Project Creator</code>：帮忙生成<code>Visual Studio</code>的<code>.project</code>文件的工具。</li><li><code>LogCompilation</code>：将<code>-XX：+LogCompilation</code>输出的日志整理成更容易阅读的格式的工具。</li><li><code>HSDIS</code>：即时编译器的反汇编插件。</li></ul><p><strong><code>HSDIS</code>：<code>JIT</code>生成代码反汇编</strong></p><p><code>HSDIS</code>是一个被官方推荐的<code>HotSpot</code>虚拟机即时编译代码的反汇编插件。<code>HSDIS</code>插件的作用是让<code>HotSpot</code>的<code>-XX：+PrintAssembly</code>指令调用它来把即时编译器动态生成的本地代码还原为<u>汇编代码</u>输出，同时还会自动产生大量非常有价值的注释，这样我们就可以通过输出的汇编代码来从最本质的角度分析问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。&lt;/code&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--十大遗珠之憾</title>
    <link href="https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html"/>
    <id>https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html</id>
    <published>2021-05-20T05:13:54.000Z</published>
    <updated>2021-05-20T05:13:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>什么！有完没完啊？这本书到底还要看多久？ <a id="more"></a></p></blockquote><h3 id="枚举又称为枚举类型或enum">1. 枚举(又称为枚举类型或<code>Enum</code>)</h3><p>枚举类型定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Members &#123; JERRY, BOBBY, PHIL &#125;;</span><br><span class="line"><span class="keyword">public</span> Members selectedBandMember;</span><br><span class="line"></span><br><span class="line"><span class="comment">// later in the code</span></span><br><span class="line"><span class="keyword">if</span> (selectedBandMember == Members.JERRY) &#123;</span><br><span class="line"><span class="comment">// do JERRY related stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在<code>enum</code>中加入构造函数、方法、变量和特定常量的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HfjEnum</span> </span>&#123;</span><br><span class="line"><span class="keyword">enum</span> Names &#123;</span><br><span class="line">        <span class="comment">// 传给下方定义构造函数的参数</span></span><br><span class="line">JERRY(“lead guitar”) &#123; <span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “plaintively”; &#125;&#125;,</span><br><span class="line">BOBBY(“rhythm guitar”) &#123; <span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “hoarsely”; &#125;&#125;,</span><br><span class="line">PHIL(“bass”);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String instrument;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// enum的构造函数，会对每个被声明的enum值执行一次</span></span><br><span class="line">        Names(String instrument) &#123;</span><br><span class="line">            <span class="keyword">this</span>.instrument = instrument;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInstrument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.instrument;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> “occasionally”;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Names n : Names.values()) &#123;</span><br><span class="line">            System.out.print(n);</span><br><span class="line">            System.out.print(“, instrument: “+ n.getInstrument());</span><br><span class="line">            System.out.println(“, sings: “ + n.sings());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组">2. 多维数组</h3><p>Java中，二维数组实际上是一个<strong><code>数组的数组</code></strong>。</p><h3 id="string-and-stringbufferstringbuilder-methods">3. <code>String</code> and <code>StringBuffer/StringBuilder</code> Methods</h3><p><code>Java 5.0</code>起，应该用<code>StringBuilder</code>取代<code>StringBuffer</code>。<code>StringBuffer/StringBuilder</code> 来操作字符串更有效率。</p><h3 id="存取权限和存取修饰符">4. 存取权限和存取修饰符</h3><p><code>Java</code>有4种存取权限等级与3种存取修饰符。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/AccessLevelsModifiers.PNG" alt="存取权限和存取修饰符" /><figcaption aria-hidden="true">存取权限和存取修饰符</figcaption></figure><h3 id="anonymous和static-nested-classes">5. <code>Anonymous</code>和<code>Static Nested Classes</code></h3><p><code>静态嵌套类</code>可以不需要外部类的实例就调用，但还是被看作外部类的一个成员，能够存取任何外部类的静态成员(包括私有)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooOuter</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarInner</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“method of a <span class="keyword">static</span> inner <span class="class"><span class="keyword">class</span>”)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FooOuter.BarInner foo = <span class="keyword">new</span> FooOuter.BarInner();</span><br><span class="line">        foo.sayIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>匿名的内部类</code>，是在需要传入一个实例的地方创建一个类，并把整个类作为参数传进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnon</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line">JButton button = <span class="keyword">new</span> JButton(“click”);</span><br><span class="line">frame.getContentPane().add(button);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// button.addActionListener(quitListener);</span></span><br><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent ev)</span> </span>&#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接的调用">6. 连接的调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"spring"</span>);</span><br><span class="line">sb = sb.delete(<span class="number">3</span>,<span class="number">6</span>).insert(<span class="number">2</span>,<span class="string">"umme"</span>).deleteCharAt(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>第二行程序从左到右执行。如下调用方法可以调用方法又不需要维护一个引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo().go();</span><br></pre></td></tr></table></figure><h3 id="块区域">7. 块区域</h3><p>区段程序代码通常在方法中，以<code>{}</code>字符来区分。在某个块区域中声明的变量，一旦离开块区域，就超出范围，无法再被使用。</p><h3 id="断言">8. 断言</h3><p>断言的使用类似<code>println()</code>，执行时未特别设定，被加入到程序中的<code>assert</code>命令会被Java虚拟机忽略。只有打开断言，才会输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> (height &gt; <span class="number">0</span>); </span><br><span class="line"><span class="comment">// if true, program continues normally</span></span><br><span class="line"><span class="comment">// if false, throw an AssertionError</span></span><br></pre></td></tr></table></figure><p>也可以加入信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> (height &gt; <span class="number">0</span>) : <span class="string">"height = "</span> + height + <span class="string">" weight = "</span> + weight;</span><br></pre></td></tr></table></figure><h3 id="不变性">9. 不变性</h3><p><code>String</code>的不变性，主要为了安全性和节省空间。比如下面的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = “<span class="number">0</span>”;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">     s = s + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上创建了<code>10</code>个<code>String</code>对象("0", "01", ..., "0123456789")。创建新<code>String</code>时，<code>JVM</code>会把它放在<code>"String Pool"</code>的特殊存储区域，如果已经出现同值的<code>String</code>，JVM不会重复建立<code>String</code>，会引用已经存在的内容。因为<code>String</code>是不变的，引用变量无法改变其他参数变量引用到的同一个<code>String</code>值。</p><p><code>包装类</code>也具有不变性。</p><h3 id="位操作">10. 位操作</h3><ul><li>按位非运算：<code>~</code></li><li>按位与运算：<code>&amp;</code></li><li>按位或运算：<code>|</code></li><li>按位异或运算：<code>^</code></li><li>右移运算：<code>&gt;&gt;</code></li><li>无符号右移：<code>&gt;&gt;&gt;</code>。第一位补<code>0</code>，正负号可能改变。</li><li>左移运算符：<code>&lt;&lt;</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;什么！有完没完啊？这本书到底还要看多久？
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--18 远程部署的RMI</title>
    <link href="https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_18_remote%20deployment_with_RMI.html"/>
    <id>https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_18_remote deployment_with_RMI.html</id>
    <published>2021-05-20T02:44:05.000Z</published>
    <updated>2021-05-20T02:44:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>分布式计算，距离不是问题。 <a id="more"></a></p></blockquote><h3 id="远程过程调用的设计">1. 远程过程调用的设计</h3><p>远程过程调用(<code>Remote Method Invocation, RMI</code>)要建出4种东西：<code>服务器</code>、<code>客户端</code>、<code>服务器辅助设施</code>和<code>客户端辅助设施</code>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/remoteMethod.PNG" alt="远程过程调用的设计" /><figcaption aria-hidden="true">远程过程调用的设计</figcaption></figure><h4 id="辅助设施的任务">1.1 <code>辅助设施</code>的任务</h4><p>辅助设施是个在实际上执行通信的对象，会让客户端对象看起来在调用远程的方法。辅助设施会去连接服务器，将调用的信息传送过去，然后等待服务器的响应。</p><p>服务器的辅助设施会接受客户端辅助设施打包的信息，调用真正的服务，然后取得返回值送回客户端辅助设施。</p><h4 id="创建远程服务">1.2 创建远程服务</h4><p>创建远程服务有5个步骤：</p><ol type="1"><li><p>创建<code>Remote</code>接口。远程接口定义了客户端可以远程调用的方法，是一个作为服务的多态化类。stub和服务都会实现此接口。</p><ul><li><p>继承<code>java.rmi.Remote</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRemote</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明所有方法都会抛出<code>RemoteException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRemote</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确定参数和返回值都是<code>primitive主数据类型</code>或<code>Serializable</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>实现<code>Remote</code>。真正执行的类，实现定义在该接口上的方法。</p><ul><li><p>实现<code>Remote</code>接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRemoteImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">MyRemote</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “Server says, ‘Hey’”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// more code in class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承<code>UnicastRemoteObject</code>。对象必须要有远程相关功能，最简单的方式就是继承<code>UnicastRemoteObject</code>类来处理。</p></li><li><p>编写声明<code>RemoteException</code>的无参数构造函数；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyRemoteImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>向<code>RMI registry</code> 注册服务。将服务初始化并加入<code>RMI registry</code> ，<code>RMI</code>系统会把<code>stub</code>加到<code>registry</code>中。使用<code>java.rmi.Naming</code>的<code>rebind</code>方法来注册服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    MyRemote service = <span class="keyword">new</span> MyRemoteImpl();</span><br><span class="line">    <span class="comment">// 帮助服务命名，并向RMI registry注册</span></span><br><span class="line">    Naming.rebind(“Remote Hello”, service);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用<code>rmic</code>产生<code>stub</code>与<code>skeleton</code>。由<code>JDK</code>附带的<code>rmic</code>工具自动处理。</p><ul><li><p>对实现出的类执行<code>rmic</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmic MyRemoteImpl</span><br></pre></td></tr></table></figure><p><code>Java software development kit(JDK)</code>中的<code>rmic</code>工具会以服务的实现产生连个新类：<code>stub</code>和<code>skeleton</code>。</p></li></ul></li><li><p>启动<code>RMI registry</code> (<code>rmiregistry</code>)。用户从此处获取代理。</p><ul><li><p>在命令行启动<code>rmiregistry</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmiregistry</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动远程服务。实现服务的类会启动服务的实例并向<code>RMI registry</code> 注册，要有注册才能对用户提供服务。</p><ul><li><p>启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java MyRemoteImpl</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="客户端获取stub">1.3 客户端获取<code>stub</code></h4><p>客户端需要获取<code>stub</code>对象，这需要<code>RMI registry</code>，客户端从上面查询得到有相符名称的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyRemote service = (MyRemote) Naming.lookup(<span class="string">"rmi://127.0.0.1/Remote Hello"</span>);</span><br></pre></td></tr></table></figure><ul><li><p>客户端查询<code>RMI registry</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Naming.lookup(<span class="string">"rmi://127.0.0.1/Remote Hello"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>RMI registry</code>返回<code>stub</code>对象，<code>RMI</code>会自动将<code>stub</code>解序列化。</p></li><li><p>客户端可以调用<code>stub</code>上的方法</p></li></ul><h3 id="servlets">2. Servlets</h3><p><code>Servlets</code>是放在<code>Http Web</code>服务上面运行的Java程序，用户通过浏览器与网页交互时，如果请求需要Java的<code>Servlets</code>时，服务器会执行或调用已经执行的<code>Servlets</code>程序代码。</p><blockquote><p><code>Servlets</code>只运行在服务器上。</p></blockquote><ul><li>用户在网页上填写表格并提交，<code>HTTP</code>服务器受到请求，判断需要<code>Servlets</code>就传送该请求</li><li><code>Servlets</code>开始执行，把数据存入数据库，然后返回内容给浏览器。</li></ul><p>创建并执行<code>Servlets</code>的步骤：</p><ol type="1"><li><p>找出可以存放<code>Servlets</code>的地方</p></li><li><p>取得<code>Servlets.jar</code>并添加到<code>classpath</code>上。<code>Servlets</code>不是标准库的一部分，需要单独下载。</p></li><li><p>通过继承<code>HttpServlet</code>来编写<code>Servlet</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletA</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>编写<code>HTML</code>来调用<code>Servlet</code></p></li><li><p>给服务器设定HTML网页和<code>Servlet</code></p></li></ol><h3 id="enterprise-javabeans">3. Enterprise JavaBeans</h3><p><code>Enterprise JavaBeans(EJB)</code>服务器作用与<code>RMI</code>调用和服务层之间，支持交易管理、安全性、并发性、数据库和网络功能等。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/EJB.PNG" alt="EJB架构的一部分" /><figcaption aria-hidden="true">EJB架构的一部分</figcaption></figure><h3 id="jini">4. Jini</h3><p><code>Jini</code>也是使用<code>RMI</code>，但有几个关键功能：</p><ol type="1"><li>自适应探索(<code>Adaptive discovery</code>)</li><li>自恢复网络(<code>Self-healing networks</code>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;分布式计算，距离不是问题。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--17 包、jar存档文件和部署</title>
    <link href="https://wuyunjie.top/2021/05/19/JavaLearning_Head_First_Java_17_package_jars_and_deployment.html"/>
    <id>https://wuyunjie.top/2021/05/19/JavaLearning_Head_First_Java_17_package_jars_and_deployment.html</id>
    <published>2021-05-19T15:21:49.000Z</published>
    <updated>2021-05-19T15:21:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>该放手了。 <a id="more"></a></p></blockquote><h3 id="部署应用程序">1. 部署应用程序</h3><p>可以有多种部署选择：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/DeploymentOptions.PNG" alt="部署选择" /><figcaption aria-hidden="true">部署选择</figcaption></figure><p>首先需要将源代码与<code>class</code>文件分离，关键在于结合<code>-d</code>这个编译选项和目录组织的结构。</p><blockquote><p>将源代码(<code>.java</code>)存储在<code>source</code>目录下，将编译输出的类文件(<code>.class</code>)放入<code>classes</code>目录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/<span class="built_in">source</span></span><br><span class="line">javac -d ../classes MyApp.java</span><br></pre></td></tr></table></figure><h4 id="把程序打包为jar">1.1 把程序打包为JAR</h4><p><code>JAR</code>即<code>Java ARchive</code>，这种文件是<code>pkzip</code>格式的文件，能把一组类文件包装起来。创建可执行的<code>JAR</code>分为以下步骤：</p><ol type="1"><li><p>确定所有的类文件都在<code>classes</code>目录下；</p></li><li><p>创建<code>manifest.txt</code>文件描述哪个类带有<code>main()</code>方法，该文件带有下面一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Main-Class: MyApp</span><br></pre></td></tr></table></figure><p>此行后面要有换行，该文件放入<code>classes</code>目录</p></li><li><p>执行<code>jar</code>工具来创建带有<strong>所有类</strong>以及<code>manifest</code>的<code>JAR</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/classes </span><br><span class="line">jar -cvmf manifest.txt app1.jar *.class</span><br><span class="line">OR</span><br><span class="line">jar -cvmf manifest.txt app1.jar MyApp.class</span><br></pre></td></tr></table></figure></li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/makingJAR.PNG" alt="创建JAR" /><figcaption aria-hidden="true">创建JAR</figcaption></figure><p><code>JVM</code>能从<code>JAR</code>中载入类，并调用该类的<code>main()</code>方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar app1.jar</span><br></pre></td></tr></table></figure><p>可以用包防止类名称的冲突。<code>Sun</code>建议加上所取得的域名(<code>domain</code>)名称来保证包名称不会重复。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/domainPackageNames.PNG" alt="使用域名的包名称" /><figcaption aria-hidden="true">使用域名的包名称</figcaption></figure><p>需要把类放在与包层次结构相对应的目录结构下：</p><ol type="1"><li><p>选择包名称。</p></li><li><p>在类中加入包指令。这必须是程序源码的第一个语句，在<code>import</code>之上。每个源文件中只能有一个包指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.headfirstjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageExercise</span> </span>&#123;</span><br><span class="line">     <span class="comment">// life-altering code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设定相对应的目录结构。按照包层次结构来放置类文件</p></li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/packageHierarchy.PNG" alt="包层次结构" /><figcaption aria-hidden="true">包层次结构</figcaption></figure><ol start="4" type="1"><li><p>编译和执行<code>JAR</code></p><ul><li><p>加上<code>-d</code>选项来编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">%编译器把输出放到class目录下正确的位置</span><br><span class="line">javac -d ../classes com/headfirstjava/PackageExercise.java</span><br><span class="line"></span><br><span class="line">%编译com.headfirstjava包下所有.java文件</span><br><span class="line">javac -d ../classes com/headfirstjava/*.java</span><br></pre></td></tr></table></figure></li><li><p>执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/classes</span><br><span class="line">java com.headfirstjava.PackageExercise</span><br></pre></td></tr></table></figure><p>一旦类被包进包中后，就不能使用“简写”名称来调用它，必须在命令栏指定要执行<code>main()</code>的类完整名称。</p></li></ul></li></ol><p>还可以条列和解压<code>JAR</code>包：</p><ul><li><p>将<code>JAR</code>内容列出，<code>-tf</code>代表<code>Table File</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -tf packEx.jar</span><br></pre></td></tr></table></figure></li><li><p>解压<code>JAR</code>内容，<code>-xf</code>代表<code>eXtract File</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Skyler</span><br><span class="line">jar -xf packEx.jar</span><br></pre></td></tr></table></figure></li></ul><h4 id="java-web-start">1.2 Java Web Start</h4><p><code>Java Web Start(JWS)</code>可以让用户从浏览器上执行首次启动，一旦程序下载后就可以独立于浏览器执行。</p><ul><li><code>JWS</code>下载程序时会调用程序的<code>main()</code>，然后用户可以通过<code>JWS helper app</code>启动应用程序而无需回到网页</li><li><code>JWS</code>能偶检测服务器上应用程序局部更新，自动下载和整合更新过的程序</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JWS.PNG" alt="Java Web Start工作方式" /><figcaption aria-hidden="true">Java Web Start工作方式</figcaption></figure><p><code>.jnlp</code>(<code>Java  Network Launch Protocol</code>)文件用于创建JWS应用程序，<code>JWS</code>会读取文件来寻找<code>JAR</code>并启动应用程序，<code>.jnlp</code>是个简单的<code>XML</code>文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;该放手了。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--16 集合与泛型</title>
    <link href="https://wuyunjie.top/2021/05/19/JavaLearning_Head_First_Java_16_collections_and_generics.html"/>
    <id>https://wuyunjie.top/2021/05/19/JavaLearning_Head_First_Java_16_collections_and_generics.html</id>
    <published>2021-05-19T04:55:36.000Z</published>
    <updated>2021-05-19T04:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>排序在Java中只是雕虫小技。 <a id="more"></a></p></blockquote><h3 id="集合">1. 集合</h3><p><code>ArrayList</code>是最常用的集合，此外还有一些较为重要的集合：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/collector.PNG" alt="一些集合类" /><figcaption aria-hidden="true">一些集合类</figcaption></figure><p>可以使用<code>TreeSet</code>或<code>Collections.sort()</code>方法对集合元素排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(songList);</span><br></pre></td></tr></table></figure><p>若将<code>ArrayList</code>声明为自定义类(如<code>Song</code>)的数组，使用<code>Collections.sort()</code>将无法通过编译。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/sortMethod.PNG" alt="sort方法定义" /><figcaption aria-hidden="true">sort方法定义</figcaption></figure><blockquote><p><code>sort()</code>方法取只能接受<code>Comparable</code>对象的<code>list</code>。</p></blockquote><h4 id="collections接口">1.1 Collections接口</h4><p><code>Collections</code>主要有<code>3</code>个接口：<code>List</code>，<code>Set</code>和<code>Map</code>。</p><ul><li><code>List</code>是一种知道索引位置的集合，可以存在重复元素。</li><li><code>Set</code>知道某物是否存在于集合中，它不允许重复。</li><li><code>Map</code>使用成对的键值(<code>key</code>)和数据值(<code>value</code>)，<code>key</code>可以引用相同的对象，但<code>key</code>自身不能重复。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/collectorTree.PNG" alt="Collection API" /><figcaption aria-hidden="true">Collection API</figcaption></figure><h4 id="对象等价">1.2 对象等价</h4><ul><li><code>引用相等性</code>。堆上同一对象的两个引用，引用对堆上同一个对象的两个引用时相等的。如果这两个引用调用<code>hashCode</code>，会得到相同的结果。使用<code>==</code>来比较变量上的子节组合，判断引用是否相等。</li><li><code>对象相等性</code>。堆上的两个不同对象在意义上是相同的，要把两个不同的对象视为相等，需要覆盖<code>hashCode</code>方法与<code>equals</code>方法。</li></ul><blockquote><p>要让<code>set</code>把对象视为重复的，必须满足<code>equals</code>和<code>hashCode</code>返回两对象相等。</p></blockquote><p><code>equals</code>和<code>hashCode</code>的相关规定：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/hashCodeEquals.PNG" alt="equals和hashCode" /><figcaption aria-hidden="true"><code>equals</code>和<code>hashCode</code></figcaption></figure><h4 id="treeset">1.3 TreeSet</h4><p>使用<code>TreeSet</code>必须使得以下一项为真：</p><ul><li><p>集合中的元素必须是有实现<code>Comparable</code>的类型；</p></li><li><p>使用重载、取用<code>Comparator</code>参数的构造函数创建<code>TreeSet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BookCompare bCompare = <span class="keyword">new</span> BookCompare();</span><br><span class="line">TreeSet&lt;Book&gt; tree = <span class="keyword">new</span> TreeSet&lt;Book&gt;(bCompare);</span><br></pre></td></tr></table></figure></li></ul><h4 id="map">1.4 Map</h4><p><code>Map</code>的元素实际上是两个对象：关键词(key)和值(value)。值可以重复，但key不能重复。通过<code>Map</code>可以用名称来取值等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; scores = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">scores.put(“Kathy”, <span class="number">42</span>);</span><br><span class="line">scores.put(“Bert”, <span class="number">343</span>);</span><br><span class="line">scores.put(“Skyler”, <span class="number">420</span>);</span><br></pre></td></tr></table></figure><h3 id="泛型">2. 泛型</h3><p><code>&lt;&gt;</code>符号代表<code>泛型(generic)</code>正在起作用，它是从<code>Java 5.0</code>开始加入的特质。泛型的主要目的是能够获取有<u>更好的类型安全性的集合</u>。</p><blockquote><p>在泛型出现前，没有办法什么<code>ArrayList</code>的类型，所以只能用<code>Object</code>来操作。各种对象以引用的形式加入到<code>ArrayList</code>中，出来时会是<code>Object</code>类型的引用。</p></blockquote><p>使用泛型后，能定义<code>ArrayList</code>类型，在取出时还是该类型的引用。此外也不能在该<code>ArrayList</code>中加入非该类的对象。关于泛型几件重要的事：</p><ol type="1"><li><p>创建被泛型化类的实例。比如创建<code>ArrayList</code>时必须指定它所容许的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ArrayList&lt;Song&gt;()</span><br></pre></td></tr></table></figure></li><li><p>声明与指定泛型类型的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Song&gt; songList = <span class="keyword">new</span> ArrayList&lt;Song&gt;()</span><br></pre></td></tr></table></figure></li><li><p>声明(与调用)取用泛型类型的方法。</p></li></ol><h4 id="泛型的类">2.1 泛型的类</h4><p>查看泛型化类型，有两个关键的部分：</p><ol type="1"><li>类的声明。</li><li>新增元素的方法的声明。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; ... </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>E</code>部分会用所声明和创建的真正类型来取代，<code>E</code>代指<code>Element</code>。在新增元素的方法中，也用<code>E</code>指示可以加入<code>ArrayList</code>的元素类型。</li><li>这里<code>E</code>并不是关键词，硬性规定的。也可以用其他合法字符串来当作类型参数。习惯用法是以单一字母表示。</li></ul></blockquote><h4 id="泛型的方法">2.2 泛型的方法</h4><p>泛型的类代表类的声明用到类型参数。泛型的方法代表方法的声明特征用到类型参数。</p><ol type="1"><li><p>使用定义在类声明的类型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; ... </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>声明类的类型参数后，就可以直接把该类或接口类型用在任何地方。</p></li><li><p>使用未定义在类声明的类型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure><p>如果类本身未使用类型参数，可以通过在返回类型之前指定给该方法。<code>&lt;T extends Animal&gt;</code>意味着<code>T</code>可以是任意一种<code>Animal</code>。</p></li></ol><p>这里需要注意的是，以下两种方法的声明合法，但意义不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;Animal&gt; list)</span></span></span><br></pre></td></tr></table></figure><p><code>&lt;T extends Animal&gt;</code>是方法声明的一部分，表示任何被声明未<code>Animal</code>或<code>Animal</code>的子类型的<code>ArrayList</code>是合法的。可以使用<strong>任意一种</strong><code>Animal</code>的<code>ArrayList</code>。</p><p>但下面的方法中<code>ArrayList&lt;Animal&gt; list</code>代表只有<code>ArrayList&lt;Animal&gt;</code>是合法的，也就是它<strong>只能使用</strong><code>Animal</code>的<code>ArrayList</code>。</p><h4 id="sort方法中的泛型">2.3 <code>sort()</code>方法中的泛型</h4><p>回到<code>sort()</code>方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure><p>实际上<code>Comparable</code>是一个接口，但以泛型的观点，<code>extends</code>代表<code>extends</code>或<code>implement</code>。所以必须实现<code>Comparable</code>才能把类的<code>ArrayList</code>传给<code>sort</code>。只有一个方法需要实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compareTo</code>方法会判别在排序位置上某个对象是高于、低于或等于另一个对象。<code>sort()</code>有重载方法，可以取用称为<code>Comparator</code>的参数。<code>Comparator</code>是独立的类，因此可以实现不同的比较方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用规则如下：</p><ul><li>调用单一参数的<code>sort(List o)</code>方法代表由<code>List</code>元素上的<code>compareTo</code>方法来决定顺序，需要实现<code>Comparable</code>接口。</li><li>调用<code>sort(List o, Comparator c)</code>方法代表不会调用<code>list</code>元素的<code>compareTo</code>方法，而会使用<code>Comparator</code>的<code>compare</code>方法，这种情况下list元素不需要实现<code>Comparable</code>接口。</li></ul><h4 id="多态与泛型">2.4 多态与泛型</h4><p>在普通的多态中，定义如下函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(Animal a: animals) &#123;</span><br><span class="line">         a.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法只能取用<code>ArrayList&lt;Animal&gt;</code>参数，而不能传入<code>ArrayList&lt;Dog&gt;</code>或<code>ArrayList&lt;Cat&gt;</code>，以为如果程序执行如下代码时，会出现类型错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">animals.add(<span class="keyword">new</span> Cat());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数换成数组时尽管能通过编译，但在执行时也会出错。</p><blockquote><p>数组的类型在运行期间检查，集合的类型检查只发生在编译期间。</p></blockquote><p>可以使用泛型的<code>万用字符(wildcard)</code>来解决这个问题。创建出可以接受<code>Animal</code>子类型参数的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;? extends Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(Animal a: animals) &#123;</span><br><span class="line">     a.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用带有<code>&lt;?&gt;</code>的声明时，编译器会组织任何可能破坏引用参数所指集合的行为。</p><ul><li>可以调用<code>list</code>中任何元素的方法，但不能加入元素。即可以操作集合元素，但不能新增集合元素，以保证安全性。</li></ul><p>两种不同的语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;? extends Animal&gt; list)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;排序在Java中只是雕虫小技。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--15 网络与线程</title>
    <link href="https://wuyunjie.top/2021/05/18/JavaLearning_Head_First_Java_15_networking_and_threads.html"/>
    <id>https://wuyunjie.top/2021/05/18/JavaLearning_Head_First_Java_15_networking_and_threads.html</id>
    <published>2021-05-18T10:46:26.000Z</published>
    <updated>2021-05-18T10:46:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>连接到外面的世界。 <a id="more"></a></p></blockquote><h3 id="客户端client与服务器server">1. 客户端(Client)与服务器(Server)</h3><p>客户端必须要认识服务器，服务器必须要认识所有的客户端。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientAndServer.PNG" alt="客户端与服务器" /><figcaption aria-hidden="true">客户端与服务器</figcaption></figure><p>工作方式如下：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientAndServerWorks.PNG" alt="客户端与服务器工作方式" /><figcaption aria-hidden="true">客户端与服务器工作方式</figcaption></figure><p>连接、传送与接受：</p><p>客户端要连接服务器需要做三件事：</p><ol type="1"><li>建立客户端与服务器之间的初始连接</li><li>传送信息到服务器</li><li>接受来自服务器的信息</li></ol><p>Java API的网络功能包(<code>java.net</code>)对底层工作细节进行了封装。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientConnectServer.PNG" alt="客户端" /><figcaption aria-hidden="true">客户端</figcaption></figure><h4 id="socket连接">1.1 Socket连接</h4><p>连接到其他机器需要<code>Socket连接</code>，<code>Socket</code>是代表两台机器间网络连接的对象(<code>java.net.Socket</code>)。创建Socket连接需要两项关于<strong>服务器</strong>的信息：<code>IP地址</code>和<code>端口号</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"196.164.1.103"</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>Socket连接的建立代表两台机器间有对方的信息(包括<code>IP地址</code>和<code>端口号</code>)</p><p><code>TCP</code>端口是一个<code>16</code>位宽、用来识别服务器上特定程序的数字。一个地址可以有<code>65536</code>个不同的端口号可用。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/wellKnownTCPPort.PNG" alt="常用的TCP端口号" /><figcaption aria-hidden="true">常用的TCP端口号</figcaption></figure><blockquote><p><code>0~1023</code>的<code>TCP</code>端口号预留给已知特定服务使用，可以从<code>1024~65535</code>中选择端口号用于自定义程序</p></blockquote><p>不同程序不能共享一个端口，使用(也叫绑定)某个已被占用的端口，会受到<code>BindException</code>异常。</p><h4 id="读取socket数据">1.2 读取Socket数据</h4><p>可以用串流来通过Socket连接沟通，即使用<code>BufferedReader</code>从<code>Socket</code>上读取数据，而不管串流来自文件还是Socket。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 建立对服务器的Socket连接</span></span><br><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立连接到Socket上低层输入串流的InputStreamReader</span></span><br><span class="line">InputStreamReader stream = <span class="keyword">new</span> InputStreamReader(chatSocket.getInputStream());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 建立BufferedReader来读取</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(stream);</span><br><span class="line">String message = reader.readLine();</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/readFromSocket.PNG" alt="读取Socket数据" /><figcaption aria-hidden="true">读取Socket数据</figcaption></figure><h4 id="向socket写入数据">1.3 向Socket写入数据</h4><p>利用<code>PrintWriter</code>向Socket写入数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 对服务器建立Socket连接</span></span><br><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立连接到Socket的PrintWriter</span></span><br><span class="line">PrintWriter writer = <span class="keyword">new</span> PrintWriter(chatSocket.getOutputStream());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 写入数据</span></span><br><span class="line">writer.println(<span class="string">"message to send"</span>);</span><br><span class="line">writer.print(<span class="string">"another message"</span>);</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/PrintWriterToSocket.PNG" alt="向Socket写入数据" /><figcaption aria-hidden="true">向Socket写入数据</figcaption></figure><h4 id="客户端">1.4 客户端</h4><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/client.PNG" alt="客户端" /><figcaption aria-hidden="true">客户端</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyAdviceClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket s = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">4242</span>);</span><br><span class="line">            InputStreamReader streamReader = <span class="keyword">new</span> InputStreamReader(s.getInputStream());</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(streamReader);</span><br><span class="line">            String advice = reader.readLine();</span><br><span class="line">            System.out.println(<span class="string">"Today you should: "</span> + advice);</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DailyAdviceClient client = <span class="keyword">new</span> DailyAdviceClient();</span><br><span class="line">        client.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务器">1.5 服务器</h4><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/server.PNG" alt="客户端" /><figcaption aria-hidden="true">客户端</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyAdviceServer</span> </span>&#123;</span><br><span class="line">    String[] adviceList = &#123;<span class="string">"Take smaller bites"</span>, <span class="string">"Go for the tight jeans. No they do NOT make you look fat."</span>, <span class="string">"One word: inappropriate"</span>, <span class="string">"Just for today, be honest. Tell your boss what you *really* think"</span>, <span class="string">"You might want to rethink that haircut."</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSock = <span class="keyword">new</span> ServerSocket(<span class="number">4242</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket sock = serverSock.accept();</span><br><span class="line"></span><br><span class="line">                PrintWriter writer = <span class="keyword">new</span> PrintWriter(sock.getOutputStream());</span><br><span class="line">                String advice = getAdvice();</span><br><span class="line">                writer.println(advice);</span><br><span class="line">                writer.close();</span><br><span class="line">                System.out.println(advice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// close go</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> random = (<span class="keyword">int</span>) (Math.random() * adviceList.length);</span><br><span class="line">        <span class="keyword">return</span> adviceList[random];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DailyAdviceServer server = <span class="keyword">new</span> DailyAdviceServer();</span><br><span class="line">        server.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程">2. 线程</h3><p>每个线程有独立的<code>执行空间(stack)</code>。Java内置有<code>多线程(Multithreading)</code>功能，但只有一种<code>Thread</code>类。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/javaThread.PNG" alt="Thread类" /><figcaption aria-hidden="true">Thread类</figcaption></figure><h4 id="新建线程">2.1 新建线程</h4><p>每个Java应用程序会启动一个主线程，将<code>main()</code>函数放在执行空间最开始处。Java虚拟机负责主线程的启动。自定义建立的线程，需要在程序中启动。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JVMThread.PNG" alt="主线程与自建线程" /><figcaption aria-hidden="true">主线程与自建线程</figcaption></figure><p>启动新线程主要有以下几个步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 建立Runnable对象(线程的任务)，此类是对线程要执行的任务的定义</span></span><br><span class="line">Runnable threadJob = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立Thread对象(执行工人)并赋值Runnable对象</span></span><br><span class="line"><span class="comment">// 告诉Thread对象把Runnable的run()方法放到执行空间执行</span></span><br><span class="line">Thread myThread = <span class="keyword">new</span> Thread(threadJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 启动线程Thread</span></span><br><span class="line"><span class="comment">// 真正到执行空间执行run()方法</span></span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure><blockquote><p><code>Thread</code>是个工人，<code>Runnable</code>是这个工人的工作。</p></blockquote><p><code>Runnable</code>是一个<strong>接口</strong>，只有<code>run()</code>这一个方法。<code>Runnable</code>带有会放在执行空间的第一项方法：<code>run()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// code that will be run by the new thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程的状态">2.2 线程的状态</h4><p>新建线程的3个状态：</p><ol type="1"><li><p>等待启动(新建线程)。Thread实例已经创建，但还未启动。即未处于执行中的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br></pre></td></tr></table></figure></li><li><p>可执行线程。启动线程时，变成可执行状态，已经布置好了执行空间，轮到它就可以执行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.start();</span><br></pre></td></tr></table></figure></li><li><p>执行中线程。线程占用资源开始执行，该过程只能依靠JVM的线程调度机制来决定。</p></li></ol><blockquote><p>一旦线程进入可执行状态，会不断在可执行与执行中两种状态切换。也可有另一种状态：暂时不可执行(<code>阻塞状态</code>)</p></blockquote><ul><li>典型的可执行/执行中循环。即JVM线程调度器会把不断切换线程，给予不同线程执行机会。</li><li>暂时被阻挡。<code>调度器(scheduler)</code>会在特殊情况下把线程阻塞，比如线程执行到等待<code>Socket</code>输入流的程序段，但又无数据可读，调度器会把线程移出可执行状态。或者<code>Sleep()</code>函数、调用某个被<code>锁住(locked)</code>的对象等等。</li></ul><h4 id="线程调度器">2.3 线程调度器</h4><p><code>线程调度器(Thread Scheduler)</code>会<u>决定哪个线程从等待状态中被挑出来运行，以及何时把哪个线程送回等待被执行的状态</u>。</p><blockquote><p>调度是无法被控制的</p></blockquote><p>可以通过<code>sleep</code>强制要求线程睡眠，暂时不被唤醒。但调度器是不可预测的，线程之间可能有多个不同的执行顺序，每次执行可能得到不同的结果。</p><blockquote><p>Thread对象不能重复使用，一旦线程的run()方法完成后，线程就不能再重新启动。</p></blockquote><h4 id="sleep">2.4 <code>sleep()</code></h4><p>确保线程有机会执行，可以让它们周期性地进入<code>睡眠</code>状态。当线程醒来时，会进入可执行状态等待被调度器调度执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p><code>sleep</code>方法可能会抛出<code>InterruptedException</code>异常，所以对它的调用需要放在<code>try/catch</code>块中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">     ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="建立与启动多个线程">2.5 建立与启动多个线程</h4><p>可以为线程命名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunThreads</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunThreads runner = <span class="keyword">new</span> RunThreads();</span><br><span class="line">        Thread alpha = <span class="keyword">new</span> Thread(runner);</span><br><span class="line">        Thread beta = <span class="keyword">new</span> Thread(runner);</span><br><span class="line">        alpha.setName(<span class="string">"Alpha thread"</span>);</span><br><span class="line">        beta.setName(<span class="string">"Beta thread"</span>);</span><br><span class="line">        alpha.start();</span><br><span class="line">        beta.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(threadName + <span class="string">" is running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程的并发性问题">2.6 线程的并发性问题</h4><p>线程的<code>并发性(Concurrency)</code>问题会引发<code>竞争状态(race condition)</code>。竞争状态可能会引起数据的损毁。需要对线程间的共享数据增加一道锁，以保证数据的安全。</p><p>要使得具有安全问题的方法<code>原子化</code>，比如对账户操作的方法<code>makeWithdrawal()</code>。确定线程一旦进入这个方法后，就必须能够在其他线程进入之前把任务执行完毕。</p><blockquote><p>使用<code>synchronized</code>关键词来修饰方法使它每次只能被单一线程存取。</p><ul><li><code>synchronized</code>关键词代表线程需要钥匙来存取被<code>同步化(synchronized)</code>过的线程。</li><li>要保护数据，就把作用在数据上的方法同步化</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">makeWithdrawal</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (account.getBalance() &gt;= amount) &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ is about to withdraw”);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             System.out.println(Thread.currentThread().getName() + “ is going to sleep”);</span><br><span class="line">             Thread.sleep(<span class="number">500</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;ex.printStackTrace(); &#125;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ woke up.”);</span><br><span class="line">         account.withdraw(amount);</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ completes the withdrawl”);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(“Sorry, not enough <span class="keyword">for</span> “ + Thread.currentThread().getName());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>锁不是配在方法上的，而是配在对象上的。这意味着对象有两个同步化的方法，就表示两个线程无法进入同一个方法，也表示两个线程无法进入不同的方法。</p></blockquote><p>同步化除了可以保证数据的安全，但同时也存在一些影响或潜在问题：</p><ul><li>同步化方法会带来额外的开销(查询钥匙等)</li><li>同步化方法会强制线程排队，影响并行性</li><li>同步化方法可能会导致死锁</li></ul><p>原则上只做最少量的同步化，可以用<code>synchronized</code>来修饰一行或数行指令而不必同步化整个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     doStuff();</span><br><span class="line">     <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">         criticalStuff();</span><br><span class="line">         moreCriticalStuff();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于静态方法，每个被载入的类也有锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;连接到外面的世界。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--14 序列化和文件的输入/输出</title>
    <link href="https://wuyunjie.top/2021/05/18/JavaLearning_Head_First_Java_14_serialization_and_file_IO.html"/>
    <id>https://wuyunjie.top/2021/05/18/JavaLearning_Head_First_Java_14_serialization_and_file_IO.html</id>
    <published>2021-05-18T07:30:59.000Z</published>
    <updated>2021-05-18T07:30:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>对象可以被序列化也可以展开。 <a id="more"></a></p></blockquote><h3 id="存储对象">1. 存储对象</h3><p>存储对象状态的数据格式（主要讨论两种）：</p><ul><li>序列化(serialization)。将被序列化的对象写到文件中，然后让程序去文件中读取序列化的对象并把他们展开变回状态。</li><li>纯文本文件。用可解析的特殊字符写到文件中，比如用<code>tab</code>字符来分隔数据。</li></ul><p>将对象序列化（存储）的方法步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1. 创建出 FileOutputStream</span></span><br><span class="line">FileOutputStream fileStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"MyGame.ser"</span>); <span class="comment">// 文件不存在会自动创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建出 ObjectOutputStream</span></span><br><span class="line">ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(fileStream); <span class="comment">// 可以向文件写入对象，但无法直接连接文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 写入对象</span></span><br><span class="line">os.writeObject(characterOne); <span class="comment">// 将变量所引用的对象序列化并写入文件</span></span><br><span class="line">os.writeObject(characterTwo);</span><br><span class="line">os.writeObject(characterThree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 关闭 ObjectOutputStream</span></span><br><span class="line">os.close(); <span class="comment">// 关闭所关联的输出串流</span></span><br></pre></td></tr></table></figure><p>Java输入/输出<code>API</code>带有连接类型的<code>串流(chain streams)</code>，代表来源与目的地之间的连接，连接串流将串流与其他串流连接起来。</p><p>串流要两两连接，一个表示连接，另一个是要被调用方法。<code>FileOutputStream</code>把子节写入文件，<code>ObjectOutputStream</code>把对象转换成可以写入串流的数据。当调用<code>ObjectOutputStream</code>的<code>writeObject</code>方法时，对象会被打成串流送到<code>FileOutputStream</code>来写入文件。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/chainStreams.PNG" alt="序列化" /><figcaption aria-hidden="true">序列化</figcaption></figure><blockquote><p>当对象被序列化时，被该对象引用的实例变量也会被序列化，且所有被引用的对象也会被序列化。</p></blockquote><p>如果要让类能够被序列化，需要实现<code>Serializable</code>。<code>Serializable</code>接口又被称为<code>marker</code>或<code>tag</code>类的标记用接口，此接口没有任何方法需要实现，唯一目的是<u><strong>声明所有实现它的类是可以被序列化的</strong></u>。所以此类型的对象可以通过序列化机制来存储。</p><blockquote><ul><li>某类是可序列化的，则它的子类也自动地可以序列化</li><li>序列化是全有或全无地，即整个对象版图必须全部正确序列化，不然全部失败。</li></ul></blockquote><p>如果某实例变量不能或不应该被序列化，需要标记其为<code>transient</code>(瞬时)。序列化程序会跳过标记的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chat</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">transient</span> String currentID;</span><br><span class="line"> </span><br><span class="line">     String userName;</span><br><span class="line">     <span class="comment">// more code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="还原对象">2. 还原对象</h3><p><code>解序列化(Deserialization)</code>像是序列化的反向操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建FileInputStream</span></span><br><span class="line">FileInputStream fileStream = <span class="keyword">new</span> FileInputStream(<span class="string">"MyGame.ser"</span>); <span class="comment">// 文件不存在会抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建ObjectInputStream</span></span><br><span class="line"><span class="comment">// ObjectInputStream可以读取对象，但不能直接连接文件，需要一个连接流(connection stream)</span></span><br><span class="line">ObjectInputStream os = <span class="keyword">new</span> ObjectInputStream(fileStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 读取对象</span></span><br><span class="line"><span class="comment">// 每次readObject都会读出下一个对象，读取顺序与写入顺序相同，次数超过会抛出异常</span></span><br><span class="line">Object one = os.readObject();</span><br><span class="line">Object two = os.readObject();</span><br><span class="line">Object three = os.readObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 转换对象类型</span></span><br><span class="line"><span class="comment">// 返回值是Object类型，因此必须要转换类型</span></span><br><span class="line">GameCharacter elf = (GameCharacter) one;</span><br><span class="line">GameCharacter troll = (GameCharacter) two;</span><br><span class="line">GameCharacter magician = (GameCharacter) three;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 关闭ObjectInputStream</span></span><br><span class="line"><span class="comment">// FileInputStream会随之自动关闭</span></span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure><p>对象被解序列化时，Java虚拟机会通过尝试在堆上创建新对象，让它维持与被序列化时有相同的状态来恢复对象的原状。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/Deserialization.PNG" alt="解序列化" /><figcaption aria-hidden="true">解序列化</figcaption></figure><ol type="1"><li>对象从<code>stream</code>中读出来；</li><li>Java虚拟机通过存储的消息判断出对象的class类型；</li><li>Java虚拟机尝试寻找和加载对象的类。如果Java虚拟机找不到或无法加载该类，则Java虚拟机会抛出异常</li><li>新的对象会被配置在堆上，但构造函数不会执行。</li><li>如果对象在继承树上有不可序列化的祖先类，则该不可序列化类以及它之上的类的构造函数会执行。</li><li>对象的实例变量会被还原成序列化时的状态值。<code>transient</code>变量会被赋值默认值。</li></ol><h3 id="将字符串写入文本文件">3. 将字符串写入文本文件</h3><p>写入文本数据与写入对象类似，可以使用<code>FileWriter</code>代替<code>FileOutputStream</code>，它不会被连接到<code>ObjectOutputStream</code>上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteAFile</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="string">"Foo.txt"</span>);</span><br><span class="line">             writer.write(<span class="string">"hello foo!"</span>);</span><br><span class="line">             writer.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">             ex.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.io.File</code>类代表磁盘上的文件，但并不是文件中的内容。<code>File</code>没有读写文件的方法，它提供一种比字符串文件名来表示文件更安全的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建出代表磁盘文件的File对象</span></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"MyCode.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立新的目录</span></span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"Chapter7"</span>); </span><br><span class="line">dir.mkdir();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 列出目录下的内容</span></span><br><span class="line"><span class="keyword">if</span> (dir.isDirectory()) &#123;</span><br><span class="line">String[] dirContents = dir.list();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dirContents.length; i++) &#123;</span><br><span class="line">System.out.println(dirContents[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 取得文件或目录的绝对路径</span></span><br><span class="line">System.out.println(dir.getAbsolutePath());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 删除文件或目录</span></span><br><span class="line"><span class="keyword">boolean</span> isDeleted = f.delete();</span><br></pre></td></tr></table></figure><p><strong>缓冲区</strong></p><p>缓冲区可以带来更高的效率。通过<code>BufferedWriter</code>和<code>FileWriter</code>的链接，<code>BufferedWriter</code>可以暂存一些数据，到满的时候在实际写入磁盘，可以减少对磁盘的操作次数。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/buffers.PNG" alt="缓冲区" /><figcaption aria-hidden="true">缓冲区</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(aFile));</span><br></pre></td></tr></table></figure><p>若想要强制缓冲区立即写入，可以调用以下方法要求立即写入缓冲区内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.flush();</span><br></pre></td></tr></table></figure><h3 id="读取文本文件">4. 读取文本文件</h3><p>用<code>File</code>对象来表示文件，以<code>FileReader</code>来执行实际的读取，并用<code>BufferedReader</code>来让读取更有效。读取以<code>while</code>循环来逐行进行，知道<code>readLine()</code>的结果为<code>null</code>为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadAFile</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             File myFile = <span class="keyword">new</span> File(<span class="string">"MyText.txt"</span>);</span><br><span class="line">             <span class="comment">// FileReader是字符连接到文本文件的串流</span></span><br><span class="line">             FileReader fileReader = <span class="keyword">new</span> FileReader(myFile);</span><br><span class="line">             <span class="comment">// FileReader链接到BufferedReader以获取更高效率</span></span><br><span class="line">             BufferedReader reader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">             </span><br><span class="line">             <span class="comment">// 用String变量来承接所读取的结果</span></span><br><span class="line">             String line = <span class="keyword">null</span>;</span><br><span class="line">             </span><br><span class="line">             <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 读一行就列出一行</span></span><br><span class="line">                 System.out.println(line);</span><br><span class="line">             &#125;</span><br><span class="line">             reader.close(); </span><br><span class="line">         &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">             ex.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析字符串</strong></p><p>用<code>String</code>的<code>split()</code>方法来解析字符串，<code>split()</code>可以将字符串拆开成<code>String</code>的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件读出来的格式</span></span><br><span class="line">String toTest = <span class="string">"What is blue + yellow?/green"</span>;</span><br><span class="line"><span class="comment">// split用参数所指定的字符来把这个String拆开成两个部分</span></span><br><span class="line">String[] result = toTest.split(<span class="string">"/"</span>);</span><br><span class="line"><span class="keyword">for</span> (String token:result) &#123;</span><br><span class="line">     System.out.println(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.nio</code>类可以直接控制<code>buffer</code>。另一个能力是<code>non-blocking</code>的输入/输出，能让输入/输出程序代码在没有东西可读取或写入时不必等待。</p><p><strong>序列化的识别</strong></p><p>版本控制很重要，如果在序列化后修改了类的定义，会伤害兼容性：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/changesForDeserialization.PNG" alt="修改对序列化的影响" /><figcaption aria-hidden="true">修改对序列化的影响</figcaption></figure><p>每当对象被序列化时，该对象会被盖上一个类版本识别ID，叫做<code>serialVersionUID</code>，根据类的结构消息计算所得。当对象被接序列化时，如果对象被序列化之后有了不同的<code>serialVersionUID</code>，还原操作会失败！</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/serialVersionUID.PNG" alt="serialVersionUID" /><figcaption aria-hidden="true">serialVersionUID</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对象可以被序列化也可以展开。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--12 图形用户接口</title>
    <link href="https://wuyunjie.top/2021/05/17/JavaLearning_Head_First_Java_12_getting_gui.html"/>
    <id>https://wuyunjie.top/2021/05/17/JavaLearning_Head_First_Java_12_getting_gui.html</id>
    <published>2021-05-17T14:28:09.000Z</published>
    <updated>2021-05-17T14:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>面对现实，你得做出图形用户接口。 <a id="more"></a></p></blockquote><h3 id="window">1. window</h3><p><code>JFrame</code>是代表屏幕上window的对象，可以把<code>button</code>，<code>checkbox</code>，<code>text</code>字段等接口放在window上。标准的<code>menu</code>也可以加到上面。</p><p>一旦创建了<code>JFrame</code>后，就可以把组件(<code>widget</code>)加到上面。最常用的组件包括：<code>JButton, JRadioButton, JCheckBox, JLabel, JList, JScrollPane, JSlider, JTextArea, JTextField, and JTable</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleGui1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 frame</span></span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 widget</span></span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">"click me"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// window关闭时结束程序</span></span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把widget加到frame上</span></span><br><span class="line">        frame.getContentPane().add(button);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定frame大小</span></span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        <span class="comment">// 显式</span></span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户接口事件">2. 用户接口事件</h3><p>让按钮在按下时执行工作需要两项：</p><ul><li>被按下时要执行的方法(按钮任务)</li><li>检测按钮被按下的方法(按钮感应装置)</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/buttonEvent.PNG" alt="按钮事件" /><figcaption aria-hidden="true">按钮事件</figcaption></figure><p>取得与处理用户操作事件的过程称为<code>event-handling</code>。如果想知道按钮的事件，就会监听事件的接口，<code>监听接口</code>是<u>介于监听与事件源间的桥梁</u>。</p><p>事件来源将用户操作转换成事件的对象，事件几乎都是以对象来表示。程序大多数情况是事件的接收方而不是创建方。事件对象通过不同的事件方法来表示不同类型的事件。</p><p>比如取得按钮的<code>ActionEvent</code>：</p><ul><li>实现ActionListener接口</li><li>向按钮注册</li><li>定义事件处理的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口ActionListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleGui1B</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">    JButton button;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleGui1B gui = <span class="keyword">new</span> SimpleGui1B();</span><br><span class="line">        gui.go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line">        button = <span class="keyword">new</span> JButton(<span class="string">"click me"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        button.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        frame.getContentPane().add(button);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.setSize(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现ActionListener接口的方法，处理事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以ActionEvent对象作为参数调用</span></span><br><span class="line">        button.setText(<span class="string">"I’ve been clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘图组件">3. 绘图组件</h3><p>创建具有绘图功能的<code>widget</code>放到<code>frame</code>上，创建<code>JPanel</code>的子类覆盖掉<code>paintComponet()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDrawPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        g.setColor(Color.orange);</span><br><span class="line">        g.fillRect(<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式<code>JPEG</code>照片：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">     Image image = <span class="keyword">new</span> ImageIcon(<span class="string">"catzilla.jpg"</span>).getImage();</span><br><span class="line">     g.drawImage(image,<span class="number">3</span>,<span class="number">4</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随机色彩圆：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    g.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">this</span>.getWidth(), <span class="keyword">this</span>.getHeight());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> red = (<span class="keyword">int</span>) (Math.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">int</span> green = (<span class="keyword">int</span>) (Math.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">int</span> blue = (<span class="keyword">int</span>) (Math.random() * <span class="number">256</span>);</span><br><span class="line">    Color randomColor = <span class="keyword">new</span> Color(red, green, blue);</span><br><span class="line">    g.setColor(randomColor);</span><br><span class="line">    g.fillOval(<span class="number">70</span>,<span class="number">70</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类inner-class">4. 内部类（Inner class）</h3><p>一个类可以嵌套在另一个类的内部。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/innerClass.PNG" alt="简单内部类" /><figcaption aria-hidden="true">简单内部类</figcaption></figure><blockquote><p>内部类可以使用外部的所有方法与变量，就算私有内容也一样。即内部类可以把外部的方法或变量当作自己的。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/Inner_class_using_outer_class.PNG" alt="内部类使用外部类的变量" /><figcaption aria-hidden="true">内部类使用外部类的变量</figcaption></figure><blockquote><p>内部类的实例一定会绑定在外部类的实例上。从外部类程序代码中初始化的内部类，此内部对象会绑定在该外部对象上。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/innerOuterBound.PNG" alt="创建内部类实例" /><figcaption aria-hidden="true">创建内部类实例</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;面对现实，你得做出图形用户接口。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--3 垃圾收集器与内存分配策略</title>
    <link href="https://wuyunjie.top/2021/05/17/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_3_Garbage_collector_and_memory_allocation_strategy.html"/>
    <id>https://wuyunjie.top/2021/05/17/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_3_Garbage_collector_and_memory_allocation_strategy.html</id>
    <published>2021-05-17T02:35:27.000Z</published>
    <updated>2021-05-17T02:35:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code> <a id="more"></a></p></blockquote><h3 id="对象已死">1. 对象"已死"？</h3><p>垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（<code>“死去”即不可能再被任何途径使用的对象</code>）。</p><h4 id="引用计数算法">1.1 引用计数算法</h4><p>在对象中添加一个<code>引用计数器（Reference Counting）</code>，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；<strong>任何时刻计数器为零的对象就是不可能再被使用的</strong>。</p><blockquote><ul><li>占用了一些额外的内存空间来进行计数</li><li>原理简单，判定效率也很高</li></ul></blockquote><p>主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作。</p><blockquote><p>譬如单纯的引用计数就很难解决对象之间<code>相互循环引用</code>的问题。</p><ul><li>对象<code>objA</code>和<code>objB</code>都有字段<code>instance</code>；</li><li>赋值令 <code>objA.instance=objB</code>及<code>objB.instance=objA</code>，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问；</li><li>但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。</li></ul></blockquote><p>打印内存回收日志的参数设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails      //打印GC详细信息</span><br><span class="line">-Xms100M    //堆大小100M</span><br><span class="line">-Xmx200M   //堆最大占用内存</span><br><span class="line">-Xmn10M     //新生代 大小 </span><br><span class="line">-XX:SurvivorRatio=8   //Eden:Survivor1:Survivor2 = 8:1:1</span><br><span class="line">-XX:MaxPermSize30M   //永久代内存大小</span><br><span class="line">-XX:MetaspaceSize=30M  //元空间 初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</span><br><span class="line">-XX:MaxMetaspaceSize=300M //最大空间，默认是没有限制的。</span><br></pre></td></tr></table></figure><h4 id="可达性分析算法">1.2 可达性分析算法</h4><p><code>可达性分析（Reachability Analysis）算法</code>的基本思路是：</p><blockquote><ul><li>通过 一系列称为<code>“GC Roots”</code>的根对象作为<strong>起始节点集</strong>，从这些节点开始，根据引用关系向下搜索；</li><li>搜索过程所走过的路径称为<code>“引用链”（Reference Chain）</code>，如果某个对象到<code>GC Roots</code>间没有任何引用链相连， 或者用图论的话来说就是从<code>GC Roots</code>到这个对象不可达时，则证明此对象是不可能再被使用的。</li></ul></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Reachability_Analysis.PNG" alt="可达性分析算法" /><figcaption aria-hidden="true">可达性分析算法</figcaption></figure><p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是使用了可达性分析算法。固定可作为<code>GC Roots</code>的对象包括以下几种：</p><ul><li>在<code>虚拟机栈（栈帧中的本地变量表）中引用的对象</code>，譬如各个线程被调用的方法堆栈中使用到的<u>参数、局部变量、临时变量</u>等。</li><li>在<strong>方法区</strong>中<code>类静态属性引用的对象</code>，譬如Java类的引用类型静态变量。</li><li>在<strong>方法区</strong>中<code>常量引用的对象</code>，譬如字符串常量池（String Table）里的引用。</li><li>在<code>本地方法栈中JNI</code>（即通常所说的Native方法）引用的对象。</li><li><code>Java虚拟机内部的引用</code>，如基本数据类型对应的Class对象，一些常驻的<strong>异常对象</strong>（比如<code>NullPointExcepiton</code>、<code>OutOfMemoryError</code>）等，还有系统类加载器。</li><li>所有被<code>同步锁（synchronized关键字）持有的对象</code>。</li><li>反映Java虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI中注册的回调</code>、<code>本地代码缓存</code>等。</li></ul><p>除了这些<strong>固定</strong>的<code>GC Roots</code>集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象<strong>“临时性”</strong>地加入，共同构成完整<code>GC Roots</code>集合。</p><h4 id="引用的分类">1.3 引用的分类</h4><p>在<code>JDK 1.2</code>版之后，Java对引用的概念进行了扩充，将引用分为<code>强引用（Strongly Re-ference）</code>、<code>软引用（Soft Reference）</code>、<code>弱引用（Weak Reference）</code>和<code>虚引用（Phantom Reference）</code>4种，这4种引用强度依次逐渐减弱。</p><ul><li><p>强引用是指在程序代码之中普遍存在的引用赋值，即类似<code>“Object obj=new Object()”</code>这种引用关系。</p><blockquote><p>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。`</p></blockquote></li><li><p>软引用是用来描述一些<strong>还有用，但非必须的对象</strong>。</p><blockquote><ul><li>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</li><li>在<code>JDK 1.2</code>版之后提供了<code>SoftReference</code>类来实现软引用。</li></ul></blockquote></li><li><p>弱引用也是用来描述那些<strong>非必须对象</strong>，但是它的强度比软引用更弱一些。</p><blockquote><p>被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><p>在<code>JDK 1.2</code>版之后提供了<code>WeakReference</code>类来实现弱引用。</p></blockquote></li><li><p>虚引用也称为<code>“幽灵引用”</code>或者<code>“幻影引用”</code>，它是最弱的一种引用关系。</p><blockquote><p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的<u>只是为了能在这个对象被收集器回收时收到一个系统通知</u>。</p><p>在<code>JDK 1.2</code>版之后提供 了<code>PhantomReference</code>类来实现虚引用。</p></blockquote></li></ul><h4 id="对象的死亡宣告">1.4 对象的死亡宣告</h4><p>在可达性分析算法中判定为不可达的对象，至少要经历两次标记过程：</p><ol type="1"><li><p>如果对象在进行可达性分析后发现没有与<code>GC Roots</code>相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是<u>此对象是否有必要执行<code>finalize()</code>方法</u>。</p><ul><li><p>假如对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为<strong>“没有必要执行”</strong>。</p></li><li><p>如果这个对象被判定为确<strong>有必要执行<code>finalize()</code>方法</strong>，那么该对象将会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条由虚拟机<strong>自动建立的、低调度优先级</strong>的<code>Finalizer</code>线程去执行它们的<code>finalize()</code> 方法。</p><ul><li><code>“执行”</code>是<u>指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束</u>。</li></ul></li></ul></li><li><p>稍后收集器将对<code>F-Queue</code>中的对象进行<u>第二次小规模的标记</u>，如果对象要在<code>finalize()</code>中重新与引用链上的任何一个对象建立关联，那在第二次标记时它将被移出“即将回收”的集合。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此代码演示了两点：</span></span><br><span class="line"><span class="comment">* 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment">* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes, i am still alive :)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/FinalizeEscapeGC.PNG" alt="FinalizeEscapeGC运行结果" /><figcaption aria-hidden="true">FinalizeEscapeGC运行结果</figcaption></figure><p>代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败了。这是因为<strong>任何一个对象的finalize()方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p><blockquote><p><code>finalize()</code>是不推荐使用的语法</p></blockquote><h4 id="回收方法区">1.5 回收方法区</h4><p>方法区的垃圾收集主要回收两部分内容：<code>废弃的常量</code>和<code>不再使用的类型</code>。</p><ul><li>回收废弃常量与回收 Java堆中的对象非常类似。</li><li>判定一个类型是否属于<code>“不再被使用的类”</code>需要同时满足下面三个条件：<ul><li><strong>该类所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li><strong>加载该类的类加载器已经被回收</strong>，这个条件则通常是很难达成。</li><li><strong>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li></ul></li></ul><h3 id="垃圾收集算法">2. 垃圾收集算法</h3><p>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为<code>“引用计数式垃圾收集”（Reference Counting GC）</code>和<code>“追踪式垃圾收集”（Tracing GC）</code>两大类，这两类也常被称作<code>“直接垃圾收集”</code>和<code>“间接垃圾收集”</code>。</p><h4 id="分代收集理论">2.1 分代收集理论</h4><p><code>“分代收集”（Generational Collection）</code>建立在两个分代假说之上：</p><ol type="1"><li><code>弱分代假说（Weak Generational Hypothesis）</code>：绝大多数对象都是朝生夕灭的。</li><li><code>强分代假说（Strong Generational Hypothesis）</code>：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ol><p>设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（<strong>年龄即对象熬过垃圾收集过程的次数</strong>）分配到不同的区域之中存储。</p><blockquote><ul><li>如果一个区域中大多数对象都是朝生夕灭，那么把它们集中放在一起，每次回收时只关注如何保留少量存活，就能以较低代价回收到大量的空间；</li><li>如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域；</li><li>同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</li></ul></blockquote><p>设计者一般至少会把Java堆划分为<code>新生代（Young Generation）</code>和<code>老年代（Old Generation）</code>两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p><p>假如要现在进行一次只局限于新生代区域内的收集<code>（Minor GC）</code>，但新生代中的对象是完全有可能被老年代所引用的。需要对分代收集理论添加第三条经验法则：</p><ol start="3" type="1"><li><code>跨代引用假说（Intergenerational Reference Hypothesis）</code>：跨代引用相对于同代引用来说仅占极少数。</li></ol><p>依据这条假说，只需在新生代上建立一个全局的数据结构（该结构被称为<code>“记忆集”</code>，<code>Remembered Set</code>），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生<code>Minor GC</code>时，只有包含了跨代引用的小块内存里的对象才会被加入到<code>GC Roots</code>进行扫描。</p><blockquote><ul><li><code>部分收集（Partial GC）</code>：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul><li><code>新生代收集（Minor GC/Young GC）</code>：指目标只是新生代的垃圾收集。</li><li><code>老年代收集（Major GC/Old GC）</code>：指目标只是老年代的垃圾收集。</li><li><code>混合收集（Mixed GC）</code>：指目标是收集整个新生代以及部分老年代的垃圾收集。</li></ul></li><li><code>整堆收集（Full GC）</code>：收集整个Java堆和方法区的垃圾收集。</li></ul></blockquote><h4 id="标记-清除mark-sweep算法">2.2 标记-清除(Mark-Sweep)算法</h4><p>算法分为<code>“标记”</code>和<code>“清除”</code>两个阶段：</p><ul><li>首先标记出所有需要回收的对象；</li><li>在标记完成后，统一回收掉所有被标记的对象；</li></ul><p>也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p><blockquote><p>主要缺点:</p><ol type="1"><li><strong>执行效率不稳定</strong>，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li><li><strong>内存空间的碎片化问题</strong>，标记、清除之后会产生大量不连续的内存碎片。</li></ol></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Sweep.PNG" alt="“标记-清除”算法" /><figcaption aria-hidden="true">“标记-清除”算法</figcaption></figure><h4 id="标记-复制mark-copying算法">2.3 标记-复制(Mark-Copying)算法</h4><p>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，标记-复制(Mark-Copying)算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。<u>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</u>。</p><blockquote><p>缺点：</p><ul><li>如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销；</li><li>这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一 点。</li></ul></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Copying.PNG" alt="“标记-复制”算法" /><figcaption aria-hidden="true">“标记-复制”算法</figcaption></figure><p><code>Appel式回收</code>(<code>Andrew Appel</code>提出的一种更优化的<code>半区复制分代策略</code>)的具体做法是：</p><ul><li>把新生代分为一块较大的<code>Eden空间</code>和两块较小的<code>Survivor空间</code>，每次分配内存只使用<code>Eden</code>和其中一块<code>Survivor</code>。</li><li>发生垃圾搜集时，将<code>Eden</code>和<code>Survivor</code>中仍然存活的对象一次性复制到另外一块<code>Survivor</code>空间上，然后直接清理掉<code>Eden</code>和已用过的那块<code>Survivor</code>空间。</li></ul><p><code>HotSpot虚拟机</code>默认<code>Eden</code>和<code>Survivor</code>的大小比例是<code>8∶1</code>，也即每次新生代中可用内存空间为整个新生代容量的<strong>90%</strong>（<code>Eden</code>的<strong>80%</strong>加上一个<code>Survivor</code>的<strong>10%</strong>）。</p><blockquote><p><code>Appel式回收</code>还有一个充当罕见情况的<code>“逃生门”</code>的安全设计，当<code>Survivor</code>空间不足以容纳一次<code>Minor GC</code>之后存活的对象时，就需要依赖<strong>其他内存区域（实际上大多就是老年代）</strong>进行<code>分配担保（Handle Promotion）</code>。</p></blockquote><h4 id="标记-整理mark-compact算法">2.4 标记-整理(Mark-Compact)算法</h4><p><code>“标记-整理”（Mark-Compact）算法</code>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Compact.PNG" alt="“标记-整理”算法" /><figcaption aria-hidden="true">“标记-整理”算法</figcaption></figure><p>是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。</p><h3 id="hotspot的算法细节实现">3. HotSpot的算法细节实现</h3><h4 id="根节点枚举">3.1 根节点枚举</h4><p>所有收集器在根节点枚举这一步骤时都是<strong>必须暂停用户线程</strong>的，因此毫无疑问根节点枚举与整理内存碎片一样会面临相似的<code>“Stop The World”</code>的困扰。</p><p><code>HotSpot</code>使用一组称为<code>OopMap</code>的数据结构直接得到哪些地方存放着对象引用。（<code>普通对象指针（Ordinary Object Pointer，OOP）</code>）</p><blockquote><ul><li>一旦类加载动作完成的时候，就会把对象内什么偏移量上是什么类型的数据计算出来；</li><li>在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。</li></ul></blockquote><p>这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等<code>GC Roots</code>开始查找。</p><h4 id="安全点">3.2 安全点</h4><p><code>HotSpot</code>没有为每条指令都生成<code>OopMap</code>，只是在<strong>“特定的位置”</strong>记录了这些信息，这些位置被称为<code>安全点（Safepoint）</code>。有了安全点的设定，强制要求必须执行到达安全点后才能够暂停下来开始垃圾收集。</p><blockquote><p>安全点位置的选取基本上是以“<code>是否具有让程序长时间执行的特征</code>”，<code>“长时间执行”</code>的最明显特征就是<strong>指令序列的复用</strong>，例如<u>方法调用、循环跳转、异常跳转</u>等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p></blockquote><p>如何在垃圾收集发生时让所有线程（这里其实<code>不包括执行JNI调用的线程</code>）都跑到最近的安全点，然后停顿下来。</p><blockquote><p><code>抢先式中断（Preemptive Suspension）</code>在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。</p><p><code>主动式中断（Voluntary Suspension）</code>当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一 个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。</p></blockquote><p><code>HotSpot</code>使用<code>内存保护陷阱</code>的方式，把轮询操作精简至只有一条汇编指令的程度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x01b6d62d: test %eax,0x160100</span><br></pre></td></tr></table></figure><p>当需要暂停用户线程时，虚拟机把<code>0x160100</code>的内存页设置为不可读，那线程执行到<code>test</code>指令时就会产生一个<code>自陷异常信号</code>，然后在预先注册的异常处理器中挂起线程实现等待。</p><h4 id="安全区域">3.3 安全区域</h4><p><code>安全区域</code>是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。</p><blockquote><ul><li>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。</li><li>当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段）:<ul><li>如果完成了，那线程就当作没事发生过，继续执行；</li><li>否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</li></ul></li></ul></blockquote><h4 id="记忆集与卡表">3.4 记忆集与卡表</h4><p><code>记忆集（Remembered Set）</code>是一种用于记录<u>从非收集区域指向收集区域的指针集合</u>的抽象数据结构。实现记忆集的一些可供选择（当然也可以选择这个范围以外的）的记录精度：</p><ul><li><strong>字长精度</strong>：每个记录精确到一个机器字长，该字包含跨代指针。</li><li><strong>对象精度</strong>：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li><li><strong>卡精度</strong>：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li></ul><p>“卡精度”所指的是用一种称为<code>“卡表”（Card Table）</code>的方式去实现记忆集，字节数组<code>CARD_TABLE</code>的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作<code>“卡页”（Card Page）</code>。</p><blockquote><p>只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为<code>1</code>，称为这个元素变脏（Dirty），没有则标识为<code>0</code>。</p></blockquote><h4 id="写屏障">3.5 写屏障</h4><p>卡表元素何时变脏?</p><blockquote><p>有其他分代区域中对象引用了本区域对象时</p></blockquote><p>如何变脏?</p><blockquote><p>在<code>HotSpot</code>虚拟机里是通过<code>写屏障（Write Barrier）</code>技术维护卡表状态的。写屏障可以看作在虚拟机层面对<code>“引用类型字段赋值”</code>这个动作的<code>AOP切面</code></p><ul><li>在引用对象赋值时会产生一个<code>环形（Around）</code>通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。<ul><li>在赋值前的部分的写屏障叫作<code>写前屏障（Pre-Write Barrier）</code>；</li><li>在赋值后的则叫作<code>写后屏障（Post-Write Barrier）</code>。</li></ul></li></ul></blockquote><p><strong>“伪共享”（False Sharing）问题</strong></p><blockquote><p>现代中央处理器的缓存系统中是以<code>缓存行（Cache Line）</code>为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低。</p><p>为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏</p></blockquote><h4 id="并发的可达性分析">3.6 并发的可达性分析</h4><p>可达性分析的停顿时间与Java堆容量直接成正比例关系，把遍历对象图过程中遇到的对象，按照<strong>“是否访问过”</strong>这个条件标记成以下三种颜色，演示并发出现<strong>“对象消失”</strong>问题：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Object_disappeared.PNG" alt="并发出现“对象消失”问题" /><figcaption aria-hidden="true">并发出现“对象消失”问题</figcaption></figure><ul><li><strong>白色</strong>：表示对象尚未被垃圾收集器访问过。</li><li><strong>黑色</strong>：表示对象已经被垃圾收集器访问过，且这个对象的<u>所有引用都已经扫描过</u>。</li><li><strong>灰色</strong>：表示对象已经被垃圾收集器访问过，但这个对象上<u>至少存在一个引用还没有被扫描过</u>。</li></ul><p>当且仅当以下两个条件同时满足时，会产生“对象消失”的问题：</p><blockquote><ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li></ul></blockquote><p>产生了两种解决方案：</p><blockquote><ul><li><p><code>增量更新（Incremental Update）</code>破坏的是第一个条件。当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</p></li><li><p><code>原始快照（Snapshot At The Beginning，SATB）</code>破坏的是第二个条件。当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p></li></ul></blockquote><h3 id="经典垃圾收集器">4. 经典垃圾收集器</h3><p>七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Garbage_collector.PNG" alt="HotSpot虚拟机的垃圾收集器" /><figcaption aria-hidden="true">HotSpot虚拟机的垃圾收集器</figcaption></figure><h4 id="新生代收集器">4.1 新生代收集器</h4><h5 id="serial收集器">4.1.1 Serial收集器</h5><p><code>Serial收集器</code>是一个单线程工作的收集器，但它的“单线程”的意义是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/serial_collector.PNG" alt="Serial/Serial Old收集器运行示意图" /><figcaption aria-hidden="true">Serial/Serial Old收集器运行示意图</figcaption></figure><blockquote><p>它是所有收集器里<code>额外内存消耗（Memory Footprint）</code>最小的，简单而高效</p></blockquote><h5 id="parnew收集器">4.1.2 ParNew收集器</h5><p><code>ParNew收集器</code>实质上是<code>Serial收集器</code>的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为都与Serial收集器完全一致。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ParNew_collector.PNG" alt="ParNew/Serial Old收集器运行示意图l Old收集器运行示意图" /><figcaption aria-hidden="true">ParNew/Serial Old收集器运行示意图l Old收集器运行示意图</figcaption></figure><p>在谈论垃圾收集器的上下文语境中，<code>并行和并发</code>可以理解为：</p><ul><li><code>并行（Parallel）</code>：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态</li><li><code>并发（Concurrent）</code>：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。</li></ul><h5 id="parallel-scavenge收集器">4.1.3 Parallel Scavenge收集器</h5><p><code>Parallel Scavenge收集器</code>也是一款<code>新生代收集器</code>，它同样是基于<u>标记-复制算法</u>实现的收集器，也是能够并行收集的多线程收集器。Parallel Scavenge收集器的目标则是达到一个可控制的<code>吞吐量（Throughput）</code>，吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值： <span class="math display">\[吞吐量 = \frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}\]</span> 高吞吐量可以最高效率地利用处理器资源，尽快完成程序的运算任务，<em>主要适合在后台运算而不需要太多交互的分析任务</em>。</p><blockquote><p><code>自适应的调节策略（GC Ergonomics）</code>让虚拟机根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p></blockquote><h4 id="老年代收集器">4.2 老年代收集器</h4><h5 id="serial-old收集器">4.2.1 Serial Old收集器</h5><p><code>Serial Old</code>是Serial收集器的老年代版本，它同样是一个单线程收集器，使用<u>标记-整理算法</u>。</p><h5 id="parallel-old收集器">4.2.2 Parallel Old收集器</h5><p><code>Parallel Old</code>是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于<u>标记-整理算法</u>实现。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Parallel_Old_collector.PNG" alt="ParNew/Serial Old收集器运行示意图" /><figcaption aria-hidden="true">ParNew/Serial Old收集器运行示意图</figcaption></figure><blockquote><p>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p></blockquote><h5 id="cms收集器">4.2.3 CMS收集器</h5><p><code>CMS（Concurrent Mark Sweep）收集器</code>是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于<u>标记-清除算法</u>实现的，它的运作过程分为四个步骤：</p><ol type="1"><li><code>初始标记（CMS initial mark）</code>。只是标记一下<code>GC Roots</code>能<strong>直接</strong>关联到的对象，速度很快；</li><li><code>并发标记（CMS concurrent mark）</code>。从<code>GC Roots</code>的<u>直接关联对象</u>开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</li><li><code>重新标记（CMS remark）</code>。修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；</li><li><code>并发清除（CMS concurrent sweep）</code>。清理删除掉标记阶段判断的已经死亡的对象。</li></ol><p>初始标记、重新标记这两个步骤仍然需要<code>“Stop The World”</code>。在整个过程中<em>耗时最长</em>的<code>并发标记</code>和<code>并发清除</code>阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说<code>CMS收集器</code>的内存回收过程是与用户线程一起<strong>并发执行</strong>的。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Concurrent_Mark_Sweep.PNG" alt="Concurrent Mark Sweep收集器运行示意图" /><figcaption aria-hidden="true">Concurrent Mark Sweep收集器运行示意图</figcaption></figure><blockquote><p>优点：并发收集、低停顿。也称之为<code>“并发低停顿收集器”（Concurrent Low Pause Collector）</code>。</p><p>缺点：</p><ul><li>CMS收集器对<code>处理器资源</code>非常敏感。</li><li>由于CMS收集器无法处理<code>“浮动垃圾”（Floating Garbage）</code>，有可能出现<code>“Con-current Mode Failure”</code>失败进而导致另一次完全<code>“Stop The World”</code>的<code>Full GC</code>的产生。<ul><li><code>“浮动垃圾”</code>：在CMS的<code>并发标记</code>和<code>并发清理</code>阶段，用户线程运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。</li><li><code>“并发失败”（Concurrent Mode Failure）</code>：CMS运行期间预留的内存无法满足程序分配新对象的需要。虚拟机将不得不启动<code>后备预案</code>：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集。</li></ul></li><li>CMS是一款基于“标记-清除”算法实现的收集器，收集结束时会有大量<code>空间碎片</code>产生。</li></ul></blockquote><h4 id="garbage-first收集器">4.3 Garbage First收集器</h4><p><code>Garbage First（简称G1）收集器</code>开创了收集器<code>面向局部收集</code>的设计思路和<code>基于Region的内存布局</code>形式，也被Oracle官方称为<code>“全功能的垃圾收集器”（Fully-Featured Garbage Collector）</code>。</p><blockquote><p><code>“停顿时间模型”（Pause Prediction Model）</code>是能够支持指定在一个长度为<strong>M毫秒</strong>的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。</p></blockquote><p><code>G1</code>面向堆内存任何部分来组成<code>回收集（Collection Set，一般简称CSet）</code>进行回收，衡量标准是<u>哪块内存中存放的垃圾数量最多，回收收益最大</u>。这就是G1收集器的<code>Mixed GC模式</code>。</p><h5 id="基于region的堆内存布局">4.3.1 基于Region的堆内存布局</h5><p>G1不再坚持固定大小以及固定数量的分代区域划分，而是<u>把连续的Java堆划分为多个大小相等的<code>独立区域（Region）</code></u>，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理。</p><blockquote><p>Region中一类特殊的<code>Humongous区域</code>，专门用来存储大对象。只要大小超过了一个 Region容量一半的对象即可判定为大对象。</p></blockquote><h5 id="面向局部收集">4.3.2 面向局部收集</h5><p>G1中新生代和老年代不再是固定的了，它们都是一系列区域（<strong>不需要连续</strong>）的<code>动态集合</code>。将Region作为单次回收的最小单元，可以有计划地避免<u>在整个Java堆中进行全区域的垃圾收集</u>。G1收集器跟踪各个Region里面的垃圾堆积的“价值”大小：</p><blockquote><p>价值即回收所获得的空间大小以及回收所需时间的经验值</p></blockquote><p>在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region。(“Garbage First”名字的由来)</p><h5 id="关键的细节问题">4.3.3 关键的细节问题</h5><ul><li><u>将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？</u>使用记忆集避免全堆作为GC Roots扫描。G1的记忆集在存储结构的<u>本质上是一 种哈希表</u>，<code>Key</code>是别的Region的起始地址，<code>Value</code>是一个集合，里面存储的元素是卡表的索引号。</li><li><u>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</u>G1 收集器是通过<code>原始快照（SATB）算法</code>保证用户线程改变对象引用关系时，不能打破原本的对象图结构。此外，G1为每一个Region设计了两个名为<code>TAMS（Top at Mark Start）</code>的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li><li><u>怎样建立起可靠的停顿预测模型？</u>G1收集器的停顿预测模型是以<code>衰减均值（Decaying Average）</code>为理论基础来实现的。在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。衰减平均值更准确地代表“最近的”平均状态。</li></ul><h5 id="关键的细节问题-1">4.3.4 关键的细节问题</h5><p>G1收集器的运作过程大致可划分为以下四个步骤：</p><ul><li><code>初始标记（Initial Marking）</code>。仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象，并且修改<code>TAMS</code>指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。</li><li><code>并发标记（Concurrent Marking）</code>。从<code>GC Root</code>开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。当对象图扫描完成以后，还要重新处理<code>原始快照SATB</code>记录下的在并发时有引用变动的对象。</li><li><code>最终标记（Final Marking）</code>。对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的<code>SATB记录</code>。</li><li><code>筛选回收（Live Data Counting and Evacuation）</code>。负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。<ul><li>这里的操作涉及存活对象的移动，是<strong>必须暂停用户线程</strong>，由多条收集器线程并行完成的。</li></ul></li></ul><p>G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/G1_collector.PNG" alt="G1收集器运行示意图" /><figcaption aria-hidden="true">G1收集器运行示意图</figcaption></figure><blockquote><p>从G1开始，最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的<code>内存分配速率 （Allocation Rate）</code>，应用在分配，同时收集器在收集，只要收集的速度能跟得上对象分配的速度，那一切就能运作得很完美。</p></blockquote><p>优点：</p><ul><li>可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集</li><li>G1<strong>从整体来看是基于“标记-整理”算法</strong>实现的收集器，但<strong>从局部（两个Region之间）上看又是基于“标记-复制”</strong>算法实现，G1运作期间不会产生内存空间碎片。</li></ul><p>缺点：</p><ul><li>G1为了垃圾收集产生的内存占用（Footprint）比CMS要高。G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间；</li><li>G1程序运行时的额外执行负载（Overload）比CMS要高。G1除了使用写后屏障来进行卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。</li></ul><h3 id="低延迟垃圾收集器">5. 低延迟垃圾收集器</h3><p>衡量垃圾收集器的三项最重要的指标是：<code>内存占用（Footprint）</code>、<code>吞吐量（Throughput）</code>和<code>延迟 （Latency）</code>。两款目前仍处于实验状态的收集器<code>Shenandoah</code>和<code>ZGC</code>，被官方命名为<code>“低延迟垃圾收集器”（Low-Latency Garbage Collector或者Low-Pause-Time Garbage Collector）</code>。</p><h4 id="shenandoah收集器">5.1 Shenandoah收集器</h4><p><code>Shenandoah</code>是一款只有<code>OpenJDK</code>才会包含，而<code>OracleJDK</code>里反而不存在的收集器。Shenandoah反而更像是G1的下一代继承者，在管理堆内存方面，它与G1至少有三个明显的不同之处：</p><ul><li>支持并发的整理算法；</li><li>Shenandoah是默认不使用分代收集的；</li><li>Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为<code>“连接矩阵”（Connection Matrix）</code>的全局数据结构来记录<em>跨Region的引用关系</em>，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。</li></ul><p>Shenandoah收集器的工作过程大致可以划分为以下九个阶段：</p><ul><li><code>初始标记（Initial Marking）</code>。标记与<code>GC Roots</code>直接关联的对象，这个阶段仍是<code>“Stop The World”</code>的。</li><li><code>并发标记（Concurrent Marking）</code>。遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的。</li><li><code>最终标记（Final Marking）</code>。处理剩余的<code>SATB扫描</code>，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组<code>回收集（Collection Set）</code>。<em>会有一小段短暂的停顿</em>。</li><li><code>并发清理（Concurrent Cleanup）</code>。清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为<code>Immediate Garbage Region</code>）。</li><li><code>并发回收（Concurrent Evacuation）</code>。Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中，Shenandoah通过读屏障和被称为“<code>Brooks Pointers</code>”的转发指针来解决并发回收阶段遇到的困难。</li><li><code>初始引用更新（Initial Update Reference）</code>。把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务。<em>会产生一个非常短暂的停顿</em>。</li><li><code>并发引用更新（Concurrent Update Reference）</code>。按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值。<em>与用户线程一起并发的</em>。</li><li><code>最终引用更新（Final Update Reference）</code>。修正存在于<code>GC Roots</code>中的引用，这个阶段是Shenandoah的最后一次停顿。</li><li><code>并发清理（Concurrent Cleanup）</code>。经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成<code>Immediate Garbage Regions</code>了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</li></ul><p>三个最重要的并发阶段<strong>（并发标记、并发回收、并发引用更新）</strong>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Shenandoah.PNG" alt="Shenandoah收集器的工作过程" /><figcaption aria-hidden="true">Shenandoah收集器的工作过程</figcaption></figure><p>黄色的区域代表的是<em>被选入回收集的Region</em>，绿色部分就代表<em>还存活的对象</em>，蓝色就是<em>用户线程可以用来分配对象的内存Region</em>。</p><p><code>Brooks Pointer</code>。<code>Brooks</code>提出了使用<code>转发指针</code>（<code>Forwarding Pointer</code>，也常被称为<code>Indirection Pointer</code>）来实现对象移动与用户程序并发的一种解决方案。<code>Brooks</code>在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Brooks_Pointers.PNG" alt="Brooks Pointers示意图" /><figcaption aria-hidden="true">Brooks Pointers示意图</figcaption></figure><p>转发指针加入后带来的收益是当对象拥有了一份新的副本时，只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Brooks_Pointers2.PNG" alt="Brooks Pointers原理" /><figcaption aria-hidden="true">Brooks Pointers原理</figcaption></figure><p><strong>Brooks转发指针的多线程竞争问题</strong>：</p><ul><li>收集器线程与用户线程发生的只是并发读取，那无论读到旧对象还是新对象上的字段，返回的结果都应该是一样的；</li><li>如果发生的是并发写入，就一定必须保证<code>写操作</code>只能发生在新复制的对象上。</li></ul><p>Shenandoah收集器是通过<code>比较并交换（Compare And Swap，CAS）操作</code>来保证并发时对象的访问正确性的。</p><h4 id="zgc收集器">5.2 ZGC收集器</h4><p><code>ZGC（Z Garbage Collector）</code>是一款在 <code>JDK 11</code>中新加入的具有实验性质的低延迟垃圾收集器。ZGC和Shenandoah的目标是高度相似的，都希望<u>在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</u>。</p><h5 id="zgc的内存布局">5.2.1 ZGC的内存布局</h5><p>ZGC也采用基于Region的堆内存布局（在一些官方资料中将它称为<code>Page</code>或者<code>ZPage</code>），ZGC的Region具有<strong>动态性</strong>——<u>动态创建和销毁，以及动态的区域容量大小</u>。ZGC的 Region可以有大、中、小三类容量：</p><ul><li><code>小型Region（Small Region）</code>：容量固定为<code>2MB</code>，用于放置<u>小于</u><code>256KB</code>的小对象。</li><li><code>中型Region（Medium Region）</code>：容量固定为<code>32MB</code>，用于放置<u>大于等于</u><code>256KB</code>但<u>小于</u><code>4MB</code>的对象。</li><li><code>大型Region（Large Region）</code>：容量不固定，可以动态变化，但必须为<code>2MB</code>的<strong>整数倍</strong>，用于放置<code>4MB</code>或以上的大对象。每个大型Region中只会存放一个大对象，大型Region在ZGC的实现中<strong>不会被重分配</strong>。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ZGC_memory.PNG" alt="ZGC的堆内存布局" /><figcaption aria-hidden="true">ZGC的堆内存布局</figcaption></figure><h5 id="zgc的并发整理算法">5.2.2 ZGC的并发整理算法</h5><p>ZGC收集器采用的<code>染色指针技术</code>（<code>Colored Pointer</code>，其他类似的技术中可能将它称为<code>Tag Pointer</code>或者<code>Version Pointer</code>）。染色指针直接把标记信息记在引用对象的指针上。</p><p>在64位系统中，理论可以访问的内存高达<code>16EB</code>（<code>2的64次幂</code>）字节。基于需求 、性能和成本的考虑，在<code>AMD64</code>架构中只支持到<code>52</code>位（<code>4PB</code>）的<u>地址总线</u>和<code>48</code>位（<code>256TB</code>）的<u>虚拟地址空间</u>。</p><blockquote><p>操作系统也还会施加自己的约束，64位的<code>Linux</code>则分别支持<code>47</code>位（<code>128TB</code>）的进程虚拟地址空间和<code>46</code>位（<code>64TB</code>）的物理地址空间，64位的<code>Windows</code>系统甚至只支持<code>44</code>位（<code>16TB</code>）的物理地址空间。</p></blockquote><p>Linux下64位指针的高18位不能用来寻址，ZGC的染色指针技术利用这剩下的46位指针宽度，将其<code>高4位</code>提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的<strong>三色标记状态</strong>、<strong>是否进入了重分配集</strong>（即被移动过）、<strong>是否只能通过finalize()方法才能被访问到</strong>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Colored_Pointer.PNG" alt="染色指针" /><figcaption aria-hidden="true">染色指针</figcaption></figure><blockquote><p>这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致ZGC能够管理的内存不可以超过<code>4TB</code></p></blockquote><p>染色指针的三大优势：</p><ul><li>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</li><li>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。</li><li>染色指针可以作为一种<code>可扩展</code>的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li></ul><h5 id="虚拟内存映射技术">5.2.3 虚拟内存映射技术</h5><p>处理器会使用<code>分页管理机制</code>把线性地址空间和物理地址空间分别划分为大小相同的块，这样的内存块被称为<code>“页”（Page）</code>。通过在线性虚拟空间的页与物理地址空间的页之间建立的<code>映射表</code>，分页管理机制会进行线性地址到物理地址空间的映射，完成线性地址到物理地址的转换。</p><p><code>Linux/x86-64</code>平台上的ZGC使用了<code>多重映射（Multi-Mapping）</code>将<u>多个不同的虚拟内存地址映射到同一个物理内存地址上</u>，这是一种<strong>多对一映射</strong>，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。把染色指针中的标志位看作是<code>地址的分段符</code>，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Multi_Mapping.PNG" alt="多重映射下的寻址" /><figcaption aria-hidden="true">多重映射下的寻址</figcaption></figure><h5 id="zgc的运作过程">5.2.4 ZGC的运作过程</h5><p>ZGC的运作过程大致可划分为以下四个大的阶段。全部四个阶段<strong><u>都是可以并发执行</u></strong>的，仅是两个阶段中间会存在短暂的停顿小阶段，如初始化<code>GC Root</code>直接关联对象的<code>Mark Start</code>。</p><ul><li><code>并发标记（Concurrent Mark）</code>：并发标记是<strong>遍历对象图做可达性分析的阶段</strong>，前后也要经过初始标记、最终标记的短暂停顿。ZGC 的标记是在指针上进行的，标记阶段会更新染色指针中的<code>Marked0</code>、<code>Marked1</code>标志位。</li><li><code>并发预备重分配（Concurrent Prepare for Relocate）</code>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成<code>重分配集（Relocation Set）</code>。ZGC每次回收都会<strong>扫描所有的Region</strong>，用范围更大的扫描成本换取<u>省去G1中记忆集的维护成本</u>。</li><li><code>并发重分配（Concurrent Relocate）</code>：把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<code>转发表（Forward Table）</code>，<u>记录从旧对象到新对象的转向关系</u>。<ul><li>指针的<code>“自愈”（Self-Healing）</code>能力：ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被<code>预置的内存屏障</code>所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象。这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次。</li></ul></li><li><code>并发重映射（Concurrent Remap）</code>：重映射所做的就是<u>修正整个堆中指向重分配集中旧对象的所有引用</u>，但是ZGC重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。ZGC把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成。</li></ul><h5 id="numa-aware的内存分配">5.2.5 “NUMA-Aware”的内存分配</h5><p>ZGC支持<code>“NUMA-Aware”的内存分配</code>。<code>NUMA</code>（<code>Non-Uniform Memory Access</code>，<strong>非统一内存访问架构</strong>）是一种为多处理器或者多核处理器的计算机所设计的内存架构。在<code>NUMA</code>架构下，ZGC收集器会优先尝试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问。</p><h3 id="选择合适的垃圾收集器">6. 选择合适的垃圾收集器</h3><h4 id="epsilon收集器">6.1 Epsilon收集器</h4><p><code>Epsilon</code>这是一款以<u>不能够进行垃圾收集</u>为“卖点”的垃圾收集器。</p><blockquote><p>Epsilon收集器由<code>RedHat</code>公司在<code>JEP 318</code>中提出，在此提案里<code>Epsilon</code>被形容成一个<code>无操作的收集器（A No-Op Garbage Collector）</code>。</p></blockquote><p>一个垃圾收集器除了垃圾收集这个本职工作之外，它还要负责<u>堆的管理与布局</u>、<u>对象的分配</u>、<u>与解释器的协作</u>、<u>与编译器的协作</u>、<u>与监控子系统协作</u>等职责。Epsilon是垃圾收集器的统一接口，用于需要剥离垃圾收集器影响的性能测试和压力测试。</p><p>在实际生产环境中，不能进行垃圾收集的Epsilon也用于应对<code>短时间、小规模</code>的服务形式，只要Java虚拟机<u>能正确分配内存，在堆耗尽之前就会退出</u>，那显然运行负载极小、没有任何回收行为的Epsilon便是很恰当的选择。</p><h4 id="收集器的权衡">6.2 收集器的权衡</h4><p>选择一款适合自己应用的收集器主要受以下三 个因素影响：</p><ul><li><code>应用程序的主要关注点是什么？</code><ul><li>如果是数据分析、科学计算类的任务，目标是能尽快算出结果， 那吞吐量就是主要关注点；</li><li>如果是<code>SLA（（Service Level Agreements））</code>应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点；</li><li>而如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的。</li></ul></li><li><code>运行应用的基础设施如何？</code><ul><li>譬如硬件规格，要涉及的系统架构；</li><li>处理器的数量多少，分配内存的大小；</li><li>选择的操作系统。</li></ul></li><li>使用JDK的发行商是什么？版本号是多少？是ZingJDK/Zulu、OracleJDK、Open-JDK、OpenJ9抑或是其他公司的发行版？该JDK对应了《Java虚拟机规范》的哪个版本？</li></ul><p>实战中切不可纸上谈兵，<strong>根据系统实际情况去测试才是选择收集器的最终依据</strong>。</p><h4 id="虚拟机及垃圾收集器日志">6.3 虚拟机及垃圾收集器日志</h4><p><code>JDK 9</code>后，<code>HotSpot</code>所有功能的日志都收归到了<code>“-Xlog”</code>参数上，这个参数的能力也相应被极大拓展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog[:[selector][:[output][:[decorators][:output-options]]]]</span><br></pre></td></tr></table></figure><p>最关键的参数是<code>选择器（Selector）</code>，它由<code>标签（Tag）</code>和<code>日志级别（Level）</code>共同组成。</p><p>日志级别从低到高，共有<code>Trace，Debug，Info，Warning，Error，Off</code>六种级别，默认级别为<code>Info</code>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Log_parameter.PNG" alt="JDK 9前后日志参数变化" /><figcaption aria-hidden="true">JDK 9前后日志参数变化</figcaption></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Log_parameter2.PNG" alt="JDK 9前后日志参数变化(续)" /><figcaption aria-hidden="true">JDK 9前后日志参数变化(续)</figcaption></figure><h4 id="垃圾收集器参数总结">6.4 垃圾收集器参数总结</h4><p>具体可以查看书籍，主要还是用到的时候查一下就行。</p><h3 id="内存分配与回收策略">7. 内存分配与回收策略</h3><p>Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：<u><strong>自动给对象分配内存</strong></u>以及<u><strong>自动回收分配给对象的内存</strong></u>。对象的内存分配，从概念上讲，应该都是在堆上分配（而实际上也有可能经过<code>即时编译</code>后被拆散为标量类型并间接地在栈上分配）。</p><h4 id="对象优先在eden分配">7.1 对象优先在Eden分配</h4><p>对象在新生代<code>Eden区</code>中分配。当<code>Eden区</code>没有足够空间进行分配时，虚拟机将发起 一次<code>Minor GC</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">// 出现一次Minor GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>testAllocation()</code>中分配<code>allocation4</code>对象的语句时会发生一次<code>Minor GC</code>，产生这次垃圾收集的原因是为<code>allocation4</code>分配内存时，发现 <code>Eden</code>已经被占用了<code>6MB</code>，剩余空间已不足以分配<code>allocation4</code>所需的<code>4MB</code>内存，因此发生<code>Minor GC</code>。</p><p>垃圾收集期间虚拟机又发现已有的三个<code>2MB</code>大小的对象全部无法放入<code>Survivor</code>空间（<strong>Survivor空间只有 1MB大小</strong>），所以只好通过分配担保机制提前转移到老年代去。</p><p>收集结束后，<code>4MB</code>的<code>allocation4</code>对象顺利分配在<code>Eden</code>中。因此程序执行完的结果是<code>Eden</code>占用 <code>4MB</code>（被<code>allocation4</code>占用），<code>Survivor</code>空闲，老年代被占用<code>6MB</code>（被<code>allocation1、2、3</code>占用）。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testAllocation.PNG" alt="testAllocation运行结果" /><figcaption aria-hidden="true">testAllocation运行结果</figcaption></figure><h4 id="大对象直接进入老年代">7.2 大对象直接进入老年代</h4><p>最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。</p><blockquote><p>在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">* -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation;</span><br><span class="line">allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">//直接分配在老年代中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Eden空间几乎没有被使用，而老年代的<code>10MB</code>空间被使用了40%，也就是<code>4MB</code>的allocation对象<strong>直接就分配在老年代中</strong></p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testPretenureSizeThreshold.PNG" alt="testPretenureSizeThreshold运行结果" /><figcaption aria-hidden="true">testPretenureSizeThreshold运行结果</figcaption></figure><h4 id="长期存活的对象将进入老年代">7.3 长期存活的对象将进入老年代</h4><p>虚拟机给每个对象定义了一个<code>对象年龄（Age）计数器</code>，存储在对象头中。</p><p>对象通常在<code>Eden区</code>里诞生，如果经过第一次 <code>Minor GC</code>后仍然存活，并且能被<code>Survivor</code>容纳的话，该对象会被移动到<code>Survivor</code>空间中，并且将其对象年龄设为<code>1岁</code>。对象在<code>Survivor</code>区中每熬过一次<code>Minor GC</code>，年龄就增加<code>1岁</code>，当它的年龄增加到一定程度（默认为15），就会<strong>被晋升到老年代中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment">* -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>]; <span class="comment">// 什么时候进入老年代决定于XX:MaxTenuringThreshold设置</span></span><br><span class="line">allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">allocation3 = <span class="keyword">null</span>;</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当<code>-XX：MaxTenuringThreshold=1</code>时，<code>allocation1</code>对象在第二次<code>GC</code>发生时进入老年代， 新生代已使用的内存在垃圾收集以后非常干净地变成<code>0KB</code>。</li><li>当<code>-XX：MaxTenuringThreshold=15</code>时， 第二次<code>GC</code>发生后，<code>allocation1</code>对象则还留在新生代<code>Survivor</code>空间，这时候新生代仍然有<code>404KB</code>被占用。</li></ul><h4 id="动态对象年龄判定">7.4 动态对象年龄判定</h4><p>如果在<code>Survivor</code>空间中相同年龄所有对象大小的总和大于<code>Survivor</code>空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><h4 id="空间分配担保">7.5 空间分配担保</h4><p>在发生<code>Minor GC</code>之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间：</p><ul><li>如果这个条件成立，那这一次<code>Minor GC</code>可以确保是安全的；</li><li>如果不成立，会查看是否允许担保失败（Handle Promotion Failure）：<ul><li>如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次<code>Minor GC</code>，尽管这次<code>Minor GC</code>是有风险的；</li><li>如果小于，或设置不允许冒险，那这时就要改为进行一次<code>Full GC</code>。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。&lt;/code&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[读书|2021阅读]--《如何阅读一本书》</title>
    <link href="https://wuyunjie.top/2021/05/14/Reading_2021--How_to_Read_a_Book.html"/>
    <id>https://wuyunjie.top/2021/05/14/Reading_2021--How_to_Read_a_Book.html</id>
    <published>2021-05-14T12:30:38.000Z</published>
    <updated>2021-05-14T12:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>如何阅读一本书 <a id="more"></a></p></blockquote><h3 id="思维导图">思维导图</h3><iframe src="https://www.xmind.net/embed/3TzT/" width="750" height="1000" frameborder="0" scrolling="no" allowfullscreen="true"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;如何阅读一本书
    
    </summary>
    
      <category term="Reading" scheme="https://wuyunjie.top/categories/Reading/"/>
    
    
      <category term="Reading" scheme="https://wuyunjie.top/tags/Reading/"/>
    
      <category term="Book" scheme="https://wuyunjie.top/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--11 异常处理</title>
    <link href="https://wuyunjie.top/2021/05/14/JavaLearning_Head_First_Java_11_exception_handling.html"/>
    <id>https://wuyunjie.top/2021/05/14/JavaLearning_Head_First_Java_11_exception_handling.html</id>
    <published>2021-05-14T08:43:25.000Z</published>
    <updated>2021-05-14T08:43:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>倒霉的事情就算会发生。找不到文件、服务器出现故障。 <a id="more"></a></p></blockquote><h3 id="异常">1. 异常</h3><p>需要对可能发生的异常情况进行处理，<strong>未雨绸缪</strong>！Java的<code>异常处理机制(exception-handling)</code>将处理错误状况的代码放在一个容易阅读的位置。如果知道调用某个方法可能会有异常情况，可以预先准备问题处理程序甚至从错误中恢复。</p><blockquote><p>异常是一种<code>Exception</code>类型的对象。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/exceptionClass.PNG" alt="异常类" /><figcaption aria-hidden="true">异常类</figcaption></figure><ul><li><p><strong>抛出异常(throws)</strong>。使用<code>throws</code>语句来抛出异常。</p><p>在编写可能会抛出异常的方法时，必须先声明有异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeRisk</span><span class="params">()</span> <span class="keyword">throws</span> BadException </span>&#123; <span class="comment">// 声明会抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (abandonAllHope) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadException(); <span class="comment">// 创建异常对象并抛出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意声明时是<code>throws</code>，抛出时是<code>throw</code>。</p></blockquote></li><li><p><strong>捕捉异常(catch)</strong>。使用<code>try/catch</code>块来捕捉处理异常。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 有风险的动作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><p>非<code>RuntimeExceptions</code>子类的异常由编译器检查，称作<code>检查异常(checked exceptions)</code>；<code>RuntimeExceptions</code>类称为<code>非检查异常</code>，编译器不会检查。编译器会确保：</p><ol type="1"><li>如果有抛出异常，一定使用了<code>throws</code>来声明</li><li>如果调用会抛出异常的方法，一定知道异常可能性。即会处理异常。</li></ol><h4 id="trycatch块">1.1 try/catch块</h4><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/tryCatchFlow.PNG" alt="try/catch块流程" /><figcaption aria-hidden="true">try/catch块流程</figcaption></figure><p><code>finally</code>块用来存放不管有没有异常都需要执行的程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     turnOvenOn();</span><br><span class="line">     x.bake(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (BakingException ex) &#123; </span><br><span class="line">     ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     turnOvenOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果try或catch块有<code>return</code>指令，<strong><code>finally</code>块还是会执行</strong>！流程会跳到<code>finally</code>块然后再回到return指令。</p></blockquote><h4 id="throws">1.2 throws</h4><p>方法可以抛出多个异常，声明时必须要含有全部可能的检查异常。调用方法时，编译器会坚持是否处理了所有可能的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laundry</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> PantsException, LingerieException </span>&#123;</span><br><span class="line">         <span class="comment">// code that could throw either exception</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Laundry laundry = <span class="keyword">new</span> Laundry();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             laundry.doLaundry();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(PantsException pex) &#123;</span><br><span class="line">             <span class="comment">// recovery code</span></span><br><span class="line">         &#125; <span class="keyword">catch</span>(LingerieException lex) &#123;</span><br><span class="line">             <span class="comment">// recovery code</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常也是多态的，所以异常也可以用多态的方式引用。抛出异常时可以声明多个异常的共同父类，捕捉异常时也同理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     laundry.doLaundry();</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClothingException cex) &#123;</span><br><span class="line">     <span class="comment">// recovery code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的确可以用<code>Exception</code>来捕捉所有异常，但也会在处理异常时无法精确定位捕捉到了何种异常。使用<code>catch</code>来处理异常时，在继承数中高层次的异常不能放到低层次的异常之前。</p><h4 id="duck异常">1.3 duck异常</h4><blockquote><p>如果不想处理异常，可以把它duck掉来避开。</p></blockquote><p>也就是不用try/catch处理异常，而是再度throw该异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Washer</span> </span>&#123;</span><br><span class="line">     Laundry laundry = <span class="keyword">new</span> Laundry();</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException </span>&#123; </span><br><span class="line">         laundry.doLaundry();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> ClothingException </span>&#123;</span><br><span class="line">         Washer a = <span class="keyword">new</span> Washer();</span><br><span class="line">         a.foo();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/duckException.PNG" alt="duck异常" /><figcaption aria-hidden="true">duck异常</figcaption></figure><h4 id="异常处理规则">1.4 异常处理规则</h4><ol type="1"><li><code>catch</code>与<code>finally</code>不能没有<code>try</code>；</li><li><code>try</code>与<code>catch</code>之间不能有程序；</li><li><code>try</code>一定要有<code>catch</code>或<code>finally</code>；</li><li>只带有<code>finally</code>的方法必须duck异常(即声明)。</li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/exceptionRules.PNG" alt="异常处理规则" /><figcaption aria-hidden="true">异常处理规则</figcaption></figure><h3 id="创建midi音乐播放器">2. 创建<code>MIDI</code>音乐播放器</h3><p><code>MIDI</code>音乐播放器，类似一款乐队软件。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/MIDI.PNG" alt="MIDI音乐播放器" /><figcaption aria-hidden="true"><code>MIDI</code>音乐播放器</figcaption></figure><h4 id="javasound-api">2.1 <code>JavaSound</code> API</h4><p><code>JavaSound</code> API是<code>Java 1.3</code>后加入的一组类和接口，分为两部分：<code>MIDI(Musical Instrument Digital Interface)</code>和<code>取样(sampled)</code>。<code>MIDI</code>是不同电子发声装置沟通的标准协议，可以想象成<code>乐谱</code>，可以输入到“高级多功能电子魔音琴”中。</p><blockquote><p><code>MIDI</code>本身不带有声音，它带有的是有MIDI播放功能装置的指令</p></blockquote><h4 id="sequencer">2.2 Sequencer</h4><p>先获取<code>Sequencer</code>对象，它会将所有MIDI数据送到正确的装置上，由装置来产生音乐。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sequencer sequencer = MidiSystem.getSequencer();</span><br></pre></td></tr></table></figure><p>直接调用无法通过编译，编译器显式需要处理异常。API中说明<code>getSequencer()</code>可能会抛出<code>MidiUnavailableException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MusicTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Sequencer sequencer = MidiSystem.getSequencer();</span><br><span class="line">            System.out.println(<span class="string">"We get a sequencer"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MidiUnavailableException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Bummer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MusicTest1 mt = <span class="keyword">new</span> MusicTest1();</span><br><span class="line">        mt.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以下是<code>JavaSound</code>的工作原理：</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JavaSoundWorkFlow.PNG" alt="JavaSound的工作原理" /><figcaption aria-hidden="true"><code>JavaSound</code>的工作原理</figcaption></figure><ul><li>运行该播放器需要5个步骤：</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/fiveStepOfMIDI.PNG" alt="JavaSound的工作原理" /><figcaption aria-hidden="true"><code>JavaSound</code>的工作原理</figcaption></figure><blockquote><p>第5步是开始播放：<code>player.start();</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniMiniMusicApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiniMiniMusicApp mini = <span class="keyword">new</span> MiniMiniMusicApp();</span><br><span class="line">        mini.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个Sequencer并打开</span></span><br><span class="line">            Sequencer player = MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            Sequence seq = <span class="keyword">new</span> Sequence(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取一道音轨</span></span><br><span class="line">            Track track = seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage a = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOn = <span class="keyword">new</span> MidiEvent(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            ShortMessage b = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOff = <span class="keyword">new</span> MidiEvent(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Sequence放到Sequencer上(相对于把CD放到CD机上)</span></span><br><span class="line">            player.setSequence(seq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始播放</span></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="制作midievent">2.3 制作<code>MidiEvent</code></h4><p><code>MidiEvent</code>是组合乐曲的指令，一连串<code>MidiEvent</code>如同乐谱。必须在<code>MidiEvent</code>中指定何时开始播放某个音符(<code>NOTE ON event</code>)以及何时停止(<code>NOTE OFF event</code>)。</p><p><code>Midi</code>指令实际上放在<code>Message</code>对象中，<code>MidiEvent</code>由<code>Message</code>和发音时机组成。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/MidiEvent.PNG" alt="MidiEvent" /><figcaption aria-hidden="true">MidiEvent</figcaption></figure><p><code>Message</code>中信息的格式：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/AnatomyMessage.PNG" alt="信息的格式" /><figcaption aria-hidden="true">信息的格式</figcaption></figure><p>使用命令行参数版本的播放器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniMusicCmdLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiniMusicCmdLine mini = <span class="keyword">new</span> MiniMusicCmdLine();</span><br><span class="line"><span class="comment">//        if (args.length &lt; 2) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Don’t forget the instrument and note args");</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            int instrument = Integer.parseInt(args[0]);</span></span><br><span class="line"><span class="comment">//            int note = Integer.parseInt(args[1]);</span></span><br><span class="line"><span class="comment">//            mini.play(instrument, note);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Input the instrument and note"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                String instrumentS = <span class="keyword">null</span>;</span><br><span class="line">                instrumentS = is.readLine();</span><br><span class="line">                String noteS = <span class="keyword">null</span>;</span><br><span class="line">                noteS = is.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> instrument = Integer.parseInt(instrumentS);</span><br><span class="line">                <span class="keyword">int</span> note = Integer.parseInt(noteS);</span><br><span class="line">                mini.play(instrument, note);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(<span class="keyword">int</span> instrument, <span class="keyword">int</span> note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个Sequencer并打开</span></span><br><span class="line">            Sequencer player = MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            Sequence seq = <span class="keyword">new</span> Sequence(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line">            <span class="comment">// 获取一道音轨</span></span><br><span class="line">            Track track = seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage first = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            first.setMessage(<span class="number">192</span>, <span class="number">1</span>, instrument, <span class="number">0</span>);</span><br><span class="line">            MidiEvent changeInstrument = <span class="keyword">new</span> MidiEvent(first, <span class="number">1</span>);</span><br><span class="line">            track.add(changeInstrument);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage a = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOn = <span class="keyword">new</span> MidiEvent(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            ShortMessage b = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOff = <span class="keyword">new</span> MidiEvent(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Sequence放到Sequencer上(相对于把CD放到CD机上)</span></span><br><span class="line">            player.setSequence(seq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始播放</span></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;倒霉的事情就算会发生。找不到文件、服务器出现故障。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
</feed>
