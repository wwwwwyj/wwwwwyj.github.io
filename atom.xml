<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuYJ&#39;s Blog</title>
  
  <subtitle>wuyunjie的小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuyunjie.top/"/>
  <updated>2021-05-20T14:41:12.000Z</updated>
  <id>https://wuyunjie.top/</id>
  
  <author>
    <name>wuyunjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--4 虚拟机性能监控、故障处理工具</title>
    <link href="https://wuyunjie.top/2021/05/20/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_4_Performance_monitoring_fault_handling.html"/>
    <id>https://wuyunjie.top/2021/05/20/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_4_Performance_monitoring_fault_handling.html</id>
    <published>2021-05-20T14:41:12.000Z</published>
    <updated>2021-05-20T14:41:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code> <a id="more"></a></p></blockquote><h3 id="基础故障处理工具">1. 基础故障处理工具</h3><p>除了编译和运行Java程序外，打包、部署、签名、调试、监控、运维等各种场景都可能会用到<code>JDK</code>的<code>bin</code>目录下的小工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。&lt;/code&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--十大遗珠之憾</title>
    <link href="https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html"/>
    <id>https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html</id>
    <published>2021-05-20T05:13:54.000Z</published>
    <updated>2021-05-20T05:13:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>什么！有完没完啊？这本书到底还要看多久？ <a id="more"></a></p></blockquote><h3 id="枚举又称为枚举类型或enum">1. 枚举(又称为枚举类型或<code>Enum</code>)</h3><p>枚举类型定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Members &#123; JERRY, BOBBY, PHIL &#125;;</span><br><span class="line"><span class="keyword">public</span> Members selectedBandMember;</span><br><span class="line"></span><br><span class="line"><span class="comment">// later in the code</span></span><br><span class="line"><span class="keyword">if</span> (selectedBandMember == Members.JERRY) &#123;</span><br><span class="line"><span class="comment">// do JERRY related stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在<code>enum</code>中加入构造函数、方法、变量和特定常量的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HfjEnum</span> </span>&#123;</span><br><span class="line"><span class="keyword">enum</span> Names &#123;</span><br><span class="line">        <span class="comment">// 传给下方定义构造函数的参数</span></span><br><span class="line">JERRY(“lead guitar”) &#123; <span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “plaintively”; &#125;&#125;,</span><br><span class="line">BOBBY(“rhythm guitar”) &#123; <span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “hoarsely”; &#125;&#125;,</span><br><span class="line">PHIL(“bass”);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String instrument;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// enum的构造函数，会对每个被声明的enum值执行一次</span></span><br><span class="line">        Names(String instrument) &#123;</span><br><span class="line">            <span class="keyword">this</span>.instrument = instrument;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInstrument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.instrument;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> “occasionally”;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Names n : Names.values()) &#123;</span><br><span class="line">            System.out.print(n);</span><br><span class="line">            System.out.print(“, instrument: “+ n.getInstrument());</span><br><span class="line">            System.out.println(“, sings: “ + n.sings());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组">2. 多维数组</h3><p>Java中，二维数组实际上是一个<strong><code>数组的数组</code></strong>。</p><h3 id="string-and-stringbufferstringbuilder-methods">3. <code>String</code> and <code>StringBuffer/StringBuilder</code> Methods</h3><p><code>Java 5.0</code>起，应该用<code>StringBuilder</code>取代<code>StringBuffer</code>。<code>StringBuffer/StringBuilder</code> 来操作字符串更有效率。</p><h3 id="存取权限和存取修饰符">4. 存取权限和存取修饰符</h3><p><code>Java</code>有4种存取权限等级与3种存取修饰符。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/AccessLevelsModifiers.PNG" alt="存取权限和存取修饰符" /><figcaption aria-hidden="true">存取权限和存取修饰符</figcaption></figure><h3 id="anonymous和static-nested-classes">5. <code>Anonymous</code>和<code>Static Nested Classes</code></h3><p><code>静态嵌套类</code>可以不需要外部类的实例就调用，但还是被看作外部类的一个成员，能够存取任何外部类的静态成员(包括私有)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooOuter</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarInner</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“method of a <span class="keyword">static</span> inner <span class="class"><span class="keyword">class</span>”)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FooOuter.BarInner foo = <span class="keyword">new</span> FooOuter.BarInner();</span><br><span class="line">        foo.sayIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>匿名的内部类</code>，是在需要传入一个实例的地方创建一个类，并把整个类作为参数传进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnon</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line">JButton button = <span class="keyword">new</span> JButton(“click”);</span><br><span class="line">frame.getContentPane().add(button);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// button.addActionListener(quitListener);</span></span><br><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent ev)</span> </span>&#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接的调用">6. 连接的调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"spring"</span>);</span><br><span class="line">sb = sb.delete(<span class="number">3</span>,<span class="number">6</span>).insert(<span class="number">2</span>,<span class="string">"umme"</span>).deleteCharAt(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>第二行程序从左到右执行。如下调用方法可以调用方法又不需要维护一个引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo().go();</span><br></pre></td></tr></table></figure><h3 id="块区域">7. 块区域</h3><p>区段程序代码通常在方法中，以<code>{}</code>字符来区分。在某个块区域中声明的变量，一旦离开块区域，就超出范围，无法再被使用。</p><h3 id="断言">8. 断言</h3><p>断言的使用类似<code>println()</code>，执行时未特别设定，被加入到程序中的<code>assert</code>命令会被Java虚拟机忽略。只有打开断言，才会输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> (height &gt; <span class="number">0</span>); </span><br><span class="line"><span class="comment">// if true, program continues normally</span></span><br><span class="line"><span class="comment">// if false, throw an AssertionError</span></span><br></pre></td></tr></table></figure><p>也可以加入信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> (height &gt; <span class="number">0</span>) : <span class="string">"height = "</span> + height + <span class="string">" weight = "</span> + weight;</span><br></pre></td></tr></table></figure><h3 id="不变性">9. 不变性</h3><p><code>String</code>的不变性，主要为了安全性和节省空间。比如下面的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = “<span class="number">0</span>”;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">     s = s + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上创建了<code>10</code>个<code>String</code>对象("0", "01", ..., "0123456789")。创建新<code>String</code>时，<code>JVM</code>会把它放在<code>"String Pool"</code>的特殊存储区域，如果已经出现同值的<code>String</code>，JVM不会重复建立<code>String</code>，会引用已经存在的内容。因为<code>String</code>是不变的，引用变量无法改变其他参数变量引用到的同一个<code>String</code>值。</p><p><code>包装类</code>也具有不变性。</p><h3 id="位操作">10. 位操作</h3><ul><li>按位非运算：<code>~</code></li><li>按位与运算：<code>&amp;</code></li><li>按位或运算：<code>|</code></li><li>按位异或运算：<code>^</code></li><li>右移运算：<code>&gt;&gt;</code></li><li>无符号右移：<code>&gt;&gt;&gt;</code>。第一位补<code>0</code>，正负号可能改变。</li><li>左移运算符：<code>&lt;&lt;</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;什么！有完没完啊？这本书到底还要看多久？
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--18 远程部署的RMI</title>
    <link href="https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_18_remote%20deployment_with_RMI.html"/>
    <id>https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_18_remote deployment_with_RMI.html</id>
    <published>2021-05-20T02:44:05.000Z</published>
    <updated>2021-05-20T02:44:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>分布式计算，距离不是问题。 <a id="more"></a></p></blockquote><h3 id="远程过程调用的设计">1. 远程过程调用的设计</h3><p>远程过程调用(<code>Remote Method Invocation, RMI</code>)要建出4种东西：<code>服务器</code>、<code>客户端</code>、<code>服务器辅助设施</code>和<code>客户端辅助设施</code>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/remoteMethod.PNG" alt="远程过程调用的设计" /><figcaption aria-hidden="true">远程过程调用的设计</figcaption></figure><h4 id="辅助设施的任务">1.1 <code>辅助设施</code>的任务</h4><p>辅助设施是个在实际上执行通信的对象，会让客户端对象看起来在调用远程的方法。辅助设施会去连接服务器，将调用的信息传送过去，然后等待服务器的响应。</p><p>服务器的辅助设施会接受客户端辅助设施打包的信息，调用真正的服务，然后取得返回值送回客户端辅助设施。</p><h4 id="创建远程服务">1.2 创建远程服务</h4><p>创建远程服务有5个步骤：</p><ol type="1"><li><p>创建<code>Remote</code>接口。远程接口定义了客户端可以远程调用的方法，是一个作为服务的多态化类。stub和服务都会实现此接口。</p><ul><li><p>继承<code>java.rmi.Remote</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRemote</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明所有方法都会抛出<code>RemoteException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRemote</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确定参数和返回值都是<code>primitive主数据类型</code>或<code>Serializable</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>实现<code>Remote</code>。真正执行的类，实现定义在该接口上的方法。</p><ul><li><p>实现<code>Remote</code>接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRemoteImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">MyRemote</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “Server says, ‘Hey’”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// more code in class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承<code>UnicastRemoteObject</code>。对象必须要有远程相关功能，最简单的方式就是继承<code>UnicastRemoteObject</code>类来处理。</p></li><li><p>编写声明<code>RemoteException</code>的无参数构造函数；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyRemoteImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>向<code>RMI registry</code> 注册服务。将服务初始化并加入<code>RMI registry</code> ，<code>RMI</code>系统会把<code>stub</code>加到<code>registry</code>中。使用<code>java.rmi.Naming</code>的<code>rebind</code>方法来注册服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    MyRemote service = <span class="keyword">new</span> MyRemoteImpl();</span><br><span class="line">    <span class="comment">// 帮助服务命名，并向RMI registry注册</span></span><br><span class="line">    Naming.rebind(“Remote Hello”, service);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用<code>rmic</code>产生<code>stub</code>与<code>skeleton</code>。由<code>JDK</code>附带的<code>rmic</code>工具自动处理。</p><ul><li><p>对实现出的类执行<code>rmic</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmic MyRemoteImpl</span><br></pre></td></tr></table></figure><p><code>Java software development kit(JDK)</code>中的<code>rmic</code>工具会以服务的实现产生连个新类：<code>stub</code>和<code>skeleton</code>。</p></li></ul></li><li><p>启动<code>RMI registry</code> (<code>rmiregistry</code>)。用户从此处获取代理。</p><ul><li><p>在命令行启动<code>rmiregistry</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmiregistry</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动远程服务。实现服务的类会启动服务的实例并向<code>RMI registry</code> 注册，要有注册才能对用户提供服务。</p><ul><li><p>启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java MyRemoteImpl</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="客户端获取stub">1.3 客户端获取<code>stub</code></h4><p>客户端需要获取<code>stub</code>对象，这需要<code>RMI registry</code>，客户端从上面查询得到有相符名称的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyRemote service = (MyRemote) Naming.lookup(<span class="string">"rmi://127.0.0.1/Remote Hello"</span>);</span><br></pre></td></tr></table></figure><ul><li><p>客户端查询<code>RMI registry</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Naming.lookup(<span class="string">"rmi://127.0.0.1/Remote Hello"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>RMI registry</code>返回<code>stub</code>对象，<code>RMI</code>会自动将<code>stub</code>解序列化。</p></li><li><p>客户端可以调用<code>stub</code>上的方法</p></li></ul><h3 id="servlets">2. Servlets</h3><p><code>Servlets</code>是放在<code>Http Web</code>服务上面运行的Java程序，用户通过浏览器与网页交互时，如果请求需要Java的<code>Servlets</code>时，服务器会执行或调用已经执行的<code>Servlets</code>程序代码。</p><blockquote><p><code>Servlets</code>只运行在服务器上。</p></blockquote><ul><li>用户在网页上填写表格并提交，<code>HTTP</code>服务器受到请求，判断需要<code>Servlets</code>就传送该请求</li><li><code>Servlets</code>开始执行，把数据存入数据库，然后返回内容给浏览器。</li></ul><p>创建并执行<code>Servlets</code>的步骤：</p><ol type="1"><li><p>找出可以存放<code>Servlets</code>的地方</p></li><li><p>取得<code>Servlets.jar</code>并添加到<code>classpath</code>上。<code>Servlets</code>不是标准库的一部分，需要单独下载。</p></li><li><p>通过继承<code>HttpServlet</code>来编写<code>Servlet</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletA</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>编写<code>HTML</code>来调用<code>Servlet</code></p></li><li><p>给服务器设定HTML网页和<code>Servlet</code></p></li></ol><h3 id="enterprise-javabeans">3. Enterprise JavaBeans</h3><p><code>Enterprise JavaBeans(EJB)</code>服务器作用与<code>RMI</code>调用和服务层之间，支持交易管理、安全性、并发性、数据库和网络功能等。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/EJB.PNG" alt="EJB架构的一部分" /><figcaption aria-hidden="true">EJB架构的一部分</figcaption></figure><h3 id="jini">4. Jini</h3><p><code>Jini</code>也是使用<code>RMI</code>，但有几个关键功能：</p><ol type="1"><li>自适应探索(<code>Adaptive discovery</code>)</li><li>自恢复网络(<code>Self-healing networks</code>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;分布式计算，距离不是问题。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--17 包、jar存档文件和部署</title>
    <link href="https://wuyunjie.top/2021/05/19/JavaLearning_Head_First_Java_17_package_jars_and_deployment.html"/>
    <id>https://wuyunjie.top/2021/05/19/JavaLearning_Head_First_Java_17_package_jars_and_deployment.html</id>
    <published>2021-05-19T15:21:49.000Z</published>
    <updated>2021-05-19T15:21:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>该放手了。 <a id="more"></a></p></blockquote><h3 id="部署应用程序">1. 部署应用程序</h3><p>可以有多种部署选择：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/DeploymentOptions.PNG" alt="部署选择" /><figcaption aria-hidden="true">部署选择</figcaption></figure><p>首先需要将源代码与<code>class</code>文件分离，关键在于结合<code>-d</code>这个编译选项和目录组织的结构。</p><blockquote><p>将源代码(<code>.java</code>)存储在<code>source</code>目录下，将编译输出的类文件(<code>.class</code>)放入<code>classes</code>目录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/<span class="built_in">source</span></span><br><span class="line">javac -d ../classes MyApp.java</span><br></pre></td></tr></table></figure><h4 id="把程序打包为jar">1.1 把程序打包为JAR</h4><p><code>JAR</code>即<code>Java ARchive</code>，这种文件是<code>pkzip</code>格式的文件，能把一组类文件包装起来。创建可执行的<code>JAR</code>分为以下步骤：</p><ol type="1"><li><p>确定所有的类文件都在<code>classes</code>目录下；</p></li><li><p>创建<code>manifest.txt</code>文件描述哪个类带有<code>main()</code>方法，该文件带有下面一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Main-Class: MyApp</span><br></pre></td></tr></table></figure><p>此行后面要有换行，该文件放入<code>classes</code>目录</p></li><li><p>执行<code>jar</code>工具来创建带有<strong>所有类</strong>以及<code>manifest</code>的<code>JAR</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/classes </span><br><span class="line">jar -cvmf manifest.txt app1.jar *.class</span><br><span class="line">OR</span><br><span class="line">jar -cvmf manifest.txt app1.jar MyApp.class</span><br></pre></td></tr></table></figure></li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/makingJAR.PNG" alt="创建JAR" /><figcaption aria-hidden="true">创建JAR</figcaption></figure><p><code>JVM</code>能从<code>JAR</code>中载入类，并调用该类的<code>main()</code>方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar app1.jar</span><br></pre></td></tr></table></figure><p>可以用包防止类名称的冲突。<code>Sun</code>建议加上所取得的域名(<code>domain</code>)名称来保证包名称不会重复。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/domainPackageNames.PNG" alt="使用域名的包名称" /><figcaption aria-hidden="true">使用域名的包名称</figcaption></figure><p>需要把类放在与包层次结构相对应的目录结构下：</p><ol type="1"><li><p>选择包名称。</p></li><li><p>在类中加入包指令。这必须是程序源码的第一个语句，在<code>import</code>之上。每个源文件中只能有一个包指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.headfirstjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageExercise</span> </span>&#123;</span><br><span class="line">     <span class="comment">// life-altering code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设定相对应的目录结构。按照包层次结构来放置类文件</p></li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/packageHierarchy.PNG" alt="包层次结构" /><figcaption aria-hidden="true">包层次结构</figcaption></figure><ol start="4" type="1"><li><p>编译和执行<code>JAR</code></p><ul><li><p>加上<code>-d</code>选项来编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">%编译器把输出放到class目录下正确的位置</span><br><span class="line">javac -d ../classes com/headfirstjava/PackageExercise.java</span><br><span class="line"></span><br><span class="line">%编译com.headfirstjava包下所有.java文件</span><br><span class="line">javac -d ../classes com/headfirstjava/*.java</span><br></pre></td></tr></table></figure></li><li><p>执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/classes</span><br><span class="line">java com.headfirstjava.PackageExercise</span><br></pre></td></tr></table></figure><p>一旦类被包进包中后，就不能使用“简写”名称来调用它，必须在命令栏指定要执行<code>main()</code>的类完整名称。</p></li></ul></li></ol><p>还可以条列和解压<code>JAR</code>包：</p><ul><li><p>将<code>JAR</code>内容列出，<code>-tf</code>代表<code>Table File</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -tf packEx.jar</span><br></pre></td></tr></table></figure></li><li><p>解压<code>JAR</code>内容，<code>-xf</code>代表<code>eXtract File</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Skyler</span><br><span class="line">jar -xf packEx.jar</span><br></pre></td></tr></table></figure></li></ul><h4 id="java-web-start">1.2 Java Web Start</h4><p><code>Java Web Start(JWS)</code>可以让用户从浏览器上执行首次启动，一旦程序下载后就可以独立于浏览器执行。</p><ul><li><code>JWS</code>下载程序时会调用程序的<code>main()</code>，然后用户可以通过<code>JWS helper app</code>启动应用程序而无需回到网页</li><li><code>JWS</code>能偶检测服务器上应用程序局部更新，自动下载和整合更新过的程序</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JWS.PNG" alt="Java Web Start工作方式" /><figcaption aria-hidden="true">Java Web Start工作方式</figcaption></figure><p><code>.jnlp</code>(<code>Java  Network Launch Protocol</code>)文件用于创建JWS应用程序，<code>JWS</code>会读取文件来寻找<code>JAR</code>并启动应用程序，<code>.jnlp</code>是个简单的<code>XML</code>文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;该放手了。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--16 集合与泛型</title>
    <link href="https://wuyunjie.top/2021/05/19/JavaLearning_Head_First_Java_16_collections_and_generics.html"/>
    <id>https://wuyunjie.top/2021/05/19/JavaLearning_Head_First_Java_16_collections_and_generics.html</id>
    <published>2021-05-19T04:55:36.000Z</published>
    <updated>2021-05-19T04:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>排序在Java中只是雕虫小技。 <a id="more"></a></p></blockquote><h3 id="集合">1. 集合</h3><p><code>ArrayList</code>是最常用的集合，此外还有一些较为重要的集合：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/collector.PNG" alt="一些集合类" /><figcaption aria-hidden="true">一些集合类</figcaption></figure><p>可以使用<code>TreeSet</code>或<code>Collections.sort()</code>方法对集合元素排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(songList);</span><br></pre></td></tr></table></figure><p>若将<code>ArrayList</code>声明为自定义类(如<code>Song</code>)的数组，使用<code>Collections.sort()</code>将无法通过编译。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/sortMethod.PNG" alt="sort方法定义" /><figcaption aria-hidden="true">sort方法定义</figcaption></figure><blockquote><p><code>sort()</code>方法取只能接受<code>Comparable</code>对象的<code>list</code>。</p></blockquote><h4 id="collections接口">1.1 Collections接口</h4><p><code>Collections</code>主要有<code>3</code>个接口：<code>List</code>，<code>Set</code>和<code>Map</code>。</p><ul><li><code>List</code>是一种知道索引位置的集合，可以存在重复元素。</li><li><code>Set</code>知道某物是否存在于集合中，它不允许重复。</li><li><code>Map</code>使用成对的键值(<code>key</code>)和数据值(<code>value</code>)，<code>key</code>可以引用相同的对象，但<code>key</code>自身不能重复。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/collectorTree.PNG" alt="Collection API" /><figcaption aria-hidden="true">Collection API</figcaption></figure><h4 id="对象等价">1.2 对象等价</h4><ul><li><code>引用相等性</code>。堆上同一对象的两个引用，引用对堆上同一个对象的两个引用时相等的。如果这两个引用调用<code>hashCode</code>，会得到相同的结果。使用<code>==</code>来比较变量上的子节组合，判断引用是否相等。</li><li><code>对象相等性</code>。堆上的两个不同对象在意义上是相同的，要把两个不同的对象视为相等，需要覆盖<code>hashCode</code>方法与<code>equals</code>方法。</li></ul><blockquote><p>要让<code>set</code>把对象视为重复的，必须满足<code>equals</code>和<code>hashCode</code>返回两对象相等。</p></blockquote><p><code>equals</code>和<code>hashCode</code>的相关规定：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/hashCodeEquals.PNG" alt="equals和hashCode" /><figcaption aria-hidden="true"><code>equals</code>和<code>hashCode</code></figcaption></figure><h4 id="treeset">1.3 TreeSet</h4><p>使用<code>TreeSet</code>必须使得以下一项为真：</p><ul><li><p>集合中的元素必须是有实现<code>Comparable</code>的类型；</p></li><li><p>使用重载、取用<code>Comparator</code>参数的构造函数创建<code>TreeSet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BookCompare bCompare = <span class="keyword">new</span> BookCompare();</span><br><span class="line">TreeSet&lt;Book&gt; tree = <span class="keyword">new</span> TreeSet&lt;Book&gt;(bCompare);</span><br></pre></td></tr></table></figure></li></ul><h4 id="map">1.4 Map</h4><p><code>Map</code>的元素实际上是两个对象：关键词(key)和值(value)。值可以重复，但key不能重复。通过<code>Map</code>可以用名称来取值等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; scores = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">scores.put(“Kathy”, <span class="number">42</span>);</span><br><span class="line">scores.put(“Bert”, <span class="number">343</span>);</span><br><span class="line">scores.put(“Skyler”, <span class="number">420</span>);</span><br></pre></td></tr></table></figure><h3 id="泛型">2. 泛型</h3><p><code>&lt;&gt;</code>符号代表<code>泛型(generic)</code>正在起作用，它是从<code>Java 5.0</code>开始加入的特质。泛型的主要目的是能够获取有<u>更好的类型安全性的集合</u>。</p><blockquote><p>在泛型出现前，没有办法什么<code>ArrayList</code>的类型，所以只能用<code>Object</code>来操作。各种对象以引用的形式加入到<code>ArrayList</code>中，出来时会是<code>Object</code>类型的引用。</p></blockquote><p>使用泛型后，能定义<code>ArrayList</code>类型，在取出时还是该类型的引用。此外也不能在该<code>ArrayList</code>中加入非该类的对象。关于泛型几件重要的事：</p><ol type="1"><li><p>创建被泛型化类的实例。比如创建<code>ArrayList</code>时必须指定它所容许的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ArrayList&lt;Song&gt;()</span><br></pre></td></tr></table></figure></li><li><p>声明与指定泛型类型的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Song&gt; songList = <span class="keyword">new</span> ArrayList&lt;Song&gt;()</span><br></pre></td></tr></table></figure></li><li><p>声明(与调用)取用泛型类型的方法。</p></li></ol><h4 id="泛型的类">2.1 泛型的类</h4><p>查看泛型化类型，有两个关键的部分：</p><ol type="1"><li>类的声明。</li><li>新增元素的方法的声明。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; ... </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>E</code>部分会用所声明和创建的真正类型来取代，<code>E</code>代指<code>Element</code>。在新增元素的方法中，也用<code>E</code>指示可以加入<code>ArrayList</code>的元素类型。</li><li>这里<code>E</code>并不是关键词，硬性规定的。也可以用其他合法字符串来当作类型参数。习惯用法是以单一字母表示。</li></ul></blockquote><h4 id="泛型的方法">2.2 泛型的方法</h4><p>泛型的类代表类的声明用到类型参数。泛型的方法代表方法的声明特征用到类型参数。</p><ol type="1"><li><p>使用定义在类声明的类型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; ... </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>声明类的类型参数后，就可以直接把该类或接口类型用在任何地方。</p></li><li><p>使用未定义在类声明的类型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure><p>如果类本身未使用类型参数，可以通过在返回类型之前指定给该方法。<code>&lt;T extends Animal&gt;</code>意味着<code>T</code>可以是任意一种<code>Animal</code>。</p></li></ol><p>这里需要注意的是，以下两种方法的声明合法，但意义不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;Animal&gt; list)</span></span></span><br></pre></td></tr></table></figure><p><code>&lt;T extends Animal&gt;</code>是方法声明的一部分，表示任何被声明未<code>Animal</code>或<code>Animal</code>的子类型的<code>ArrayList</code>是合法的。可以使用<strong>任意一种</strong><code>Animal</code>的<code>ArrayList</code>。</p><p>但下面的方法中<code>ArrayList&lt;Animal&gt; list</code>代表只有<code>ArrayList&lt;Animal&gt;</code>是合法的，也就是它<strong>只能使用</strong><code>Animal</code>的<code>ArrayList</code>。</p><h4 id="sort方法中的泛型">2.3 <code>sort()</code>方法中的泛型</h4><p>回到<code>sort()</code>方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure><p>实际上<code>Comparable</code>是一个接口，但以泛型的观点，<code>extends</code>代表<code>extends</code>或<code>implement</code>。所以必须实现<code>Comparable</code>才能把类的<code>ArrayList</code>传给<code>sort</code>。只有一个方法需要实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compareTo</code>方法会判别在排序位置上某个对象是高于、低于或等于另一个对象。<code>sort()</code>有重载方法，可以取用称为<code>Comparator</code>的参数。<code>Comparator</code>是独立的类，因此可以实现不同的比较方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用规则如下：</p><ul><li>调用单一参数的<code>sort(List o)</code>方法代表由<code>List</code>元素上的<code>compareTo</code>方法来决定顺序，需要实现<code>Comparable</code>接口。</li><li>调用<code>sort(List o, Comparator c)</code>方法代表不会调用<code>list</code>元素的<code>compareTo</code>方法，而会使用<code>Comparator</code>的<code>compare</code>方法，这种情况下list元素不需要实现<code>Comparable</code>接口。</li></ul><h4 id="多态与泛型">2.4 多态与泛型</h4><p>在普通的多态中，定义如下函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(Animal a: animals) &#123;</span><br><span class="line">         a.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法只能取用<code>ArrayList&lt;Animal&gt;</code>参数，而不能传入<code>ArrayList&lt;Dog&gt;</code>或<code>ArrayList&lt;Cat&gt;</code>，以为如果程序执行如下代码时，会出现类型错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">animals.add(<span class="keyword">new</span> Cat());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数换成数组时尽管能通过编译，但在执行时也会出错。</p><blockquote><p>数组的类型在运行期间检查，集合的类型检查只发生在编译期间。</p></blockquote><p>可以使用泛型的<code>万用字符(wildcard)</code>来解决这个问题。创建出可以接受<code>Animal</code>子类型参数的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;? extends Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(Animal a: animals) &#123;</span><br><span class="line">     a.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用带有<code>&lt;?&gt;</code>的声明时，编译器会组织任何可能破坏引用参数所指集合的行为。</p><ul><li>可以调用<code>list</code>中任何元素的方法，但不能加入元素。即可以操作集合元素，但不能新增集合元素，以保证安全性。</li></ul><p>两种不同的语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;? extends Animal&gt; list)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;排序在Java中只是雕虫小技。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--15 网络与线程</title>
    <link href="https://wuyunjie.top/2021/05/18/JavaLearning_Head_First_Java_15_networking_and_threads.html"/>
    <id>https://wuyunjie.top/2021/05/18/JavaLearning_Head_First_Java_15_networking_and_threads.html</id>
    <published>2021-05-18T10:46:26.000Z</published>
    <updated>2021-05-18T10:46:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>连接到外面的世界。 <a id="more"></a></p></blockquote><h3 id="客户端client与服务器server">1. 客户端(Client)与服务器(Server)</h3><p>客户端必须要认识服务器，服务器必须要认识所有的客户端。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientAndServer.PNG" alt="客户端与服务器" /><figcaption aria-hidden="true">客户端与服务器</figcaption></figure><p>工作方式如下：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientAndServerWorks.PNG" alt="客户端与服务器工作方式" /><figcaption aria-hidden="true">客户端与服务器工作方式</figcaption></figure><p>连接、传送与接受：</p><p>客户端要连接服务器需要做三件事：</p><ol type="1"><li>建立客户端与服务器之间的初始连接</li><li>传送信息到服务器</li><li>接受来自服务器的信息</li></ol><p>Java API的网络功能包(<code>java.net</code>)对底层工作细节进行了封装。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientConnectServer.PNG" alt="客户端" /><figcaption aria-hidden="true">客户端</figcaption></figure><h4 id="socket连接">1.1 Socket连接</h4><p>连接到其他机器需要<code>Socket连接</code>，<code>Socket</code>是代表两台机器间网络连接的对象(<code>java.net.Socket</code>)。创建Socket连接需要两项关于<strong>服务器</strong>的信息：<code>IP地址</code>和<code>端口号</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"196.164.1.103"</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>Socket连接的建立代表两台机器间有对方的信息(包括<code>IP地址</code>和<code>端口号</code>)</p><p><code>TCP</code>端口是一个<code>16</code>位宽、用来识别服务器上特定程序的数字。一个地址可以有<code>65536</code>个不同的端口号可用。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/wellKnownTCPPort.PNG" alt="常用的TCP端口号" /><figcaption aria-hidden="true">常用的TCP端口号</figcaption></figure><blockquote><p><code>0~1023</code>的<code>TCP</code>端口号预留给已知特定服务使用，可以从<code>1024~65535</code>中选择端口号用于自定义程序</p></blockquote><p>不同程序不能共享一个端口，使用(也叫绑定)某个已被占用的端口，会受到<code>BindException</code>异常。</p><h4 id="读取socket数据">1.2 读取Socket数据</h4><p>可以用串流来通过Socket连接沟通，即使用<code>BufferedReader</code>从<code>Socket</code>上读取数据，而不管串流来自文件还是Socket。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 建立对服务器的Socket连接</span></span><br><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立连接到Socket上低层输入串流的InputStreamReader</span></span><br><span class="line">InputStreamReader stream = <span class="keyword">new</span> InputStreamReader(chatSocket.getInputStream());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 建立BufferedReader来读取</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(stream);</span><br><span class="line">String message = reader.readLine();</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/readFromSocket.PNG" alt="读取Socket数据" /><figcaption aria-hidden="true">读取Socket数据</figcaption></figure><h4 id="向socket写入数据">1.3 向Socket写入数据</h4><p>利用<code>PrintWriter</code>向Socket写入数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 对服务器建立Socket连接</span></span><br><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立连接到Socket的PrintWriter</span></span><br><span class="line">PrintWriter writer = <span class="keyword">new</span> PrintWriter(chatSocket.getOutputStream());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 写入数据</span></span><br><span class="line">writer.println(<span class="string">"message to send"</span>);</span><br><span class="line">writer.print(<span class="string">"another message"</span>);</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/PrintWriterToSocket.PNG" alt="向Socket写入数据" /><figcaption aria-hidden="true">向Socket写入数据</figcaption></figure><h4 id="客户端">1.4 客户端</h4><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/client.PNG" alt="客户端" /><figcaption aria-hidden="true">客户端</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyAdviceClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket s = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">4242</span>);</span><br><span class="line">            InputStreamReader streamReader = <span class="keyword">new</span> InputStreamReader(s.getInputStream());</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(streamReader);</span><br><span class="line">            String advice = reader.readLine();</span><br><span class="line">            System.out.println(<span class="string">"Today you should: "</span> + advice);</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DailyAdviceClient client = <span class="keyword">new</span> DailyAdviceClient();</span><br><span class="line">        client.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务器">1.5 服务器</h4><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/server.PNG" alt="客户端" /><figcaption aria-hidden="true">客户端</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyAdviceServer</span> </span>&#123;</span><br><span class="line">    String[] adviceList = &#123;<span class="string">"Take smaller bites"</span>, <span class="string">"Go for the tight jeans. No they do NOT make you look fat."</span>, <span class="string">"One word: inappropriate"</span>, <span class="string">"Just for today, be honest. Tell your boss what you *really* think"</span>, <span class="string">"You might want to rethink that haircut."</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSock = <span class="keyword">new</span> ServerSocket(<span class="number">4242</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket sock = serverSock.accept();</span><br><span class="line"></span><br><span class="line">                PrintWriter writer = <span class="keyword">new</span> PrintWriter(sock.getOutputStream());</span><br><span class="line">                String advice = getAdvice();</span><br><span class="line">                writer.println(advice);</span><br><span class="line">                writer.close();</span><br><span class="line">                System.out.println(advice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// close go</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> random = (<span class="keyword">int</span>) (Math.random() * adviceList.length);</span><br><span class="line">        <span class="keyword">return</span> adviceList[random];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DailyAdviceServer server = <span class="keyword">new</span> DailyAdviceServer();</span><br><span class="line">        server.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程">2. 线程</h3><p>每个线程有独立的<code>执行空间(stack)</code>。Java内置有<code>多线程(Multithreading)</code>功能，但只有一种<code>Thread</code>类。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/javaThread.PNG" alt="Thread类" /><figcaption aria-hidden="true">Thread类</figcaption></figure><h4 id="新建线程">2.1 新建线程</h4><p>每个Java应用程序会启动一个主线程，将<code>main()</code>函数放在执行空间最开始处。Java虚拟机负责主线程的启动。自定义建立的线程，需要在程序中启动。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JVMThread.PNG" alt="主线程与自建线程" /><figcaption aria-hidden="true">主线程与自建线程</figcaption></figure><p>启动新线程主要有以下几个步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 建立Runnable对象(线程的任务)，此类是对线程要执行的任务的定义</span></span><br><span class="line">Runnable threadJob = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立Thread对象(执行工人)并赋值Runnable对象</span></span><br><span class="line"><span class="comment">// 告诉Thread对象把Runnable的run()方法放到执行空间执行</span></span><br><span class="line">Thread myThread = <span class="keyword">new</span> Thread(threadJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 启动线程Thread</span></span><br><span class="line"><span class="comment">// 真正到执行空间执行run()方法</span></span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure><blockquote><p><code>Thread</code>是个工人，<code>Runnable</code>是这个工人的工作。</p></blockquote><p><code>Runnable</code>是一个<strong>接口</strong>，只有<code>run()</code>这一个方法。<code>Runnable</code>带有会放在执行空间的第一项方法：<code>run()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// code that will be run by the new thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程的状态">2.2 线程的状态</h4><p>新建线程的3个状态：</p><ol type="1"><li><p>等待启动(新建线程)。Thread实例已经创建，但还未启动。即未处于执行中的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br></pre></td></tr></table></figure></li><li><p>可执行线程。启动线程时，变成可执行状态，已经布置好了执行空间，轮到它就可以执行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.start();</span><br></pre></td></tr></table></figure></li><li><p>执行中线程。线程占用资源开始执行，该过程只能依靠JVM的线程调度机制来决定。</p></li></ol><blockquote><p>一旦线程进入可执行状态，会不断在可执行与执行中两种状态切换。也可有另一种状态：暂时不可执行(<code>阻塞状态</code>)</p></blockquote><ul><li>典型的可执行/执行中循环。即JVM线程调度器会把不断切换线程，给予不同线程执行机会。</li><li>暂时被阻挡。<code>调度器(scheduler)</code>会在特殊情况下把线程阻塞，比如线程执行到等待<code>Socket</code>输入流的程序段，但又无数据可读，调度器会把线程移出可执行状态。或者<code>Sleep()</code>函数、调用某个被<code>锁住(locked)</code>的对象等等。</li></ul><h4 id="线程调度器">2.3 线程调度器</h4><p><code>线程调度器(Thread Scheduler)</code>会<u>决定哪个线程从等待状态中被挑出来运行，以及何时把哪个线程送回等待被执行的状态</u>。</p><blockquote><p>调度是无法被控制的</p></blockquote><p>可以通过<code>sleep</code>强制要求线程睡眠，暂时不被唤醒。但调度器是不可预测的，线程之间可能有多个不同的执行顺序，每次执行可能得到不同的结果。</p><blockquote><p>Thread对象不能重复使用，一旦线程的run()方法完成后，线程就不能再重新启动。</p></blockquote><h4 id="sleep">2.4 <code>sleep()</code></h4><p>确保线程有机会执行，可以让它们周期性地进入<code>睡眠</code>状态。当线程醒来时，会进入可执行状态等待被调度器调度执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p><code>sleep</code>方法可能会抛出<code>InterruptedException</code>异常，所以对它的调用需要放在<code>try/catch</code>块中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">     ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="建立与启动多个线程">2.5 建立与启动多个线程</h4><p>可以为线程命名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunThreads</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunThreads runner = <span class="keyword">new</span> RunThreads();</span><br><span class="line">        Thread alpha = <span class="keyword">new</span> Thread(runner);</span><br><span class="line">        Thread beta = <span class="keyword">new</span> Thread(runner);</span><br><span class="line">        alpha.setName(<span class="string">"Alpha thread"</span>);</span><br><span class="line">        beta.setName(<span class="string">"Beta thread"</span>);</span><br><span class="line">        alpha.start();</span><br><span class="line">        beta.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(threadName + <span class="string">" is running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程的并发性问题">2.6 线程的并发性问题</h4><p>线程的<code>并发性(Concurrency)</code>问题会引发<code>竞争状态(race condition)</code>。竞争状态可能会引起数据的损毁。需要对线程间的共享数据增加一道锁，以保证数据的安全。</p><p>要使得具有安全问题的方法<code>原子化</code>，比如对账户操作的方法<code>makeWithdrawal()</code>。确定线程一旦进入这个方法后，就必须能够在其他线程进入之前把任务执行完毕。</p><blockquote><p>使用<code>synchronized</code>关键词来修饰方法使它每次只能被单一线程存取。</p><ul><li><code>synchronized</code>关键词代表线程需要钥匙来存取被<code>同步化(synchronized)</code>过的线程。</li><li>要保护数据，就把作用在数据上的方法同步化</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">makeWithdrawal</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (account.getBalance() &gt;= amount) &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ is about to withdraw”);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             System.out.println(Thread.currentThread().getName() + “ is going to sleep”);</span><br><span class="line">             Thread.sleep(<span class="number">500</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;ex.printStackTrace(); &#125;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ woke up.”);</span><br><span class="line">         account.withdraw(amount);</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ completes the withdrawl”);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(“Sorry, not enough <span class="keyword">for</span> “ + Thread.currentThread().getName());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>锁不是配在方法上的，而是配在对象上的。这意味着对象有两个同步化的方法，就表示两个线程无法进入同一个方法，也表示两个线程无法进入不同的方法。</p></blockquote><p>同步化除了可以保证数据的安全，但同时也存在一些影响或潜在问题：</p><ul><li>同步化方法会带来额外的开销(查询钥匙等)</li><li>同步化方法会强制线程排队，影响并行性</li><li>同步化方法可能会导致死锁</li></ul><p>原则上只做最少量的同步化，可以用<code>synchronized</code>来修饰一行或数行指令而不必同步化整个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     doStuff();</span><br><span class="line">     <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">         criticalStuff();</span><br><span class="line">         moreCriticalStuff();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于静态方法，每个被载入的类也有锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;连接到外面的世界。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--14 序列化和文件的输入/输出</title>
    <link href="https://wuyunjie.top/2021/05/18/JavaLearning_Head_First_Java_14_serialization_and_file_IO.html"/>
    <id>https://wuyunjie.top/2021/05/18/JavaLearning_Head_First_Java_14_serialization_and_file_IO.html</id>
    <published>2021-05-18T07:30:59.000Z</published>
    <updated>2021-05-18T07:30:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>对象可以被序列化也可以展开。 <a id="more"></a></p></blockquote><h3 id="存储对象">1. 存储对象</h3><p>存储对象状态的数据格式（主要讨论两种）：</p><ul><li>序列化(serialization)。将被序列化的对象写到文件中，然后让程序去文件中读取序列化的对象并把他们展开变回状态。</li><li>纯文本文件。用可解析的特殊字符写到文件中，比如用<code>tab</code>字符来分隔数据。</li></ul><p>将对象序列化（存储）的方法步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1. 创建出 FileOutputStream</span></span><br><span class="line">FileOutputStream fileStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"MyGame.ser"</span>); <span class="comment">// 文件不存在会自动创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建出 ObjectOutputStream</span></span><br><span class="line">ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(fileStream); <span class="comment">// 可以向文件写入对象，但无法直接连接文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 写入对象</span></span><br><span class="line">os.writeObject(characterOne); <span class="comment">// 将变量所引用的对象序列化并写入文件</span></span><br><span class="line">os.writeObject(characterTwo);</span><br><span class="line">os.writeObject(characterThree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 关闭 ObjectOutputStream</span></span><br><span class="line">os.close(); <span class="comment">// 关闭所关联的输出串流</span></span><br></pre></td></tr></table></figure><p>Java输入/输出<code>API</code>带有连接类型的<code>串流(chain streams)</code>，代表来源与目的地之间的连接，连接串流将串流与其他串流连接起来。</p><p>串流要两两连接，一个表示连接，另一个是要被调用方法。<code>FileOutputStream</code>把子节写入文件，<code>ObjectOutputStream</code>把对象转换成可以写入串流的数据。当调用<code>ObjectOutputStream</code>的<code>writeObject</code>方法时，对象会被打成串流送到<code>FileOutputStream</code>来写入文件。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/chainStreams.PNG" alt="序列化" /><figcaption aria-hidden="true">序列化</figcaption></figure><blockquote><p>当对象被序列化时，被该对象引用的实例变量也会被序列化，且所有被引用的对象也会被序列化。</p></blockquote><p>如果要让类能够被序列化，需要实现<code>Serializable</code>。<code>Serializable</code>接口又被称为<code>marker</code>或<code>tag</code>类的标记用接口，此接口没有任何方法需要实现，唯一目的是<u><strong>声明所有实现它的类是可以被序列化的</strong></u>。所以此类型的对象可以通过序列化机制来存储。</p><blockquote><ul><li>某类是可序列化的，则它的子类也自动地可以序列化</li><li>序列化是全有或全无地，即整个对象版图必须全部正确序列化，不然全部失败。</li></ul></blockquote><p>如果某实例变量不能或不应该被序列化，需要标记其为<code>transient</code>(瞬时)。序列化程序会跳过标记的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chat</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">transient</span> String currentID;</span><br><span class="line"> </span><br><span class="line">     String userName;</span><br><span class="line">     <span class="comment">// more code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="还原对象">2. 还原对象</h3><p><code>解序列化(Deserialization)</code>像是序列化的反向操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建FileInputStream</span></span><br><span class="line">FileInputStream fileStream = <span class="keyword">new</span> FileInputStream(<span class="string">"MyGame.ser"</span>); <span class="comment">// 文件不存在会抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建ObjectInputStream</span></span><br><span class="line"><span class="comment">// ObjectInputStream可以读取对象，但不能直接连接文件，需要一个连接流(connection stream)</span></span><br><span class="line">ObjectInputStream os = <span class="keyword">new</span> ObjectInputStream(fileStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 读取对象</span></span><br><span class="line"><span class="comment">// 每次readObject都会读出下一个对象，读取顺序与写入顺序相同，次数超过会抛出异常</span></span><br><span class="line">Object one = os.readObject();</span><br><span class="line">Object two = os.readObject();</span><br><span class="line">Object three = os.readObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 转换对象类型</span></span><br><span class="line"><span class="comment">// 返回值是Object类型，因此必须要转换类型</span></span><br><span class="line">GameCharacter elf = (GameCharacter) one;</span><br><span class="line">GameCharacter troll = (GameCharacter) two;</span><br><span class="line">GameCharacter magician = (GameCharacter) three;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 关闭ObjectInputStream</span></span><br><span class="line"><span class="comment">// FileInputStream会随之自动关闭</span></span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure><p>对象被解序列化时，Java虚拟机会通过尝试在堆上创建新对象，让它维持与被序列化时有相同的状态来恢复对象的原状。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/Deserialization.PNG" alt="解序列化" /><figcaption aria-hidden="true">解序列化</figcaption></figure><ol type="1"><li>对象从<code>stream</code>中读出来；</li><li>Java虚拟机通过存储的消息判断出对象的class类型；</li><li>Java虚拟机尝试寻找和加载对象的类。如果Java虚拟机找不到或无法加载该类，则Java虚拟机会抛出异常</li><li>新的对象会被配置在堆上，但构造函数不会执行。</li><li>如果对象在继承树上有不可序列化的祖先类，则该不可序列化类以及它之上的类的构造函数会执行。</li><li>对象的实例变量会被还原成序列化时的状态值。<code>transient</code>变量会被赋值默认值。</li></ol><h3 id="将字符串写入文本文件">3. 将字符串写入文本文件</h3><p>写入文本数据与写入对象类似，可以使用<code>FileWriter</code>代替<code>FileOutputStream</code>，它不会被连接到<code>ObjectOutputStream</code>上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteAFile</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="string">"Foo.txt"</span>);</span><br><span class="line">             writer.write(<span class="string">"hello foo!"</span>);</span><br><span class="line">             writer.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">             ex.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.io.File</code>类代表磁盘上的文件，但并不是文件中的内容。<code>File</code>没有读写文件的方法，它提供一种比字符串文件名来表示文件更安全的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建出代表磁盘文件的File对象</span></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"MyCode.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立新的目录</span></span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"Chapter7"</span>); </span><br><span class="line">dir.mkdir();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 列出目录下的内容</span></span><br><span class="line"><span class="keyword">if</span> (dir.isDirectory()) &#123;</span><br><span class="line">String[] dirContents = dir.list();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dirContents.length; i++) &#123;</span><br><span class="line">System.out.println(dirContents[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 取得文件或目录的绝对路径</span></span><br><span class="line">System.out.println(dir.getAbsolutePath());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 删除文件或目录</span></span><br><span class="line"><span class="keyword">boolean</span> isDeleted = f.delete();</span><br></pre></td></tr></table></figure><p><strong>缓冲区</strong></p><p>缓冲区可以带来更高的效率。通过<code>BufferedWriter</code>和<code>FileWriter</code>的链接，<code>BufferedWriter</code>可以暂存一些数据，到满的时候在实际写入磁盘，可以减少对磁盘的操作次数。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/buffers.PNG" alt="缓冲区" /><figcaption aria-hidden="true">缓冲区</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(aFile));</span><br></pre></td></tr></table></figure><p>若想要强制缓冲区立即写入，可以调用以下方法要求立即写入缓冲区内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.flush();</span><br></pre></td></tr></table></figure><h3 id="读取文本文件">4. 读取文本文件</h3><p>用<code>File</code>对象来表示文件，以<code>FileReader</code>来执行实际的读取，并用<code>BufferedReader</code>来让读取更有效。读取以<code>while</code>循环来逐行进行，知道<code>readLine()</code>的结果为<code>null</code>为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadAFile</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             File myFile = <span class="keyword">new</span> File(<span class="string">"MyText.txt"</span>);</span><br><span class="line">             <span class="comment">// FileReader是字符连接到文本文件的串流</span></span><br><span class="line">             FileReader fileReader = <span class="keyword">new</span> FileReader(myFile);</span><br><span class="line">             <span class="comment">// FileReader链接到BufferedReader以获取更高效率</span></span><br><span class="line">             BufferedReader reader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">             </span><br><span class="line">             <span class="comment">// 用String变量来承接所读取的结果</span></span><br><span class="line">             String line = <span class="keyword">null</span>;</span><br><span class="line">             </span><br><span class="line">             <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 读一行就列出一行</span></span><br><span class="line">                 System.out.println(line);</span><br><span class="line">             &#125;</span><br><span class="line">             reader.close(); </span><br><span class="line">         &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">             ex.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析字符串</strong></p><p>用<code>String</code>的<code>split()</code>方法来解析字符串，<code>split()</code>可以将字符串拆开成<code>String</code>的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件读出来的格式</span></span><br><span class="line">String toTest = <span class="string">"What is blue + yellow?/green"</span>;</span><br><span class="line"><span class="comment">// split用参数所指定的字符来把这个String拆开成两个部分</span></span><br><span class="line">String[] result = toTest.split(<span class="string">"/"</span>);</span><br><span class="line"><span class="keyword">for</span> (String token:result) &#123;</span><br><span class="line">     System.out.println(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.nio</code>类可以直接控制<code>buffer</code>。另一个能力是<code>non-blocking</code>的输入/输出，能让输入/输出程序代码在没有东西可读取或写入时不必等待。</p><p><strong>序列化的识别</strong></p><p>版本控制很重要，如果在序列化后修改了类的定义，会伤害兼容性：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/changesForDeserialization.PNG" alt="修改对序列化的影响" /><figcaption aria-hidden="true">修改对序列化的影响</figcaption></figure><p>每当对象被序列化时，该对象会被盖上一个类版本识别ID，叫做<code>serialVersionUID</code>，根据类的结构消息计算所得。当对象被接序列化时，如果对象被序列化之后有了不同的<code>serialVersionUID</code>，还原操作会失败！</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/serialVersionUID.PNG" alt="serialVersionUID" /><figcaption aria-hidden="true">serialVersionUID</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对象可以被序列化也可以展开。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--12 图形用户接口</title>
    <link href="https://wuyunjie.top/2021/05/17/JavaLearning_Head_First_Java_12_getting_gui.html"/>
    <id>https://wuyunjie.top/2021/05/17/JavaLearning_Head_First_Java_12_getting_gui.html</id>
    <published>2021-05-17T14:28:09.000Z</published>
    <updated>2021-05-17T14:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>面对现实，你得做出图形用户接口。 <a id="more"></a></p></blockquote><h3 id="window">1. window</h3><p><code>JFrame</code>是代表屏幕上window的对象，可以把<code>button</code>，<code>checkbox</code>，<code>text</code>字段等接口放在window上。标准的<code>menu</code>也可以加到上面。</p><p>一旦创建了<code>JFrame</code>后，就可以把组件(<code>widget</code>)加到上面。最常用的组件包括：<code>JButton, JRadioButton, JCheckBox, JLabel, JList, JScrollPane, JSlider, JTextArea, JTextField, and JTable</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleGui1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 frame</span></span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 widget</span></span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">"click me"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// window关闭时结束程序</span></span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把widget加到frame上</span></span><br><span class="line">        frame.getContentPane().add(button);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定frame大小</span></span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        <span class="comment">// 显式</span></span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户接口事件">2. 用户接口事件</h3><p>让按钮在按下时执行工作需要两项：</p><ul><li>被按下时要执行的方法(按钮任务)</li><li>检测按钮被按下的方法(按钮感应装置)</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/buttonEvent.PNG" alt="按钮事件" /><figcaption aria-hidden="true">按钮事件</figcaption></figure><p>取得与处理用户操作事件的过程称为<code>event-handling</code>。如果想知道按钮的事件，就会监听事件的接口，<code>监听接口</code>是<u>介于监听与事件源间的桥梁</u>。</p><p>事件来源将用户操作转换成事件的对象，事件几乎都是以对象来表示。程序大多数情况是事件的接收方而不是创建方。事件对象通过不同的事件方法来表示不同类型的事件。</p><p>比如取得按钮的<code>ActionEvent</code>：</p><ul><li>实现ActionListener接口</li><li>向按钮注册</li><li>定义事件处理的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口ActionListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleGui1B</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">    JButton button;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleGui1B gui = <span class="keyword">new</span> SimpleGui1B();</span><br><span class="line">        gui.go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line">        button = <span class="keyword">new</span> JButton(<span class="string">"click me"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        button.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        frame.getContentPane().add(button);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.setSize(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现ActionListener接口的方法，处理事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以ActionEvent对象作为参数调用</span></span><br><span class="line">        button.setText(<span class="string">"I’ve been clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘图组件">3. 绘图组件</h3><p>创建具有绘图功能的<code>widget</code>放到<code>frame</code>上，创建<code>JPanel</code>的子类覆盖掉<code>paintComponet()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDrawPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        g.setColor(Color.orange);</span><br><span class="line">        g.fillRect(<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式<code>JPEG</code>照片：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">     Image image = <span class="keyword">new</span> ImageIcon(<span class="string">"catzilla.jpg"</span>).getImage();</span><br><span class="line">     g.drawImage(image,<span class="number">3</span>,<span class="number">4</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随机色彩圆：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    g.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">this</span>.getWidth(), <span class="keyword">this</span>.getHeight());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> red = (<span class="keyword">int</span>) (Math.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">int</span> green = (<span class="keyword">int</span>) (Math.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">int</span> blue = (<span class="keyword">int</span>) (Math.random() * <span class="number">256</span>);</span><br><span class="line">    Color randomColor = <span class="keyword">new</span> Color(red, green, blue);</span><br><span class="line">    g.setColor(randomColor);</span><br><span class="line">    g.fillOval(<span class="number">70</span>,<span class="number">70</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类inner-class">4. 内部类（Inner class）</h3><p>一个类可以嵌套在另一个类的内部。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/innerClass.PNG" alt="简单内部类" /><figcaption aria-hidden="true">简单内部类</figcaption></figure><blockquote><p>内部类可以使用外部的所有方法与变量，就算私有内容也一样。即内部类可以把外部的方法或变量当作自己的。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/Inner_class_using_outer_class.PNG" alt="内部类使用外部类的变量" /><figcaption aria-hidden="true">内部类使用外部类的变量</figcaption></figure><blockquote><p>内部类的实例一定会绑定在外部类的实例上。从外部类程序代码中初始化的内部类，此内部对象会绑定在该外部对象上。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/innerOuterBound.PNG" alt="创建内部类实例" /><figcaption aria-hidden="true">创建内部类实例</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;面对现实，你得做出图形用户接口。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--3 垃圾收集器与内存分配策略</title>
    <link href="https://wuyunjie.top/2021/05/17/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_3_Garbage_collector_and_memory_allocation_strategy.html"/>
    <id>https://wuyunjie.top/2021/05/17/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_3_Garbage_collector_and_memory_allocation_strategy.html</id>
    <published>2021-05-17T02:35:27.000Z</published>
    <updated>2021-05-17T02:35:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code> <a id="more"></a></p></blockquote><h3 id="对象已死">1. 对象"已死"？</h3><p>垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（<code>“死去”即不可能再被任何途径使用的对象</code>）。</p><h4 id="引用计数算法">1.1 引用计数算法</h4><p>在对象中添加一个<code>引用计数器（Reference Counting）</code>，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；<strong>任何时刻计数器为零的对象就是不可能再被使用的</strong>。</p><blockquote><ul><li>占用了一些额外的内存空间来进行计数</li><li>原理简单，判定效率也很高</li></ul></blockquote><p>主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作。</p><blockquote><p>譬如单纯的引用计数就很难解决对象之间<code>相互循环引用</code>的问题。</p><ul><li>对象<code>objA</code>和<code>objB</code>都有字段<code>instance</code>；</li><li>赋值令 <code>objA.instance=objB</code>及<code>objB.instance=objA</code>，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问；</li><li>但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。</li></ul></blockquote><p>打印内存回收日志的参数设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails      //打印GC详细信息</span><br><span class="line">-Xms100M    //堆大小100M</span><br><span class="line">-Xmx200M   //堆最大占用内存</span><br><span class="line">-Xmn10M     //新生代 大小 </span><br><span class="line">-XX:SurvivorRatio=8   //Eden:Survivor1:Survivor2 = 8:1:1</span><br><span class="line">-XX:MaxPermSize30M   //永久代内存大小</span><br><span class="line">-XX:MetaspaceSize=30M  //元空间 初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</span><br><span class="line">-XX:MaxMetaspaceSize=300M //最大空间，默认是没有限制的。</span><br></pre></td></tr></table></figure><h4 id="可达性分析算法">1.2 可达性分析算法</h4><p><code>可达性分析（Reachability Analysis）算法</code>的基本思路是：</p><blockquote><ul><li>通过 一系列称为<code>“GC Roots”</code>的根对象作为<strong>起始节点集</strong>，从这些节点开始，根据引用关系向下搜索；</li><li>搜索过程所走过的路径称为<code>“引用链”（Reference Chain）</code>，如果某个对象到<code>GC Roots</code>间没有任何引用链相连， 或者用图论的话来说就是从<code>GC Roots</code>到这个对象不可达时，则证明此对象是不可能再被使用的。</li></ul></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Reachability_Analysis.PNG" alt="可达性分析算法" /><figcaption aria-hidden="true">可达性分析算法</figcaption></figure><p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是使用了可达性分析算法。固定可作为<code>GC Roots</code>的对象包括以下几种：</p><ul><li>在<code>虚拟机栈（栈帧中的本地变量表）中引用的对象</code>，譬如各个线程被调用的方法堆栈中使用到的<u>参数、局部变量、临时变量</u>等。</li><li>在<strong>方法区</strong>中<code>类静态属性引用的对象</code>，譬如Java类的引用类型静态变量。</li><li>在<strong>方法区</strong>中<code>常量引用的对象</code>，譬如字符串常量池（String Table）里的引用。</li><li>在<code>本地方法栈中JNI</code>（即通常所说的Native方法）引用的对象。</li><li><code>Java虚拟机内部的引用</code>，如基本数据类型对应的Class对象，一些常驻的<strong>异常对象</strong>（比如<code>NullPointExcepiton</code>、<code>OutOfMemoryError</code>）等，还有系统类加载器。</li><li>所有被<code>同步锁（synchronized关键字）持有的对象</code>。</li><li>反映Java虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI中注册的回调</code>、<code>本地代码缓存</code>等。</li></ul><p>除了这些<strong>固定</strong>的<code>GC Roots</code>集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象<strong>“临时性”</strong>地加入，共同构成完整<code>GC Roots</code>集合。</p><h4 id="引用的分类">1.3 引用的分类</h4><p>在<code>JDK 1.2</code>版之后，Java对引用的概念进行了扩充，将引用分为<code>强引用（Strongly Re-ference）</code>、<code>软引用（Soft Reference）</code>、<code>弱引用（Weak Reference）</code>和<code>虚引用（Phantom Reference）</code>4种，这4种引用强度依次逐渐减弱。</p><ul><li><p>强引用是指在程序代码之中普遍存在的引用赋值，即类似<code>“Object obj=new Object()”</code>这种引用关系。</p><blockquote><p>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。`</p></blockquote></li><li><p>软引用是用来描述一些<strong>还有用，但非必须的对象</strong>。</p><blockquote><ul><li>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</li><li>在<code>JDK 1.2</code>版之后提供了<code>SoftReference</code>类来实现软引用。</li></ul></blockquote></li><li><p>弱引用也是用来描述那些<strong>非必须对象</strong>，但是它的强度比软引用更弱一些。</p><blockquote><p>被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><p>在<code>JDK 1.2</code>版之后提供了<code>WeakReference</code>类来实现弱引用。</p></blockquote></li><li><p>虚引用也称为<code>“幽灵引用”</code>或者<code>“幻影引用”</code>，它是最弱的一种引用关系。</p><blockquote><p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的<u>只是为了能在这个对象被收集器回收时收到一个系统通知</u>。</p><p>在<code>JDK 1.2</code>版之后提供 了<code>PhantomReference</code>类来实现虚引用。</p></blockquote></li></ul><h4 id="对象的死亡宣告">1.4 对象的死亡宣告</h4><p>在可达性分析算法中判定为不可达的对象，至少要经历两次标记过程：</p><ol type="1"><li><p>如果对象在进行可达性分析后发现没有与<code>GC Roots</code>相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是<u>此对象是否有必要执行<code>finalize()</code>方法</u>。</p><ul><li><p>假如对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为<strong>“没有必要执行”</strong>。</p></li><li><p>如果这个对象被判定为确<strong>有必要执行<code>finalize()</code>方法</strong>，那么该对象将会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条由虚拟机<strong>自动建立的、低调度优先级</strong>的<code>Finalizer</code>线程去执行它们的<code>finalize()</code> 方法。</p><ul><li><code>“执行”</code>是<u>指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束</u>。</li></ul></li></ul></li><li><p>稍后收集器将对<code>F-Queue</code>中的对象进行<u>第二次小规模的标记</u>，如果对象要在<code>finalize()</code>中重新与引用链上的任何一个对象建立关联，那在第二次标记时它将被移出“即将回收”的集合。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此代码演示了两点：</span></span><br><span class="line"><span class="comment">* 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment">* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes, i am still alive :)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/FinalizeEscapeGC.PNG" alt="FinalizeEscapeGC运行结果" /><figcaption aria-hidden="true">FinalizeEscapeGC运行结果</figcaption></figure><p>代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败了。这是因为<strong>任何一个对象的finalize()方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p><blockquote><p><code>finalize()</code>是不推荐使用的语法</p></blockquote><h4 id="回收方法区">1.5 回收方法区</h4><p>方法区的垃圾收集主要回收两部分内容：<code>废弃的常量</code>和<code>不再使用的类型</code>。</p><ul><li>回收废弃常量与回收 Java堆中的对象非常类似。</li><li>判定一个类型是否属于<code>“不再被使用的类”</code>需要同时满足下面三个条件：<ul><li><strong>该类所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li><strong>加载该类的类加载器已经被回收</strong>，这个条件则通常是很难达成。</li><li><strong>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li></ul></li></ul><h3 id="垃圾收集算法">2. 垃圾收集算法</h3><p>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为<code>“引用计数式垃圾收集”（Reference Counting GC）</code>和<code>“追踪式垃圾收集”（Tracing GC）</code>两大类，这两类也常被称作<code>“直接垃圾收集”</code>和<code>“间接垃圾收集”</code>。</p><h4 id="分代收集理论">2.1 分代收集理论</h4><p><code>“分代收集”（Generational Collection）</code>建立在两个分代假说之上：</p><ol type="1"><li><code>弱分代假说（Weak Generational Hypothesis）</code>：绝大多数对象都是朝生夕灭的。</li><li><code>强分代假说（Strong Generational Hypothesis）</code>：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ol><p>设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（<strong>年龄即对象熬过垃圾收集过程的次数</strong>）分配到不同的区域之中存储。</p><blockquote><ul><li>如果一个区域中大多数对象都是朝生夕灭，那么把它们集中放在一起，每次回收时只关注如何保留少量存活，就能以较低代价回收到大量的空间；</li><li>如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域；</li><li>同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</li></ul></blockquote><p>设计者一般至少会把Java堆划分为<code>新生代（Young Generation）</code>和<code>老年代（Old Generation）</code>两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p><p>假如要现在进行一次只局限于新生代区域内的收集<code>（Minor GC）</code>，但新生代中的对象是完全有可能被老年代所引用的。需要对分代收集理论添加第三条经验法则：</p><ol start="3" type="1"><li><code>跨代引用假说（Intergenerational Reference Hypothesis）</code>：跨代引用相对于同代引用来说仅占极少数。</li></ol><p>依据这条假说，只需在新生代上建立一个全局的数据结构（该结构被称为<code>“记忆集”</code>，<code>Remembered Set</code>），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生<code>Minor GC</code>时，只有包含了跨代引用的小块内存里的对象才会被加入到<code>GC Roots</code>进行扫描。</p><blockquote><ul><li><code>部分收集（Partial GC）</code>：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul><li><code>新生代收集（Minor GC/Young GC）</code>：指目标只是新生代的垃圾收集。</li><li><code>老年代收集（Major GC/Old GC）</code>：指目标只是老年代的垃圾收集。</li><li><code>混合收集（Mixed GC）</code>：指目标是收集整个新生代以及部分老年代的垃圾收集。</li></ul></li><li><code>整堆收集（Full GC）</code>：收集整个Java堆和方法区的垃圾收集。</li></ul></blockquote><h4 id="标记-清除mark-sweep算法">2.2 标记-清除(Mark-Sweep)算法</h4><p>算法分为<code>“标记”</code>和<code>“清除”</code>两个阶段：</p><ul><li>首先标记出所有需要回收的对象；</li><li>在标记完成后，统一回收掉所有被标记的对象；</li></ul><p>也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p><blockquote><p>主要缺点:</p><ol type="1"><li><strong>执行效率不稳定</strong>，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li><li><strong>内存空间的碎片化问题</strong>，标记、清除之后会产生大量不连续的内存碎片。</li></ol></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Sweep.PNG" alt="“标记-清除”算法" /><figcaption aria-hidden="true">“标记-清除”算法</figcaption></figure><h4 id="标记-复制mark-copying算法">2.3 标记-复制(Mark-Copying)算法</h4><p>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，标记-复制(Mark-Copying)算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。<u>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</u>。</p><blockquote><p>缺点：</p><ul><li>如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销；</li><li>这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一 点。</li></ul></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Copying.PNG" alt="“标记-复制”算法" /><figcaption aria-hidden="true">“标记-复制”算法</figcaption></figure><p><code>Appel式回收</code>(<code>Andrew Appel</code>提出的一种更优化的<code>半区复制分代策略</code>)的具体做法是：</p><ul><li>把新生代分为一块较大的<code>Eden空间</code>和两块较小的<code>Survivor空间</code>，每次分配内存只使用<code>Eden</code>和其中一块<code>Survivor</code>。</li><li>发生垃圾搜集时，将<code>Eden</code>和<code>Survivor</code>中仍然存活的对象一次性复制到另外一块<code>Survivor</code>空间上，然后直接清理掉<code>Eden</code>和已用过的那块<code>Survivor</code>空间。</li></ul><p><code>HotSpot虚拟机</code>默认<code>Eden</code>和<code>Survivor</code>的大小比例是<code>8∶1</code>，也即每次新生代中可用内存空间为整个新生代容量的<strong>90%</strong>（<code>Eden</code>的<strong>80%</strong>加上一个<code>Survivor</code>的<strong>10%</strong>）。</p><blockquote><p><code>Appel式回收</code>还有一个充当罕见情况的<code>“逃生门”</code>的安全设计，当<code>Survivor</code>空间不足以容纳一次<code>Minor GC</code>之后存活的对象时，就需要依赖<strong>其他内存区域（实际上大多就是老年代）</strong>进行<code>分配担保（Handle Promotion）</code>。</p></blockquote><h4 id="标记-整理mark-compact算法">2.4 标记-整理(Mark-Compact)算法</h4><p><code>“标记-整理”（Mark-Compact）算法</code>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Compact.PNG" alt="“标记-整理”算法" /><figcaption aria-hidden="true">“标记-整理”算法</figcaption></figure><p>是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。</p><h3 id="hotspot的算法细节实现">3. HotSpot的算法细节实现</h3><h4 id="根节点枚举">3.1 根节点枚举</h4><p>所有收集器在根节点枚举这一步骤时都是<strong>必须暂停用户线程</strong>的，因此毫无疑问根节点枚举与整理内存碎片一样会面临相似的<code>“Stop The World”</code>的困扰。</p><p><code>HotSpot</code>使用一组称为<code>OopMap</code>的数据结构直接得到哪些地方存放着对象引用。（<code>普通对象指针（Ordinary Object Pointer，OOP）</code>）</p><blockquote><ul><li>一旦类加载动作完成的时候，就会把对象内什么偏移量上是什么类型的数据计算出来；</li><li>在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。</li></ul></blockquote><p>这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等<code>GC Roots</code>开始查找。</p><h4 id="安全点">3.2 安全点</h4><p><code>HotSpot</code>没有为每条指令都生成<code>OopMap</code>，只是在<strong>“特定的位置”</strong>记录了这些信息，这些位置被称为<code>安全点（Safepoint）</code>。有了安全点的设定，强制要求必须执行到达安全点后才能够暂停下来开始垃圾收集。</p><blockquote><p>安全点位置的选取基本上是以“<code>是否具有让程序长时间执行的特征</code>”，<code>“长时间执行”</code>的最明显特征就是<strong>指令序列的复用</strong>，例如<u>方法调用、循环跳转、异常跳转</u>等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p></blockquote><p>如何在垃圾收集发生时让所有线程（这里其实<code>不包括执行JNI调用的线程</code>）都跑到最近的安全点，然后停顿下来。</p><blockquote><p><code>抢先式中断（Preemptive Suspension）</code>在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。</p><p><code>主动式中断（Voluntary Suspension）</code>当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一 个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。</p></blockquote><p><code>HotSpot</code>使用<code>内存保护陷阱</code>的方式，把轮询操作精简至只有一条汇编指令的程度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x01b6d62d: test %eax,0x160100</span><br></pre></td></tr></table></figure><p>当需要暂停用户线程时，虚拟机把<code>0x160100</code>的内存页设置为不可读，那线程执行到<code>test</code>指令时就会产生一个<code>自陷异常信号</code>，然后在预先注册的异常处理器中挂起线程实现等待。</p><h4 id="安全区域">3.3 安全区域</h4><p><code>安全区域</code>是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。</p><blockquote><ul><li>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。</li><li>当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段）:<ul><li>如果完成了，那线程就当作没事发生过，继续执行；</li><li>否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</li></ul></li></ul></blockquote><h4 id="记忆集与卡表">3.4 记忆集与卡表</h4><p><code>记忆集（Remembered Set）</code>是一种用于记录<u>从非收集区域指向收集区域的指针集合</u>的抽象数据结构。实现记忆集的一些可供选择（当然也可以选择这个范围以外的）的记录精度：</p><ul><li><strong>字长精度</strong>：每个记录精确到一个机器字长，该字包含跨代指针。</li><li><strong>对象精度</strong>：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li><li><strong>卡精度</strong>：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li></ul><p>“卡精度”所指的是用一种称为<code>“卡表”（Card Table）</code>的方式去实现记忆集，字节数组<code>CARD_TABLE</code>的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作<code>“卡页”（Card Page）</code>。</p><blockquote><p>只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为<code>1</code>，称为这个元素变脏（Dirty），没有则标识为<code>0</code>。</p></blockquote><h4 id="写屏障">3.5 写屏障</h4><p>卡表元素何时变脏?</p><blockquote><p>有其他分代区域中对象引用了本区域对象时</p></blockquote><p>如何变脏?</p><blockquote><p>在<code>HotSpot</code>虚拟机里是通过<code>写屏障（Write Barrier）</code>技术维护卡表状态的。写屏障可以看作在虚拟机层面对<code>“引用类型字段赋值”</code>这个动作的<code>AOP切面</code></p><ul><li>在引用对象赋值时会产生一个<code>环形（Around）</code>通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。<ul><li>在赋值前的部分的写屏障叫作<code>写前屏障（Pre-Write Barrier）</code>；</li><li>在赋值后的则叫作<code>写后屏障（Post-Write Barrier）</code>。</li></ul></li></ul></blockquote><p><strong>“伪共享”（False Sharing）问题</strong></p><blockquote><p>现代中央处理器的缓存系统中是以<code>缓存行（Cache Line）</code>为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低。</p><p>为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏</p></blockquote><h4 id="并发的可达性分析">3.6 并发的可达性分析</h4><p>可达性分析的停顿时间与Java堆容量直接成正比例关系，把遍历对象图过程中遇到的对象，按照<strong>“是否访问过”</strong>这个条件标记成以下三种颜色，演示并发出现<strong>“对象消失”</strong>问题：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Object_disappeared.PNG" alt="并发出现“对象消失”问题" /><figcaption aria-hidden="true">并发出现“对象消失”问题</figcaption></figure><ul><li><strong>白色</strong>：表示对象尚未被垃圾收集器访问过。</li><li><strong>黑色</strong>：表示对象已经被垃圾收集器访问过，且这个对象的<u>所有引用都已经扫描过</u>。</li><li><strong>灰色</strong>：表示对象已经被垃圾收集器访问过，但这个对象上<u>至少存在一个引用还没有被扫描过</u>。</li></ul><p>当且仅当以下两个条件同时满足时，会产生“对象消失”的问题：</p><blockquote><ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li></ul></blockquote><p>产生了两种解决方案：</p><blockquote><ul><li><p><code>增量更新（Incremental Update）</code>破坏的是第一个条件。当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</p></li><li><p><code>原始快照（Snapshot At The Beginning，SATB）</code>破坏的是第二个条件。当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p></li></ul></blockquote><h3 id="经典垃圾收集器">4. 经典垃圾收集器</h3><p>七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Garbage_collector.PNG" alt="HotSpot虚拟机的垃圾收集器" /><figcaption aria-hidden="true">HotSpot虚拟机的垃圾收集器</figcaption></figure><h4 id="新生代收集器">4.1 新生代收集器</h4><h5 id="serial收集器">4.1.1 Serial收集器</h5><p><code>Serial收集器</code>是一个单线程工作的收集器，但它的“单线程”的意义是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/serial_collector.PNG" alt="Serial/Serial Old收集器运行示意图" /><figcaption aria-hidden="true">Serial/Serial Old收集器运行示意图</figcaption></figure><blockquote><p>它是所有收集器里<code>额外内存消耗（Memory Footprint）</code>最小的，简单而高效</p></blockquote><h5 id="parnew收集器">4.1.2 ParNew收集器</h5><p><code>ParNew收集器</code>实质上是<code>Serial收集器</code>的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为都与Serial收集器完全一致。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ParNew_collector.PNG" alt="ParNew/Serial Old收集器运行示意图l Old收集器运行示意图" /><figcaption aria-hidden="true">ParNew/Serial Old收集器运行示意图l Old收集器运行示意图</figcaption></figure><p>在谈论垃圾收集器的上下文语境中，<code>并行和并发</code>可以理解为：</p><ul><li><code>并行（Parallel）</code>：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态</li><li><code>并发（Concurrent）</code>：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。</li></ul><h5 id="parallel-scavenge收集器">4.1.3 Parallel Scavenge收集器</h5><p><code>Parallel Scavenge收集器</code>也是一款<code>新生代收集器</code>，它同样是基于<u>标记-复制算法</u>实现的收集器，也是能够并行收集的多线程收集器。Parallel Scavenge收集器的目标则是达到一个可控制的<code>吞吐量（Throughput）</code>，吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值： <span class="math display">\[吞吐量 = \frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}\]</span> 高吞吐量可以最高效率地利用处理器资源，尽快完成程序的运算任务，<em>主要适合在后台运算而不需要太多交互的分析任务</em>。</p><blockquote><p><code>自适应的调节策略（GC Ergonomics）</code>让虚拟机根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p></blockquote><h4 id="老年代收集器">4.2 老年代收集器</h4><h5 id="serial-old收集器">4.2.1 Serial Old收集器</h5><p><code>Serial Old</code>是Serial收集器的老年代版本，它同样是一个单线程收集器，使用<u>标记-整理算法</u>。</p><h5 id="parallel-old收集器">4.2.2 Parallel Old收集器</h5><p><code>Parallel Old</code>是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于<u>标记-整理算法</u>实现。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Parallel_Old_collector.PNG" alt="ParNew/Serial Old收集器运行示意图" /><figcaption aria-hidden="true">ParNew/Serial Old收集器运行示意图</figcaption></figure><blockquote><p>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p></blockquote><h5 id="cms收集器">4.2.3 CMS收集器</h5><p><code>CMS（Concurrent Mark Sweep）收集器</code>是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于<u>标记-清除算法</u>实现的，它的运作过程分为四个步骤：</p><ol type="1"><li><code>初始标记（CMS initial mark）</code>。只是标记一下<code>GC Roots</code>能<strong>直接</strong>关联到的对象，速度很快；</li><li><code>并发标记（CMS concurrent mark）</code>。从<code>GC Roots</code>的<u>直接关联对象</u>开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</li><li><code>重新标记（CMS remark）</code>。修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；</li><li><code>并发清除（CMS concurrent sweep）</code>。清理删除掉标记阶段判断的已经死亡的对象。</li></ol><p>初始标记、重新标记这两个步骤仍然需要<code>“Stop The World”</code>。在整个过程中<em>耗时最长</em>的<code>并发标记</code>和<code>并发清除</code>阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说<code>CMS收集器</code>的内存回收过程是与用户线程一起<strong>并发执行</strong>的。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Concurrent_Mark_Sweep.PNG" alt="Concurrent Mark Sweep收集器运行示意图" /><figcaption aria-hidden="true">Concurrent Mark Sweep收集器运行示意图</figcaption></figure><blockquote><p>优点：并发收集、低停顿。也称之为<code>“并发低停顿收集器”（Concurrent Low Pause Collector）</code>。</p><p>缺点：</p><ul><li>CMS收集器对<code>处理器资源</code>非常敏感。</li><li>由于CMS收集器无法处理<code>“浮动垃圾”（Floating Garbage）</code>，有可能出现<code>“Con-current Mode Failure”</code>失败进而导致另一次完全<code>“Stop The World”</code>的<code>Full GC</code>的产生。<ul><li><code>“浮动垃圾”</code>：在CMS的<code>并发标记</code>和<code>并发清理</code>阶段，用户线程运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。</li><li><code>“并发失败”（Concurrent Mode Failure）</code>：CMS运行期间预留的内存无法满足程序分配新对象的需要。虚拟机将不得不启动<code>后备预案</code>：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集。</li></ul></li><li>CMS是一款基于“标记-清除”算法实现的收集器，收集结束时会有大量<code>空间碎片</code>产生。</li></ul></blockquote><h4 id="garbage-first收集器">4.3 Garbage First收集器</h4><p><code>Garbage First（简称G1）收集器</code>开创了收集器<code>面向局部收集</code>的设计思路和<code>基于Region的内存布局</code>形式，也被Oracle官方称为<code>“全功能的垃圾收集器”（Fully-Featured Garbage Collector）</code>。</p><blockquote><p><code>“停顿时间模型”（Pause Prediction Model）</code>是能够支持指定在一个长度为<strong>M毫秒</strong>的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。</p></blockquote><p><code>G1</code>面向堆内存任何部分来组成<code>回收集（Collection Set，一般简称CSet）</code>进行回收，衡量标准是<u>哪块内存中存放的垃圾数量最多，回收收益最大</u>。这就是G1收集器的<code>Mixed GC模式</code>。</p><h5 id="基于region的堆内存布局">4.3.1 基于Region的堆内存布局</h5><p>G1不再坚持固定大小以及固定数量的分代区域划分，而是<u>把连续的Java堆划分为多个大小相等的<code>独立区域（Region）</code></u>，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理。</p><blockquote><p>Region中一类特殊的<code>Humongous区域</code>，专门用来存储大对象。只要大小超过了一个 Region容量一半的对象即可判定为大对象。</p></blockquote><h5 id="面向局部收集">4.3.2 面向局部收集</h5><p>G1中新生代和老年代不再是固定的了，它们都是一系列区域（<strong>不需要连续</strong>）的<code>动态集合</code>。将Region作为单次回收的最小单元，可以有计划地避免<u>在整个Java堆中进行全区域的垃圾收集</u>。G1收集器跟踪各个Region里面的垃圾堆积的“价值”大小：</p><blockquote><p>价值即回收所获得的空间大小以及回收所需时间的经验值</p></blockquote><p>在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region。(“Garbage First”名字的由来)</p><h5 id="关键的细节问题">4.3.3 关键的细节问题</h5><ul><li><u>将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？</u>使用记忆集避免全堆作为GC Roots扫描。G1的记忆集在存储结构的<u>本质上是一 种哈希表</u>，<code>Key</code>是别的Region的起始地址，<code>Value</code>是一个集合，里面存储的元素是卡表的索引号。</li><li><u>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</u>G1 收集器是通过<code>原始快照（SATB）算法</code>保证用户线程改变对象引用关系时，不能打破原本的对象图结构。此外，G1为每一个Region设计了两个名为<code>TAMS（Top at Mark Start）</code>的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li><li><u>怎样建立起可靠的停顿预测模型？</u>G1收集器的停顿预测模型是以<code>衰减均值（Decaying Average）</code>为理论基础来实现的。在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。衰减平均值更准确地代表“最近的”平均状态。</li></ul><h5 id="关键的细节问题-1">4.3.4 关键的细节问题</h5><p>G1收集器的运作过程大致可划分为以下四个步骤：</p><ul><li><code>初始标记（Initial Marking）</code>。仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象，并且修改<code>TAMS</code>指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。</li><li><code>并发标记（Concurrent Marking）</code>。从<code>GC Root</code>开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。当对象图扫描完成以后，还要重新处理<code>原始快照SATB</code>记录下的在并发时有引用变动的对象。</li><li><code>最终标记（Final Marking）</code>。对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的<code>SATB记录</code>。</li><li><code>筛选回收（Live Data Counting and Evacuation）</code>。负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。<ul><li>这里的操作涉及存活对象的移动，是<strong>必须暂停用户线程</strong>，由多条收集器线程并行完成的。</li></ul></li></ul><p>G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/G1_collector.PNG" alt="G1收集器运行示意图" /><figcaption aria-hidden="true">G1收集器运行示意图</figcaption></figure><blockquote><p>从G1开始，最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的<code>内存分配速率 （Allocation Rate）</code>，应用在分配，同时收集器在收集，只要收集的速度能跟得上对象分配的速度，那一切就能运作得很完美。</p></blockquote><p>优点：</p><ul><li>可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集</li><li>G1<strong>从整体来看是基于“标记-整理”算法</strong>实现的收集器，但<strong>从局部（两个Region之间）上看又是基于“标记-复制”</strong>算法实现，G1运作期间不会产生内存空间碎片。</li></ul><p>缺点：</p><ul><li>G1为了垃圾收集产生的内存占用（Footprint）比CMS要高。G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间；</li><li>G1程序运行时的额外执行负载（Overload）比CMS要高。G1除了使用写后屏障来进行卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。</li></ul><h3 id="低延迟垃圾收集器">5. 低延迟垃圾收集器</h3><p>衡量垃圾收集器的三项最重要的指标是：<code>内存占用（Footprint）</code>、<code>吞吐量（Throughput）</code>和<code>延迟 （Latency）</code>。两款目前仍处于实验状态的收集器<code>Shenandoah</code>和<code>ZGC</code>，被官方命名为<code>“低延迟垃圾收集器”（Low-Latency Garbage Collector或者Low-Pause-Time Garbage Collector）</code>。</p><h4 id="shenandoah收集器">5.1 Shenandoah收集器</h4><p><code>Shenandoah</code>是一款只有<code>OpenJDK</code>才会包含，而<code>OracleJDK</code>里反而不存在的收集器。Shenandoah反而更像是G1的下一代继承者，在管理堆内存方面，它与G1至少有三个明显的不同之处：</p><ul><li>支持并发的整理算法；</li><li>Shenandoah是默认不使用分代收集的；</li><li>Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为<code>“连接矩阵”（Connection Matrix）</code>的全局数据结构来记录<em>跨Region的引用关系</em>，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。</li></ul><p>Shenandoah收集器的工作过程大致可以划分为以下九个阶段：</p><ul><li><code>初始标记（Initial Marking）</code>。标记与<code>GC Roots</code>直接关联的对象，这个阶段仍是<code>“Stop The World”</code>的。</li><li><code>并发标记（Concurrent Marking）</code>。遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的。</li><li><code>最终标记（Final Marking）</code>。处理剩余的<code>SATB扫描</code>，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组<code>回收集（Collection Set）</code>。<em>会有一小段短暂的停顿</em>。</li><li><code>并发清理（Concurrent Cleanup）</code>。清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为<code>Immediate Garbage Region</code>）。</li><li><code>并发回收（Concurrent Evacuation）</code>。Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中，Shenandoah通过读屏障和被称为“<code>Brooks Pointers</code>”的转发指针来解决并发回收阶段遇到的困难。</li><li><code>初始引用更新（Initial Update Reference）</code>。把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务。<em>会产生一个非常短暂的停顿</em>。</li><li><code>并发引用更新（Concurrent Update Reference）</code>。按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值。<em>与用户线程一起并发的</em>。</li><li><code>最终引用更新（Final Update Reference）</code>。修正存在于<code>GC Roots</code>中的引用，这个阶段是Shenandoah的最后一次停顿。</li><li><code>并发清理（Concurrent Cleanup）</code>。经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成<code>Immediate Garbage Regions</code>了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</li></ul><p>三个最重要的并发阶段<strong>（并发标记、并发回收、并发引用更新）</strong>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Shenandoah.PNG" alt="Shenandoah收集器的工作过程" /><figcaption aria-hidden="true">Shenandoah收集器的工作过程</figcaption></figure><p>黄色的区域代表的是<em>被选入回收集的Region</em>，绿色部分就代表<em>还存活的对象</em>，蓝色就是<em>用户线程可以用来分配对象的内存Region</em>。</p><p><code>Brooks Pointer</code>。<code>Brooks</code>提出了使用<code>转发指针</code>（<code>Forwarding Pointer</code>，也常被称为<code>Indirection Pointer</code>）来实现对象移动与用户程序并发的一种解决方案。<code>Brooks</code>在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Brooks_Pointers.PNG" alt="Brooks Pointers示意图" /><figcaption aria-hidden="true">Brooks Pointers示意图</figcaption></figure><p>转发指针加入后带来的收益是当对象拥有了一份新的副本时，只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Brooks_Pointers2.PNG" alt="Brooks Pointers原理" /><figcaption aria-hidden="true">Brooks Pointers原理</figcaption></figure><p><strong>Brooks转发指针的多线程竞争问题</strong>：</p><ul><li>收集器线程与用户线程发生的只是并发读取，那无论读到旧对象还是新对象上的字段，返回的结果都应该是一样的；</li><li>如果发生的是并发写入，就一定必须保证<code>写操作</code>只能发生在新复制的对象上。</li></ul><p>Shenandoah收集器是通过<code>比较并交换（Compare And Swap，CAS）操作</code>来保证并发时对象的访问正确性的。</p><h4 id="zgc收集器">5.2 ZGC收集器</h4><p><code>ZGC（Z Garbage Collector）</code>是一款在 <code>JDK 11</code>中新加入的具有实验性质的低延迟垃圾收集器。ZGC和Shenandoah的目标是高度相似的，都希望<u>在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</u>。</p><h5 id="zgc的内存布局">5.2.1 ZGC的内存布局</h5><p>ZGC也采用基于Region的堆内存布局（在一些官方资料中将它称为<code>Page</code>或者<code>ZPage</code>），ZGC的Region具有<strong>动态性</strong>——<u>动态创建和销毁，以及动态的区域容量大小</u>。ZGC的 Region可以有大、中、小三类容量：</p><ul><li><code>小型Region（Small Region）</code>：容量固定为<code>2MB</code>，用于放置<u>小于</u><code>256KB</code>的小对象。</li><li><code>中型Region（Medium Region）</code>：容量固定为<code>32MB</code>，用于放置<u>大于等于</u><code>256KB</code>但<u>小于</u><code>4MB</code>的对象。</li><li><code>大型Region（Large Region）</code>：容量不固定，可以动态变化，但必须为<code>2MB</code>的<strong>整数倍</strong>，用于放置<code>4MB</code>或以上的大对象。每个大型Region中只会存放一个大对象，大型Region在ZGC的实现中<strong>不会被重分配</strong>。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ZGC_memory.PNG" alt="ZGC的堆内存布局" /><figcaption aria-hidden="true">ZGC的堆内存布局</figcaption></figure><h5 id="zgc的并发整理算法">5.2.2 ZGC的并发整理算法</h5><p>ZGC收集器采用的<code>染色指针技术</code>（<code>Colored Pointer</code>，其他类似的技术中可能将它称为<code>Tag Pointer</code>或者<code>Version Pointer</code>）。染色指针直接把标记信息记在引用对象的指针上。</p><p>在64位系统中，理论可以访问的内存高达<code>16EB</code>（<code>2的64次幂</code>）字节。基于需求 、性能和成本的考虑，在<code>AMD64</code>架构中只支持到<code>52</code>位（<code>4PB</code>）的<u>地址总线</u>和<code>48</code>位（<code>256TB</code>）的<u>虚拟地址空间</u>。</p><blockquote><p>操作系统也还会施加自己的约束，64位的<code>Linux</code>则分别支持<code>47</code>位（<code>128TB</code>）的进程虚拟地址空间和<code>46</code>位（<code>64TB</code>）的物理地址空间，64位的<code>Windows</code>系统甚至只支持<code>44</code>位（<code>16TB</code>）的物理地址空间。</p></blockquote><p>Linux下64位指针的高18位不能用来寻址，ZGC的染色指针技术利用这剩下的46位指针宽度，将其<code>高4位</code>提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的<strong>三色标记状态</strong>、<strong>是否进入了重分配集</strong>（即被移动过）、<strong>是否只能通过finalize()方法才能被访问到</strong>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Colored_Pointer.PNG" alt="染色指针" /><figcaption aria-hidden="true">染色指针</figcaption></figure><blockquote><p>这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致ZGC能够管理的内存不可以超过<code>4TB</code></p></blockquote><p>染色指针的三大优势：</p><ul><li>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</li><li>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。</li><li>染色指针可以作为一种<code>可扩展</code>的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li></ul><h5 id="虚拟内存映射技术">5.2.3 虚拟内存映射技术</h5><p>处理器会使用<code>分页管理机制</code>把线性地址空间和物理地址空间分别划分为大小相同的块，这样的内存块被称为<code>“页”（Page）</code>。通过在线性虚拟空间的页与物理地址空间的页之间建立的<code>映射表</code>，分页管理机制会进行线性地址到物理地址空间的映射，完成线性地址到物理地址的转换。</p><p><code>Linux/x86-64</code>平台上的ZGC使用了<code>多重映射（Multi-Mapping）</code>将<u>多个不同的虚拟内存地址映射到同一个物理内存地址上</u>，这是一种<strong>多对一映射</strong>，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。把染色指针中的标志位看作是<code>地址的分段符</code>，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Multi_Mapping.PNG" alt="多重映射下的寻址" /><figcaption aria-hidden="true">多重映射下的寻址</figcaption></figure><h5 id="zgc的运作过程">5.2.4 ZGC的运作过程</h5><p>ZGC的运作过程大致可划分为以下四个大的阶段。全部四个阶段<strong><u>都是可以并发执行</u></strong>的，仅是两个阶段中间会存在短暂的停顿小阶段，如初始化<code>GC Root</code>直接关联对象的<code>Mark Start</code>。</p><ul><li><code>并发标记（Concurrent Mark）</code>：并发标记是<strong>遍历对象图做可达性分析的阶段</strong>，前后也要经过初始标记、最终标记的短暂停顿。ZGC 的标记是在指针上进行的，标记阶段会更新染色指针中的<code>Marked0</code>、<code>Marked1</code>标志位。</li><li><code>并发预备重分配（Concurrent Prepare for Relocate）</code>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成<code>重分配集（Relocation Set）</code>。ZGC每次回收都会<strong>扫描所有的Region</strong>，用范围更大的扫描成本换取<u>省去G1中记忆集的维护成本</u>。</li><li><code>并发重分配（Concurrent Relocate）</code>：把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<code>转发表（Forward Table）</code>，<u>记录从旧对象到新对象的转向关系</u>。<ul><li>指针的<code>“自愈”（Self-Healing）</code>能力：ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被<code>预置的内存屏障</code>所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象。这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次。</li></ul></li><li><code>并发重映射（Concurrent Remap）</code>：重映射所做的就是<u>修正整个堆中指向重分配集中旧对象的所有引用</u>，但是ZGC重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。ZGC把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成。</li></ul><h5 id="numa-aware的内存分配">5.2.5 “NUMA-Aware”的内存分配</h5><p>ZGC支持<code>“NUMA-Aware”的内存分配</code>。<code>NUMA</code>（<code>Non-Uniform Memory Access</code>，<strong>非统一内存访问架构</strong>）是一种为多处理器或者多核处理器的计算机所设计的内存架构。在<code>NUMA</code>架构下，ZGC收集器会优先尝试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问。</p><h3 id="选择合适的垃圾收集器">6. 选择合适的垃圾收集器</h3><h4 id="epsilon收集器">6.1 Epsilon收集器</h4><p><code>Epsilon</code>这是一款以<u>不能够进行垃圾收集</u>为“卖点”的垃圾收集器。</p><blockquote><p>Epsilon收集器由<code>RedHat</code>公司在<code>JEP 318</code>中提出，在此提案里<code>Epsilon</code>被形容成一个<code>无操作的收集器（A No-Op Garbage Collector）</code>。</p></blockquote><p>一个垃圾收集器除了垃圾收集这个本职工作之外，它还要负责<u>堆的管理与布局</u>、<u>对象的分配</u>、<u>与解释器的协作</u>、<u>与编译器的协作</u>、<u>与监控子系统协作</u>等职责。Epsilon是垃圾收集器的统一接口，用于需要剥离垃圾收集器影响的性能测试和压力测试。</p><p>在实际生产环境中，不能进行垃圾收集的Epsilon也用于应对<code>短时间、小规模</code>的服务形式，只要Java虚拟机<u>能正确分配内存，在堆耗尽之前就会退出</u>，那显然运行负载极小、没有任何回收行为的Epsilon便是很恰当的选择。</p><h4 id="收集器的权衡">6.2 收集器的权衡</h4><p>选择一款适合自己应用的收集器主要受以下三 个因素影响：</p><ul><li><code>应用程序的主要关注点是什么？</code><ul><li>如果是数据分析、科学计算类的任务，目标是能尽快算出结果， 那吞吐量就是主要关注点；</li><li>如果是<code>SLA（（Service Level Agreements））</code>应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点；</li><li>而如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的。</li></ul></li><li><code>运行应用的基础设施如何？</code><ul><li>譬如硬件规格，要涉及的系统架构；</li><li>处理器的数量多少，分配内存的大小；</li><li>选择的操作系统。</li></ul></li><li>使用JDK的发行商是什么？版本号是多少？是ZingJDK/Zulu、OracleJDK、Open-JDK、OpenJ9抑或是其他公司的发行版？该JDK对应了《Java虚拟机规范》的哪个版本？</li></ul><p>实战中切不可纸上谈兵，<strong>根据系统实际情况去测试才是选择收集器的最终依据</strong>。</p><h4 id="虚拟机及垃圾收集器日志">6.3 虚拟机及垃圾收集器日志</h4><p><code>JDK 9</code>后，<code>HotSpot</code>所有功能的日志都收归到了<code>“-Xlog”</code>参数上，这个参数的能力也相应被极大拓展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog[:[selector][:[output][:[decorators][:output-options]]]]</span><br></pre></td></tr></table></figure><p>最关键的参数是<code>选择器（Selector）</code>，它由<code>标签（Tag）</code>和<code>日志级别（Level）</code>共同组成。</p><p>日志级别从低到高，共有<code>Trace，Debug，Info，Warning，Error，Off</code>六种级别，默认级别为<code>Info</code>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Log_parameter.PNG" alt="JDK 9前后日志参数变化" /><figcaption aria-hidden="true">JDK 9前后日志参数变化</figcaption></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Log_parameter2.PNG" alt="JDK 9前后日志参数变化(续)" /><figcaption aria-hidden="true">JDK 9前后日志参数变化(续)</figcaption></figure><h4 id="垃圾收集器参数总结">6.4 垃圾收集器参数总结</h4><p>具体可以查看书籍，主要还是用到的时候查一下就行。</p><h3 id="内存分配与回收策略">7. 内存分配与回收策略</h3><p>Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：<u><strong>自动给对象分配内存</strong></u>以及<u><strong>自动回收分配给对象的内存</strong></u>。对象的内存分配，从概念上讲，应该都是在堆上分配（而实际上也有可能经过<code>即时编译</code>后被拆散为标量类型并间接地在栈上分配）。</p><h4 id="对象优先在eden分配">7.1 对象优先在Eden分配</h4><p>对象在新生代<code>Eden区</code>中分配。当<code>Eden区</code>没有足够空间进行分配时，虚拟机将发起 一次<code>Minor GC</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">// 出现一次Minor GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>testAllocation()</code>中分配<code>allocation4</code>对象的语句时会发生一次<code>Minor GC</code>，产生这次垃圾收集的原因是为<code>allocation4</code>分配内存时，发现 <code>Eden</code>已经被占用了<code>6MB</code>，剩余空间已不足以分配<code>allocation4</code>所需的<code>4MB</code>内存，因此发生<code>Minor GC</code>。</p><p>垃圾收集期间虚拟机又发现已有的三个<code>2MB</code>大小的对象全部无法放入<code>Survivor</code>空间（<strong>Survivor空间只有 1MB大小</strong>），所以只好通过分配担保机制提前转移到老年代去。</p><p>收集结束后，<code>4MB</code>的<code>allocation4</code>对象顺利分配在<code>Eden</code>中。因此程序执行完的结果是<code>Eden</code>占用 <code>4MB</code>（被<code>allocation4</code>占用），<code>Survivor</code>空闲，老年代被占用<code>6MB</code>（被<code>allocation1、2、3</code>占用）。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testAllocation.PNG" alt="testAllocation运行结果" /><figcaption aria-hidden="true">testAllocation运行结果</figcaption></figure><h4 id="大对象直接进入老年代">7.2 大对象直接进入老年代</h4><p>最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。</p><blockquote><p>在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">* -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation;</span><br><span class="line">allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">//直接分配在老年代中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Eden空间几乎没有被使用，而老年代的<code>10MB</code>空间被使用了40%，也就是<code>4MB</code>的allocation对象<strong>直接就分配在老年代中</strong></p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testPretenureSizeThreshold.PNG" alt="testPretenureSizeThreshold运行结果" /><figcaption aria-hidden="true">testPretenureSizeThreshold运行结果</figcaption></figure><h4 id="长期存活的对象将进入老年代">7.3 长期存活的对象将进入老年代</h4><p>虚拟机给每个对象定义了一个<code>对象年龄（Age）计数器</code>，存储在对象头中。</p><p>对象通常在<code>Eden区</code>里诞生，如果经过第一次 <code>Minor GC</code>后仍然存活，并且能被<code>Survivor</code>容纳的话，该对象会被移动到<code>Survivor</code>空间中，并且将其对象年龄设为<code>1岁</code>。对象在<code>Survivor</code>区中每熬过一次<code>Minor GC</code>，年龄就增加<code>1岁</code>，当它的年龄增加到一定程度（默认为15），就会<strong>被晋升到老年代中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment">* -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>]; <span class="comment">// 什么时候进入老年代决定于XX:MaxTenuringThreshold设置</span></span><br><span class="line">allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">allocation3 = <span class="keyword">null</span>;</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当<code>-XX：MaxTenuringThreshold=1</code>时，<code>allocation1</code>对象在第二次<code>GC</code>发生时进入老年代， 新生代已使用的内存在垃圾收集以后非常干净地变成<code>0KB</code>。</li><li>当<code>-XX：MaxTenuringThreshold=15</code>时， 第二次<code>GC</code>发生后，<code>allocation1</code>对象则还留在新生代<code>Survivor</code>空间，这时候新生代仍然有<code>404KB</code>被占用。</li></ul><h4 id="动态对象年龄判定">7.4 动态对象年龄判定</h4><p>如果在<code>Survivor</code>空间中相同年龄所有对象大小的总和大于<code>Survivor</code>空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><h4 id="空间分配担保">7.5 空间分配担保</h4><p>在发生<code>Minor GC</code>之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间：</p><ul><li>如果这个条件成立，那这一次<code>Minor GC</code>可以确保是安全的；</li><li>如果不成立，会查看是否允许担保失败（Handle Promotion Failure）：<ul><li>如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次<code>Minor GC</code>，尽管这次<code>Minor GC</code>是有风险的；</li><li>如果小于，或设置不允许冒险，那这时就要改为进行一次<code>Full GC</code>。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。&lt;/code&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[读书|2021阅读]--《如何阅读一本书》</title>
    <link href="https://wuyunjie.top/2021/05/14/Reading_2021--How_to_Read_a_Book.html"/>
    <id>https://wuyunjie.top/2021/05/14/Reading_2021--How_to_Read_a_Book.html</id>
    <published>2021-05-14T12:30:38.000Z</published>
    <updated>2021-05-14T12:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>如何阅读一本书 <a id="more"></a></p></blockquote><h3 id="思维导图">思维导图</h3><iframe src="https://www.xmind.net/embed/3TzT/" width="750" height="1000" frameborder="0" scrolling="no" allowfullscreen="true"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;如何阅读一本书
    
    </summary>
    
      <category term="Reading" scheme="https://wuyunjie.top/categories/Reading/"/>
    
    
      <category term="Reading" scheme="https://wuyunjie.top/tags/Reading/"/>
    
      <category term="Book" scheme="https://wuyunjie.top/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--11 异常处理</title>
    <link href="https://wuyunjie.top/2021/05/14/JavaLearning_Head_First_Java_11_exception_handling.html"/>
    <id>https://wuyunjie.top/2021/05/14/JavaLearning_Head_First_Java_11_exception_handling.html</id>
    <published>2021-05-14T08:43:25.000Z</published>
    <updated>2021-05-14T08:43:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>倒霉的事情就算会发生。找不到文件、服务器出现故障。 <a id="more"></a></p></blockquote><h3 id="异常">1. 异常</h3><p>需要对可能发生的异常情况进行处理，<strong>未雨绸缪</strong>！Java的<code>异常处理机制(exception-handling)</code>将处理错误状况的代码放在一个容易阅读的位置。如果知道调用某个方法可能会有异常情况，可以预先准备问题处理程序甚至从错误中恢复。</p><blockquote><p>异常是一种<code>Exception</code>类型的对象。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/exceptionClass.PNG" alt="异常类" /><figcaption aria-hidden="true">异常类</figcaption></figure><ul><li><p><strong>抛出异常(throws)</strong>。使用<code>throws</code>语句来抛出异常。</p><p>在编写可能会抛出异常的方法时，必须先声明有异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeRisk</span><span class="params">()</span> <span class="keyword">throws</span> BadException </span>&#123; <span class="comment">// 声明会抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (abandonAllHope) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadException(); <span class="comment">// 创建异常对象并抛出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意声明时是<code>throws</code>，抛出时是<code>throw</code>。</p></blockquote></li><li><p><strong>捕捉异常(catch)</strong>。使用<code>try/catch</code>块来捕捉处理异常。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 有风险的动作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><p>非<code>RuntimeExceptions</code>子类的异常由编译器检查，称作<code>检查异常(checked exceptions)</code>；<code>RuntimeExceptions</code>类称为<code>非检查异常</code>，编译器不会检查。编译器会确保：</p><ol type="1"><li>如果有抛出异常，一定使用了<code>throws</code>来声明</li><li>如果调用会抛出异常的方法，一定知道异常可能性。即会处理异常。</li></ol><h4 id="trycatch块">1.1 try/catch块</h4><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/tryCatchFlow.PNG" alt="try/catch块流程" /><figcaption aria-hidden="true">try/catch块流程</figcaption></figure><p><code>finally</code>块用来存放不管有没有异常都需要执行的程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     turnOvenOn();</span><br><span class="line">     x.bake(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (BakingException ex) &#123; </span><br><span class="line">     ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     turnOvenOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果try或catch块有<code>return</code>指令，<strong><code>finally</code>块还是会执行</strong>！流程会跳到<code>finally</code>块然后再回到return指令。</p></blockquote><h4 id="throws">1.2 throws</h4><p>方法可以抛出多个异常，声明时必须要含有全部可能的检查异常。调用方法时，编译器会坚持是否处理了所有可能的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laundry</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> PantsException, LingerieException </span>&#123;</span><br><span class="line">         <span class="comment">// code that could throw either exception</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Laundry laundry = <span class="keyword">new</span> Laundry();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             laundry.doLaundry();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(PantsException pex) &#123;</span><br><span class="line">             <span class="comment">// recovery code</span></span><br><span class="line">         &#125; <span class="keyword">catch</span>(LingerieException lex) &#123;</span><br><span class="line">             <span class="comment">// recovery code</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常也是多态的，所以异常也可以用多态的方式引用。抛出异常时可以声明多个异常的共同父类，捕捉异常时也同理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     laundry.doLaundry();</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClothingException cex) &#123;</span><br><span class="line">     <span class="comment">// recovery code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的确可以用<code>Exception</code>来捕捉所有异常，但也会在处理异常时无法精确定位捕捉到了何种异常。使用<code>catch</code>来处理异常时，在继承数中高层次的异常不能放到低层次的异常之前。</p><h4 id="duck异常">1.3 duck异常</h4><blockquote><p>如果不想处理异常，可以把它duck掉来避开。</p></blockquote><p>也就是不用try/catch处理异常，而是再度throw该异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Washer</span> </span>&#123;</span><br><span class="line">     Laundry laundry = <span class="keyword">new</span> Laundry();</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException </span>&#123; </span><br><span class="line">         laundry.doLaundry();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> ClothingException </span>&#123;</span><br><span class="line">         Washer a = <span class="keyword">new</span> Washer();</span><br><span class="line">         a.foo();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/duckException.PNG" alt="duck异常" /><figcaption aria-hidden="true">duck异常</figcaption></figure><h4 id="异常处理规则">1.4 异常处理规则</h4><ol type="1"><li><code>catch</code>与<code>finally</code>不能没有<code>try</code>；</li><li><code>try</code>与<code>catch</code>之间不能有程序；</li><li><code>try</code>一定要有<code>catch</code>或<code>finally</code>；</li><li>只带有<code>finally</code>的方法必须duck异常(即声明)。</li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/exceptionRules.PNG" alt="异常处理规则" /><figcaption aria-hidden="true">异常处理规则</figcaption></figure><h3 id="创建midi音乐播放器">2. 创建<code>MIDI</code>音乐播放器</h3><p><code>MIDI</code>音乐播放器，类似一款乐队软件。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/MIDI.PNG" alt="MIDI音乐播放器" /><figcaption aria-hidden="true"><code>MIDI</code>音乐播放器</figcaption></figure><h4 id="javasound-api">2.1 <code>JavaSound</code> API</h4><p><code>JavaSound</code> API是<code>Java 1.3</code>后加入的一组类和接口，分为两部分：<code>MIDI(Musical Instrument Digital Interface)</code>和<code>取样(sampled)</code>。<code>MIDI</code>是不同电子发声装置沟通的标准协议，可以想象成<code>乐谱</code>，可以输入到“高级多功能电子魔音琴”中。</p><blockquote><p><code>MIDI</code>本身不带有声音，它带有的是有MIDI播放功能装置的指令</p></blockquote><h4 id="sequencer">2.2 Sequencer</h4><p>先获取<code>Sequencer</code>对象，它会将所有MIDI数据送到正确的装置上，由装置来产生音乐。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sequencer sequencer = MidiSystem.getSequencer();</span><br></pre></td></tr></table></figure><p>直接调用无法通过编译，编译器显式需要处理异常。API中说明<code>getSequencer()</code>可能会抛出<code>MidiUnavailableException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MusicTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Sequencer sequencer = MidiSystem.getSequencer();</span><br><span class="line">            System.out.println(<span class="string">"We get a sequencer"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MidiUnavailableException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Bummer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MusicTest1 mt = <span class="keyword">new</span> MusicTest1();</span><br><span class="line">        mt.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以下是<code>JavaSound</code>的工作原理：</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JavaSoundWorkFlow.PNG" alt="JavaSound的工作原理" /><figcaption aria-hidden="true"><code>JavaSound</code>的工作原理</figcaption></figure><ul><li>运行该播放器需要5个步骤：</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/fiveStepOfMIDI.PNG" alt="JavaSound的工作原理" /><figcaption aria-hidden="true"><code>JavaSound</code>的工作原理</figcaption></figure><blockquote><p>第5步是开始播放：<code>player.start();</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniMiniMusicApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiniMiniMusicApp mini = <span class="keyword">new</span> MiniMiniMusicApp();</span><br><span class="line">        mini.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个Sequencer并打开</span></span><br><span class="line">            Sequencer player = MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            Sequence seq = <span class="keyword">new</span> Sequence(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取一道音轨</span></span><br><span class="line">            Track track = seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage a = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOn = <span class="keyword">new</span> MidiEvent(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            ShortMessage b = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOff = <span class="keyword">new</span> MidiEvent(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Sequence放到Sequencer上(相对于把CD放到CD机上)</span></span><br><span class="line">            player.setSequence(seq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始播放</span></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="制作midievent">2.3 制作<code>MidiEvent</code></h4><p><code>MidiEvent</code>是组合乐曲的指令，一连串<code>MidiEvent</code>如同乐谱。必须在<code>MidiEvent</code>中指定何时开始播放某个音符(<code>NOTE ON event</code>)以及何时停止(<code>NOTE OFF event</code>)。</p><p><code>Midi</code>指令实际上放在<code>Message</code>对象中，<code>MidiEvent</code>由<code>Message</code>和发音时机组成。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/MidiEvent.PNG" alt="MidiEvent" /><figcaption aria-hidden="true">MidiEvent</figcaption></figure><p><code>Message</code>中信息的格式：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/AnatomyMessage.PNG" alt="信息的格式" /><figcaption aria-hidden="true">信息的格式</figcaption></figure><p>使用命令行参数版本的播放器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniMusicCmdLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiniMusicCmdLine mini = <span class="keyword">new</span> MiniMusicCmdLine();</span><br><span class="line"><span class="comment">//        if (args.length &lt; 2) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Don’t forget the instrument and note args");</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            int instrument = Integer.parseInt(args[0]);</span></span><br><span class="line"><span class="comment">//            int note = Integer.parseInt(args[1]);</span></span><br><span class="line"><span class="comment">//            mini.play(instrument, note);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Input the instrument and note"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                String instrumentS = <span class="keyword">null</span>;</span><br><span class="line">                instrumentS = is.readLine();</span><br><span class="line">                String noteS = <span class="keyword">null</span>;</span><br><span class="line">                noteS = is.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> instrument = Integer.parseInt(instrumentS);</span><br><span class="line">                <span class="keyword">int</span> note = Integer.parseInt(noteS);</span><br><span class="line">                mini.play(instrument, note);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(<span class="keyword">int</span> instrument, <span class="keyword">int</span> note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个Sequencer并打开</span></span><br><span class="line">            Sequencer player = MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            Sequence seq = <span class="keyword">new</span> Sequence(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line">            <span class="comment">// 获取一道音轨</span></span><br><span class="line">            Track track = seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage first = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            first.setMessage(<span class="number">192</span>, <span class="number">1</span>, instrument, <span class="number">0</span>);</span><br><span class="line">            MidiEvent changeInstrument = <span class="keyword">new</span> MidiEvent(first, <span class="number">1</span>);</span><br><span class="line">            track.add(changeInstrument);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage a = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOn = <span class="keyword">new</span> MidiEvent(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            ShortMessage b = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOff = <span class="keyword">new</span> MidiEvent(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Sequence放到Sequencer上(相对于把CD放到CD机上)</span></span><br><span class="line">            player.setSequence(seq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始播放</span></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;倒霉的事情就算会发生。找不到文件、服务器出现故障。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--10 数字和静态</title>
    <link href="https://wuyunjie.top/2021/05/14/JavaLearning_Head_First_Java_10_numbers_and_statics.html"/>
    <id>https://wuyunjie.top/2021/05/14/JavaLearning_Head_First_Java_10_numbers_and_statics.html</id>
    <published>2021-05-14T04:53:28.000Z</published>
    <updated>2021-05-14T04:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>盘算一下。 <a id="more"></a></p></blockquote><h3 id="静态static">1. 静态（static）</h3><h4 id="静态方法">1.1 静态方法</h4><p>在<code>Java</code>中没有<code>全局(global)</code>方法。但有些类中的方法不需要实例变量，为这样的类在堆上建立实例时很浪费的。</p><blockquote><p><code>Math</code>方法是最接近全局的方法。</p></blockquote><p><code>Math</code>类中所有方法都不需要实例变量，这些方法都是<code>静态(static)</code>的。而且无需也无法创建<code>Math</code>实例，只会用到它的类本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = Math.round(<span class="number">42.2</span>);</span><br><span class="line"><span class="keyword">int</span> y = Math.min(<span class="number">56</span>,<span class="number">12</span>);</span><br><span class="line"><span class="keyword">int</span> z = Math.abs(-<span class="number">343</span>);</span><br></pre></td></tr></table></figure><p><code>Java</code>中使用<code>static</code>这一关键词来标记出不需要实例的方法。一个静态方法代表<u><strong>一种不依靠实例变量(对象)的行为</strong></u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">     <span class="comment">//returns the lesser of a and b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以类名调用静态方法，以引用变量名调用非静态方法。</p></blockquote><p>带有静态方法的类通常会被设置为不可初始化。除了把类定义为抽象类之外，也可以<strong>把构造函数标记为私有</strong>防止类被初始化。但带有静态方法的类也可以被初始化(比如带有<code>main()</code>函数的类，<code>main()</code>函数是一个静态方法)</p><blockquote><p>静态方法不能调用非静态的变量。静态方法无法引用到该类的任何实例变量，静态方法也不能调用非静态的方法。</p></blockquote><p>可以用实例变量来调用静态方法，但编译器会解析出原来的类，并不会知道是哪个对象引用调用的该静态方法。</p><h4 id="静态变量">1.2 静态变量</h4><p>静态变量的值对所有实例来说都相同，而且该变量被所有实例共享。比如要计算当前<code>Duck</code>实例的数量，或许可以在构造函数中递增计算器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> duckCount = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         duckCount++;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于<code>duckCount</code>是实例变量，每个<code>Duck</code>对象都会将其初始化为0。而将其设置为静态变量可以实现所需要的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> duckCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         duckCount++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">         size = s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态变量只在类第一次载入时初始化。同一个类所有实例共享一份静态变量。</p></blockquote><p><code>Java</code>虚拟机会加载某个类主要因为第一次被尝试创建该类的实例，或使用该类的静态方法或变量时。静态项目的初始化又两项保证：</p><blockquote><ul><li>静态变量会在该类的任何对象创建前就完成初始化。</li><li>静态变量会在该类的任何静态方法执行前就初始化。</li></ul></blockquote><p>被标记为<code>final</code>的变量代表该变量初始化后就不会改动，是一个常数。而静态的<code>final</code>变量在类加载后就会一致维持原值。</p><blockquote><p><code>静态初始化程序(static initializer)</code>是一段在加载类时会执行的程序代码，会在其他程序可以使用该类前执行，所有适合放置<code>静态final变量</code>在该部分。</p></blockquote><blockquote><p>根据<code>命名惯例(naming convention)</code>，常数变量的名称应该都是大写字母！</p></blockquote><p><code>静态final变量</code>可以通过两种方法初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 在声明时初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FOO_X = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在静态初始化程序中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> BAR_SIGN;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">static</span> &#123; <span class="comment">// 这部分代码在类加载时就执行，早于任何方法或静态变量被使用之前</span></span><br><span class="line">         BAR_SIGN = (<span class="keyword">double</span>) Math.random();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若未使用上述方法为<code>静态final变量</code>初始化，编译器会报错。</p><blockquote><p><code>final</code>还可以修饰其他变量，方法甚至类</p><ul><li><code>final</code>变量代表不能改变它的值；</li><li><code>final</code>方法代表不能覆盖该方法；</li><li><code>final</code>类代表不能继承该类；</li></ul></blockquote><h3 id="数字">2. 数字</h3><h4 id="math方法">2.1 <code>Math</code>方法</h4><p>下面是对<code>Math</code>方法的一些结束：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/mathMethods.PNG" alt="Math方法" /><figcaption aria-hidden="true"><code>Math</code>方法</figcaption></figure><h4 id="primitive主数据类型包装">2.2 <code>primitive</code>主数据类型包装</h4><p>把<code>primitive</code>主数据类型当作对象来处理，需要一个包装该数据类型的类。每个<code>primitive</code>主数据类型都有一个包装类，存放在<code>java.lang</code>这个包中。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/wrapperClasses.PNG" alt="包装类" /><figcaption aria-hidden="true">包装类</figcaption></figure><p>包装类将<code>primitive</code>主数据类型名称第一个字母大写，以符合命名惯例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包装值</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">288</span>;</span><br><span class="line">Integer iWrap = <span class="keyword">new</span> Integer(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解开包装</span></span><br><span class="line"><span class="keyword">int</span> unWrapped = iWrap.intValue();</span><br></pre></td></tr></table></figure><h4 id="autoboxing">2.3 <code>autoboxing</code></h4><p><code>java 5.0</code>以后加入了<code>autoboxing</code>，自动将<code>primitive</code>主数据类型转换成包装过的对象。</p><blockquote><p>但依旧无法直接声明<code>ArrayList&lt;int&gt;</code>，因为<code>generic</code>类型的规则是只能指定类或接口类型，因此<code>ArrayList&lt;int&gt;</code>无法通过编译。但可以把该包装对象的<code>primitive</code>主数据类型直接放入<code>ArrayList</code>中。</p></blockquote><p><code>autoboxing</code>除了在包装或解包<code>primitive</code>主数据类型给<code>collection</code>之外，还可以用到其他地方：</p><ul><li><p>方法的参数</p><p>参数是包装类型，可以传入相应的<code>primitive</code>主数据类型。反之亦然。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">takeNumber</span><span class="params">(Integer i)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>返回值</p><p>如果方法声明为返回某些<code>primitive</code>主数据类型，也可以返回兼容的包装类型。</p></li><li><p><code>boolean</code>表达式</p><p>可以使用<code>Boolean</code>包装类型</p></li><li><p>数值运算</p><p>可以直接对包装类型进行数值运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">42</span>); </span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">5</span>); </span><br><span class="line">Integer k = j + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>赋值</p><p>将包装类型赋值给<code>primitive</code>主数据类型或相反。</p></li></ul><p>包装内也有实用的静态方法，比如字符串和主数据类型的转化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = Integer.parseInt(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">double</span> d = Double.parseDouble(“<span class="number">420.24</span>”);</span><br></pre></td></tr></table></figure><blockquote><p>注意没有<code>Boolean.parseBoolean()</code>方法，但<code>Boolean</code>构造函数可以用<code>String</code>类型创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">42.5</span>;</span><br><span class="line">String doubleString = <span class="string">""</span> + d; <span class="comment">// "+"运算符是Java中唯一重载过的运算符，作为字符串拼接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">42.5</span>;</span><br><span class="line">String doubleString = Double.toString(d);</span><br></pre></td></tr></table></figure><h4 id="数字格式">2.4 数字格式</h4><p>Java中数字与日期的<code>格式化</code>功能没有结合在输入/输出功能上。该功能在<code>java 5.0</code>以后由<code>java.lang</code>中的<code>Formatter</code>类来提供，该类的功能加入到了部分输入/输出类和<code>String</code>中。可以直接调用<strong>静态</strong>的<code>String.format()</code>来实现格式设定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = String.format(<span class="string">"%, d"</span>, <span class="number">1000000000</span>); <span class="comment">// 将数字以带逗号的形式格式化</span></span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p>格式化主要由两个主要部分组成：</p><ol type="1"><li><strong>格式指令</strong>。概述要输出的特殊格式。</li><li><strong>要格式化的值</strong>。</li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/formatString.PNG" alt="格式化" /><figcaption aria-hidden="true">格式化</figcaption></figure><p>格式化说明中，跟在<code>百分号(%)</code>后面包括类型指示(如<code>d</code>或<code>f</code>)的每个东西都是格式化指令，类型指示后的字符被视作直接输出的字符串。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/formatSpecifier.PNG" alt="格式化说明" /><figcaption aria-hidden="true">格式化说明</figcaption></figure><blockquote><p>类型是唯一的必填项</p></blockquote><blockquote><p><code>format()</code>使用<code>可变参数列表(variable argument lists, varargs)</code>来对应有不同数目排列组合的参数。</p></blockquote><h4 id="日期格式">2.5 日期格式</h4><p><code>Date</code>类型是Java上表示时间用的，数值与日期时间格式化的主要差别在于日期格式的类型是用<code>"t"</code>开头的两个字符表示：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dateFormat.PNG" alt="日期格式" /><figcaption aria-hidden="true">日期格式</figcaption></figure><p><code>java.util.Date</code>适合用于查看当前日期时间，但许多功能已经停用。更多功能推荐使用API <code>java.util.Calendar</code>。<code>Calendar</code>是一个抽象类，当需要<code>Calendar</code>类型时，需要从<code>JVM</code>获取一个子类实例。需要用到静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br></pre></td></tr></table></figure><p>通过调用<code>getInstance()</code>会返回一个具体子类的实例。一般默认返回<code>java.util.GregorianCalendar</code>的实例。<code>Calendar</code>类的几个关键特性：</p><ul><li>字段会保持状态。比如可以读取或设置<code>year</code>或<code>month</code>字段；</li><li>日期和时间可以运算。</li><li>日期与时间可以用<code>milliseconds</code>表示。即可以将日期转化为微秒，也可以将微秒转换为日期。(相对于<code>1970年1月1日</code>的微秒数)。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/CalendarExample.PNG" alt="Calendar示例" /><figcaption aria-hidden="true">Calendar示例</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;盘算一下。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--9 构造器与垃圾收集器</title>
    <link href="https://wuyunjie.top/2021/05/13/JavaLearning_Head_First_Java_9_constructors_and_garbage_collection.html"/>
    <id>https://wuyunjie.top/2021/05/13/JavaLearning_Head_First_Java_9_constructors_and_garbage_collection.html</id>
    <published>2021-05-13T14:35:19.000Z</published>
    <updated>2021-05-14T04:53:44.341Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>对象有生死。 <a id="more"></a></p></blockquote><h3 id="栈与堆">1. 栈与堆</h3><p><code>Java</code>中主要在意两种内存区域：对象的生存空间<code>堆(heap)</code>与方法调用及变量的生存空间<code>栈(stack)</code>。<code>Java</code>虚拟机启动时，会从底层操作系统取得一块内存，用于执行Java程序。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/stackHeap.PNG" alt="栈与堆" /><figcaption aria-hidden="true">栈与堆</figcaption></figure><p>几乎所有对象都存活于可垃圾回收的堆上，而变量根据它的类型判断存在于那一个内存区域。实例变量存在于堆中，而局部变量(也叫区域变量)存在于栈上，所以也叫栈变量。</p><blockquote><ul><li><code>实例变量</code>被声明在类中方法之外，代表每个独理对象的“字段”，存在于所属对象中。</li><li><code>局部变量</code>和<code>方法</code>被声明在方法中，是<code>暂时</code>的，生命周期只限于方法被放置于栈上这段时间(即方法调用到执行完毕)</li></ul></blockquote><h4 id="局部变量">1.1 局部变量</h4><p>调用一个方法时，该方法会放在调用栈的栈顶。实际上放到栈顶的时<code>栈帧(stack frame)</code>，带有方法的状态，程序计数器及所有的局部变量值。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/twoMthodsStack.PNG" alt="放了两个方法的栈" /><figcaption aria-hidden="true">放了两个方法的栈</figcaption></figure><p>比如<code>foo()</code>调用了<code>bar()</code>，则<code>bar()</code>方法会放置在<code>foo()</code>上面。</p><h4 id="对象局部变量">1.2 对象局部变量</h4><p>非<code>primitive</code>的变量只是保存对象的引用，对象放于堆上，而局部变量本身放于栈上。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/objectLocalVariable.PNG" alt="对象局部变量" /><figcaption aria-hidden="true">对象局部变量</figcaption></figure><h4 id="实例变量">1.3 实例变量</h4><p>实例变量存在于对象所属的堆空间上。</p><ul><li>如果实例变量全是<code>primitive</code>主数据类型，<code>Java</code>会根据其类型的大小为该实例变量留下空间</li><li>如果实例变量是一个对象，会留下对象引用所用到的空间，而不是对象本身。</li></ul><h3 id="构造函数">2. 构造函数</h3><h4 id="创建对象">2.1 创建对象</h4><p>声明对象和赋值的3个步骤：<code>声明引用变量</code>、<code>创建对象</code>、<code>连接对象和引用</code>。第二步<code>创建对象</code>看起来好像在调用类名的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duck myDuck = <span class="keyword">new</span> Duck();</span><br></pre></td></tr></table></figure><p>实际上调用的是<code>Duck</code>的构造函数。</p><blockquote><p>构造函数并不是方法，它带有<code>new</code>的时候会执行的程序代码，在初始化对象时执行。调用构造函数唯一的方法是通过<code>new</code>新建一个类对象。</p></blockquote><p>未写构造函数时，编译器会有一个默认构造函数。下面是一个默认构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>构造函数没有返回类型，名字必须与类名相同。</p></li><li><p>可以有与类同名的方法而不会变成构造函数。</p></li><li><p>构造函数不会被继承。</p></li></ul></blockquote><p>构造函数的一个关键特征是，在对象与引用连接前就执行，可以对对象进行预处理。大部分人使用构造函数来初始化对象的状态，也就是给对象的实例变量赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> size;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">(<span class="keyword">int</span> duckSize)</span> </span>&#123; <span class="comment">// 构造函数加上参数</span></span><br><span class="line">     System.out.println(“Quack”);</span><br><span class="line">    size = duckSize;</span><br><span class="line">     System.out.println(“size is “ + size);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseADuck</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Duck d = <span class="keyword">new</span> Duck(<span class="number">42</span>); <span class="comment">// 传值初始化类对象</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最好要有不需要参数的构造函数，来对应参数无法确定的默认情况。</p></blockquote><p>只有在完全没定义构造函数时，编译器才会帮忙编写默认构造函数。如果已经写了一个有参数的构造函数，编译器并不会增加无参数的构造函数，需要<code>手动编写</code>。</p><blockquote><p>构造函数可以是<code>公有</code>、<code>私有</code>或<code>不指定</code>的。</p></blockquote><h4 id="父类及继承与构造函数的关系">2.2 父类及继承与构造函数的关系</h4><p>在创建新对象时，所有继承下来的构造函数都会执行。即每个父类的构造函数都会在子类对象创建时期执行。</p><blockquote><p>抽象类也有构造函数，只是无法对其执行<code>new</code>操作，他的构造函数会在子类创建实例时执行。</p></blockquote><p>如果<code>Hippo</code>对象继承<code>Animal</code>，<code>Animal</code>继承了<code>Object</code>，那么创建对象的过程被称为一个<code>"构造函数链(Constructor Chaining)"</code>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/ConstructorChaining.PNG" alt="Hippo类构造函数调用" /><figcaption aria-hidden="true">Hippo类构造函数调用</figcaption></figure><blockquote><p>调用父类构造函数唯一的方法时调用<code>super()</code>。</p></blockquote><p>如果没有显式调用<code>super()</code>，编译器会自动加上<code>super()</code>的调用。且编译器自动加入的一定是<strong>没有参数的构造函数</strong>。</p><blockquote><p><code>super()</code>的调用必须是构造函数的第一个语句</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boop</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>();</span><br><span class="line">     size = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过要求父类的构造函数必须有名字，可以使得子类可以继承父类的<code>get</code>方法来访问私有的实例变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String theName)</span> </span>&#123;</span><br><span class="line">        name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hippo</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hippo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeHippo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hippo h = <span class="keyword">new</span> Hippo(<span class="string">"Buffy"</span>);</span><br><span class="line">        System.out.println(h.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类没有无参构造函数时，子类必须显式调用父类的构造函数，不然编译无法通过。</p><p>也可以在同一个类中调用另外的构造函数。比如多个构造函数有相同的工作部分，可以把这部分代码放在一个构造函数中，然后由其他构造函数调用。</p><blockquote><p>使用<code>this()</code>来从某个构造函数调用同一个类的另外一个构造函数。</p><p><code>this()</code>只能在构造函数中，且也必须时第一行语句。所以<code>super()</code>和<code>this()</code>不能在一个构造函数中同时调用。</p></blockquote><h4 id="垃圾收集器">3 垃圾收集器</h4><h4 id="对象的生命周期">3.1 对象的生命周期</h4><p>对象的生命周期取决于引用到它的"引用"，引用变量的声明周期又看它是局部变量还是实例变量。</p><blockquote><ul><li>局部变量只会存活在声明该变量的方法中</li><li>实例变量的寿命与对象相同。</li></ul></blockquote><p><strong>"life"与"scope"的差别</strong></p><ul><li><strong>life</strong>。只要变量的堆栈块还存在于堆栈上，局部变量就算存活。</li><li><strong>scope</strong>。局部变量的范围只限于声明它的方法之内。当此方法调用其他方法时，该变量依旧存活，但不在目前执行范围内。</li></ul><p>如果对象的唯一引用解散，那么对象就会从堆中被抛弃，变成可回收的。</p><blockquote><p>若没有引用指向该对象，对象无法被获取，<code>垃圾收集器(GC)</code>会自动回收内存空间。</p></blockquote><p>有三种方法可以释放对象的引用：</p><ol type="1"><li><p>引用永久性的离开它的范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Life z = <span class="keyword">new</span> Life();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用被赋值到其他对象上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Life z = <span class="keyword">new</span> Life();</span><br><span class="line">z = <span class="keyword">new</span> Life();</span><br></pre></td></tr></table></figure></li><li><p>直接将引用设定为<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Life z = <span class="keyword">new</span> Life();</span><br><span class="line">z = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对象有生死。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--8 接口与抽象类</title>
    <link href="https://wuyunjie.top/2021/05/13/JavaLearning_Head_First_Java_8_interfaces_and_abstract_classes.html"/>
    <id>https://wuyunjie.top/2021/05/13/JavaLearning_Head_First_Java_8_interfaces_and_abstract_classes.html</id>
    <published>2021-05-13T09:12:14.000Z</published>
    <updated>2021-05-13T09:12:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>继承只是个开始。 <a id="more"></a></p></blockquote><h3 id="抽象类">1. 抽象类</h3><h4 id="抽象类-1">1.1 抽象类</h4><p>有些类不应该被初始化。比如如果尝试创建一个<code>Animal</code>对象，很难定义该对象或者说该对象并没有意义(没有一种叫做<code>Animal</code>的动物)。而又需要<code>Animal</code>类来继承和产生多态，需要<strong>限制只有它的子类才能被初始化</strong>。</p><p>通过标记类为<code>抽象类</code>，可以告诉编译器这个类不能创建任何类型实例。记让这个类不能被<code>"nwe"</code>出来。设计抽象类只需要在类前加入关键词<code>abstract</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Canie</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roam</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是可以用这种抽象类作为引用类型给多态使用。不是<code>抽象(abstract)</code>的类就被称为<code>具体(concrete)</code>类</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/abstractConcrete.PNG" alt="抽象与具体" /><figcaption aria-hidden="true">抽象与具体</figcaption></figure><h4 id="抽象方法">1.2 抽象方法</h4><p>方法也可以被标及为<code>abstract</code>。抽象类代表此类必须要被<code>extend</code>，抽象方法代表此方法必须要被覆盖。</p><blockquote><p><strong>抽象的方法没有实体</strong></p></blockquote><p>比如一个抽象的方法可以写作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>如果声明了一个抽象方法，那么这个类也必须被标记为抽象类。</p><blockquote><p>即<strong>非抽象类不能拥有抽象方法</strong></p></blockquote><p>抽象方法的意义是<u>就算无法实现出方法的内容，但还是可以定义出一组子类共同的协议</u>。由于抽象方法没有内容，只是为了标记出多态而存在，所以<strong>继承树下的第一个具体类必须要实现出所有的抽象方法</strong>。</p><p>一个抽象类继承另一个抽象类，不需要实现其抽象方法。但抽象类可以同时带有抽象和非抽象方法，所以如果有需要，也可以对抽象方法进行实现。</p><h4 id="多态范例">1.3 多态范例</h4><p>如果要一个可以保持Dog对象的list，可以写一个专用的list类。但如果Cat也要用同样的方法，如果重新编写一个类似的类过于麻烦。可以利用多态的特点，编写一个<code>AnimalList</code>类来处理<code>Animal</code>的所有子类。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/animalList.PNG" alt="Animal List" /><figcaption aria-hidden="true">Animal List</figcaption></figure><p>进一步，可以设计处理<code>Animal</code>之上的类，得到更通用、更抽象的类。</p><blockquote><p>Java中所有类都是从<code>Object</code>这个类继承出来的。<code>Object</code>是所有类的源头，即所有类的父类。</p></blockquote><p>没有直接继承过其他类的类会隐含地继承<code>Object</code>类。这样一个终极类(<code>ultra-super-megaclass</code>)需要带有一些每个对象都需要的行为。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/ultra-super-megaclass-Object.PNG" alt="终极类Object" /><figcaption aria-hidden="true">终极类<code>Object</code></figcaption></figure><p><code>Object</code>不是一个正式的<code>Java</code>抽象类，也就是说可以创建<code>Object</code>对象。</p><blockquote><p><code>Object</code>对象的意义主要在于，有时需要一个<u>通用的、轻量化的</u>对象。比如在线程同步中。</p></blockquote><p><code>Object</code>类的主要目的是：</p><ul><li>作为多态让方法可以应付多种类型的机制；</li><li>提供Java在执行期间对任何对象都需要实现的程序代码。</li></ul><p>而如果使用<code>Object</code>类型的多态引用会带来一些问题：</p><ul><li>以<code>Object</code>类型作为引用时，<code>Java</code>会把它当作<code>Object</code>类型的实例，这代表只能调用由<code>Object</code>声明的方法。</li><li>任何重<code>ArrayList&lt;Object&gt;</code>取出的东西都会被当作<code>Object</code>类型的引用，也就导致无法复制给原来的类型。</li></ul><blockquote><p>编译器是<u>根据引用类型来判断有那些method可以调用，而不是<code>Object</code>的确实类型</u>。</p></blockquote><p>对象会带有从父类继承的所有东西。所以无论这个对象实际类型，它也是一个<code>Object</code>实例。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/snowboardObject.PNG" alt="内部Object" /><figcaption aria-hidden="true">内部<code>Object</code></figcaption></figure><p>但也有办法可以让<code>Object</code>引用恢复成原来的类，那就是使用<code>类型转化</code>。如果确定对象类型，可以直接转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog d = (Dog) o;</span><br></pre></td></tr></table></figure><p>如果无法确定类型，可以使用<code>instanceof</code>来检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">Dog d = (Dog) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口">2. 接口</h3><h4 id="接口-1">2.1 接口</h4><p>如果想要修改<code>合约</code>，比如为Dog类加入Pet的方法，而又不影响其他非Pet类的使用，就需要<code>接口</code>。先看看没有<code>接口</code>会遇到的问题，可以用如下方式加入<code>Pet</code>方法进行修改：</p><ol type="1"><li>把<code>Pet</code>方法加入到<code>Animal</code>类中。<ul><li><code>优点</code>：所有子类马上继承<code>Pet</code>方法，无需改变子类程序代码。</li><li><code>缺点</code>：<code>非Pet</code>类也会继承到<code>Pet</code>方法</li></ul></li><li>把<code>Pet</code>方法加入到<code>Animal</code>类中，但把其设定为抽象的。<ul><li><code>优点</code>：<code>非Pet</code>类覆盖方法时，作出合理动作。</li><li><code>缺点</code>：所有子类都需要实现<code>Pet</code>方法，耗时。</li></ul></li><li>把方法添加到需要的子类中。<ul><li><code>优点</code>：<code>非Pet</code>类无需实现，更灵活。</li><li><code>缺点</code>：失去合约保证，且多态无法其作用。</li></ul></li></ol><p>真正需要的是：<code>Pet</code>方法只需要在宠物上实现；所有宠物类都有相同的方法定义；可以运用到多态。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/twoSuperClassesAtTop.PNG" alt="继承多个上次父类" /><figcaption aria-hidden="true">继承多个上次父类</figcaption></figure><p>图中的<code>多重继承</code>会有被称为<code>”致命方块”（Deadly Diamond of Death）</code>的问题，而且Java也并不支持这种方式。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/DeadlyDiamondofDeath.PNG" alt="”致命方块”（Deadly Diamond of Death）" /><figcaption aria-hidden="true">”致命方块”（Deadly Diamond of Death）</figcaption></figure><p>·同名的实例变量和函数会导致冲突，带来更复杂的问题。</p><p>Java里使用<code>接口(interface)</code>来解决这一问题，接口把全部方法设为抽象的，所有子类都需要实现其方法。接口定义如下，使用<code>interface</code>代替<code>class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pet</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>接口实现如下，使用关键字<code>implements</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Canine</span> <span class="keyword">implements</span> <span class="title">Pet</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现某接口的类<code>必须实现它所有的方法</code>，因为这些方法都是<code>public</code>与<code>abstract</code>的。</p></blockquote><p>接口主要为<code>多态</code>服务，以接口取代具体的子类或抽象父类作为参数或返回值，<code>可以传入任何有实现该接口的东西</code>。此外，使用接口可以继承超过一个以上的来源。</p><blockquote><p>不同继承树的类也可以实现相同的接口</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceTreeInterface.PNG" alt="继承树中的接口" /><figcaption aria-hidden="true">继承树中的接口</figcaption></figure><p>用接口作为多态类型时，对象可以来自任何地方。唯一的条件是<strong>该对象必须是来自有实现此接口的类</strong>。类可以实现多个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Pet</span>, <span class="title">Saveable</span>, <span class="title">Paintable</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>可以把接口理解为<strong>类可以扮演的角色</strong>。</p><h4 id="super的使用">2.2 <code>Super</code>的使用</h4><p>如果子类不打算完全覆盖某个父类方法，又需要加入额外动作，可以使用<code>super</code>关键词来调用父类方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">runReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// set-up report </span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">printReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// generic printing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuzzwordsReport</span> <span class="keyword">extends</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.runReport();  <span class="comment">//调用父类方法</span></span><br><span class="line">buzzwordCompliance();</span><br><span class="line">printReport();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">buzzwordCompliance</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/superClass.PNG" alt="superClass" /><figcaption aria-hidden="true">superClass</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;继承只是个开始。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--2 Java内存区域与内存溢出异常</title>
    <link href="https://wuyunjie.top/2021/05/12/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_2_Java_memory_area.html"/>
    <id>https://wuyunjie.top/2021/05/12/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_2_Java_memory_area.html</id>
    <published>2021-05-12T15:03:54.000Z</published>
    <updated>2021-05-12T15:03:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code> <a id="more"></a></p></blockquote><p>在<code>Java</code>虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的<code>delete/free</code>代码，不容易出现内存泄漏和内存溢出问题。</p><p>但也因此，如果不了解虚拟机是怎样使用内存的，一旦出现内存泄漏和溢出方面的问题，那排查错误、修正问题将会成为一项异常艰难的工作。</p><h3 id="运行时数据区域">1 运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为<strong>若干个不同的数据区域</strong>。这些区域有各自的用途，以及创建和销毁的时间，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/runtimeDataArea.PNG" alt="Java虚拟机运行时数据区" /><figcaption aria-hidden="true">Java虚拟机运行时数据区</figcaption></figure><h4 id="程序计数器">1.1 程序计数器</h4><p><code>程序计数器（Program Counter Register）</code>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。字节码解释器工作时就是通过改变这个计数器的值来<strong>选取下一条需要执行的字节码指令</strong>。</p><blockquote><p>程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p></blockquote><p>Java虚拟机的多线程是通过<strong>线程轮流切换、分配处理器执行时间</strong>的方式来实现的，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</p><blockquote><p>这类内存区域为“线程<code>私有</code>”的内存</p></blockquote><p>如果线程正在执行的是一个<code>Java方法</code>，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<code>本地（Native）方法</code>，这个计数器值则应为空（Undefined）。</p><blockquote><p>此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何<code>OutOfMemoryError情况</code>的区域。</p></blockquote><h4 id="java虚拟机栈">1.2 Java虚拟机栈</h4><p><code>Java虚拟机栈（Java Virtual Machine Stack）</code>描述的是<strong>Java<code>方法</code>执行的线程内存模型</strong>：每个<code>方法</code>被执行的时候，Java虚拟机都会同步创建一个<code>栈帧（Stack Frame）</code>用于存储<em>局部变量表、操作数栈、动态连接、方法出口</em>等信息。</p><blockquote><p><code>Java虚拟机栈（Java Virtual Machine Stack）</code>也是线程<code>私有</code>的，它的生命周期与线程相同。</p></blockquote><p>有人把Java内存区域笼统地划分为<code>堆内存（Heap）</code>和<code>栈内存（Stack）</code>。<strong>“栈”通常就是指虚拟机栈</strong>，或者更多的情况下只是指虚拟机栈中<em>局部变量表部分</em>。</p><blockquote><p>局部变量表中的存储空间以<code>局部变量槽（Slot）</code>来表示，其中64位长度的<code>long</code>和<code>double</code>类型的数据会<em>占用两个变量槽</em>，其余的数据类型只占用一个。</p><p><strong>局部变量表所需的内存空间在编译期间完成分配</strong>，一个方法需要在栈帧中分配多大的局部变量空间是<strong>完全确定</strong>的，在方法运行期间不会改变局部变量表的大小(<em>“大小”是指变量槽的数量</em>)</p></blockquote><p>这个内存区域规定了两类异常状况：</p><blockquote><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError异常</code></li><li>如果Java虚拟机栈容量可以<em>动态扩展</em>，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError异常</code></li></ul></blockquote><h4 id="本地方法栈">1.3 本地方法栈</h4><p><code>本地方法栈（Native Method Stacks）</code>与虚拟机栈所发挥的作用是非常相似的，其<strong>区别</strong>只是：</p><blockquote><p>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务；</p><p>本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p></blockquote><p>有的Java虚拟机（譬如<code>Hot-Spot虚拟机</code>）直接把<strong>本地方法栈和虚拟机栈合二为一</strong>。</p><blockquote><p>本地方法栈规定了<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p></blockquote><h4 id="java堆">1.4 Java堆</h4><p><code>Java堆（Java Heap）</code>唯一目的就是<strong>存放对象实例</strong>，Java世界里<em>“几乎”</em>所有的对象实例都在这里分配内存。Java堆是被所有线程<code>共享</code>的一块内存区域，在虚拟机启动时创建，也是虚拟机所管理的内存中<em>最大</em>的一块。</p><blockquote><p>在《Java虚拟机规范》中对Java堆的描述是：<code>“所有的对象实例以及数组都应当在堆上分配”</code></p></blockquote><p>Java堆是<strong>垃圾收集器管理的内存区域</strong>，因此它也被称作<code>“GC堆”（Garbage Collected Heap）</code>。如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个<strong>线程私有</strong>的<code>分配缓冲区 （Thread Local Allocation Buffer，TLAB）</code>。</p><p>Java堆可以处于<code>物理上不连续</code>的内存空间中，但在逻辑上它应该被视为连续的。</p><blockquote><p>如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出<code>OutOfMemoryError异常</code>。</p></blockquote><h4 id="方法区">1.5 方法区</h4><p><code>方法区（Method Area）</code>用于存储<strong>已被虚拟机加载</strong>的<em>类型信息、常量、静态变量、即时编译器编译后的代码缓存</em>等数据。与Java堆一样，是各个线程<code>共享</code>的内存区域。</p><blockquote><p>《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作<code>“非堆”（Non-Heap）</code></p></blockquote><p>很多人都更愿意把方法区称为<code>“永久代”（Permanent Generation）</code>，或将两者混为一谈。<strong>本质上这两者并不是等价的</strong>，因为仅仅是<strong>使用永久代来实现方法区</strong>而已。</p><blockquote><ul><li>永久代来实现方法区导致了Java应用更容易遇到<code>内存溢出</code>的问题（永久代有<code>-XX：MaxPermSize</code>的上限，即使不设置也有默认大小)；</li><li>在JDK 6的时候HotSpot开发团队就有<strong>放弃永久代</strong>，逐步改为<strong>采用本地内存（Native Memory）</strong>来实现方法区的计划了；</li><li>JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出；</li><li>而到了JDK 8，终于<strong>完全废弃了永久代的概念</strong>，改用与JRockit、J9一样在本地内存中实现的<code>元空间（Meta-space）</code>来代替。</li></ul></blockquote><p>除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择<strong>不实现垃圾收集</strong>。</p><blockquote><p>这区域的内存回收目标主要是针<strong>对常量池的回收</strong>和<strong>对类型的卸载</strong></p></blockquote><blockquote><p>如果方法区无法满足新的内存分配需求时，将抛出 <code>OutOfMemoryError异常</code>。</p></blockquote><h4 id="运行时常量池">1.6 运行时常量池</h4><p><code>运行时常量池（Runtime Constant Pool）</code>是<strong>方法区的一部分</strong>。<code>Class文件</code>中有一项信息是<code>常量池表（Constant Pool Table）</code>，用于存放编译期生成的各种<strong>字面量</strong>与<strong>符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><blockquote><p>Class文件中还包括类的<em>版本、字段、方法、接口等描述信息</em></p></blockquote><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，运行期间也可以将新的常量放入池中。</p><blockquote><p>当常量池无法再申请到内存时会抛出<code>OutOfMemoryError异常</code>。</p></blockquote><h4 id="直接内存">1.7 直接内存</h4><p><code>直接内存（Direct Memory）</code>并不是虚拟机运行时数据区的一部分。</p><blockquote><p>在<code>JDK 1.4</code>中新加入了<code>NIO（New Input/Output）类</code>，引入了一种基于<code>通道（Channel）</code>与<code>缓冲区 （Buffer）</code>的I/O方式，它可以使用<strong><code>Native函数库</code>直接分配堆外内存</strong>，然后通过一个存储在Java堆里面的<code>DirectByteBuffer</code>对象作为<strong>这块内存的引用</strong>进行操作。</p><p>避免了在<code>Java堆</code>和<code>Native堆</code>中来回复制数据。</p></blockquote><p>本机直接内存的分配不会受到Java堆大小的限制，但是肯定还是会受到本机总内存大小以及处理器寻址空间的限制：</p><blockquote><p>动态扩展时可能会出现 <code>OutOfMemoryError异常</code>。</p></blockquote><h3 id="hotspot虚拟机对象探秘">2. <code>HotSpot</code>虚拟机对象探秘</h3><h4 id="对象的创建">2.1 对象的创建</h4><p>在虚拟机中<code>(普通)对象</code>的创建过程如下：</p><blockquote><ol type="1"><li>当Java虚拟机遇到一条<code>字节码new指令</code>时，首先将去检查这个指令的参数是否能在<code>常量池</code>中定位到一个类的<code>符号引用</code>，并且检查这个符号引用代表的类是否已被<strong>加载、解析和初始化</strong>过。如果没有，必须先执行相应的<strong>类加载过程</strong>。</li><li>在类加载检查通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。<em>对象所需内存的大小在类加载完成后便可完全确定</em>，为对象分配空间的任务实际上便等同于把一块<u>确定大小</u>的内存块从<code>Java堆</code>中划分出来。<ul><li><code>“指针碰撞”（Bump The Pointer）</code>。如果Java堆中内存是<strong>绝对规整</strong>的，所有被<u>使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器</u>。那所分配内存就仅仅是把指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</li><li><code>“空闲列表”（Free List）</code>。如果Java堆中的内存是<strong>不规整</strong>的，已被使用的内存和空闲的内存相互交错在一起，<u>虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</u>。</li><li>Java堆是否规整<u>由所采用的垃圾收集器是否带有<code>空间压缩整理（Compact）</code>的能力决定</u>。</li><li>为了保证对象创建过程<code>线程安全</code>，有两种方法：<ul><li>对分配内存空间的动作进行<code>同步处理</code>——实际上虚拟机是采用<code>CAS配上失败重试</code>的方式保证<strong>更新操作的原子性</strong>；</li><li><u>把内存分配的动作按照线程划分在不同的空间之中进行</u>，即每个线程在Java堆中<strong>预先分配一小块内存</strong>，称为<code>本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）</code>。线程要分配内存，就在该线程的本地缓冲区中分配，<u>只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定</u>。</li></ul></li></ul></li><li>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都<strong><code>初始化为零值</code></strong>，如果使用了<code>TLAB</code>，这一项工作也可以提前至<code>TLAB</code>分配时进行。</li><li>Java虚拟机对对象进行<strong>必要的设置</strong>，例如<u>对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的<code>GC</code>分代年龄等</u>信息。这些信息存放在对象的<code>对象头（Object Header）</code>之中。</li></ol></blockquote><p>从<code>虚拟机的视角</code>来看，一个新的对象已经产生了。但是从<code>Java程序的视角</code>看来，对象创建才<u>刚刚开始</u>:</p><blockquote><p><strong>构造函数</strong>，即<code>Class文件</code>中的<code>&lt;init&gt;()</code>方法还没有执行，<u>所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好</u>。</p></blockquote><h4 id="对象的内存布局">2.2 对象的内存布局</h4><p>在<code>HotSpot虚拟机</code>里，对象在堆内存中的存储布局可以划分为三个部分：<code>对象头（Header）</code>、<code>实例数据（Instance Data）</code>和<code>对齐填充（Padding）</code>。</p><h5 id="对象头">2.2.1 对象头</h5><p>对象头部分包括两类信息：</p><ol type="1"><li>第一类是用于存储<strong>对象自身的<code>运行时数据</code></strong>，如<u>哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</u>等。官方称它为<code>“Mark Word”</code>。</li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/markWord.PNG" alt="HotSpot虚拟机对象头Mark Word" /><figcaption aria-hidden="true">HotSpot虚拟机对象头<code>Mark Word</code></figcaption></figure><blockquote><p><code>Mark Word</code>被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p></blockquote><ol start="2" type="1"><li>另外一部分是<strong><code>类型指针</code></strong>，即<u>对象指向它的类型元数据的指针</u>，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</li></ol><blockquote><p>此外，如果对象是一个<code>Java数组</code>，那在对象头中还必须有一块用于<u>记录数组长度</u>的数据。</p></blockquote><h5 id="实例数据">2.2.2 实例数据</h5><p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面<u>所定义的各种类型的字段内容</u>。</p><blockquote><p>存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</p><ul><li>HotSpot虚拟机默认的分配顺序为<code>longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs）</code>，相同宽度的字段总是被分配到一起存放</li><li>在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前</li></ul></blockquote><h5 id="对齐填充">2.2.3 对齐填充</h5><p>对齐填充<em>不是必然存在</em>的，它仅仅起着<code>占位符</code>的作用。主要由于HotSpot虚拟机的自动内存管理系统要求<u>对象起始地址必须是8字节的整数倍</u>。</p><h4 id="对象的访问定位">2.3 对象的访问定位</h4><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。主流的访问方式主要有<code>使用句柄</code>和<code>直接指针</code>两种：</p><ol type="1"><li><code>使用句柄</code>。Java堆中将可能会划分出一块内存来作为<code>句柄池</code>，<code>reference</code>中存储的就是对象的<code>句柄地址</code>，而句柄中包含了<u>对象实例数据与类型数据</u>各自具体的<strong>地址信息</strong>。</li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/handleAccess.PNG" alt="通过句柄访问对象" /><figcaption aria-hidden="true">通过句柄访问对象</figcaption></figure><blockquote><p>最大好处就是reference中存储的是稳定句柄地址，在对象被移动时<strong>只会改变句柄中的实例数据指针</strong>，而 <code>reference</code>本身不需要被修改。可以理解为只需要移动对象实例数据。</p></blockquote><ol start="2" type="1"><li><code>直接指针</code>。Java堆中对象的内存布局需要考虑<u>如何放置访问类型数据的相关信息</u>，<code>reference</code>中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/pointerAccess.PNG" alt="通过直接指针访问对象" /><figcaption aria-hidden="true">通过直接指针访问对象</figcaption></figure><blockquote><p>最大的好处就是速度更快，它节省了一次指针定位的时间开销。</p></blockquote><h3 id="outofmemoryerror异常处理">3. <code>OutOfMemoryError</code>异常处理</h3><h4 id="java堆溢出">3.1 Java堆溢出</h4><p>为了捕捉堆溢出，书中实现了如下异常测试程序：</p><blockquote><p>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证<strong><code>GC Roots</code>到对象之间有可达路径</strong>来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>堆的<code>最小值-Xms</code>参数与<code>最大值-Xmx</code>参数设置为一样即可避免堆自动扩展</li><li>参数<code>-XX：+HeapDumpOnOutOf-MemoryError</code>可以让虚拟机在出现内存溢出异常的时候<strong>Dump出当前的内存堆转储快照</strong>以便进行事后分析</li></ul></blockquote><p>运行结果如下：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/heapOOM.PNG" alt="HeapOOM测试结果" /><figcaption aria-hidden="true">HeapOOM测试结果</figcaption></figure><p>要解决这个内存区域的异常，常规的处理方法是首先通过内存映像分析工具对Dump出来的堆转储快照进行分析。</p><blockquote><p>这里使用的是<code>IDEA</code>的插件<code>jprofiler</code>，安装方法参考文章：<a href="https://blog.csdn.net/wytocsdn/article/details/79258247" target="_blank" rel="noopener">Intellij IDEA集成JProfiler性能分析神器</a></p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/heapOOMJprofiler.PNG" alt="HeapOOM Jprofiler结果" /><figcaption aria-hidden="true">HeapOOM Jprofiler结果</figcaption></figure><p>第一步首先应确认内存中<code>导致OOM的对象是</code>否是必要的，也就是要先分清楚到底是出现了<code>内存泄漏（Memory Leak）</code>还是<code>内存溢出（Memory Overflow）</code>。</p><ul><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到<code>GC Roots</code>的<code>引用链</code></li><li>如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数设置，与机器的内存对比，看看是否还有向上调整的空间。</li></ul><h4 id="虚拟机栈和本地方法栈溢出">3.2 虚拟机栈和本地方法栈溢出</h4><p>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，<code>-Xoss参数</code>（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，<strong>栈容量只能由-<code>Xss参数</code>来设定</strong>。</p><p>先将实验范围限制在单线程中操作，尝试下面行为是否能让HotSpot虚拟机产生<code>OutOfMemoryError</code>异常：</p><ol type="1"><li>使用<code>-Xss参数</code>减少栈内存容量。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xss128k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaVMStackSOF.PNG" alt="JavaVMStackSOF结果" /><figcaption aria-hidden="true">JavaVMStackSOF结果</figcaption></figure><blockquote><p>栈容量最小值主要取决于操作系统内存分页大小</p></blockquote><ol start="2" type="1"><li>定义大量的本地变量，增大此方法帧中本地变量表的长度。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> unused1, unused2, unused3, unused4, unused5,</span><br><span class="line">                unused6, unused7, unused8, unused9, unused10,</span><br><span class="line">                unused11, unused12, unused13, unused14, unused15,</span><br><span class="line">                unused16, unused17, unused18, unused19, unused20,</span><br><span class="line">                unused21, unused22, unused23, unused24, unused25,</span><br><span class="line">                unused26, unused27, unused28, unused29, unused30,</span><br><span class="line">                unused31, unused32, unused33, unused34, unused35,</span><br><span class="line">                unused36, unused37, unused38, unused39, unused40,</span><br><span class="line">                unused41, unused42, unused43, unused44, unused45,</span><br><span class="line">                unused46, unused47, unused48, unused49, unused50,</span><br><span class="line">                unused51, unused52, unused53, unused54, unused55,</span><br><span class="line">                unused56, unused57, unused58, unused59, unused60,</span><br><span class="line">                unused61, unused62, unused63, unused64, unused65,</span><br><span class="line">                unused66, unused67, unused68, unused69, unused70,</span><br><span class="line">                unused71, unused72, unused73, unused74, unused75,</span><br><span class="line">                unused76, unused77, unused78, unused79, unused80,</span><br><span class="line">                unused81, unused82, unused83, unused84, unused85,</span><br><span class="line">                unused86, unused87, unused88, unused89, unused90,</span><br><span class="line">                unused91, unused92, unused93, unused94, unused95,</span><br><span class="line">                unused96, unused97, unused98, unused99, unused100;</span><br><span class="line">        stackLength ++;</span><br><span class="line">        test();</span><br><span class="line">        unused1 = unused2 = unused3 = unused4 = unused5 =</span><br><span class="line">        unused6 = unused7 = unused8 = unused9 = unused10 =</span><br><span class="line">        unused11 = unused12 = unused13 = unused14 = unused15 =</span><br><span class="line">        unused16 = unused17 = unused18 = unused19 = unused20 =</span><br><span class="line">        unused21 = unused22 = unused23 = unused24 = unused25 =</span><br><span class="line">        unused26 = unused27 = unused28 = unused29 = unused30 =</span><br><span class="line">        unused31 = unused32 = unused33 = unused34 = unused35 =</span><br><span class="line">        unused36 = unused37 = unused38 = unused39 = unused40 =</span><br><span class="line">        unused41 = unused42 = unused43 = unused44 = unused45 =</span><br><span class="line">        unused46 = unused47 = unused48 = unused49 = unused50 =</span><br><span class="line">        unused51 = unused52 = unused53 = unused54 = unused55 =</span><br><span class="line">        unused56 = unused57 = unused58 = unused59 = unused60 =</span><br><span class="line">        unused61 = unused62 = unused63 = unused64 = unused65 =</span><br><span class="line">        unused66 = unused67 = unused68 = unused69 = unused70 =</span><br><span class="line">        unused71 = unused72 = unused73 = unused74 = unused75 =</span><br><span class="line">        unused76 = unused77 = unused78 = unused79 = unused80 =</span><br><span class="line">        unused81 = unused82 = unused83 = unused84 = unused85 =</span><br><span class="line">        unused86 = unused87 = unused88 = unused89 = unused90 =</span><br><span class="line">        unused91 = unused92 = unused93 = unused94 = unused95 =</span><br><span class="line">        unused96 = unused97 = unused98 = unused99 = unused100 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaVMStackSOF.PNG" alt="JavaVMStackSOF2结果" /><figcaption aria-hidden="true">JavaVMStackSOF2结果</figcaption></figure><blockquote><p>出现<code>StackOverflowError</code>异常时，会有明确错误堆栈可供分析，相对而言比较容易定位到问题所在。</p></blockquote><h4 id="方法区和运行时常量池溢出">3.3 方法区和运行时常量池溢出</h4><h5 id="运行时常量池-1">运行时常量池</h5><p><code>String::intern()</code>是一个本地方法，它的作用是：</p><ul><li>如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；</li><li>否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</li></ul><p>对于<code>JDK 6</code>来运行如下代码，会出现运行时常量池的内存溢出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-XX:PermSize=6M -XX:MaxPermSize=6M</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Set保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在short范围内足以让6MB的PermSize产生OOM了</span></span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有安装<code>JDK 6</code>就没测试了，按书中所述，会出现如下异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">at java.lang.String.intern(Native Method)</span><br><span class="line">at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java: <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p><code>“PermGen space”</code>说明运行时常量池的确是属于方法区的一部分。使用<code>JDK 7</code>或更高版本的<code>JDK</code>并不会得到相同的结果，因为自<code>JDK 7</code>起，原本<u>存放在永久代的字符串常量池被移至Java堆之中</u>，所以在<code>JDK 7</code>及以上版 本，限制方法区的容量对该测试用例来说是毫无意义的。</p><h5 id="字符串常量池的实现方式的影响">字符串常量池的实现方式的影响</h5><p>对于字符串常量池的实现引出了对<code>String.intern()</code>这个方法的影响，见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1);</span><br><span class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>在<code>JDK 6</code>中运行，会得到<strong>两个<code>false</code></strong>。在<code>JDK 6</code>中，<code>intern()</code>方法会<strong>把首次遇到的字符串实例复制到永久代的字符串常量池中存储</strong>，返回的也是<u>永久代里面这个字符串实例</u>的引用，而由<code>StringBuilder</code>创建的字符串对象实例<strong>在Java堆</strong>上，所以必然不可能是同一个引用，结果将返回false。</p></li><li><p>在<code>JDK 7</code>中运行，会得到一个<code>true</code>和一个<code>false</code>。<code>JDK 7</code>的<code>intern()</code>方法<strong>不需要再拷贝字符串的实例到永久代</strong>，<u>字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可</u>，因此intern()返回的引用和由<code>StringBuilder</code>创建的那个字符串实例就是同一个。</p><ul><li>对<code>str2</code>比较返回<code>false</code>，这是因为<code>“java”</code>这个字符串在执行<code>StringBuilder.toString()</code>之前就已经出现过了，字符串常量池中已经有它的引用。<code>“java”</code>在加载<code>sun.misc.Version</code>这个类的时候进入常量池</li></ul></li></ul></blockquote><h5 id="方法区-1">方法区</h5><p>方法区的主要职责是用于存放类型的相关信息，如<u>类名、访问修饰符、常量池、字段描述、方法描述</u>等。对于这部分区域的测试，基本的思路是<strong>运行时产生大量的类去填满方法区，直到溢出为止</strong>。作者借助了<code>CGLib</code>直接操作字节码运行时生成了大量的动态类。</p><blockquote><p>类似这样的代码确实可能会<strong>出现在实际应用</strong>中：当前的很多主流框架，如<code>Spring</code>、<code>Hibernate</code>对类进行增强时，都会使用到<code>CGLib</code>这类字节码技术。</p></blockquote><p>一个类如果要被垃圾收集器回收，要达成的条件是<strong>比较苛刻</strong>的。在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。</p><p><code>JDK 8</code>以后，<code>元空间</code>作为<code>永久代</code>替代者登场。<code>HotSpot</code>还是提供了一 些参数作为元空间的防御措施：</p><blockquote><ul><li><code>-XX：MaxMetaspaceSize</code>：设置元空间最大值；</li><li><code>-XX：MetaspaceSize</code>：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整</li><li><code>-XX：MinMetaspaceFreeRatio</code>：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。</li></ul></blockquote><h4 id="本机直接内存溢出">3.4 本机直接内存溢出</h4><p><code>直接内存（Direct Memory）</code>的容量大小可通过<code>-XX：MaxDirectMemorySize</code>参数来指定，如果不去指定，则默认与<code>Java堆最大值</code>（由<code>-Xmx</code>指定）一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通 过反射获取<code>Unsafe</code>实例进行内存分配，虽然使用<code>DirectByteBuffer</code>分配内存也会抛出<code>内存溢出异常</code>，但它抛出异常时并没有真正向操作系统申请分配内存，而是<u>通过计算得知内存无法分配就会在代码里手动抛出溢出异常</u>，真正申请分配内存的方法是<code>Unsafe::allocateMemory()</code>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/DirectMemoryOOM.PNG" alt="DirectMemoryOOM结果" /><figcaption aria-hidden="true">DirectMemoryOOM结果</figcaption></figure><p>如果发现内存溢出之后产生的<code>Dump文件</code>很小，而程序中又直接或间接使用了<code>DirectMemory</code>（<strong>典型的间接使用就是<code>NIO</code></strong>），可以考虑重点检查一下直接内存方面的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。&lt;/code&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head First Java]--7 继承与多态</title>
    <link href="https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_7_inheritance_and_polymorphism.html"/>
    <id>https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_7_inheritance_and_polymorphism.html</id>
    <published>2021-05-12T11:38:08.000Z</published>
    <updated>2021-05-12T11:38:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>规划程序时要考虑未来。 <a id="more"></a></p></blockquote><h3 id="继承">1. 继承</h3><h4 id="继承-1">1.1 继承</h4><p>设计<strong>继承</strong>时，会把共同程序代码放在某个类中，告诉其他类此类事他们的父类。当某个类继承另一个类的时候，也就是子类继承自父类。继承的关系意味着子类继承了父类的方法和实例变量。</p><p>如下一个例子</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceExample.PNG" alt="继承" /><figcaption aria-hidden="true">继承</figcaption></figure><p><code>PantherMan</code>会自动继承<code>SuperHero</code>的实例变量和方法，且<code>PantherMan</code>也可以加入自己的方法和实例变量，或者覆盖掉继承的方法。而<code>FriedEggMan</code>不需要独特的行为，所以没有覆盖任何方法。</p><blockquote><p>实例变量无法覆盖是因为不需要，它们没有定义特殊的行为。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceExample.PNG" alt="继承范例" /><figcaption aria-hidden="true">继承范例</figcaption></figure><p>在这个继承范例中，<code>Family Doctor</code>增加了实例变量和方法，<code>Surgeon</code>覆盖了继承的方法并增加了一个新方法。</p><blockquote><ul><li><p>需要注意继承使用的关键词<code>extends</code></p></li><li><p>如果在子类中还打算引用父类的方法，可以使用<code>super</code>关键字：</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.roam();</span><br><span class="line">     <span class="comment">// my own roam stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承层次设计">1.2 继承层次设计</h4><p>比如以设计动物仿真程序为例，主要有以下步骤：</p><ol type="1"><li>找出具有共同属性和行为的对象</li><li>设计代表共同状态与行为的类</li><li>决定子类是否需要让某项行为(即方法的实现)有特定不同的运作方式</li><li>通过寻找使用共同行为的子类来找出更多抽象化的机会</li><li>完成类的继承层次</li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/animalInheritanceTree.PNG" alt="动物类继承层次" /><figcaption aria-hidden="true">动物类继承层次</figcaption></figure><blockquote><p>当调用对象引用的方法时，会调用到与该对象类型最接近的方法。即<code>最低阶</code>会胜出。Java虚拟机会从树的叶节点开始往上寻找方法。</p></blockquote><p>所有子类与其任一个上层父类之间应该都是<code>IS-A</code>的关系。</p><h4 id="存取权限">1.3 存取权限</h4><p>父类可以通过存取权限决定子类是否能够继承某些特定的成员。主要有以下4种存取权限，左边最受限制，越往右限制程度越小：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/accessLevels.PNG" alt="存取权限" /><figcaption aria-hidden="true">存取权限</figcaption></figure><p><code>存取权限(Access levels)</code>控制谁可以接触什么：</p><blockquote><ul><li><code>public</code>类型的成员会被继承</li><li><code>private</code>类型的成员不会被继承</li></ul></blockquote><h4 id="继承的意义">1.4 继承的意义</h4><p>通过继承，子类不需要重新编译就能运行到新版本的父类。此外通过继承可以：</p><ol type="1"><li><p>避免重复的程序代码</p><p>即可以在父类这一单一位置定义共同程序代码。</p></li><li><p>定义出共同的协议</p><p>继承可以确保每个父类下的所有类都会有父类所持有的全部(可继承的)方法。也就是说，通过继承来定义相关类之间的共同协议。</p></li></ol><h4 id="私有类">1.5 "私有类"</h4><p>实际上没有"私有类"的概念，但有三种方法可以防止这个类被继承：</p><ol type="1"><li><p>存取控制。不能标记类为私有，但可以不标记为公有。非公有类只能被同一个包的类继承。</p></li><li><p>使用<code>final</code>修饰符。表示它是继承树的末端，不能被继承。</p><blockquote><p><code>final</code>表示符主要为保证安全，确保方法都是当前版本。</p><p>如果想防止特定方法被覆盖，可以在该方法前表示<code>final</code>修饰符。</p></blockquote></li><li><p>让类只拥有<code>private</code>的构造函数。</p></li></ol><h3 id="多态">2. 多态</h3><p>一般声明引用和创建对象时，重点在于要求引用类型与对象类型必须相符。而在多态下，引用与对象可以是不同类型：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphismExample.PNG" alt="多态" /><figcaption aria-hidden="true">多态</figcaption></figure><p>运用多态时，引用类型可以时实际对象类型的父类。所以可以实现<code>多态数组(polymorphic arrays)</code>这一类东西：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphicArray.PNG" alt="多态数组" /><figcaption aria-hidden="true">多态数组</figcaption></figure><p>参数和返回类型也可以用多态。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphicArgument.PNG" alt="参数多态" /><figcaption aria-hidden="true">参数多态</figcaption></figure><h3 id="覆盖的规则">3. 覆盖的规则</h3><p>当要覆盖父类的方法时，必须遵守以下规则：</p><ol type="1"><li>参数必须一样，且返回类型必须兼容</li><li><strong>不能降低</strong>方法的存取权限</li></ol><h3 id="方法的重载overload">4. 方法的重载(overload)</h3><p>重载的意义是两个方法的名称相同，但参数不同。所以<strong>重载与多态毫无关系</strong>。</p><blockquote><p>重载的方法只是刚好有相同名字的不同方法，它与继承或多态无关</p></blockquote><p>重载的方法有更多的扩展性：</p><ol type="1"><li>返回类型可以不同</li><li>不能只改变返回类型。重载的条件是<strong>要使用不同的参数</strong>。</li><li>可以任意设定存取权限</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;规划程序时要考虑未来。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head First Java]--6 认识Java的API</title>
    <link href="https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_6_Using_the_Java_Library.html"/>
    <id>https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_6_Using_the_Java_Library.html</id>
    <published>2021-05-12T07:33:45.000Z</published>
    <updated>2021-05-12T07:33:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>Java内置有数百个类。 <a id="more"></a></p></blockquote><h3 id="解决上一章程序的bug">1. 解决上一章程序的bug</h3><p>上一章的简单版游戏中，一旦猜中了一格，可以持续攻击同一格结束游戏。需要一种机制判别之前是否已经猜中过。</p><h4 id="方案一">方案一</h4><p>使用第二个数组，一旦玩家猜中某格，就把对应的格设置为true，之后每次猜中都检查是否已经猜中过。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionOneForDotComBug.PNG" alt="方案一" /><figcaption aria-hidden="true">方案一</figcaption></figure><p>但这种方法过于耗时，每次猜中某一格，都必须检查或改变第二个数组的状态，且需要额外的空间。</p><h4 id="方案二">方案二</h4><p>只动用原来数组，将任何被命中的格子改为<code>-1</code>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionTwoForDotComBug.PNG" alt="方案二" /><figcaption aria-hidden="true">方案二</figcaption></figure><p>但依旧不是很有效率，已经命中过的格子还是需要再次被搜索。</p><h4 id="方案三">方案三</h4><p>在命中某个格子后，就把它删掉，格子会越来越少。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionThreeForDotComBug.PNG" alt="方案三" /><figcaption aria-hidden="true">方案三</figcaption></figure><p>但数组大小无法改变，必须创建新数组并进行拷贝。如果有<em>可变数组</em>就可以解决这个问题。</p><h3 id="arraylist类">2. <code>ArrayList</code>类</h3><p><code>ArrayList</code>类是Java库函数中的一个类，是一个"边长的数组"。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/someMethodsArrayList.PNG" alt="ArrayList类部分方法" /><figcaption aria-hidden="true"><code>ArrayList</code>类部分方法</figcaption></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/someMethodsArrayList2.PNG" alt="ArrayList的操作" /><figcaption aria-hidden="true"><code>ArrayList</code>的操作</figcaption></figure><p><code>ArrayList</code>与一般数组的区别：</p><blockquote><ul><li>一般数组在创建时必须确定大小，但<code>ArrayList</code>只需要创建出该类型对象就可以。</li><li>存放对象时，一般数组需要指定位置；<code>ArrayList</code>可以使用方法<code>add()</code>。</li><li>一般数组使用<code>[]</code>来存取对象；<code>ArrayList</code>使用<code>get</code>方法。</li><li>在<code>Java 5.0</code>中<code>ArrayList</code>是<strong>参数化的(parameterized)</strong>，即<code>ArrayList&lt;Type&gt;</code>。<code>&lt;Type&gt;</code>是类型参数，代表<code>Type</code>类型的集合。</li></ul></blockquote><h3 id="完整版sink-a-dot-com">3. 完整版"Sink a Dot Com"</h3><p>需要对原来的三个类进行修改：</p><blockquote><ul><li><code>DotCom</code>类。原来的<code>SimpleDotCom</code>类。<ul><li>需要增加名称变量来保存<code>DotCom</code>的名字。</li></ul></li><li><code>DotComBust</code>类。原来的<code>SimpleDotComGame</code>类。<ul><li>需要创建多个<code>DotCom</code>对象。</li><li>将<code>DotCom</code>对象放到方阵上。</li><li>每次猜测要检查多个<code>DotCom</code>，所有都击沉后才能结束游戏。</li><li>脱离<code>main()</code>函数。</li></ul></li><li><code>GameHelper</code>类。</li></ul></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/fullDotComGame.PNG" alt="完整版&quot;Sink a Dot Com&quot;类间关系" /><figcaption aria-hidden="true">完整版"Sink a Dot Com"类间关系</figcaption></figure><h4 id="dotcombust类">3.1 <code>DotComBust</code>类</h4><h5 id="伪码">伪码</h5><p><code>DotComBust</code>类有3个任务：启动游戏，运行游戏以及结束游戏。可以对运行游戏任务分解，较小的方法更容易测试修改。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dotComBustPrepCode.PNG" alt="DotComBust伪码" /><figcaption aria-hidden="true">DotComBust伪码</figcaption></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dotComBustPrepCodeContinued.PNG" alt="DotComBust伪码（续）" /><figcaption aria-hidden="true">DotComBust伪码（续）</figcaption></figure><h5 id="真实码">真实码</h5><p><code>DotComBust</code>类Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotComBust</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GameHelper helper = <span class="keyword">new</span> GameHelper();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;DotCom&gt; dotComList = <span class="keyword">new</span> ArrayList&lt;DotCom&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfGuesses = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建dotCom实例，并加入到dotComList中</span></span><br><span class="line">        DotCom one = <span class="keyword">new</span> DotCom();</span><br><span class="line">        one.setName(<span class="string">"Pets.com"</span>);</span><br><span class="line">        dotComList.add(one);</span><br><span class="line"></span><br><span class="line">        DotCom two = <span class="keyword">new</span> DotCom();</span><br><span class="line">        two.setName(<span class="string">"eToys.com"</span>);</span><br><span class="line">        dotComList.add(two);</span><br><span class="line"></span><br><span class="line">        DotCom three = <span class="keyword">new</span> DotCom();</span><br><span class="line">        three.setName(<span class="string">"Go2.com"</span>);</span><br><span class="line">        dotComList.add(three);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出提示信息</span></span><br><span class="line">        System.out.println(<span class="string">"Your goal is to sink three dot coms."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Pets.com, eToys.com, Go2.com"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Try to sink them all in the fewest number of guesses"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化每个dotCom在棋盘中的位置</span></span><br><span class="line">        <span class="keyword">for</span> (DotCom dotComToSet: dotComList) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; newLocation = helper.placeDotCom(<span class="number">3</span>);</span><br><span class="line">            dotComToSet.setLocationCells(newLocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startPlaying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!dotComList.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取用户的猜测值</span></span><br><span class="line">            String userGuess = helper.getUserInput(<span class="string">"Enter a guess"</span>);</span><br><span class="line">            <span class="comment">// 检查玩家猜测值</span></span><br><span class="line">            checkUserGuess(userGuess);</span><br><span class="line">        &#125;</span><br><span class="line">        finishGame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkUserGuess</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        numOfGuesses++;</span><br><span class="line">        String result = <span class="string">"miss"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (DotCom dotComToSet: dotComList) &#123;</span><br><span class="line">            result = dotComToSet.checkYourself(userGuess);</span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"hit"</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"kill"</span>)) &#123;</span><br><span class="line">                dotComList.remove(dotComToSet);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"All Dot Coms are dead! Your stock is now worthless."</span>);</span><br><span class="line">        <span class="keyword">if</span> (numOfGuesses &lt;= <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"It only took you "</span> + numOfGuesses + <span class="string">" guesses."</span>);</span><br><span class="line">            System.out.println(<span class="string">" You got out before your options sank."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Took you long enough. "</span> + numOfGuesses + <span class="string">" guesses."</span>);</span><br><span class="line">            System.out.println(<span class="string">"Fish are dancing with your options."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotComBust game = <span class="keyword">new</span> DotComBust();</span><br><span class="line">        game.setUpGame();</span><br><span class="line">        game.startPlaying();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dotcom类">3.2 <code>DotCom</code>类</h4><p><code>DotCom</code>类Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotCom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; locationCells;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocationCells</span> <span class="params">(ArrayList&lt;String&gt; locations)</span> </span>&#123;</span><br><span class="line">        locationCells = locations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkYourself</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">"miss"</span>; <span class="comment">// 创建保存返回结果的变量, 以miss作为默认值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (locationCells.contains(userGuess)) &#123;</span><br><span class="line">            locationCells.remove(userGuess);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(locationCells.isEmpty()) &#123;</span><br><span class="line">                result = <span class="string">"kill"</span>;</span><br><span class="line">                System.out.println(<span class="string">"Ouch! You sunk "</span> + name + <span class="string">" :("</span>); <span class="comment">// 显式结果</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="string">"hit"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(result); // 显式结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gamehelper类">3.3 <code>GameHelper</code>类</h4><p><code>GameHelper</code>类除了获取玩家输入外，还增加了设置<code>DotCom</code>的位置这一功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String alphabet = <span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gridLength = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gridSize = <span class="number">49</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] grid = <span class="keyword">new</span> <span class="keyword">int</span>[gridSize];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> comCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInput</span><span class="params">(String prompt)</span> </span>&#123;</span><br><span class="line">        String inputLine = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(prompt + <span class="string">"  "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">            );</span><br><span class="line">            inputLine = is.readLine();</span><br><span class="line">            <span class="keyword">if</span> (inputLine.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inputLine.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">placeDotCom</span><span class="params">(<span class="keyword">int</span> comSize)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; alphaCells = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        String temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 现有字符串</span></span><br><span class="line">        <span class="keyword">int</span> [] coords = <span class="keyword">new</span> <span class="keyword">int</span> [comSize];</span><br><span class="line">        <span class="comment">// 目前测试的字符串</span></span><br><span class="line">        <span class="keyword">int</span> attempts = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到适合的位置吗？</span></span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 目前起点</span></span><br><span class="line">        <span class="keyword">int</span> location = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在处理到第n个dot com</span></span><br><span class="line">        comCount++;</span><br><span class="line">        <span class="comment">// incr是增量, 水平方向增量(+1), 垂直增量(+7, gridLength)</span></span><br><span class="line">        <span class="keyword">int</span> incr = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果是单数号dot com, 垂直增量</span></span><br><span class="line">        <span class="keyword">if</span> ((comCount % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            incr = gridLength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主要搜索循环</span></span><br><span class="line">        <span class="keyword">while</span> (!success &amp; attempts++ &lt; <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 随机起点</span></span><br><span class="line">            location = (<span class="keyword">int</span>) (Math.random() * gridSize);</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 假设是适合的位置</span></span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查找未使用的点</span></span><br><span class="line">            <span class="keyword">while</span> (success &amp;&amp; x &lt; comSize) &#123;</span><br><span class="line">                <span class="comment">// 若未使用</span></span><br><span class="line">                <span class="keyword">if</span> (grid[location] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 存储位置，尝试下一个点</span></span><br><span class="line">                    coords[x++] = location;</span><br><span class="line">                    location += incr;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 超出边缘, 失败, 不是适合的</span></span><br><span class="line">                    <span class="keyword">if</span> (location &gt;= gridSize) &#123;</span><br><span class="line">                        success = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 水平方向超出边缘, 失败</span></span><br><span class="line">                    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; (location % gridLength) == <span class="number">0</span>) &#123;</span><br><span class="line">                        success = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 该位置已经使用过</span></span><br><span class="line">                    success = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将位置转换为字符串</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(x &lt; comSize) &#123;</span><br><span class="line">            <span class="comment">// 标示格子已用</span></span><br><span class="line">            grid[coords[x]] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 行值</span></span><br><span class="line">            row = (<span class="keyword">int</span>) (coords[x] / gridLength);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 列值</span></span><br><span class="line">            column = coords[x] % gridLength;</span><br><span class="line">            temp = String.valueOf(alphabet.charAt(column));</span><br><span class="line"></span><br><span class="line">            alphaCells.add(temp.concat(Integer.toString(row)));</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  alphaCells;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布尔表达式">4. 布尔表达式</h3><ol type="1"><li><p>“与”和“或”运算符(<code>&amp;&amp;</code>, <code>||</code>)</p></li><li><p>“不等于”运算符(<code>!=</code>和<code>!</code>)</p></li><li><p>短运算符(<code>&amp;&amp;</code>, <code>||</code>)</p><blockquote><p>比如<code>&amp;&amp;</code>表达式中，左右两边都为<code>true</code>这个表达式才为<code>true</code>。因此<code>Java</code>虚拟机发现左方表达式为<code>false</code>时不需要也不会计算右边表达式。<code>||</code>类似。基于这样的性质可以避免调用内容为<code>null</code>的引用变量：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (refVar != <span class="keyword">null</span> &amp;&amp; refVar.isValidType() ) &#123;</span><br><span class="line"> <span class="comment">// do ‘got a valid type’ stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>长运算符(<code>&amp;</code>, <code>|</code>)</p><p><code>&amp;</code>和 <code>|</code>运算符通常用于位运算，Java虚拟机会计算运算符两边的算式。</p></li></ol><h3 id="使用库函数java-api">5. 使用库函数(<code>Java API</code>)</h3><h4 id="库函数的使用">5.1 库函数的使用</h4><p>在<code>Java API</code>中，类是包装在<code>包</code>中的。要使用<code>API</code>中的类，必须直到它在哪个包中。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/apiPakage.PNG" alt="在Java API中，类被包装在包中" /><figcaption aria-hidden="true">在<code>Java API</code>中，类被包装在<code>包</code>中</figcaption></figure><p>必须指明程序代码中所使用到的类的完整名称。(<strong>除了<code>java.lang</code>之外</strong>)</p><blockquote><p>比如<code>ArrayList</code>的完整名称应该是：<code>java.util.ArrayList</code></p></blockquote><p>主要有两种方法可以指定使用的是哪一个<code>ArrayList</code>：</p><ol type="1"><li><p><code>Import</code></p><p>在程序源文件最前面放上<code>import</code>述句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;... &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Type</code></p><p>直接在程序代码中打出全名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line">java.util.ArrayList&lt;Dog&gt; list = <span class="keyword">new</span> java.util.ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用参数</span></span><br><span class="line">java.util.ArrayList&lt;Dog&gt; list = <span class="keyword">new</span> java.util.ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型</span></span><br><span class="line"><span class="keyword">public</span> java.util.<span class="function">ArrayList&lt;Dog&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><code>java.lang</code>是个预先被引用的包，因为<code>java.lang</code>是经常会被用到的基础包，所有可以不必指定名称。比如<code>java.lang.String</code>与<code>java.lang.System</code>都不需要<code>import</code>或写全名。</p></blockquote><h4 id="关于javax开头的包中x的含义">5.2 关于<code>javax</code>开头的包中<code>x</code>的含义</h4><p><code>javax</code>作为开头的包是指标准版的扩展函数库。后来纳入到标准库中后，为了保持程序的兼容性，故而沿用了<code>javax</code>这一命名。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/javaxHistory.PNG" alt="javax中x的由来" /><figcaption aria-hidden="true"><code>javax</code>中<code>x</code>的由来</figcaption></figure><h4 id="如何查阅api">5.3 如何查阅<code>API</code></h4><p>使用函数库必须知道：</p><ol type="1"><li>库中有哪些类</li><li>这些类是做什么的</li></ol><p>主要方法是：</p><ol type="1"><li>查阅参考书</li><li>查阅HTML API文档</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Java内置有数百个类。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head First Java]--5 超强力方法</title>
    <link href="https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_5_Extra-Strength_Methods.html"/>
    <id>https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_5_Extra-Strength_Methods.html</id>
    <published>2021-05-12T04:57:22.000Z</published>
    <updated>2021-05-12T04:57:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>让方法产生更大的作用。创建一个类似战舰的游戏：攻击达康 <a id="more"></a></p></blockquote><h3 id="创建一个类似战舰的游戏攻击达康">1. 创建一个类似战舰的游戏：攻击达康</h3><h4 id="简介">1.1. 简介</h4><p>一种棋盘类的战舰游戏，目标是猜测对方战舰的坐标，然后轮流开炮攻击，命中数发可以击沉对方战舰。</p><ul><li><strong>游戏目标</strong>：以最少的猜测次数打掉计算机安排的<code>达康公司(Dot Com)</code>网站。计算机根据表现来评分。</li><li><strong>初始设置</strong>：程序启动后，计算机会在虚拟的<code>7×7</code>方格上安排3个达康网站。然后开始要求猜坐标。</li><li><strong>进行游戏</strong>：目前先在命令栏上进行游戏。计算机根据输入所猜测的位置(比如<code>A3</code>或<code>C5</code>)等，返回命中<code>Hit</code>，未命中<code>Miss</code>或击沉<code>Sunk</code>等回应。清关所有网站后，会列出分数并结束。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/sunk_site.PNG" alt="攻击达康棋盘" /><figcaption aria-hidden="true">攻击达康棋盘</figcaption></figure><h4 id="顶层设计">1.2 顶层设计</h4><p>首先，了解游戏流程。基本思路：</p><ol type="1"><li>玩家启动游戏</li></ol><blockquote><p>A. 计算机创建3个网站 B. 将3个网站停在虚拟战场(棋盘)上</p></blockquote><ol start="2" type="1"><li>游戏开始</li></ol><blockquote><p>重复以下操作直到所有网站被歼灭 A. 提示玩家输入坐标 B. 检查是否命中、未命中或击沉。命中删除格子，击沉删除网站。</p></blockquote><ol start="3" type="1"><li>游戏结束</li></ol><blockquote><p>根据猜测次数给分。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/flow_of_sunk_dotcom.PNG" alt="游戏流程图" /><figcaption aria-hidden="true">游戏流程图</figcaption></figure><h4 id="简单的开始">1.3 简单的开始</h4><p>至少需要两个类：<code>Game</code>类和<code>DotCom</code>类。首先从一个简单版本开始。</p><blockquote><p>只使用一个横列作为棋盘(即一维数组)，并只设定一家达康公司。游戏目标依旧相同。</p></blockquote><p>要注意虚拟的横列是虚幻的，即并没有真正在程序中声明一个一维数组。只需要玩家和计算机直到有3个连续格子会出现在7格的横列中。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simple_sunk_site.PNG" alt="简单版游戏" /><figcaption aria-hidden="true">简单版游戏</figcaption></figure><h3 id="开发类">2 开发类</h3><p>在创建Java程序时，主要依照以下过程：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/process_of_create_javaapp.PNG" alt="Java程序开发基本流程" /><figcaption aria-hidden="true">Java程序开发基本流程</figcaption></figure><blockquote><p>最后一条是认真的吗</p></blockquote><p>我们会为每个类写出：<code>伪码(prep code)</code>、<code>测试码(test code)</code>和<code>真实码(real code)</code></p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/prepTestReal.PNG" alt="伪码、测试码和真实码" /><figcaption aria-hidden="true"><code>伪码</code>、<code>测试码</code>和<code>真实码</code></figcaption></figure><blockquote><p><strong>伪码</strong>：帮助我们专注于逻辑而无需考虑程序语法</p><p><strong>测试码</strong>：测试用的程序代码</p><p><strong>真实码</strong>：实际设计出的真正Java程序代码</p></blockquote><h4 id="simpledotcom类">2.1 <code>SimpleDotCom</code>类</h4><h5 id="伪码">伪码</h5><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComPrep.PNG" alt="SimpleDotCom类伪码" /><figcaption aria-hidden="true"><code>SimpleDotCom</code>类伪码</figcaption></figure><p>伪码介于Java程序和正常英语之间，大致包括3个部分：实例变量的声明、方法的声明和方法的逻辑。</p><blockquote><p>伪码最重要的部分是<strong>方法的逻辑</strong>。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComPrepCode.PNG" alt="SimpleDotCom类伪码" /><figcaption aria-hidden="true"><code>SimpleDotCom</code>类伪码</figcaption></figure><h5 id="测试码">测试码</h5><p>编写方法的实现部分，实现可用的方法程序代码。先编写测试用代码的概念来自于<code>极限编程(Extreme Programming, XP)</code>方法论，可以使我们更快更任意写出程序代码。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/Extreme_Programming.PNG" alt="极限编程" /><figcaption aria-hidden="true">极限编程</figcaption></figure><p>首先实现<code>SimpleDotCom</code>类中的方法，先实现<code>checkYourself()</code>这个方法。（至于<code>setLocationCells()</code>这个方法，可以很容易直到它是个<code>setter</code>方法）。首先要知道<code>checkYourself()</code>方法应该要测试的部分：</p><blockquote><ol type="1"><li><code>SimpleDotCom</code>对象的初始化；</li><li>赋值位置(即一个<code>int</code>数组)；</li><li>创建代表玩家猜测的字符串；</li><li>传入伪造的玩家猜测来调用<code>checkYourself()</code>方法；</li><li>列出结果观察结果是否正确。</li></ol></blockquote><p><code>SimpleDotCom</code>测试码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotComDrive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleDotCom dot = <span class="keyword">new</span> SimpleDotCom(); <span class="comment">// 初始化SimpleDotCom对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] locations = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// 创建 dot com 位置数组</span></span><br><span class="line">        dot.setLocationCells(locations); <span class="comment">// 调用 dot com 的 setter</span></span><br><span class="line"></span><br><span class="line">        String userGuess = <span class="string">"2"</span>; <span class="comment">// 假的猜测</span></span><br><span class="line">        String result = dot.checkYourself(userGuess); <span class="comment">// 调用被测试的方法, 传入假数据</span></span><br><span class="line">        String testResult = <span class="string">"failed"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.equals(<span class="string">"hit"</span>)) &#123;</span><br><span class="line">            testResult = <span class="string">"passed"</span>; <span class="comment">// 测试返回 "hit" 才算成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.println(testResult); <span class="comment">// 输出测试结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思索与编写测试用的程序代码能够帮助我们了解被测试的应用程序应该要做哪些事情。当实作代码完成时，也可以有准备好地测试代码进行验证。</p><p>理想上，先写出一点测试码，然后编写能够通过该测试的方法。之后再编写测试码，编写新的实现使其通过测试。如此循环，就可以证明新加入代码不会破坏原有已经测试过的部分。</p></blockquote><h5 id="真实码">真实码</h5><p>从伪码到真正的Java程序代码之间，不会完美对应，需要有一些调整。下面使<code>checkYourself()</code>方法的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotCom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] locationCells;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfHIts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLocationCells</span> <span class="params">(<span class="keyword">int</span>[] locations)</span> </span>&#123;</span><br><span class="line">        locationCells = locations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkYourself</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> guess = Integer.parseInt(userGuess); <span class="comment">// 字符串转int</span></span><br><span class="line">        String result = <span class="string">"miss"</span>; <span class="comment">// 创建保存返回结果的变量, 以miss作为默认值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cell: locationCells) &#123; <span class="comment">// 对每个格子重复执行</span></span><br><span class="line">            <span class="keyword">if</span> (guess == cell) &#123; <span class="comment">// 比较格子与猜测值</span></span><br><span class="line">                result = <span class="string">"hit"</span>; <span class="comment">// 命中</span></span><br><span class="line">                numOfHIts++;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 离开循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numOfHIts == locationCells.length) &#123; <span class="comment">// 判断是否击沉</span></span><br><span class="line">            result = <span class="string">"kill"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result); <span class="comment">// 显式结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="simpledotcomgame类">2.2 <code>SimpleDotComGame</code>类</h4><h5 id="伪码-1">伪码</h5><p><code>SimpleDotComGame</code>类伪码如下：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComGamePrepCode.PNG" alt="SimpleDotComGame类伪码" /><figcaption aria-hidden="true"><code>SimpleDotComGame</code>类伪码</figcaption></figure><p><code>SimpleDotComGame</code>类需要有以下功能：</p><blockquote><ol type="1"><li>创建出<code>SimpleDotCom</code>对象</li><li>初始化赋值该对象</li><li>要求玩家开始猜测</li><li>检查猜测值</li><li>重复猜测直到击沉为止</li><li>显示玩家猜测次数</li></ol></blockquote><h5 id="真实码-1">真实码</h5><p>这里跳过了这个类的测试程序，因为次游戏测试程序只有一个<code>main</code>方法。其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotComGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfGuesses = <span class="number">0</span>; <span class="comment">// 记录玩家猜测次数</span></span><br><span class="line">        GameHelper helper = <span class="keyword">new</span> GameHelper(); <span class="comment">// 使用该类来获取玩家输入</span></span><br><span class="line"></span><br><span class="line">        SimpleDotCom theDotCom = <span class="keyword">new</span> SimpleDotCom();</span><br><span class="line">        <span class="keyword">int</span> randomNum = (<span class="keyword">int</span>) (Math.random() * <span class="number">5</span>); <span class="comment">// 随机数用作第一格的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] locations = &#123;randomNum, randomNum+<span class="number">1</span>, randomNum+<span class="number">2</span>&#125;;</span><br><span class="line">        theDotCom.setLocationCells(locations);</span><br><span class="line">        <span class="keyword">boolean</span> isAlive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(isAlive) &#123;</span><br><span class="line">            String guess = helper.getUserInput(<span class="string">"enter a guess number"</span>);</span><br><span class="line">            String result = theDotCom.checkYourself(guess);</span><br><span class="line">            numOfGuesses++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"kill"</span>)) &#123;</span><br><span class="line">                isAlive = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(<span class="string">"You took "</span> + numOfGuesses + <span class="string">" guesses!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一个带有<code>getUserInput</code>方法的类<code>GameHelper</code>。它可以从命令行获取输入，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInput</span><span class="params">(String prompt)</span> </span>&#123;</span><br><span class="line">        String inputLine = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(prompt + <span class="string">"  "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">            );</span><br><span class="line">            inputLine = is.readLine();</span><br><span class="line">            <span class="keyword">if</span> (inputLine.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inputLine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="要点">2.3 要点</h4><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/keyPointOfChapter5.PNG" alt="要点" /><figcaption aria-hidden="true">要点</figcaption></figure><h3 id="关于for循环">3. 关于<code>for</code>循环</h3><h4 id="基本的for循环">3.1 基本的<code>for</code>循环</h4><p>一个基本的<code>for</code>循环如下：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/regularForLoops.PNG" alt="基本的for循环" /><figcaption aria-hidden="true">基本的<code>for</code>循环</figcaption></figure><p>即重复执行代码100次，编译器解释为:</p><blockquote><ol type="1"><li>创建变量<code>i</code>并赋值为<code>0</code>；</li><li>只要<code>i</code>小于<code>100</code>就重复执行；</li><li>每次重复过程最后把<code>i</code>加<code>1</code>。</li></ol></blockquote><p>主要分为三个部分：</p><h5 id="第一部分初始化initialization">第一部分：初始化(initialization)</h5><p>声明和初始化在循环体内的变量，通常将该变量作为<code>计数器</code>。</p><h5 id="第二部分boolean测试boolean-test">第二部分：boolean测试(boolean test)</h5><p>测试条件计算出一个<code>boolean</code>值。可以使boolean表达式，或返回boolean值的方法。</p><h5 id="第三部分重复表达式-iteration-expression">第三部分：重复表达式( iteration expression)</h5><p>安置每趟循环完成后要执行的项目。</p><blockquote><p><code>whlie</code>循环与<code>for</code>循环的区别是，<code>while</code>循环只有<code>boolean</code>测试，它并没有内建的初始化或重复表达式。</p><ul><li><code>while</code>适合在不清楚循环次数的循环上；</li><li><code>for</code>相对来说更容易阅读。</li></ul></blockquote><p>此外，这里可以说明一下前置与后置的递增/递减操作符：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/IncrementDecrementOperator.PNG" alt="基本的for循环" /><figcaption aria-hidden="true">基本的<code>for</code>循环</figcaption></figure><h4 id="加强版的for循环">3.2 加强版的<code>for</code>循环</h4><p>从<code>Java 5.0</code>开始，有加强版的<code>for</code>循环，可以逐个运行数组或其他集合的元素。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/enhancedforloop.PNG" alt="加强版的for循环" /><figcaption aria-hidden="true">加强版的<code>for</code>循环</figcaption></figure><p>即对<code>nameArray</code>中每个元素执行一次，编译器解释为:</p><blockquote><ol type="1"><li>创建名称为<code>name</code>的<code>String</code>变量；</li><li>将<code>nameArray</code>的第一个元素赋值给<code>name</code>；</li><li>执行重复内容；</li><li>赋值给下一个元素<code>name</code>；</li><li>重复执行直到所有元素都被运行为止。</li></ol></blockquote><p>主要分为两个部分：</p><h5 id="第一部分声明循环变量iteration-variable-declaration">第一部分：声明循环变量(iteration variable declaration)</h5><p>声明和初始化用在循环体内的变量，循环过程中该变量的值会不断变化。此变量的类型需要与数组元素类型匹配。</p><h5 id="第二部分要运行的集合the-actual-collection">第二部分：要运行的集合(the actual collection)</h5><p>必须是对数组或其他集合的引用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;让方法产生更大的作用。创建一个类似战舰的游戏：攻击达康
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head First Java]--4 对象的行为</title>
    <link href="https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_4_behavior_of_objects.html"/>
    <id>https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_4_behavior_of_objects.html</id>
    <published>2021-05-12T02:08:12.000Z</published>
    <updated>2021-05-12T02:08:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>状态影响行为，行为影响变量。 <a id="more"></a></p></blockquote><h3 id="对象参数">1. 对象参数</h3><h4 id="对象的状态与行为">1.1. 对象的状态与行为</h4><p>类是对象的蓝图。在编写类时，是在描述Java虚拟机应该如何制作该类型的对象。</p><blockquote><p>类所描述的是对象<code>知道什么与执行什么</code></p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/instance_and_method.PNG" alt="实例变量与方法" /><figcaption aria-hidden="true">实例变量与方法</figcaption></figure><p>同一个类型的对象能有不同的方法行为。每个实例有相同的方法，但方法可以根据实例变量的值变现不同行为。</p><h4 id="方法的参数">1.2. 方法的参数</h4><p>可以传值给方法。可以使用<code>实参(argument)</code>或<code>形参(parameter)</code>来调用传给方法的参数</p><blockquote><p>方法会运用形参，调用一方会传入实参</p><ul><li>实参是传给方法的值；</li><li>实参传入方法后就成为了形参；</li><li>参数跟局部变量一样。它也有类型和名称，可以在方法内运用</li></ul></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/argument_and_parameter.PNG" alt="实参与形参" /><figcaption aria-hidden="true">实参与形参</figcaption></figure><h4 id="返回值">1.3. 返回值</h4><p>方法可以有返回值，每个方法都需要声明返回的类型。</p><blockquote><p><code>void</code>表示没有返回任何东西。</p></blockquote><p>比如可以声明一个返回<code>int</code>类型值的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">giveSecret</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果声明了方法有返回值，必须返回声明类型的值！</p><h4 id="多个参数">1.4. 多个参数</h4><p>方法可以有多个参数，声明和传入时都要以逗号分开。</p><blockquote><p>一定要以正确数量，类型和顺序来传递参数</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/multipe_argument.PNG" alt="多个参数" /><figcaption aria-hidden="true">多个参数</figcaption></figure><h4 id="参数传递">1.5. 参数传递</h4><p>Java通过值传递，或者通过拷贝传递参数。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/argument_pass.PNG" alt="参数传递" /><figcaption aria-hidden="true">参数传递</figcaption></figure><blockquote><p><strong>方法无法改变调用方所传入的参数。</strong></p></blockquote><h4 id="要点">1.6. 要点</h4><blockquote><ul><li>如果传入的参数是对象，那么<strong>实际上传入的是远程控制的拷贝</strong>。</li><li>方法只能声明单一返回值。如果需要返回多个返回值，可以使用数组。如需要返回混合不同类型值，可以使用<code>ArrayList</code></li></ul></blockquote><h3 id="封装encapsulation">2. 封装(Encapsulation)</h3><p>不封装可能会导致数据泄露。比如直接通过圆点运算符(<code>.</code>)来存取实例变量，可能会出现异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theCat.height = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>需要创建<code>Setter</code>方法，使得在设置变量前可以进行检查。将程序实现从不良数据改成可以保护数据，且还能保持数据可修改，可以使用两个<code>存取修饰符(access modifier)</code>：公有修饰符<code>public</code>和私有修饰符<code>private</code>。封装的基本原则是：</p><blockquote><p>将实例变量标记为私有，提供公有的<code>getter</code>与<code>setter</code>方法来控制存取动作。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/advantage_of_setter.PNG" alt="封装的好处" /><figcaption aria-hidden="true">封装的好处</figcaption></figure><h3 id="初始化实例变量">3. 初始化实例变量</h3><p>声明变量是需要名称和类型，也可以同时初始化变量(为变量赋值)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">256</span>;</span><br></pre></td></tr></table></figure><p>如果未明确初始化实例变量，会为实例变量设置默认值。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/init_variable.PNG" alt="实例变量默认值" /><figcaption aria-hidden="true">实例变量默认值</figcaption></figure><blockquote><p>这么看，<code>String</code>变量内存储的也是一个对象引用。</p></blockquote><h3 id="实例变量与局部变量">4. 实例变量与局部变量</h3><p>实例变量与局部变量的区别：</p><blockquote><ul><li>实例变量声明在类内而不是方法中；而局部变量声明在方法中</li><li>局部变量使用前必须初始化，即<strong>局部变量没有默认值！</strong>如果在初始化前被调用，编译器会报错。</li></ul></blockquote><p>方法参数基本上与局部变量是相同的。</p><h3 id="变量的比较">5. 变量的比较</h3><h4 id="section">5.1 <code>==</code></h4><blockquote><p><code>==</code>用于比较两个变量的字节组合是否相等。</p></blockquote><p>可以使用<code>==</code>来比较两个<code>primitive</code>主数据类型是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123; <span class="comment">// true &#125;</span></span><br></pre></td></tr></table></figure><p>也可以用<code>==</code>来判断两个引用是否指向同一对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Foo a = <span class="keyword">new</span> Foo();</span><br><span class="line">Foo b = <span class="keyword">new</span> Foo();</span><br><span class="line">Foo c = a;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123; <span class="comment">// false &#125;</span></span><br><span class="line"><span class="keyword">if</span> (a == c) &#123; <span class="comment">// true &#125;</span></span><br><span class="line"><span class="keyword">if</span> (b == c) &#123; <span class="comment">// false &#125;</span></span><br></pre></td></tr></table></figure><h4 id="equals">5.2 <code>equals()</code></h4><p>使用<code>equals()</code>方法来判断两个对象是否在含义上相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1,s2,s3 = <span class="string">"abc"</span>, s4 =<span class="string">"abc"</span> ;</span><br><span class="line">s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">s1==s2   是 <span class="keyword">false</span>      <span class="comment">//两个变量的内存地址不一样，也就是说它们指向的对象不一样，</span></span><br><span class="line"></span><br><span class="line">s1.equals(s2) 是 <span class="keyword">true</span>    <span class="comment">//两个变量的所包含的内容是abc，故相等。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;状态影响行为，行为影响变量。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head First Java]--3 认识变量</title>
    <link href="https://wuyunjie.top/2021/05/11/JavaLearning_Head_First_Java_3_recognize_variables.html"/>
    <id>https://wuyunjie.top/2021/05/11/JavaLearning_Head_First_Java_3_recognize_variables.html</id>
    <published>2021-05-11T13:35:06.000Z</published>
    <updated>2021-05-11T13:35:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>变量有两种：<code>primitive</code>主数据类型和引用。 <a id="more"></a></p></blockquote><h3 id="声明变量">1. 声明变量</h3><p><code>Java</code>中必须声明所有变量的类型。主要分为两种变量</p><blockquote><ul><li><code>primitive</code>主数据类型保存基本类型的值，包括<strong>整数、布尔和浮点数等</strong>；</li><li><code>对象引用</code>保存对象的引用</li></ul></blockquote><p>变量必须有<strong>类型</strong>和<strong>名称</strong>。（<strong><code>variables must have a type and a name</code></strong>）</p><h4 id="primitive主数据类型"><code>primitive</code>主数据类型</h4><p><code>primitive</code>主数据类型有不同大小和名称：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/variable_type_size.PNG" alt="primitive主数据类型有不同大小" /><figcaption aria-hidden="true"><code>primitive</code>主数据类型有不同大小</figcaption></figure><p>这里展示了<code>primitive</code>主数据类型的名称以及对应的位数：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/primitive_variable_type_size.PNG" alt="primitive主数据类型名称以及对应的位数" /><figcaption aria-hidden="true"><code>primitive</code>主数据类型名称以及对应的位数</figcaption></figure><blockquote><p>这里注意在声明浮点数时，除非加上<code>f</code>，否则所有带小数点的值都会被<code>Java</code>当作<code>double</code>处理。(比如<code>float f = 32.5f</code>)</p></blockquote><p><code>Java</code>编译器不允许将较大的类型值赋给较小类型，比如<code>int</code>类型值无法赋予<code>byte</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">byte</span> b = x;</span><br></pre></td></tr></table></figure><p>即使<code>byte</code>可以装下<code>24</code>，这条语句也不能通过编译。</p><h4 id="对象引用">对象引用</h4><p>没有对象变量存在，只有<code>引用（reference）</code>到对象的变量。</p><blockquote><p>对象引用变量保存的是<strong>存取对象的方法</strong>；</p></blockquote><p>它不是对象的容器，而是类似于指向对象的指针或者说地址。</p><blockquote><p>但只有<code>Java</code>虚拟机知道如何使用引用来获取对象，我们并不知道引用变量中实际装载的是什么。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/variable_object_reference.PNG" alt="对象引用" /><figcaption aria-hidden="true">对象引用</figcaption></figure><p>对象的声明、创建与赋值有三个步骤：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/create_object.PNG" alt="对象的声明、创建与赋值" /><figcaption aria-hidden="true">对象的声明、创建与赋值</figcaption></figure><blockquote><p><strong>数组也是对象</strong></p></blockquote><p>无论声明来承载<code>primitive</code>主数据类型还是对象引用，数组永远是对象。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/array_is_object.PNG" alt="数组也是对象" /><figcaption aria-hidden="true">数组也是对象</figcaption></figure><h3 id="变量命名规范">2. 变量命名规范</h3><p>可以根据一下规则来为类、方法或变量命名：</p><blockquote><ul><li>名称必须以字母、下划线(<code>_</code>)或<code>$</code>符号开头，不能用数字开头；</li><li>除了第一个字符外，后面就可以用数字；</li><li>只要符合上述两条规则，就可以进行任意命名了。但要注意避开Java<code>保留字</code>。</li></ul></blockquote><p>这里的规则是最为基础的规则了，实际上为了命名规范，还有更多更复杂的要求。Java<code>保留字</code>一览表：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/reserved_word.PNG" alt="Java保留字一览表" /><figcaption aria-hidden="true">Java<code>保留字</code>一览表</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;变量有两种：&lt;code&gt;primitive&lt;/code&gt;主数据类型和引用。
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
</feed>
