<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuYJ&#39;s Blog</title>
  
  <subtitle>HELLO WORLD</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wuyujie.top/"/>
  <updated>2019-03-28T10:55:21.015Z</updated>
  <id>http://wuyujie.top/</id>
  
  <author>
    <name>Wuyunjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第一周LeetCode</title>
    <link href="http://wuyujie.top/2019/03/28/%E7%AC%AC%E4%B8%80%E5%91%A8LeetCode/"/>
    <id>http://wuyujie.top/2019/03/28/第一周LeetCode/</id>
    <published>2019-03-28T10:42:20.000Z</published>
    <updated>2019-03-28T10:55:21.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一周LeetCode刷题记录"><a href="#第一周LeetCode刷题记录" class="headerlink" title="第一周LeetCode刷题记录"></a>第一周LeetCode刷题记录</h2><p>1.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%941-Two-Sum/" title="LeetCode——1. Two Sum" target="_blank" rel="external">LeetCode——1. Two Sum</a><br>2.<a href="http://wuyunjie.top/2019/03/28/LeLeetCode%E2%80%94%E2%80%942-Add-Two-Numbers/" title="LeetCode——2. Add Two Numbers" target="_blank" rel="external">LeetCode——2. Add Two Numbers</a><br>3.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%943-Longest-Substring-Without-Repeating-Characters/" title="LeetCode——3. Longest Substring Without Repeating Characters" target="_blank" rel="external">LeetCode——3. Longest Substring Without Repeating Characters</a><br>4.<a href="http://wuyunjie.top/2019/03/28/LeLeetCode%E2%80%94%E2%80%947-Reverse-Integer/" title="LeetCode——7. Reverse Integer" target="_blank" rel="external">LeetCode——7. Reverse Integer</a><br>5.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94709-To-Lower-Case/" title="LeetCode——709. To Lower Case" target="_blank" rel="external">LeetCode——709. To Lower Case</a><br>6.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94771-Jewels-and-Stones/" title="LeetCode——771. Jewels and Stones" target="_blank" rel="external">LeetCode——771. Jewels and Stones</a><br>7.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94929-Unique-Email-Addresses/" title="LeetCode——929. Unique Email Addresses" target="_blank" rel="external">LeetCode——929. Unique Email Addresses</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一周LeetCode刷题记录&quot;&gt;&lt;a href=&quot;#第一周LeetCode刷题记录&quot; class=&quot;headerlink&quot; title=&quot;第一周LeetCode刷题记录&quot;&gt;&lt;/a&gt;第一周LeetCode刷题记录&lt;/h2&gt;&lt;p&gt;1.&lt;a href=&quot;http://
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode——5. Longest Palindromic Substring</title>
    <link href="http://wuyujie.top/2019/03/28/LeetCode%E2%80%94%E2%80%945-Longest-Palindromic-Substring/"/>
    <id>http://wuyujie.top/2019/03/28/LeetCode——5-Longest-Palindromic-Substring/</id>
    <published>2019-03-28T10:40:14.000Z</published>
    <updated>2019-03-31T03:29:45.734Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.<br><a id="more"></a></p></blockquote><p><strong>Example1:</strong></p><blockquote><p>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.</p></blockquote><p><strong>Example2:</strong></p><blockquote><p>Input: “cbbd”<br>Output: “bb”</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>最开始想到的当然还是暴力算法，想法是先用暴力算法把题目做出来理解题目，然后尝试着对实现的算法进行改进，或者再想想有没有其他思路。最开始的想法是</p><blockquote><p>设置两个游标i、j，i从前往后遍历字符串，j从后往前遍历字符串；先将i固定住，然后j从后往前遍历，依次判断从当前j到i的字符串是不是一个回文，其长度是不是最大，若满足条件，就将该字符串的位置信息记录下来，遍历完后最终输出即可。</p></blockquote><p>显然这个方法的效果不会太好，选择尝试对其进行优化。想要的优化思路如下</p><blockquote><p>若当前要判断的子串比已经找到的最长回文子串要短，那么该子串以及比它短的子串都没必要在判断了，可以通过跳过这些不必要的比较过程节省大量时间</p></blockquote><p>修改过后，时间上果然有了很大提升，但结果告诉我显然这种方法还是不好，肯定存在更优化的方法。仔细分析后发现，其实这种方法就相当于将字符串反转后找最大公共子串，它存在一些问题：</p><blockquote><p>这种方法是从两端往内部收缩的算法，如果一个字符串恰好只是最内部的一部分不是子串，那么两端的整个判断过程都是无意义的，而且很费时。我们需要能够更早发现这不是一个回文。若我们把判断过程换一个方向就可以做到，即收缩改为扩展。由内而外的判断子串是不是回文，可以在不是回文的地方及时停止，并且保证之前判断的子串的确是回文，不是无意义的判断。</p></blockquote><p>实现后发现，这种扩展的算法效率比最开始的算法效率要好太多了，因为避免了许多无意义的计算过程。总结起来就是，有时候换一个方向想问题，可以得到更加优化的结果。<br>查看解题的文档后发现还有以下几种比较巧妙的方式：</p><blockquote><p>1.最长公共子串暴力算法<br>反转 S，使之变成 S’。找到 S 和 S’之间最长的公共子串,每当我们找到最长的公共子串的候选项时，都需要检查子串的索引是否与反向子串的原始索引相同。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。我所用到的第一种方法思路根这种方法一致。</p><p>2.动态规划<br>考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，”ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。可以给出P(i,j)的定义如下</p><ul><li>P(i,j) = true,  如果子串Si,…,Sj是回文子串</li><li>P(i,j) = false, 其他情况</li></ul><p>因此P(i,j)更新公式如下：</p><ul><li>P(i,j) = (P(i+1,j−1) and Si == Sj)</li></ul><p>这是一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推</p><p>3.Manacher 算法<br>也叫“马拉松”算法，这个算法可以将时间复杂度提升为<strong>O(n)</strong>。</p><ol><li><p>首先对字符串进行预处理，处理原因是防止偶数问题。比如，有一个偶回文<strong>abba</strong>和一个奇回文<strong>opxpo</strong>，转换为<strong>#a#b#b#a#</strong>和<strong>#o#p#x#p#o#</strong>，长度都转换成了奇数。</p></li><li><p>定义一个辅助数组p[]，其中p[i]表示以 <strong>i</strong> 为中心的最长回文的半径</p></li><li><p>接下来的重点就是求解 p 数组。参考下图<br><img src="https://image-static.segmentfault.com/105/998/1059982876-58b966b759200" alt=""><br>设置两个变量，mx 和 id。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么：<br><code>if (i &lt; mx) p[i]=min(p[2 * id - i], mx - i);</code><br><strong>(2 * id - i)</strong>为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快更新数组。</p></li></ol></blockquote><p>参考文献：<a href="https://subetter.com/algorithm/manacher-algorithm.html" target="_blank" rel="external">https://subetter.com/algorithm/manacher-algorithm.html</a></p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-改进的收缩算法-最长字符串匹配"><a href="#1-改进的收缩算法-最长字符串匹配" class="headerlink" title="1. 改进的收缩算法(最长字符串匹配)"></a>1. 改进的收缩算法(最长字符串匹配)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> begin=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> LongestLength=<span class="number">1</span>;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=s.length()<span class="number">-1</span>;j&gt;i;j--)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> forward=i;</div><div class="line">                <span class="keyword">int</span> backward=j;</div><div class="line">                <span class="keyword">while</span>(s[forward]==s[backward]&amp;&amp;forward&lt;backward)</div><div class="line">                &#123;</div><div class="line">                    forward++;</div><div class="line">                    backward--;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(forward&gt;=backward)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(LongestLength&lt;(j-i+<span class="number">1</span>))</div><div class="line">                    &#123;</div><div class="line">                        begin=i;</div><div class="line">                        LongestLength=(j-i+<span class="number">1</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(LongestLength&gt;=(j-i+<span class="number">1</span>))</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(LongestLength&gt;=(s.length()-i+<span class="number">1</span>))</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">         <span class="keyword">return</span> s.substr(begin, LongestLength); </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="2-扩展算法"><a href="#2-扩展算法" class="headerlink" title="2. 扩展算法"></a>2. 扩展算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(s.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> start_idx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; s.size()) &#123;</div><div class="line">        <span class="keyword">int</span> r_ptr = i; </div><div class="line">        <span class="keyword">int</span> l_ptr = i;</div><div class="line">        <span class="comment">//找到回文中心</span></div><div class="line">        <span class="keyword">while</span>(r_ptr &lt; s.size()<span class="number">-1</span> &amp;&amp; s[r_ptr] == s[r_ptr + <span class="number">1</span>]) r_ptr++;</div><div class="line">        i = r_ptr+<span class="number">1</span>;<span class="comment">//记录下次启示位置，防止重复计算</span></div><div class="line">        <span class="comment">//从中心开始扩展</span></div><div class="line">        <span class="keyword">while</span>(r_ptr &lt; s.size()<span class="number">-1</span> &amp;&amp; l_ptr &gt; <span class="number">0</span> &amp;&amp; s[r_ptr + <span class="number">1</span>] == s[l_ptr - <span class="number">1</span>]) &#123;</div><div class="line">            r_ptr++;</div><div class="line">            l_ptr--;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//更新最长回文子串信息</span></div><div class="line">        <span class="keyword">int</span> new_len = r_ptr - l_ptr + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(new_len &gt; max_len) &#123;</div><div class="line">            start_idx = l_ptr;</div><div class="line">            max_len = new_len;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s.substr(start_idx, max_len);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-动态规划算法"><a href="#3-动态规划算法" class="headerlink" title="3. 动态规划算法"></a>3. 动态规划算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> LongestLength = <span class="number">1</span>;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        <span class="keyword">int</span> len = s.length();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(len,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len,<span class="literal">false</span>));</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</div><div class="line">        &#123;</div><div class="line">            dp[i][i] = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dist = <span class="number">1</span>;dist &lt; len - i;dist++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> j = dist + i;</div><div class="line">                dp[i][j] = (dist == <span class="number">1</span>)? s[i] == s[j] : s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</div><div class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; LongestLength)</div><div class="line">                &#123;</div><div class="line">                    LongestLength = j-i+<span class="number">1</span>;</div><div class="line">                    begin=i;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> s.substr(begin, LongestLength); </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="4-Manacher算法"><a href="#4-Manacher算法" class="headerlink" title="4. Manacher算法"></a>4. Manacher算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="comment">// 字符串预处理，插入 '#'</span></div><div class="line">        <span class="built_in">string</span> t = <span class="string">"$#"</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</div><div class="line">            t += s[i];</div><div class="line">            t += <span class="string">"#"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 处理t</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(t.size(), <span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, resLen = <span class="number">0</span>, resCenter = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.size(); ++i) &#123;</div><div class="line">            p[i] = i &lt; mx ? min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++p[i]; <span class="comment">//// 不需边界判断，因为左有'$',右有'\0'</span></div><div class="line">            </div><div class="line">            <span class="comment">//希望 mx 尽可能的远</span></div><div class="line">            <span class="keyword">if</span> (mx &lt; i + p[i]) &#123;</div><div class="line">                mx = i + p[i];</div><div class="line">                id = i;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</div><div class="line">                resLen = p[i];</div><div class="line">                resCenter = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s.substr((resCenter - resLen) / <span class="number">2</span>, resLen - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Given a string &lt;strong&gt;s&lt;/strong&gt;, find the longest palindromic substring in &lt;strong&gt;s&lt;/strong&gt;. You may assume that the maximum length of &lt;strong&gt;s&lt;/strong&gt; is 1000.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode——7. Reverse Integer</title>
    <link href="http://wuyujie.top/2019/03/28/LeLeetCode%E2%80%94%E2%80%947-Reverse-Integer/"/>
    <id>http://wuyujie.top/2019/03/28/LeLeetCode——7-Reverse-Integer/</id>
    <published>2019-03-28T09:52:20.000Z</published>
    <updated>2019-03-31T04:06:16.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote><p>Given a 32-bit signed integer, reverse digits of an integer..<br><a id="more"></a></p></blockquote><p><strong>Example1:</strong></p><blockquote><p>Input: 123<br>Output: 321</p></blockquote><p><strong>Example1:</strong></p><blockquote><p>Input: -123<br>Output: -321</p></blockquote><p><strong>Example1:</strong></p><blockquote><p>Input: 120<br>Output: 21</p></blockquote><p><strong>Note:</strong></p><blockquote><p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>问题很简单，即将一个int型整数逆序。这里需要注意的是，int的表示范围是[−2^31,  2^31 − 1]，所以若逆序后的数在这个范围之外，即溢出的时候，直接输出0。<br>我的想法是，用一个更大的类型，即<strong>long</strong>来存储转化结果，然后判断结果在不在int的表示范围内，对计算结果进行处理。对比评论区，发现思路大致相同，这貌似就是最优的方法，还以为又会有啥逻辑上的转换。</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">long</span> MAX=<span class="number">2147483647</span>;</div><div class="line">    <span class="keyword">long</span> MIN=<span class="number">-2147483648</span>;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> result=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            result=result*<span class="number">10</span>+x%<span class="number">10</span>;</div><div class="line">            x=x/<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(result&gt;MAX||result&lt;MIN)</div><div class="line">        &#123;</div><div class="line">            result=<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><p>据说出题人想考的是溢出判断，不能用long，只用Int的实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">long</span> MAX=<span class="number">2147483647</span>;</div><div class="line">    <span class="keyword">long</span> MIN=<span class="number">-2147483648</span>;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(result&gt;MAX/<span class="number">10</span>||result&lt;MIN/<span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            result=result*<span class="number">10</span>+x%<span class="number">10</span>;</div><div class="line">            x=x/<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>也就是计算结果的时候，先判断这次计算会不会溢出，溢出就直接返回0</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer..&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode——3. Longest Substring Without Repeating Characters</title>
    <link href="http://wuyujie.top/2019/03/28/LeetCode%E2%80%94%E2%80%943-Longest-Substring-Without-Repeating-Characters/"/>
    <id>http://wuyujie.top/2019/03/28/LeetCode——3-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2019-03-28T09:30:26.000Z</published>
    <updated>2019-03-28T09:50:55.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.<br><a id="more"></a></p></blockquote><h5 id="Example1"><a href="#Example1" class="headerlink" title="Example1:"></a>Example1:</h5><blockquote><p>Input: “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3. </p></blockquote><h5 id="Example1-1"><a href="#Example1-1" class="headerlink" title="Example1:"></a>Example1:</h5><blockquote><p>Input: “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</p></blockquote><h5 id="Example1-2"><a href="#Example1-2" class="headerlink" title="Example1:"></a>Example1:</h5><blockquote><p>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3. </p><ul><li>Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</li></ul></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目要求的是，最长不含重复元素的字串。<br>最开始的想法是，用一个向量数组，存储以每一个位置为终点，包含该位置字符在内的最长不含重复元素的字串的长度，相当于一个dp的算法。数组更新方式是：用一个二重循环，外循环是从第一个字符到最后一个字符一次遍历；内循环用于判断，以该位置字符为终点，可以得到的最长不重复字串有多长。该算法成功解决了问题。<br>后来继续分析程序，发现可以不使用向量数组，因为数组内的每一个元素的值只需要访问一次，直接用一个变量保存即可。用此方法改进后，速度和空间都得到了优化。</p><blockquote><p>讨论区有另外一种更优化的解法，代码中用vector生成256个-1，用来存储每个字符上一次出现的下标。代码比较抽象，理解如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v(<span class="number">256</span>,<span class="number">-1</span>); <span class="comment">//构造字符串的容器。初始化为-1，意思是暂时不存在这个字符。</span></div><div class="line">start=<span class="number">-1</span>; <span class="comment">//start用来记录子串开始的位置，初始化为-1，表示没有开始构造子字符串。</span></div><div class="line"><span class="keyword">if</span>(v[s[i]]&gt;start)<span class="comment">//已经在该字符出现之前出现过相同的字符了，那么就将start也就是开始位置标记为上次该字符的出现位置。</span></div><div class="line">start=v[s[i]]; </div><div class="line">v[s[i]]=i; <span class="comment">//更新字符在容器中对应的下标</span></div><div class="line">ans=max(ans,i-start); <span class="comment">//i-start的意思是，当前for循环的i（也就是子字符串的结束字符）减去子字符串结束的字符的下标位置，结果就是子字符串的长度。</span></div></pre></td></tr></table></figure></p></blockquote><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol><li>解法1(使用了向量数组)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="comment">//空字符串，直接返回0</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> max=<span class="number">1</span>; <span class="comment">//非空字符串，最短为1</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; longestsub; <span class="comment">//每个位置的最长不重复字串长度</span></div><div class="line">        longestsub.push_back(<span class="number">1</span>); <span class="comment">//初始化第一个位置</span></div><div class="line"><span class="comment">//遍历每一个位置</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</div><div class="line">        &#123;</div><div class="line">            longestsub.push_back(<span class="number">1</span>);</div><div class="line"><span class="comment">//从上一个位置的最长不重复字串为起点</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-longestsub[i<span class="number">-1</span>];j&lt;i;j++)</div><div class="line">            &#123;</div><div class="line"><span class="comment">//没有重复，继续计算</span></div><div class="line">                <span class="keyword">if</span>(s[j]!=s[i])</div><div class="line">                &#123;</div><div class="line">                    longestsub[i]++;</div><div class="line">                &#125;</div><div class="line"><span class="comment">//有重复，从1开始重新计数</span></div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    longestsub[i]=<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"><span class="comment">//记录最长长度</span></div><div class="line">            <span class="keyword">if</span>(longestsub[i]&gt;max)</div><div class="line">            &#123;</div><div class="line">                max=longestsub[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ol><li>不使用数组</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> Longest=<span class="number">1</span>,Last=<span class="number">1</span>;<span class="comment">//记录最长长度和上一字符的最长不重复字串长度</span></div><div class="line">        <span class="comment">//vector&lt;int&gt; longestsub;</span></div><div class="line">        <span class="comment">//longestsub.push_back(1);</span></div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//longestsub.push_back(1);</span></div><div class="line">            <span class="keyword">int</span> present=<span class="number">1</span>;<span class="comment">//计算当前位置最长不重复字串长度</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-Last;j&lt;i;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(s[j]!=s[i])</div><div class="line">                &#123;</div><div class="line">                    present++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    present=<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            Longest=max(Longest,present);</div><div class="line">            Last=present;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Longest;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>3.解法3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, start = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != s.length(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (dict[s[i]] &gt; start)</div><div class="line">                start = dict[s[i]];</div><div class="line">            dict[s[i]] = i;</div><div class="line">            maxLen = max(maxLen, i - start);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxLen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Given a string, find the length of the &lt;strong&gt;longest substring&lt;/strong&gt; without repeating characters.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode——2. Add Two Numbers</title>
    <link href="http://wuyujie.top/2019/03/28/LeLeetCode%E2%80%94%E2%80%942-Add-Two-Numbers/"/>
    <id>http://wuyujie.top/2019/03/28/LeLeetCode——2-Add-Two-Numbers/</id>
    <published>2019-03-28T08:44:40.000Z</published>
    <updated>2019-03-28T10:50:14.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br><a id="more"></a><br>You may assume the two numbers do not contain any leading zero, except the number 0 itself. </p></blockquote><h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><blockquote><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目意思即，两个数是用链表按逆序存储的，现在要求两个数的和。实现算法思想即，模拟一个加法器，按位(这里即每一个链表结点)相加，需要设置一个进位标志位。这里只需要注意几种特殊情况即可：<br>1.两个数不一样长时，需要额外处理；<br>2.如果最终计算结果超过两个数的长度时，需要多增加一位。<br>在实现过程中，用一个新的链表来存储计算结果。<br>在查看讨论区后，发现算法思路大致相同，但是别人的代码更加精简，可以从中借鉴代码的一些简化方法和思想</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol><li>解法1</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> CF=<span class="number">0</span>; <span class="comment">//进位</span></div><div class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>; <span class="comment">//每位计算的中间结果</span></div><div class="line">        ListNode* result=<span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//新链表存储结果，头结点</span></div><div class="line">        ListNode* present=result; <span class="comment">//结果链表当前节点</span></div><div class="line">        <span class="comment">//两个数都有节点还未计算是，循环按位计算</span></div><div class="line"><span class="keyword">while</span>(l1&amp;&amp;l2)</div><div class="line">        &#123;</div><div class="line"><span class="comment">//加法结果</span></div><div class="line">            tmp=(l1-&gt;val+l2-&gt;val+CF)%<span class="number">10</span>;</div><div class="line">            present-&gt;val=tmp;</div><div class="line">            </div><div class="line"><span class="comment">//进位</span></div><div class="line">            CF=(l1-&gt;val+l2-&gt;val+CF)/<span class="number">10</span>;</div><div class="line">            </div><div class="line"><span class="comment">//链表指针后移</span></div><div class="line">l1=l1-&gt;next;</div><div class="line">            l2=l2-&gt;next;</div><div class="line">            </div><div class="line"><span class="comment">//如果其中一个数已经加完，不再new新节点</span></div><div class="line">            <span class="keyword">if</span>(l1&amp;&amp;l2)</div><div class="line">            &#123;</div><div class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">                present=present-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="comment">//若其中一个数未加完，即比另外一个数要长，需要结合进位进一步处理</span></div><div class="line"><span class="comment">//两个数的处理方式相同</span></div><div class="line">        <span class="keyword">while</span>(l1)</div><div class="line">        &#123;</div><div class="line"><span class="comment">//有进位，需要加上进位继续处理</span></div><div class="line">            <span class="keyword">if</span>(CF==<span class="number">1</span>)</div><div class="line">            &#123;</div><div class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">                present=present-&gt;next;</div><div class="line"></div><div class="line">                tmp=(l1-&gt;val+CF)%<span class="number">10</span>;</div><div class="line">                present-&gt;val=tmp;</div><div class="line"></div><div class="line">                CF=(l1-&gt;val+CF)/<span class="number">10</span>;</div><div class="line">                l1=l1-&gt;next;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line"><span class="comment">//若已经没进位，计算结果后面的数与该数剩下的数相同</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                present-&gt;next=l1;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(l2)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(CF==<span class="number">1</span>)</div><div class="line">            &#123;</div><div class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">                present=present-&gt;next;</div><div class="line"></div><div class="line">                tmp=(l2-&gt;val+CF)%<span class="number">10</span>;</div><div class="line">                present-&gt;val=tmp;</div><div class="line"></div><div class="line">                CF=(l2-&gt;val+CF)/<span class="number">10</span>;</div><div class="line">                l2=l2-&gt;next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                present-&gt;next=l2;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="comment">//如果两个数都加完了，还有进位，那么new一个新节点，保存该进位</span></div><div class="line">        <span class="keyword">if</span>(CF==<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ol><li>精简的解法</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</div><div class="line">        ListNode preHead(0), *p = &amp;preHead;</div><div class="line">        int extra = 0;</div><div class="line">        while (l1 || l2 || extra) &#123;</div><div class="line">            int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + extra;</div><div class="line">            extra = sum / 10;</div><div class="line">            p-&gt;next = new ListNode(sum % 10);</div><div class="line">            p = p-&gt;next;</div><div class="line">            l1 = l1 ? l1-&gt;next : l1;</div><div class="line">            l2 = l2 ? l2-&gt;next : l2;</div><div class="line">        &#125;</div><div class="line">        return preHead.next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;You are given two &lt;strong&gt;non-empty&lt;/strong&gt; linked lists representing two non-negative integers. The digits are stored in &lt;strong&gt;reverse order&lt;/strong&gt; and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode——1. Two Sum</title>
    <link href="http://wuyujie.top/2019/03/28/LeetCode%E2%80%94%E2%80%941-Two-Sum/"/>
    <id>http://wuyujie.top/2019/03/28/LeetCode——1-Two-Sum/</id>
    <published>2019-03-28T08:42:04.000Z</published>
    <updated>2019-03-31T03:57:12.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.<br><a id="more"></a><br>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the same element twice.</p></blockquote><p><strong>Example1:</strong></p><blockquote><p>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>给定一个数组，和一个目标数target，要求数组中，和为target的两个数的下标。<br>想到的方法是暴力求法，即直接逐个遍历数组，找出满足要求的两个数。尽管这种方法能成功AC,但显然效率不高，这种方法比较耗时。需要寻找更加优化的算法。<br>查阅资料和题解思路得知，更加优化的方法是使用哈希表，这是一种通过以空间换取速度的方式，我们可以将查找时间从 O(n)降低到 O(1)。主要有以下两种：</p><blockquote><p>1.两遍哈希表<br>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。</p><p>2.一遍哈希表<br>更优化的方法是，我们可以一次完成计算。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p></blockquote><p>这里将这两种方法都实现了一遍。</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol><li><p>解法1 暴力求法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indices;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-1</span>;i++)</div><div class="line">        &#123;</div><div class="line">            indices.push_back(i);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size();j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(nums[j]==target-nums[i])</div><div class="line">                &#123;</div><div class="line">                    indices.push_back(j);</div><div class="line">                    <span class="keyword">return</span> indices;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            indices.pop_back();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> indices;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>解法2 两遍哈希表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  indices;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">        &#123;</div><div class="line">            hash[nums[i]]=i;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> complement = target - nums[i];</div><div class="line">            <span class="keyword">if</span> (hash.count(complement) &amp;&amp; hash[complement] != i)</div><div class="line">            &#123;</div><div class="line">                indices.push_back(i);</div><div class="line">                indices.push_back(hash[complement]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> indices;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>一遍哈希表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  indices;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> complement = target - nums[i];</div><div class="line">            <span class="keyword">if</span> (hash.count(complement))</div><div class="line">            &#123;</div><div class="line">                indices.push_back(i);</div><div class="line">                indices.push_back(hash[complement]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            hash[nums[i]]=i;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> indices;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li></ol><hr><p>更新：map与unordered_map区别<br>原文：<a href="https://blog.csdn.net/BillCYJ/article/details/78985895" target="_blank" rel="external">https://blog.csdn.net/BillCYJ/article/details/78985895</a><br><strong>1.内部实现机理不同</strong><br><strong>map</strong>： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。</p><p><strong>unordered_map</strong>: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p><p><strong>2.优缺点以及适用处</strong><br><strong>map：</strong><br>优点：</p><ol><li>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</li><li>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</li></ol><p>缺点：<br>空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间</p><p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p><p><strong>unordered_map：</strong><br>优点： 因为内部实现了哈希表，因此其查找速度非常的快</p><p>缺点： 哈希表的建立比较耗费时间</p><p>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p><p><strong>总结：</strong></p><ol><li>内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。</li><li>但是unordered_map执行效率要比map高很多</li><li>对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Given an array of integers, return &lt;strong&gt;indices&lt;/strong&gt; of the two numbers such that they add up to a specific target.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode——929. Unique Email Addresses</title>
    <link href="http://wuyujie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94929-Unique-Email-Addresses/"/>
    <id>http://wuyujie.top/2019/03/28/LeetCode——929-Unique-Email-Addresses/</id>
    <published>2019-03-28T08:09:35.000Z</published>
    <updated>2019-03-28T08:39:25.053Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote><p>Every email consists of a local name and a domain name, separated by the @ sign.</p><p>For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name.<br><a id="more"></a><br>Besides lowercase letters, these emails may contain ‘.’s or ‘+’s.</p><p>If you add periods (‘.’) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, “alice.z@leetcode.com” and “alicez@leetcode.com” forward to the same email address.  (Note that this rule does not apply for domain names.)</p><p>If you add a plus (‘+’) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.)</p><p>It is possible to use both of these rules at the same time.</p><p>Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails? </p></blockquote><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: <code>{&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;}</code><br>Output: <strong>2</strong></p></blockquote><p>Explanation: “testemail@leetcode.com” and “testemail@lee.tcode.com” actually receive mails</p><h5 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h5><ul><li>1 &lt;= emails[i].length &lt;= 100</li><li>1 &lt;= emails.length &lt;= 100</li><li>Each emails[i] contains exactly one ‘@’ character.</li></ul><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目的意思是，邮箱作为一个字符串，在字符”@”前面的部分：</p><blockquote><p>1.若出现字符’.’，则可以去掉该’.’;<br>2.若出现’+’，则从’+’到’@’的字符串都可去掉。</p></blockquote><p>根据这样的规则，判断总共有多少个不同的邮箱。思路很明确，只需要将每一个邮箱转换为其最简单的形式，然后去除其中重复的字符串，计算最终剩下的字符串个数即可。<br>首先联想到的是在每次处理完字符串后，将处理过的字符串放入一个set中，由于set内不含重复元素，所以自然就可以去重。但是vector有没有什么直接去重的方法呢？查阅资料后发现还真有，在vector类型中，有一种去重的方法是：先在vector内对向量进行排序，然后用erase加unique函数即可实现去除重复元素。</p><blockquote><ul><li>unique函数是一个去重函数，去除相邻中的重复元素（只留一个）。其中，最关键的是：并不是把重复的元素删除，而是全部放倒数组的后面。</li><li>由于unique只是去除（相邻）的重复元素，因此，为了去除重复的元素，应该，首先对数组Vector进行排序，这样保证重复元素在相邻的位置。</li><li>unique函数，返回的是去重后的尾地址。因此对于一个内容为{2, 2, 5, 5, 6}的vector，执行unique函数以后，vector大小并没有改变，只不过顺序变成了{2, 5, 6, 2, 5}，并且函数的返回值为:3。此时需要删除重复元素，只需要将后面的数据全部删除即可。</li></ul></blockquote><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numUniqueEmails</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; emails)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator email=emails.begin();email&lt;emails.end();email++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(*email).find(<span class="string">'@'</span>);i++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>((*email)[i]==<span class="string">'.'</span>)  (*email).erase(i,<span class="number">1</span>);</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((*email)[i]==<span class="string">'+'</span>)</div><div class="line">                &#123;</div><div class="line">                    (*email).erase(i,(*email).find(<span class="string">'@'</span>)-i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        sort(emails.begin(),emails.end());</div><div class="line">        emails.erase(unique(emails.begin(), emails.end()), emails.end());</div><div class="line">        <span class="keyword">return</span> emails.size();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Every email consists of a local name and a domain name, separated by the @ sign.&lt;/p&gt;
&lt;p&gt;For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode——709. To Lower Case</title>
    <link href="http://wuyujie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94709-To-Lower-Case/"/>
    <id>http://wuyujie.top/2019/03/28/LeetCode——709-To-Lower-Case/</id>
    <published>2019-03-28T07:35:25.000Z</published>
    <updated>2019-03-28T08:03:40.030Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote><p>Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.<br><a id="more"></a></p></blockquote><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: “Hello”<br>Output: “hello”</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: “here”<br>Output: “here”</p></blockquote><h5 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h5><blockquote><p>Input: “LOVELY”<br>Output: “lovely”</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题主要用来熟悉下transform(STL transform)函数</p><blockquote><p>transform() 可以将函数应用到序列的元素上，并将这个函数返回的值保存到另一个序列中，它返回的迭代器指向输出序列所保存的最后一个元素的下一个位置。调用方法如下：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryOperator</span> &gt; </span></div><div class="line"><span class="title">OutputIterator</span> <span class="title">transform</span> ( <span class="title">InputIterator</span> <span class="title">first1</span>,  // 源容器的起始地址 </div><div class="line">  <span class="title">InputIterator</span> <span class="title">last1</span>,    // 源容器的终止地址 </div><div class="line">  <span class="title">OutputIterator</span> <span class="title">result</span>,  // 目标容器的起始地址 </div><div class="line">  <span class="title">UnaryOperator</span> <span class="title">op</span> );     <span class="comment">// 函数指针 </span></div><div class="line"><span class="comment">// typedef 目标容器元素类型 (*UnaryOperator)(源容器元素类型); </span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, </span></div><div class="line"><span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">BinaryOperator</span> &gt; </div><div class="line"><span class="title">OutputIterator</span> <span class="title">transform</span> ( <span class="title">InputIterator1</span> <span class="title">first1</span>,     // 源容器1的起始地址 </div><div class="line">  <span class="title">InputIterator1</span> <span class="title">last1</span>,       // 源容器1的终止地址 </div><div class="line">  <span class="title">InputIterator2</span> <span class="title">first2</span>,      // 源容器2的起始地址，元素个数与1相同 </div><div class="line">  <span class="title">OutputIterator</span> <span class="title">result</span>,      // 目标容器的起始地址，元素个数与1相同 </div><div class="line">  <span class="title">BinaryOperator</span> <span class="title">binary_op</span> ); <span class="comment">// 函数指针 </span></div><div class="line"><span class="comment">// typedef 目标容器元素类型 (*BinaryOperator)(源容器1元素类型，源容器2元素类型);</span></div></pre></td></tr></table></figure><p>所以transform结合大小写转换函数tolower，只需要一行即可完成任务</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toLowerCase</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</div><div class="line">        transform(str.begin(),str.end(),str.begin(),::<span class="built_in">tolower</span>);</div><div class="line">        <span class="keyword">return</span> str;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode——771. Jewels and Stones</title>
    <link href="http://wuyujie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94771-Jewels-and-Stones/"/>
    <id>http://wuyujie.top/2019/03/28/LeetCode——771-Jewels-and-Stones/</id>
    <published>2019-03-28T07:26:09.000Z</published>
    <updated>2019-03-28T08:03:36.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><a id="more"></a><blockquote><p>You’re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.<br>The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.</p></blockquote><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h5><blockquote><p>Input: J = “aA”, S = “aAAbbbb”<br>Output: 3</p></blockquote><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h5><blockquote><p>Input: J = “z”, S = “ZZ”<br>Output: 0</p></blockquote><h5 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h5><blockquote><ul><li>S and J will consist of letters and have length at most 50.</li><li>The characters in J are distinct.</li></ul></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>1.这是一道很简单的题，只需要逐个判断字符串 <strong>S</strong> 中的每个字符,是否在字符串 <strong>J</strong> 中出现过。设置一个计数器count，每次判断后更新该计数器，带遍历完整个字符串，即可得出最终结果。比较字符串的过程中，应用了string库里的find()函数。<br>2.在看别人提交的解法中，看见了另外一种比较有趣的方法，建立了一个与字符ASCII码大小相同的数组，每次判断字符是否存在，只需直接在数组内查看该字符ASCII码对应的位置是否为1，这是一种空间换时间的方法。</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol><li>解法1 </li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(J.find(S[i]) != J.npos)</div><div class="line">            &#123;</div><div class="line">                ++count;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ol><li>解法2</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> exist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;; </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; J.length();i++) &#123;</div><div class="line">            exist[J.at(i)] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++) &#123;</div><div class="line">            <span class="keyword">if</span> (exist[S.at(i)]) &#123;</div><div class="line">                num++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>My new Post</title>
    <link href="http://wuyujie.top/2017/09/21/My-new-Post/"/>
    <id>http://wuyujie.top/2017/09/21/My-new-Post/</id>
    <published>2017-09-21T06:16:07.000Z</published>
    <updated>2017-09-21T06:16:07.941Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://wuyujie.top/2017/07/10/hello-world/"/>
    <id>http://wuyujie.top/2017/07/10/hello-world/</id>
    <published>2017-07-10T10:09:19.631Z</published>
    <updated>2017-09-21T16:39:10.819Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
