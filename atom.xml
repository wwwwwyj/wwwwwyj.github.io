<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuYJ&#39;s Blog</title>
  
  <subtitle>wuyunjie的小站</subtitle>
  <link href="https://wuyunjie.top/atom.xml" rel="self"/>
  
  <link href="https://wuyunjie.top/"/>
  <updated>2021-08-05T08:00:14.000Z</updated>
  <id>https://wuyunjie.top/</id>
  
  <author>
    <name>wuyunjie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java|正则表达式]</title>
    <link href="https://wuyunjie.top/2021/08/05/JavaLearning_Regular-Expression.html"/>
    <id>https://wuyunjie.top/2021/08/05/JavaLearning_Regular-Expression.html</id>
    <published>2021-08-05T08:00:14.000Z</published>
    <updated>2021-08-05T08:00:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>正则表达式，又称规则表达式（<code>Regular Expression</code>，在代码中常简写为<code>regex</code>、<code>regexp</code>或<code>RE</code>），通常被用来检索、替换那些符合某个模式(规则)的文本。 <span id="more"></span></p></blockquote><h3 id="正则表达式的规则">1. 正则表达式的规则</h3><ul><li><p>任意一个字符表示匹配任意对应的字符，如a匹配a，7匹配7，-匹配-。</p></li><li><p><code>[]</code>代表匹配中括号中其中任一个字符，如<code>[abc]</code>匹配a或b或c。</p></li><li><p><code>-</code>在中括号里面和外面代表含义不同，如在外时，就匹配<code>-</code>，如果在中括号内<code>[a-b]</code>表示匹配26个小写字母中的任一个。</p></li><li><p><code>^</code>在中括号里面和外面含义不同，如在外时，就表示开头，如<code>^7[0-9]</code>表示匹配开头是7的，且第二位是任一数字的字符串；如果在中括号里面，表示除了这个字符之外的任意字符(包括数字，特殊字符)，如<code>[^abc]</code>表示匹配出去<code>abc</code>之外的其他任一字符。</p></li><li><p><code>.</code>表示匹配任意的字符。</p></li><li><p><code>\d</code>表示数字。</p></li><li><p><code>\D</code>表示非数字。</p></li><li><p><code>\s</code>表示由空字符组成，<code>[ \t\n\r\x\f]</code>。</p></li><li><p><code>\S</code>表示由非空字符组成，<code>[^\s]</code>。</p></li><li><p><code>\w</code>表示字母、数字、下划线，<code>[a-zA-Z0-9_]</code>。</p></li><li><p><code>\W</code>表示不是由字母、数字、下划线组成。</p></li><li><p><code>?</code> 表示出现0次或1次，<code>X?</code> 表示匹配 0 个或 1 个字母 X。</p></li><li><p><code>+</code>表示出现1次或多次。</p></li><li><p><code>*</code>表示出现0次、1次或多次。</p></li><li><p><code>&#123;n&#125;</code>表示出现n次。</p></li><li><p><code>&#123;n,m&#125;</code>表示出现n~m次。</p></li><li><p><code>&#123;n,&#125;</code>表示出现n次或n次以上。</p></li><li><p><code>XY</code>表示<code>X</code>后面跟着<code>Y</code>，这里X和Y分别是正则表达式的一部分。</p></li><li><p><code>X|Y</code>表示X或Y，比如<code>"food|f"</code>匹配的是<code>foo(d或f)</code>，而<code>"(food)|f"</code>匹配的是<code>food</code>或<code>f</code>。</p></li><li><p><code>(X)</code>子表达式，将<code>X</code>看做是一个整体。</p></li></ul><h3 id="java中的正则表达式">2. Java中的正则表达式</h3><p>在<code>java</code>中调用正则表达式的类是<code>java.util.regex.Matcher</code>和<code>java.util.regex.Pattern</code>，<code>java.util.regex</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;8&quot;</span>;</span><br><span class="line">    String regex = <span class="string">&quot;[0-9]&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Pattern.matches(regex, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正则表达式</span></span><br><span class="line"><span class="comment"> * 正则表达式 的用法主要是4种方面的使用</span></span><br><span class="line"><span class="comment"> * 匹配，分割，替换，获取.</span></span><br><span class="line"><span class="comment"> * 用一些简单的符号来代表代码的操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cyc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//针对字符串处理</span></span><br><span class="line">        RegexMatches reg = <span class="keyword">new</span> RegexMatches();</span><br><span class="line">        <span class="comment">//校验qq的reg正则表达式</span></span><br><span class="line">        <span class="comment">//这里的\w 是指的是[a-zA-Z0-9],还有一个重要的是?,*.+这三个分别</span></span><br><span class="line">        <span class="comment">//?表示出现1次或者1次都没有，</span></span><br><span class="line">        <span class="comment">//+表示出现1次或者n次，</span></span><br><span class="line">        <span class="comment">//*表示出现0次或者n次，</span></span><br><span class="line">        <span class="comment">//还有些特殊的写法X&#123;n&#125;恰好n次X&#123;n,&#125;至少n次，X&#123;n,m&#125;n次到m次，</span></span><br><span class="line">        String mathReg = <span class="string">&quot;[0-9]\\d&#123;4,19&#125;&quot;</span>;</span><br><span class="line">        String divisionReg = <span class="string">&quot;(.)\\1+&quot;</span>;</span><br><span class="line">        <span class="comment">//\\b 是指的边界值</span></span><br><span class="line">        String getStringReg = <span class="string">&quot;\\b\\w&#123;3&#125;\\b&quot;</span>;</span><br><span class="line">        <span class="comment">//字符串匹配(首位是除0 的字符串)</span></span><br><span class="line">        reg.getMatch(<span class="string">&quot;739295732&quot;</span>,mathReg);</span><br><span class="line">        reg.getMatch(<span class="string">&quot;039295732&quot;</span>,mathReg);</span><br><span class="line">        <span class="comment">//字符串的替换</span></span><br><span class="line">        <span class="comment">//去除叠词</span></span><br><span class="line">        reg.getReplace(<span class="string">&quot;12111123ASDASDAAADDD&quot;</span>,divisionReg,<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">        <span class="comment">//字符串的分割</span></span><br><span class="line">        <span class="comment">//切割叠词,重复的</span></span><br><span class="line">        <span class="comment">//这里要知道一个组的概念(.)\\1第二个和第一个至相同</span></span><br><span class="line">        reg.getDivision(<span class="string">&quot;aadddddasdasdasaaaaaassssfq&quot;</span>,divisionReg);</span><br><span class="line">        <span class="comment">//字符串的获取</span></span><br><span class="line">        <span class="comment">//现在获取三个字符串取出</span></span><br><span class="line">        reg.getString(<span class="string">&quot;ming tian jiu yao fangjia le &quot;</span>,getStringReg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取查询的字符串</span></span><br><span class="line"><span class="comment">     * 将匹配的字符串取出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getString</span><span class="params">(String str, String regx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.将正在表达式封装成对象Patten 类来实现</span></span><br><span class="line">        Pattern pattern = Pattern.compile(regx);</span><br><span class="line">        <span class="comment">//2.将字符串和正则表达式相关联</span></span><br><span class="line">        Matcher matcher = pattern.matcher(str);</span><br><span class="line">        <span class="comment">//3.String 对象中的matches 方法就是通过这个Matcher和pattern来实现的。</span></span><br><span class="line"></span><br><span class="line">        System.out.println(matcher.matches());</span><br><span class="line">        <span class="comment">//查找符合规则的子串</span></span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            <span class="comment">//获取 字符串</span></span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">            <span class="comment">//获取的字符串的首位置和末位置</span></span><br><span class="line">            System.out.println(matcher.start()+<span class="string">&quot;--&quot;</span>+matcher.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串的分割</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getDivision</span><span class="params">(String str, String regx)</span> </span>&#123;</span><br><span class="line">        String [] dataStr = str.split(regx);</span><br><span class="line">        <span class="keyword">for</span>(String s:dataStr)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正则表达式分割++&quot;</span>+s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串的替换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getReplace</span><span class="params">(String str, String regx,String replaceStr)</span> </span>&#123;</span><br><span class="line">        String stri = str.replaceAll(regx,replaceStr) ;</span><br><span class="line">        System.out.println(<span class="string">&quot;正则表达式替换&quot;</span>+stri);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串处理之匹配</span></span><br><span class="line"><span class="comment">     * String类中的match 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMatch</span><span class="params">(String str, String regx)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正则表达匹配&quot;</span>+str.matches(regx));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, String&gt; <span class="title">splitCountry</span><span class="params">(String country)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; ret = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        Pattern mpattern = Pattern.compile(<span class="string">&quot;(((.*省)|(.*市)|(.*区)).*?|.*)&quot;</span>);</span><br><span class="line">        Matcher mmatcher = mpattern.matcher(country);</span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (mmatcher.find()) &#123;</span><br><span class="line">            str = mmatcher.group();</span><br><span class="line">            <span class="keyword">if</span> (str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str.endsWith(<span class="string">&quot;省&quot;</span>))</span><br><span class="line">                    ret.put(<span class="string">&quot;province&quot;</span>, str);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (str.endsWith(<span class="string">&quot;市&quot;</span>))</span><br><span class="line">                    ret.put(<span class="string">&quot;city&quot;</span>, str);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (str.endsWith(<span class="string">&quot;区&quot;</span>))</span><br><span class="line">                    ret.put(<span class="string">&quot;region&quot;</span>, str);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ret.put(<span class="string">&quot;province&quot;</span>, str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献">参考文献</h3><p>[1] <a href="https://www.jianshu.com/p/3c076c6b2dc8">Java中正则表达式</a></p><p>[2] <a href="https://segmentfault.com/a/1190000009162306">Java 正则表达式详解</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;正则表达式，又称规则表达式（&lt;code&gt;Regular Expression&lt;/code&gt;，在代码中常简写为&lt;code&gt;regex&lt;/code&gt;、&lt;code&gt;regexp&lt;/code&gt;或&lt;code&gt;RE&lt;/code&gt;），通常被用来检索、替换那些符合某个模式(规则)的文本。</summary>
    
    
    
    <category term="Java" scheme="https://wuyunjie.top/categories/Java/"/>
    
    
    <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
    <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
    <category term="Regular Expression" scheme="https://wuyunjie.top/tags/Regular-Expression/"/>
    
  </entry>
  
  <entry>
    <title>[大数据技术原理|第三篇 大数据处理与分析(2)]</title>
    <link href="https://wuyunjie.top/2021/08/04/Big_Data_3_process-and-analyze-2.html"/>
    <id>https://wuyunjie.top/2021/08/04/Big_Data_3_process-and-analyze-2.html</id>
    <published>2021-08-04T08:51:49.000Z</published>
    <updated>2021-08-04T08:51:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介">简介</h3><p><code>Spark</code>最初的设计目标是使数据分析更快——不仅运行速度快，也要能快速、容易地编写程序。为了使程序运行更快， <code>Spark</code>提供了内存计算，减少了迭代计算时的<code>IO开销</code>；而为了使编写程序更为容易， <code>Spark</code>使用简练、优雅的<code>Scala</code>语言编写，基于<code>Scala</code>提供了交互式的编程体验。</p><span id="more"></span><h3 id="spark概述">1. Spark概述</h3><h4 id="spark简介">1.1 Spark简介</h4><p><code>Spark</code>具有如下4个主要特点：</p><ol type="1"><li><strong>运行速度快</strong>。<code>Spark</code>使用先进的<code>DAG（ Directed Acyclic Graph，有向无环图）</code>执行引擎，以支持循环数据流与内存计算，基于内存的执行速度可比 Hadoop MapReduce快上百倍。</li><li><strong>容易使用</strong>。<code>Spark</code>支持使用<code>Scala、Java、Python</code>和<code>R</code>语言进行编程，简洁的API设计有助于用户轻松构建并行程序，并且可以通过<code>Spark Shell</code>进行交互式编程。</li><li><strong>通用性</strong>。<code>Spark</code>提供了完整而强大的技术栈，包括<strong>SQL查询、流式计算、机器学习和图算法</strong>组件，这些组件可以无缝整合在同一个应用中，足以应对复杂的计算。</li><li><strong>运行模式多样</strong>。 <code>Spark</code>可运行于独立的集群模式中，或者运行于<code>Hadoop</code>中，也可运行于<code>Amazon EC2</code>等云环境中，并且可以访问<code>HDFS</code>、<code>Cassandra</code>、<code>HBase</code>、<code>Hive</code>等多种数据源。</li></ol><h4 id="scala简介">1.2 Scala简介</h4><p><code>Scala</code>是一门现代的多范式编程语言，平滑地集成了面向对象和函数式语言的特性，旨在以简练、优雅的方式来表达常用编程模式。<code>Scala</code>语言的名称来自于<code>“可扩展的语言（ A Scalable Language）"</code>，从写个小脚本到建立个大系统的编程任务均可胜任。<code>Scala</code>运行于<code>JVM</code>上，兼容现有的<code>Java</code>程序。总体而言，<code>Scala</code>具有以下突出的优点。</p><ul><li><code>Scala</code>具备强大的并发性，支持函数式编程，可以更好地支持分布式系统。</li><li><code>Scala</code>语法简洁，能提供优雅的API。</li><li><code>Scala</code>兼容<code>Java</code>，运行速度快，且能融合到 Hadoop生态圈中。</li></ul><h4 id="spark与hadoop的对比">1.3 <code>Spark</code>与<code>Hadoop</code>的对比</h4><p><code>Hadoop</code>最主要的缺陷是其MapReduce计算模型延迟过高，无法胜任实吋、快速计算的需求，因而只适用于离线批处理的应用场景。<code>Hadoop</code>主要存在以下缺点：</p><ul><li><strong>表达能力有限</strong>。计算都必须要转化成<code>Map</code>和<code>Reduce</code>两个操作，难以描述复杂的数据处理过程。</li><li><strong>磁盘IO开销大</strong>。每次执行时都需要从磁盘读取数据，并且在计算完成后需要将中间结果写入到磁盘中。</li><li><strong>延迟高</strong>。一次计算可能需要分解成一系列按顺序执行的<code>MapReduce</code>任务，任务之间的衔接由于涉及到<code>IO</code>开销，会产生较高延迟。在前一个任务执行完成之前，其他任务无法开始。</li></ul><p><code>Spark</code>在借鉴<code>Hadoop MapReduce</code>优点的同时，很好地解决了<code>MapReduce</code>所面临的问题。<code>Spark</code>主要具有如下优点：</p><ul><li><strong><u>编程模型比<code>MapReduce</code>更灵活</u></strong>。<code>Spark</code>的计算模式也属于<code>MapReduce</code>，但不局限于<code>Map</code>和<code>Reduce</code>操作，还提供了多种数据集操作类型。</li><li><code>Spark</code>提供了<strong>内存计算</strong>，中间结果直接放到内存中，带来了更高的迭代运算效率。</li><li><code>Spark</code>基于<code>DAG</code>的任务调度执行机制，要优于<code>MapReduce</code>的迭代执行机制。</li></ul><p><code>Spark</code>最大的特点就是<strong><u>将计算数据、中间结果都存储在内存中，大大减少了IO开销</u></strong>，因而<code>Spark</code>更适合于<strong><u>迭代运算比较多的数据挖掘与机器学习运算</u></strong>。</p><p><code>Spark</code>并不能完全替代<code>Hadoop</code>，主要用于替代<code>Hadoop</code>中的<code>MapReduce</code>计算模型，它可以借助于<code>YARN</code>实现资源调度管理，借助于<code>HDFS</code>实现分布式存储。<code>Spak</code>对硬件的要求稍高，对内存喝CPU有一定要求。</p><h3 id="spark生态系统">2. Spark生态系统</h3><p><code>Spark</code>的设计遵循<code>“一个软件栈满足不同应用场景”</code>的理念，逐渐形成了一套完整的生态系统，既能够提供内存计算框架，也可以支持<code>SQL</code>即席査询、实时流式计算、机器学习和图计算等。<code>Spark</code>可以部署在资源管理器<code>YARN</code>之上，提供一站式的大数据解决方案。</p><p><code>Spark</code>生态系统已经成为<strong>伯克利数据分析软件栈</strong><code>BDAS（Berkeley Data Analytics Stack）</code>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/BDAS.png" alt="伯克利数据分析软件栈BDAS" /><figcaption aria-hidden="true">伯克利数据分析软件栈BDAS</figcaption></figure><p><code>Spak</code>生态系统主要包含了<code>Spark Core</code>、<code>Spark SQL</code>、<code>Spark Streaming</code>、<code>MLlib</code>和<code>GraphX</code>等组件，各个组件的具体功能如下。</p><ol type="1"><li><strong>Spark Core</strong>。Spark Core包含<code>Spark</code>的基本功能，如内存计算、任务调度、部署模式、故障恢复、存储管理等，主要面向批数据处理。<code>Spark</code>建立在统一的抽象<code>RDD</code>之上，使其可以<strong><u>以基本一致的方式应对不同的大数据处理场景</u></strong>。</li><li><strong>Spark SQL</strong>。Spark SQL允许开发人员直接处理<code>RDD</code>，同时也可查询Hive、HBase等外部数据源。Spark SQL的一个重要特点是其<strong><u>能够统一处理关系表和<code>RDD</code></u></strong>，开发人员可以轻松地使用SQL命令进行查询，进行更复杂的数据分析。</li><li><strong>Spark Streaming</strong>。Spark Streaming支持高吞吐量、可容错处理的实时流数据处理，其核心思路是<strong><u>将流数据分解成一系列短小的批处理作业</u></strong>，每个短小的批处理作业都可以使用Spark Core进行快速处理。Spark Streaming支持多种数据输入源，如 <code>Kafka</code>、<code>Flume</code>和<code>TCP</code>套接字等。</li><li><strong>MLlib（机器学习）</strong>。<code>MLlib</code>提供了常用机器学习算法的实现，包括聚类、分类、回归、协同过滤等。</li><li><code>GraphX（图计算）</code>。GraphX是<code>Spark</code>中用于图计算的API，可认为是<code>Pregel</code>在<code>Spark</code>上的重写及优化，<code>GraphX</code>性能良好，拥有丰富的功能和运算符，能在海量数据上自如地运行复杂的图算法。</li></ol><h3 id="spark-运行架构">3. Spark 运行架构</h3><h4 id="基本概念">3.1 基本概念</h4><ul><li><code>RDD</code>：即<code>弹性分布式数据集（ Resilient Distributed dataset）</code>，是分布式内存的一个抽象概念，提供了一种高度受限的<strong>共享内存模型</strong>；</li><li><code>DAG</code>：即<code>Directed Acyclic Graph（有向无环图）</code>，反映<code>RDD</code>之间的依赖关系</li><li><code>Executor</code>：运行在工作节点（Worker Node）上的一个进程，负责运行任务，并为应用程序存储数据。</li><li><code>Application</code>：用户编写的<code>Spark</code>应用程序。</li><li><code>Driver</code>：<code>Spark</code>中的<code>Driver</code>运行<code>Application</code>的<code>main</code>函数，并创建<code>SparkContext</code>准备<code>Spark</code>应用程序的运行环境。在<code>Spark</code>中由<code>SparkContext</code>负责与<code>ClusterManager</code>通信，进行资源申请、任务的分配和监控等，当<code>Executor</code>部分运行完毕后，<code>Driver</code>同时负责将<code>SparkContext</code>关闭。</li><li><code>Task</code>：运行在<code>Executor</code>上的工作单元。</li><li><code>Job</code>：一个作业包含多个<code>RDD</code>及作用于相应<code>RDD</code>上的各种操作。</li><li><code>Stage</code>：是作业的基本调度单位，一个作业会分为多组任务，每组任务被称为“阶段”，或者也被称为“任务集”。</li><li><code>CluterManager</code>：指集群上获取资源的外部服务。目前有三种类型<ol type="1"><li><code>Standalon</code> ：<code>Spark</code>原生的资源管理，由<code>Master</code>负责资源的分配</li><li><code>Apache Mesos</code>：与<code>Hadoop MR</code>兼容性良好的一种资源调度框架</li><li><code>Hadoop Yarn</code>：主要是指<code>Yarn</code>中的<code>ResourceManager</code></li></ol></li></ul><h4 id="架构设计">3.2 架构设计</h4><p>Spark运行架构，包括<code>集群资源管理器（Cluster Manager）</code>，运行作业任务的<code>工作节点（Worker Node）</code>、每个应用的<code>任务控制节点（Driver）</code>和每个工作节点上负责具体任务的<code>执行进程（Executor）</code>。集群资源管理器可以是<code>Spak</code>自带的资源管理器，也可以是<code>YARN</code>或<code>Mesos</code>等资源管理框架。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/Spark.png" alt="Spark运行架构" /><figcaption aria-hidden="true">Spark运行架构</figcaption></figure><p><code>Spark</code>所采用的<code>Executor</code>有两个优点：</p><ul><li>利用多线程来执行具体的任务（Hadoop MapReduce采用的是进程模型），减少任务的启动开销；</li><li><code>Executor</code>中有一个<code>BlockManager</code>存储模块，会将内存和磁盘共同作为存储设备，当需要多轮迭代计算时，可以将中间结果存储到这个存储模块里，减少IO开销。</li></ul><p><code>Spark</code>中各个概念的关系为：</p><ul><li><code>Spark</code>中一个<code>应用（Application）</code>由一个<code>任务控制节点（Driver）</code>和若干个<code>作业（Job）</code>构成；</li><li>一个作业由多个<code>阶段（Stage）</code>构成；</li><li>一个阶段由多个<code>任务（Task）</code>组成。</li></ul><p>当执行一个应用时，任务控制节点会向集群管理器（Cluster Manager）申请资源，启动 Executor，并向Executor发送应用程序代码和文件，然后在Executor上执行任务，运行结束后执行结果会返回给任务控制节点，或者写到HDFS或者其他数据库中。</p><h4 id="spark运行基本流程">3.3 Spark运行基本流程</h4><p><code>Spark</code>运行基本流程如下：</p><ol type="1"><li>当一个<code>Spak</code>应用被提交时，首先为这个应用构建<strong><u>基本运行环境</u></strong>，即由<code>任务控制节点（Driver）</code>创建一个<code>Spark Context</code>，由<code>Spark Context</code>负责和Cluster Manager的通信以及进行资源的申请、任务的分配和监控等。<code>Spark Context</code>会向资源管理器注册并申请运行Executor的资源。</li><li>资源管理器为Executor分配资源，并启动Executor进程，Executor运行情况将随着“心跳”发送到资源管理器上。</li><li><code>Spark Context</code>根据<code>RDD</code>的依赖关系构建<code>DAG</code>图，<code>DAG</code>图提交给<code>DAG调度器（DAG Scheduler）</code>进行解析，将DAG图分解成多个“阶段”，并且计算出各个阶段之间的依赖关系，然后把“任务集”提交给底层的<code>任务调度器（Task Scheduler）</code>进行处理；<code>Executor</code>向<code>Spark Context</code>申请任务，任务调度器将任务分发给<code>Executor</code>运行，同时<code>Spark Context</code>将应用程序代码发放给<code>Executor</code>；</li><li>任务在Executor运行，把执行结果反馈给任务调度器，然后反馈给DAG调度器，运行完毕后写入数据并释放所有资源。</li></ol><p><code>Spark</code>运行架构具有以下特点。</p><ul><li>每个应用都有自己专属的<code>Executor</code>进程，并且该进程在应用运行期间一直驻留。<code>Executor</code>进程以多线程的方式运行任务，减少了多进程任务频繁的启动开销。</li><li><code>Spark</code>运行过程与资源管理器无关，只要能够获取<code>Executor</code>进程并保持通信即可。</li><li><code>Executor</code>上有一个<code>BlockManager</code>存储模块，会将内存和磁盘共同作为存储设备，提高读写IO性能。</li><li>任务采用了<strong>数据本地性</strong>和<strong>推测执行</strong>等优化机制。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/SparkWork.png" alt="Spark运行基本流程" /><figcaption aria-hidden="true">Spark运行基本流程</figcaption></figure><h4 id="rdd的设计与运行原理">3.4 RDD的设计与运行原理</h4><h5 id="rdd的概念">3.4.1 RDD的概念</h5><p>一个<code>RDD</code>就是一个分布式对象集合，本质上是一个<strong><u>只读的分区记录集合</u></strong>。</p><ul><li><p>每个<code>RDD</code>可分成多个分区，每个分区就是一个<strong><u>数据集片段</u></strong>，并且一个<code>RDD</code>的不同分区可以被保存到集群中不同的节点上，从而<u><strong>可以在集群的不同节点上进行并行计算</strong></u>。</p></li><li><p><code>RDD</code>提供了一种高度受限的共享内存模型，即<code>RDD</code>是<strong><u>只读的记录分区的集合，不能直接修改</u></strong>。只能基于稳定的物理存储中的数据集创建<code>RDD</code>，或者通过在其他<code>RDD</code>上执行确定的转换操作（如<code>map</code>，<code>join</code>和<code>groupBy</code>）而创建得到新的<code>RDD</code>。</p></li></ul><p><code>RDD</code>提供了一组丰富的操作以支持常见的数据运算</p><ul><li><code>“行动”（Action）</code>。用于执行计算并指定输出的形式，行动操作（如<code>count</code>、<code>collect</code>等）<strong><u>接受<code>RDD</code>但是返回非<code>RDD</code></u></strong>（即输出一个值或结果）。</li><li><code>转换”（Transformation）</code>。指定<code>RDD</code>之间的相互依赖关系，转换操作（如<code>map</code>、<code>filter</code>、<code>groupBy</code>、<code>join</code>等）<strong><u>接受<code>RDD</code>并返回<code>RDD</code></u></strong>。</li></ul><p><code>RDD</code>执行过程：</p><ol type="1"><li><code>RDD</code>读入外部数据源进行创建；</li><li><code>RDD</code>经过一系列的<code>转换（Transformation）</code>操作，每一次都会产生不同的<code>RDD</code>供下一个转换操作使用；</li><li>最后一个<code>RDD</code>经过<code>“动作”</code>操作进行处理，并输出到外部数据源。</li></ol><p><code>RDD</code>使用<strong>惰性调用</strong>：</p><ul><li>即在<code>RDD</code>的执行过程中，真正的计算发生在<code>RDD</code>的<code>“行动”</code>操作，对于<code>“行动”</code>之前的所有<code>“转换”</code>操作，<code>Spark</code>只记录<code>“转换”</code>操作应用的基础数据集以及<code>RDD</code>生成的轨迹，而不会触发真正的计算。</li><li><code>RDD</code>生成的轨迹称为一个<code>“血缘关系(Lineage)"</code>，即<code>DAG</code>拓扑排序的结果。</li><li>采用惰性调用，通过血缘关系连接起来的一系列<code>RDD</code>操作就可以实现<code>管道化（Pipeline）</code>，<strong><u>避免了多次转换操作之间数据同步的等待，而且不必担心有过多的中间数据</u></strong>。</li></ul><h5 id="rdd特性">3.4.2 RDD特性</h5><p><code>Spark</code>采用<code>RDD</code>以后能够实现高效计算的主要原因是：</p><ul><li><strong>高效的容错性</strong>。<code>RDD</code>是一种天生具有容错机制的特殊集合，只需通过<code>RDD</code>父子依赖（血缘）关系重新计算得到丢失的分区来实现容错，无需回滚整个系统，避免了数据复制的高开销。重算过程可以在不同节点之间并行进行，实现了高效的容错。</li><li><strong>中间结果持久化到内存</strong>。数据在内存中的多个<code>RDD</code>操作之间进行传递，避免了不必要的IO开销。</li><li>存放的数据可以是<code>Java对象</code>，避免了不必要的对象序列化和反序列化开销。</li></ul><h5 id="rdd之间的依赖关系">3.4.3 RDD之间的依赖关系</h5><p><code>RDD</code>中不同的操作会使得不同<code>RDD</code>中的分区产生不同的依赖。<code>RDD</code>中的依赖关系分为<code>窄依赖（Narrow Dependency）</code>与<code>宽依赖（Wide Dependency）</code>。</p><ul><li>窄依赖表现为一个或多个父<code>RDD</code>的分区对应于一个子<code>RDD</code>的分区。</li><li>宽依赖表现为存在一个父<code>RDD</code>的一个分区对应一个子<code>RDD</code>的多个分区。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/SparkDependency.png" alt="窄依赖与宽依赖" /><figcaption aria-hidden="true">窄依赖与宽依赖</figcaption></figure><p>如果<code>父RDD</code>的一个分区只被一个<code>子RDD</code>的一个分区所使用就是窄依赖，否则就是宽依赖。窄依赖典型的操作包括<code>map</code>、 <code>filter</code>、<code>union</code>等，宽依赖典型的操作包括 <code>groupByKey</code>、<code>sortByKey</code>等。</p><ul><li>对于窄依赖的RDD，可以以流水线的方式计算所有父分区，不会造成网络之间的数据混合。</li><li>对于宽依赖的RDD，则通常伴随着<code>Shuffle</code>操作，即<strong><u>首先需要计算好所有父分区数据，然后在节点之间进行 <code>Shuffle</code></u></strong>。</li></ul><p>相对而言，在两种依赖关系中，窄依赖的失败恢复更为高效，它只需要根据父RDD分区重新计算丢失的分区即可<strong>（不需要重新计算所有分区）</strong>，而且可以并行地在不同节点上进行重新计算。而对于宽依赖而言，单个节点失效通常意味着重新计算过程会涉及多个父RDD分区，开销较大。</p><p>在进行故障恢复时，<code>Spark</code>会对数据检查点开销和重新计算<code>RDD</code>分区的开销进行比较，从而自动选择最优的恢复策略。</p><h5 id="阶段的划分">3.4.4 阶段的划分</h5><p><code>Spark</code>通过分析各个RDD的依赖关系生成了<code>DAG</code>，再<strong><u>通过分析各个RDD中的分区之间的依赖关系来决定如何划分阶段</u></strong>，具体划分方法是：</p><ul><li>在<code>DAG</code>中进行反向解析，<strong><u>遇到宽依赖就断开，遇到窄依赖就把当前的<code>RDD</code>加入到当前的阶段中</u></strong>；</li><li>将窄依赖尽量划分在同一个阶段中可以实现流水线计算。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/SparkStage.png" alt="阶段的划分" /><figcaption aria-hidden="true">阶段的划分</figcaption></figure><p>这样划分的主要原因是：由于<code>shuffle</code>依赖必须等<code>RDD</code>的<code>父RDD</code>分区数据<strong><u>全部可读之后</u></strong>才能开始计算，因此<code>Spark</code>的设计是<strong><u>让父RDD将结果写在本地，完全写完之后，通知后面的RDD</u></strong>。后面的RDD则首先去读之前RDD的本地数据作为输入，然后进行运算。</p><ul><li>写入本地的原因是，后面的RDD多个分区都要去读这个信息，如果放到内存，假如出现数据丢失，后面所有的步骤全部不能进行，违背需要父RDD分区数据全部ready的原则。</li></ul><p>把一个DAG图划分成多个阶段以后，每个阶段都代表了一组<strong><u>关联的、相互之间没有<code>Shuffle</code>依赖关系的任务</u></strong>组成的任务集合。每个任务集合会被提交给任务调度器进行处理，由任务调度器将任务分发给Executor运行。</p><h5 id="rdd运行过程">3.4.5 RDD运行过程</h5><ul><li>创建RDD对象；</li><li><code>Spark Context</code>负责计算RDD之间的依赖关系，构建<code>DAG</code>；</li><li><code>DAGScheduler</code>负责把<code>DAG</code>图分解成多个阶段，每个阶段中包含了多个任务；</li><li>每个任务会被任务调度器分发给各个工作节点（ Worker Node）上的 Executor去执行。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/SparkRunProcess.png" alt="RDD运行过程" /><figcaption aria-hidden="true">RDD运行过程</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Spark&lt;/code&gt;最初的设计目标是使数据分析更快——不仅运行速度快，也要能快速、容易地编写程序。为了使程序运行更快， &lt;code&gt;Spark&lt;/code&gt;提供了内存计算，减少了迭代计算时的&lt;code&gt;IO开销&lt;/code&gt;；而为了使编写程序更为容易， &lt;code&gt;Spark&lt;/code&gt;使用简练、优雅的&lt;code&gt;Scala&lt;/code&gt;语言编写，基于&lt;code&gt;Scala&lt;/code&gt;提供了交互式的编程体验。&lt;/p&gt;</summary>
    
    
    
    <category term="大数据" scheme="https://wuyunjie.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="大数据" scheme="https://wuyunjie.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="基础" scheme="https://wuyunjie.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[大数据技术原理|第三篇 大数据处理与分析(1)]</title>
    <link href="https://wuyunjie.top/2021/08/04/Big_Data_3_process-and-analyze-1.html"/>
    <id>https://wuyunjie.top/2021/08/04/Big_Data_3_process-and-analyze-1.html</id>
    <published>2021-08-04T02:04:54.000Z</published>
    <updated>2021-08-04T02:04:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>介绍大数据处理与分析相关技术的概念与原理。</p><span id="more"></span><h3 id="mapreduce">1. MapReduce</h3><h4 id="概述">1.1 概述</h4><h5 id="简介-1">1.1.1 简介</h5><p>分布式并行程序可以运行在由大量计算机构成的集群上，从而可以充分利用集群的并行处理能力，同时通过向集群中增加新的计算节点，就可以很容易地实现集群计算能力的扩充。</p><p>在<code>MapReduce</code>中，一个存储在分布式文件系统中的大规模数据集会被切分成许多<strong><u>独立的小数据块</u></strong>，这些小数据块可以被多个<code>Map</code>任务并行处理。<code>MapReduce</code>框架会为每个<code>Map</code>任务输入一个数据子集，<code>Map</code>任务生成的结果会继续作为 <code>Reduce</code>任务的输入，最终由<code>Reduce</code>任务输出最后结果，并写入分布式文件系统。</p><p>适合用<code>MapReduce</code>来处理的数据集需要满足一个前提条件：<strong><u>待处理的数据集可以分解成许多小的数据集，而且每一个小数据集都可以完全并行地进行处理</u></strong>。</p><p><code>MapReduce</code>设计的一个理念就是<code>“计算向数据靠拢”</code>，因为移动数据需要大量的网络传输开销，所以移动计算要比移动数据更加经济。在一个集群中，只要有可能，<code>MapReduce</code>框架就会将<code>Map</code>程序就近地在<code>HDFS</code>数据所在的节点运行，即<u><strong>将计算节点和存储节点放在一起运行，从而减少了节点间的数据移动开销</strong></u>。</p><h5 id="map和reduce函数">1.1.2 Map和Reduce函数</h5><p><code>MapReduce</code>模型的核心是<code>Map</code>函数和<code>Reduce</code>函数，二者都是由应用程序开发者负责具体实现的，程序员只要关注如何实现<code>Map</code>和<code>Reduce</code>函数而不需要处理并行编程中的其他各种复杂问题，如分布式存储、工作调度、负载均衡、容错处理、网络通信等，这些问题都会由<code>MapReduce</code>框架负责处理。</p><p><code>Map</code>函数和<code>Reduce</code>函数都是以<code>&lt;key, value&gt;</code>作为输入，按一定的映射规则转换成另一个或一批<code>&lt;key, value&gt;</code>进行输出。</p><table><colgroup><col style="width: 6%" /><col style="width: 17%" /><col style="width: 17%" /><col style="width: 60%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">输入</th><th style="text-align: center;">输出</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Map</td><td style="text-align: center;"><span class="math inline">\(&lt;k_1, v_1&gt;\)</span></td><td style="text-align: center;"><span class="math inline">\(List(&lt;k_2,v_2&gt;)\)</span></td><td style="text-align: left;">1. 将小数据集进一步解析成一批<code>&lt;key, value&gt;</code>对，输入<code>Map</code>函数中进行处理；<br />2. 每一个输入的<span class="math inline">\(&lt;k_1,v_1&gt;\)</span>​会输出一批<span class="math inline">\(&lt;k_2,v_2&gt;\)</span>​，<span class="math inline">\(&lt;k_2, v_2&gt;\)</span>​是计算的中间结果</td></tr><tr class="even"><td style="text-align: center;">Reduce</td><td style="text-align: center;"><span class="math inline">\(&lt;k_2,List(v_2)&gt;\)</span></td><td style="text-align: center;"><span class="math inline">\(&lt;k_3,v_3&gt;\)</span></td><td style="text-align: left;">输入的中间结果<span class="math inline">\(&lt;k_2，List(v_2)&gt;\)</span>中的<span class="math inline">\(List(v_2)\)</span>表示是一批属于同一个<span class="math inline">\(k_2\)</span>的<span class="math inline">\(value\)</span></td></tr></tbody></table><ul><li><code>Map</code>函数的输入来自于分布式文件系统的<strong><u>文件块</u></strong>，这些文件块的格式是任意的。文件块是一系列元素的集合，这些元素也是任意类型的，<strong><u>同一个元素不能跨文件块存储</u></strong>。<code>Map</code>函数将输入的元素转换成<code>&lt;key, value&gt;</code>形式的键值对，键和值的类型也是任意的。键没有唯一性，不能作为输出的身份标识，即使是同一输入元素，也可通过一个<code>Map</code>任务生成具有相同键的多个<code>&lt;key,vaue&gt;</code>。</li><li><code>Reduce</code>函数的任务就是将输入的一系列具有相同键的键值对以某种方式组合起来，输出处理后的键值对，输出结果会合并成一个文件。用户可以指定<code>Reduce</code>任务的个数，并通知实现系统，然后主控进程通常会选择一个<code>Hash</code>函数，<code>Map</code>任务输出的每个键都会经过<code>Hash</code>函数计算，并根据哈希结果将该键值对输入相应的<code>Reduce</code>任务来处理。</li></ul><h4 id="mapreduce的工作流程">1.2 MapReduce的工作流程</h4><h5 id="工作流程概述">1.2.1 工作流程概述</h5><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/MapReduce.PNG" alt="MapReduce" /><figcaption aria-hidden="true">MapReduce</figcaption></figure><p><code>MapReduce</code>的核心思想可以用<code>“分而治之”</code>来描述，即把一个大的数据集拆分成多个小数据块在多台机器上并行处理。</p><ul><li>一个大的<code>MapReduce</code>作业，首先会被拆分成许多个<code>Map</code>任务在多台机器上并行执行，每个<code>Map</code>任务通常运行在数据存储的节点上，计算和数据就可以放在一起运行，不需要额外的数据传输开销。</li><li>当<code>Map</code>任务结束后，会生成以<code>&lt;key,vaue&gt;</code>形式表示的许多中间结果。这些中间结果会被分发到多个<code>Reduce</code>任务在多台机器上并行执行，具有相同<code>key</code>的<code>&lt;key, value&gt;</code>会被发送到同一个<code>Reduce</code>任务，<code>Reduce</code>任务会对中间结果进行汇总计算得到最后结果，并输出到分布式文件系统中。</li></ul><p>不同的<code>Map</code>任务之间不会进行通信，不同的<code>Reduce</code>任务之间也不会发生任何信息交换；用户不能显式地从一台机器向另一台机器发送消息，所有的数据交换都是通过<code>MapReduce</code>框架自身去实现的。</p><p><code>Map</code>任务的输入文件、<code>Reduce</code>任务的处理结果<strong><u>都是保存在分布式文件系统中的</u></strong>，而<code>Map</code>任务处理得到的<strong><u>中间结果则保存在本地有储中</u></strong>。只有当<code>Map</code>处理全部结束后，<code>Reduce</code>过程才能开始。</p><h5 id="mapreduce的各个执行阶段">1.2.2 MapReduce的各个执行阶段</h5><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/MapReduceStage.PNG" alt="MapReduce的各个执行阶段" /><figcaption aria-hidden="true">MapReduce的各个执行阶段</figcaption></figure><p><code>MapReduce</code>算法的执行过程。</p><ol type="1"><li><code>MapReduce</code>框架使用<code>InputFormat</code>模块做<code>Map</code>前的<strong><u>预处理</u></strong>，比如验证输入的格式是否符合输入定义；然后，将输入文件切分为逻辑上的多个<code>InputSplit</code><ul><li><strong><u><code>InputSplit</code>是<code>MapReduce</code>对文件进行处理和运算的输入单位</u></strong>，只是一个逻辑概念，每个<code>InputSplit</code>并没有对文件进行实际切割，只是记录了要处理的数据的位置和长度。</li></ul></li><li>通过<code>RecordReader（RR）</code>根据<code>Inputsplit</code>中的信息来处理<code>InputSplit</code>中的具体记录，加载数据并转换为适合<code>Map</code>任务读取的键值对，输入给Map任务。</li><li><code>Map</code>任务会根据用户自定义的映射规则，输出一系列的<code>&lt;key, value&gt;</code>作为中间结果。</li><li>对<code>Map</code>的输出进行一定的<code>分区（Portation）</code>、<code>排序（Sort）</code>、<code>合并（Combine）</code>、<code>归并（Merge）</code>等操作，得到<code>&lt;key, value-list&gt;</code>形式的中间结果，再交给对应的<code>Reduce</code>进行处理，这个过程称为<code>Shuffle</code>。从无序的<code>&lt; key, value&gt;</code>到有序的<code>&lt;key value-list&gt;</code>。</li><li><code>Reduce</code>以一系列<code>&lt;key, value-list&gt;</code>中间结果作为输入，执行用户定义的逻辑，输出结果给<code>OutputFormat</code>模块。</li><li><code>OutputFormat</code>模块验证输出目录是否已经存在以及输出结果类型是否符合配置文件中的配置类型，如果都满足，就输出<code>Reduce</code>的结果到分布式文件系统。</li></ol><h5 id="shuffle过程">1.2.3 Shuffle过程</h5><h6 id="简介-2">1. 简介</h6><p><code>Shuffle</code>，是指对<code>Map</code>输出结果进行<strong>分区、排序、合并</strong>等处理并交绐<code>Reduce</code>的过程。</p><h6 id="map端的shuffle过程">2. Map端的Shuffle过程</h6><p><code>Map</code>的输出结果首先被写入缓存，当缓存满时启动溢写操作，把缓存中的数据写人磁盘文件，并清空缓存。当启动溢写操作时，首先需要把缓存中的数据进行分区，然后对每个分区的数据进行<code>排序（Sort）</code>和<code>合并（Combine）</code>，之后再写入磁盘文件。每次溢写操作会生成一个新的磁盘文件，在<code>Map</code>任务全部结束之前，这些溢写文件会被<code>归并（Merge）</code>成一个大的磁盘文件，然后通知相应的<code>Reduce</code>任务来领取属于自己处理的数据。</p><ol type="1"><li><p>输入数据和执行<code>Map</code>任务</p><p><code>Map</code>任务的输入数据一般保存在分布式文件系统的文件块中。<code>Map</code>任务接受<code>&lt;key, vale&gt;</code>作为输入后，按一定的映射规则转换成一批<code>&lt;key, value&gt;</code>进行输出。</p></li><li><p>写入缓存</p><p>每个<code>Map</code>任务都会被分配一个缓存，<strong><u><code>Map</code>的输出结果不是立即写入磁盘，而是首先写入缓存</u></strong>。在缓存中积累一定数量的<code>Map</code>输出结果以后，再一次性批量写入磁盘。</p></li><li><p>溢写（分区、排序和合并）</p><ul><li><p><code>Map</code>任务结果占满缓存后，必须启动<code>溢写（Spill）</code>操作，把缓存中的内容一次性写入磁盘，并清空缓存。溢写的过程通常是由另外一个单独的后台线程来完成的，不会影响<code>Map</code>结果往缓存写入，为了保证<code>Map</code>结果能够不停地持续写入缓存，不受溢写过程的影响，就必须让缓存中一直有可用的空间，不能等到全部占满才启动溢写过程，一般会设置一个<strong><u>溢写比例</u></strong>。</p></li><li><p>在溢写到磁盘之前，缓存中的数据首先会被<code>分区（Partition）</code>。<code>MapReduce</code>通过<code>Partitioner</code>接口对这些键值对进行分区，默认采用的分区方式是采用<code>Hash</code>函数对<code>key</code>进行哈希后再用<code>Reduce</code>任务的数量进行取模。 也可以通过重载<code>Partitioner</code>接口来自定义分区方式。</p></li><li><p>对于每个分区内的所有键值对，后台线程会根据<code>key</code>对它们进行<code>内存排序（Sort）</code>，排序是<code>MapReduce</code>的<strong>默认操作</strong>。</p></li><li><p>排序结束后，有一个可选的<code>合并（Combine）</code>操作。如果未定义<code>Combiner</code>函数，就不用进行合并操作。如果事先定义了<code>Combiner</code>函数，则这个时候会执行合并操作，从而减少需要溢写到磁盘的数据量。<code>“合并”</code>，是指将那些具有相同<code>key</code>的<code>&lt;key, value&gt;</code>的<code>value</code>加起来，减少了键值对的数量。</p></li></ul><p>经过分区、排序以及可能发生的合并操作之后，这些缓存中的键值对就可以被写入磁盘，并清空缓存。</p></li><li><p>文件归并</p><p>在<code>Map</code>任务全部结束之前，系统会对所有溢写文件中的数据进行<code>归并（Merge）</code>，生成一个大的溢写文件，这个大的溢写文件中的所有键值对也是经过分区和排序的。所谓<code>“归并”</code>，是指对于具有相同<code>key</code>的键值对会被归并成一个新的键值对。即对于若干个具有相同<code>key</code>的键值对<code>&lt;k,v1&gt;，&lt;k,v2&gt;...&lt;k,vn&gt;</code>会被归并成一个新的键值对<code>&lt;k, &lt;v1, v2, ..., vn&gt;&gt;</code>。</p><p>进行文件归并时，如果磁盘中已经生成的溢写文件的数量超过参数<code>min.num.spills. for.combine</code>的值时，可以再次运行<code>Combiner</code>，对数据进行合并操作，从而减少写入磁盘的数据量。</p></li></ol><p><code>JobTracker</code>会一直监测<code>Map</code>任务的执行，当监测到一个<code>Map</code>任务完成后，就会立即通知相关的<code>Reduce</code>任务来<code>“领取”</code>数据，然后开始<code>Reduce</code>端的<code>Shuffle</code>过程。</p><h6 id="reduce端的shuffle过程">3. Reduce端的Shuffle过程</h6><ol type="1"><li><p><code>“领取”</code>数据</p><p><code>Map</code>端的<code>Shuffle</code>过程结束后，所有<code>Map</code>输出结果都保存在<code>Map</code>机器的本地磁盘上，<code>Reduce</code>任务需要把这些数据<strong><u><code>“领取”（Fetch）</code>回来存放到自己所在机器的本地磁盘上</u></strong>。</p><ul><li>每个<code>Reduce</code>任务会不断地通过<code>RPC</code>向<code>JobTracker</code>询问Map任务是否已经完成；</li><li><code>JobTracker</code>监测到一个<code>Map</code>任务完成后，就会通知相关的<code>Reduce</code>任务来<code>“领取”</code>数据；</li><li>一旦一个<code>Reduce</code>任务收到<code>JobTracker</code>的通知，它就会到该<code>Map</code>任务所在机器上把属于自己处理的分区数据领取到本地磁盘中。</li></ul></li><li><p>归并数据</p><p>从<code>Map</code>端领回的数据会<strong><u>首先被存放在<code>Reduce</code>任务所在机器的缓存中</u></strong>，如果缓存被占满，就会像<code>Map</code>端一样被溢写到磁盘中。由于在<code>Shuffle</code>阶段<code>Reduce</code>任务还没有真正开始执行，可以把内存的大部分空间分配给<code>Shuffle</code>过程作为缓存。</p><p>当溢写过程启动时，具有相同<code>key</code>的键值对会被<code>归并（Merge）</code>，如果用户定义了<code>Combiner</code>，则归并后的数据还可以执行合并操作，减少写入磁盘的数据量。当所有的<code>Map</code>端数据都已经被领回时，多个溢写文件会被归并成一个大文件，归并时还会对键值对进行排序，使得最终大文件中的键值对都是有序的。</p><p>在数据很少的情形下，缓存可以存储所有数据，可以直接在内存中执行归并操作，然后直接输出给<code>Reduce</code>任务。</p></li><li><p>把数据输入给<code>Reduce</code>任务</p><p>磁盘中经过多轮归并后得到的若干个大文件，直接输入给<code>Reduce</code>任务，这样可以减少磁盘读写开销。<code>Reduce</code>任务会执行<code>Reduce</code>函数中定义的各种映射，输出最终结果，并保存到分布式文件系统中。</p></li></ol><h4 id="mapreduce体系结构">1.3 MapReduce体系结构</h4><p><code>MapReduce</code>体系结构主要由四个部分组成，分别是：<code>Client</code>、<code>JobTracker</code>、<code>TaskTracker</code>以及<code>Task</code></p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/MapReduceStructure.PNG" alt="MapReduce体系结构" /><figcaption aria-hidden="true">MapReduce体系结构</figcaption></figure><ul><li><code>Client</code>。用户编写的<code>MapReduce</code>程序通过<code>Client</code>提交到<code>JobTracker</code>端；用户可通过<code>Client</code>提供的一些接口查看作业运行状态</li><li><code>JobTracker</code>。<code>JobTracker</code>负责资源监控和作业调度；<code>JobTracker</code> 监控所有<code>TaskTracker</code>与<code>Job</code>的健康状况，一旦发现失败，就将相应的任务转移到其他节点；<code>JobTracker</code> 会跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器（<code>TaskScheduler</code>），而调度器会在资源出现空闲时，选择合适的任务去使用这些资源。</li><li><code>TaskTracker</code>。<code>TaskTracker</code>会周期性地通过“心跳”将本节点上资源的使用情况和任务的运行进度汇报给<code>JobTracker</code>，同时接收<code>JobTracker</code> 发送过来的命令并执行相应的操作；<code>TaskTracker</code> 使用<code>“slot”</code>等量划分本节点上的资源量。一个<code>Task</code> 获取到一个<code>slot</code> 后才有机会运行，而<code>Hadoop</code>调度器的作用就是将各个<code>TaskTracker</code>上的空闲<code>slot</code>分配给<code>Task</code>使用。<code>slot</code> 分为<code>Map slot</code> 和<code>Reduce slot</code> 两种，分别供<code>Map Task</code> 和<code>Reduce Task</code> 使用。</li><li><code>Task</code>。<code>Task</code> 分为<code>Map Task</code> 和<code>Reduce Task</code> 两种，均由<code>TaskTracker</code> 启动。</li></ul><h4 id="mapreduce-具体应用">1.4 MapReduce 具体应用</h4><h5 id="mapreduce在关系代数中应用">1.4.1 MapReduce在关系代数中应用</h5><h6 id="关系的选择运算">1. 关系的选择运算</h6><p>对于关系的选择运算，只需要<code>Map</code>过程就能实现，对于关系<code>R</code>中的每个元组<code>t</code>，检测是否是满足条件的所需元组，如果满足条件，则输出键值对<code>&lt;t, t&gt;</code>，即键和值都是<code>t</code>。<code>Reduce</code>函数对输入不作任何变换就直接输出。</p><h6 id="关系的投影运算">2. 关系的投影运算</h6><p>假设对关系<code>R</code>投影后的属性集为<code>S</code>，在<code>Map</code>函数中，对于<code>R</code>中的每个元组<code>t</code>，剔除<code>t</code>中不属于<code>S</code>的字段得到元组<code>t'</code>，输出键值对<code>&lt;t', t'&gt;</code>。</p><p>对于<code>Map</code>任务产生的每个键<code>t'</code>，可能存在一个或多个键值对<code>&lt;t', t'&gt;</code>，通过<code>Reduce</code>函数来剔除冗余，把属性值完全相同的元组合并。</p><h6 id="关系的并交差运算">3. 关系的并、交、差运算</h6><ul><li><p>对两个关系求<strong>并集</strong>时，<code>Map</code>任务将两个关系的元组转换成键值对<code>&lt;t, t&gt;</code>，<code>Reduce</code>任务则是剔除冗余数据的过程。</p></li><li><p>对两个关系求<strong>交集</strong>时，使用与并集相同的<code>Map</code>过程，在<code>Reduce</code>过程中，如果键<code>t</code>有两个相同值与它关联，则输出一个元组<code>&lt;t, t&gt;</code>，如果与键关联的只有一个值，则输出空值（<code>NULL</code>）。</p></li><li><p>对两个关系求<strong>差</strong>时，<code>Map</code>过程产生的<strong>键值</strong>对不仅要记录元组的信息，还要记录该元组来自于哪个关系（<code>R</code>或<code>S</code>），<code>Reduce</code>过程中按键值相同的<code>t</code>合并后，与键<code>t</code>相关联的值如果只有<code>R</code>（说明该元组只属于<code>R</code>，不属于<code>S</code>），就输出元组，其他情况均输出空值。</p></li></ul><h6 id="关系的自然连接运算">4. 关系的自然连接运算</h6><p>在<code>MapReduce</code>环境下执行两个关系的连接操作的方法如下：</p><ul><li>假设关系<code>R（A,B）</code>和<code>S（B,C）</code>都存储在一个文件中，为了连接这些关系，必须把来自每个关系的各个元组都和一个键关联，这个键就是属性<code>B</code>的值。</li><li>使用<code>Map</code>过程把来自<code>R</code>的每个元组<code>&lt;a, b&gt;</code>转换成一个键值对<code>&lt;b, &lt;R, a&gt;&gt;</code>。这里把关系<code>R</code>包含到值中，使得可以在<code>Reduce</code>阶段只把来自<code>R</code>的元组和来自<code>S</code>的元组进行匹配。</li><li>使用<code>Map</code>过程把来自<code>S</code>的每个元组<code>&lt;b, c&gt;</code>转换成一个键值对<code>&lt;b, &lt;S, c&gt;&gt;</code>。</li><li><code>Reduce</code>进程把来自关系<code>R</code>和<code>S</code>的具有共同属性<code>B</code>值的元组进行合并。</li></ul><h5 id="分组与聚合运算">1.4.2 分组与聚合运算</h5><ul><li><code>Map</code>过程，选择关系的某一字段（也可以是某些属性构成的属性表）的值作为键，其他字段的值作为与键相关联的值。</li><li><code>Reduce</code>过程，对相同键相关联的值施加某种聚合运算，如<code>SUM（求和）</code>、 <code>COUNT（计数）</code>、<code>AVG（求平均值）</code>、 <code>MIN</code>和<code>MAX</code>（求最小最大值）等，输出则为<code>&lt;键，聚合运算结果&gt;</code>。</li></ul><h5 id="矩阵-向量乘法">1.4.3 矩阵-向量乘法</h5><p>假定一个<span class="math inline">\(n\)</span>维向量<span class="math inline">\(V\)</span>，其第<span class="math inline">\(j\)</span>个元素记为<span class="math inline">\(v_j\)</span>，假定一个<span class="math inline">\(n \times n\)</span>的矩阵<span class="math inline">\(M\)</span>，其第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列元素记为<span class="math inline">\(m_{ij}\)</span>，则矩阵<span class="math inline">\(M\)</span>和向量<span class="math inline">\(V\)</span>的乘积是一个<span class="math inline">\(n\)</span>维向量<span class="math inline">\(X\)</span>，其第<span class="math inline">\(i\)</span>个元素<span class="math inline">\(x_i = \sum^n_{j=1}{m_{ij}v_j}\)</span>。</p><p>矩阵<span class="math inline">\(M\)</span>和向量<span class="math inline">\(V\)</span>各自在分布式文件系统中存成一个文件。假定可以获得矩阵元素的行列下标，计算矩阵和向量乘法的<code>MapReduce</code>函数可以设计为：</p><ul><li><code>Map</code>函数。每个<code>Map</code>任务将整个向量<span class="math inline">\(V\)</span>​和矩阵<span class="math inline">\(M\)</span>​的一个文件块作为输人。对每个矩阵元素<span class="math inline">\(m_{ij}\)</span>​，<code>Map</code>任务会产生键值对<span class="math inline">\(&lt;i，m_{ij}v_j&gt;\)</span>​。计算<span class="math inline">\(x_i\)</span>​的所有<span class="math inline">\(n\)</span>​个求和项<span class="math inline">\(m_{ij}v_j\)</span>​的键都相同，即都是<span class="math inline">\(i\)</span>​。</li><li><code>Reduce</code>函数。<code>Reduce</code>任务将所有与给定键<span class="math inline">\(i\)</span>关联的值相加即可得到<span class="math inline">\(&lt;i, x_i&gt;\)</span>。</li></ul><h5 id="矩阵乘法">1.4.4 矩阵乘法</h5><p>矩阵<span class="math inline">\(M\)</span>第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列元素记为<span class="math inline">\(m_{ij}\)</span>，矩阵<span class="math inline">\(N\)</span>第<span class="math inline">\(j\)</span>行第<span class="math inline">\(k\)</span>列元素记为<span class="math inline">\(n_{jk}\)</span>，则矩阵<span class="math inline">\(P=M \times N\)</span>，其第<span class="math inline">\(i\)</span>行第<span class="math inline">\(k\)</span>列元素为<span class="math inline">\(p_{ik} = \sum^n_{j=1}{m_{ij}n_{jk}}\)</span>。</p><p>可以把矩阵看成一个带有3个属性的关系：行下标、列下标和值。因此，矩阵<code>M</code>可以看成关系<code>M</code>，记为<code>M(I, J, V)</code>，元组为<span class="math inline">\(&lt;i, j, m_{ij}&gt;\)</span>，矩阵<code>N</code>可以看作关系<code>N</code>，记为<code>N(J, K, W)</code>，元组为<span class="math inline">\(&lt;j, k, n_{jk}&gt;\)</span>。</p><p>矩阵乘法可以看作是一个自然连接运算再加上分组聚合运算。关系<code>M</code>和<code>N</code>根据公共属性<code>J</code>将每个元组连接得到元组<span class="math inline">\(&lt;i,j,k,v,w&gt;\)</span>​​，这个五字段元组代表了两个矩阵的元素对<span class="math inline">\(&lt;m_{ij},n_{jk}&gt;\)</span>​​，对矩阵元素进行求积运算后可以得到四字段元组<span class="math inline">\(&lt;i,j,k,ν \times w&gt;\)</span>​​​，然后可以进行分组聚合运算。矩阵乘法可以通过两个<code>MapReduce</code>运算的串联实现：</p><h6 id="自然连接阶段">1. 自然连接阶段</h6><ul><li><code>Map</code>函数：对每个矩阵元素<span class="math inline">\(m_{ij}\)</span>产生一个键值对<span class="math inline">\(&lt;j, &lt;M, i, m_{ij}&gt;&gt;\)</span>，对每个矩阵元素<span class="math inline">\(n_{jk}\)</span>产生一个键值对<span class="math inline">\(&lt;j，&lt;N,k,n_{jk}&gt;&gt;\)</span>。</li><li><code>Reduce</code>函数：对每个相同键<span class="math inline">\(j\)</span>，输出所有满足形式<span class="math inline">\(&lt;j, &lt;i, k, m_{ij}n_{jk}&gt;&gt;\)</span>的元组。</li></ul><h6 id="分组聚合阶段">2. 分组聚合阶段</h6><ul><li><code>Map</code>函数：对自然连接阶段产生的键值对<span class="math inline">\(&lt;j, &lt;&lt;i_1, k_1, v_1&gt;,..., &lt;i_p, k_p, v_p&gt;&gt;&gt;\)</span>，产生键值对<span class="math inline">\(&lt;&lt;&lt;i_1, l_1&gt;, v1&gt;,..., &lt;&lt;i_p,k_p&gt;,v_p&gt;&gt;\)</span>；</li><li><code>Reduce</code>函数：对每个键<span class="math inline">\(&lt;i,k&gt;\)</span>​，计算与此键关联的所有值的和，结果记为<span class="math inline">\(&lt;&lt;i,k&gt;,v&gt;\)</span>​。</li></ul><h3 id="hadoop的优化与发展">2. Hadoop的优化与发展</h3><h4 id="hdfs-ha">2.1 HDFS HA</h4><p>对于分布式文件系统<code>HDFS</code>而言，名称节点（<code>Name Node</code>）是系统的核心节点，存储了各类元数据信息，并负责管理文件系统的命名空间和客户端对文件的访问。</p><p>在<code>HDFS1.0</code>中，只存在一个名称节点，一旦这个唯一的名称节点发生故障，就会导致整个集群变得不可用，这就是常说的<code>“单点故障问题”</code>。虽然<code>HDFS1.0</code>中存在一个<code>“第二名称节点（Secondary Name Node）</code>，但是第二名称节点并不是名称节点的备用节点，其<strong><u>主要功能是周期性地从名称节点获取命名空间镜像文件（Fslmage）和修改日志（EditLog），进行合并后再发送给名称节点，替换掉原来的Fslmage，以防止日志文件EditLog过大，导致名称节点失败恢复时消耗过多时间</u></strong>。</p><p>第二名称节点无法提供<code>“热备份”</code>功能，即在名称节点发生故障的时候，系统无法实时切换到第二名称节点立即对外提供服务，仍然需要进行停机恢复，因此<code>HDFS1.0</code>的设计是存在单点故障问题的。为了解决单点故障问题，<code>HDFS2.0</code>采用了<code>HA（High Availability）</code>架构。在一个典型的<code>HA</code>集群中，一般设置两个名称节点，其中一个名称节点处于<code>“活跃（Active）”</code>状态，另一个处于<code>“待命（Standby）”</code>状态。</p><ul><li>处于活跃状态的名称节点负责对外处理所有客户端的请求；</li><li>处于待命状态的名称节点则作为备用节点，保存了足够多的系统元数据，当名称节点出现故障时提供快速恢复能力。处于待命状态的名称节点提供了<code>“热备份”</code>，一旦活跃名称节点出现故障，就可以立即切换到待命名称节点，不会影响到系统的正常对外服务。</li></ul><p>活跃名称节点的状态信息必须实时同步到待命名称节点。两种名称节点的状态同步，可以借助于一个共享存储系统来实现，比如<code>NFS（Network File System）</code>、<code>QJM（Quorum Journal Manager）</code>或者<code>Zookeeper</code>。</p><h4 id="hdfs-联邦">2.2 HDFS 联邦</h4><p><code>HDFS1.0</code>采用单名称节点的设计，不仅会带来单点故障问题，还存在<strong>可扩展性</strong>、<strong>性能</strong>和<strong>隔离性</strong>等问题。</p><p><code>HDFS联邦</code>可以很好地解决上述三个方面的问题。在HDFS联邦中，设计了多个相互独立的名称节点，使得HDFS的命名服务能够水平扩展，这些名称节点分别进行各自命名空间和块的管理，相互之间是联邦关系，不需要彼此协调。<code>HDFS联邦</code>并不是真正的分布式设计，但是采用这种简单的<code>“联合”</code>设计方式。</p><p>在<code>HDFS联邦</code>中，所有名称节点会共享底层的数据节点存储资源，每个数据节点要向集群中所有的名称节点注册，并周期性地向名称节点发送“心跳”和块信息，报告自己的状态，同时也会处理来自名称节点的指令。<code>HDFS联邦</code>拥有多个独立的命名空间，每一个命名空间管理属于自己的一组块，这些属于同一个命名空间的块构成一个<code>“块池”（Block pool）</code>。每个数据节点会为多个块池提供块的存储。<strong><u>数据节点是一个物理概念，而块池则属于逻辑概念</u></strong>，一个块池是一组块的逻辑集合，块池中的各个块实际上是存储在各个不同的数据节点中的。因此，HDFS联邦中的一个名称节点失效，也不会影响到与它相关的数据节点继续为其他名称节点提供服务。</p><p>对于<code>HDFS</code>联邦中的多个命名空间，可以采用<code>客户端挂载表（Client Side Mount Table）</code>方式进行数据共享和访问，客户可以<strong><u>访问不同的挂载点来访问不同的子命名空间</u></strong>。这就是<code>HDFS联邦</code>中命名空间管理的基本原理，即把各个命名空间挂载到全局<code>“挂载表”（Mount-table）</code>中，实现数据全局共享；同样地，命名空间挂载到个人的挂载表中，就成为应用程序可见的命名空间。</p><p>需要注意的是，<code>HDFS联邦</code><u><strong>并不能解决单点故障问题，每个名称节点都存在单点故障问题</strong></u>，需要为每个名称节点部署一个后备名称节点，以应对名称节点宕机后对业务产生的影响。</p><h4 id="新一代资源管理调度框架yarn">2.3 新一代资源管理调度框架YARN</h4><h5 id="yarn设计思路">2.3.1 <code>YARN</code>设计思路</h5><p><code>YARN（ Yet Another Resource Negotiator）</code>架构设计基本思路就是<strong>“放权”</strong>，把原<code>JobTracker</code>三大功能（资源管理、任务调度和任务监控）进行拆分，分别交给不同的新组件去处理。重新设计后得到的<code>YARN</code>包括<code>ResourceManager</code>、 <code>Application Master</code>和<code>NodeManager</code>：</p><ul><li><code>ResourceManager</code>负责资源管理</li><li><code>ApplicationMaster</code>负责任务调度和监控</li><li><code>NodeManager</code>负责执行原<code>TaskTracker</code>的任务。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/YARNDesign.PNG" alt="YARN设计思路" /><figcaption aria-hidden="true"><code>YARN</code>设计思路</figcaption></figure><ul><li><p>在<code>Hadoop1.0</code>中，其核心子项目<code>MapReduce1.0</code>既是一个计算框架，也是一个资源管理调度框架。</p></li><li><p>到了<code>Hadoop2.0</code>以后，<code>MapReduce2.0</code>中的资源管理调度功能被单独分离出来形成<code>YARN</code>，它是一个纯粹的资源管理调度框架，而不是一个计算框架；被剥离了资源管理调度功能的<code>MapReduce</code>框架就变成了<code>MapReduce2.0</code>，它是运行在<code>YARN</code>之上的一个纯粹的计算框架，不再自己负责资源调度管理服务，而是由<code>YARN</code>为其提供资源管理调度服务。</p></li></ul><h5 id="yarn体系结构">2.3.2 YARN体系结构</h5><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/YARNStructure.PNG" alt="YARN体系结构" /><figcaption aria-hidden="true">YARN体系结构</figcaption></figure><h6 id="resource-manager">1. Resource Manager</h6><p><code>ResourceManager（RM）</code>是一个全局的资源管理器，负责整个系统的资源管理和分配，主要包括两个组件：</p><ul><li><code>调度器（ Scheduler）</code>。主要负责资源管理和分配。调度器接收来自<code>ApplicationMaster</code>的应用程序资源请求，并根据容量、队列等限制条件，把集群中的资源以<code>“容器”</code>的形式分配给提出申请的应用程序，容器的选择通常会考虑应用程序所要处理的数据的位置，进行就近选择，实现<strong>“计算向数据靠拢”</strong>。</li><li><code>应用程序管理器（Applications Manager）</code>。应用程序管理器负责系统中所有应用程序的管理工作，主要包括应用程序提交、与调度器协商资源以启动<code>ApplicationMaster</code>、监控<code>ApplicationMaster</code>运行状态并在失败时重新启动等。</li></ul><p>在<code>YARN</code>中是以<code>容器（Container）</code>作为动态资源分配单位，每个容器中都封装了一定数量的CPU、内存、磁盘等资源，从而限定每个应用程序可以使用的资源量。同时，在<code>YARN</code>中调度器被设计成是一个可插拔的组件，<code>YARN</code>不仅自身提供了许多种直接可用的调度器，也允许用户根据自己的需求重新设计调度器。</p><p>主要功能包括：</p><ul><li>处理客户端请求</li><li>启动监控<code>ApplicationMaster</code></li><li>监控<code>NodeManager</code></li><li>资源分配与调度</li></ul><h6 id="applicationmaster">2. ApplicationMaster</h6><p>在Hadoop平台上，用户的应用程序是以<code>作业（Job）</code>的形式提交的，然后一个作业会被分解成多个任务进行分布式执行。<code>ResourceManager</code>接收用户提交的作业，按照作业的上下文信息以及从<code>NodeManager</code>收集来的容器状态信息，启动调度过程，为用户作业启动一个<code>ApplicationMaster</code>。<code>ApplicationMaster</code>的主要功能是：</p><ul><li>当用户作业提交时， <code>ApplicationMaster</code>与<code>ResourceManager</code>协商获取资源，<code>ResourceManager</code>会以容器的形式为<code>ApplicationMaster</code>分配资源；</li><li>把获得的资源进一步分配给内部的各个任务，实现资源的<code>“二次分配”</code>；</li><li>与<code>NodeManager</code>保持交互通信进行应用程序的启动、运行监控和停止，监控申请到的资源的使用情况，对所有任务的执行进度和状态进行监控，并在任务发生失败时执行失败恢复；</li><li>定时向<code>ResourceManager</code>发送“心跳”消息，报告资源的使用情况和应用的进度信息；</li><li>当作业完成时，<code>ApplicationMaster</code>向<code>ResourceManager</code>注销容器，执行周期完成。</li></ul><h6 id="nodemanager">3. NodeManager</h6><p><code>NodeManager</code>是驻留在一个<code>YARN</code>集群中的每个节点上的代理，主要负责：</p><ul><li>容器生命周期管理，监控每个容器的资源使用情况，跟踪节点健康状况；</li><li>以“心跳”的方式与<code>ResourceManager</code>保持通信，向<code>ResourceManager</code> 汇报作业的资源使用情况和每个容器的运行状态；</li><li>接收来自<code>ApplicationMaster</code>的启动/停止容器的各种请求。</li></ul><p><code>NodeManager</code>主要负责管理抽象的容器，只处理与容器相关的事情，而不具体负责每个任务自身状态的管理。</p><p><code>YARN</code>的各个组件是和<code>Hadoop</code>集群中的其他组件进行统一部署的。</p><ul><li><code>YARN</code>的<code>ResourceManager</code>组件和<code>HDFS</code>的<code>名称节点（NameNode）</code>部署在一个节点上；</li><li><code>YARN</code>的<code>ApplicationMaster</code>及<code>NodeManager</code>是和HDFS的<code>数据节点（DataNode）</code>部署在一起的；</li><li><code>YARN</code>中的容器代表了CPU、内存、网络等计算资源，也是和HDFS的数据节点一起的。</li></ul><h5 id="yarn工作流程">2.3.3 YARN工作流程</h5><p>在<code>YARN</code>框架中执行一个<code>MapReduce</code>程序时，从提交到完成需要经历如下8个步骤：</p><ol type="1"><li>用户编写客户端应用程序，向<code>YARN</code>提交应用程序，提交的内容包括<code>ApplicationMaster</code>程序、启动 <code>ApplicationMaster</code>的命令、用户程序等。</li><li><code>YARN</code>中的<code>ResourceManager</code>负责接收和处理来自客户端的请求。接到客户端应用程序请求后， <code>ResourceManager</code>里面的调度器会为应用程序分配一个容器。<code>ResourceManager</code>的应用程序管理器会与该容器所在的<code>NodeManager</code>通信，为该应用程序在该容器中启动一个<code>ApplicationMaster</code>。</li><li><code>ApplicationMaster</code>被创建后会首先向<code>ResourceManager</code>注册，从而使得用户可以通过<code>ResourceManager</code>来直接查看应用程序的运行状态。</li><li><code>ApplicationMaster</code>用轮询的方式通过<code>RPC</code>协议向<code>ResourceManager</code>申请资源。</li><li><code>ResourceManager</code>以<code>“容器”</code>的形式向提出申请的<code>ApplicationMaster</code>分配资源，一旦<code>ApplicationMaster</code>申请到资源后，就会与该容器所在的<code>NodeManager</code>进行通信，要求它启动任务。</li><li>当<code>ApplicationMaster</code>要求容器启动任务时，它会为任务设置好运行环境（包括环境变量、 JAR包、二进制程序等），然后将任务启动命令写到一个脚本中，最后通过在容器中运行该脚本来启动任务。</li><li>各个任务通过某个RRC协议向<code>ApplicationMaster</code>汇报自己的状态和进度，让<code>ApplicationMaster</code>可以随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。</li><li>应用程序运行完成后，<code>ApplicationMaster</code>向<code>ResourceManager</code>的应用程序管理器注销并关闭自己。若<code>ApplicationMaster</code>因故失败，<code>ResourceManager</code>中的应用程序管理器会监测到失败的情形，然后将其重新启动，直到所有的任务执行完毕。</li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/YARNWorkFlow.PNG" alt="YARN工作流程" /><figcaption aria-hidden="true">YARN工作流程</figcaption></figure><h5 id="总结">2.3.4 总结</h5><p><code>YARN</code>的目标是实现<code>“一个集群多个框架”</code>，即在一个集群上部署一个统一的资源调度管理框架<code>YARN</code>，在<code>YARN</code>之上可以部署其他各种计算框架，比如 Mapreduce、Tez、 HBase、 Storm、Giraph、Spark、OpenMPI等，由<code>YARN</code>为这些计算框架提供统一的资源调度管理服务，并且能够根据各种计算框架的负载需求，调整各自占用的资源，实现集群资源共享和资源弹性收缩。</p><ul><li>可以实现一个集群上的不同应用负载混搭，有效提高了集群的利用率；</li><li>不同计算框架可以共享底层存储，在一个集群上集成多个数据集，使用多个计算框架来访问这些数据集，从而避免了数据集跨集群移动</li><li>这种部署方式也大大降低了企业运维成本</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;介绍大数据处理与分析相关技术的概念与原理。&lt;/p&gt;</summary>
    
    
    
    <category term="大数据" scheme="https://wuyunjie.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="大数据" scheme="https://wuyunjie.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="基础" scheme="https://wuyunjie.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[大数据技术原理|第二篇 大数据存储与管理(2)]</title>
    <link href="https://wuyunjie.top/2021/08/03/Big_Data_2_store-and-manage-2.html"/>
    <id>https://wuyunjie.top/2021/08/03/Big_Data_2_store-and-manage-2.html</id>
    <published>2021-08-03T07:02:28.000Z</published>
    <updated>2021-08-03T07:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>学习<code>NoSQL数据库</code>和<code>云数据库</code>。</p><span id="more"></span><h3 id="nosql数据库">1. NoSQL数据库</h3><h4 id="简介-1">1.1 简介</h4><p><code>NoSQL</code>是一种对非关系型数据库的统称，它所采用的数据模型并非传统关系数据库的关系模型，而是类似<code>键/值</code>、<code>列族</code>、<code>文档</code>等非关系模型。<code>NoSQL</code>数据库没有固定的表结构，通常也不存在连接操作，也没有严格遵守<code>ACID</code>约束（原子性、一致性、隔离性和持续性）。<code>NoSQL</code>数据库<u>支持MapReduce风格的编程，可以较好地应用于大数据管理</u>。通常<code>NoSQL</code>数据库具有以下3个特点：</p><ol type="1"><li>灵活的可扩展性</li><li>灵活的数据模型</li><li>与云计算紧密融合</li></ol><h4 id="nosql的四大类型">1.2 NoSQL的四大类型</h4><h5 id="键值数据库">1.2.1 键值数据库</h5><p><code>键值数据库（Key-Value Database）</code>会使用一个哈希表，这个表中有一个特定的<code>Key</code>和一个指针指向特定的<code>Value</code>。<code>Key</code>可以用来定位<code>Value</code>，即存储和检索具体的<code>Value</code>。</p><p>键值数据库可以进一步划分：</p><ul><li><code>内存键值数据库</code>，把数据保存在内存，如Memcached和 Redis；</li><li><code>持久化（ Persistent）键值数据库</code>，把数据保存在磁盘，如BerkeleyDB、 Voldmort和Riak。</li></ul><h5 id="列族数据库">1.2.2 列族数据库</h5><p>列族数据库一般采用列族数据模型，数据库由多个行构成，每行数据包含多个列族，不同的行可以具有不同数量的列族，属于同一列族的数据会被存放在一起。</p><h5 id="文档数据库">1.2.3 文档数据库</h5><p>文档数据库中，<strong>文档</strong>是数据库的最小单位。虽然每一种文档数据库的部署都有所不同，但是大都假定文档以某种标准化格式封装并对数据进行加密，同时用多种格式进行解码，包括XML、YAML、JSON和BSON等，或者也可以使用二进制格式（如PDF、微软 Office文档等）。</p><p>文档数据库通过键来定位一个文档，因此可以看成是键值数据库的一个衍生品，而且前者比后者具有更高的查询效率。</p><h5 id="图数据库">1.2.4 图数据库</h5><p>图数据库以图论为基础，图用来表示一个对象集合，包括顶点以及连接顶点的边。图数据库使用图作为数据模型来存储数据，完全不同于键值、列族和文档数据模型，可以高效地存储不同顶点之间的关系。图数据库专门用于处理具有高度相互关联关系的数据，可以高效地处理实体之间的关系，比较适合于社交网络、模式识别、依赖分析、推荐系统以及路径寻找等问题。</p><h4 id="nosql的三大基石">1.3 NoSQL的三大基石</h4><p>NoSQL的三大基石包括<code>CAP</code>、<code>BASE</code>和<code>最终一致性</code>。</p><h5 id="cap">1.3.1 CAP</h5><p><code>CAP</code>指：</p><ul><li>C（<code>Consistency</code>）：一致性。指何一个读操作总是能够读到之前完成的写操作的结果，即多点的数据是一致的。</li><li>A（ <code>Availability</code>）：可用性。指快速获取数据，可以在确定的时间内返回操作结果。</li><li>·P（<code>Tolerance of Network Partition</code>）：分区容忍性。指当出现网络分区的情况时，分离的系统也能够正常运行。</li></ul><p>CAP理论指出，<strong><u>一个分布式系统不可能同时满足一致性、可用性和分区容忍性这3个需求，最多只能同时满足其中2个</u></strong>。</p><ul><li>如果追求一致性，那么就要牺牲可用性，需要处理因为系统不可用而导致的写操作失败的情况；</li><li>如果追求可用性，那么就要预估到可能发生数据不一致的情况，比如，系统的读操作可能不能精确地读取到写操作写入的最新值。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/CAP.PNG" alt="CAP理论" /><figcaption aria-hidden="true">CAP理论</figcaption></figure><ol type="1"><li><code>CA</code>。强调<code>一致性（C）</code>和<code>可用性（A）</code>，放弃<code>分区容忍性（P）</code>，最简单的做法是把所有与事务相关的内容都放到同一台机器上。传统的关系数据库都采用了这种设计原则，因此扩展性都比较差。</li><li><code>CP</code>。强调<code>一致性（C）</code>和<code>分区容忍性（P）</code>，放弃<code>可用性（A）</code>，当出现网络分区的情况时，受影响的服务需要等待数据一致，因此在等待期间就无法对外提供服务。<code>Neo4J</code>、 <code>BigTable</code>和<code>HBase</code>等<code>NoSQL</code>数据库都采用了<code>CP</code>设计原则。</li><li><code>AP</code>。强调<code>可用性（A）</code>和<code>分区容忍性（P）</code>，放弃<code>一致性（C）</code>，允许系统返回不一致的数据。对于<code>Web2.0</code>网站而言，可用性与分区容忍性优先级要高于数据一致性，网站一般会尽量朝着<code>AP</code>的方向设计。在采用<code>AP</code>设计时，也可以不完全放弃一致性，转而采用<strong><u>最终一致性</u></strong>。</li></ol><h5 id="base">1.3.2 BASE</h5><p>一个数据库事务具有<code>ACID</code>四性：</p><ul><li><code>A（Atomicity）</code>：原子性。指事务必须是原子工作单元，对于其数据修改，要么全都执行，要么全都不执行。</li><li><code>C（Consistency）</code>：一致性。指事务在完成时，必须使所有的数据都保持一致状态。</li><li><code>I（Isolation）</code>：隔离性。指由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</li><li><code>D（Durability）</code>：持久性。指事务完成之后，对于系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持。</li></ul><p><code>BASE</code>牺牲了<strong>高一致性</strong>，从而获得<strong>可用性</strong>或<strong>可靠性</strong>。<code>BASE</code>（<code>Basically Availble, Soft-state, Eventual consistency</code>）的基本含义是：</p><ul><li><code>基本可用（Basically Availble）</code>：基本可用是指一个分布式系统的一部分发生问题变得不可用时，其他部分仍然可以正常使用也就是允许分区失败的情形出现。</li><li><code>软状态（Soft-state）</code>：指状态可以有一段时间不同步，具有一定的滞后性。当经过短暂延迟后，状态最终一致。</li><li><code>最终一致性（Eventual consistency）</code> ：一致性的类型包括<strong>强一致性</strong>和<strong>弱一致性</strong>，二者的主要区别在于<strong><u>高并发的数据访问操作下，后续操作是否能够获取最新的数据</u></strong>。<ul><li>强一致性，指当执行完一次更新操作后，后续的其他读操作就可以保证读到更新后的最新数据；</li><li>弱一致性，指不能保证后续访问读到的都是更新后的最新数据。</li><li>最终一致性是弱一致性的一种特例，允许后续的访问操作可以暂时读不到更新后的数据，但是经过一段时间之后，必须最终读到更新后的数据。</li></ul></li></ul><h5 id="最终一致性">1.3.3 最终一致性</h5><p>最终一致性根据更新数据后各进程访问到数据的时间和方式的不同，又可以进行如下区分。</p><ul><li><strong>因果一致性</strong>。如果进程<code>A</code>通知进程<code>B</code>已经更新了一个数据项，那么进程<code>B</code>的后续访问将获得进程<code>A</code>写入的最新值。而与进程<code>A</code>无因果关系的进程<code>C</code>的访问，仍然遵守一般的最终一致性规则。</li><li><strong>“读己之所写”一致性</strong>。当进程<code>A</code>自己执行一个更新操作之后，它自己总是可以访问到更新过的值，不会看到旧值。</li><li><strong>会话一致性</strong>。把访问存储系统的进程放到<code>会话（Session）</code>的上下文中，只要会话还存在，系统就保证<code>“读己之所写”一致性</code>。</li><li><strong>单调读一致性</strong>。如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回在那个值之前的值。</li><li><strong>单调写一致性</strong>。系统保证来自同一个进程的写操作顺序执行。</li></ul><h4 id="newsql">1.4 NewSQL</h4><p><code>NewSQL</code>是对各种新的可扩展、高性能数据库的简称，这类数据库不仅具有<code>NoSQL</code>对海量数据的存储管理能力，还保持了传统数据库支持<code>ACID</code>和<code>SQL</code>等特性。<code>NewSQL</code>数据库有两个显著的共同特点：</p><ul><li>都支持关系数据模型；</li><li>都使用<code>SQL</code>作为其主要的接口。</li></ul><h3 id="云数据库">2. 云数据库</h3><h4 id="概述">2.1 概述</h4><p>云数据库是部署和虚拟化在云计算环境中的数据库，云数据库具有高可扩展性、高可用性、采用多租形式和支持资源有效分发等特点。</p><p>在云数据库中，所有数据库功能都是在云端提供的，客户端可以通过网络远程使用云数据库提供的服务。客户端不需要了解云数据库的底层细节，所有的底层硬件都已经被虚拟化，对客户端而言是透明的，就像在使用一个运行在单一服务器上的数据库一样，非常方便容易，同时又可以获得理论上近乎无限的存储和处理能力。</p><h4 id="云数据库系统架构">2.2 云数据库系统架构</h4><p>以阿里集团核心系统数据库团队开发的<code>UMP（ Unified MySQL Platform）</code>系统为例进行介绍。</p><h5 id="ump系统概述">2.2.1 UMP系统概述</h5><p><code>UMP</code>系统是低成本和高性能的<code>MySQL</code>云数据库方案，关键模块采用<code>Erlang</code>语言实现。<code>UMP</code>系统把各种服务器资源划分为资源池，并以资源池为单位把资源分配给<code>MySQL</code>实例。</p><ul><li>系统中包含了一系列组件，这些组件协同工作，以对用户透明的形式提供主从热备、数据备份、迁移、容灾、读写分离、分库分表等一系列服务。</li><li>系统内部划分为3种规格的用户：<code>数据量和流量比较小的用户</code>、<code>中等规模用户</code>以及<code>需要分库分表的用户</code>。</li></ul><p><code>UMP</code>系统架构设计遵循了以下原则。</p><ul><li>保持单一的系统对外入口，并且为系统内部维护单一的资源池。</li><li>消除单点故障，保证服务的高可用性。</li><li>保证系统具有良好的可伸缩性，能够动态地增加、删减计算与存储节点。</li><li>保证分配给用户的资源也是弹性可伸缩的，资源之间相互隔离，确保应用和数据的安全。</li></ul><h5 id="ump系统架构">2.2.2 UMP系统架构</h5><p><code>UMP</code>系统中的角色包括：Controller服务器、Proxy服务器、Agent服务器、Web控制台、日志分析服务器、信息统计服务器、愚公系统；</p><p>依赖的开源组件包括：Mnesia、 LVS、 RabbitMQ和 Zookeeper。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/UMP.PNG" alt="UMP系统架构" /><figcaption aria-hidden="true">UMP系统架构</figcaption></figure><h6 id="mnesia">1. Mnesia</h6><p><code>Mnesia</code>是一个分布式数据库管理系统，适合于电信及其他需要持续运行和具备软实时特性的<code>Erlang</code>应用，是构建电信应用的控制系统平台——<code>开放式电信平台（Open Telecom Platform, OTP）</code>的一部分。</p><p><code>Mnesia</code>支持事务，支持透明的数据分片，利用两阶段锁实现分布式事务，可以线性扩展到至少50个节点。</p><h6 id="rabbitmq">2. RabbitMQ</h6><p><code>RabbitMQ</code>是一个用<code>Erlang</code>开发的工业级的消息队列产品，作为消息传输中间件来使用，可以实现可靠的消息传送。</p><h6 id="zookeeper">3. Zookeeper</h6><p><code>Zookeeper</code>是高效和可靠的协同工作系统，提供分布式锁之类的基本服务（如统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等），用于构建分布式应用，减轻分布式应用程序所承担的协调任务。在UMP系统中， Zookeeper主要发挥3个作用。</p><ul><li><strong>作为全局的配置服务器</strong>。</li><li><strong>提供分布式锁</strong>。</li><li><strong>监控所有MySQL实例</strong>。</li></ul><h6 id="lvs">4. LVS</h6><p><code>LVS（Linux virtual server）</code>即Linux虚拟服务器，是一个虚拟的服务器集群系统。LVS集群采用<code>IP</code>负载均衡技术和基于内容请求分发技术。<code>UMP</code>系统借助于<code>LVS</code>来实现集群内部的负载均衡。</p><h6 id="controller服务器">5. Controller服务器</h6><p>Controller服务器向UMP集群提供各种管理服务，实现集群成员管理、元数据存储、 MySQL实例管理、故障恢复、备份、迁移、扩容等功能。 Controller服务器上运行了一组Mnesia分布式数据库服务，其中存储了各种系统元数据，主要包括集群成员、用户的配置和状态信息，以及用户名到后端 MySQL实例地址的映射关系（或称为“路由表”）等。</p><h6 id="web控制台">6. Web控制台</h6><p>Web控制台向用户提供系统管理界面。</p><h6 id="proxy服务器">7. Proxy服务器</h6><p>Proxy服务器向用户提供访问MySQL数据库的服务，它完全实现了MySQL协议，用户可以使用已有的MySQL客户端连接到 Proxy服务器，Proxy服务器通过用户名获取到用户的认证信息、资源配额的限制以及后台MySQL实例的地址，然后用户的SQL查询请求会被转发到相应的MySQL实例上。</p><h6 id="agent服务器">8. Agent服务器</h6><p>Agent服务器部署在运行MySQL进程的机器上，用来管理每台物理机上的MySQL实例，执行主从切换、创建、删除、备份、迁移等操作，同时还负责收集和分析 MySQL进程的统计信息、慢查询日志（ Slow Query Log）和 bin-log。</p><h6 id="日志分析服务器">9. 日志分析服务器</h6><p>日志分析服务器存储和分析Proxy服务器传入的用户访问日志，并支持实时查询一段时间内的慢日志和统计报表。</p><h6 id="信息统计服务器">10. 信息统计服务器</h6><p>信息统计服务器定期将采集到的用户的连接数、QPS数值以及MySQL实例的进程状态用<code>RRDtool</code>进行统计。</p><h6 id="愚公系统">11. 愚公系统</h6><p>愚公系统是一个全量复制结合<code>bin-log</code>分析进行增量复制的工具，可以实现在不停机的情况下动态扩容、缩容和迁移。</p><h5 id="ump系统功能">2.2.3 UMP系统功能</h5><p>UMP系统是构建在一个大的集群之上的，通过多个组件的协同作业，整个系统实现了对用户透明的容灾、读写分离、分库分表、资源管理、资源调度、资源隔离和数据安全功能。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;学习&lt;code&gt;NoSQL数据库&lt;/code&gt;和&lt;code&gt;云数据库&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="大数据" scheme="https://wuyunjie.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="大数据" scheme="https://wuyunjie.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="基础" scheme="https://wuyunjie.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[大数据技术原理|第二篇 大数据存储与管理(1)]</title>
    <link href="https://wuyunjie.top/2021/07/31/Big_Data_2_store-and-manage.html"/>
    <id>https://wuyunjie.top/2021/07/31/Big_Data_2_store-and-manage.html</id>
    <published>2021-07-31T13:22:01.000Z</published>
    <updated>2021-07-31T13:22:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>介绍大数据存储与管理相关技术的概念与原理，包括<code>Hadoop分布式文件系统（HDFS）</code>、<code>分布式数据库（ HBase）</code>、<code>NoSQL数据库</code>和<code>云数据库</code>。</p><span id="more"></span><h3 id="分布式文件系统hdfs">1. 分布式文件系统<code>HDFS</code></h3><h4 id="分布式文件系统">1.1 分布式文件系统</h4><p><code>分布式文件系统（ Distributed File System）</code>是一种通过网络实现文件在多台主机上进行分布式存储的文件系统。分布式文件系统的设计一般采用<code>“客户机/服务器”（ Client/Server）模式</code>，客户端以特定的通信协议通过网络与服务器建立连接，提出文件访问请求，客户端和服务器可以通过设置访问权来限制请求方对底层数据存储块的访问。</p><h5 id="计算机集群结构">1.1.1 计算机集群结构</h5><p>分布式文件系统把文件分布存储到多个计算机节点上，与使用多个处理器和专用高级硬件的并行化处理装置不同的是，分布式文件系统所采用的计算机集群都是由普通硬件构成的。</p><p>集群中的计算机节点存放在<code>机架（Rack）</code>上，每个机架可以存放<code>8~64</code>个节点，同一机架上的不同节点之间通过网络互连，多个不同机架之间采用另一级网络或交换机互连。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/clusterStructure.PNG" alt="计算机集群结构" /><figcaption aria-hidden="true">计算机集群结构</figcaption></figure><h5 id="分布式文件系统的结构">1.1.2 分布式文件系统的结构</h5><p>分布式文件系统也采用了<code>块（Block）</code>的概念，文件被分成若干个块进行存储，块是数据读写的基本单元。比如，<code>HDFS</code>默认的一个块的大小是<code>64MB</code>。与普通文件不同的是，在分布式文件系统中，<strong><u>如果一个文件小于一个数据块的大小，它并不占用整个数据块的存储空间</u></strong>。</p><p>分布式文件系统在物理结构上是由计算机集群中的多个节点构成的。这些节点分为两类：</p><ul><li><code>“主节点”（ Master Node）</code>，也被称为<code>“名称节点”（ NameNode）</code>。名称节点负责<u><strong>文件和目录的创建</strong></u>、<strong><u>删除和重命名</u></strong>等，同时<strong><u>管理着数据节点和文件块的映射关系</u></strong>，因此客户端只有访问名称节点才能找到请求的文件块所在的位置，进而到相应位置读取所需文件块。</li><li><code>“从节点”（ Slave Node）</code>，也被称为<code>“数据节点”（ DataNode）</code>。数据节点负责<strong><u>数据的存储和读取</u></strong>。<ul><li>在存储时，由名称节点分配存储位置，然后由客户端把数据直接写入相应数据节点；</li><li>在读取时，客户端从名称节点获得数据节点和文件块的映射关系，然后就可以到相应位置访问文件块。</li><li>数据节点也要根据名称节点的命令创建、删除数据块和冗余复制。</li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/DFSStructure.PNG" alt="分布式文件系统的结构" /><figcaption aria-hidden="true">分布式文件系统的结构</figcaption></figure><p>计算机集群中的节点可能发生故障，因此为了保证数据的完整性，分布式文件系统通常采用<code>多副本存储</code>。文件块会被复制为多个副本，存储在不同的节点上，而且存储同一文件块的不同副本的各个节点会分布在不同的机架上。在单个节点出现故障时，可以快速调用副本重启单个节点上的计算过程，而不用重启整个计算过程，整个机架出现故障时也不会丢失所有文件块。</p><h5 id="分布式文件系统设计需求">1.1.3 分布式文件系统设计需求</h5><p>分布式文件系统的设计目标主要包括以下几点：</p><ul><li><strong>透明性</strong>。包括<code>访问透明性</code>、<code>位置透明性</code>、<code>性能和伸缩透明性</code>。<ul><li><strong>访问透明性</strong>是指用户能够通过相同的操作来访问本地文件和远程文件资源。</li><li><strong>位置透明性</strong>是指在不改变路径名的前提下，不管文件副本数量和实际存储位置发生何种变化，对用户而言都是透明的，只需要<strong><u>使用相同的路径名</u></strong>就始终可以访问同一个文件。</li><li><strong>性能和伸缩透明性</strong>是指系统中节点的增加或减少以及性能的变化对用户而言是透明的。</li></ul></li><li><strong>并发控制</strong>。客户端对于文件的读写不应该影响其他客户端对同一个文件的读写。</li><li><strong>文件复制</strong>。文件可以拥有在不同位置的多个副本。</li><li><strong>硬件和操作系统的异构性</strong>。可以在不同的操作系统和计算机上实现同样的客户端和服务器端程序。</li><li><strong>可伸缩性</strong>。支持节点的动态加入或退出。</li><li><strong>容错</strong>。保证文件服务在客户端或者服务端出现问题的时候能正常使用。</li><li><strong>安全需求</strong>。保障系统的安全性。</li></ul><h4 id="hdfs-简介">1.2 HDFS 简介</h4><p><code>HDFS</code>在设计之初就充分考虑了实际应用环境的特点，即<strong><u>硬件出错在普通服务器集群中是一种常态，而不是异常</u></strong>。因此，<code>HDFS</code>在设计上采取了多种机制保证在硬件出错的环境中实现数据的完整性。</p><ul><li><strong>兼容廉价的硬件设备</strong>。<code>HDFS</code>设计了<strong><u>快速检测硬件故障和进行自动恢复的机制</u></strong>，可以实现持续监视、错误检查、容错处理和自动恢复，使得在硬件出错的情况下也能实现数据的完整性。</li><li><strong>流数据读写</strong>。<code>HDFS</code>则是为了满足批量数据处理的要求而设计的，因此<strong><u>为了提高数据吞吐率</u></strong>，<code>HDFS</code>放松了一些 <code>POSIX</code>的要求，从而能够以流式方式来访问文件系统数据。</li><li><strong>大数据集</strong>。</li><li><strong>简单的文件模型</strong>。<code>HDFS</code>采用了<code>“一次写入、多次读取”</code>的简单文件模型，<strong><u>文件一旦完成写入，关闭后就无法再次写入，只能被读取</u></strong>。</li><li><strong>强大的跨平台兼容性</strong>。</li></ul><p><code>HDFS</code>自身也具有应用局限性，主要包括：</p><ul><li><strong>不适合低延迟数据访问</strong>。对于低延时要求的应用程序而言， <code>HBase</code>是一个更好的选择</li><li><strong>无法高效存储大量小文件</strong>。过多小文件会给系统扩展性和性能带来诸多问题。<ul><li><code>HDFS</code>采用<code>名称节点（ NameNode）</code>来管理文件系统的元数据，这些元数据被<strong><u>保存在内存</u></strong>中，从而使客户端可以快速获取文件实际存储位置。通常，每个文件、目录和块大约占<code>150</code>字节。文件数量过多时，名称节点保存元数据所需要的内存空间会大大增加，元数据检索的效率会降低，需要花费较多的时间找到一个文件的实际存储位置。</li><li>用<code>MapReduce</code>处理大量小文件时，会产生过多的<code>Map</code>任务，线程管理开销会大大增加。</li><li>访问大量小文件，需要不断从一个数据节点跳到另一个数据节点，严重影响性能。</li></ul></li><li><strong>不支持多用户写入及任意修改文件</strong>。<code>HDFS</code>只允许一个文件有一个写入者，不允许多个用户对同一个文件执行写操作，而且<strong><u>只允许对文件执行追加操作，不能执行随机写操作</u></strong>。</li></ul><h4 id="hdfs相关概念">1.3 HDFS相关概念</h4><h5 id="块">1.3.1 块</h5><p><code>HDFS</code>采用了块的概念，默认的一个块大小是<code>64MB</code>。在<code>HDFS</code>中的文件会被拆分成多个块，每个块作为独立的单元进行存储。<code>HDFS</code>这么做的原因，是为了<strong><u>最小化寻址开销</u></strong>。<code>HDFS</code>寻址开销包括<code>磁盘寻道开销</code>和<code>数据块的定位开销</code>。当客户端需要访问一个文件时：</p><ul><li>首先从名称节点获得组成这个文件的数据块的位置列表；</li><li>然后根据位置列表获取实际存储各个数据块的数据节点的位置；</li><li>最后数据节点根据数据块信息在本地<code>Linux</code>文件系统中找到对应的文件，并把数据返回给客户端。</li></ul><p>设计一个比较大的块，可以把上述寻址开销分摊到较多的数据中，降低了单位数据的寻址开销。</p><h5 id="名称节点和数据节点">1.3.2 名称节点和数据节点</h5><h6 id="名称节点">1.3.2.1 名称节点</h6><p><code>名称节点（ Name Node）</code>负责管理分布式文件系统的<code>命名空间（ Namespace）</code>，保存了两个核心的数据结构，即 <code>FsImage</code>和 <code>EditLog</code>：</p><ul><li><code>FsImage</code>用于维护文件系统树以及文件树中所有的文件和文件夹的元数据；</li><li>操作日志文件<code>EditLog</code>中记录了所有针对文件的创建删除、重命名等操作。</li></ul><p>名称节点记录了每个文件中各个块所在的数据节点的位置信息，但是<strong><u>并不持久化存储这些信息，而是在系统每次启动时扫描所有数据节点重构得到这些信息</u></strong>。</p><ul><li>名称节点在启动时，会将<code>FsImage</code>的内容加载到内存当中，然后执行<code>EditLog</code>文件中的各项操作，使得内存中的元数据保持最新。</li><li>这个操作完成以后，就会创建一个新的<code>FImage</code>文件和一个空的<code>EditLog</code>文件。</li><li>名称节点启动成功并进入正常运行状态以后，HDFS中的更新操作都会被写入到<code>EditLog</code>，而不是直接写入 <code>FsImage</code>。因为<code>FsImage</code>文件通常都很庞大，如果所有的更新操作都直接往<code>FsImage</code>文件中添加，那么系统就会变得非常缓慢。<code>EditLog</code>通常都要远远小于<code>FsImage</code>，更新操作写入到 <code>EditLog</code>是非常高效的。</li></ul><p>名称节点在启动的过程中处于<code>“安全模式”</code>，只能<strong><u>对外提供读操作无法提供写操作</u></strong>。启动过程结束后，系统就会退出安全模式，进入正常运行状态，对外提供读写操作。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/NameNodeDataStructure.PNG" alt="名称节点数据结构" /><figcaption aria-hidden="true">名称节点数据结构</figcaption></figure><h6 id="数据节点">1.3.2.2 数据节点</h6><p><code>数据节点（ DataNode）</code>是分布式文件系统<code>HDFS</code>的工作节点，负责<strong><u>数据的存储和读取</u></strong>，会根据客户端或者名称节点的调度来进行数据的存储和检索，并且向名称节点定期发送自己所存储的块的列表。每个数据节点中的数据会被保存在各自节点的本地<code>Linux</code>文件系统中。</p><h5 id="第二名称节点">1.3.3 第二名称节点</h5><p>不断变大的<code>EditLog</code>文件通常对于系统性能不会产生显著影响。但是当名称节点重启时，如果<code>EditLog</code>很大，会导致整个过程变得非常缓慢，使得名称节点在启动过程中长期处于<code>“安全模式”</code>。为了有效解决<code>EditLog</code>逐渐变大带来的问题，<code>HDFS</code>在设计中采用了<code>第二名称节点（ Secondary Name Node）</code>，具有两个方面的功能：</p><ul><li>可以完成<code>EditLog</code>与<code>FsImage</code>的合并操作，减小<code>EditLog</code>文件大小，缩短名称节点重启时间。<ul><li>每隔一段时间，第二名称节点会和名称节点通信，请求其停止使用<code>EditLog</code>文件，暂时将新到达的写操作添加到一个新的文件<code>EditLog.new</code>中；</li><li>第二名称节点把名称节点中的<code>FsImage</code>文件和<code>EditLog</code>文件拉回到本地，再加载到内存中；</li><li>对二者执行合并操作，即在内存中逐条执行<code>EditLog</code>中的操作，使得<code>FsImage</code>保持最新；</li><li>合并结束后，第二名称节点会把合并后得到的最新的<code>FsImage</code>文件发送到名称节点；</li><li>名称节点收到后，会用最新的<code>FsImage</code>文件去替换旧的<code>FsImage</code>文件，同时用<code>EditLog.new</code>文件去替换 <code>EditLog</code>文件，从而减小了 EditLog文件的大小。</li></ul></li><li>可以作为名称节点的<code>“检查点”（checkpoint）</code>，保存名称节点中的元数据信息。<ul><li>第二名称节点会定期和名称节点通信，从名称节点获取<code>FsImage</code>文件和<code>EditLog</code>文件，执行合并操作得到新的<code>FsImage</code>文件。从这个角度来讲，第二名称节点相当于为名称节点设置了一个<code>“检查点”</code>，周期性地备份名称节点中的元数据信息，当名称节点发生故障时，可以用第二名称节点中记录的元数据信息进行系统恢复。</li><li>但第二名称节点并不能起到<code>热备份</code>的作用。节点上的<code>FsImage</code>文件是合并操作发生时<code>HDFS</code>记录的元数据信息，系统就会丢失合并操作之后的部分元数据信息。</li></ul></li></ul><h4 id="hdfs体系结构">1.4 HDFS体系结构</h4><h5 id="概述">1.4.1 概述</h5><p><code>HDFS</code>采用了<code>主从（ Master/Slave）结构模型</code>，一个HDFS集群包括<strong><u>一个名称节点和若干个数据节点</u></strong>。</p><ul><li>名称节点作为<strong>中心服务器</strong>，负责管理文件系统的命名空间及客户端对文件的访问。</li><li>数据节点，负责处理文件系统客户端的读写请求，在名称节点的统一调度下进行数据块的创建、删除和复制等操作，一般是<strong><u>一个节点运行一个数据节点进程</u></strong>。每个数据节点的数据实际上是保存在本地<code>Linux</code>文件系统中的。每个数据节点会<u><strong>周期性地向名称节点发送<code>“心跳”</code>信息</strong></u>，报告自己的状态，没有按时发送心跳信息的数据节点会被标记为<code>“宕机”</code>，不会再给它分配任何IO请求。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HDFS.PNG" alt="HDFS体系结构" /><figcaption aria-hidden="true">HDFS体系结构</figcaption></figure><p>用户在使用<code>HDFS</code>时，使用文件名去存储和访问文件。</p><ul><li>当客户端需要访问一个文件时，首先把文件名发送给名称节点，名称节点根据文件名找到对应的数据块；</li><li>名称节点再根据每个数据块信息找到实际存储各个数据块的数据节点的位置，并把数据节点位置发送给客户端；</li><li>最后客户端直接访问这些数据节点获取数据。在整个访问过程中，名称节点并不参与数据的传输。</li></ul><h5 id="hdfs命名空间管理">1.4.2 HDFS命名空间管理</h5><p><code>HDFS</code>的命名空间包含<strong><u>目录、文件和块</u></strong>。命名空间管理是指<u>命名空间支持对HDFS中的目录、文件和块做类似文件系统的创建、修改、删除等基本操作</u>。在当前的<code>HDFS</code>体系结构中，在整个<code>HDFS</code>集群中<u><strong>只有一个命名空间，并且只有唯一一个名称节点</strong></u>负责对这个命名空间进行管理。</p><p>HDFS使用的是传统的<strong><u>分级文件体系</u></strong>，因此用户可以像使用普通文件系统一样，创建、删除目录和文件，在目录间转移文件、重命名文件等。<code>HDFS</code><strong><u>还没有实现磁盘配额和文件访问权限等功能，也不支持文件的硬连接和软连接</u></strong>。</p><h5 id="通信协议">1.4.3 通信协议</h5><p><code>HDFS</code>通信协议都是构建在<code>TCP/IP</code>协议基础上的。</p><ul><li>客户端通过一个可配置的端口向名称节点主动发起<code>TCP</code>连接，并使用客户端协议与名称节点进行交互。</li><li>名称节点和数据节点之间则使用数据节点协议进行交互。</li><li>客户端与数据节点的交互是通过<code>RPC（ Remote Procedure Cal）</code>来实现的。名称节点不会主动发起<code>RPC</code>，而是响应来自客户端和数据节点的<code>RPC</code>请求。</li></ul><h5 id="客户端">1.4.4 客户端</h5><p>客户端是用户操作<code>HDFS</code>最常用的方式，<code>HDFS</code>在部署时都提供了客户端。但客户端并不算是<code>HDFS</code>的一部分。客户端可以支持打开、读取、写入等常见的操作，并且提供了类似<code>shell</code>的命令行方式来访问HDFS中的数据。</p><h5 id="hdfs体系结构的局限性">1.4.5 HDFS体系结构的局限性</h5><ol type="1"><li><strong>命名空间的限制</strong>。名称节点是保存在内存中的，因此名称节点能够容纳对象（文件、块）的个数会受到内存空间大小的限制。</li><li><strong>性能的瓶颈</strong>。整个分布式文件系统的吞吐量受限于单个名称节点的吞吐量。</li><li><strong>隔离问题</strong>。由于集群中只有一个名称节点，只有一个命名空间，因此无法对不同应用程序进行隔离。</li><li><strong>集群的可用性</strong>。一旦这个唯一的名称节点发生故障，会导致整个集群变得不可用。</li></ol><h4 id="hdfs存储原理">1.5 HDFS存储原理</h4><h5 id="数据的冗余存储">1.5.1 数据的冗余存储</h5><p>为了保证系统的<strong><u>容错性和可用性</u></strong>，<code>HDFS</code>采用了<strong><u>多副本方式</u></strong>对数据进行冗余存储，通常一个数据块的多个副本会被分布到不同的数据节点上。这种多副本方式具有以下优点：</p><ul><li><strong>加快数据传输速度</strong>。多个客户端需要同时访问同一个文件时，可以让各个客户端分别从不同的数据块副本中读取数据，这就大大加快了数据传输速度。</li><li><strong>容易检查数据错误</strong>。<code>HDFS</code>的数据节点之间通过网络传输数据，采用多个副本可以很容易判断数据传输是否出错。</li><li><strong>保证数据的可靠性</strong>。即使某个数据节点出现故障失效，也不会造成数据丢失。</li></ul><h5 id="数据存取策略">1.5.2 数据存取策略</h5><h6 id="数据存放">1.5.2.1 数据存放</h6><p><code>HDFS</code>采用了<strong>以<code>机架（Rack）</code>为基础的数据存放策略</strong>。<code>HDFS</code>默认每个数据节点都是在不同的机架上：</p><ul><li>缺点是写入数据的时候<strong><u>不能充分利用同一机架内部机器之间的带宽</u></strong>。</li><li>但也带来了更多很显著的优点：<ul><li>可以获得很高的数据可靠性，即使一个机架发生故障，位于其他机架上的数据副本仍然是可用的；</li><li>在读取数据的时候，可以在多个机架上并行读取数据，大大提高了数据读取速度；</li><li>可以更容易地实现系统内部负载均衡和错误处理。</li></ul></li></ul><p><code>HDFS</code>默认的冗余复制因子是<code>3</code>，每一个文件块会被同时保存到<code>3</code>个地方，有两份副本放在同一个机架的不同机器上面，第三个副本放在不同机架的机器上面，这样既可以保证机架发生异常时的数据恢复，也可以提高数据读写性能。</p><ul><li>如果是在集群内发起写操作请求，则把第一个副本放置在发起写操作请求的数据节点上，实现就近写入数据。</li><li>如果是来自集群外部的写操作请求，则从集群内部挑选一台<strong>磁盘不太满、CPU不太忙</strong>的数据节点，作为第一个副本的存放地。</li><li>第二个副本会被放置在<strong><u>与第一个副本不同的机架的数据节点上</u></strong>。</li><li>第三个副本会被放置在<strong><u>与第一个副本相同的机架的其他节点上</u></strong>。</li><li>如果还有更多的副本，则继续从集群中随机选择数据节点进行存放。</li></ul><h6 id="数据读取">1.5.2.2 数据读取</h6><p><code>HDFS</code>提供了一个<code>API</code>可以确定一个数据节点所属的机架<code>ID</code>，客户端可以调用<code>API</code>获取自己所属的机架。当客户端读取数据时：</p><ul><li>从名称节点获得数据块<strong><u>不同副本的存放位置列表</u></strong>，列表中包含了副本所在的数据节点，可以调用<code>API</code>来确定客户端和这些数据节点所属的机架<code>ID</code>。</li><li>当发现某个数据块副本对应的机架ID和客户端对应的机架ID相同时，就优先选择该副本读取数据，如果没有发现，就随机选择一个副本读取数据。</li></ul><h6 id="数据复制">1.5.2.3 数据复制</h6><p><code>HDFS</code>的数据复制采用了<strong><u>流水线复制的策略</u></strong>，大大提高了数据复制过程的效率。当客户端要往<code>HDFS</code>中写入一个文件时：</p><ul><li>首先把这个文件写入本地，并被切分成若干个块，每个块的大小是由<code>HDFS</code>的设定值来决定的。每个块都向<code>HDFS</code>集群中的名称节点发起写请求；</li><li>名称节点会根据系统中各个数据节点的使用情况，选择一个数据节点列表返回给客户端，然后客户端就把数据首先写入列表中的第一个数据节点，同时把列表传给第一个数据节点；</li><li>当第一个数据节点接收到<code>4KB</code>数据的时候，写入本地，并且向列表中的第二个数据节点发起连接请求，把自己已经接收到的<strong><u><code>4KB</code>数据和列表</u></strong>传给第二个数据节点；</li><li>当第二个数据节点接收到<code>4KB</code>数据的时候，写入本地，并且向列表中的第三个数据节点发起连接请求，依次类推列表中的多个数据节点形成一条<strong><u>数据复制的流水线</u></strong>。</li><li>最后，当文件写完的时候，数据复制也同时完成。</li></ul><h5 id="数据错误与恢复">1.5.3 数据错误与恢复</h5><h6 id="名称节点出错">1.5.3.1.名称节点出错</h6><p>名称节点保存了所有的元数据信息，其中最核心的两大数据结构是<code>FsImage</code>和<code>EditLog</code>，如果这两个文件发生损坏，那么整个<code>HDFS</code>实例将失效。<code>Hadoop</code>采用两种机制来确保名称节点的安全：</p><ul><li>把名称节点上的元数据信息同步存储到其他文件系统中（比如远程挂载的网络文件系统<code>NFS</code>）；</li><li>运行一个第二名称节点，当名称节点宕机以后，可以把第二名称节点作为一种弥补措施，利用第二名称节点中的元数据信息进行系统恢复，但这样做仍然会丢失部分数据。</li></ul><p>一般会把两种方式结合使用，当名称节点发生宕机时，首先到远程挂载的网络文件系统中<u><strong>获取备份的元数据信息</strong></u>，<strong><u>放到第二名称节点上进行恢复，并把第二名称节点作为名称节点来使用</u></strong>。</p><h6 id="数据节点出错">1.5.3.2 数据节点出错</h6><p>每个数据节点会定期向名称节点发送<code>“心跳”</code>信息，向名称节点报告自己的状态。当数据节点发生故障，或者网络发生断网时，名称节点就无法收到来自一些数据节点的<code>“心跳”</code>信息，这时这些数据节点就会被标记为<code>“宕机”</code>，节点上面的所有数据都会被标记为<code>“不可读”</code>，名称节点不会再给它们发送任何<code>IO</code>请求。</p><p>由于一些数据节点的不可用，会导致一些数据块的副本数量小于冗余因子。名称节点会定期检查这种情况，一旦发现某个数据块的副本数量小于冗余因子，就会启动数据冗余复制，为它生成新的副本。</p><h6 id="数据出错">1.5.3.3 数据出错</h6><p>网络传输和磁盘错误等因素都会造成数据错误。客户端在读取到数据后，会采用<code>md5</code>和<code>sha1</code>对数据块进行校验，以确定读取到正确的数据。如果校验出错，客户端就会请求到另外一个数据节点读取该文件块，并且向名称节点报告这个文件块有错误，名称节点会定期检查并且重新复制这个块。</p><h4 id="hdfs的数据读写过程">1.6 HDFS的数据读写过程</h4><h5 id="读数据">1.6.1 读数据</h5><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HDFSRead.PNG" alt="HDFS读" /><figcaption aria-hidden="true">HDFS读</figcaption></figure><p><code>HDFS</code>的内部执行过程如下：</p><ol type="1"><li>客户端通过<code>FileSystem.open()</code>打开文件，在<code>HDFS</code>文件系统中<code>DistributedFileSystem</code>具体实现了<code>FileSystem</code>。调用<code>open()</code>方法后，<code>DistributedFileSystem</code>会创建输入流<code>FSDatalnputstream</code>，对于<code>HDFS</code>而言，<strong><u>具体的输入流就是<code>DFSInputStream</code></u></strong>。</li><li>在<code>DFSInputStream</code>的构造函数中，输入流通过<code>ClientProtocal.getBlockLocations()</code>远程调用名称节点，获得文件开始部分数据块的保存位置。<ul><li>名称节点返回保存该数据块的所有数据节点的地址，同时根据距离客户端的远近对数据节点进行排序；</li><li><code>DistributedFileSystem</code>利用<code>DFSInputStream</code>来实例化<code>FSDataInputStream</code>，返回给客户端，同时返回数据块的数据节点地址。</li></ul></li><li>获得输入流<code>FSDataInputStream</code>后，客户端调用<code>read()</code>函数开始读取数据。输入流根据前面的排序结果，选择距离客户端最近的数据节点建立连接并读取数据。</li><li>数据从该数据节点读到客户端；当该数据块读取完毕时，<code>FSDataInputStream</code>关闭和该数据节点的连接。</li><li>输入流通过<code>getBlockLocations()</code>方法查找下一个数据块。</li><li>找到该数据块的最佳数据节点，读取数据。</li><li>当客户端读取完毕数据的时候，调用<code>FSDataInputStream</code>的<code>close()</code>函数，关闭输入流。</li></ol><p>在读取数据的过程中，如果客户端与数据节点通信时出现错误，就会尝试连接包含此数据块的下一个数据节点。</p><h5 id="写数据">1.6.2 写数据</h5><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HDFSWrite.PNG" alt="HDFS写" /><figcaption aria-hidden="true">HDFS写</figcaption></figure><p><code>HDFS</code>的内部执行过程如下：</p><ol type="1"><li>客户端通过<code>FileSystem.create()</code>创建文件，调用<code>create()</code>方法后，<code>DistributedFileSystem</code>会创建输出流 <code>FSDataOutputStream</code>，对于<code>HDFS</code>而言，具体的输出流就是<code>DFSOutputStream</code>；</li><li><code>DistributedFileSystem</code>通过<code>RPC</code>远程调用名称节点，在文件系统的命名空间中创建一个新的文件。<ul><li>名称节点会执行一些检查，比如文件是否已经存在、客户端是否有权限创建文件等。检查通过之后，名称节点会构造一个新文件，并添加文件信息。</li><li>远程方法调用结束后，<code>DistributedFileSystem</code>会利用<code>DFSOutputStream</code>来实例化 <code>FSDataOutputStream</code>，返回给客户端，客户端使用这个输出流写入数据。</li></ul></li><li>获得输出流<code>FSDataOutputStream</code>以后，客户端调用输出流的<code>write()</code>方法向<code>HDFS</code>中对应的文件写入数据。</li><li>客户端向输出流<code>FSDataOutputStream</code>中写入的数据会首先被分成分包，这些分包被放入<code>DFSOutputStream</code>对象的内部队列。输出流<code>FSDataOutputStream</code>会向名称节点申请保存文件和副本数据块的若干个数据节点，这些数据节点形成一个数据流管道。队列中的分包最后被打包成数据包，数据包会流经管道上的各个数据节点。</li><li>为了保证所有数据节点的数据都是准确的，接收到数据的数据节点要向发送者发送<code>“确认包”（ ACK Packet）</code>。确认包沿着数据流管道逆流而上，从数据流管道依次经过各个数据节点并最终发往客户端，当客户端收到应答时，它将对应的分包从内部队列移除。不断执行直到数据全部写完。</li><li>客户端调用<code>close()</code>方法关闭输出流，客户端不会再向输出流中写入数据，当<code>DFSOutputStream</code>对象内部队列中的分包都收到应答以后，使用<code>ClientProtocol.complete()</code>方法通知名称节点关闭文件。</li></ol><h4 id="hdfs实践">1.7 HDFS实践</h4><h5 id="hdfs常用命令">1.7.1 HDFS常用命令</h5><h6 id="文件夹目录操作">1.7.1.1 文件夹目录操作</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看目录</span></span><br><span class="line"><span class="comment"># 显示目录结构</span></span><br><span class="line">hdfs dfs -ls &lt;path&gt;</span><br><span class="line"><span class="comment"># 以人性化的方式递归显示目录结构</span></span><br><span class="line">hdfs dfs -ls  -R -h &lt;path&gt;</span><br><span class="line"><span class="comment"># 显示根目录下内容</span></span><br><span class="line">hdfs dfs -ls /</span><br><span class="line"><span class="comment"># 查看HDFS目录“/tmp/&#123;test&#125;/hdfs_data”的内容。</span></span><br><span class="line">hadoop fs -ls /tmp/&#123;<span class="built_in">test</span>&#125;/hdfs_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建目录</span></span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">hdfs dfs -mkdir &lt;path&gt; </span><br><span class="line"><span class="comment"># 递归创建目录</span></span><br><span class="line">hdfs dfs -mkdir -p &lt;path&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在HDFS上创建目录“/tmp/&#123;test&#125;/hdfs_data”。</span></span><br><span class="line">hadoop fs -mkdir -p /tmp/&#123;<span class="built_in">test</span>&#125;/hdfs_data</span><br><span class="line"><span class="comment"># 一般在hdfs上都有的需要处理的数据目录</span></span><br><span class="line">hdfs dfs -mkdir /input </span><br><span class="line"><span class="comment"># 一般在hdfs上都有的处理的结果数据目录</span></span><br><span class="line">hdfs dfs -mkdir /output</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除目录</span></span><br><span class="line"><span class="comment"># 删除空文件夹</span></span><br><span class="line">hdfs dfs -rmdir &lt;path&gt;</span><br><span class="line"><span class="comment"># 递归删除目录和文件</span></span><br><span class="line">hdfs dfs -rm -r &lt;path&gt; </span><br></pre></td></tr></table></figure><h6 id="文件操作">1.7.1.2 文件操作</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看文件信息</span></span><br><span class="line"><span class="comment"># 二选一执行即可</span></span><br><span class="line">hdfs dfs -cat &lt;path&gt; </span><br><span class="line"><span class="comment">#将HDFS中文件以文本形式输出（包括zip包，jar包等形式）</span></span><br><span class="line">hdfs dfs -text &lt;path&gt; </span><br><span class="line"></span><br><span class="line">hdfs dfs -tail &lt;path&gt; </span><br><span class="line"><span class="comment">#和Unix中tail -f命令类似，当文件内容更新时，输出将会改变，具有实时性</span></span><br><span class="line">hdfs dfs -tail -f &lt;path&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 修改文件的权限、所有者</span></span><br><span class="line"><span class="comment"># 权限控制和Linux上使用方式一致</span></span><br><span class="line"><span class="comment"># 变更文件或目录的所属群组。 用户必须是文件的所有者或超级用户。</span></span><br><span class="line">hdfs dfs -chgrp [-R] GROUP URI [URI ...]</span><br><span class="line"><span class="comment"># 修改文件或目录的访问权限  用户必须是文件的所有者或超级用户。</span></span><br><span class="line">hdfs dfs -chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; URI [URI ...]</span><br><span class="line"><span class="comment"># 修改文件的拥有者  用户必须是超级用户。</span></span><br><span class="line">hdfs dfs -chown [-R] [OWNER][:[GROUP]] URI [URI ]</span><br><span class="line"><span class="comment">#案例</span></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -chmod -R 774 /tmp</span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -chown -R biubiubiu:hadoopenv /tmp</span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -chgrp -R <span class="built_in">test</span> /tmp</span><br><span class="line"></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -chmod 777 /input/hello.txt</span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -chown 1111:1111  /input/hello.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 统计文件信息</span></span><br><span class="line"><span class="comment"># 统计目录下各文件大小</span></span><br><span class="line">hdfs dfs -du [-s] [-h] URI [URI ...]</span><br><span class="line">-s : 显示所有文件大小总和</span><br><span class="line">-h : 将以更友好的方式显示文件大小（例如 64.0m 而不是 67108864）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计文件系统的可用空间</span></span><br><span class="line">hdfs dfs -df -h /</span><br><span class="line">-h : 将以更友好的方式显示文件大小（例如 64.0m 而不是 67108864）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 修改文件的副本数</span></span><br><span class="line"><span class="comment">#更改文件的复制因子。如果 path 是目录，则更改其下所有文件的复制因子</span></span><br><span class="line">hdfs dfs -setrep [-w] &lt;numReplicas&gt; &lt;path&gt;</span><br><span class="line">-w : 标志的请求，命令等待复制完成。这有可能需要很长的时间。</span><br><span class="line"></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -setrep 2  /input/hello.txt</span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -setrep -w 5 /input/bbb.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 删除文件</span></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">hdfs dfs -rm &lt;path&gt;</span><br><span class="line"></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -rm  /input/hello.txt</span><br></pre></td></tr></table></figure><h6 id="本地与集群的操作">1.7.1.3 本地与集群的操作</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 将Linux本地的文件上传到集群</span></span><br><span class="line"><span class="comment"># 二选一执行即可</span></span><br><span class="line">hdfs dfs -put &lt;localsrc&gt; &lt;dst&gt;</span><br><span class="line">hdfs dfs -copyFromLocal &lt;localsrc&gt; &lt;dst&gt;</span><br><span class="line">-f ：当文件存在时，进行覆盖</span><br><span class="line">-p ：将权限、所属组、时间戳、ACL以及XATTR等也进行拷贝</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将Linux本地的文件剪切到集群</span></span><br><span class="line">hdfs dfs -moveFromLocal &lt;localsrc&gt; &lt;dst&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 将Linux本地的文件追加到集群文件</span></span><br><span class="line">hdfs dfs -appendToFile &lt;localsrc&gt; ... &lt;dst&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#案例</span></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -appendToFile ./test_1.txt /input/aaa.txt</span><br><span class="line"><span class="comment"># 多个文件用空格隔开</span></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -appendToFile ./test_1.txt ./test_2.txt /input/aaa.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 将集群文件下载到Linux本地</span></span><br><span class="line"><span class="comment"># 二选一执行即可</span></span><br><span class="line">hdfs dfs -get &lt;src&gt; &lt;localdst&gt;</span><br><span class="line">hdfs dfs -copyToLocal &lt;src&gt; &lt;localdst&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 合并下载多个文件到本地Linux</span></span><br><span class="line">hdfs dfs -getmerge [-nl] &lt;src&gt; &lt;localdst&gt;</span><br><span class="line"></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -getmerge /input/*  data.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例 将HDFS上的wordcount_input.txt和aaa.txt合并后下载到本地的当前用户家目录的merge.txt</span></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -getmerge /input/wordcount_input.txt /wordcount/input/aaa.txt ~/merge.txt</span><br><span class="line">-nl: 在每个文件的末尾添加换行符（LineFeed）</span><br><span class="line">-skip-empty-file: 跳过空文件</span><br></pre></td></tr></table></figure><p>更多可以参考<a href="https://blog.csdn.net/qq_40246175/article/details/104304193">【csdn-HDFS常用Shell命令总结】</a>或官方<code>API</code>。</p><h5 id="hdfs-web界面">1.7.2 HDFS Web界面</h5><p>在配置好<code>Hadoop</code>集群之后，可以通过浏览器登录<code>"http://[NameNodelP]:50070"</code>访问<code>HDFS</code>文件系统，<code>[NameNodeIP]</code>表示名称节点的<code>IP</code>地址。伪分布式安装后，可以登录<code>"http://localhost:50070"</code>来查看文件系统信息。该<code>Web</code>界面的所有功能都能通过<code>Shell</code>命令等价实现。</p><h3 id="分布式数据库hbase">2. 分布式数据库<code>HBase</code></h3><h4 id="概述-1">2.1 概述</h4><p>HBase是一个高可靠、高性能、面向列、可伸缩的<strong><u>分布式数据库</u></strong>，主要用来存储非结构化和半结构化的松散数据。</p><ul><li><code>HBase</code>利用<code>Hadoop MapReduce</code>来处理<code>HBase</code>中的海量数据，实现高性能计算；</li><li>利用<code>Zookeeper</code>作为协同服务，实现稳定服务和失败恢复；</li><li>使用<code>HDFS</code>作为高可靠的底层存储，利用廉价集群提供海量数据存储能力。<code>HBase</code>也可以直接使用本地文件系统而不用<code>HDFS</code>作为底层数据存储方式。</li><li><code>Sqoop</code>为<code>HBase</code>提供了高效、便捷的<code>RDBMS</code>数据导入功能；</li><li><code>Pig</code>和<code>Hive</code>为<code>HBase</code>提供了高层语言支持。</li></ul><p><code>HBase</code>与传统的关系数据库的区别主要体现在以下几个方面。</p><ul><li><strong>数据类型</strong>。关系数据库采用<code>关系模型</code>，具有丰富的数据类型和存储方式。<code>HBase</code>则采用了更加简单的数据模型，它<strong><u>把数据存储为未经解释的字符串</u></strong>，用户可以把不同格式的结构化数据和非结构化数据都序列化成字符串保存到 <code>HBase</code>中，需要<strong><u>自己编写程序把字符串解析成不同的数据类型</u></strong>。</li><li><strong>数据操作</strong>。关系数据库中包含了丰富的操作，如插入、删除、更新、查询等，其中会涉及复杂的多表连接。<code>HBase</code>操作则不存在复杂的表与表之间的关系，只有简单的<strong><u>插入、查询、删除、清空</u></strong>等，因为<code>HBase</code>在设计上就避免了复杂的表与表之间的关系，通常只采用单表的主键查询。</li><li><strong>存储模式</strong>。关系数据库是<strong><u>基于行模式存储的</u></strong>，元组或行会被连续地存储在磁盘页中。<code>HBase</code>是<strong><u>基于列存储的</u></strong>，每个列族都由几个文件保存，不同列族的文件是分离的，优点是：<ul><li>可以降低IO开销，支持大量并发用户查询，因为仅需要处理可以回答这些查询的列，而不需要处理与查询无关的大量数据行；</li><li>同一个列族中的数据会被一起进行压缩，由于同一列族内的数据相似度较高，因此可以获得较高的数据压缩比。</li></ul></li><li><strong>数据索引</strong>。关系数据库通常可以针对不同列构建复杂的多个索引，以提高数据访问性能。<code>HBase</code>只有一个索引——<strong><u>行键</u></strong>，<code>Hase</code>中的所有访问方法，或者通过行键访问，或者通过行键扫描，可以使用<code>Hadoop MapReduce</code>来快速、高效地生成索引表。</li><li><strong>数据维护</strong>。在关系数据库中，更新操作会用最新的当前值去替换记录中原来的旧值，旧值被覆盖后就不会存在。而在<code>HBase</code>中执行更新操作时，并不会删除数据旧的版本，而是<strong><u>生成一个新的版本，旧有的版本仍然保留</u></strong>。</li><li><strong>可伸缩性</strong>。关系数据库很难实现横向扩展，纵向扩展的空间也比较有限。<code>HBase</code>和<code>Big Table</code>这些分布式数据库能够轻易地通过在集群中增加或者减少硬件数量来实现性能的伸缩。</li><li><strong>事务</strong>。<code>HBase</code>不支持事务，因此无法实现跨行的原子性。</li></ul><h4 id="hbase-数据模型">2.2 HBase 数据模型</h4><h5 id="数据模型概述">2.2.1 数据模型概述</h5><p><code>HBase</code>是一个<strong><u>稀疏、多维度、排序的映射表</u></strong>，这张表的<strong><u>索引是行键、列族、列限定符和时间戳</u></strong>。每个值是一个未经解释的字符串，没有数据类型。</p><ul><li><p>用户在表中存储数据，每一行都有一个<strong><u>可排序的行键和任意多的列</u></strong>。表在水平方向由一个或者多个列族组成，一个列族中可以包含任意多个列，同一个列族里面的数据存储在一起。列族支持<strong><u>动态扩展</u></strong>，可以很轻松地添加一个列族或列。由于同一张表里面的每一行数据都可以有截然不同的列，<code>HBase</code>是稀疏的。</p></li><li><p>在<code>HBase</code>中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本。客户端可以选择获取距离某个时间最近的版本，或者一次获取所有版本。如果在查询的时候不提供时间戳，那么会返回距离现在最近的那一个版本的数据。<code>HBase</code>提供了两种数据版本回收方式：一是保存数据的最后<code>n</code>个版本；二是保存最近一段时间内的版本。</p></li></ul><h5 id="数据模型相关概念">2.2.2 数据模型相关概念</h5><p><code>HBase</code>实际上就是一个稀疏、多维、持久化存储的映射表，它采用<code>行键（Row Key）</code>、<code>列族（Column Family）</code>、<code>列限定符（Column Qualifier）</code>和<code>时间戳（Timestamp）</code>进行索引，每个值都是未经解释的字节数组<code>byte</code>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBaseData.PNG" alt="HBase数据模型" /><figcaption aria-hidden="true">HBase数据模型</figcaption></figure><h6 id="表">1.表</h6><p><code>HBase</code>采用表来组织数据，表由行和列组成，列划分为若干个列族。</p><h6 id="行">2. 行</h6><p>每个<code>HBase</code>表都由若干行组成，每个行由<code>行键（Row Key）</code>来标识。访问表中的行有3种方式：</p><ul><li>通过单个行键访问；</li><li>通过一个行键的区间来访问；</li><li>全表扫描。</li></ul><p>在<code>HBase</code>内部，行键保存为字节数组，数据按照行键的字典序排序存储。</p><h6 id="列族">3. 列族</h6><p><code>HBase</code>表被分组成许多<code>“列族”</code>的集合，它是基本的<strong><u>访问控制单元</u></strong>，列族需要在表创建时就定义好。</p><ul><li>存储在一个列族当中的所有数据，通常都属于同一种数据类型，具有更高的压缩率。</li><li>表中的每个列都归属于某个列族，数据可以被存放到列族的某个列下面。</li><li>在<code>HBase</code>中，访问控制、磁盘和内存的使用统计都是在列族层面进行的。</li></ul><h6 id="列限定符">4. 列限定符</h6><p>列族里的数据通过列限定符（或列）来定位。列限定符不用事先定义，也不需要在不同行之间保持一致。列限定符没有数据类型，总被视为字节数组<code>byte</code>。</p><h6 id="单元格">5.单元格</h6><p>在<code>HBase</code>表中，通过行、列族和列限定符确定一个<code>“单元格”（cell）</code>。单元格中存储的数据没有数据类型，总被视为字节数组<code>byte[]</code>。每个单元格中可以保存一个数据的多个版本，每个版本对应一个不同的时间戳。</p><h6 id="时间戳">6. 时间戳</h6><p>每个单元格都保存着同一份数据的多个版本，这些版本采用时间戳进行索引。每次对一个单元格执行操作（新建、修改、删除）时，<code>HBase</code>都会隐式地自动生成并存储一个时间戳。时间戳一般是<code>64</code>位整型，可以由用户自己赋值，也可以由 <code>HBase</code>在数据写入时自动赋值。<strong><u>一个单元格的不同版本是根据时间戳降序的顺序进行存储的</u></strong>。</p><h5 id="数据坐标">2.2.3 数据坐标</h5><p><code>HBase</code>使用坐标来定位表中的数据，<code>HBase</code>中需要根据<code>行键</code>、<code>列族</code>、<code>列限定符</code>和<code>时间戳</code>来确定一个单元格，因此可以视为一个<strong>“四维坐标”</strong>，即<code>[行键，列族，列限定符，时间戳]</code>。</p><p>如果把所有坐标看成一个整体，视为<code>“键”</code>，把四维坐标对应的单元格中的数据视为<code>“值”</code>，<code>HBase</code>也可以看成一个键值数据库。</p><h5 id="概念视图">2.2.4 概念视图</h5><p>在<code>HBase</code>的概念视图中，一个表可以视为一个稀疏、多维的映射关系。在一个<code>HBase</code>表的概念视图中，每个行都包含相同的列族，不需要在每个列族里存储数据，<code>HBase</code>表里面存在很多空的单元格。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBaseLogicVision.PNG" alt="HBase 概念视图" /><figcaption aria-hidden="true">HBase 概念视图</figcaption></figure><h5 id="物理视图">2.2.5 物理视图</h5><p>在物理存储层面，<code>HBase</code>采用了<strong><u>基于列的存储方式</u></strong>，<code>HBase</code>表会按照列族分别存放，属于同一个列族的数据保存在一起，和每个列族一起存放的还包括行键和时间戳。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBasePyhsicalView.PNG" alt="HBase 概念视图" /><figcaption aria-hidden="true">HBase 概念视图</figcaption></figure><p>在物理视图中，空列不会被存储成<code>null</code>，而是根本就不会被存储，当请求这些空白的单元格的时候会返回<code>null</code>值。</p><h5 id="面向列的存储">2.2.6 面向列的存储</h5><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBaseDataStore.PNG" alt="行式存储和列式存储" /><figcaption aria-hidden="true">行式存储和列式存储</figcaption></figure><h6 id="行式数据库">1. 行式数据库</h6><p>行式数据库使用<code>NSM（N-ary Storage Model）</code>存储模型，一个元组（或行）会被连续地存储在磁盘页中，数据是一行一行被存储的。在从磁盘中读取数据时，需要从磁盘中顺序扫描每个元组的完整内容，然后从每个元组中筛选出查询所需要的属性。如果每个元组只有少量属性的值对于查询是有用的，那么<code>NSM</code>就会浪费许多磁盘空间和内存带宽。</p><ul><li>行式数据库主要适合于小批量的数据处理，如联机事务型数据处理，<code>Oracle</code>和<code>MySQL</code>等关系数据库都属于行式数据库。</li></ul><h6 id="列式数据库">2. 列式数据库</h6><p>列式数据库采用<code>DSM（Decomposition Storage Model）</code>存储模型，目的是最小化无用的<code>I/O</code>。<code>DSM</code>会对关系进行垂直分解，并为每个属性分配一个子关系。一个具有<code>n</code>个属性的关系会被分解成<code>n</code>个子关系，每个子关系单独存储，每个子关系只有当其相应的属性被请求时才会被访问。也就是说，<code>DSM</code>是以关系数据库中的属性或列为单位进行存储，关系中多个元组的同一属性值（或同一列值）会被存储在一起，而一个元组中不同属性值则通常会被分别存放于不同的磁盘页中。</p><ul><li><p>列式数据库主要适合于批量数据处理和即席查询（Ad-Hoc Query）。优点是：</p><ul><li>可以降低<code>I/O</code>开销，支持大量并发用户查询，处理速度快；</li><li>具有较高的数据压缩比，较传统的行式数据库更加有效果。</li></ul><p>列式数据库主要用于数据挖掘、决策支持和地理信息系统等<code>查询密集型系统</code>中。</p></li><li><p><code>DSM</code>存储模型的缺陷是：</p><ul><li>执行连接操作时需要昂贵的元组重构代价，因为一个元组的不同属性被分散到不同磁盘页中存储，当需要一个完整的元组时，就要从多个磁盘页中读取相应字段的值来重新组合得到原来的一个元组。</li><li>对于联机事务型数据处理而言，需要频繁对一些元组进行修改，如果采用<code>DSM</code>存储模型，就会带来高昂的开销。</li></ul><p>对于分析型应用而言，一般数据被存储后不会发生修改（如数据仓库），因此不会涉及昂贵的元组重构代价。</p></li></ul><h4 id="hbase实现原理">2.3 HBase实现原理</h4><h5 id="hbase的功能组件">2.3.1 HBase的功能组件</h5><p><code>HBase</code>的实现包括3个主要的功能组件：</p><ul><li><strong>库函数</strong>，链接到每个客户端；</li><li>一个<code>Master</code>主服务器。<code>Master</code>负责<strong><u>管理和维护<code>HBase</code>表的分区信息</u></strong>。</li><li>多个<code>Region</code>服务器。<code>Region</code>服务器负责<strong><u>存储和维护分配给自己的<code>Region</code>，处理来自客户端的读写请求</u></strong>。</li></ul><p><code>Master</code>会实时监测集群中的<code>Region</code>服务器，把特定的<code>Region</code>分配到可用的<code>Region</code>服务器上，并确保整个集群内部不同<code>Region</code>服务器之间的<strong><u>负载均衡</u></strong>，当某个<code>Region</code>服务器因出现故障而失效时，<code>Master</code>会把该故障服务器上存储的<code>Region</code>重新分配给其他可用的<code>Region</code>服务器。<code>Master</code>还处理模式变化，如表和列族的创建。</p><p>客户端在获得<code>Region</code>的存储位置信息后，直接从<code>Region</code>服务器上读取数据。<code>HBase</code>客户端并借助于<code>Zookeeper</code>来获得<code>Region</code>的位置信息的，所以<strong><u>大多数客户端从来不和主服务器Master通信，这种设计方式使Master的负载很小</u></strong>。</p><h5 id="表和region">2.3.2 表和Region</h5><p>对于每个<code>HBase</code>表而言，表中的行是根据行键的值的字典序进行维护的，表中包含的行的数量可能非常庞大，无法存储在一台机器上。因此，需要<strong><u>根据行键的值对表中的行进行分区</u></strong>，每个行区间构成一个分区，被称为<code>“ Region”</code>，包含了位于某个值域区间内的所有数据，这些<code>Region</code>会被分发到不同的<code>Region</code>服务器上。</p><ul><li>初始时，每个表只包含一个<code>Region</code>，随着数据的不断插入，<code>Region</code>会持续增大，当一个<code>Region</code>中包含的行数量达到一个阈值时，就会被自动等分成两个新的<code>Region</code>。</li><li>每个<code>Region</code>的默认大小是<code>100MB</code>到<code>200MB</code>，是HBase中<strong><u>负载均衡和数据分发的基本单位</u></strong>。同一个<code>Region</code>是不会被拆分到多个<code>Region</code>服务器上的。每个<code>Region</code>服务器负责管理一个<code>Region</code>集合。</li></ul><h5 id="region的定位">2.3.3 Region的定位</h5><p>每个<code>Region</code>都有一个<code>RegionID</code>来标识它的唯一性，一个<code>Region</code>标识符就可以表示成<code>"表名+开始主键+RegionID"</code>。</p><p>为了定位每个<code>Region</code>所在的位置，可以构建一张映射表，映射表的每个条目（或每行）包含两项内容：</p><ul><li><code>Region</code>标识符；</li><li><code>Region</code>服务器标识。</li></ul><p>这个条目就表示<code>Region</code>和<code>Region</code>服务器之间的对应关系。这个映射表包含了关于<code>Region</code>的元数据，也被称为<code>“元数据表”</code>，又名<code>“.META.表”</code>。</p><p>当一个<code>HBase</code>表中的<code>Region</code>数量非常庞大的时候，<code>.META.表</code>也会被分裂成多个<code>Region</code>，为了定位这些<code>Region</code>，就需要再构建一个新的映射表，记录所有元数据的具体位置，这个新的映射表就是<code>“根数据表”</code>，又名<code>“-ROOT-表”</code>。</p><ul><li><code>-ROOT-表</code>是不能被分割的，<strong><u>永远只存在一个<code>Region</code>用于存放<code>-ROOT-表</code></u></strong>，<code>Master</code>主服务器永远知道它的位置。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBaseRegion.PNG" alt="Region的定位" /><figcaption aria-hidden="true">Region的定位</figcaption></figure><ul><li><code>Zookeeper</code>文件。记录了<code>-ROOT-表</code>的位置信息；</li><li>-<code>ROOT-表</code>。记录了<code>.META.表</code>的<code>Region</code>位置信息，</li><li><code>.META.表</code>。记录了用户数据表的<code>Region</code>位置信息，META表可以有多个<code>Region</code>。为了加快访问速度，<code>.META.表</code>的全部<code>Region</code>都会被保存在内存中。</li></ul><p>客户端访问用户数据时：</p><ul><li>首先访问<code>Zookeeper</code>，获取-<code>ROOT-表</code>的位置信息；</li><li>然后访问-<code>ROOT-表</code>，获得<code>.META.表</code>的信息；</li><li>接着访问<code>.META.表</code>，找到所需的<code>Region</code>具体位置；</li><li>最后到该<code>Region</code>服务器读取数据。</li></ul><p>为了加速寻址过程，一般会在客户端做缓存，把查询过的位置信息缓存起来，以后访问相同的数据时，就可以直接从客户端缓存中获取<code>Region</code>的位置信息。</p><ul><li>随着<code>HBase</code>中表的不断更新，客户端缓存的<code>Region</code>位置信息可能会失效，客户端需要访问数据时，从缓存中获取<code>Region</code>位置信息却发现不存在时，会判断出缓存失效，这时需要再次经历的<code>“三级寻址”</code>过程，重新获取最新的 <code>Region</code>位置信息去访问数据，并用最新的<code>Region</code>位置信息替换缓存中失效的信息。</li></ul><h4 id="hbase运行机制">2.4 HBase运行机制</h4><h5 id="hbase系统架构">2.4.1 HBase系统架构</h5><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBaseStructure.PNG" alt="HBase系统架构" /><figcaption aria-hidden="true">HBase系统架构</figcaption></figure><h6 id="客户端-1">1. 客户端</h6><p><code>HBase</code>客户端使用<code>HBase</code>的<code>RPC</code>机制与<code>Master</code>和<code>Region</code>服务器进行通信。</p><ul><li>对于管理类操作，客户端与<code>Master</code>进行<code>RPC</code>；</li><li>对于数据读写类操作，客户端与<code>Region</code>服务器进行<code>RPC</code>。</li></ul><h6 id="zookeeper服务器">2. Zookeeper服务器</h6><p><code>Zookeeper</code>服务器<strong><u>并非一台单一的机器，可能是由多台机器构成的集群</u></strong>来提供稳定可靠的协同服务。</p><ul><li>每个<code>Region</code>服务器都需要到<code>Zookeeper</code>中进行注册，<code>Zookeeper</code>会实时监控每个<code>Region</code>服务器的状态并通知给<code>Master</code>，这样<code>Master</code>就可以通过<code>Zookeeper</code>随时感知到各个<code>Region</code>服务器的工作状态。</li><li><code>HBase</code>中可以启动多个<code>Master</code>，但是<code>Zookeeper</code>可以<strong><u>帮助选举出一个Master作为集群的总管，并保证在任何时刻总有唯一一个 Master在运行</u></strong>，可以避免Master的<code>“单点失效”</code>问题。</li><li><code>Zookeeper</code>中保存了<code>-ROOT-表</code>的地址和<code>Master</code>的地址。当一个客户端从<code>Zookeeper</code>服务器上拿到-<code>ROOT-表</code>的地址后，就可以进行<code>“三级寻址”</code>，不用再连接主服务器<code>Master</code>。</li></ul><h6 id="master">3. Master</h6><p>主服务器<code>Master</code>主要负责<strong><u>表和<code>Region</code>的管理工作</u></strong>。</p><ul><li>管理用户对表的增加、删除、修改、查询等操作。</li><li>实现不同Region服务器之间的负载均衡。</li><li>在Region分裂或合并后，负责重新调整Region的分布。</li><li>对发生故障失效的<code>Region</code>服务器上的<code>Region</code>进行迁移。</li></ul><p><code>Master</code>仅仅维护着表和<code>Region</code>的元数据信息，因此负载很低。</p><h6 id="region服务器">4. Region服务器</h6><p><code>Region</code>服务器是<code>HBase</code>中最核心的模块，负责<strong><u>维护分配给自己的Region，并响应用户的读写请求</u></strong>。<code>HBase</code>一般采用<code>HDFS</code>作为底层存储文件系统，因此<code>Region</code>服务器需要向<code>HDFS</code>文件系统中读写数据。</p><h5 id="region服务器的工作原理">2.4.2 Region服务器的工作原理</h5><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBaseReadWrite.PNG" alt="Region服务器的工作原理" /><figcaption aria-hidden="true">Region服务器的工作原理</figcaption></figure><ul><li><p><code>Region</code>服务器内部管理了一系列<code>Region</code>对象和一个<code>HLog</code>文件，其中<code>HLog</code>是磁盘上面的记录文件，它记录着所有的更新操作。</p></li><li><p>每个<code>Region</code>对象又是由多个<code>Store</code>组成的，每个<code>Store</code>对应了表中的一个列族的存储。</p></li><li><p>每个<code>Store</code>又包含一个 <code>MemStore</code>和若干个<code>StoreFile</code>，<code>MemStore</code>是在内存中的缓存，保存最近更新的数据； <code>StoreFile</code>是磁盘中的文件，这些文件都是<strong><u>B树结构</u></strong>的，方便快速读取。</p></li><li><p><code>StoreFile</code>在底层的实现方式是<code>HDFS</code>文件系统的<code>Hfile</code>，<code>HFile</code>的数据块通常采用压缩方式存储，压缩之后可以大大减少网络<code>I/O</code>和磁盘<code>I/O</code>。</p></li></ul><h6 id="用户读写数据的过程">1. 用户读写数据的过程</h6><p>当用户写入数据时，会被分配到相应的<code>Region</code>服务器去执行操作。</p><ul><li>用户数据首先被写入到<code>MemStore</code>和<code>HLog</code>中；</li><li>当操作写入<code>HLog</code>之后，<code>commit()</code>调用才会将其返回给客户端。</li></ul><p>当用户读取数据时：</p><ul><li><code>Region</code>服务器会首先访问<code>MemStore</code>缓存；</li><li>如果数据不在缓存中，才会到磁盘上面的<code>StoreFile</code>中去寻找。</li></ul><h6 id="缓存的刷新">2.缓存的刷新</h6><p><code>MemStore</code>缓存的容量有限，系统会周期性地调用<code>Region.flushcache()</code>把<code>MemStore</code>缓存里面的内容写到磁盘的 <code>StoreFile</code>文件中，清空缓存，并在<code>HLog</code>文件中写入一个标记，用来表示缓存中的内容已经被写入<code>StoreFile</code>文件中。每次缓存刷新操作都会在磁盘上生成一个新的<code>StoreFile</code>文件，因此每个<code>Store</code>会包含多个<code>StoreFile</code>文件。</p><p>每个<code>Region</code>服务器在启动时，都会检查自己的<code>HLog</code>文件，确认最近一次执行缓存刷新操作之后是否发生新的写入操作。</p><ul><li>如果没有更新，说明所有数据已经被永久保存到磁盘的<code>StoreFile</code>文件中；</li><li>如果发现更新，就先把这些更新写入<code>MemStore</code>，然后再刷新缓存，写入到磁盘的<code>StoreFile</code>文件中。</li><li>最后，删除旧的<code>HLog</code>文件，并开始为用户提供数据访问服务。</li></ul><h6 id="storefile的合并">3. StoreFile的合并</h6><p>系统中的每个<code>Store</code>会存在多个<code>StoreFile</code>文件，当需要访问某个<code>Store</code>中的某个值时，就必须查找所有<code>StoreFile</code>文件，非常耗费时间。为了减少查找时间，系统会调用<code>Store.compact()</code>把多个<code>StoreFile</code>文件合并成一个大文件。</p><h5 id="store工作原理">2.4.3 Store工作原理</h5><p><code>Store</code>则是<code>Region</code>服务器的核心。每个<code>Store</code>对应了表中的一个列族的存储。每个<code>Store</code>包含一个<code>MemStore</code>缓存和若干个<code>StoreFile</code>文件。</p><ul><li><code>MemStore</code>是排序的内存缓冲区；</li><li>随着<code>StoreFile</code>文件数量的不断增加，到达阈值时就会触发文件合并操作；</li><li>当单个<code>StoreFile</code>文件大小超过一定阈值时，就会触发文件分裂操作。</li></ul><h5 id="hlog工作原理">2.4.4 HLog工作原理</h5><p><code>HBase</code>采用<code>HLog</code>来保证系统发生故障时能够恢复到正确的状态。</p><p><code>HLog</code>文件是一种<code>预写式日志（ Write Ahead Log）</code>，即<strong><u>用户更新数据必须首先被记入日志后才能写入 MemStore缓存，并且直到MemStore缓存内容对应的日志已经被写入磁盘之后，该缓存内容才会被刷新写入磁盘。</u></strong></p><p>当某个<code>Region</code>服务器发生故障时，<code>Zookeeper</code>会通知<code>Master</code>：</p><ul><li><code>Master</code>首先会处理该故障<code>Region</code>服务器上面遗留的<code>HLog</code>文件，其中包含了来自多个<code>Region</code>对象的日志记录。</li><li>系统会根据每条日志记录所属的<code>Region</code>对象对<code>HLog</code>数据进行拆分，分别放到相应<code>Region</code>对象的目录下，然后再将失效的<code>Region</code>重新分配到可用的<code>Region</code>服务器中。</li><li><code>Region</code>服务器领取到分配给自己的<code>Region</code>对象以及与之相关的<code>HLog</code>日志记录以后，会重新做一遍日志记录中的各种操作，把日志记录中的数据写入<code>MemStore</code>缓存，然后刷新到磁盘的<code>StoreFile</code>文件中，完成数据恢复。</li></ul><h4 id="hbase实践">2.5 HBase实践</h4><p>需要注意，<code>Hadoop</code>安装以后，只包含<code>HDFS</code>和<code>MapReduce</code>，并不包含<code>HBase</code>。关于<code>HBase</code>的常用<code>shell</code>命令和编程<code>API</code>可以在使用时查看文档。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;介绍大数据存储与管理相关技术的概念与原理，包括&lt;code&gt;Hadoop分布式文件系统（HDFS）&lt;/code&gt;、&lt;code&gt;分布式数据库（ HBase）&lt;/code&gt;、&lt;code&gt;NoSQL数据库&lt;/code&gt;和&lt;code&gt;云数据库&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="大数据" scheme="https://wuyunjie.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="大数据" scheme="https://wuyunjie.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="基础" scheme="https://wuyunjie.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[大数据技术原理|第一篇 大数据基础]</title>
    <link href="https://wuyunjie.top/2021/07/30/Big_Data_1_basic.html"/>
    <id>https://wuyunjie.top/2021/07/30/Big_Data_1_basic.html</id>
    <published>2021-07-30T06:12:33.000Z</published>
    <updated>2021-07-30T06:12:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>《大数据技术原理与应用》的学习笔记，这本书推荐的学习路线如下：</p><span id="more"></span><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/learningPath.PNG" alt="推荐的学习路线参考书籍" /><figcaption aria-hidden="true">推荐的学习路线参考书籍</figcaption></figure><h3 id="大数据概述">1. 大数据概述</h3><h4 id="大数据的概念">1.1 大数据的概念</h4><p>大数据的 <code>"4v"</code> 指的是大数据的4个特点：</p><ul><li>数据量大（<code>Volume</code>）</li><li>数据类型繁多（<code>Variety</code>）</li><li>处理速度快（<code>Velocity</code>）</li><li>价值密度低（<code>Value</code>）</li></ul><h4 id="大数据的思维方式">1.2 大数据的思维方式</h4><p>大数据时代思维方式的3种转变：</p><ul><li>全样而非抽样</li><li>效率而非精确</li><li>相关而非因果</li></ul><h4 id="大数据计算模式">1.3 大数据计算模式</h4><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/ComputeSchema.PNG" alt="大数据计算模式" /><figcaption aria-hidden="true">大数据计算模式</figcaption></figure><h5 id="批处理计算">1.3.1 批处理计算</h5><p>批处理计算主要解决针对大规模数据的批量处理：</p><ul><li><code>MapReduce</code>。将并行计算过程高度抽象为两个函数——<code>Map</code>和<code>Reduce</code>。</li><li><code>Spark</code>。针对超大数据集合的低延迟集群分布式计算系统，启用内存分布数据集，除可以交互式查询外，还可以优化迭代工作复杂。</li><li><code>MapReduce</code>数据流从一个稳定的来源加工处理后，流出到一个稳定的文件系统（如<code>HDFS</code>）；而<code>Spark</code>使用内存代替<code>HDFS</code>来存储中间结果。</li></ul><h5 id="流计算">1.3.2 流计算</h5><p>流数据是指在时间分布和数量上无限的一系列动态数据集合体，需要采用实时计算的方式给出秒级响应。</p><ul><li>商业级流计算平台。<code>IBM InfoSphere Streams</code> 和 <code>IBM StreamBase</code>等</li><li>开源流计算框架。包括 <code>Twitter Storm</code>、 <code>Yahoo！s4（ Simple Scalable Streaming System）</code>、 <code>Spark Streaming</code>等；</li><li>公司为支持自身业务开发的流计算框架。</li></ul><h5 id="图计算">1.3.3 图计算</h5><p>针对大型图的计算，需要采用图计算模式。</p><ul><li><code>Pregel</code>是一种基于<code>BSP</code>（ <code>Bulk Synchronous Parallel</code>）模型实现的并行图处理系统。<code>Pregel</code>主要用于图遍历、最短路径、 <code>PageRank</code>计算等。</li></ul><h5 id="查询分析计算">1.3.4 查询分析计算</h5><p>针对超大规模数据的存储管理和查询分析，需要提供实时或准实时的响应。</p><ul><li>谷歌公司开发的 <code>Dremel</code> 是一种可扩展的、交互式的实时查询系统，用于只读嵌套数据的分析。通过结合多级树状执行过程和列式数据结构，它能做到几秒内完成对万亿张表的聚合查询。</li><li><code>Cloudera</code>公司参考 <code>Dremel</code> 系统开发了实时查询引擎 <code>Impala</code>，它提供<code>SoL</code>语义，能快速查询存储在 <code>Hadoop</code> 的<code>HDFS</code>和 <code>HBase</code>中的PB级大数据。</li></ul><h4 id="大数据与云计算">1.4 大数据与云计算</h4><h5 id="云计算">1.4.1 云计算</h5><p>云计算实现了<strong><u>通过网络</u></strong>提供<strong>可伸缩的</strong>、<strong>廉价</strong>的分布式计算能力，用户只需要在具备网络接入条件的地方，就可以随时随地获得所需的各种<code>IT</code>资源。云计算代表了<strong><u>以虚拟化技术为核心、以低成本为目标的、动态可扩展的</u></strong>网络应用基础设施，是近年来最有代表性的网络计算技术与模式。</p><p>云计算包括3种典型的服务模式：</p><ul><li><code>IaaS</code>（基础设施即服务）</li><li><code>PaaS</code>（平台即服务）</li><li><code>SaaS</code>（软件即服务）</li></ul><p><code>Iaas</code>将基础设施（计算资源和存储）作为服务出租，<code>PaaS</code>把平台作为服务出租，<code>SaaS</code>把软件作为服务出租。</p><h5 id="云计算关键技术">1.4.2 云计算关键技术</h5><p>云计算的关键技术包括<strong>虚拟化</strong>、<strong>分布式存储</strong>、<strong>分布式计算</strong>、<strong>多租户</strong>等。</p><h6 id="虚拟化">1.4.2.1 <strong>虚拟化</strong></h6><p>虚拟化技术是指将一台计算机虚拟为多台逻辑计算机，在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。虚拟化的资源可以是硬件（如服务器、磁盘和网络），也可以是软件。</p><p><code>Hyper-V</code>、 <code>VMware</code>、<code>KWM</code>、 <code>Virtualbox</code>、<code>Xen</code>、<code>Qemu</code>等都是非常典型的虚拟化技术。</p><h6 id="分布式存储">1.4.2.2 <strong>分布式存储</strong></h6><ul><li><p><code>GFS</code>（ <code>Google File System</code>）是谷歌公司推出的一款分布式文件系统，可以满足大型、分布式、对大量数据进行访问的应用的需求。</p></li><li><p><code>HDFS</code>（ <code>Hadoop Distributed File System</code>）是对GFS的开源实现，它采用了更加简单的<code>“一次写入、多次读取”</code>文件模型，文件一旦创建、写入并关闭了，之后就只能对它执行读取操作，而不能执行任何修改操作；同时，HDFS是基于Java实现的，具有强大的跨平台兼容性。</p></li><li><p>谷歌公司后来以GFS为基础开发了分布式数据管理系统 <code>Big Table</code>，它是一个<strong>稀疏、分布、持续多维度的排序映射数组</strong>，适合于非结构化数据存储的数据库，具有高可靠性、高性能、可伸缩等特点。<code>HBase</code>是针对 <code>Big Table</code> 的开源实现。</p></li></ul><h6 id="分布式计算">1.4.2.3 分布式计算</h6><p>谷歌公司提出了并行编程模型 <code>MapReduce</code>，<code>MapReduce</code>将复杂的、运行于大规模集群上的并行计算过程抽象为两个函数——<code>Map</code>和 <code>Reduce</code>，并把一个大数据集切分成多个小的数据集，分布到不同的机器上进行并行处理，极大提高了数据处理速度，可以有效满足许多应用对海量数据的批量处理需求。 <code>Hadoop</code> 开源实现了 <code>MapReduce</code> 编程框架，被广泛应用于分布式计算。</p><h6 id="多租户">1.4.2.4 多租户</h6><p>多租户技术目的在于<u>使大量用户能够共享同一堆栈的软硬件资源，每个用户按需使用资源能够对软件服务进行客户化配置，而不影响其他用户的使用</u>。多租户技术的核心包括<strong>数据隔离</strong>、<strong>客户化配置</strong>、<strong>架构扩展</strong>和<strong>性能定制</strong>。</p><h3 id="大数据处理框架hadoop">2. 大数据处理框架<code>Hadoop</code></h3><p><code>Hadoop</code>是一个开源的、可运行于大规模集群上的分布式计算平台，它实现了 <code>MapReduce</code> 计算模型和分布式文件系统<code>HDFS</code>等功能。</p><h4 id="概述">2.1 概述</h4><h5 id="hadoop简介">2.1.1 Hadoop简介</h5><p><code>Hadoop</code>是<code>Apache</code>软件基金会旗下的一个开源分布式计算平台，为用户提供了系统底层细节透明的分布式基础架构。</p><ul><li><code>Hadoop</code>的<strong>核心</strong>是<code>分布式文件系统（ Hadoop Distributed File System, HDFS）</code>和 <code>MapReduce</code>；</li><li><code>HDFS</code>是针对<code>谷歌文件系统（ Google File System, GFS）</code>的开源实现，具有<strong>较高的读写速度</strong>、<strong>很好的容错性</strong>和<strong>可伸缩性</strong>，支持大规模数据的分布式存储，其<u><strong>冗余数据存储的方式很好地保证了数据的安全性</strong></u>。</li><li><code>MapReduce</code>是针对谷歌 <code>MapReduce</code>的开源实现，采用 <code>MapReduce</code> 来整合分布式文件系统上的数据，可保证分析和处理数据的高效性。</li></ul><h5 id="hadoop的特性">2.1.2 Hadoop的特性</h5><p><code>Hadoop</code>是一个能够对大量数据进行分布式处理的软件框架，具有以下几个方面的特性。</p><ul><li><strong>高可靠性</strong>。采用<strong><u>冗余数据存储方式</u></strong>，即使一个副本发生故障，其他副本也可以保证正常对外提供服务。</li><li><strong>高效性</strong>。作为并行分布式计算平台，<code>Hadoop</code>采用<strong>分布式存储</strong>和<strong>分布式处理</strong>两大核心技术，能够高效地处理PB级数据。</li><li><strong>高可扩展性</strong>。<code>Hadoop</code>的设计目标是可以高效稳定地运行在廉价的计算机集群上。</li><li><strong>高容错性</strong>。采用冗余数据存储方式，自动保存数据的多个副本，并且能够<strong><u>自动将失败的任务进行重新分配</u></strong>。</li><li><strong>成本低</strong>。<code>Hadoop</code>采用廉价的计算机集群，成本比较低。</li><li><strong>运行在<code>Linux</code>平台上</strong>。<code>Hadoop</code>是基于<code>Java</code> 语言开发的，可以较好地运行在 <code>Linux</code> 平台上。</li><li><strong>支持多种编程语言</strong>。<code>Hadoop</code>上的应用程序也可以使用其他语言编写。</li></ul><h4 id="hadoop生态系统">2.2 <code>Hadoop</code>生态系统</h4><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/hadoopEcoSys.png" alt="Hadoop生态系统" /><figcaption aria-hidden="true"><code>Hadoop</code>生态系统</figcaption></figure><p>除了核心的<code>HDFS</code>和<code>MapReduce</code>以外，<code>Hadoop</code>生态系统还包括 <code>Zookeeper</code>、<code>HBase</code>、<code>Hive</code>、<code>Pig</code>、<code>Mahout</code>、<code>Sqoop</code>、<code>Flume</code>、<code>Ambari</code>等功能组件。<code>Hadoop2.0</code>中新增 <code>HDFS HA</code> 和分布式资源调度管理框架<code>YARN</code>等。</p><h5 id="hdfs">2.2.1 HDFS</h5><p><code>Hadoop</code>分布式文件系统（ <code>Hadoop Distributed File System, HDFS</code>）是 <code>Hadoop</code>项目的两大核心之一。<code>HDFS</code>具有处理超大数据、流式处理、可以运行在廉价商用服务器上等优点。</p><p><code>HDFS</code>放宽了一部分<code>POSX（Portable Operating System Interface）</code>约束，从而实现以流的形式访问文件系统中的数据，提供高吞吐量应用程序数据访问功能。</p><h5 id="hbase">2.2.2 HBase</h5><p><code>HBase</code>是一个提供高可靠性、高性能、可伸缩、实时读写、分布式的<strong><u>列式数据库</u></strong>，一般采用<code>HDFS</code>作为其底层数据存储，具有强大的<strong><u>非结构化数据存储能力</u></strong>。</p><p><code>HBase</code>与传统关系数据库的一个重要区别是，前者采用<strong><u>基于列的存储</u></strong>，而后者采用<strong><u>基于行的存储</u></strong>。<code>HBase</code>具有良好的横向扩展能力，可以通过不断增加廉价的商用服务器来增加存储能力。</p><h5 id="mapreduce">2.2.3 MapReduce</h5><p><code>Hadoop MapReduce</code>是一种<strong><u>编程模型</u></strong>，用于大规模数据集的<strong><u>并行运算</u></strong>，将复杂的、运行于大规模集群上的并行计算过程高度地抽象到了两个函数——<code>Map</code>和<code>Reduce</code>上。</p><p><code>MapReduce</code>的<strong>核心思想</strong>就是<code>“分而治之”</code>，把输入的数据集切分为若干独立的数据块，分发给一个主节点管理下的各个分节点来共同并行完成；最后，通过整合各个节点的中间结果得到最终结果。</p><h5 id="hive">2.2.4 Hive</h5><p><code>Hive</code>是一个基于Hadoop的<strong><u>数据仓库工具</u></strong>，可以用于对<code>Hadoop</code>文件中的数据集进行<strong>数据整理</strong>、<strong>特殊查询</strong>和<strong>分析存储</strong>。<code>Hive</code>提供了类似于关系数据库<code>SQL</code>语言的查询语言——<code>Hive QL</code>，可以通过<code>Hive QL</code>语句快速实现简单的<code>MapReduce</code>统计，<code>Hive</code>自身可以将<code>Hive QL</code>语句转换为 <code>MapReduce</code> 任务进行运行。</p><h5 id="pig">2.2.5 Pig</h5><p><code>Pig</code>是一种<strong><u>数据流语言和运行环境</u></strong>，适合于使用Hadoop和MapReduce平台来<strong>查询大型半结构化数据集</strong>。</p><p><code>Pig</code> 在<code>MapReduce</code>的基础上创建了更简单的过程语言抽象，为<code>Hadoop</code>应用程序提供了一种更加接近<code>结构化查询语言（SQL）</code>的接口。</p><h5 id="mahout">2.2.6 Mahout</h5><p><code>Mahout</code>是<code>Apache</code>软件基金会旗下的一个开源项目，<strong><u>提供一些可扩展的机器学习领域经典算法的实现</u></strong>。<code>Mahout</code>包含许多实现，包括<strong>聚类、分类、推荐过滤、频繁子项挖掘</strong>。</p><h5 id="zookeeper">2.2.7 Zookeeper</h5><p><code>Zookeeper</code>是针对谷歌<code>Chubby</code>的一个开源实现，是高效和可靠的<strong><u>协同工作系统</u></strong>，提供分布式锁之类的基本服务（如统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等），用于构建分布式应用，减轻分布式应用程序所承担的协调任务。</p><h5 id="fiume">2.2.8 FIume</h5><p><code>Flume</code>是<code>Cloudera</code>提供的一个高可用的、高可靠的、分布式的<strong><u>海量日志采集、聚合和传输的系统</u></strong>。<code>Flume</code>支持在日志系统中定制各类数据发送方，用于收集数据；同时，<code>Flume</code>提供对数据进行简单处理并写到各种数据接受方的能力。</p><h5 id="sqoop">2.2.9 Sqoop</h5><p><code>Sqoop</code>是 <code>SQL-to-Hadoop</code> 的缩写，主要用来在<code>Hadoop</code>和关系数据库之间交换数据，可以改进数据的互操作性。通过 <code>Sqoop</code>可以方便地：</p><ul><li>将数据从<code>MySQL</code>、<code>Oracle</code>、<code>PostgreSQL</code>等关系数据库中导入<code>Hadoop</code>（可以导入<code>HDFS</code>、<code>HBase</code>或<code>Hive</code>）</li><li>将数据从<code>Hadoop</code>导出到关系数据库，使得传统关系数据库和<code>Hadoop</code>之间的数据迁移变得非常方便。</li></ul><p><code>Sqoop</code>主要通过<code>JDBC（Java DataBase Connectivity）</code>和关系数据库进行交互，理论上支持<code>JDBC</code>的关系数据库都可以使 <code>Sqoop</code>和<code>Hadoop</code>进行数据交互。</p><h5 id="ambari">2.2.10 Ambari</h5><p><code>Apache Ambari</code>是一种基于<code>web</code>的工具，支持<code>Apache Hadoop</code>集群的安装、部署、配置和管理。</p><h5 id="yarn">2.2.11 Yarn</h5><p><code>YARN （Yet Another Resource Negotiator，另一种资源协调者）</code>是一种新的 <code>Hadoop</code> 资源管理器，它是一个通用资源管理系统，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。</p><p><code>YARN</code>的基本思想是将<code>JobTracker</code>的两个主要功能（<strong>资源管理</strong>和<strong>作业调度/监控</strong>）分离，主要方法是<u>创建一个全局的ResourceManager（RM）</u>和<u>若干个针对应用程序的ApplicationMaster（AM）</u>，应用程序是指传统的<code>MapReduce</code>作业或作业的<code>DAG</code>（有向无环图）。</p><h5 id="oozie">2.2.12 Oozie</h5><p><code>Oozie</code>是一种<code>Java Web</code>应用程序，它运行在<code>Java servlet</code>容器——即<code>Tomcat</code>中，可以把多个<code>Map/Reduce</code>作业组合到一个逻辑工作单元中，从而完成更大型的任务。使用数据库来存储以下内容：</p><ul><li>工作流定义</li><li>当前运行的工作流实例，包括实例的状态和变量</li></ul><p><code>Oozie</code>工作流是放置在控制依赖<code>DAG</code>中的一组动作（例如，Hadoop的Map/Reduce作业、Pig作业等），其中指定了动作执行的顺序。</p><h5 id="spark">2.2.13 Spark</h5><p><code>Spark</code> 是专为大规模数据处理而设计的<strong>快速通用</strong>的<code>计算引擎</code>，拥有<code>Hadoop MapReduce</code>所具有的优点；但不同于<code>MapReduce</code>的是——<code>Job</code>中间输出结果可以保存在内存中，从而不再需要读写<code>HDFS</code>，因此<code>Spark</code>能更好地适用于数据挖掘与机器学习等需要迭代的<code>MapReduce</code>的算法。</p><p><code>Spark</code> 是在 <code>Scala</code> 语言中实现的，它将 <code>Scala</code> 用作其应用程序框架，<code>Scala</code> 可以像操作本地集合对象一样轻松地操作分布式数据集。实际上它是对 <code>Hadoop</code> 的补充，可以在 <code>Hadoop</code> 文件系统中并行运行。</p><h5 id="tez">2.2.14 Tez</h5><p><code>Tez</code>是一个针对<code>Hadoop</code>数据处理应用程序的新分布式执行框架。<code>Tez</code>是<code>Apache</code>最新的支持<code>DAG</code>作业的开源计算框架，它可以将多个有依赖的作业转换为一个作业从而大幅提升<code>DAG</code>作业的性能。</p><h5 id="storm">2.2.15 Storm</h5><p><code>Storm</code>为分布式实时计算提供了一组通用原语，可被用于<code>“流处理”</code>之中，实时处理消息并更新数据库。这是管理队列及工作者集群的另一种方式。<code>Storm</code>也可被用于<code>“连续计算”（continuous computation）</code>，对数据流做连续查询，在计算时就将结果以流的形式输出给用户。它还可被用于<code>“分布式RPC”</code>，以并行的方式运行昂贵的运算。</p><h5 id="kafka">2.2.16 kafka</h5><p><code>kafka</code>是由Apache软件基金会开发的一个<strong>开源流处理平台</strong>，由<code>Scala</code>和<code>Java</code>编写。<code>Kafka</code>是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。<code>Kafka</code>的目的是通过<code>Hadoop</code>的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息</p><h3 id="hadoop-的安装与使用">3. Hadoop 的安装与使用</h3><p><code>Hadoop</code>基本安装配置主要包括以下5个步骤。</p><h4 id="创建-hadoop用户">3.1 创建 Hadoop用户</h4><p>创建一个名为<code>hadoop</code>的用户运行程序，分离权限方便操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ useradd -s /bin/bash -d /home/hadoop -m hadoop</span><br><span class="line">$ passwd hadoop</span><br></pre></td></tr></table></figure><h4 id="安装-java">3.2 安装 Java</h4><p>由于 <code>Hadoop</code> 本身是使用<code>Java</code>语言编写的，因此 <code>Hadoop</code> 的开发和运行都需要<code>Java</code>的支持。</p><p>对于 <code>Ubuntu</code>本身，系统上可能已经预装了<code>Java</code>，它的<code>JDK</code>版本为 <code>openjdk</code>，路径为<code>“/usr/lib/jvm/default-java”</code>，后文中需要配置的 <code>JAVA_HOME</code> 环境变量就可以设置为这个值。</p><p>也可以自行安装<code>Oracle</code>公式的<code>Java</code>版本。</p><h4 id="设置ssh登录权限">3.3 设置SSH登录权限</h4><p>对于 <code>Hadoop</code> 的伪分布和全分布而言，<code>Hadoop</code>名称节点<code>（Name Node）</code>需要启动集群中所有机器的 <code>Hadoop</code> 守护进程，这个过程可以通过<code>SSH</code>登录来实现。为了能够顺利登录每台机器，需要将所有机器配置为名称节点可以无密码登录。</p><p>首先需要让名称节点生成自己的<code>SSH</code>密钥，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -P <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>按照默认位置，会存放在用户目录的<code>.ssh/</code>路径下。</p><p>名称节点生成自己的密钥之后，需要将它的公共密钥发送给集群中的其他机器。可以将<code>id_dsa. pub</code>中的内容添加到需要匿名登录的机器的<code>“~/ssh/authorized_keys”</code>目录下，然后名称节点就可以无密码登录这台机器。</p><h4 id="单机安装配置">3.4 单机安装配置</h4><p>将<code>hadoop</code>文件夹解压后，放置到任意文件位置如<code>“/usr/local/hadoop”</code>文件夹下。文件夹的用户和组必须都为 <code>hadoop</code>。</p><p>在 <code>Hadoop</code>的文件夹中下的<code>“etc/hadoop”</code>目录下面放置了配置文件，对于单机安装，首先需要更改 <code>hadoop-env.sh</code> 文件，以配置<code>Hadoop</code>运行的环境变量，这里只需要将<code>JAVA_HOME</code>环境变量指定到本机的<code>JDK</code>目录就可以了，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$export</span> JAVA_HOME=/usr/lib/jvm/default-java</span><br></pre></td></tr></table></figure><p>完成之后，我们可以试着查看<code>Hadoop</code>版本信息，可以运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$./bin/hadoop version</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/hadoopVersion.PNG" alt="hadoop version" /><figcaption aria-hidden="true">hadoop version</figcaption></figure><p>运行<code>hadoop</code>自带的 <code>WordCount</code>的例子来检测一下<code>Hadoop</code>安装是否成功。</p><ul><li><p>首先在 <code>hadoop</code>目录下新建 <code>input</code>文件夹，用来存放输入数据；</p></li><li><p>然后，将 <code>etc/hadoop</code>文件夹下的配置文件拷贝进 <code>input</code>文件夹中；</p></li><li><p>接下来，在<code>hadoop</code>目录下新建<code>output</code>文件夹，用来存放输出数据；</p></li><li><p>最后，运行示例程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ./input</span><br><span class="line">$ cp ./etc/hadoop/*.xml ./input</span><br><span class="line">$ cp ./etc/hadoop/*.xml ./input   <span class="comment"># 将配置文件作为输入文件</span></span><br><span class="line">$ ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep ./input ./output <span class="string">&#x27;dfs[a-z.]+&#x27;</span></span><br><span class="line">$ cat ./output/*          <span class="comment"># 查看运行结果</span></span><br></pre></td></tr></table></figure></li></ul><p>这意味着，在所有的配置文件中，只有一个符合正则表达式的单词，结果正确。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/hadoopExample.PNG" alt="hadoop example" /><figcaption aria-hidden="true">hadoop example</figcaption></figure><h4 id="伪分布式安装配置">3.5 伪分布式安装配置</h4><p>伪分布式安装是指<strong><u>在一台机器上模拟一个小的集群，但是集群中只有一个节点</u></strong>。当<code>Hadoop</code>应用于集群时，不论是伪分布式还是真正的分布式运行，都需要通过配置文件对各组件的协同工作进行设置，最重要的几个配置文件见表。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/hadoopConfigFile.PNG" alt="hadoop配置文件" /><figcaption aria-hidden="true">hadoop配置文件</figcaption></figure><p>要修改该目录下的文件<code>core-site.xml</code>和<code>hdfs-site.xml</code>来达到实现伪分布式配置。修改<code>core-site.xml</code>，将<code>&lt;configure&gt;&lt;/configure&gt;</code>修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改<code>hdfs-site.xml</code>，将<code>&lt;configure&gt;&lt;/configure&gt;</code>修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成后初始化文件系统，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hdfs namenode -format</span><br></pre></td></tr></table></figure><p>接着使用<code>sbin/start-dfs.sh</code>来开启<code>namenode</code>和<code>datanode</code>，开启后使用命令<code>jps</code>查看是否开启成功，如下图：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/startHDFS.PNG" alt="初始化文件系统" /><figcaption aria-hidden="true">初始化文件系统</figcaption></figure><p>之后可以配置<code>yarn</code>，首先复制<code>mapred-site.xml</code>配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp etc/hadoop/mapred-site.xml.template etc/hadoop/mapred-site.xml</span><br></pre></td></tr></table></figure><p>然后修改<code>etc/hadoop/mapred-site.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改<code>etc/hadoop/yarn-site.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动资源管理器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./sbin/start-yarn.sh</span><br><span class="line">$ ./sbin/mr-jobhistory-daemon.sh start historyserver <span class="comment">#查看历史任务</span></span><br></pre></td></tr></table></figure><p>关闭资源管理器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./sbin/stop-yarn.sh</span><br><span class="line">$ ./sbin/mr-jobhistory-daemon.sh stop historyserver</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;《大数据技术原理与应用》的学习笔记，这本书推荐的学习路线如下：&lt;/p&gt;</summary>
    
    
    
    <category term="大数据" scheme="https://wuyunjie.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="大数据" scheme="https://wuyunjie.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="基础" scheme="https://wuyunjie.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|二分查找]</title>
    <link href="https://wuyunjie.top/2021/07/28/Data_structure_and_algorithm_binary_search.html"/>
    <id>https://wuyunjie.top/2021/07/28/Data_structure_and_algorithm_binary_search.html</id>
    <published>2021-07-28T12:06:28.000Z</published>
    <updated>2021-07-28T12:06:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二分查找简介">1. 二分查找简介</h3><p>二分查找就是从一个有序数组中查找一个<code>key</code>值的方法，通过对数组不断二分减少遍历比较的次数。</p><span id="more"></span><p>一般二分查找形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (arr[mid] == key) <span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; key) right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>许多时候会遇到一些二分查找的变种，比如小于等于某个数的最大下标，大于等于某个数的最小下标等等，这里进行一些总结。</p><h3 id="二分查找变种">2. 二分查找变种</h3><h4 id="找出第一个与key相等的元素">2.1 找出第一个与key相等的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(arr[mid] &gt;= key) right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>( left &lt; n &amp;&amp; arr[left] == key) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找出最后一个与key相等的元素">2.2 找出最后一个与key相等的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(arr[mid] &gt; key) right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>( right&gt;=<span class="number">0</span> &amp;&amp; arr[right] == key) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找第一个等于或者大于key的元素">2.3 查找第一个等于或者大于Key的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(arr[mid] &gt;= key) right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找出第一个大于key的元素">2.4 找出第一个大于Key的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(arr[mid] &gt; key) right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找最后一个等于或者小于key的元素">2.5 查找最后一个等于或者小于key的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(arr[mid] &gt; key) right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找最后一个小于key的元素">2.6 查找最后一个小于key的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(arr[mid] &gt;= key) right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;二分查找简介&quot;&gt;1. 二分查找简介&lt;/h3&gt;
&lt;p&gt;二分查找就是从一个有序数组中查找一个&lt;code&gt;key&lt;/code&gt;值的方法，通过对数组不断二分减少遍历比较的次数。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="https://wuyunjie.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|求素数的方法]</title>
    <link href="https://wuyunjie.top/2021/07/25/Data_structure_and_algorithm_prime.html"/>
    <id>https://wuyunjie.top/2021/07/25/Data_structure_and_algorithm_prime.html</id>
    <published>2021-07-25T14:51:16.000Z</published>
    <updated>2021-07-25T14:51:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题介绍">1. 问题介绍</h3><p>求素数（质数）问题很普遍，问题很简单就是求小于某个数的素数。目前看还没有特别优化的方法，基本上都是打表，主要是在优化打表过程。这里总结一下目前求解素数的一些方法。</p><span id="more"></span><h3 id="题解">2. 题解</h3><h4 id="leetcode-204.-计数质数">2.1 leetcode-204. 计数质数</h4><blockquote><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p></blockquote><h5 id="枚举">2.1.1 枚举</h5><p>很直观的思路是枚举每个数判断其是不是质数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += isPrime(i) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度过大，为<span class="math inline">\(O(n\sqrt{n})\)</span>。</p><h5 id="埃氏筛">2.1.2 埃氏筛</h5><p>由希腊数学家厄拉多塞（<code>Eratosthenes</code>）提出，称为厄拉多塞筛法，简称埃氏筛。</p><blockquote><p>如果 <code>x</code> 是质数，那么大于 <code>x</code> 的 <code>x</code> 的倍数 <span class="math inline">\(2x,3x,\ldots\)</span> 一定不是质数。</p></blockquote><p>对于一个质数 <code>x</code>，直接从 <span class="math inline">\(x\cdot x\)</span> 开始标记，因为 <span class="math inline">\(2x,3x,\ldots\)</span> 这些数一定在 <span class="math inline">\(x\)</span>之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span>) i * i &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线性筛">2.1.3 线性筛</h5><p>埃氏筛还是存在冗余的标记操作，比如对于 45 这个数，它会同时被 3,5 两个数标记为合数。</p><p>线性筛需要多维护一个 <span class="math inline">\(\textit{primes}\)</span> 数组表示当前得到的质数集合。「标记过程」不再仅当 <span class="math inline">\(x\)</span> 为质数时才进行，而是对每个整数 <span class="math inline">\(x\)</span> 都进行。对于整数 <span class="math inline">\(x\)</span>，不再标记其所有的倍数 <span class="math inline">\(x\cdot x,x\cdot (x+1),\ldots\)</span>，而是只标记质数集合中的数与 <span class="math inline">\(x\)</span> 相乘的数，即 <span class="math inline">\(x\cdot\textit{primes}_0,x\cdot\textit{primes}_1,\ldots\)</span>且，在发现 <span class="math inline">\(x \bmod \textit{primes}_i=0\)</span> 的时候结束当前标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                primes.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.size() &amp;&amp; i * primes.get(j) &lt; n; ++j) &#123;</span><br><span class="line">                isPrime[i * primes.get(j)] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % primes.get(j) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="奇数筛">2.1.4 奇数筛</h5><p>主要用两条规则来优化埃氏筛：</p><ul><li><code>质数</code>一定是<code>奇数</code>，<code>偶数</code>一定不是<code>质数</code>。只用在<code>奇数</code>范围标记<code>合数</code>，未标记是<code>质数</code></li><li><code>奇数</code> 乘以 <code>偶数</code> 一定是 <code>偶数</code>。只用<code>奇数</code> 乘以 <code>奇数</code>，确保在<code>奇数</code>范围内标记</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] isCom = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> b = (<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">    <span class="keyword">int</span> r = n &gt; <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCom[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= b) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; i * j &lt; n; j += <span class="number">2</span>) &#123;</span><br><span class="line">                    isCom[i*j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方法更适合用于统计，不适合用于打表，因为尤其是在偶数域上，没有标记。</p><blockquote><p>不过换个思路，可以直接遍历奇数，找出奇数中的所有质数就可以得到所有质数了。只需要注意使用这个表时特殊处理就可以了。</p></blockquote><h4 id="求最大公约数">2.2 求最大公约数</h4><h5 id="短除法暴力求解">2.2.1 短除法（暴力求解）</h5><blockquote><p>采用短除法找出2个数的所有公约数，将这些公因子相乘，结果就是2个数的最大公约数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span> ; i&lt;=m &amp;&amp; i&lt;=n; ) &#123;</span><br><span class="line">    <span class="keyword">while</span>(m%i==<span class="number">0</span>&amp;&amp;n%i==<span class="number">0</span>) &#123;</span><br><span class="line">        f*=i;</span><br><span class="line">        m/=i;</span><br><span class="line">        n/=i;</span><br><span class="line">    &#125;</span><br><span class="line">  i++;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f;</span><br></pre></td></tr></table></figure><h5 id="辗转相除法">2.2.2 辗转相除法</h5><blockquote><p><strong>辗转相除法</strong>， 又名<strong>欧几里德算法</strong>（Euclidean algorithm），是求最大公约数的一种方法。它的具体做法是：</p><ul><li>用较小数除较大数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是<code>0</code>为止。<strong><u>最后的<code>除数</code>就是这两个数的最大公约数</u></strong>。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(m &lt; n) &#123;</span><br><span class="line">    tmp = m;</span><br><span class="line">    m = n;</span><br><span class="line">    n = tmp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">i = m % n;</span><br><span class="line"><span class="keyword">while</span> (i) &#123;</span><br><span class="line">  m = n;</span><br><span class="line">  n = i;</span><br><span class="line">  i = m % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f=n;</span><br></pre></td></tr></table></figure><blockquote><p>求互质数可以直接判断最大公约数是否只有<code>1</code>。</p></blockquote><h3 id="参考文献">参考文献</h3><ol type="1"><li><a href="https://leetcode-cn.com/problems/count-primes/solution/ji-shu-zhi-shu-by-leetcode-solution/">计数质数-leetcode</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;问题介绍&quot;&gt;1. 问题介绍&lt;/h3&gt;
&lt;p&gt;求素数（质数）问题很普遍，问题很简单就是求小于某个数的素数。目前看还没有特别优化的方法，基本上都是打表，主要是在优化打表过程。这里总结一下目前求解素数的一些方法。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法" scheme="https://wuyunjie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="素数" scheme="https://wuyunjie.top/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|求最长的XXX]</title>
    <link href="https://wuyunjie.top/2021/07/25/Data_structure_and_algorithm_longest_xxx.html"/>
    <id>https://wuyunjie.top/2021/07/25/Data_structure_and_algorithm_longest_xxx.html</id>
    <published>2021-07-25T11:57:33.000Z</published>
    <updated>2021-07-25T11:57:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍">1. 介绍</h3><p>经常遇见一类问题，求最长字串，最长递增序列等等，大部分求解的思路都类型，可以用动态规划求解。但遇到一些变种后，问题常常变得很困难，这里对这类问题进行一个归纳。</p><span id="more"></span><h3 id="题解">2. 题解</h3><h4 id="leetcode-1027.-最长等差数列">2.1 leetcode-1027. 最长等差数列</h4><blockquote><p>给定一个整数数组 <code>A</code>，返回 <code>A</code> 中最长等差子序列的长度。</p><p>回想一下，<code>A</code> 的子序列是列表 <code>A[i_1], A[i_2], ..., A[i_k]</code> 其中 <code>0 &lt;= i_1 &lt; i_2 &lt; ... &lt; i_k &lt;= A.length - 1</code>。并且如果 <code>B[i+1] - B[i]( 0 &lt;= i &lt; B.length - 1)</code> 的值都相同，那么序列 <code>B</code> 是等差的。</p></blockquote><p>可以用<code>dp[i][diff]</code>表示以第<code>i</code>个数为结尾，以<code>diff</code>为差值的最长子序列长度，那么可以写出其状态转移方程： <span class="math display">\[dp[i][diff] =\begin{cases}    \operatorname{max}(dp[i][diff], dp[j][diff] + 1) &amp;, dp[i-1][diff] &gt; 0 \\     \operatorname{max}(dp[i][diff], 2) &amp;, else \\ \end{cases}\\ 1 \leq j &lt; i\]</span> 即当要加入第<code>i</code>个元素时，考虑将其与之前第<code>j</code>个元素构成一个等差数列的子序列，此时有两种情况：</p><ul><li><p>之前以 <code>diff = nums[i] - nums[j]</code>组成的最长数列长度为<code>dp[j][diff]</code>（大于<code>0</code>），加入第<code>i</code>个数后，序列长度加<code>1</code>；</p></li><li><p>之前不存在以 <code>diff = nums[i] - nums[j]</code>组成的数列，则当前两个数组成新序列，此时最大长度为<code>2</code>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLen = nums.length, longest = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[numsLen][<span class="number">20002</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span> ; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> diff = nums[j] - nums[i] + <span class="number">10000</span>;</span><br><span class="line">                dp[i][diff] = Math.max(dp[i][diff], dp[j][diff] == <span class="number">0</span> ? <span class="number">2</span> : dp[j][diff] + <span class="number">1</span>);</span><br><span class="line">                longest = Math.max(longest, dp[i][diff]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="墨奇科技笔试-最长的连续的等差子数组的长度">2.2 墨奇科技笔试-最长的连续的等差子数组的长度</h4><blockquote><p>有一个整数数组，允许替换一个数字，返回替换后数组中最长的连续的等差子数组的长度。例如将8 5 2 0替换为8 5 2 -1，返回4。</p></blockquote><p>应该也可以用动态规划解决，而且是连续的子序列，应该状态不会太多。初步想法是，需要设置的状态有两个，一个是当前是否修改过数组，另一个是需要处理子序列长度为<code>3</code>时修改的方式：</p><ul><li>修改第一个节点使得符合之后的序列；</li><li>修改最后一个节点使得符合之前的序列。</li></ul><p>但这样会使得状态更新变得很复杂。使用了同学介绍的快慢指针方法，先固定一个点，遍历从这个点开始往后走可以到达的最大长度，记录下最值。为了解决上面存在两种修改方式的问题，使用了正反两遍的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSub</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">2</span>, last = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = nums[i] - nums[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (diff == last) <span class="keyword">continue</span>; <span class="comment">// 减枝</span></span><br><span class="line">        <span class="keyword">else</span> last = diff;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] - nums[j-<span class="number">1</span>] == diff) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> oldValue = nums[j];</span><br><span class="line">            <span class="keyword">int</span> oldIndex = j;</span><br><span class="line"></span><br><span class="line">            nums[j] = nums[j-<span class="number">1</span>] + diff;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] - nums[j-<span class="number">1</span>] == diff) j++;</span><br><span class="line">            nums[oldIndex] = oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        longest = Math.max(longest, j - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = nums[i] - nums[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (diff == last) <span class="keyword">continue</span>; <span class="comment">// 减枝</span></span><br><span class="line">        <span class="keyword">else</span> last = diff;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] - nums[j+<span class="number">1</span>] == diff) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> oldValue = nums[j];</span><br><span class="line">            <span class="keyword">int</span> oldIndex = j;</span><br><span class="line"></span><br><span class="line">            nums[j] = nums[j+<span class="number">1</span>] + diff;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] - nums[j+<span class="number">1</span>] == diff) j--;</span><br><span class="line">            nums[oldIndex] = oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        longest = Math.max(longest, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管例子都过了，但提交的时候没过，也没找到问题在哪。</p><h4 id="leetcode-674.-最长连续递增序列">2.3 leetcode-674. 最长连续递增序列</h4><blockquote><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p></blockquote><p>这个题很简答，用动态规划解决的经典问题，而且由于要求是连续的，降低了问题的难度。用<code>dp[i]</code>表示以第<code>i</code>个元素结尾的最长递增子序列长度，转移方程可以表示为： <span class="math display">\[dp[i] =\begin{cases}    dp[i-1] + 1 &amp;, nums[i] &gt; nums[i-1] \\     1 &amp;, else \\ \end{cases}\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            pre = nums[i] &gt; nums[i-<span class="number">1</span>] ? pre + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            maxLen = Math.max(pre, maxLen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-718.-最长重复子数组">2.4 leetcode-718. 最长重复子数组</h4><blockquote><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p></blockquote><p>最长字串问题，用<code>dp[i][j]</code>表示以<code>A</code>的第<code>i</code>个字符串结尾和<code>B</code>的第<code>j</code>个字符串结尾的最长子串长度，可以得到转移方程： <span class="math display">\[dp[i+1][j+1] =\begin{cases}    dp[i][j] + 1 &amp;, nums1[i] == nums2[j] \\     0 &amp;, else \\ \end{cases}\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j++) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = nums1[i] == nums2[j]? dp[i][j] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                longest = Math.max(longest, dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-1218.-最长定差子序列">2.5 leetcode-1218. 最长定差子序列</h4><blockquote><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>difference</code>，请你找出并返回 <code>arr</code> 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 <code>difference</code> 。</p><p>子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 <code>arr</code> 派生出来的序列。</p></blockquote><p>一开始想用<code>dp[i]</code>表示以第<code>i</code>个数结尾的最长子序列，但难以找到<code>nums[i]-difference</code>这个数的位置或者是否存在，想到了之前遇到的类似用空间换时间的方法，因为是有序的所以直接存储<code>dp[nums[i]]</code>作为以当前这个数结尾的符合定差的子序列长度，状态转移方程为： <span class="math display">\[dp[nums[i]] = dp[nums[i]-difference]\]</span> 实际上也可以用<code>HashMap</code>来实现这个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">400004</span>];</span><br><span class="line">        <span class="keyword">if</span>(difference!=<span class="number">0</span>) Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = arr[i] + <span class="number">20000</span>;</span><br><span class="line">            dp[cur + difference] = dp[cur] + <span class="number">1</span>;</span><br><span class="line">            longest = Math.max(longest, dp[cur]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = map.getOrDefault(arr[i] - difference, <span class="number">0</span> ) + <span class="number">1</span>;</span><br><span class="line">            map.put(arr[i], curLen);</span><br><span class="line"></span><br><span class="line">            longest = Math.max(longest, curLen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-300.-最长递增子序列">2.6 leetcode-300. 最长递增子序列</h4><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p></blockquote><p>用<code>dp[i]</code>表示以第<code>i</code>个元素结尾得到的最长递增子序列，与连续递增子序列类似，状态转移方程相同。不同的是，需要遍历第<code>i</code>个元素之前的所有数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, longest = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                longest = Math.max(dp[i], longest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-1143.-最长公共子序列">2.7 leetcode-1143. 最长公共子序列</h4><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。</li></ul><p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p></blockquote><p>最长字串问题，用<code>dp[i][j]</code>表示以<code>A</code>的第<code>i</code>个字符串结尾和<code>B</code>的第<code>j</code>个字符串结尾的最长子串长度，转移方程与连续子串类似。唯一不同是需要遍历所有<code>i</code>和<code>j</code>的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;介绍&quot;&gt;1. 介绍&lt;/h3&gt;
&lt;p&gt;经常遇见一类问题，求最长字串，最长递增序列等等，大部分求解的思路都类型，可以用动态规划求解。但遇到一些变种后，问题常常变得很困难，这里对这类问题进行一个归纳。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法" scheme="https://wuyunjie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="最值问题" scheme="https://wuyunjie.top/tags/%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|贪心算法]</title>
    <link href="https://wuyunjie.top/2021/07/24/Data_structure_and_algorithm_greedy_algorithm.html"/>
    <id>https://wuyunjie.top/2021/07/24/Data_structure_and_algorithm_greedy_algorithm.html</id>
    <published>2021-07-23T16:04:49.000Z</published>
    <updated>2021-07-23T16:04:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介">1. 简介</h3><h4 id="基本概念">1.1 基本概念</h4><p><code>贪心算法</code>（又称<code>贪婪算法</code>）是指，总是<u>做出在当前看来是最好的选择</u>，算法得到的是在某种意义上的<strong>局部最优解</strong>。</p><span id="more"></span><p>贪心算法不是对所有问题都能得到整体最优解，贪心算法设计的关键是贪心策略的选择。利用贪心法求解的问题应具备如下2个特征：</p><ul><li><p><strong>贪心选择性质</strong>。</p><blockquote><p>一个问题的整体最优解可通过一系列<strong>局部最优解</strong>的选择达到，并且每次的选择可以<u>依赖以前作出的选择，但不依赖于后面要作出的选择</u>。要确定一个问题是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。</p></blockquote><p>动态规划算法通常以<strong>自底向上</strong>的方式解各子问题，而贪心算法则通常以<strong>自顶向下</strong>的方式进行，以迭代的方式作出相继的贪心选择，<u>每作一次贪心选择就将所求问题简化为规模更小的子问题</u>。</p></li><li><p><strong>最优子结构性质</strong>。</p><blockquote><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</p></blockquote></li></ul><p>但该算法存在如下问题：</p><ul><li>不能保证解是最佳的。因为贪心算法总是从局部出发，并没从整体考虑；</li><li>贪心算法一般用来解决求最大或最小解；</li><li>贪心算法只能确定某些问题的可行性范围。</li></ul><h4 id="实现框架">1.2 实现框架</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">从问题的某一初始解出发;</span><br><span class="line"><span class="keyword">while</span> (能朝给定总目标前进一步) &#123;</span><br><span class="line">利用可行的决策，求出可行解的一个解元素;</span><br><span class="line">&#125;</span><br><span class="line">由所有解元素组合成问题的一个可行解；</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">Greedy(C)&#123;  <span class="comment">//C是问题的输入集合即候选集合</span></span><br><span class="line">    S=&#123; &#125;;  <span class="comment">//初始解集合为空集</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="function">not <span class="title">solution</span><span class="params">(S)</span>) </span>&#123; <span class="comment">//集合S没有构成问题的一个解</span></span><br><span class="line">       x=select(C);    <span class="comment">//在候选集合C中做贪心选择</span></span><br><span class="line">       <span class="function"><span class="keyword">if</span> <span class="title">feasible</span><span class="params">(S, x)</span>  <span class="comment">//判断集合S中加入x后的解是否可行</span></span></span><br><span class="line"><span class="function">          S</span>=S+&#123;x&#125;;</span><br><span class="line">          C=C-&#123;x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="贪心算法与动态规划的区别">1.3 贪心算法与动态规划的区别</h4><p>动态规划：</p><ul><li>态规划就是为了<strong><u>消除其重叠子问题</u></strong>而设计的，其实就是利用最优子结构和重叠子问题性质对穷举法进行优化，通过将中间结果保存在数组中，实现<strong><u>用空间来换取时间交换</u></strong>，实现程序的快速运行；</li><li>局最优解中一定包含某个局部最优解，但<strong><u>不一定包含前一个局部最优解</u></strong>，因此需要记录之前的<strong><u>所有的局部最优解</u></strong>。</li><li>动态规划自底向上，<u><strong>从叶子向根</strong>构造子问题的解</u>，对每一个子树的根，求出下面每一个叶子的值，最后得到一棵完整的树，并且最终选择其中的最优值作为自身的值；</li><li>动态规划本质是穷举法，可以保证结果是最佳的，复杂度高。</li></ul><p>贪心算法：</p><ul><li>贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次；</li><li>每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留；</li><li>贪心<strong>从根出发</strong>，每次<u>向下遍历最优子树</u>即可（通常这个“最优”都是基于当前情况下显而易见的“最优”），不需要知道一个节点的所有子树情况，于是构不成一棵完整的树；</li><li>贪心不能保证求得的最后解是最佳的，一般复杂度低。</li></ul><h3 id="题解">2. 题解</h3><h4 id="leetcode-455.-分发饼干">2.1 leetcode-<a href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a></h4><blockquote><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p></blockquote><p>根据贪心的思想，每次都把当前最大的饼干，分给它可以满足的孩子中胃口最大的一个，这样使得之后小的饼干可以分配给胃口较小的孩子，得到局部最优解，使得尽可能多的孩子得到满足。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(g); Arrays.sort(s);</span><br><span class="line">        <span class="keyword">int</span> index = g.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (index &gt;= <span class="number">0</span> &amp;&amp; g[index] &gt; s[i]) &#123;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            res++;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="活动安排问题">2.2 活动安排问题</h4><blockquote><p>设有<code>N</code>个活动时间集合，每个活动都要使用同一个资源，比如说会议场，而且同一时间内只能有一个活动使用这个资源，每个活动<code>i</code>都有一个使用活动的开始<code>si</code>和结束时间<code>fi</code>，即使用区间为<code>[si, fi]</code>，现在要求分配活动占用时间表，要求从所给的活动集合中选出最大的相容活动子集合。</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(i\)</span></th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th><th style="text-align: center;">8</th><th style="text-align: center;">9</th><th style="text-align: center;">10</th><th style="text-align: center;">11</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(s[i]\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">3</td><td style="text-align: center;">0</td><td style="text-align: center;">5</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td><td style="text-align: center;">8</td><td style="text-align: center;">8</td><td style="text-align: center;">2</td><td style="text-align: center;">12</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(f[i]\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">8</td><td style="text-align: center;">9</td><td style="text-align: center;">10</td><td style="text-align: center;">11</td><td style="text-align: center;">12</td><td style="text-align: center;">13</td><td style="text-align: center;">14</td></tr></tbody></table></blockquote><p>首先将各活动的按结束时间进行排序，每次选择满足条件的最小结束时间活动，使得每次选择的都是耗时尽可能小的活动，达到局部最优。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">arrangeActivity</span><span class="params">(<span class="keyword">int</span>[] s, <span class="keyword">int</span>[] e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = s.length;</span><br><span class="line">    <span class="keyword">int</span> endFlag = e[<span class="number">0</span>];</span><br><span class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    results.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; endFlag) &#123;</span><br><span class="line">            results.add(i);</span><br><span class="line">            endFlag = e[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-435.-无重叠区间">2.3 leetcode-<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h4><blockquote><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p></blockquote><p>实际上和活动安排的解题思路一致，每次都加入最下可满足的区间，否则就删除这个区间，最后得到的是可以使得填满当前所在序列上的最大区间数，也是最小删除次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[<span class="number">1</span>] - nums2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftFlag = Integer.MIN_VALUE, deleteCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; leftFlag) &#123;</span><br><span class="line">                deleteCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftFlag = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deleteCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-1353.-最多可以参加的会议数目">2.4 leetcode-<a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/">1353. 最多可以参加的会议数目</a></h4><blockquote><p>给你一个数组 <code>events</code>，其中 <code>events[i] = [startDayi, endDayi]</code> ，表示会议 <code>i</code> 开始于 <code>startDayi</code> ，结束于 <code>endDayi</code> 。</p><p>你可以在满足 <code>startDayi &lt;= d &lt;= endDayi</code> 中的任意一天 <code>d</code> 参加会议 <code>i</code> 。注意，一天只能参加一个会议。</p><p>请你返回你可以参加的 <strong>最大</strong> 会议数目。</p></blockquote><p>贪心的思想，对于第 <code>i</code> 天，如果有若干的会议都可以在这一天开，那么肯定是让 <code>endDayendDay</code> 小的会议先在这一天开才会使答案最优，因为 <code>endDayendDay</code> 大的会议可选择的空间是比 <code>endDayendDay</code> 小的多的，所以在满足条件的会议需要让 <code>endDayendDay</code> 小的先开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEvents</span><span class="params">(<span class="keyword">int</span>[][] events)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据开始时间排序</span></span><br><span class="line">        Arrays.sort(events, Comparator.comparingInt(o -&gt; o[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, curDay = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; canJoin = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;events.length||!canJoin.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!canJoin.isEmpty()&amp;&amp;canJoin.peek()&lt;curDay)&#123;<span class="comment">//可能有些已经超过参加时间了，处理一下</span></span><br><span class="line">                canJoin.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;events.length&amp;&amp;events[i][<span class="number">0</span>]&lt;=curDay)&#123;<span class="comment">//把当前能够参加的会议的结束时间都丢进canJoin中，</span></span><br><span class="line">                canJoin.add(events[i++][<span class="number">1</span>]);                <span class="comment">//当前不能参加的表示startDay还没到，之后可能还有机会参加</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!canJoin.isEmpty())&#123;</span><br><span class="line">                canJoin.poll();</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            curDay++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEvents</span><span class="params">(<span class="keyword">int</span>[][] events)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先排序：开始时间小的在前。这样是方便我们顺序遍历，把开始时间一样的都放进堆</span></span><br><span class="line">        Arrays.sort(events, (o1, o2) -&gt; o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">//结果、开始时间、events下标、有多少组数据</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, last = <span class="number">1</span>, i = <span class="number">0</span>, n = events.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n || !pq.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//将start相同的会议都放进堆里</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; events[i][<span class="number">0</span>] == last) &#123;</span><br><span class="line">                pq.offer(events[i++][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//pop掉当前天数之前的</span></span><br><span class="line">            <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; pq.peek() &lt; last) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//顶上的就是要参加的</span></span><br><span class="line">            <span class="keyword">if</span> (!pq.isEmpty()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-452.-用最少数量的箭引爆气球">2.5 leetcode-<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h4><blockquote><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 <code>x</code> 轴从不同点完全垂直地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>xstart</code>，<code>xend</code>， 且满足 <code>xstart ≤ x ≤ xend</code>，则该气球会被引爆。可以射出的弓箭的数量没有限制。弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 <code>points</code> ，其中 <code>points [i] = [xstart,xend]</code> ，返回引爆所有气球所必须射出的最小弓箭数。</p></blockquote><p>利用贪心思想，每个气球肯定会被一只箭射中，所以每次都找到在这个气球的范围内，可以引爆最大的气球数量。不断重复直至没有气球为止：</p><ul><li>首先按开始横坐标进行排序；</li><li>然后将当前可以被同时击中的气球放入同一个集合中(双指针实现)</li><li>直到无法增加新气球，消耗一只箭，进入下一轮统计</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">1</span>] &lt; o2[<span class="number">1</span>] ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] &lt; o2[<span class="number">0</span>] ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minArrows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; points.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> curLeft = points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j &lt; points.length &amp;&amp; points[j][<span class="number">0</span>] &lt;= points[i][<span class="number">1</span>] &amp;&amp; curLeft &gt;= points[j][<span class="number">0</span>])&#123;</span><br><span class="line">                curLeft = Math.min(curLeft, points[j][<span class="number">1</span>]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            i = j;</span><br><span class="line">            minArrows++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minArrows++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="背包问题">2.6 背包问题</h4><blockquote><p>有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。 要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</p></blockquote><ul><li>目标函数：<span class="math inline">\(\sum p_i\)</span>最大</li><li>约束条件是装入的物品总质量不超过背包容量：<span class="math inline">\(\sum w_i&lt;=M\)</span></li></ul><p>思考几种贪心策略及其反例：</p><ol type="1"><li><p>根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">W=<span class="number">30</span></span><br><span class="line">物品：A B C</span><br><span class="line">重量：<span class="number">28</span> <span class="number">12</span> <span class="number">12</span></span><br><span class="line">价值：<span class="number">30</span> <span class="number">20</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>根据策略，首先选取物品<code>A</code>，此时无法继续放入其他物品，但最优解为<code>B、C</code>。</p></li><li><p>每次挑选所占重量最小的物品装入是否能得到最优解？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">W=<span class="number">30</span></span><br><span class="line">物品：A B C</span><br><span class="line">重量：<span class="number">28</span> <span class="number">20</span> <span class="number">10</span></span><br><span class="line">价值：<span class="number">28</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>根据策略，首先选取物品<code>B、C</code>，此时无法继续放入其他物品，但最优解为<code>A</code>。</p></li><li><p>每次选取单位重量价值最大的物品。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">W=30</span><br><span class="line">物品：A B C</span><br><span class="line">重量：28 20 10</span><br><span class="line">价值：28 20 10</span><br></pre></td></tr></table></figure><p>三种物品单位重量价值一样时，无法得到最优解。可以在此基础上加入策略，遇见单位价值相同的时候，优先装重量小的，这样可以获取最优解。</p></li></ol><h3 id="总结">3. 总结</h3><ul><li>注意一般都需要先进行排序，使得当前的序列可以满足我们选择局部最优解；</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;1. 简介&lt;/h3&gt;
&lt;h4 id=&quot;基本概念&quot;&gt;1.1 基本概念&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;贪心算法&lt;/code&gt;（又称&lt;code&gt;贪婪算法&lt;/code&gt;）是指，总是&lt;u&gt;做出在当前看来是最好的选择&lt;/u&gt;，算法得到的是在某种意义上的&lt;strong&gt;局部最优解&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法" scheme="https://wuyunjie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|并查集]</title>
    <link href="https://wuyunjie.top/2021/07/23/Data_structure_and_algorithm_union-find.html"/>
    <id>https://wuyunjie.top/2021/07/23/Data_structure_and_algorithm_union-find.html</id>
    <published>2021-07-23T07:05:20.000Z</published>
    <updated>2021-07-23T07:05:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="并查集介绍">1. 并查集介绍</h3><p>并查集（UnionFindSet）主要用于解决动态连通性问题，判断一个图中两个点是否连同。开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间反复查找一个元素在哪个集合中。</p><span id="more"></span><p>并查集顾名思义就是有<code>“合并集合”</code>和<code>“查找集合中的元素”</code>两种操作的关于数据结构的一种算法，它的名字中<code>“并”</code>、<code>“査”</code>、<code>“集”</code>分别取自<code>Union</code>(合并)、<code>Find</code>(査找)、<code>Set</code>(集合)这3个单词。</p><h4 id="并查集的数据结构">1.1 并查集的数据结构</h4><p>并查集在使用中以<strong><u>森林</u></strong>来表示，维护一个数组<code>father[]</code>记录每个结点<code>x</code>的父亲结点<code>father[x]</code>。</p><p>初始状态将每个节点看作一棵只有一个节点的数，此时每个节点的父节点都指向它本身，即<code>father[x] = x</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] findSet = <span class="keyword">null</span>; <span class="comment">// 即father</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    findSet = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后通过不断加入边，更新<code>father[]</code>数组将多棵树合并。如下图是一个森林的<code>father</code>数组：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/algorithm/UnionFind.png" alt="并查集森林" /><figcaption aria-hidden="true">并查集森林</figcaption></figure><h4 id="并查集的查找">1.2 并查集的查找</h4><p>查找元素<code>x</code>所在的集合，即找到<code>x</code>的根节点的标号。同一个集合中<u>只存在一个根结点</u>，因此查找操作就是对给定的结点寻找其根结点的过程。查找方法是：通过反复寻找父亲结点，直到找到根结点(即<code>father[x]=x</code>的结点)。比如要查找节点<code>4</code>的根节点，流程如下：</p><ul><li>x=4，father[x] = 2，不是根节点(4 != father[4])，继续查找；</li><li>x=2，father[x] = 1，不是根节点，继续查找；</li><li>x=1，father[x] = 1，满足根节点条件，返回根节点<code>1</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == findSet[cur]) <span class="keyword">return</span> cur;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findSet[cur];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并查集的合并">1.3 并查集的合并</h4><p>合并是指把两个集合合并成一个集合，通过两个元素<code>x</code>，<code>y</code>，把这两个元素所在的集合合并<code>Union(x, y)</code>。合并过程只需要把其中一个集合的根结点设置为另一个集合根结点的孩子即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    xRoot = Find(x);</span><br><span class="line">    yRoot = Find(y);</span><br><span class="line">    <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">        findSet[xRoot] = yRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路径压缩">1.4 路径压缩</h4><p>在并查集查找中，查找元素<code>x</code>所在的集合的运算次数=元素<code>x</code>所在的深度。极端情况下，如果整棵树构造成了一个链，元素过多时深度会过深，时间复杂度过大。这里需要对森林中的树进行优化。</p><p>可以发现最优化的时候，即每棵树中非根节点都刚好指向跟节点，此时每个孩子节点的深度都为<code>2</code>。复杂度从<code>O(n)</code>降为了<code>O(1)</code>。</p><p>该优化过程可以在查找过程中实现，查找到跟节点后，同步更新当前节点的根节点，这个过程即<strong><u>路径压缩</u></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == findSet[cur]) <span class="keyword">return</span> cur;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        findSet[cur] = Find(findSet[cur]);  <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> findSet[cur];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，在合并过程中也可以进行优化，尽量降低树的深度。每次合并中，将深度较小的树作为另一棵树的子树，这时需要一个额外的数组<code>rank</code>来记录当前各树的深度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加权 Quick Union</span></span><br><span class="line"><span class="comment">// 合并x和y所在的集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x); <span class="comment">//找到x所在的集合，即x的根节点</span></span><br><span class="line">    <span class="keyword">int</span> fy = find(y); <span class="comment">//找到y所在集合，即y的根节点</span></span><br><span class="line">    <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rank[fx] &gt; rank[fy]) &#123; <span class="comment">// y 所在的树深度较小，y 合并到 x</span></span><br><span class="line">        father[fy] = fx;</span><br><span class="line">        <span class="keyword">if</span>(rank[fy]+<span class="number">1</span>&gt;rank[fx]) &#123; <span class="comment">//如果挂上fy之后深度增加</span></span><br><span class="line">            rank[fx]=rank[fy]+<span class="number">1</span>; <span class="comment">//这里的秩为深度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;           </span><br><span class="line">        father[fx] = fy;</span><br><span class="line">        <span class="keyword">if</span>(rank[fx]+<span class="number">1</span>&gt;rank[fy]) rank[fy]=rank[fx]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并查集模板">1.5 并查集模板</h4><p>一般并查集都比较模板化，实现都差不多，直接并查集模板如下，这里没有用<code>加权 Quick Union</code>，简化模板。太复杂的记不住。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] findSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        findSet = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            findSet[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == findSet[cur]) <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            findSet[cur] = Find(findSet[cur]);</span><br><span class="line">            <span class="keyword">return</span> findSet[cur];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xRoot = Find(x);</span><br><span class="line">        <span class="keyword">int</span> yRoot = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">            findSet[xRoot] = yRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Find(x) == Find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解">2. 题解</h3><h4 id="leetcode-1202.-交换字符串中的元素">2.1 leetcode-1202. 交换字符串中的元素</h4><blockquote><p>给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。</p><p>你可以 任意多次交换 在 pairs 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。</p></blockquote><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]</span><br><span class="line">输出：&quot;bacd&quot;</span><br><span class="line">解释： </span><br><span class="line">交换 s[0] 和 s[3], s = &quot;bcad&quot;</span><br><span class="line">交换 s[1] 和 s[2], s = &quot;bacd&quot;</span><br></pre></td></tr></table></figure><p>由于可以交换任意次数，所以存在情况 <code>pairs = [[0, 1], [1, 2]]</code>，这时候<code>0, 1, 2</code>位置上的元素可以任意交换，所以可以看出他们形成了一个集合。可以将其转化为一个图论的问题，需要找出同属于一个连通分量的所有字符，然后把「连在一起」的索引按照字符的 <code>ASCII</code> 值升序排序，可以使用并查集来寻找这些连通分量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] father;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            father = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                father[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (father[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">            father[x] = Find(father[x]);</span><br><span class="line">            <span class="keyword">return</span> father[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> xRoot = Find(x);</span><br><span class="line">            <span class="keyword">int</span> yRoot = Find(y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">                father[xRoot] = yRoot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">smallestStringWithSwaps</span><span class="params">(String s, List&lt;List&lt;Integer&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span> || pairs.size() == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        UnionFind pairUF = <span class="keyword">new</span> UnionFind(sLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; pair : pairs) &#123;</span><br><span class="line">            pairUF.Union(pair.get(<span class="number">0</span>), pair.get(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于每个并查集中的集合, 用优先队列存储字符, 使得字符有序</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        Map&lt;Integer, PriorityQueue&lt;Character&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> root = pairUF.Find(i);</span><br><span class="line">             map.computeIfAbsent(root, key -&gt; <span class="keyword">new</span> PriorityQueue&lt;&gt;()).offer(charArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于每个位置的字符, 用其对应的优先队列中的最小字符替换</span></span><br><span class="line">        StringBuilder newStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> root = pairUF.Find(i);</span><br><span class="line">            newStr.append( map.get(root).poll() );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newStr.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-399.-除法求值">2.2 leetcode-399. 除法求值</h4><blockquote><p>给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p><p>另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。</p><p>注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p></blockquote><p><strong>变量之间的倍数关系具有传递性</strong>，处理有传递性关系的问题，可以使用「并查集」。分析示例 1：</p><ul><li><p><span class="math inline">\(a / b = 2.0\)</span> 说明 <span class="math inline">\(a = 2b\)</span>， <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 在同一个集合中；</p></li><li><p><span class="math inline">\(b / c = 3.0\)</span>​ 说明 <span class="math inline">\(b = 3c\)</span>​ ，<span class="math inline">\(b\)</span> 和 <span class="math inline">\(c\)</span> 在同一个集合中。</p></li><li><p>求 <span class="math inline">\(\cfrac{a}{c}\)</span>，可以把 <span class="math inline">\(a = 2b\)</span>，<span class="math inline">\(b = 3c\)</span> 依次代入，得到 <span class="math inline">\(\cfrac{a}{c} = \cfrac{2b} {c} = \cfrac{2 \cdot 3c} {c} = 6.0\)</span>；</p></li><li><p>求 <span class="math inline">\(\cfrac{b}{a}\)</span>，可以把 <span class="math inline">\(b\)</span> 和 <span class="math inline">\(a\)</span> 都转换成为 <span class="math inline">\(c\)</span> 的倍数，<span class="math inline">\(\cfrac{b}{a} = \cfrac{b} {2b} = \cfrac{3c} {6c} = \cfrac{1}{2} = 0.5\)</span></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = equations.size();</span><br><span class="line"></span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(len*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++ ) &#123;</span><br><span class="line">            List&lt;String&gt; cur = equations.get(i);</span><br><span class="line">            uf.union(cur.get(<span class="number">0</span>), cur.get(<span class="number">1</span>), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> queriesSize = queries.size();</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queriesSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queriesSize; i++) &#123;</span><br><span class="line">            String val1 = queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String val2 = queries.get(i).get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            res[i] = uf.isConnected(val1, val2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; father;</span><br><span class="line">        HashMap&lt;String, Double&gt; weights;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            father = <span class="keyword">new</span> HashMap&lt;&gt;(len);</span><br><span class="line">            weights = <span class="keyword">new</span> HashMap&lt;&gt;(len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">            String curFather = father.computeIfAbsent(x, key -&gt; x);</span><br><span class="line">            weights.computeIfAbsent(x, key -&gt; <span class="number">1.0d</span>);</span><br><span class="line">            <span class="keyword">if</span> (!curFather.equals(x)) &#123;</span><br><span class="line">                String lastFather = curFather;</span><br><span class="line">                curFather = find(curFather);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">double</span> weight = weights.computeIfAbsent(lastFather, key -&gt; <span class="number">1.0d</span>);</span><br><span class="line">                weights.put(x, weight * weights.computeIfAbsent(x, key -&gt; <span class="number">1.0d</span>));</span><br><span class="line">                father.put(x, curFather);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curFather;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(String x, String y, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">            String rootX = find(x);</span><br><span class="line">            String rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (!rootX.equals(rootY)) &#123;</span><br><span class="line">                father.put(rootX, rootY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 关系式的推导</span></span><br><span class="line">                weights.put(rootX, weights.get(y) * value / weights.get(x));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">isConnected</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!father.containsKey(x) || !father.containsKey(y)) <span class="keyword">return</span> -<span class="number">1.0d</span>;</span><br><span class="line"></span><br><span class="line">            String rootX = find(x);</span><br><span class="line">            String rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX.equals(rootY)) &#123;</span><br><span class="line">                <span class="keyword">return</span> weights.get(x) / weights.get(y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1.0d</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题-17.07.-婴儿名字">2.3 <a href="https://leetcode-cn.com/problems/baby-names-lcci/">面试题 17.07. 婴儿名字</a></h4><blockquote><p>每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John 和 Jon 本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果 John 和 Jon 是相同的，并且 Jon 和 Johnny 相同，则 John 与 Johnny 也相同，即它们有传递和对称性。</p><p>在结果列表中，选择 字典序最小 的名字作为真实名字。</p></blockquote><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;John(15)&quot;,&quot;Jon(12)&quot;,&quot;Chris(13)&quot;,&quot;Kris(4)&quot;,&quot;Christopher(19)&quot;], synonyms = [&quot;(Jon,John)&quot;,&quot;(John,Johnny)&quot;,&quot;(Chris,Kris)&quot;,&quot;(Chris,Christopher)&quot;]</span><br><span class="line">输出：[&quot;John(27)&quot;,&quot;Chris(36)&quot;]</span><br></pre></td></tr></table></figure><p>分析条件中，强调的传递性和关系，又是一个求连通子图的题，可以使用并查集直接求解。主要是数据处理上很麻烦，需要处理很多字符串的切分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 并查集</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind1</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind1</span><span class="params">(String[] names)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">                map.put(name, name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 并</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(String name1, String name2)</span> </span>&#123;</span><br><span class="line">            String parent1 = find(name1);</span><br><span class="line">            <span class="keyword">if</span> (parent1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent1 = name1;</span><br><span class="line">            &#125;</span><br><span class="line">            String parent2 = find(name2);</span><br><span class="line">            <span class="keyword">if</span> (parent2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent2 = name2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!parent1.equals(parent2)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent2.compareTo(parent1) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    map.put(parent2, parent1);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(parent1, parent2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查</span></span><br><span class="line">        <span class="function">String <span class="title">find</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (name.equals(map.get(name))) &#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> find(map.get(name));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] trulyMostPopular(String[] names, String[] synonyms) &#123;</span><br><span class="line">        <span class="comment">// 初始化并查集</span></span><br><span class="line">        String[] nameArray = Arrays.stream(names).map(ele -&gt; ele.substring(<span class="number">0</span>, ele.indexOf(<span class="string">&quot;(&quot;</span>))).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        UnionFind1 uf = <span class="keyword">new</span> UnionFind1(nameArray);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String syn : synonyms) &#123;</span><br><span class="line">            String[] array = syn.replace(<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27; &#x27;</span>).replace(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27; &#x27;</span>).trim().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            uf.union(array[<span class="number">0</span>], array[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算数字</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String item : names) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = item.indexOf(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            String name = item.substring(<span class="number">0</span>, index);</span><br><span class="line">            <span class="keyword">int</span> num = Integer.parseInt(item.substring(index + <span class="number">1</span>, item.length() - <span class="number">1</span>));</span><br><span class="line">            name = uf.find(name);</span><br><span class="line">            map.put(name, map.getOrDefault(name, <span class="number">0</span>) + num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.entrySet().stream().map(ele -&gt; String.format(<span class="string">&quot;%s(%d)&quot;</span>, ele.getKey(), ele.getValue())).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-1631.-最小体力消耗路径">2.4 leetcode-1631. 最小体力消耗路径</h4><blockquote><p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <code>0</code> 开始编号）。你每次可以往 <strong>上，下，左，右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p><p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p><p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p></blockquote><p>可以将本题抽象成如下的一个图论模型：</p><ul><li><p>将地图中的每一个格子看成图中的一个节点；</p></li><li><p>将两个相邻（左右相邻或者上下相邻）的两个格子对应的节点之间连接一条无向边，边的权值为这两个格子的高度差的绝对值；</p></li><li><p>需要找到一条从左上角到右下角的最短路径，其中一条路径的长度定义为其经过的所有边权的最大值。</p></li></ul><p>可以将图中的所有边按照权值从小到大进行排序，并依次加入并查集中。当加入一条权值为 <code>x</code> 的边之后，如果左上角和右下角从非连通状态变为连通状态，那么 <code>x</code> 即为答案。可以参考力扣上的博客：<a href="https://leetcode-cn.com/problems/path-with-minimum-effort/solution/duo-tu-xiang-xi-fen-xi-jie-ti-si-lu-fen-7z89x/">多图详细分析解题思路，分享刷题心得</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] findSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">            findSet = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                findSet[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == findSet[cur]) <span class="keyword">return</span> cur;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                findSet[cur] = Find(findSet[cur]);</span><br><span class="line">                <span class="keyword">return</span> findSet[cur];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> xRoot = Find(x);</span><br><span class="line">            <span class="keyword">int</span> yRoot = Find(y);</span><br><span class="line">            <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">                findSet[xRoot] = yRoot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Find(x) == Find(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span> <span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.begin = begin;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="keyword">int</span>[][] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = heights.length;</span><br><span class="line">        <span class="keyword">int</span> colunms = heights[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(rows*colunms);</span><br><span class="line">        PriorityQueue&lt;Edge&gt; edgeQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Edge&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge e1, Edge e2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> e1.value - e2.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> curValue;</span><br><span class="line">        Edge curE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colunms; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = i*colunms+j;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; rows-<span class="number">1</span>) &#123;</span><br><span class="line">                    curValue = Math.abs(heights[i+<span class="number">1</span>][j] - heights[i][j]); </span><br><span class="line">                    curE = <span class="keyword">new</span> Edge(id, id + colunms, curValue);</span><br><span class="line">                    edgeQ.offer(curE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(j &lt; colunms-<span class="number">1</span>) &#123;</span><br><span class="line">                    curValue = Math.abs(heights[i][j+<span class="number">1</span>] - heights[i][j]); </span><br><span class="line">                    curE = <span class="keyword">new</span> Edge(id, id + <span class="number">1</span>, curValue);</span><br><span class="line">                    edgeQ.offer(curE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> last = rows*colunms-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!edgeQ.isEmpty()) &#123;</span><br><span class="line">            curE = edgeQ.poll();</span><br><span class="line">            uf.Union(curE.begin, curE.end);</span><br><span class="line">            <span class="keyword">if</span> (uf.Connected(<span class="number">0</span>, last)) <span class="keyword">return</span> curE.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">3. 总结</h3><p>总结起来并查集可以解决的问题存在以下性质：</p><ul><li>可以转化为寻找连通分量；</li><li>元素之间的关系具备传递性；</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;并查集介绍&quot;&gt;1. 并查集介绍&lt;/h3&gt;
&lt;p&gt;并查集（UnionFindSet）主要用于解决动态连通性问题，判断一个图中两个点是否连同。开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间反复查找一个元素在哪个集合中。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法" scheme="https://wuyunjie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="并查集" scheme="https://wuyunjie.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|动态规划]</title>
    <link href="https://wuyunjie.top/2021/07/22/Data_structure_and_algorithm_dynamic_programming.html"/>
    <id>https://wuyunjie.top/2021/07/22/Data_structure_and_algorithm_dynamic_programming.html</id>
    <published>2021-07-22T08:37:30.000Z</published>
    <updated>2021-07-22T08:37:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态规划概述">1. 动态规划概述</h3><h4 id="简介">1.1 简介</h4><p>动态规划（<code>dynamic programming</code>）可以理解为是对递归算法的一种优化，是R.E.Bellman等人在研究多阶段决策过程(<code>multistep decision process</code>)的优化问题时，提出的最优化原理(<code>principle of optimality</code>)，即把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系逐个求解。</p><blockquote><p><code>dynamic programming</code>的名字是为了<a href="https://www.zhihu.com/question/39948290/answer/83920614">规避军方的厌恶</a></p></blockquote><span id="more"></span><h4 id="基本思想">1.2 基本思想</h4><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。动态规划过程是：</p><blockquote><p><strong><u>每次决策依赖于当前状态，又随即引起状态的转移</u></strong>。</p></blockquote><p>动态规划将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。能采用动态规划求解的问题的一般要具有3个性质：</p><ul><li><strong>最优化原理</strong>：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</li><li><strong>无后效性</strong>：即某阶段状态一旦确定，就不受这个状态以后决策的影响。</li><li><strong>有重叠子问题</strong>：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。这<strong><u>并非必要条件</u></strong>，但满足这个条件动态规划才能发挥出较大的优势。</li></ul><h4 id="求解的基本步骤">1.3 求解的基本步骤</h4><p>动态规划一般要经历以下几个步骤：</p><ul><li><strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。</li><li><strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的不同的状态表示出来。确定<code>状态</code>需要满足<strong>最优化原理</strong>和<strong>无后效性</strong>。</li><li><strong>确定决策并写出状态转移方程</strong>：根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</li><li><strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</li></ul><p>可以看出，动态规划最主要的两个核心部分是：<code>DP 状态</code>和<code>DP 转移方程</code>。整个求解过程可以用一个<strong><u>最优决策表</u></strong>来描述：</p><ul><li><code>最优决策表</code>是一个<strong>二维表</strong>，其中<strong><u>行表示决策的阶段</u></strong>，列表示<strong><u>问题状态</u></strong>，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值；</li><li>填表的过程就是根据递推关系，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</li></ul><h4 id="动态规划与递归">1.4 动态规划与递归</h4><p>动态规划是<strong>自底向上</strong>，递归树是<strong>自顶向下</strong>。</p><ul><li><p><strong>自顶向下</strong>的递归。从规模较大的原问题比如说 <span class="math inline">\(f(n)\)</span>，向下逐渐分解规模直到边界条件<span class="math inline">\(f(1)\)</span>触底，然后逐层返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> Fibonacci1(n-<span class="number">1</span>) + Fibonacci1(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>自底向上</strong>的动态规划。从问题规模最小的<span class="math inline">\(f(1)\)</span>，直到推到得到原问题答案<span class="math inline">\(f(n)\)</span>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[N + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="变体">1.4 变体</h4><h5 id="数位dp">1.4.1 <code>数位dp</code></h5><p>可以看这个视频：<a href="https://www.bilibili.com/video/BV1ip4y1v7zw?from=search&amp;seid=13099671920328002016">数位DP</a>。数位DP解决的问题是：</p><blockquote><p>求出在给定区间<span class="math inline">\([A,B]\)</span>内，符合条件<span class="math inline">\(f(i)\)</span>的数<span class="math inline">\(i\)</span>的个数。条件<span class="math inline">\(f(i)\)</span>一般与数的大小无关，而与数的组成有关由于数是按位dp，<strong>数的大小对复杂度的影响很小</strong>。</p></blockquote><p>暴力解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=A; i&lt;=B; i++)</span><br><span class="line"><span class="keyword">if</span>(f(i)) ans++;</span><br></pre></td></tr></table></figure><p>引入数位的概念，使得新的枚举方式满足dp的性质，然后记忆化搜索。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/dp/numBitBP.PNG" alt="数位搜索" /><figcaption aria-hidden="true">数位搜索</figcaption></figure><p>从起点向下搜索，到最底层得到方案数，一层一层向上返回答案并累加，最后从搜索起点得到最终答案。主要涉及以下参数：</p><ul><li>数位dp基本的量数字位数<code>pos</code>，记录答案的<code>st</code>；</li><li>最高位限制<code>limit</code>。</li><li>判断<strong>前导0</strong>的标记<code>lead</code>。部分题目中，前导0会影响答案结果，需要进行区分。</li><li>经常要比较当前位和前一位或前几位的关系，一般在<code>dfs()</code>中也要记录前一位或前几位数<code>pre</code>。</li><li>更多参量以区分状态，视题意而定。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">long</span> dp[<span class="number">20</span>][state];<span class="comment">//不同题目状态不同</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="comment">/*其他state变量*/</span>,<span class="keyword">boolean</span> lead<span class="comment">/*前导零*/</span>,<span class="keyword">boolean</span> limit<span class="comment">/*数位上界变量*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归边界，按位枚举最低位是0，pos &lt; 0 说明这个数枚举完了</span></span><br><span class="line">    <span class="comment">// 这里一般返回1，表示枚举的这个数是合法的</span></span><br><span class="line">    <span class="comment">// 也可能返回别的值</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记忆化</span></span><br><span class="line">    <span class="comment">// !limit 代表非边界状态，无需特殊处理</span></span><br><span class="line">    <span class="comment">// dp[pos][state] != -1 代表已经遍历过了</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state] != -<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> dp[pos][state];</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//根据limit判断枚举的上界up</span></span><br><span class="line">    <span class="keyword">int</span> up = limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">long</span> ans=<span class="number">0</span>; <span class="comment">// 开始计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up;i++) &#123; <span class="comment">//枚举，然后把不同情况的个数加到ans就可以了</span></span><br><span class="line">        <span class="keyword">if</span>() ...</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>()...</span><br><span class="line">        ans+=dfs(pos-<span class="number">1</span>,<span class="comment">/*状态转移*/</span>,lead &amp;&amp; i==<span class="number">0</span>,limit &amp;&amp; i==a[pos]) <span class="comment">//最后两个变量传参都是这样写的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算完，记录状态</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead) dp[pos][state]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123; <span class="comment">//把数位都分解出来</span></span><br><span class="line">        a[pos++] = x % <span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// //刚开始最高位都是有限制并且有前导零的</span></span><br><span class="line">    <span class="keyword">return</span> dfs(pos-<span class="number">1</span><span class="comment">/*从最高位开始枚举*/</span>,<span class="comment">/*一系列状态 */</span>,<span class="keyword">true</span>,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="背包问题">1.4.2 <code>0/1</code>背包问题</h5><blockquote><p>有一个容量有限的背包，总容量为<code>c</code>，有<code>n</code>个可待选择的物品，<strong><u>每个物品只有一件</u></strong>，它们都有各自的重量和价值，需要从中选择合适的组合来使得背包中的物品总价值最大。</p></blockquote><p>背包问题抽象为寻找组合<span class="math inline">\(\{x_1,x_2,x_3,...,x_n\}\)</span>​​​ （其中<span class="math inline">\(x_i\)</span>​​​取<code>0</code>或<code>1</code>，表示第<span class="math inline">\(i\)</span>个物品取或者不取），<span class="math inline">\(v_i\)</span>代表第<span class="math inline">\(i\)</span>个物品的价值，<span class="math inline">\(w_i\)</span>代表第<span class="math inline">\(i\)</span>个物品的重量，总物品数为<span class="math inline">\(n\)</span>，背包容量为<span class="math inline">\(c\)</span>。问题即求解： <span class="math display">\[\textbf{目标}：&amp; max\{ x_1v_1 + x_2v_2 + x_3v_3 + ... + x_nv_n \} \\\textbf{约束条件}：&amp; x_1w_1 + x_2w_2 + x_3w_3 + ... + x_nw_n &lt; c\]</span> 证明最优化原理：</p><blockquote><p>假设<span class="math inline">\((x_1，x_2，…，x_n)\)</span>是<span class="math inline">\(0/1\)</span>背包问题的最优解，则有<span class="math inline">\((x_2，x_3，…，x_n)\)</span>是其子问题的最优解，假设<span class="math inline">\((y_2，y_3，…，y_n)\)</span>是上述问题的子问题最优解，则有<span class="math inline">\((v_2y_2+v_3y_3+…+v_ny_n)+v_1x_1 &gt; (v_2x_2+v_3x_3+…+v_nx_n)+v_1x_1\)</span>。说明<span class="math inline">\((X_1，Y_2，Y_3，…，Y_n)\)</span>才是该<span class="math inline">\(0/1\)</span>背包问题的最优解，这与最开始的假设相矛盾，故满足<code>最优性原理</code>。</p></blockquote><p>用<span class="math inline">\(dp[i][j]\)</span>表示第<span class="math inline">\(i\)</span>件物品放入容量为<span class="math inline">\(j\)</span>的背包所得的最大价值，则状态转移方程可以推出如下： <span class="math display">\[dp[i][j]=max\{dp[i-1][j-v[i]]+c[i],dp[i-1][j]\};、\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) <span class="comment">//枚举物品  &#123;  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= C; j++) &#123; <span class="comment">//枚举背包容量    </span></span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j];  </span><br><span class="line">        <span class="comment">// 能装下物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= v[i]) &#123;</span><br><span class="line">            <span class="comment">// 选择最优装法</span></span><br><span class="line">            f[i][j] = Max(f[i - <span class="number">1</span>][j],f[i - <span class="number">1</span>][j - v[i]] + c[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数的划分">1.4.2 数的划分</h5><p>将整数<code>n</code>分成<code>k</code>份，且每份不能为空，任意两种分法不能相同（不考虑顺序）。</p><blockquote><p>例如：<code>n=7, k=3</code>，下面三种分法被认为是相同的：<code>5,1,1; 1, 1, 5; 1, 5, 1</code>。</p></blockquote><p>问有多少种不同的分法。</p><p>用<span class="math inline">\(dp[i][j]\)</span>表示将整数 <span class="math inline">\(i\)</span> 划分为 <span class="math inline">\(j\)</span> 份的方案数。由于每份不为空，需要先拿出<span class="math inline">\(j\)</span>个<span class="math inline">\(1\)</span>放到<span class="math inline">\(j\)</span>份上，此时剩下<span class="math inline">\(i-j\)</span>个数，可以将其放到<span class="math inline">\(1 \to j\)</span>份中，将其累加集可得到<span class="math inline">\(dp[i][j]\)</span>。所以<span class="math inline">\(dp[i][j]\)</span>的动态转移方程为： <span class="math display">\[dp[i][j] = dp[i-j][1]+dp[i-j][2]+...+dp[i-j][j]\]</span> 可以进行规约： <span class="math display">\[dp[i-1,j-1]=dp[(i-1)-(j-1)][1]+dp[(i-1)-(j-1)][2]+...+dp[(i-1)-(j-1)][j-1]\\ = dp[i-j][1]+dp[i-j][2]+...+dp[i-j][j-1]\]</span> 合并两个公式得到： <span class="math display">\[dp[i][j] = dp[i-j][j] + dp[i-1][j-1]\]</span> 也可以将这个转移方程理解为，分割方法可以分为两类：</p><ul><li>第一类：<code>n</code>份中不包含 <code>1</code> 的分法，为保证每份都 <code>&gt;= 2</code>，可以先拿出 <code>k</code> 个 <code>1</code> 分到每一份，然后再把剩下的 <code>n-k</code> 分成 <code>k</code> 份即可，分法有： <code>dp[n-k][k]</code></li><li>第二类: <code>n</code> 份中<strong><u>至少有一份</u></strong>为 <code>1</code> 的分法，可以先那出一个 <code>1</code> 作为单独的<code>1</code>份，剩下的 <code>n-1</code> 再分成 <code>k-1</code> 份即可，分法有：<code>dp[n-1][k-1]</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">spiltNums</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][k+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于dp[0][0]作特殊处理（为了后面的动态转移方程能够起作用）</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="comment">//j的范围是1~k（不能超过需要划分的份数）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">dp[i][j] = dp[i-j][j] + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划题解">2. 动态规划题解</h3><h4 id="剑指offer-10-斐波那契数列">2.1 剑指offer-10 斐波那契数列</h4><p>斐波那契数列的标准公式为： <span class="math display">\[F(1)=1;F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)\]</span></p><p>可以看出定义即为转移方程的定义，可以很容易写出其动态规划实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] fibDP = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        fibDP[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        fibDP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            fibDP[i] = (fibDP[i-<span class="number">1</span>] + fibDP[i-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fibDP[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指offer-10-跳台阶">2.2 剑指offer-10 跳台阶</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p></blockquote><p>实际上是斐波那契数列的变种，求第<span class="math inline">\(n\)</span>个台阶的跳法时，需要之前的两个状态：</p><ul><li>上一步跳<code>1</code>级台阶，求跳到<code>n-1</code>级台阶的方法；</li><li>上一步跳<code>2</code>级台阶，求跳到<code>n-2</code>级台阶的方法；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n== <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] numWays = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        numWays[<span class="number">1</span>] = <span class="number">1</span>; numWays[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            numWays[i] = (numWays[i-<span class="number">1</span>] + numWays[i-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numWays[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指offer-13-机器人的运动范围">2.3 剑指offer-13 机器人的运动范围</h4><blockquote><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p></blockquote><p>搜索的过程中搜索方向可以缩减为向右和向下，由可达解分析机器人可 <strong>仅通过向右和向下移动，访问所有可达解</strong> 。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ13/Reachable.PNG" alt="可达解分析" /><figcaption aria-hidden="true">可达解分析</figcaption></figure><p>所以 <code>(i, j)</code> 的格子只会从 <code>(i - 1, j)</code> 或者 <code>(i, j - 1)</code> 两个格子走过来（不考虑边界条件），那么 <code>vis[i][j]</code> 是否可达的状态则可由如下公式计算得到：</p><p><span class="math display">\[vis[i][j]=vis[i−1][j]\ \ or\ \ vis[i][j−1]\]</span> 因此只要遍历所有格子，递推计算出它们是否可达然后用变量 <code>ans</code> 记录可达的格子数量即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] movingCountDP = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        movingCountDP[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( reachable(i, j, k) ) &#123;</span><br><span class="line">                    <span class="comment">// 转移方程</span></span><br><span class="line">                    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) movingCountDP[i][j] = movingCountDP[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) movingCountDP[i][j] = movingCountDP[i][j-<span class="number">1</span>] &gt; <span class="number">0</span> ? <span class="number">1</span> : movingCountDP[i][j];</span><br><span class="line">                    ans += movingCountDP[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reachable</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> || j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += (i % <span class="number">10</span> + j % <span class="number">10</span>);</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法缺点是，许多不可达的节点也需要进行计算，应该可以进行进一步优化。</p><h4 id="剑指-offer-14--i.-剪绳子">2.4 剑指 Offer 14- I. 剪绳子</h4><blockquote><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]<em>k[1]</em>...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></blockquote><p>先把绳子剪掉第一段（长度为<code>j</code>），剩下<code>(i - j)</code>长度可以剪也可以不剪。</p><ul><li>如果不剪，这种分割方法长度乘积即为<code>j * (i - j)</code>；</li><li>如果继续剪，这种分割方法长度乘积即为<code>j * dp[i - j]</code>；</li><li>取两者最大值<code>max(j * (i - j), j * dp[i - j])</code>。</li></ul><p>因此<code>dp[i]</code>的转移方程为 <span class="math display">\[dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++ ) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * (i-j), j * dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题实际上有更优化的解法，需要结合数学推理和贪心算法，具体可以参考对这道题的解析：<a href="">待完善</a>。</p><h4 id="剑指-offer-19.-正则表达式匹配">2.5 剑指 Offer 19. 正则表达式匹配</h4><blockquote><p>请实现一个函数用来匹配包含<code>'. '</code>和<code>'*'</code>的正则表达式。模式中的字符<code>'.'</code>表示任意一个字符，而<code>'*'</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。</p></blockquote><p>用 <span class="math inline">\(f[i][j]\)</span> 表示 <span class="math inline">\(s\)</span> 的前 <span class="math inline">\(i\)</span> 个字符与 <span class="math inline">\(p\)</span>​ 中的前 <span class="math inline">\(j\)</span> 个字符是否能够匹配。在进行状态转移时，考虑 <span class="math inline">\(p\)</span> 的第 <span class="math inline">\(j\)</span> 个字符的匹配情况：</p><ul><li><p>如果 <span class="math inline">\(p\)</span>​ 的第 <span class="math inline">\(j\)</span>​​ 个字符是一个<code>正常字符</code>，那么必须在 <span class="math inline">\(s\)</span> 中匹配一个相同的正常字符： <span class="math display">\[f[i][j] =   \begin{cases}      f[i-1][j-1], &amp; s[i]=p[j] \\       \text { false, } &amp; s[i] \neq p[j]\end{cases}\]</span></p></li><li><p>如果 <span class="math inline">\(p\)</span> 的第 <span class="math inline">\(j\)</span> 个字符是 <code>'*'</code>，那么就表示可以对 <span class="math inline">\(p\)</span> 的第 <span class="math inline">\(j-1\)</span> 个字符匹配任意次数。</p><ul><li><p>如果匹配 <span class="math inline">\(0\)</span>​ 次： <span class="math display">\[f[i][j]=f[i][j−2]\]</span></p></li><li><p>匹配 <span class="math inline">\(s\)</span>​ 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；不匹配字符，丢掉带星号的组合，不再继续匹配。 <span class="math display">\[f[i][j] = f[i-1][j] or f[i][j-2]，s[i] = p[j-1]\]</span></p></li></ul></li><li></li></ul><p>最终的状态转移方程如下： <span class="math display">\[f[i][j]= \begin{cases}    \text { if }\left(p[j] \neq &#39;*&#39; \right) =         \begin{cases}            f[i-1][j-1], &amp; \text { matches }(s[i], p[j]) \\             \text { false, } &amp; \text { otherwise }        \end{cases} \\     \text { otherwise }=         \begin{cases}            f[i-1][j] \text { or } f[i][j-2], &amp; \text { matches }(s[i], p[j-1]) \\             f[i][j-2], &amp; \text { otherwise }        \end{cases}\end{cases}\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> pLen = p.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第零行表示其中一个为空串时的结果</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sLen+<span class="number">1</span>][pLen+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pLen; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前判断的 第 j 个 p 字符为&quot;*&quot;</span></span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span> ) &#123;</span><br><span class="line">                    <span class="comment">// 匹配 0 次</span></span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    <span class="comment">// 匹配 n 次</span></span><br><span class="line">                    <span class="keyword">if</span> ( matches(s, p, i, j-<span class="number">1</span>) ) &#123;</span><br><span class="line">                        dp[i][j] |= dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 正常字符</span></span><br><span class="line">                    <span class="keyword">if</span> ( matches(s, p, i, j) ) &#123;</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[sLen][pLen];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="offer-42.-连续子数组的最大和">2.6 Offer 42. 连续子数组的最大和</h4><blockquote><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p></blockquote><p>我们用 <span class="math inline">\(f(i)\)</span>​​​ 代表以第 <span class="math inline">\(i\)</span>​​​​ 个数结尾的「连续子数组的最大和」。可以考虑 <span class="math inline">\(nums[i]\)</span>​​ 单独成为一段还是加入 <span class="math inline">\(f(i−1)\)</span>​​ 对应的那一段，这取决于 <span class="math inline">\(nums[i]\)</span>​ 和 <span class="math inline">\(f(i−1)+nums[i]\)</span> 的大小，于是可以写出这样的动态规划转移方程： <span class="math display">\[f(i)=max\{f(i−1)+nums[i],nums[i]\}\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = Math.max(nums[i], nums[i] + nums[i-<span class="number">1</span>]);</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-43.-1n-整数中-1-出现的次数">2.7 剑指 Offer 43. 1～n 整数中 1 出现的次数</h4><blockquote><p>输入一个整数 <code>n</code> ，求1～n这n个整数的十进制表示中1出现的次数。</p></blockquote><p>这道题有直接基于规律统计的方法。但还有一种基于动态规划的方法——<code>数位dp</code>，按数位来遍历。状态转移方程为： <span class="math display">\[dp[pos][count] = \left\{    \begin{array}{lr}    dp[pos][count] &amp; , pos &lt; up \ \&amp; \ not \ limit \\    \sum_0^{up}{dfs(pos-1, limit=true)} &amp; , else  \\    \end{array}\right.\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] num;</span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>];</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> numLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            num[numLen++] = n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; ++i) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);<span class="comment">//初始化dp数组，用-1表示对应的dfs有没有执行过</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(numLen - <span class="number">1</span> , <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> count, <span class="keyword">boolean</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!limit &amp;&amp; dp[pos][count] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[pos][count];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> up = limit ? num[pos] : <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= up; i++) &#123;</span><br><span class="line">            res += dfs(pos - <span class="number">1</span>, (i == <span class="number">1</span>) ? count+<span class="number">1</span> : count, limit &amp;&amp; i == up);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!limit) dp[pos][count] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-46.-把数字翻译成字符串">2.8 剑指 Offer 46. 把数字翻译成字符串</h4><blockquote><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p></blockquote><p>用 <span class="math inline">\(f(i)\)</span> 表示以第 <span class="math inline">\(i\)</span>​ 位结尾的前缀串翻译的方案数，这时有两种选择：</p><ul><li>单独翻译第 <span class="math inline">\(i\)</span>​​ 位，对 <span class="math inline">\(f(i)\)</span> 的贡献为 <span class="math inline">\(f(i - 1)\)</span>；</li><li>如果第 <span class="math inline">\(i−1\)</span>​ 位存在，并且第 <span class="math inline">\(i - 1\)</span>​ 位和第 <span class="math inline">\(i\)</span>​ 位形成的数字 <span class="math inline">\(x\)</span>​ 满足 <span class="math inline">\(10 \leq x \leq 25\)</span>，那么就可以把第 <span class="math inline">\(i−1\)</span> 位和第 <span class="math inline">\(i\)</span> 位连起来一起翻译，对 <span class="math inline">\(f(i)\)</span> 的贡献为 <span class="math inline">\(f(i - 2)\)</span>，否则为 0。</li></ul><p>可以列出动态规划转移方程： <span class="math display">\[f(i)= \left\{    \begin{array}{lr}    f(i-1)+f(i-2), num[i-1] \geq 0 \ \&amp; \ 10 \leq x \leq 25 \\    f(i-1), else  \\    \end{array}\right.\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        </span><br><span class="line">        String numStr = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> numLen = numStr.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[numLen];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        dp[<span class="number">1</span>] = numStr.substring(<span class="number">0</span>, <span class="number">2</span>).compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; numLen; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            String pre = numStr.substring(i-<span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ( pre.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> &amp;&amp; pre.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">                dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[numLen-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-47.-礼物的最大价值">2.9 剑指 Offer 47. 礼物的最大价值</h4><blockquote><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p></blockquote><p>可以看作找连续子数组的最大和的升级版，从一维数组变为了二维数组，但思想上是差不多的。只可能每次向右或者向下移动一格，设 <code>f(i,j)</code> 为从棋盘左上角走至单元格 <code>(i,j)</code> 的礼物最大累计价值，易得到以下递推关系：<code>f(i,j)</code> 等于 <code>f(i,j−1)</code> 和 <code>f(i−1,j)</code> 中的较大值加上当前单元格礼物价值 <code>grid(i,j)</code> 。 <span class="math display">\[f(i,j) = \max[f(i,j-1), f(i-1,j)] + grid(i,j)\]</span></p><p><span class="math display">\[dp(i, j) = \begin{cases}    \operatorname{grid}(i, j) &amp; , i=0, j=0 \\     \operatorname{grid}(i, j)+d p(i, j-1) &amp; , i=0, j \neq 0 \\     \operatorname{grid}(i, j)+d p(i-1, j) &amp; , i \neq 0, j=0 \\     \operatorname{grid}(i, j)+\max [d p(i-1, j), d p(i, j-1)] &amp; , i \neq 0, j \neq 0\end{cases}\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxGift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) dp[i][j] = dp[i][j - <span class="number">1</span>] +  grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[ grid.length - <span class="number">1</span> ][ grid[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-49.-丑数">2.10 剑指 Offer 49. 丑数</h4><blockquote><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p></blockquote><p>定义数组 <span class="math inline">\(dp\)</span>​​，其中 <span class="math inline">\(dp[i]\)</span> 表示第 <span class="math inline">\(i\)</span> 个丑数，第 <span class="math inline">\(n\)</span> 个丑数即为 <span class="math inline">\(dp[n]\)</span>。最小的丑数是 <span class="math inline">\(1\)</span>，因此 <span class="math inline">\(dp[1]=1\)</span>。</p><ul><li>定义三个指针 <span class="math inline">\(p_2,p_3,p_5\)</span>，表示下一个丑数是当前指针指向的丑数乘以对应的质因数。初始时，三个指针的值都是 <span class="math inline">\(1\)</span>。</li><li>可以定义转移方程：</li></ul><p><span class="math display">\[\textit{dp}[i]=\min(\textit{dp}[p_2] \times 2, \textit{dp}[p_3] \times 3, \textit{dp}[p_5] \times 5)\]</span></p><ul><li>比较 <span class="math inline">\(\textit{dp}[i]\)</span> 和 <span class="math inline">\(\textit{dp}[p_2],\textit{dp}[p_3],\textit{dp}[p_5]\)</span>，如果相等则将对应的指针加 <code>1</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n ; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur2 = <span class="number">2</span> * dp[p2], cur3 = <span class="number">3</span> * dp[p3], cur5 = <span class="number">5</span> * dp[p5];</span><br><span class="line">            dp[i] = Math.min(cur2, Math.min(cur3, cur5));</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == cur2) p2++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == cur3) p3++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == cur5) p5++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-60.-n个骰子的点数">2.11 剑指 Offer 60. n个骰子的点数</h4><blockquote><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p></blockquote><p>设输入 <span class="math inline">\(n\)</span>​个骰子的解（即概率列表）为 <span class="math inline">\(f(n)\)</span>​，其中「点数和」 <span class="math inline">\(x\)</span>​ 的概率为 <span class="math inline">\(f(n, x)\)</span>​。假设已知 <span class="math inline">\(n - 1\)</span>​ 个骰子的解 <span class="math inline">\(f(n - 1)\)</span>，此时添加一枚骰子，求 <span class="math inline">\(n\)</span> 个骰子的点数和为 <span class="math inline">\(x\)</span> 的概率 <span class="math inline">\(f(n, x)\)</span>。</p><ul><li>当添加骰子的点数为 <span class="math inline">\(1\)</span> 时，前 <span class="math inline">\(n - 1\)</span> 个骰子的点数和应为 <span class="math inline">\(x - 1\)</span>，方可组成点数和 <span class="math inline">\(x\)</span>；</li><li>同理，当此骰子为 <span class="math inline">\(i\)</span> 时，前 <span class="math inline">\(n - 1\)</span> 个骰子应为 <span class="math inline">\(x - i\)</span>；</li><li>递推公式如下所示：</li></ul><p><span class="math display">\[f(n, x) = \sum_{i=1}^6 f(n - 1, x - i) \times \frac{1}{6}\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] dicesProbability(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] probs = <span class="keyword">new</span> <span class="keyword">double</span>[ <span class="number">6</span> * n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i) probs[i] = <span class="number">1.0</span> / <span class="number">6.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = i*<span class="number">6</span>; x &gt;= i; x--) &#123;</span><br><span class="line">                <span class="comment">// 因为是从后往前逐个累加，在加到当前点数时，必须把原先存放的n-1个骰子的数据置0</span></span><br><span class="line">                probs[x] = <span class="number">0.0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// n-1个骰子的最小值就是n-1</span></span><br><span class="line">                    <span class="keyword">if</span> (x - j  &gt;= i-<span class="number">1</span>) &#123;</span><br><span class="line">                        probs[x] += probs[x-j] / <span class="number">6.0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>*n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= <span class="number">6</span>*n; i++) &#123;</span><br><span class="line">            res[i - n] = probs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h4 id="剑指-offer-63.-股票的最大利润">2.12 剑指 Offer 63. 股票的最大利润</h4><blockquote><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p></blockquote><p>感觉应该是个简单题，思路就是找两个数字之间的最大差值。使用动态规划的思想，设 <span class="math inline">\(dp[i]\)</span> 为前 <span class="math inline">\(i\)</span> 天股票的最低价格，<span class="math inline">\(maxProfit\)</span> 是当前已经获取的最大利润，那么有转移方程： <span class="math display">\[dp[i] = min(prices[i], dp[i-1]) \\maxProfit = max(maxPtofit, prices[i] - dp[i])\]</span> 实际上只用两个变量直接遍历数组一遍就可以得到答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            res = Math.max(res, prices[i] - prices[i-<span class="number">1</span>]);</span><br><span class="line">            prices[i] = Math.min(prices[i], prices[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-62-不同路径">2.13 leetcode-62 不同路径</h4><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p></blockquote><p>比起剑指Offer那道题来说，约束条件更加明确。由于只能向下或向右移动，到达 <code>(i, j)</code>单元格的方法数只与 <code>(i-1, j )</code>和 <code>(i, j-1)</code>两个单元格的状态有关。可以得到转移方程： <span class="math display">\[dp[i][j] = dp[i-1][j] + dp[i][j-1]\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = (i - <span class="number">1</span> &gt;= <span class="number">0</span> ? dp[i - <span class="number">1</span>][j] : <span class="number">0</span>) +  (j - <span class="number">1</span> &gt;= <span class="number">0</span> ? dp[i][j - <span class="number">1</span>] : <span class="number">0</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="leetcode-871.-最低加油次数">2.14 leetcode-871. 最低加油次数</h4><blockquote><p>汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。</p><p>沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1] 升汽油。</p><p>假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。</p><p>当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。</p><p>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。</p><p>注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。</p></blockquote><p>用<span class="math inline">\(dp[i]\)</span>表示只加 <span class="math inline">\(i\)</span>​​​ 次油可以到达的最远距离。那么最后只需要求解<span class="math inline">\(dp\)</span>中可以到达<span class="math inline">\(target\)</span>的最小 <span class="math inline">\(i\)</span>，求解<span class="math inline">\(dp\)</span>的状态转移方程为： <span class="math display">\[dp[k+1] =\begin{cases}    \operatorname{max}(dp[k+1], dp[k]+stations[i][0]) &amp; , stations[i][0] \leq dp[k] \\     dp[k+1] &amp; , else \\ \end{cases}\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minRefuelStops</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> startFuel, <span class="keyword">int</span>[][] stations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startFuel &gt;= target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[stations.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = startFuel;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stations.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[k] &gt;= stations[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                    dp[k+<span class="number">1</span>] = Math.max(dp[k+<span class="number">1</span>], dp[k] + stations[i][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= stations.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt;= target) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题也可以用优先队列求解，先求当前能到达的最远距离，然后当不够到达下一个地点时，选择之前路过可选的最大油量，加一次油继续前进，直到到达最终<span class="math inline">\(targer\)</span>，可以得到最小的加油次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minRefuelStops</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> startFuel, <span class="keyword">int</span>[][] stations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startFuel &gt;= target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minRefuel = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; topFuel = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer one, Integer two)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> two - one;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> curStation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curFuel = startFuel;</span><br><span class="line">        <span class="keyword">int</span> N = stations.length;</span><br><span class="line">        <span class="keyword">while</span> (curStation &lt; N) &#123;</span><br><span class="line">            <span class="comment">// 当前可以前进距离</span></span><br><span class="line">            <span class="keyword">while</span> (curStation &lt; N &amp;&amp; curFuel &gt;= stations[curStation][<span class="number">0</span>]) &#123;</span><br><span class="line">                topFuel.offer(stations[curStation++][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(target &lt;= curFuel ) <span class="keyword">return</span> minRefuel;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (curFuel &lt; target &amp;&amp; ! topFuel.isEmpty()) &#123;</span><br><span class="line">                curFuel += topFuel.poll();</span><br><span class="line">                minRefuel++;</span><br><span class="line">                <span class="keyword">if</span> (target &lt;= curFuel) <span class="keyword">return</span> minRefuel;</span><br><span class="line">                <span class="keyword">if</span> (curStation &lt; N &amp;&amp; curFuel &gt;= stations[curStation][<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curStation &lt; N &amp;&amp; curFuel &lt; stations[curStation][<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分苹果">2.15 分苹果</h4><blockquote><p>M个相同苹果放到N个相同篮子里有多少种放法,<strong><u>允许有篮子不放</u></strong>。</p></blockquote><p>设<code>dp[m][n]</code>为<code>m</code>个苹果，<code>n</code>个盘子的放法数目：</p><ul><li>当<code>n &gt; m</code>：必定有<code>n - m</code>个盘子永远空着，它们对摆放苹果方法数目不产生影响。即<code>dp[m][n] = dp[m][m] (n&gt;m)</code></li><li>当<code>n &lt;= m</code>：不同的放法可以分成两类：<ul><li>有至少一个盘子空着，即相当于<code>dp[m][n-1]</code>;</li><li>所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即<code>dp[m-n,n]</code>。</li><li>而总的放苹果的放法数目等于两者的和，即 <code>dp[m][n] = dp[m][n-1] + dp[m-n][n]</code></li></ul></li></ul><h4 id="数的划分-1">2.16 数的划分</h4><h5 id="将n划分成不大于m的划分法">2.16.1 将n划分成不大于m的划分法</h5><ul><li><p>若是划分多个整数可以存在相同的：</p><p><code>dp[n][m]= dp[n][m-1]+ dp[n-m][m]</code> ， <code>dp[n][m]</code>表示整数 <code>n</code> 的划分中，每个数不大于 <code>m</code> 的划分数。则划分数可以分为两种情况：</p><ul><li>划分中每个数都小于 <code>m</code>，相当于每个数不大于 <code>m-1</code>，故划分数为 <code>dp[n][m-1]</code>；</li><li>划分中有一个数为 <code>m</code>. 那就在 <code>n</code> 中减去 <code>m</code>，剩下的就相当于把 <code>n-m</code> 进行划分，故划分数为 <code>dp[n-m][m]</code>。</li></ul></li><li><p>若是划分多个不同的整数：</p><p><code>dp[n][m]= dp[n][m-1]+ dp[n-m][m-1]</code>， <code>dp[n][m]</code>表示整数 <code>n</code> 的划分中，每个数不大于 <code>m</code> 的划分数。同样划分情况分为两种情况：</p><ul><li>划分中每个数都小于<code>m</code>，相当于每个数不大于 <code>m-1</code>，划分数为 <code>dp[n][m-1]</code>；</li><li>划分中有一个数为 <code>m</code>，在<code>n</code>中减去<code>m</code>，剩下相当对<code>n-m</code>进行划分，且每一个数不大于<code>m-1</code>，故划分数为 <code>dp[n-m][m-1]</code>。</li></ul></li></ul><h5 id="将n划分成k个数的划分法">2.16.2 将n划分成k个数的划分法</h5><p><code>dp[n][k]= dp[n-k][k]+ dp[n-1][k-1]</code>，方法可以分为两类：</p><ul><li>第一类： <code>n</code> 份中不包含 1 的分法，为保证每份都 <code>&gt;= 2</code>，可以先拿出 <code>k</code> 个 <code>1</code> 分到每一份，然后再把剩下的 <code>n- k</code> 分成 <code>k</code> 份即可，分法有：<code>dp[n-k][k]</code>；</li><li>第二类: <code>n</code> 份中至少有一份为 <code>1</code> 的分法，可以先那出一个 <code>1</code> 作为单独的 <code>1</code> 份，剩下的 <code>n-1</code> 再分成 <code>k- 1</code> 份即可，分法有：<code>dp[n-1][k-1]</code></li></ul><h5 id="将n划分成若干奇数的划分法">2.16.3.将n划分成若干奇数的划分法</h5><p><code>g[i][j]</code>：将<code>i</code>划分为<code>j</code>个偶数；<code>f[i][j]</code>：将<code>i</code>划分为<code>j</code>个奇数</p><ul><li><code>g[i][j] = f[i - j][j]</code></li><li><code>f[i][j] = f[i - 1][j - 1] + g[i - j][j]</code></li></ul><p>方法可以分为两类：</p><ul><li><p>第一类：<code>i</code>中拿出<code>j</code>个<code>1</code>分到每一份中，将剩余的<code>i-j</code>分成<code>j</code>个奇数；</p></li><li><p>第二类：一份包含奇数<code>1</code>，剩余的<code>i-1</code>分成<code>j-1</code>个奇数；另一种，每份至少大于<code>1</code>，将<code>j</code>个<code>1</code>拿出来分到每一份中，其余<code>i-j</code>分成<code>j</code>份偶数。</p></li></ul><h3 id="参考文献">参考文献：</h3><p>[1] <a href="https://houbb.github.io/2020/01/23/data-struct-learn-07-base-dp#">五大基本算法之动态规划算法 DP</a></p><p>[2] <a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html">五大常用算法之二：动态规划算法</a></p><p>[3] <a href="https://www.zhihu.com/question/39948290/answer/1309260344">如何理解动态规划？ - 力扣（LeetCode）的回答 - 知乎</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;动态规划概述&quot;&gt;1. 动态规划概述&lt;/h3&gt;
&lt;h4 id=&quot;简介&quot;&gt;1.1 简介&lt;/h4&gt;
&lt;p&gt;动态规划（&lt;code&gt;dynamic programming&lt;/code&gt;）可以理解为是对递归算法的一种优化，是R.E.Bellman等人在研究多阶段决策过程(&lt;code&gt;multistep decision process&lt;/code&gt;)的优化问题时，提出的最优化原理(&lt;code&gt;principle of optimality&lt;/code&gt;)，即把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系逐个求解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dynamic programming&lt;/code&gt;的名字是为了&lt;a href=&quot;https://www.zhihu.com/question/39948290/answer/83920614&quot;&gt;规避军方的厌恶&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法" scheme="https://wuyunjie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://wuyunjie.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--11 Java并发编程实践</title>
    <link href="https://wuyunjie.top/2021/07/22/JavaLearning_The_art_of_concurrent_programming_in_Java-11-concurrent-programming-practice.html"/>
    <id>https://wuyunjie.top/2021/07/22/JavaLearning_The_art_of_concurrent_programming_in_Java-11-concurrent-programming-practice.html</id>
    <published>2021-07-22T07:12:03.000Z</published>
    <updated>2021-07-22T07:12:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>并发编程产生的问题和风险可能也会随之而来。 <span id="more"></span></p><h3 id="生产者和消费者模式">1. 生产者和消费者模式</h3><p>生产者和消费者模式是<strong><u>通过一个容器来解决生产者和消费者的强耦合问题</u></strong>。生产者和消费者彼此之间不直接通信，而是<strong><u>通过阻塞队列来进行通信</u></strong>。</p><ul><li>生产者生产完数据之后不用等待消费者处理，直接放入阻塞队列；</li><li>消费者不找生产者要数据，而是直接从阻塞队列取数据；</li><li>阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</li></ul><h4 id="多生产者和多消费者">1.1 多生产者和多消费者</h4><p>消费者消费的数据，有可能需要继续处理，于是消费者处理完数据之后，它又要作为生产者把数据放在新的队列里，交给其他消费者继续处理。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/MultipleProducePay.PNG" alt="多生产者消费者模式" /><figcaption aria-hidden="true">多生产者消费者模式</figcaption></figure><h3 id="线上问题定位">2. 线上问题定位</h3><p>主要讲述了利用<code>top</code>来查看每个进程的情况，然后定位问题。其实有个更好用的<code>htop</code>，但需要单独安装，<code>top</code>是linux内置的：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/top.PNG" alt="top指令" /><figcaption aria-hidden="true">top指令</figcaption></figure><ul><li>COMMAND表示启动当前进程的命令</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/top1.PNG" alt="top交互" /><figcaption aria-hidden="true">top交互</figcaption></figure><p>使用top的交互命令数字<code>1</code>查看每个<code>CPU</code>的性能数据。参数的含义如下：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/CPUParam.PNG" alt="CPU参数含义" /><figcaption aria-hidden="true">CPU参数含义</figcaption></figure><h3 id="性能测试">3. 性能测试</h3><ul><li><p>使用<code>netstat</code>命令查询有多少台机器连接到端口上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep 12200 –c</span><br></pre></td></tr></table></figure></li><li><p>通过<code>ps</code>命令查看下线程数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf | grep java -c</span><br></pre></td></tr></table></figure></li><li><p>查看网络流量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/net/dev</span><br></pre></td></tr></table></figure></li><li><p>查看系统平均负载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/loadavg</span><br></pre></td></tr></table></figure></li><li><p>查看系统内存情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure></li><li><p>查看CPU的利用率</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/<span class="built_in">stat</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="异步任务池">4. 异步任务池</h3><p>任务池的主要处理流程是，每台机器会启动一个任务池，每个任务池里有多个线程池，当某台机器将一个任务交给任务池后，任务池会先将这个任务保存到数据库中，然后某台机器上的任务池会从数据库中获取待执行的任务，再执行这个任务。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/AsynchronousTaskPool.PNG" alt="异步任务池" /><figcaption aria-hidden="true">异步任务池</figcaption></figure><p>每个任务有几种状态：</p><ul><li>创建（<code>NEW</code>）：提交给任务池之后的状态；</li><li>执行中（<code>EXECUTING</code>）：任务池从数据库中拿到任务执行时的状态；</li><li>重试（<code>RETRY</code>）：当执行任务时出现错误，程序显式地告诉任务池这个任务需要重试，并设置下一次执行时间；</li><li>挂起 （<code>SUSPEND</code>）：当一个任务的执行依赖于其他任务完成时，可以将这个任务挂起，当收到消息后，再开始执行；</li><li>中止（<code>TEMINER</code>）：任务执行失败，让任务池停止执行这个任务，并设置错误消息告诉调用端；</li><li>执行完成（<code>FINISH</code>）：任务执行结束。</li></ul><p><strong>任务池的任务隔离</strong>。异步任务有很多种类型，不同类型的任务优先级不一样，所以对任务进行隔离执行。使用不同的线程池处理不同的任务，或者不同的线程池处理不同优先级的任务。</p><p><strong>任务池的重试策略</strong>。根据不同的任务类型设置不同的重试策略。</p><p><strong>使用任务池的注意事项</strong>。任务必须无状态：任务不能在执行任务的机器中保存数据，上传的文件必须存在其他的集群里，比如<code>OSS</code>或<code>SFTP</code>。</p><p><strong>异步任务的属性</strong>。包括任务名称、下次执行时间、已执行次数、任务类型、任务优先级和执行时的报错信息。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;并发编程产生的问题和风险可能也会随之而来。</summary>
    
    
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
    <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--10 Executor框架</title>
    <link href="https://wuyunjie.top/2021/07/22/JavaLearning_The_art_of_concurrent_programming_in_Java-10-Executor-framework.html"/>
    <id>https://wuyunjie.top/2021/07/22/JavaLearning_The_art_of_concurrent_programming_in_Java-10-Executor-framework.html</id>
    <published>2021-07-22T02:04:28.000Z</published>
    <updated>2021-07-22T02:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>Java的线程既是<strong>工作单元</strong>，也是<strong>执行机制</strong>。<code>JDK 5</code>开始，把<strong>工作单元</strong>与<strong>执行机制</strong>分离开来，<strong>工作单元</strong>包括<code>Runnable</code>和<code>Callable</code>，而执行机制由<code>Executor</code>框架提供。 <span id="more"></span></p><h3 id="executor框架简介">1. <code>Executor</code>框架简介</h3><h4 id="executor框架的两级调度模型">1.1 <code>Executor</code>框架的两级调度模型</h4><p>两级调度模型即：</p><ul><li><strong>应用程序通过<code>Executor</code>框架控制<u>上层的调度</u></strong>。<code>Java</code>多线程程序把应用分解为若干个任务，然后使用用户级的调度器（<code>Executor</code>框架）将这些任务映射为固定数量的线程；</li><li><strong>由<code>操作系统内核</code>控制<u>下层的调度</u></strong>。操作系统内核将这些线程映射到硬件处理器上，下层的调度不受应用程序的控制。在<code>HotSpot VM</code>的线程模型中，<code>Java</code>线程（<code>java.lang.Thread</code>）被一对一映射为本地操作系统线程。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/TwoLevelSchedule.PNG" alt="线程池的主要处理流程" /><figcaption aria-hidden="true">线程池的主要处理流程</figcaption></figure><h4 id="executor框架的结构与成员">1.2 <code>Executor</code>框架的结构与成员</h4><h5 id="executor框架的结构">1.2.1 <code>Executor</code>框架的结构</h5><p><code>Executor</code>框架主要由3大部分组成：</p><ul><li><strong>任务</strong>。包括被执行任务需要实现的接口：<code>Runnable</code>接口或<code>Callable</code>接口。<ul><li><code>Runnable</code>接口和<code>Callable</code>接口的实现类，都可以被<code>Executor</code>接口的<strong>实现类</strong>执行。</li></ul></li><li><strong>任务的执行</strong>。包括任务执行机制的核心接口<code>Executor</code>，以及继承自<code>Executor</code>的<code>ExecutorService</code>接口。<code>Executor</code>接口是<strong>Executor框架</strong>的基础，它将任务的提交与任务的执行分离开来。<code>Executor</code>框架有两个<strong>关键类</strong>实现了<code>ExecutorService</code>接口：<ul><li><code>ThreadPoolExecutor</code>，线程池的核心实现类，用来<strong><u>执行被提交的任务</u></strong>；</li><li><code>ScheduledThreadPoolExecutor</code>，可以<strong><u>在给定的延迟后运行命令，或者定期执行命令</u></strong>。比<code>Timer</code>更灵活，功能更强大。</li></ul></li><li><strong>异步计算的结果</strong>。包括接口<code>Future</code>和实现<code>Future</code>接口的<code>FutureTask</code>类，代表异步计算的结果。</li></ul><p><code>Executor</code>框架的使用过程一般如下：</p><ul><li>主线程首先要创建实现<code>Runnable</code>或者<code>Callable</code>接口的任务对象。工具类<code>Executors</code>可以把一 个<code>Runnable</code>对象封装为一个<code>Callable</code>对象：<ul><li><code>Executors.callable(Runnable task)</code>；</li><li><code>Executors.callable(Runnable task, Object resule)</code>。</li></ul></li><li>然后可以把<code>Runnable</code>对象<strong><u>直接</u></strong>交给<code>ExecutorService</code>执行；或者也可以把<code>Runnable</code>对象或<code>Callable</code>对象<strong><u>提交</u></strong>给<code>ExecutorService</code>执行：<ul><li><code>ExecutorService.execute(Runnable command)</code></li><li><code>ExecutorService.submit(Runnable task)</code></li><li><code>ExecutorService.submit(Callabletask)</code></li></ul></li><li>如果执行<code>ExecutorService.submit</code>，<code>ExecutorService</code>将返回一个实现<code>Future</code>接口的对象。<ul><li>由于<code>FutureTask</code>实现了<code>Runnable</code>，也可以创建<code>FutureTask</code>，然后直接交给<code>ExecutorService</code>执行</li></ul></li><li>最后，主线程可以执行<code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行<code>FutureTask.cancel(boolean mayInterruptIfRunning)</code>来取消此任务的执行。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/ExractorFramework.PNG" alt="线程池的主要处理流程" /><figcaption aria-hidden="true">线程池的主要处理流程</figcaption></figure><h5 id="executor框架的成员">1.2.2 <code>Executor</code>框架的成员</h5><h6 id="threadpoolexecutor">1.2.2.1 <code>ThreadPoolExecutor</code></h6><p><code>ThreadPoolExecutor</code>通常使用工厂类<code>Executors</code>来创建。<code>Executors</code>可以创建3种类型的<code>ThreadPoolExecutor</code>：</p><ul><li><p><code>SingleThreadExecutor</code>。适用于<strong><u>需要保证顺序地执行各个任务</u></strong>；并且在任意时间点，不会有多个线程是活动的应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors提供的API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>FixedThreadPool</code>。适用于为了满足资源管理的需求，而<strong><u>需要限制当前线程数量</u></strong>的应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors提供的API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>CachedThreadPool</code>。<strong><u>大小无界</u></strong>的线程池，适用于执行很多的<strong><u>短期异步任务</u></strong>的小程序，或者是负载较轻的服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors提供的API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li></ul><h6 id="scheduledthreadpoolexecutor">1.2.2.2 <code>ScheduledThreadPoolExecutor</code></h6><p><code>ScheduledThreadPoolExecutor</code>通常使用工厂类<code>Executors</code>来创建。Executors可以创建2种类型的<code>ScheduledThreadPoolExecutor</code>：</p><ul><li><p><code>ScheduledThreadPoolExecutor</code>。包含若干个线程的<code>ScheduledThreadPoolExecutor</code>。适用于<strong><u>需要多个后台线程执行周期任务</u></strong>，同时为了满足资源管理的需求而<strong><u>需要限制后台线程的数量</u></strong>的应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize,ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>SingleThreadScheduledExecutor</code>。只包含一个线程的<code>ScheduledThreadPoolExecutor</code>。适用于需要<strong><u>单个后台线程执行周期任务</u></strong>，同时<strong><u>需要保证顺序地执行各个任务</u></strong>的应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li></ul><h6 id="future接口">1.2.2.3 <code>Future</code>接口</h6><p><code>Future</code>接口和实现<code>Future</code>接口的<code>FutureTask</code>类用来表示异步计算的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span></span><br><span class="line"><span class="function">Future&lt;&gt; <span class="title">submit</span><span class="params">(Runnable task)</span></span></span><br></pre></td></tr></table></figure><p>把<code>Runnable</code>接口或<code>Callable</code>接口的实现类<strong><u>提交（submit）</u></strong>给<code>ThreadPoolExecutor</code>或<code>ScheduledThreadPoolExecutor</code>时，<code>ThreadPoolExecutor</code>或<code>ScheduledThreadPoolExecutor</code>会返回一个<code>FutureTask</code>对象。</p><h6 id="runnable接口和callable接口">1.2.2.4 <code>Runnable</code>接口和<code>Callable</code>接口</h6><p>它们之间的区别是<code>Runnable</code><strong>不会返回结果</strong>，而<code>Callable</code><strong>可以返回结果</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把一个Runnable包装成一个Callable</span></span><br><span class="line"><span class="comment">// 当任务成功完成后FutureTask.get()方法将返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 把一个Runnable和一个待返回的结果包装成一个Callable</span></span></span><br><span class="line"><span class="function"><span class="comment">// 当任务成功完成后FutureTask.get()方法将返回result对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span></span></span><br></pre></td></tr></table></figure><h3 id="threadpoolexecutor详解">2. <code>ThreadPoolExecutor</code>详解</h3><p><code>Executor</code>框架<strong>最核心</strong>的类是<code>ThreadPoolExecutor</code>，它是<strong><u>线程池的实现类</u></strong>，主要由下列4个组件构成。</p><ul><li><code>corePool</code>：核心线程池的大小。</li><li><code>maximumPool</code>：最大线程池的大小。</li><li><code>BlockingQueue</code>：用来暂时保存任务的工作队列。</li><li><code>RejectedExecutionHandler</code>：当<code>ThreadPoolExecutor</code>已经关闭或<code>ThreadPoolExecutor</code>已经饱和时，<code>execute()</code>方法将要调用的Handler。</li></ul><h4 id="fixedthreadpool详解">2.1 <code>FixedThreadPool</code>详解</h4><p><code>FixedThreadPool</code>被称为<strong><u>可重用固定线程数</u></strong>的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>FixedThreadPool</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>都被设置为创建<code>FixedThreadPool</code>时指定的参数<code>nThreads</code>。</li><li>当线程池中的线程数大于<code>corePoolSize</code>时，<code>keepAliveTime</code>为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。这里把<code>keepAliveTime</code>设置为<code>0L</code>，意味着<strong><u>多余的空闲线程会被立即终止</u></strong>。</li></ul><p><code>FixedThreadPool</code>的<code>execute()</code>方法的运行流程如下：</p><ul><li>如果当前运行的线程数少于<code>corePoolSize</code>，则创建新线程来执行任务；</li><li>在线程池完成预热之后（当前运行的线程数等于<code>corePoolSize</code>），将任务加入 <code>LinkedBlockingQueue</code>。</li><li>线程执行完<code>1</code>中的任务后，会在循环中反复从<code>LinkedBlockingQueue</code>获取任务来执行。</li></ul><p><code>FixedThreadPool</code>使用<strong><u>无界队列</u></strong><code>LinkedBlockingQueue</code>作为线程池的工作队列（队列的容量为 <code>Integer.MAX_VALUE</code>）。使用无界队列作为工作队列会对线程池带来如下影响：</p><ol type="1"><li>当线程池中的线程数达到<code>corePoolSize</code>后，新任务将在无界队列中等待，因此线程池中的线程数不会超过<code>corePoolSize</code>。</li><li>使用无界队列时<code>maximumPoolSize</code>将是一个无效参数。使用无界队列时<code>keepAliveTime</code>将是一个无效参数。</li><li>由于使用无界队列，运行中的<code>FixedThreadPool</code>（未执行方法<code>shutdown()</code>或<code>shutdownNow()</code>）不会拒绝任务。</li></ol><h4 id="singlethreadexecutor详解">2.2 <code>SingleThreadExecutor</code>详解</h4><p><code>SingleThreadExecutor</code>是使用<strong><u>单个</u></strong><code>worker</code>线程的<code>Executor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>SingleThreadExecutor</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>被设置为<code>1</code>。</li><li><code>SingleThreadExecutor</code>使用无界队列<code>LinkedBlockingQueue</code>作为线程池的工作队列（队列的容量为<code>Integer.MAX_VALUE</code>）。</li></ul><h4 id="cachedthreadpool详解">2.3 <code>CachedThreadPool</code>详解</h4><p><code>CachedThreadPool</code>是一个会根据需要创建新线程的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>CachedThreadPool</code>的<code>corePoolSize</code>被设置为<code>0</code>，即<code>corePool</code>为空；</p></li><li><p><code>maximumPoolSize</code>被设置为<code>Integer.MAX_VALUE</code>，即<code>maximumPool</code>是无界的。</p></li><li><p><code>keepAliveTime</code>设置为<code>60L</code>，意味着<code>CachedThreadPool</code>中的空闲线程等待新任务的最长时间为<code>60</code>秒，空闲线程超过<code>60</code>秒后将会被终止。</p></li><li><p><code>CachedThreadPool</code>使用<strong><u>没有容量</u></strong>的<code>SynchronousQueue</code>作为线程池的工作队列，但<code>CachedThreadPool</code>的<code>maximumPool</code>是无界的。</p><ul><li>如果主线程提交任务的速度高于<code>maximumPool</code>中线程处理任务的速度时，<code>CachedThreadPool</code>会不断创建新线程。</li><li>极端情况下，<code>CachedThreadPool</code>会<strong><u>因为创建过多线程而耗尽CPU和内存资源</u></strong>。</li></ul></li></ul><p><code>CachedThreadPool</code>的<code>execute()</code>方法的执行流程为：</p><ol type="1"><li>首先执行<code>SynchronousQueue.offer(Runnable task)</code>。如果当前<code>maximumPool</code>中有空闲线程正在执行<code>SynchronousQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>，那么主线程执行<code>offer</code>操作与空闲线程执行的<code>poll</code>操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code>方法执行完成；</li><li>当初始<code>maximumPool</code>为空，或者<code>maximumPool</code>中当前没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>。此时<code>CachedThreadPool</code>会创建一个新线程执行任务，<code>execute()</code>方法执行完成。</li><li>新创建的线程将任务执行完后，会执行 <code>SynchronousQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>。这个<code>poll</code>操作会让空闲线程最多在<code>SynchronousQueue</code>中等待<code>60</code>秒钟。<ul><li>如果<code>60</code>秒钟内主线程提交了一个新任务，那么这个空闲线程将执行主线程提交的新任务；</li><li>否则，这个空闲线程将终止。</li></ul></li></ol><h3 id="scheduledthreadpoolexecutor详解">3. <code>ScheduledThreadPoolExecutor</code>详解</h3><p><code>ScheduledThreadPoolExecutor</code>继承自<code>ThreadPoolExecutor</code>。主要用来在给定的延迟之后运行任务，或者定期执行任务。</p><h4 id="scheduledthreadpoolexecutor的运行机制">3.1 <code>ScheduledThreadPoolExecutor</code>的运行机制</h4><p><code>ScheduledThreadPoolExecutor</code>使用无界队列<code>DelayQueue</code>作为线程池的工作队列。执行主要分为两大部分：</p><ul><li>当调用<code>ScheduledThreadPoolExecutor</code>的<code>scheduleAtFixedRate()</code>方法或者<code>scheduleWithFixedDelay()</code>方法时，会向<code>ScheduledThreadPoolExecutor</code>的<code>DelayQueue</code>添加一个实现了<code>RunnableScheduledFutur</code>接口的<code>ScheduledFutureTask</code>。</li><li>线程池中的线程从<code>DelayQueue</code>中获取<code>ScheduledFutureTask</code>，然后执行任务。</li></ul><p>为了实现<strong><u>周期性</u></strong>的执行任务，<code>ScheduledThreadPoolExecutor</code>做了如下修改：</p><ul><li>使用<code>DelayQueue</code>作为任务队列。</li><li>获取任务的方式不同。</li><li>执行周期任务后，增加了额外的处理。</li></ul><h4 id="scheduledthreadpoolexecutor的实现">3.2 <code>ScheduledThreadPoolExecutor</code>的实现</h4><p><code>ScheduledFutureTask</code>主要包含3个成员变量：</p><ul><li><code>long</code>型成员变量<code>time</code>，表示这个任务将要被执行的具体时间。</li><li><code>long</code>型成员变量<code>sequenceNumber</code>，表示这个任务被添加到<code>ScheduledThreadPoolExecutor</code>中的序号。</li><li><code>long</code>型成员变量<code>period</code>，表示任务执行的间隔周期。</li></ul><p><code>DelayQueue</code>封装了一个<code>PriorityQueue</code>，这个<code>PriorityQueue</code>会对队列中的<code>ScheduledFutureTask</code>进行排序。</p><ul><li><code>time</code>小的排在前面。</li><li>如果两个<code>ScheduledFutureTask</code>的<code>time</code>相同，<code>sequenceNumber</code>小的排在前面。</li></ul><p><code>ScheduledThreadPoolExecutor</code>执行某个周期任务的4个步骤：</p><ol type="1"><li><p>工作线程从<code>DelayQueue</code>中获取已到期的<code>ScheduledFutureTask</code>（<code>DelayQueue.take()</code>）。到期任务是指<code>ScheduledFutureTask</code>的<strong><u><code>time</code>大于等于当前时间</u></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                available.await(); <span class="comment">// 2.1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> tl = available.awaitNanos(delay); <span class="comment">// 2.2</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    E x = q.poll(); <span class="comment">// 2.3.1</span></span><br><span class="line">                    <span class="keyword">assert</span> x != <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (q.size() != <span class="number">0</span>)</span><br><span class="line">                        available.signalAll(); <span class="comment">// 2.3.2</span></span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取任务分为3大步骤。</p><ul><li>获取<code>Lock</code>。</li><li>获取周期任务。<ul><li>如果<code>PriorityQueue</code>为空，当前线程到<code>Condition</code>中等待；</li><li>如果<code>PriorityQueue</code>的头元素的<code>time</code>时间比当前时间大，到<code>Condition</code>中等待到<code>time</code>时间；</li><li>获取<code>PriorityQueue</code>的头元素，如果<code>PriorityQueue</code>不为空，则唤醒在<code>Condition</code>中等待的所有线程。</li></ul></li><li>释放<code>Lock</code>。</li></ul></li><li><p>工作线程执行这个<code>ScheduledFutureTask</code>，并修改<code>ScheduledFutureTask</code>的<code>time</code>变量为下次将要被执行的时间。</p></li><li><p>工作线程把这个修改<code>time</code>之后的<code>ScheduledFutureTask</code>放回<code>DelayQueue</code>中（<code>DelayQueue.add()</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E first = q.peek();</span><br><span class="line">        q.offer(e); <span class="comment">// 2.1</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || e.compareTo(first) &lt; <span class="number">0</span>)</span><br><span class="line">            available.signalAll(); <span class="comment">// 2.2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加任务分为3大步骤：</p><ul><li>获取<code>Lock</code>。</li><li>添加任务。<ul><li>向<code>PriorityQueue</code>添加任务。</li><li>如果添加的任务是<code>PriorityQueue</code>的<strong>头元素</strong>，唤醒在<code>Condition</code>中等待的所有线程。</li></ul></li><li>释放<code>Lock</code>。</li></ul></li></ol><h3 id="futuretask详解">4. <code>FutureTask</code>详解</h3><h4 id="futuretask简介">4.1 <code>FutureTask</code>简介</h4><p><code>FutureTask</code>除了实现<code>Future</code>接口外，还实现了<code>Runnable</code>接口。因此，<code>FutureTask</code>可以交给<code>Executor</code>执行，也可以由调用线程直接执行（<code>FutureTask.run()</code>）。<code>FutureTask</code>可以处于下面3种状态：</p><ul><li><strong>未启动</strong>。当创建一 个<code>FutureTask</code>，<code>FutureTask.run()</code>方法还没有被执行之前，<code>FutureTask</code>处于未启动状态。</li><li><strong>已启动</strong>。<code>FutureTask.run()</code>方法被执行的过程中，<code>FutureTask</code>处于已启动状态。</li><li><strong>已完成</strong>。<code>FutureTask.run()</code>方法执行完后正常结束，或被取消（<code>FutureTask.cancel(…)</code>），或执行<code>FutureTask.run()</code>方法时抛出异常而异常结束，<code>FutureTask</code>处于已完成状态。</li></ul><p>不同状态下调用<code>FutureTask</code>方法的响应不同：</p><ul><li>当<code>FutureTask</code>处于<strong>未启动</strong>或<strong>已启动</strong>状态时，执行<code>FutureTask.get()</code>方法将导致调用线程阻塞；</li><li>当<code>FutureTask</code>处于<strong>已完成</strong>状态时，执行<code>FutureTask.get()</code>方法将导致调用线程立即返回结果或抛出异常。</li><li>当<code>FutureTask</code>处于<strong>未启动</strong>状态时，执行<code>FutureTask.cancel()</code>方法将导致此任务<strong><u>永远不会被执行</u></strong>；</li><li>当<code>FutureTask</code>处于<strong>已启动</strong>状态时，执行<code>FutureTask.cancel(true)</code>方法将以<strong><u>中断执行此任务线程</u></strong>的方式来试图停止任务；</li><li>当<code>FutureTask</code>处于<strong>已启动</strong>状态时，执行<code>FutureTask.cancel(false)</code>方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；</li><li>当<code>FutureTask</code>处于<strong>已完成</strong>状态时，执行<code>FutureTask.cancel(…)</code>方法将返回<code>false</code>。</li></ul><h4 id="futuretask的使用">4.2 <code>FutureTask</code>的使用</h4><p>当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行，此时可以使用<code>FutureTask</code>。</p><ul><li>可以把<code>FutureTask</code>交给<code>Executor</code>执行；</li><li>可以通过<code>ExecutorService.submit(…)</code>方法返回一个<code>FutureTask</code>，然后执行<code>FutureTask.get()</code>方法或<code>FutureTask.cancel(…)</code>方法；</li><li>也可以单独使用<code>FutureTask</code>。</li></ul><h4 id="futuretask的实现">4.3 <code>FutureTask</code>的实现</h4><p><code>FutureTask</code>的实现基于<code>AbstractQueuedSynchronizer</code>（<code>AQS</code>）：</p><ul><li><code>FutureTask</code>的<code>get()</code>/<code>get(long timeout, TimeUnit unit)</code>方法调用<code>AQS</code>的<code>acquire</code>操作。</li><li><code>FutureTask</code>的<code>run()</code>方法和<code>cancel(…)</code>方法调用<code>AQS</code>的<code>release</code>操作。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/FutureTask.PNG" alt="FutureTask的设计" /><figcaption aria-hidden="true">FutureTask的设计</figcaption></figure><p><code>Sync</code>是<code>FutureTask</code>继承自<code>AQS</code>的<strong><u>内部私有类</u></strong>，实现了<code>tryAcquireShared(int)</code>方法和<code>tryReleaseShared(int)</code>方法，<code>Sync</code>通过这两个方法来检查和更新同步状态。</p><blockquote><p>需要注意的是，在<code>jdk 1.8</code>，不再基于<code>AQS</code>实现<code>FutureTask</code>：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Revision notes: This differs from previous versions of this</span></span><br><span class="line"><span class="comment"> * class that relied on AbstractQueuedSynchronizer, mainly to</span></span><br><span class="line"><span class="comment"> * avoid surprising users about retaining interrupt status during</span></span><br><span class="line"><span class="comment"> * cancellation races. Sync control in the current design relies</span></span><br><span class="line"><span class="comment"> * on a &quot;state&quot; field updated via CAS to track completion, along</span></span><br><span class="line"><span class="comment"> * with a simple Treiber stack to hold waiting threads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Style note: As usual, we bypass overhead of using</span></span><br><span class="line"><span class="comment"> * AtomicXFieldUpdaters and instead directly use Unsafe intrinsics.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></blockquote></blockquote><p><code>FutureTask.get()</code>方法执行过程为：</p><ol type="1"><li>调用<code>AQS.acquireSharedInterruptibly(int arg)</code>方法，这个方法首先会回调在子类Sync中实现的<code>tryAcquireShared()</code>方法来判断<code>acquire</code>操作是否可以成功。<ul><li><code>acquire</code>操作可以成功的条件为：<code>state</code>为<strong><u>执行完成</u></strong>状态<code>RAN</code>或<strong><u>已取消</u></strong>状态<code>CANCELLED</code>，且<code>runner</code>不为<code>null</code>。</li></ul></li><li>如果成功则<code>get()</code>方法立即返回。如果失败则到线程等待队列中去等待其他线程执行<code>release</code>操作。</li><li>当其他线程执行<code>release</code>操作唤醒当前线程后，当前线程再次执行<code>tryAcquireShared()</code>将返回正值<code>1</code>，当前线程将离开线程等待队列并唤醒它的后继线程。</li><li>最后返回计算的结果或抛出异常。</li></ol><p><code>FutureTask.run()</code>的执行过程如下：</p><ol type="1"><li>执行在构造函数中指定的任务（<code>Callable.call()</code>）。</li><li>以原子方式来更新同步状态（调用<code>AQS.compareAndSetState(int expect，int update)</code>，设置<code>state</code>为执行完成状态<code>RAN</code>）。如果这个原子操作成功，就设置代表计算结果的变量<code>result</code>的值为<code>Callable.call()</code>的返回值，然后调用<code>AQS.releaseShared(int arg)</code>。</li><li><code>AQS.releaseShared(int arg)</code>首先会回调在子类<code>Sync</code>中实现的<code>tryReleaseShared(arg)</code>来执行<code>release</code>操作（设置运行任务的线程<code>runner</code>为<code>null</code>，然会返回<code>true</code>）；然后唤醒线程等待队列中的第一个线程。</li><li>调用<code>FutureTask.done()</code>。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;Java的线程既是&lt;strong&gt;工作单元&lt;/strong&gt;，也是&lt;strong&gt;执行机制&lt;/strong&gt;。&lt;code&gt;JDK 5&lt;/code&gt;开始，把&lt;strong&gt;工作单元&lt;/strong&gt;与&lt;strong&gt;执行机制&lt;/strong&gt;分离开来，&lt;strong&gt;工作单元&lt;/strong&gt;包括&lt;code&gt;Runnable&lt;/code&gt;和&lt;code&gt;Callable&lt;/code&gt;，而执行机制由&lt;code&gt;Executor&lt;/code&gt;框架提供。</summary>
    
    
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
    <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--9 Java中的线程池</title>
    <link href="https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-9-Java-thread-pool.html"/>
    <id>https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-9-Java-thread-pool.html</id>
    <published>2021-07-21T12:19:57.000Z</published>
    <updated>2021-07-21T12:19:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。 <span id="more"></span></p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。使用线程池可以进行统一分配、调优和监控。</li></ul><h3 id="线程池的实现原理">1. 线程池的实现原理</h3><p>当提交一个新任务到线程池时，线程池的处理流程如下。</p><ul><li>线程池判断<u><strong>核心线程池是否已满</strong></u>。<ul><li>如果不是，则创建一个新的工作线程来执行任务。</li><li>如果是，则进入下个流程。</li></ul></li><li>线程池判断<strong><u>工作队列是否已经满</u></strong>。</li><li>如果工作队列没有满，则将新提交的任务存储在这个工作队列里。</li><li>如果工作队列满了，则进入下个流程。</li><li>线程池判断<strong><u>线程池是否已满</u></strong>。<ul><li>如果没有，则创建一个新的工作线程来执行任务。</li><li>如果已经满了，则交给饱和策略来处理这个任务。</li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter9/thradPoolFlow.PNG" alt="线程池的主要处理流程" /><figcaption aria-hidden="true">线程池的主要处理流程</figcaption></figure><p><code>ThreadPoolExecutor</code>执行<code>execute()</code>方法有四种情况：</p><ol type="1"><li>如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（<strong><u>需要获取全局锁</u></strong>）。</li><li>如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li><li>如果无法将任务加入<code>BlockingQueue</code>（队列已满），则创建新的线程来处理任务（<strong><u>需要获取全局锁</u></strong>）。</li><li>如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并调用 <code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ol><p>在<code>ThreadPoolExecutor</code>完成预热之后（当前运行的线程数大于等于<code>corePoolSize</code>），几乎所有的<code>execute()</code>方法调用都是执行步骤<code>2</code>，而步骤<code>2</code>不需要获取全局锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="comment">// 如果线程数小于基本线程数，则创建线程并执行当前任务</span></span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line"><span class="comment">// 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span></span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，</span></span><br><span class="line"><span class="comment">// 则创建一个线程执行任务。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line"><span class="comment">// 抛出RejectedExecutionException异常</span></span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter9/thradPoolExecute.PNG" alt="ThreadPoolExecutor" /><figcaption aria-hidden="true">ThreadPoolExecutor</figcaption></figure><p>线程池创建线程时，会将线程封装成工作线程<code>Worker</code>，<code>Worker</code>在执行完任务后，还会循环获取工作队列里的任务来执行。线程池中的线程执行任务分两种情况。</p><ol type="1"><li>在<code>execute()</code>方法中创建一个线程时，会让这个线程执行当前任务。</li><li>这个线程执行完<code>1</code>的任务后，会反复从<code>BlockingQueue</code>获取任务来执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Worker类的run()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Runnable task = firstTask;</span><br><span class="line">        firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            runTask(task);task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        workerDone(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池的使用">2 线程池的使用</h3><h4 id="线程池的创建">2.1 线程池的创建</h4><p>通过<code>ThreadPoolExecutor</code>来创建一个线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);</span><br></pre></td></tr></table></figure><p>输入几个参数介绍如下：</p><ul><li><code>corePoolSize</code>：线程池的基本大小。<ul><li>需要执行的任务数小于线程池基本大小时，即使其他空闲的基本线程能够执行新任务，线程池会先创建一个线程来执行任务。</li><li>如果调用了线程池的<code>prestartAllCoreThreads()</code>方法，线程池会<strong><u>提前</u></strong>创建并启动所有基本线程。</li></ul></li><li><code>runnableTaskQueue</code>：任务队列。用于保存等待执行的任务的阻塞队列。可以选择的阻塞队列有：<ul><li><code>ArrayBlockingQueue</code>；</li><li><code>LinkedBlockingQueue</code>。静态方法<code>Executors.newFixedThreadPool()</code>使用这个队列。</li><li><code>SynchronousQueue</code>。静态方法<code>Executors.newCachedThreadPool</code>使用这个队列。</li><li><code>PriorityBlockingQueue</code>。</li></ul></li><li><code>maximumPoolSize</code>：线程池允许创建的最大线程数。<ul><li>如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</li></ul></li><li><code>ThreadFactory</code>：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li><li><code>RejectedExecutionHandler</code>：饱和策略。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。策略默认情况下是<code>AbortPolicy</code>，表示无法处理新任务时抛出异常。Java线程池框架提供了以下4种策略。<ul><li><code>AbortPolicy</code>：直接抛出异常。</li><li><code>CallerRunsPolicy</code>：用调用者所在线程来运行任务。</li><li><code>DiscardOldestPolicy</code>：丢弃队列里最近的一个任务，并执行当前任务。</li><li><code>DiscardPolicy</code>：不处理，直接丢弃掉。</li><li>也可以实现<code>RejectedExecutionHandler</code>接口自定义策略</li></ul></li><li><code>keepAliveTime</code>：线程活动保持时间。线程池的工作线程空闲后，保持存活的时间。</li><li><code>TimeUnit</code>：线程活动保持时间的单位。可选的单位有<code>天（DAYS）</code>、<code>小时（HOURS）</code>、<code>分钟（MINUTES）</code>、<code>毫秒（MILLISECONDS）</code>、<code>微秒（MICROSECONDS）</code>和<code>纳秒（NANOSECONDS）</code>。</li></ul><h4 id="向线程池提交任务">2.2 向线程池提交任务</h4><p>可以使用两个方法向线程池提交任务：</p><ul><li><p><code>execute()</code>方法。用于提交<u><strong>不需要返回值</strong></u>的任务，所以无法判断任务是否被线程池执行成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>submit()</code>方法。用于提交<u><strong>需要返回值</strong></u>的任务，线程池会返回一个<code>future</code>类型的对象，通过该<code>future</code>对象可以判断任务是否执行成功，并可以通过<code>future</code>的<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Object s = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 处理中断异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="关闭线程池">2.3 关闭线程池</h4><p>通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。</p><blockquote><p>原理是<strong><u>遍历线程池中的工作线程</u></strong>，然后逐个调用线程的<code>interrupt</code>方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p></blockquote><ul><li><p><code>shutdownNow</code>首先将线程池的状态设置成<code>STOP</code>，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表；</p></li><li><p><code>shutdown</code>只是将线程池的状态设置成<code>SHUTDOWN</code>状态，然后中断所有<strong><u>没有正在执行任务</u></strong>的线程。</p></li><li><p>只要调用了关闭方法，<code>isShutdown</code>方法就会返回<code>true</code>。</p></li><li><p>当所有的任务都已关闭后，才表示线程池关闭成功，这时调用<code>isTerminaed</code>方法会返回<code>true</code>。</p></li></ul><h4 id="合理地配置线程池">2.4 合理地配置线程池</h4><ul><li>性质不同的任务可以用不同规模的线程池分开处理。</li><li>优先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理。</li><li>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</li><li><strong><u>建议使用有界队列</u></strong>。有界队列能增加系统的稳定性和预警能力。</li></ul><h4 id="线程池的监控">2.5 线程池的监控</h4><p>可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。</p><ul><li><code>taskCount</code>：线程池需要执行的任务数量。</li><li><code>completedTaskCount</code>：线程池在运行过程中已完成的任务数量，小于或等于<code>taskCount</code>。</li><li><code>largestPoolSize</code>：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。</li><li><code>getPoolSize</code>：线程池的线程数量。<u>如果线程池不销毁的话，线程池里的线程不会自动销毁</u>，所以这个大小<strong><u>只增不减</u></strong>。</li><li><code>getActiveCount</code>：获取活动的线程数。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。</summary>
    
    
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
    <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--8 Java中的并发工具类</title>
    <link href="https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-8-Java-concurrent-tools.html"/>
    <id>https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-8-Java-concurrent-tools.html</id>
    <published>2021-07-21T09:14:21.000Z</published>
    <updated>2021-07-21T09:14:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>CountDownLatch</code>、<code>CyclicBarrier</code>和<code>Semaphore</code>工具类提供了一种<strong><u>并发流程控制</u></strong>的手段，<code>Exchanger</code>工具类则提供了在<strong><u>线程间交换数据</u></strong>的一种手段。 <span id="more"></span></p></blockquote><h3 id="等待多线程完成的countdownlatch">1. 等待多线程完成的<code>CountDownLatch</code></h3><p>要实现主线程等待所有线程完成操作，最简单的做法是使用<code>join()</code>方法。<code>join</code>用于让当前执行线程等待<code>join</code>线程执行结束。原理是不停检查<code>join</code>线程是否存活，如果<code>join</code>线程存活则让当前线程永远等待。<code>join</code>线程中止后，线程的<code>this.notifyAll()</code>方法会被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CountDownLatch</code>允许一个或多个线程等待其他线程完成操作，比<code>join</code>的功能更多。</p><ul><li><code>CountDownLatch</code>的构造函数接收一个<code>int</code>类型的参数作为计数器，表示需要等待<code>N</code>个点完成。</li><li>调用<code>CountDownLatch</code>的<code>countDown</code>方法时，<code>N</code>就会减<code>1</code>；</li><li><code>CountDownLatch</code>的<code>await</code>方法会阻塞当前线程，直到<code>N</code>变成零。</li></ul><blockquote><p>由于<code>countDown</code>方法可以用在<strong><u>任何地方</u></strong>，所以这里说的<code>N</code>个点，可以是<code>N</code>个线程，也可以是<code>1</code>个线程里的<code>N</code>个执行步骤。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        c.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步屏障cyclicbarrier">2. 同步屏障<code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code>的字面意思是<strong><u>可循环使用（Cyclic）</u></strong>的<u><strong>屏障（Barrier）</strong></u>。让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><h4 id="cyclicbarrier简介">2.1 <code>CyclicBarrier</code>简介</h4><p><code>CyclicBarrier</code>默认的构造方法是<code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉<code>CyclicBarrier</code>我已经到达了屏障，然后当前线程被阻塞。</p><p><code>CyclicBarrier</code>还提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行<code>barrierAction</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment"> * given number of parties (threads) are waiting upon it, and which</span></span><br><span class="line"><span class="comment"> * will execute the given barrier action when the barrier is tripped,</span></span><br><span class="line"><span class="comment"> * performed by the last thread entering the barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties the number of threads that must invoke &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment"> *        before the barrier is tripped</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> barrierAction the command to execute when the barrier is</span></span><br><span class="line"><span class="comment"> *        tripped, or &#123;<span class="doctag">@code</span> null&#125; if there is no action</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties&#125; is less than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment"> * given number of parties (threads) are waiting upon it, and</span></span><br><span class="line"><span class="comment"> * does not perform a predefined action when the barrier is tripped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties the number of threads that must invoke &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment"> *        before the barrier is tripped</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties&#125; is less than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>CyclicBarrier</code>可以用于<u><strong>多线程计算数据，最后合并计算结果的场景</strong></u>。</p></blockquote><h4 id="cyclicbarrier和countdownlatch的区别">2.2 <code>CyclicBarrier</code>和<code>CountDownLatch</code>的区别</h4><p><code>CountDownLatch</code>的计数器只能使用一次，<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置。<code>CyclicBarrier</code>还提供其他有用的方法：</p><ul><li><code>getNumberWaiting</code>方法可以获得<code>CyclicBarrier</code>阻塞的线程数量。</li><li><code>isBroken()</code>方法用来了解阻塞的线程是否被中断。</li></ul><h3 id="控制并发线程数的semaphore">3. 控制并发线程数的<code>Semaphore</code></h3><p><code>Semaphore（信号量）</code>是用来控制<strong><u>同时访问特定资源的线程数量</u></strong>，它通过协调各个线程，以保证合理的使用公共资源。</p><h4 id="应用场景">3.1 应用场景</h4><p><code>Semaphore</code>可以用于做<strong><u>流量控制</u></strong>，特别是公用资源有限的应用场景，比如数据库连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println(<span class="string">&quot;save data&quot;</span>);</span><br><span class="line">                        s.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他方法">3.2 其他方法</h4><ul><li><code>intavailablePermits()</code>：返回此信号量中当前可用的许可证数。</li><li><code>intgetQueueLength()</code>：返回正在等待获取许可证的线程数。</li><li><code>booleanhasQueuedThreads()</code>：是否有线程正在等待获取许可证。</li><li><code>void reducePermits(int reduction)</code>：减少<code>reduction</code>个许可证，是个<code>protected</code>方法。</li><li><code>Collection getQueuedThreads()</code>：返回所有等待获取许可证的线程集合，是个<code>protected</code>方法。</li></ul><h3 id="线程间交换数据的exchanger">4. 线程间交换数据的<code>Exchanger</code></h3><p><code>Exchanger（交换者）</code>是一个用于<strong><u>线程间协作</u></strong>的工具类。<code>Exchanger</code>用于进行<strong><u>线程间的数据交换</u></strong>。</p><ul><li>它提供一个<code>同步点</code>，在这个同步点，两个线程通过<code>exchange</code>方法交换彼此的数据，如果第一个线程先执行<code>exchange()</code>方法，它会一直等待第二个线程也执行<code>exchange</code>方法；</li><li>当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方；</li><li>可以使用<code>exchange(V x，longtimeout，TimeUnit unit)</code>设置最大等待时长。</li></ul><h4 id="应用场景-1">4.1 应用场景</h4><ul><li><code>Exchanger</code>可以用于<strong><u>遗传算法</u></strong>，遗传算法里需要选出两个人作为配对对象，这时候会交换两人的数据。</li><li><code>Exchanger</code>也可以用于<strong><u>校对工作</u></strong>。如对两份录入数据进行校对，看看是否录入一致。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String A = <span class="string">&quot;银行流水A&quot;</span>; <span class="comment">// A录入银行流水数据</span></span><br><span class="line">                    String B = exgr.exchange(A);</span><br><span class="line">                    System.out.println(<span class="string">&quot;A和B数据是否一致：&quot;</span> + A.equals(B) + <span class="string">&quot;，A录入的是：&quot;</span>+ A + <span class="string">&quot;，B录入是：&quot;</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String B = <span class="string">&quot;银行流水B&quot;</span>; <span class="comment">// B录入银行流水数据</span></span><br><span class="line">                    String A = exgr.exchange(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;A和B数据是否一致：&quot;</span> + A.equals(B) + <span class="string">&quot;，A录入的是：&quot;</span>+ A + <span class="string">&quot;，B录入是：&quot;</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;CyclicBarrier&lt;/code&gt;和&lt;code&gt;Semaphore&lt;/code&gt;工具类提供了一种&lt;strong&gt;&lt;u&gt;并发流程控制&lt;/u&gt;&lt;/strong&gt;的手段，&lt;code&gt;Exchanger&lt;/code&gt;工具类则提供了在&lt;strong&gt;&lt;u&gt;线程间交换数据&lt;/u&gt;&lt;/strong&gt;的一种手段。</summary>
    
    
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
    <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--7 Java中的13个原子操作类</title>
    <link href="https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-7-Java-atomic-class.html"/>
    <id>https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-7-Java-atomic-class.html</id>
    <published>2021-07-21T08:06:12.000Z</published>
    <updated>2021-07-21T08:06:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>java.util.concurrent.atomic</code>包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。<code>Atomic</code>包里的类基本都是<u>使用<code>Unsafe</code>实现的包装类</u>。 <span id="more"></span></p></blockquote><h3 id="原子更新基本类型类">1. 原子更新基本类型类</h3><p><code>Atomic</code>包提供了3个类更新基本类型：</p><ul><li><code>AtomicBoolean</code>：原子更新布尔类型。</li><li><code>AtomicInteger</code>：原子更新整型。</li><li><code>AtomicLong</code>：原子更新长整型。</li></ul><p>以上3个类提供的方法几乎一模一样，常用方法有：</p><ul><li><p><code>int addAndGet(int delta)</code>：以原子方式将输入的数值与实例中的值（<code>AtomicInteger</code>里的<code>value</code>）相加，并返回结果。</p></li><li><p><code>boolean compareAndSet(int expect，int update)</code>：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>int getAndIncrement()</code>：以原子方式将当前值加<code>1</code>，返回的是自增前的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk 1.8 实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>void lazySet(int newValue)</code>：最终会设置成<code>newValue</code>，使用<code>lazySet</code>设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</p></li><li><p><code>int getAndSet(int newValue)</code>：以原子方式设置为<code>newValue</code>的值，并返回旧值。</p></li></ul><p><code>Atomic</code>包里的类基本都是使用<code>Unsafe</code>实现的。<code>Unsafe</code>只提供了<code>3</code>种<code>CAS</code>方法，<code>AtomicBoolean</code>先把<code>Boolean</code>转换成<strong>整型</strong>，再使用<code>compareAndSwapInt</code>进行<code>CAS</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果当前数值是expected，则原子的将Java变量更新成x</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果更新成功则返回true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object expected, Object x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> expected, <span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="原子更新数组">2. 原子更新数组</h3><p>Atomic包提供了4个类更新数组里的某个元素：</p><ul><li><code>AtomicIntegerArray</code>：原子更新整型数组里的元素。</li><li><code>AtomicLongArray</code>：原子更新长整型数组里的元素。</li><li><code>AtomicReferenceArray</code>：原子更新引用类型数组里的元素。</li><li><code>AtomicBooleanArray</code> ：原子更新布尔类型数组的元素。</li></ul><p>其常用方法如下：</p><ul><li><p><code>int addAndGet(int i，int delta)</code>：以原子方式将输入值与数组中索引<code>i</code>的元素相加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getAndAdd(i, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;index &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.getAndAddInt(array, checkedByteOffset(i), delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>boolean compareAndSet(int i，int expect，int update)</code>：如果当前值等于预期值，则以原子方式将数组位置<code>i</code>的元素设置成<code>update</code>值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基于已有数组创建<code>AtomicIntegerArray</code>对象时，构造函数会将当前数组复制一份，所以当<code>AtomicIntegerArray</code>对内部的数组元素进行修改时，不会影响原数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Visibility guaranteed by final field guarantees</span></span><br><span class="line">    <span class="keyword">this</span>.array = array.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="原子更新引用类型">3. 原子更新引用类型</h3><p>Atomic包提供了3个类原子更新引用类型：</p><ul><li><p><code>AtomicReference</code>：原子更新引用类型。</p></li><li><p><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段。</p></li><li><p><code>AtomicMarkableReference</code>：原子更新带有标记位的引用类型。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更新的仅仅只是引用，引用的对象并未改变。</p></blockquote><h3 id="原子更新字段类">4. 原子更新字段类</h3><p>Atomic包提供了3个类进行原子字段更新。</p><ul><li><code>AtomicIntegerFieldUpdater</code>：原子更新整型的字段的更新器。</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器。</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。可以解决使用<code>CAS</code>进行原子更新时可能出现的<code>ABA</code>问题。</li></ul><p>原子地更新字段类需要两步。</p><ul><li>第一步，必须使用静态方法<code>newUpdater()</code>创建一个更新器，并且需要设置想要更新的类和属性。</li><li>第 二步，更新类的字段（属性）必须使用<code>public volatile</code>修饰符。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建原子更新器，并设置需要更新的对象类和对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.</span><br><span class="line">        newUpdater(User.class, <span class="string">&quot;old&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置柯南的年龄是10岁</span></span><br><span class="line">        User conan = <span class="keyword">new</span> User(<span class="string">&quot;conan&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 柯南长了一岁，但是仍然会输出旧的年龄</span></span><br><span class="line">        System.out.println(a.getAndIncrement(conan));</span><br><span class="line">        <span class="comment">// 输出柯南现在的年龄</span></span><br><span class="line">        System.out.println(a.get(conan));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> old;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.old = old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt;包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。&lt;code&gt;Atomic&lt;/code&gt;包里的类基本都是&lt;u&gt;使用&lt;code&gt;Unsafe&lt;/code&gt;实现的包装类&lt;/u&gt;。</summary>
    
    
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
    <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--6 Java并发容器和框架</title>
    <link href="https://wuyunjie.top/2021/07/20/JavaLearning_The_art_of_concurrent_programming_in_Java-6-Java-concurrent-container-and-framework.html"/>
    <id>https://wuyunjie.top/2021/07/20/JavaLearning_The_art_of_concurrent_programming_in_Java-6-Java-concurrent-container-and-framework.html</id>
    <published>2021-07-20T12:56:06.000Z</published>
    <updated>2021-07-20T12:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>并发编程大师Doug Lea不遗余力地为Java开发者提供了非常多的并发容器和框架</code> <span id="more"></span></p></blockquote><h3 id="concurrenthashmap的实现原理">1. <code>ConcurrentHashMap</code>的实现原理</h3><p>在并发编程中使用<code>HashMap</code>可能导致程序死循环，而使用线程安全的<code>HashTable</code>效率又非常低下。<code>ConcurrentHashMap</code>是线程安全且高效的<code>HashMap</code>。</p><ul><li><p><strong>线程不安全的<code>HashMap</code></strong>。在多线程环境下，使用<code>HashMap</code>进行<code>put</code>操作会引起死循环。</p></li><li><p><strong>效率低下的<code>HashTable</code></strong>。<code>HashTable</code>容器使用<code>synchronized</code>来保证线程安全，但在线程竞争激烈的情况下<code>HashTable</code>的效率非常低下。</p></li><li><p><code>ConcurrentHashMap</code>的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p></li></ul><h4 id="concurrenthashmap的结构">1.1 <code>ConcurrentHashMap</code>的结构</h4><p><code>ConcurrentHashMap</code>是由<code>Segment</code>数组结构和<code>HashEntry</code>数组结构组成。</p><ul><li><code>Segment</code>是一种<strong>可重入锁</strong>（<code>ReentrantLock</code>），一个<code>ConcurrentHashMap</code>里包含一个<code>Segment</code>数组；<ul><li><code>Segment</code>的结构和<code>HashMap</code>类似，是一种<strong>数组和链表结构</strong>；</li><li>一个<code>Segment</code>里包含一个<code>HashEntry</code>数组，每个<code>Segment</code>守护着一个<code>HashEntry</code>数组里的元素，当对<code>HashEntry</code>数组的数据进行修改时，必须首先获得与它对应的<code>Segment</code>锁。</li></ul></li><li><code>HashEntry</code>则用于存储键值对数据，每个<code>HashEntry</code>是一个<strong>链表结构</strong>的元素。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentHashMapClass.PNG" alt="ConcurrentHashMap类图" /><figcaption aria-hidden="true">ConcurrentHashMap类图</figcaption></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentHashMapStructure.PNG" alt="ConcurrentHashMap结构" /><figcaption aria-hidden="true">ConcurrentHashMap结构</figcaption></figure><h4 id="concurrenthashmap的初始化">1.2 <code>ConcurrentHashMap</code>的初始化</h4><p><code>ConcurrentHashMap</code>初始化方法是通过<code>initialCapacity</code>、<code>loadFactor</code>和<code>concurrencyLevel</code>等几个参数来初始化<code>segment</code>数组、段偏移量<code>segmentShift</code>、段掩码<code>segmentMask</code>和每个<code>segment</code>里的<code>HashEntry</code>数组来实现的。</p><h5 id="初始化segments数组">1.2.1 初始化<code>segments</code>数组</h5><p><code>segments</code>数组的长度<code>ssize</code>是通过<code>concurrencyLevel</code>计算得出的：</p><ul><li>为了能通过<code>按位与的散列算法</code>来定位<code>segments</code>数组的索引，必须保证<code>segments</code>数组的长度是<code>2</code>的<code>N</code>次方，所以必须计算出一个大于或等于<code>concurrencyLevel</code>的最小的2的N次方值来作为<code>segments</code>数组的长度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure><h5 id="初始化segmentshift和segmentmask">1.2.2 初始化<code>segmentShift</code>和<code>segmentMask</code></h5><p>这两个全局变量需要在定位<code>segment</code>时的散列算法里使用：</p><ul><li><code>sshift</code>等于<code>ssize</code>从1向左移位的次数。<code>segmentShift</code>用于<u><strong>定位参与散列运算的位数</strong></u>，<code>segmentShift</code>等于<code>32</code>减<code>sshift</code>，这里之所以用32是因为<code>ConcurrentHashMap</code>里的<code>hash()</code>方法输出的最大数是32位的。</li><li><code>segmentMask</code>是散列运算的掩码，等于<code>ssize</code>减<code>1</code>，掩码的二进制各个位的值都是<code>1</code>。</li></ul><h5 id="初始化每个segment">1.2.3 初始化每个<code>segment</code></h5><p>输入参数<code>initialCapacity</code>是<code>ConcurrentHashMap</code>的<strong>初始化容量</strong>，<code>loadfactor</code>是每个<code>segment</code>的<strong>负载因子</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">++c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line"><span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);</span><br></pre></td></tr></table></figure><ul><li>变量<code>cap</code>是<code>segment</code>里<code>HashEntry</code>数组的长度，它等于<code>initialCapacity</code>除以<code>ssize</code>的倍数<code>c</code>。</li><li><code>segment</code>的容量<code>threshold＝（int）cap*loadFactor</code>。</li></ul><h4 id="定位segment">1.3 定位<code>Segment</code></h4><p>在<strong>插入和获取</strong>元素的时候，必须先通过散列算法定位到<code>Segment</code>。</p><ul><li><code>ConcurrentHashMap</code>会首先使用<code>Wang/Jenkins hash</code>的变种算法对元素的<code>hashCode</code>进行一次再散列。目的是<strong><u>减少散列冲突</u></strong>，使元素能够均匀地分布在不同的<code>Segment</code>上， 从而提高容器的存取效率。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种再散列能让数字的每一位都参加到散列运算当中，从而减少散列冲突。<code>ConcurrentHashMap</code>通过以下散列算法定位<code>segment</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="concurrenthashmap的操作">1.4 <code>ConcurrentHashMap</code>的操作</h4><h5 id="get操作">1.4.1 <code>get</code>操作</h5><p><code>Segment</code>的<code>get</code>操作先经过一次再散列，然后使用这个散列值通过散列运算定位到<code>Segment</code>，再通过散列算法定位到元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line"><span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get</code>操作的高效之处在于<u><strong>整个<code>get</code>过程不需要加锁，除非读到的值是空才会加锁重读</strong></u>。</p><ul><li><p><code>get</code>方法里将要使用的共享变量都定义成<code>volatile</code>类型，如用于统计当前<code>Segement</code>大小的<code>count</code>字段和用于存储值的<code>HashEntry</code>的<code>value</code>。这是用volatile替换锁的经典应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">volatile</span> V value;</span><br></pre></td></tr></table></figure></li><li><p>定位<code>Segment</code>使用的是元素的<code>hashcode</code>通过再散列后得到的值的高位，而定位<code>HashEntry</code>直接使用的是再散列后的值。其目的是避免两次散列后的值一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask <span class="comment">// 定位Segment所使用的hash算法</span></span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); <span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="put操作">1.4.2 <code>put</code>操作</h5><p><code>put</code>方法首先定位到<code>Segment</code>，然后在<code>Segment</code>里进行插入操作。插入操作需要经历两个步骤</p><ul><li>第一步判断是否需要对<code>Segment</code>里的<code>HashEntry</code>数组进行扩容；<ul><li>在<strong><u>插入元素前</u></strong>先判断<code>Segment</code>里的<code>HashEntry</code>数组是否超过<code>容量（threshold）</code>，如果超过阈值，则对数组进行扩容。扩容的时候首先会创建一个容量是<strong><u>原来容量两倍</u></strong>的数组，然后将原数组里的元素进行<u><strong>再散列后插入</strong></u>到新的数组里。</li><li><code>HashMap</code>是在<strong><u>插入元素后</u></strong>判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时<code>HashMap</code>就进行了一次无效的扩容。</li></ul></li><li>第二步定位添加元素的位置，然后将其放在<code>HashEntry</code>数组里。</li></ul><h5 id="size操作">1.4.3 <code>size</code>操作</h5><p><code>ConcurrentHashMap</code>统计<code>size</code>时，先尝试<code>2</code>次通过<strong>不锁住</strong><code>Segment</code>的方式来统计各个<code>Segment</code>大小，如果统计的过程中，容器的<code>count</code>发生了变化，则再采用<strong>加锁</strong>的方式来统计所有<code>Segment</code>的大小。</p><h3 id="concurrentlinkedqueue">2. <code>ConcurrentLinkedQueue</code></h3><p>实现一个线程安全的队列有两种方式：</p><ul><li><strong>使用阻塞算法</strong>。用一个<strong>锁</strong>（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</li><li><strong>使用非阻塞算法</strong>。使用循环<code>CAS</code>的方式来实现。</li></ul><p><code>ConcurrentLinkedQueue</code>是一个基于链接节点的<strong>无界线程安全队列</strong>。它采用了<code>“wait-free”算法</code>（即<code>CAS</code>算法）来实现。</p><h4 id="concurrentlinkedqueue的结构">2.1 <code>ConcurrentLinkedQueue</code>的结构</h4><p><code>ConcurrentLinkedQueue</code>由<code>head</code>节点和<code>tail</code>节点组成。</p><ul><li>每个节点（Node）由节点元素（item）和 指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一 张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail = head;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentLinkedQueueClass.PNG" alt="ConcurrentLinkedQueue类图" /><figcaption aria-hidden="true">ConcurrentLinkedQueue类图</figcaption></figure><h4 id="入队列">2.2 入队列</h4><h5 id="入队列的过程">2.2.1 入队列的过程</h5><p>入队列就是将入队节点添加到队列的尾部。入队主要做两件事情：</p><ul><li>将<strong>入队节点</strong>设置成当前队列尾节点的下一个节点；</li><li>更新<code>tail</code>节点，如果<code>tail</code>节点的<code>next</code>节点不为空，则将入队节点设置成<code>tail</code>节点，如果<code>tail</code>节点的<code>next</code>节点为空，则将入队节点设置成<code>tail</code>的<code>next</code>节点，<u><strong>所以<code>tail</code>节点不总是尾节点</strong></u>。</li></ul><p>多个线程同时进行入队操作时，使用<code>CAS</code>算法来入队：</p><ul><li>首先定位出尾节点；</li><li>然后使用<code>CAS</code>算法将入队节点设置成尾节点的<code>next</code>节点，如不成功则重试。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 入队前，创建一个入队节点</span></span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    </span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 死循环，入队不成功反复入队。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 创建一个指向tail节点的引用</span></span><br><span class="line">        Node&lt;E&gt; t = tail;</span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class="line">        Node&lt;E&gt; p = t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">            <span class="comment">// 获得p节点的下一个节点。</span></span><br><span class="line">            Node&lt;E&gt; next = succ(p);</span><br><span class="line">            <span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;</span><br><span class="line">                <span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</span></span><br><span class="line"><span class="comment">                  更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt;= HOPS)</span><br><span class="line">                    casTail(t, n); <span class="comment">// 更新tail节点，允许失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = succ(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>入队方法永远返回<code>true</code>，所以不要通过返回值判断入队是否成功。</p></blockquote><h5 id="定位尾节点">2.2.2 定位尾节点</h5><p><code>tail</code>节点并不总是尾节点，所以每次入队都必须先通过<code>tail</code>节点来找到尾节点。</p><blockquote><p>尾节点可能是<code>tail</code>节点，也可能是<code>tail</code>节点的<code>next</code>节点。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">Node&lt;E&gt; next = p.getNext();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取tail节点的next节点需要注意的是 p 节点等于 p 的 next 节点的情况，</span></span><br><span class="line"><span class="comment">     * 此时p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="设置入队节点为尾节点">2.2.3 设置入队节点为尾节点</h5><p><code>p.casNext(null，n)</code>方法用于将入队节点设置为当前队列尾节点的<code>next</code>节点：</p><ul><li>如果<code>p</code>是<code>null</code>， 表示<code>p</code>是当前队列的尾节点；</li><li>如果不为<code>null</code>，表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</li></ul><h5 id="hops的设计">2.2.4 <code>HOPS</code>的设计</h5><p>使用<code>hops</code>变量来<strong><u>控制并减少<code>tail</code>节点的更新频率</u></strong>。</p><ul><li>不是每次节点入队后都将<code>tail</code>节点更新成尾节点，而是当<code>tail</code>节点和尾节点的距离大于等于常量<code>HOPS</code>的值（默认等于1）时才更新<code>tail</code>节点。<strong><u><code>tail</code>和尾节点的距离越长，使用<code>CAS</code>更新<code>tail</code>节点的次数就会越少</u></strong>；</li><li>但是距离越长带来的<strong>负面效果</strong>就是<u>每次入队时定位尾节点的时间就越长</u>，因为循环体需要多循环一次来定位出尾节点。但是这样仍然能提高入队的效率，因为<u><strong>通过增加对<code>volatile</code>变量的读操作来减少对<code>volatile</code>变量的写操作</strong></u>，而对volatile变量的写操作开销要远远大于读操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOPS = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="出队列">2.3 出队列</h4><p><strong>出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用</strong>。与入队列类似，<u>不是每次出队时都更新<code>head</code>节点</u>，通过<code>hops</code>变量来减少使用<code>CAS</code>更新<code>head</code>节点的消耗。</p><ul><li>当<code>head</code>节点里<strong>有元素</strong>时，直接弹出<code>head</code>节点里的元素，而不会更新<code>head</code>节点。</li><li>只有当<code>head</code>节点里<strong>没有元素</strong>时，出队操作才会更新<code>head</code> 节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">// p表示头节点，需要出队的节点</span></span><br><span class="line">    Node&lt;E&gt; p = h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">        <span class="comment">// 获取p节点的元素</span></span><br><span class="line">        E item = p.getItem();</span><br><span class="line">        <span class="comment">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</span></span><br><span class="line">        <span class="comment">// 如果成功则返回p节点的元素。</span></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hops &gt;= HOPS) &#123;</span><br><span class="line">                <span class="comment">// 将p节点下一个节点设置成head节点</span></span><br><span class="line">                Node&lt;E&gt; q = p.getNext();</span><br><span class="line">                updateHead(h, (q != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</span></span><br><span class="line">        <span class="comment">// 一个线程修改了。那么获取p节点的下一个节点</span></span><br><span class="line">        Node&lt;E&gt; next = succ(p);</span><br><span class="line">        <span class="comment">// 如果p的下一个节点也为空，说明这个队列已经空了</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 更新头节点。</span></span><br><span class="line">            updateHead(h, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span></span><br><span class="line">        p = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个线程同时进行出队操作时，使用<code>CAS</code>算法来出队：</p><ul><li>首先获取<strong>头节点的元素</strong>，然后判断<strong>头节点元素</strong>是否为空；</li><li>如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走；</li><li>如果不为空，则使用<code>CAS</code>的方式将头节点的引用设置成<code>null</code>；<ul><li>如果<code>CAS</code>成功，则直接返回头节点的元素；</li><li>如果不成功，表示另外一个线程已经进行了一次出队操作更新了<code>head</code>节点，需要重新获取头节点。</li></ul></li></ul><h3 id="java中的阻塞队列">3. Java中的阻塞队列</h3><h4 id="阻塞队列介绍">3.1 阻塞队列介绍</h4><p><code>阻塞队列（BlockingQueue）</code>支持阻塞的插入和移除方法。</p><ul><li><strong>支持阻塞的插入方法</strong>：当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li><li><strong>支持阻塞的移除方法</strong>：在队列为空时，获取元素的线程会等待队列变为非空。</li></ul><p>在阻塞队列不可用时，这两个附加操作提供了4种处理方式：</p><ul><li><strong>抛出异常</strong>：当队列满时，如果再往队列里插入元素，会抛出<code>IllegalStateException("Queue full")</code>异常。当队列空时，从队列里获取元素会抛出<code>NoSuchElementException</code>异常。主要方法有：<code>add(e), remove(), element()</code>。</li><li><strong>返回特殊值</strong>：当往队列插入元素时，会返回元素是否插入成功，成功返回<code>true</code>。如果是移除方法，则是从队列里取出一个元素，如果没有则返回<code>null</code>。主要方法有：<code>offer(e), poll(), peek()</code>。</li><li><strong>一直阻塞</strong>：当阻塞队列满时，如果生产者线程往队列里<code>put</code>元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里<code>take</code>元素，队列会阻塞住消费者线程，直到队列不为空。主要方法有：<code>put(e), take()</code>。</li><li><strong>超时退出</strong>：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。主要方法有：<code>offer(e, time, unit), poll(time, unit)</code>。</li></ul><blockquote><p>无界阻塞队列<strong>不可能会出现满</strong>的情况，所以使用<code>put</code>或<code>offer</code>方法永远不会被阻塞，而且使用<code>offer</code>方法时，该方法永远返回<code>true</code>。</p></blockquote><h4 id="java里的阻塞队列">3.2 Java里的阻塞队列</h4><p><code>JDK 7</code>提供了<code>7</code>个阻塞队列。</p><h5 id="arrayblockingqueue">3.2.1 <code>ArrayBlockingQueue</code></h5><p>一个由<strong><u>数组结构</u></strong>组成的<strong>有界</strong>阻塞队列，默认情况下不保证线程公平的访问队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="linkedblockingqueue">3.2.2 <code>LinkedBlockingQueue</code></h5><p>一个由<strong><u>链表结构</u></strong>组成的<strong>有界</strong>阻塞队列。此队列的默认和最大长度为<code>Integer.MAX_VALUE</code>。</p><h5 id="priorityblockingqueue">3.2.3 <code>PriorityBlockingQueue</code></h5><p>一个<strong><u>支持优先级排序</u></strong>的<strong>无界</strong>阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现<code>compareTo()</code>方法来指定元素排序规则，或者初始化<code>PriorityBlockingQueue</code>时，指定构造参数<code>Comparator</code>来对元素进行排序。</p><blockquote><p>不能保证同优先级元素的顺序。</p></blockquote><h5 id="delayqueue">3.2.4 <code>DelayQueue</code></h5><p>一个使用<u><strong>优先级队列(<code>PriorityQueue</code>)</strong></u>实现的<strong>无界</strong>阻塞队列，支持<strong><u>延时获取元素</u></strong>。</p><ul><li>队列中的元素必须实现<code>Delayed</code>接口，在创建元素时可以指定多久才能从队列中获取当前元素。</li><li>只有在延迟期满时才能从队列中提取元素。</li></ul><h6 id="delayed接口实现">3.2.4.1 <code>Delayed</code>接口实现</h6><p>参考<code>ScheduledThreadPoolExecutor</code>里<code>ScheduledFutureTask</code>类的实现。</p><ul><li>第一步：在对象创建的时候，初始化基本数据。使用<code>time</code>记录当前对象延迟到什么时候可以使用，使用<code>sequenceNumber</code>来标识元素在队列中的先后顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二步：实现<code>getDelay</code>方法，该方法返回当前元素还需要延时多长时间，单位是纳秒。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三步：实现<code>compareTo</code>方法来指定元素的顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero ONLY if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;&gt; x = (ScheduledFutureTask&lt;&gt;)other;</span><br><span class="line">        <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// othter 不是 ScheduledFutureTask 对象时</span></span><br><span class="line">    <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) - other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">    <span class="keyword">return</span> (d == <span class="number">0</span>) ? <span class="number">0</span> : ( (d &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="实现延时阻塞队列">3.2.4.2 实现延时阻塞队列</h6><p>当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> q.poll();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">    available.await();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    Thread thisThread = Thread.currentThread();</span><br><span class="line">    leader = thisThread;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        available.awaitNanos(delay);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>leader</code>是一个<u><strong>等待获取队列头部元素的线程</strong></u>。</p><ul><li>如果<code>leader</code>不等于空，表示<u>已经有线程在等待获取队列的头元素</u>。使用<code>await()</code>方法让当前线程等待信号；</li><li>如果<code>leader</code>等于空，则把当前线程设置成<code>leader</code>，并使用<code>awaitNanos()</code>方法让当前线程等待接收信号或等待<code>delay</code>时间。</li></ul><h6 id="delayqueue应用场景">3.2.4.3 <code>DelayQueue</code>应用场景</h6><ul><li><strong>缓存系统的设计</strong>：用<code>DelayQueue</code>保存缓存元素的<u>有效期</u>，使用一个线程循环查询<code>DelayQueue</code>，一旦能从<code>DelayQueue</code>中获取元素时，表示缓存有效期到了。</li><li><strong>定时任务调度</strong>：使用<code>DelayQueue</code>保存当天将会执行的任务和执行时间，一旦从<code>DelayQueue</code>中获取到任务就开始执行，比如<code>TimerQueue</code>就是使用<code>DelayQueue</code>实现的。</li></ul><h5 id="synchronousqueue">3.2.5 <code>SynchronousQueue</code></h5><p>一个<strong><u>不存储元素</u></strong>的阻塞队列。每一个<code>put</code>操作<strong><u>必须等待</u></strong>一个<code>take</code>操作， 否则不能继续添加元素。默认情况下线程采用非公平性策略访问队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">transferer = fair ? <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列本身并不存储任何元素，非常适合传递性场景。</p><ul><li><code>SynchronousQueue</code>的吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>。</li></ul><h5 id="linkedtransferqueue">3.2.6 <code>LinkedTransferQueue</code></h5><p>一个由<strong><u>链表结构</u></strong>组成的<strong>无界</strong>阻塞队列。<code>LinkedTransferQueue</code>增加了<code>tryTransfer</code>和<code>transfer</code>方法。</p><ol type="1"><li><p><code>transfer</code>方法</p><ul><li>如果当前有消费者正在等待接收元素，<code>transfer</code>方法可以把生产者传入的元素立刻<code>transfer</code>（传输）给消费者。</li><li>如果没有消费者在等待接收元素，<code>transfer</code>方法会将元素存放在队列的<code>tail</code>节点，并等到该元素被消费者消费了才返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试图把存放当前元素的s节点作为tail节点</span></span><br><span class="line">Node pred = tryAppend(s, haveData);</span><br><span class="line"><span class="comment">// 让CPU自旋等待消费者消费元素</span></span><br><span class="line"><span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br></pre></td></tr></table></figure></li><li><p><code>tryTransfer</code>方法</p><p>用来试探生产者传入的元素是否能直接传给消费者。</p><ul><li>如果没有消费者等待接收元素，则返回<code>false</code>；</li><li><code>tryTransfer</code>方法无论消费者是否接收，方法<u><strong>立即返回</strong></u>；<code>transfer</code>方法是<u><strong>必须等到消费者消费了才返回</strong></u>。</li><li>带有时间限制的<code>tryTransfer(E e, long timeout, TimeUnit unit)</code>方法，如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false；如果在超时时间内消费了元素，则返回true。</li></ul></li></ol><h5 id="linkedblockingdeque">3.2.7 <code>LinkedBlockingDeque</code></h5><p>一个由<strong><u>链表结构</u></strong>组成的<strong><u>双向</u></strong>阻塞队列。在初始化<code>LinkedBlockingDeque</code>时可以设置容量防止其过度膨胀。</p><blockquote><p>双向阻塞队列可以运用在<code>“工作窃取”模式</code>中。</p></blockquote><h4 id="阻塞队列的实现">3.3 阻塞队列的实现</h4><p>使用<strong><u>通知模式</u></strong>实现阻塞队列。如<code>ArrayBlockingQueue</code>使用了<code>Condition</code>来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        insert(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> extract();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    putIndex = inc(putIndex);</span><br><span class="line">    ++count;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞生产者主要通过 <code>LockSupport.park(this)</code>来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程加入等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步状态，也就是释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 调用setBlocker先保存一下将要阻塞的线程</span></span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    <span class="comment">// 调用unsafe.park阻塞当前线程</span></span><br><span class="line">    unsafe.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unsafe.park是个native方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure><p><code>park</code>方法会阻塞当前线程，只有以下4种情况中的一种发生时，该方法才会返回：</p><ul><li>与<code>park</code>对应的<code>unpark</code>执行或已经执行时。<code>“已经执行”</code>是指<u><code>unpark</code>先执行，然后再执行<code>park</code></u>的情况。</li><li>线程被中断时。</li><li>等待完<code>time</code>参数指定的毫秒数时。</li><li>异常现象发生时，这个异常现象没有任何原因。</li></ul><p><code>Linux</code>下使用的是系统方法<code>pthread_cond_wait</code>实现<code>park</code>方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> os::PlatformEvent::<span class="built_in">park</span>() &#123;</span><br><span class="line">    <span class="keyword">int</span> v ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        v = _Event ;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg</span> (v<span class="number">-1</span>, &amp;_Event, v) == v) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">guarantee</span> (v &gt;= <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// Do this the hard way by blocking ...</span></span><br><span class="line">        <span class="keyword">int</span> status = <span class="built_in">pthread_mutex_lock</span>(_mutex);</span><br><span class="line">        <span class="built_in">assert_status</span>(status == <span class="number">0</span>, status, <span class="string">&quot;mutex_lock&quot;</span>);</span><br><span class="line">        <span class="built_in">guarantee</span>(_nParked == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        ++ _nParked;</span><br><span class="line">        <span class="keyword">while</span> (_Event &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// pthread_cond_wait是一个多线程的条件变量函数</span></span><br><span class="line">            status = <span class="built_in">pthread_cond_wait</span>(_cond, _mutex);</span><br><span class="line"><span class="comment">// for some reason, under 2.7 lwp_cond_wait() may return ETIME ...</span></span><br><span class="line"><span class="comment">// Treat this the same as if the wait was interrupted</span></span><br><span class="line">            <span class="keyword">if</span> (status == ETIME) &#123; status = EINTR; &#125;</span><br><span class="line">            <span class="built_in">assert_status</span>(status == <span class="number">0</span> || status == EINTR, status, <span class="string">&quot;cond_wait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        -- _nParked ;</span><br><span class="line"><span class="comment">// In theory we could move the ST of 0 into _Event past the unlock(),</span></span><br><span class="line"><span class="comment">// but then we&#x27;d need a MEMBAR after the ST.</span></span><br><span class="line">        _Event = <span class="number">0</span> ;</span><br><span class="line">        status = <span class="built_in">pthread_mutex_unlock</span>(_mutex);</span><br><span class="line">        <span class="built_in">assert_status</span>(status == <span class="number">0</span>, status, <span class="string">&quot;mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">guarantee</span> (_Event &gt;= <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="forkjoin框架">4. Fork/Join框架</h3><h4 id="forkjoin框架介绍">4.1 Fork/Join框架介绍</h4><p><code>Fork/Join框架</code>是<code>Java 7</code>提供的一个<strong><u>用于并行执行任务</u></strong>的框架。它<u>把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果</u>。</p><ul><li><code>Fork</code>就是把一个大任务切分为若干子任务并行的执行；</li><li><code>Join</code>就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li></ul><h4 id="工作窃取算法">4.2 工作窃取算法</h4><p><code>工作窃取（work-stealing）</code>算法是指<u><strong>某个线程从其他队列里窃取任务来执行</strong></u>。</p><ul><li>把大任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。</li><li>但某个线程先完成自己队列里的任务，而其他线程对应的队列里还有任务等待处理，它会去其他线程的队列里窃取一个任务来执行。</li><li>为了减少窃取任务线程和被窃取任务线程之间的竞争，通常使用<strong><u>双端队列</u></strong>，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</li></ul><p><strong>工作窃取算法的优点</strong>：充分利用线程进行并行计算，减少了线程间的竞争。</p><p><strong>工作窃取算法的缺点</strong>：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。且会消耗更多的系统资源。</p><h4 id="forkjoin框架的设计">4.3 Fork/Join框架的设计</h4><p>Fork/Join框架主要有两个步骤：</p><ul><li><strong>步骤1 分割任务</strong>。首先需要一个<code>fork类</code>来把大任务分割成子任务。</li><li><strong>步骤2 执行任务并合并结果</strong>。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。<u>子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据</u>。</li></ul><blockquote><p>很像<code>MapReduce</code>算法，都是任务分解(Map)，然后聚合结果(Reduce)</p></blockquote><p><code>Fork/Join</code>使用两个类来完成以上两件事情：</p><ul><li><code>ForkJoinTask</code>：首先创建一个<code>ForkJoin</code>任务。它提供在任务中执行<code>fork()</code>和<code>join()</code>操作的机制。一般不需要直接继承<code>ForkJoinTask</code>类，<strong>Fork/Join框架</strong>提供了两个子类。<ul><li><code>RecursiveAction</code>：用于<strong><u>没有返回结果</u></strong>的任务。</li><li><code>RecursiveTask</code>：用于<strong><u>有返回结果</u></strong>的任务。</li></ul></li><li><code>ForkJoinPool</code>：<code>ForkJoinTask</code>需要通过<code>ForkJoinPool</code>来执行。</li></ul><h4 id="使用forkjoin框架">4.4 使用Fork/Join框架</h4><p><code>ForkJoinTask</code>需要实现<code>compute</code>方法，在这个方法里首先需要判断任务是否足够小：</p><ul><li>如果足够小就直接执行任务。</li><li>如果不足够小，就必须分割成两个子任务，每个子任务在调用<code>fork</code>方法时，又会进入<code>compute</code>方法。</li></ul><p>使用<code>join</code>方法会等待子任务执行完并得到其结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>; <span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forkjoin框架的异常处理">4.5 Fork/Join框架的异常处理</h4><p><code>ForkJoinTask</code>提供了<code>isCompletedAbnormally()</code>方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过<code>ForkJoinTask</code>的<code>getException</code>方法获取异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(task.isCompletedAbnormally()) &#123;</span><br><span class="line">System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forkjoin框架的实现">4.6 Fork/Join框架的实现</h4><p><code>ForkJoinPool</code>由<code>ForkJoinTask</code>数组和<code>ForkJoinWorkerThread</code>数组组成：</p><ul><li><code>ForkJoinTask</code>数组负责将存放程序提交给<code>ForkJoinPool</code>的任务；</li><li><code>ForkJoinWorkerThread</code>数组负责执行这些任务。</li></ul><h5 id="forkjointask的fork方法">4.6.1 ForkJoinTask的fork方法</h5><p>调用<code>ForkJoinTask</code>的<code>fork</code>方法时</p><ul><li>首先调用<code>ForkJoinWorkerThread</code>的<code>pushTask</code>方法<strong><u>异步地执行</u></strong>这个任务。</li><li><code>pushTask</code>方法把当前任务存放在<code>ForkJoinTask</code>数组队列里。然后再调用<code>ForkJoinPool</code>的<code>signalWork()</code>方法唤醒或创建一个工作线程来执行任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">((ForkJoinWorkerThread) Thread.currentThread()).pushTask(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pushTask</span><span class="params">(ForkJoinTask&lt;&gt; t)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;&gt;[] q; </span><br><span class="line">    <span class="keyword">int</span> s, m;</span><br><span class="line">    <span class="keyword">if</span> ((q = queue) != <span class="keyword">null</span>) &#123; <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="comment">// 计算t放到队列中的位置，即u</span></span><br><span class="line">        <span class="keyword">long</span> u = (((s = queueTop) &amp; (m = q.length - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="comment">// 加入队列</span></span><br><span class="line">        UNSAFE.putOrderedObject(q, u, t);</span><br><span class="line">        queueTop = s + <span class="number">1</span>; <span class="comment">// or use putOrderedInt</span></span><br><span class="line">        <span class="comment">// 激活或创建工作线程</span></span><br><span class="line">        <span class="keyword">if</span> ((s -= queueBase) &lt;= <span class="number">2</span>)</span><br><span class="line">            pool.signalWork();</span><br><span class="line">        <span class="comment">// 队列已满</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == m)</span><br><span class="line">            growQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="forkjointask的join方法">4.6.2 ForkJoinTask的join方法</h5><p><code>Join</code>方法的主要作用是阻塞当前线程并等待获取结果。</p><ul><li>首先通过<code>doJoin()</code>方法得到当前任务的状态。任务状态有4种：<code>已完成（NORMAL）</code>、<code>被取消（CANCELLED）</code>、<code>信号（SIGNAL）</code>和<code>出现异常（EXCEPTIONAL）</code>。<ul><li>如果任务状态是已完成，则直接返回任务状态；</li><li>如果没有执行完，则从任务数组里取出任务并执行；</li><li>如果任务顺利执行完成，则设置任务状态为<code>NORMAL</code>；</li><li>如果出现异常，则记录异常，并将任务状态设置为<code>EXCEPTIONAL</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (doJoin() != NORMAL)</span><br><span class="line">        <span class="keyword">return</span> reportResult();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t; ForkJoinWorkerThread w; <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                completed = exec();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (completed)</span><br><span class="line">                <span class="keyword">return</span> setCompletion(NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w.joinTask(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> externalAwaitDone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">reportResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Throwable ex;</span><br><span class="line">    <span class="comment">// 如果任务状态是被取消，则直接抛出CancellationException</span></span><br><span class="line">    <span class="keyword">if</span> ((s = status) == CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="comment">// 如果任务状态是抛出异常，则直接抛出对应的异常</span></span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.throwException(ex);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;并发编程大师Doug Lea不遗余力地为Java开发者提供了非常多的并发容器和框架&lt;/code&gt;</summary>
    
    
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
    <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--5 Java中的锁</title>
    <link href="https://wuyunjie.top/2021/07/19/JavaLearning_The_art_of_concurrent_programming_in_Java-5-Java-lock.html"/>
    <id>https://wuyunjie.top/2021/07/19/JavaLearning_The_art_of_concurrent_programming_in_Java-5-Java-lock.html</id>
    <published>2021-07-19T14:37:39.000Z</published>
    <updated>2021-07-19T14:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。</code> <span id="more"></span></p></blockquote><h3 id="lock接口">1. Lock接口</h3><p><code>Java SE 5</code>之后，<strong>并发包</strong>中新增了<code>Lock</code>接口（以及相关实现类）用来实现锁功能。</p><ul><li>提供了与<code>synchronized</code>关键字类似的同步功能，在使用时需要<strong>显式地</strong>获取和释放锁。</li><li>拥有<strong>锁获取与释放</strong>的<code>可操作性</code>、<code>可中断的获取锁</code>以及<code>超时获取锁</code>等多种synchronized关键字所不具备的同步特性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 保证在获取到锁之后，最终能够被释放</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/LockFeature.PNG" alt="Lock接口提供的主要特性" /><figcaption aria-hidden="true">Lock接口提供的主要特性</figcaption></figure><p>Lock接口定义了锁获取和释放的基本操作：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/LockAPI.PNG" alt="Lock API" /><figcaption aria-hidden="true">Lock API</figcaption></figure><h3 id="队列同步器">2. 队列同步器</h3><p>队列同步器<code>AbstractQueuedSynchronizer</code>，是用来构建锁或者其他同步组件的基础框架。</p><blockquote><p>使用了一个i<strong>nt成员变量</strong>表示<code>同步状态</code>，通过内置的<code>FIFO</code>队列来完成<u>资源获取线程的排队工作</u>。</p></blockquote><p>子类通过继承同步器并实现它的抽象方法来管理同步状态，同步器提供3个方法对同步状态进行更改，保证状态的改变是安全的：</p><ul><li><code>getState()</code>，获取当前同步状态；</li><li><code>setState(int newState)</code>，设置当前同步状态；</li><li><code>compareAndSetState(int expect, int update)</code>，使用CAS设置当前状态，该方法能够保证状态设置的<strong>原子性</strong>。</li></ul><p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义：</p><ul><li>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；</li><li>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</li></ul><h4 id="队列同步器的接口与示例">2.1 队列同步器的接口与示例</h4><p>使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法。同步器可重写的方法如下：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/AQSMethod.PNG" alt="同步器可重写的方法" /><figcaption aria-hidden="true">同步器可重写的方法</figcaption></figure><p>同步器提供的模板方法基本上分为3类：</p><ul><li><p>独占式获取与释放同步状态；</p></li><li><p>共享式获取与释放同步状态；</p></li><li><p>查询同步队列中的等待线程情况。</p></li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/AQSMethodTemplate.PNG" alt="同步器提供的模板方法" /><figcaption aria-hidden="true">同步器提供的模板方法</figcaption></figure><p><code>独占锁</code>是<u><strong>在同一时刻只能有一个线程获取到锁</strong>，而其他获取锁的线程只能处于同步队列中等待</u>，只有获取锁的线程释放了锁，后继的线程才能够获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类，自定义同步器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否处于占用状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当状态为0的时候获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁，将状态设置为0</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅需要将操作代理到Sync上即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用户使用<code>Mutex</code>时并不会直接和内部同步器的实现打交道，而是调用<code>Mutex</code>提供的方法；</li><li>在Mutex的实现中，只需要在方法实现中调用同步器的模板方法即可，当前线程调用该方法获取同步状态失败后会被加入到同步队列中等待。</li></ul><h4 id="队列同步器的实现">2.2 队列同步器的实现</h4><h5 id="同步队列">2.2.1 同步队列</h5><p>同步器依赖内部的同步队列来完成<strong>同步状态的管理</strong>：</p><ul><li>当前线程获取同步状态失败时，同步器会将<strong><u>当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列</u></strong>，同时会阻塞当前线程；</li><li>当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/AQSNode.PNG" alt="同步队列中的节点（Node）" /><figcaption aria-hidden="true">同步队列中的节点（Node）</figcaption></figure><p>同步器拥有<code>首节点（head）</code>和<code>尾节点（tail）</code>，没有成功获取同步状态的线程将会成为节点加入该队列的尾部。</p><ul><li>同步器提供了一个基于<code>CAS</code>的设置尾节点的方法：<code>compareAndSetTail(Node expect, Node update)</code>，需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</li><li>首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是<u><strong>通过获取同步状态成功的线程来完成的</strong></u>，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/SynchronizedQueue.PNG" alt="同步队列" /><figcaption aria-hidden="true">同步队列</figcaption></figure><h5 id="独占式同步状态获取与释放">2.2.2 独占式同步状态获取与释放</h5><p>同步器的<code>acquire(int arg)</code>方法可以获取同步状态，该方法对中断不敏感。主要完成<strong>同步状态获取</strong>、<strong>节点构造</strong>、<strong>加入同步队列</strong>以及<strong>在同步队列中自旋等待</strong>的相关工作。</p><ul><li>首先调用自定义同步器实现的<code>tryAcquire(int arg)</code>方法，该方法保证<strong>线程安全的获取同步状态</strong>；</li><li>如果同步状态获取失败，则构造同步节点（独占式<code>Node.EXCLUSIVE</code>，同一时刻只能有一个线程成功获取同步状态）；</li><li>通过<code>addWaiter(Node node)</code> 方法将该节点加入到同步队列的尾部；</li><li>最后调用<code>acquireQueued(Node node, int arg)</code>方法，使得该节点以<strong>“死循环”</strong>的方式获取同步状态；</li><li>如果获取不到则<u><strong>阻塞节点中的线程</strong></u>，而被阻塞线程的<strong>唤醒</strong><u>主要依靠前驱节点的出队或阻塞线程被中断来实现</u>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 快速尝试在尾部添加</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用 compareAndSetTail 方法来确保节点能够被线程安全添加</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">    pred.next = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同步器通过“死循环”来保证节点的正确添加</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// 通过CAS将节点设置成为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">            tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点进入同步队列之后，就进入了一个自旋的过程</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 只有前驱节点是头节点才能够尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/acquireFlow.PNG" alt="独占式同步状态获取流程" /><figcaption aria-hidden="true">独占式同步状态获取流程</figcaption></figure><p>同步器的<code>release(int arg)</code>方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// unparkSuccessor(Node node)方法使用LockSupport来唤醒处于等待状态的线程。</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="共享式同步状态获取与释放">2.2.3 共享式同步状态获取与释放</h5><p><strong>共享式获取</strong>与<strong>独占式获取</strong>最主要的区别：<u><strong>在于同一时刻能否有多个线程同时获取到同步状态</strong></u>。</p><ul><li>共享式访问资源时，<u>其他<strong>共享式</strong>的访问均被允许</u>，而<strong>独占式</strong>访问被阻塞；</li><li>独占式访问资源时，同一时刻其他访问均被阻塞。</li></ul><p>同步器的<code>acquireShared(int arg)</code>方法可以共享式地获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquireShared 方法尝试获取同步状态，</span></span><br><span class="line">    <span class="comment">// tryAcquireShared 方法返回值为int类型，</span></span><br><span class="line">    <span class="comment">// 当返回值大于等于0时，表示能够获取到同步状态</span></span><br><span class="line"><span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果当前节点的前驱为头节点时，尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 获取同步状态成功，从自旋过程中退出</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            setHeadAndPropagate(node, r);</span><br><span class="line">            p.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用<code>releaseShared(int arg)</code>方法可以释放同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryReleaseShared 必须确保同步状态（或者资源数）线程安全释放，</span></span><br><span class="line">    <span class="comment">// 一般是通过循环和CAS来保证的</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="独占式超时获取同步状态">2.2.4 独占式超时获取同步状态</h5><p>同步器的<code>doAcquireNanos(int arg, long nanosTimeout)</code>方法可以超时获取同步状态，<code>doAcquireNanos</code>方法在<strong><u>支持响应中断</u></strong>的基础上，增加了<u><strong>超时获取</strong></u>的特性。</p><ul><li><strong>支持响应中断</strong>。在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出<code>InterruptedException</code>。</li><li><strong>超时获取</strong>。即在指定的时间段内获取同步状态，如果获取到同步状态则返回<code>true</code>；否则，返回<code>false</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> lastTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 计算时间，当前时间now减去睡眠之前的时间lastTime得到已经睡眠</span></span><br><span class="line">            <span class="comment">// 的时间delta，然后被原有超时时间nanosTimeout减去，得到了</span></span><br><span class="line">            <span class="comment">// 还应该睡眠的时间</span></span><br><span class="line">            nanosTimeout -= now - lastTime;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/doAcquireNanosFlow.PNG" alt="独占式超时获取同步状态流程" /><figcaption aria-hidden="true">独占式超时获取同步状态流程</figcaption></figure><h5 id="自定义同步组件twinslock">2.2.5 自定义同步组件——<code>TwinsLock</code></h5><p><code>TwinsLock</code>要求在同一时刻，只允许<strong><u>至多两个</u></strong>线程同时访问，超过两个线程的访问将被阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count must large than zero.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current - reduceCount;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> returnCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current + returnCount;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步器作为一个桥梁，连接<strong>线程访问</strong>以及<strong>同步状态控制</strong>等底层技术与不同并发组件的接口语义。</p><h3 id="重入锁">3 重入锁</h3><p>重入锁<code>ReentrantLock</code>，即支持重进入的锁，该锁能够支持<u><strong>一个线程对资源的重复加锁</strong></u>。</p><ul><li>在调用<code>lock()</code>方法时，<strong>已经获取到锁</strong>的线程，能够<strong>再次调用</strong><code>lock()</code>方法获取锁而<u>不被阻塞</u>。</li></ul><p>该锁的还支持获取锁时的公平和非公平性选择。</p><ul><li>在<strong>绝对时间</strong>上，先对锁进行获取的请求一定先被满足，那么这个锁是<code>公平</code>的；</li><li>反之，是<code>不公平</code>的。</li></ul><h4 id="实现重进入">3.1 实现重进入</h4><p>重进入是指<u><strong>任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞</strong></u>：</p><ul><li><strong>线程再次获取锁</strong>。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</li><li><strong>锁的最终释放</strong>。线程重复<code>n</code>次获取了锁，随后在第<code>n</code>次释放该锁后，其他线程能够获取到该锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 再次获取同步状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 将同步状态值进行增加并返回true，表示获取同步状态成功</span></span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在释放同步状态时减少同步状态值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公平与非公平获取锁">3.2 公平与非公平获取锁</h4><ul><li>对于非公平锁，<code>nonfairTryAcquire</code>方法，只要<code>CAS</code>设置同步状态成功，则表示当前线程获取了锁；</li><li>对于公平锁，<code>tryAcquire</code>方法为判断条件增加了<code>hasQueuedPredecessors()</code>方法，判断同步队列中当前节点是否有前驱节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察公平和非公平锁在获取锁时的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairAndUnfairTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock fairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock unfairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//    @Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(fairLock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    @Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(unfairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动10个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Job w = <span class="keyword">new</span> Job(lock);</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FairAndUnfairTest test = <span class="keyword">new</span> FairAndUnfairTest();</span><br><span class="line">        test.testLock(fairLock);</span><br><span class="line"><span class="comment">//        test.testLock(unfairLock);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Lock lock;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.print(<span class="string">&quot;Lock by [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;], Waiting by [&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Thread t : ((ReentrantLock2) lock).getQueuedThreads()) &#123;</span><br><span class="line">                    System.out.print(t.getName() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock2</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            List&lt;Thread&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="keyword">super</span>.getQueuedThreads());</span><br><span class="line">            Collections.reverse(arrayList);</span><br><span class="line">            <span class="keyword">return</span> arrayList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平性锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁出现了一个线程连续获取锁的情况。</p><blockquote><p>非公平性锁可能使线程<code>“饥饿”</code>，但被设定成默认的实现</p></blockquote><p>非公平性锁虽然可能造成线程“饥饿”，但线程切换极少，减小了线程上下文切换带来的开销，保证了其更大的吞吐量。</p><h3 id="读写锁">4. 读写锁</h3><p><code>读写锁</code>维护了<strong>一对锁</strong>，一个<code>读锁</code>和一个<code>写锁</code>，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p><ul><li>读操作时获取读锁；</li><li>写操作时获取写锁。写锁被获取到时，后续（非当前写 操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行。</li></ul><p>Java并发包提供读写锁的实现是<code>ReentrantReadWriteLock</code>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ReentrantReadWriteLock.PNG" alt="ReentrantReadWriteLock特性" /><figcaption aria-hidden="true">ReentrantReadWriteLock特性</figcaption></figure><h4 id="读写锁的接口">4.1 读写锁的接口</h4><p><code>ReadWriteLock</code>仅定义了<strong>获取</strong>读锁和写锁的两个方法，即<code>readLock()</code>方法和<code>writeLock()</code>方法；<code>ReentrantReadWriteLock</code>除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ReentrantReadWriteLockMthods.PNG" alt="ReentrantReadWriteLock方法" /><figcaption aria-hidden="true">ReentrantReadWriteLock方法</figcaption></figure><h4 id="读写锁的实现">4.2 读写锁的实现</h4><h5 id="读写状态的设计">4.2.1 读写状态的设计</h5><p>读写锁同样依赖<strong>自定义同步器</strong>来实现同步功能，而<strong>读写状态</strong>就是其同步器的同步状态。</p><ul><li>读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态。</li></ul><p>读写锁将变量切分成了两个部分，<u><strong>高16位表示读</strong>，<strong>低16位表示写</strong></u>。读写锁通过<code>位运算</code>迅速确定读和写各自的状态。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ReadWriteLockStatus.PNG" alt="读写锁状态的划分" /><figcaption aria-hidden="true">读写锁状态的划分</figcaption></figure><h5 id="写锁的获取与释放">4.2.2 写锁的获取与释放</h5><p>写锁是一个支持重进入的<strong>排它锁</strong>。</p><ul><li>如果当前线程已经获取了写锁，则增加写状态。</li><li>如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程， 则当前线程进入等待状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">        <span class="comment">// c != 0 且 w == 0，代表存在读锁</span></span><br><span class="line">    <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 写锁超过最大值</span></span><br><span class="line">    <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置写锁(此时该线程已经获取过写锁，所以无需CAS也是线程安全的)</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为加锁，尝试获取写锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁成功</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写锁的释放与<code>ReentrantLock</code>的释放过程基本类似，每次释放均减少写状态，当写状态为<code>0</code>时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁。</p><h5 id="读锁的获取与释放">4.2.3 读锁的获取与释放</h5><p>读锁是一个支持重进入的<strong>共享锁</strong>。</p><ul><li>能够被<u>多个线程</u>同时获取，在没有其他<u>写线程访问</u>（或者写状态为0）时，读锁总会被成功地获取，只需增加读状态。</li><li>如果当前线程已经获取了<strong>读锁或写锁</strong>，则增加读状态。</li><li>如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</li><li>读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在<code>ThreadLocal</code>中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; c)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="锁降级">4.2.4 锁降级</h5><p><code>锁降级</code>指的是<strong><u>写锁降级成为读锁</u></strong>。线程已经持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程，即<code>锁降级</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">        <span class="comment">// 必须先释放读锁</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">// 锁降级从写锁获取到开始</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">                <span class="comment">// 准备数据的流程（略）</span></span><br><span class="line">                update = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            readLock.lock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 锁降级完成，写锁降级为读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">// 使用数据的流程（略）</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁降级中读锁的获取主要是为了保证数据的可见性。</p><ul><li>如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。</li><li>如果当前线程获取读锁，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进 行数据更新。</li></ul><h3 id="locksupport工具">5. <code>LockSupport</code>工具</h3><p>当需要<strong>阻塞</strong>或<strong>唤醒</strong>一个线程的时候，都会使用<code>LockSupport</code>工具类来完成相应工作。<code>LockSupport</code>定义了一组的<strong><u>公共静态方法</u></strong>，这些方法提供了最基本的线程阻塞和唤醒功能，而<code>LockSupport</code>也成为构建同步组件的基础工具。</p><ul><li>以<code>park</code>开头的方法用来<strong><u>阻塞当前线程</u></strong>；</li><li><code>unpark(Thread thread)</code> 方法来<u><strong>唤醒一个被阻塞的线程</strong></u>。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/LockSupportMethods.PNG" alt="读写锁状态的划分" /><figcaption aria-hidden="true">读写锁状态的划分</figcaption></figure><p><code>Java 6</code>中，<code>LockSupport</code>增加了<code>park(Object blocker)</code>、<code>parkNanos(Object blocker, long nanos)</code>和<code>parkUntil(Object blocker, long deadline)</code>3个方法，用于实现阻塞当前线程的功能，其中参数<code>blocker</code>是用来<u><strong>标识当前线程在等待的对象</strong></u>（以下称为阻塞对象）。</p><h3 id="condition接口">6. <code>Condition</code>接口</h3><p><code>Condition</code>接口也提供了类似<code>Object</code>的<strong>监视器</strong>方法，与<code>Lock</code>配合可以实现等待/通知模式。</p><h4 id="condition接口与示例">6.1 Condition接口与示例</h4><p><code>Condition</code>定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要<strong><u>提前获取</u></strong>到<code>Condition</code>对象关联的锁。<code>Condition</code>对象是由<code>Lock</code>对象（调用Lock对象的<code>newCondition()</code>方法）创建出来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 一般都会将Condition对象作为成员变量</span></span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用await()方法后，当前线程会释放锁并在此等待</span></span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 其他线程调用Condition对象的signal()方法，</span></span><br><span class="line">        <span class="comment">// 通知当前线程后，当前线程才从await()方法返回，</span></span><br><span class="line">        <span class="comment">// 并且在返回前已经获取了锁。</span></span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ConditionMethods.PNG" alt="Condition的方法" /><figcaption aria-hidden="true">Condition的方法</figcaption></figure><p>基于<code>Condition</code>实现的有界队列：</p><ul><li>当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素；</li><li>当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] items;</span><br><span class="line">    <span class="comment">// 添加的下标，删除的下标和数组当前数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addIndex, removeIndex, count;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个元素，如果数组满，则添加线程进入等待状态，直到有&quot;空位&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[addIndex] = t;</span><br><span class="line">            <span class="keyword">if</span> (++addIndex == items.length)</span><br><span class="line">                addIndex = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[removeIndex];</span><br><span class="line">            <span class="keyword">if</span> (++removeIndex == items.length)</span><br><span class="line">                removeIndex = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> (T) x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="condition的实现">6.2 Condition的实现</h4><p><code>ConditionObject</code>是同步器<code>AbstractQueuedSynchronizer</code>的内部类。每个<code>Condition</code>对象都包含着一个队列（等待队列），该队列是<code>Condition</code>对象实现<strong><u>等待/通知功能</u></strong>的关键。</p><h5 id="等待队列">6.2.1 等待队列</h5><p>等待队列是一个<code>FIFO</code>的队列，在队列中的每个节点都包含了一个<strong><code>线程引用</code></strong>，该线程就是在<code>Condition</code>对象上等待的线程：</p><ul><li>同步队列和等待队列中节点类型都是同步器的静态内部类<code>AbstractQueuedSynchronizer.Node</code>。</li><li><code>Lock</code>（同步器）拥有一个同步队列和多个等待队列</li></ul><p>同理，<code>Condition</code>拥有<code>首节点（firstWaiter）</code>和<code>尾节点（lastWaiter）</code>。</p><ul><li>当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。节点引用更新的过程并<strong><u>没有使用</u></strong><code>CAS</code>保证，原因在于调用<code>await()</code>方法的线程必定是获取了锁的线程。</li></ul><h5 id="等待">6.2.2 等待</h5><p>调用<code>Condition</code>的<code>await()</code>方法，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。从await()方法返回时，当前线程<u><strong>一定获取了<code>Condition</code>相关联的锁</strong></u>。</p><ul><li>被唤醒后的线程，将从<code>await()</code>方法中的while循环中退出（<code>isOnSyncQueue(Node node)</code>方法返回true，节点已经在同步队列中）；</li><li>进而调用同步器的<code>acquireQueued()</code>方法加入到获取同步状态的竞争中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程加入等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步状态，也就是释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于<u><strong>同步队列的<code>首节点</code>（获取了锁的节点）移动到Condition的<code>等待队列</code>中</strong></u>。</p><h5 id="通知">6.2.3 通知</h5><p>调用Condition的<code>signal()</code>方法，将会唤醒在等待队列中<u><strong>等待时间最长</strong></u>的节点（<code>首节点</code>），在唤醒节点之前，会将节点移到同步队列中。</p><ul><li>调用该方法的前置条件是当前线程必须获取了锁；</li><li>通过调用同步器的<code>enq(Node node)</code>方法，等待队列中的头节点线程安全地移动到同步队列。</li><li>当节点移动到同步队列后，当前线程再使用<code>LockSupport</code>唤醒该节点的线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用该方法的前置条件是当前线程必须获取了锁</span></span><br><span class="line"><span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line"><span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。&lt;/code&gt;</summary>
    
    
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
    <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--4  Java并发编程基础</title>
    <link href="https://wuyunjie.top/2021/07/18/JavaLearning_The_art_of_concurrent_programming_in_Java-4-Java-concurrent-programming-basics.html"/>
    <id>https://wuyunjie.top/2021/07/18/JavaLearning_The_art_of_concurrent_programming_in_Java-4-Java-concurrent-programming-basics.html</id>
    <published>2021-07-18T14:31:47.000Z</published>
    <updated>2021-07-18T14:31:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>线程作为操作系统调度的最小单元，多个线程能够同时执行，这将显著提升程序性能，在多核环境中表现得更加明显。</code> <span id="more"></span></p></blockquote><h3 id="线程简介">1. 线程简介</h3><h4 id="线程定义">1.1 线程定义</h4><p>现代操作系统<strong>调度的最小单元</strong>是线程，也叫<code>轻量级进程（Light Weight Process）</code>，在一个进程里可以创建多个线程，这些线程都拥有<u>各自的计数器、堆栈和局部变量</u>等属性，并且能够访问共享的内存变量。</p><blockquote><p>Java程序<u>天生就是多线程程序</u>，因为执行<code>main()</code>方法的是一个名称为main的线程。</p></blockquote><p>一个Java程序的运行是main线程和多个其他线程的同时运行。</p><h4 id="多线程">1.2 多线程</h4><p>使用多线程的原因主要有以下几点：</p><ol type="1"><li><strong>更多的处理器核心</strong>。使用多线程技术将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。</li><li><strong>更快的响应时间</strong>。使用多线程技术，将数据一致性不强的操作派发给其他线程处理，缩短响应时间。</li><li><strong>更好的编程模型</strong>。</li></ol><h4 id="线程优先级">1.3 线程优先级</h4><p>线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。在Java线程中，通过一个整型成员变量<code>priority</code>来控制优先级，优先级的范围从<code>1~10</code>，在线程构建的时候可以通过<code>setPriority(int)</code>方法来修改优先级，默认优先级是<code>5</code>。</p><blockquote><p>优先级只是一个建议，实际执行时可能会忽略对线程优先级的设定。</p></blockquote><h4 id="线程的状态">1.4 线程的状态</h4><p>Java线程在运行的生命周期中可能处于<code>6</code>种不同的状态，且在给定的一个时刻，线程<u><strong>只能处于其中的一个状态</strong></u>：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter4/threadState.PNG" alt="线程状态" /><figcaption aria-hidden="true">线程状态</figcaption></figure><p>可以使用<code>jps</code>查看进程<code>ID</code>，然后用<code>"jstack 进程ID"</code>查看运行时的线程信息。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter4/threadStateChange.PNG" alt="Java线程状态变迁" /><figcaption aria-hidden="true">Java线程状态变迁</figcaption></figure><h4 id="daemon线程">1.5 Daemon线程</h4><p><code>Daemon</code>线程是一种<strong>支持型线程</strong>，因为它主要被用作程序中<u>后台调度以及支持性工作</u>。</p><blockquote><p>当一个Java虚拟机中<strong>不存在非Daemon线程</strong>的时候，Java虚拟机将会退出。</p></blockquote><p>通过调用<code>Thread.setDaemon(true)</code>将线程设置为Daemon线程，<u>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置</u>。</p><blockquote><p>在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</p></blockquote><p>实际上经过测试，甚至Daemon线程中<code>run()</code>内的代码都不一定会被执行，。main线程（非 Daemon线程）在启动了线程<code>DaemonRunner</code>之后随着main方法执行完毕而终止，而此时Java虚拟机中已经没有非Daemon线程，虚拟机需要退出。Java虚拟机中的所有Daemon线程都需要立即终止，因此<code>DaemonRunner</code>立即终止，但是<code>DaemonRunner</code>中的finally块并没有执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(), <span class="string">&quot;DaemonRunner&quot;</span>);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;DaemonThread finally run.&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;DaemonThread finally run.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;DaemonThread finally run.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动和终止线程">2. 启动和终止线程</h3><h4 id="构造线程">2.1 构造线程</h4><p>线程对象在构造的时候需要提供线程所需要的属性，如线程所属的<strong>线程组</strong>、<strong>线程优先级</strong>、<strong>是否是Daemon线程</strong>等信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程就是该线程的父线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将daemon、priority属性设置为父线程的对应属性</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将父线程的InheritableThreadLocal复制过来</span></span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">// 分配一个线程ID</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个新构造的线程对象是由其parent线程来进行空间分配的。</p><h4 id="启动线程">2.2 启动线程</h4><p>线程对象在初始化完成之后，调用<code>start()</code>方法启动这个线程：<u><strong>当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用<code>start()</code>方法的线程</strong></u>。</p><h4 id="中断">2.3 中断</h4><p><code>中断</code>可以理解为线程的一个<strong>标识位属性</strong>，它表示<u>一个运行中的线程是否被其他线程进行了中断操作</u>。</p><ul><li>其他线程通过调用该线程的<code>interrupt()</code>方法对其进行中断操作；</li><li>线程通过方法<code>isInterrupted()</code>来进行判断自身是否被中断；<ul><li>如果该线程已经处于<strong><u>终结状态</u></strong>，即使该线程被中断过，在调用该线程对象的<code>isInterrupted()</code>时依旧会返回<code>false</code>；</li><li>方法在抛出<code>InterruptedException</code>之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出<code>InterruptedException</code>，此时调用<code>isInterrupted()</code>方法将会返回<code>false</code>。</li></ul></li><li>可以调用静态方法<code>Thread.interrupted()</code>对当前线程的中断标识位进行复位；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeWaiting(), <span class="string">&quot;TimeWaitingThread&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Waiting(), <span class="string">&quot;WaitingThread&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 使用两个Blocked线程，一个获取锁成功，另一个被阻塞</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">&quot;BlockedThread-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">&quot;BlockedThread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该线程不断地进行睡眠</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该线程在Waiting.class实例上等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Waiting.class) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Waiting.class.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该线程在Blocked.class实例上加锁后，不会释放该锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Blocked.class) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(<span class="keyword">long</span> seconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过期deprecated的suspendresume和stop">2.4 过期(<code>deprecated</code>)的<code>suspend()</code>、<code>resume()</code>和<code>stop()</code></h4><p><code>suspend()</code>、<code>resume()</code>和<code>stop()</code>方法完成线程的<strong>暂停</strong>、<strong>恢复</strong>和<strong>终止</strong>工作。但是这些<code>API</code>是过期的，已经不建议使用，因为这些方法会带来副作用：</p><ul><li>在调用<code>suspend()</code>后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发<strong>死锁问题</strong>；</li><li><code>stop()</code>方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</li></ul><h4 id="安全地终止线程">2.5 安全地终止线程</h4><p>中断操作是一种适合用来取消或停止任务的交互方式。除了中断以外，还可以利用一个boolean变量来控制<u>是否需要停止任务并终止该线程</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shutdown</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread countThread = <span class="keyword">new</span> Thread(one, <span class="string">&quot;CountThread&quot;</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line"></span><br><span class="line">        Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">        countThread = <span class="keyword">new</span> Thread(two, <span class="string">&quot;CountThread&quot;</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Count i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种通过<strong>标识位</strong>或者<strong>中断操作</strong>的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止。</p><h3 id="线程间通信">3. 线程间通信</h3><h4 id="volatile和synchronized关键字">3.1 <code>volatile</code>和<code>synchronized</code>关键字</h4><ul><li>关键字<code>volatile</code>可以用来修饰字段（成员变量），告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</li><li>关键字<code>synchronized</code>可以修饰方法或者以同步块的形式来进行使用，它确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</li></ul><h4 id="等待通知机制">3.2 等待/通知机制</h4><p>等待/通知的相关方法是<u><strong>任意Java对象都具备的</strong></u>，因为这些方法被定义在所有对象的超类<code>java.lang.Object</code>上。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter4/WaitAndNotify.PNG" alt="等待/通知方法" /><figcaption aria-hidden="true">等待/通知方法</figcaption></figure><p>等待/通知机制通过对象O来完成线程之间的交互：</p><ul><li>一个线程A调用了对象O的<code>wait()</code>方法进入等待状态；</li><li>另一个线程B调用了对象O的<code>notify()</code>或者<code>notifyAll()</code>方法，线程A收到通知后从对象O的<code>wait()</code>方法返回，进而执行后续操作。</li><li>对象上的<code>wait()</code>和<code>notify/notifyAll()</code>的关系就如同开关信号，用来完成等待方和通知方之间的交互工作。</li></ul><p>调用<code>wait()</code>、<code>notify()</code>以及<code>notifyAll()</code>时需要注意的细节：</p><ol type="1"><li>使用<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>时需要先对调用<strong>对象加锁</strong>。</li><li>调用<code>wait()</code>方法后，线程状态由<code>RUNNING</code>变为<code>WAITING</code>，并将当前线程放置到对象的等待队列。</li><li><code>notify()</code>或<code>notifyAll()</code>方法调用后，<u><strong>等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回</strong></u>。</li><li><code>notify()</code>方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而<code>notifyAll()</code>方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为 BLOCKED。</li><li>从<code>wait()</code>方法返回的<strong>前提</strong>是<u>获得了调用对象的锁</u>。</li></ol><h4 id="等待通知的经典范式">3.3 等待/通知的经典范式</h4><p><strong>等待/通知的经典范式</strong>分为两部分，分别针对<strong>等待方（消费者）</strong>和<strong>通知方（生产者）</strong>：</p><ul><li><strong>等待方</strong>遵循如下原则：<ol type="1"><li>获取对象的锁；</li><li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件；</li><li>条件满足则执行对应的逻辑；</li></ol></li><li><strong>通知方</strong>遵循如下原则：<ol type="1"><li>获得对象的锁；</li><li>改变条件；</li><li>通知所有等待在对象上的线程。</li></ol></li></ul><h4 id="管道输入输出流">3.4 管道输入/输出流</h4><p>管道输入/输出流主要用于<strong>线程</strong>之间的数据传输，而<u>传输的媒介为内存</u>。主要包括4种具体实现：</p><ul><li>面向字节：<code>PipedOutputStream</code>、<code>PipedInputStream</code></li><li>面向字符：<code>PipedReader</code>、<code>PipedWriter</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        <span class="comment">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</span></span><br><span class="line">        out.connect(in);</span><br><span class="line"></span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">&quot;PrintThread&quot;</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader in;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="thread.join的使用">3.5 <code>Thread.join()</code>的使用</h4><p>一个线程A执行<code>thread.join()</code>后，当前线程A等待thread线程终止之后才从<code>thread.join()</code>返回。线程Thread除了提供<code>join()</code>方法之外，还提供了<code>join(long millis)</code>和<code>join(long millis, int nanos)</code>两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁当前线程对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 条件不满足，继续等待</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件符合，方法返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="threadlocal的使用">3.6 <code>ThreadLocal</code>的使用</h4><p><code>ThreadLocal</code>，即线程变量，是一个<u>以<code>ThreadLocal</code>对象为<strong>键</strong></u>、<u>任意对象为<strong>值</strong></u>的存储结构。一个线程可以根据一个<code>ThreadLocal</code>对象查询到绑定在这个线程上的一个值。</p><ul><li>可以通过<code>set(T)</code>方法来设置一个值；</li><li>在当前线程下再通过<code>get()</code>方法获取到原先设置的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Cost: &quot;</span> + Profiler.end() + <span class="string">&quot; mills&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程应用实例">4. 线程应用实例</h3><h4 id="等待超时模式">4.1 等待超时模式</h4><p>在<strong>等待/通知的经典范式</strong>上加入<strong>超时等待</strong>，可以使得该模式更具有灵活性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对当前对象加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line"><span class="keyword">long</span> remaining = mills;</span><br><span class="line">    <span class="comment">// 当超时大于0并且result返回值不满足要求</span></span><br><span class="line">    <span class="keyword">while</span> ((result == <span class="keyword">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    wait(remaining);</span><br><span class="line">        remaining = future - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据库连接池示例">4.2 数据库连接池示例</h4><p>使用等待超时模式来构造一个简单的<code>数据库连接池</code>，从连接池中<strong>获取</strong>、<strong>使用</strong>和<strong>释放连接</strong>，而客户端获取连接的过程被设定为等待超时的模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">                <span class="comment">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span></span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在mills内无法获取到连接，将会返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">            <span class="comment">// 完全超时</span></span><br><span class="line">            <span class="keyword">if</span> (mills &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty()) &#123;</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">                <span class="keyword">long</span> remaining = mills;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                Connection result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (!pool.isEmpty()) &#123;</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在资源一定的情况下（连接池中的10个连接），随着客户端线程的逐步增加，客户端出现超时无法获取连接的比率会不断升高。</p><h4 id="线程池技术及其示例">4.3 线程池技术及其示例</h4><p>对于服务端的程序，经常面对的是客户端传入的<strong>短小（执行时间短、工作内容较为单一）</strong>任务，需要服务端快速处理并返回结果。如果采用一个任务一个线程的方式，任务过多时会创建大量线程，线程上下文切换会增加系统的负载。</p><p><code>线程池技术</code>预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。</p><ul><li>一方面，消除了频繁创建和消亡线程的系统资源开销；</li><li>另一方面，面对过量任务的提交能够平缓的劣化。</li></ul><p>一个简单的线程池接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 执行一个Job，这个Job需要实现Runnable</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 增加工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 减少工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 得到正在等待执行的任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端可以通过<code>execute(Job)</code>方法将<code>Job</code><strong><u>提交入线程池执行</u></strong>，而客户端自身不用等待<code>Job</code>的执行完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 线程池最大限制数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 线程池默认的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 线程池最小的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这是一个工作列表，将会向里面插入工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;Job&gt;();</span><br><span class="line">    <span class="comment">// 工作者列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Worker&gt;());</span><br><span class="line">    <span class="comment">// 工作者线程的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">    <span class="comment">// 线程编号生成</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong threadNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initializeWokers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;</span><br><span class="line">        initializeWokers(workerNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加一个工作，然后进行通知</span></span><br><span class="line">            <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="comment">// 限制新增的Worker数量不能超过最大值</span></span><br><span class="line">            <span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWokers(num);</span><br><span class="line">            <span class="keyword">this</span>.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="keyword">this</span>.workerNum) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;beyond workNum&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 按照给定的数量停止Worker</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程工作者</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWokers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">&quot;ThreadPool-Worker-&quot;</span> + threadNum.incrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作者，负责消费任务</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否工作</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                    <span class="comment">// 如果工作者列表是空的，那么就wait</span></span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                            <span class="comment">// 感知到外部对WorkerThread的中断操作，返回</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 取出一个Job</span></span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        job.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        <span class="comment">// 忽略Job执行中的Exception</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的本质就是使用了一个线程安全的工作队列连接工作者线程和客户端线程：</p><ul><li>客户端线程将任务放入工作队列后便返回；</li><li>工作者线程则不断地从工作队列上取出工作并执行。</li></ul><h4 id="基于线程池技术的简单web服务器">4.4 基于线程池技术的简单Web服务器</h4><p>常用的Java Web服务器，如<code>Tomcat</code>、<code>Jetty</code>，在其处理请求的过程中都使用到了线程池技术。</p><p>构造一个简单的Web服务器，这个Web服务器用来处理<code>HTTP</code>请求，使用<code>main</code>线程不断地接受客户端<code>Socket</code>的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理HttpRequest的线程池</span></span><br><span class="line">    <span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool&lt;HttpRequestHandler&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// SimpleHttpServer的根路径</span></span><br><span class="line">    <span class="keyword">static</span> String basePath;</span><br><span class="line">    <span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="comment">// 服务监听端口</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (port &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span><span class="params">(String basePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (basePath != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> File(basePath).exists() &amp;&amp; <span class="keyword">new</span> File(basePath).isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动SimpleHttpServer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">            InputStream in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 由相对路径计算出绝对路径</span></span><br><span class="line">                String filePath = basePath + header.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>];</span><br><span class="line">                out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">&quot;jpg&quot;</span>) || filePath.endsWith(<span class="string">&quot;ico&quot;</span>)) &#123;</span><br><span class="line">                    in = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">                    out.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Server: Molly&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Content-Type: image/jpeg&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Content-Length: &quot;</span> + array.length);</span><br><span class="line">                    out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(filePath)));</span><br><span class="line">                    out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                    out.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Server: Molly&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Content-Type: text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                out.println(<span class="string">&quot;HTTP/1.1 500&quot;</span>);</span><br><span class="line">                out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(br, in, reader, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭流或者Socket</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeables != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable closeable : closeables) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SimpleHttpServer</code>在建立了与客户端的连接之后，并不会处理客户端的请求，而是将其包装成<code>HttpRequestHandler</code>并交由线程池处理。启动服务的测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHttpServer newSever = <span class="keyword">new</span> SimpleHttpServer();</span><br><span class="line">        newSever.setBasePath(<span class="string">&quot;..\\src\\Concurrency\\Chapter4\\DefaultThreadPool&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newSever.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<code>Apache HTTP server benchmarking tool</code>来测试不同线程数下，<code>SimpleHttpServer</code>的吞吐量表现。</p><blockquote><p><a href="https://www.cnblogs.com/cjsblog/p/9038838.html">Apache HTTP server benchmarking tool</a>是服务器压力测试工具，可以参考链接查看使用方法。</p></blockquote><p>随着线程池中线程数量的增加，<code>SimpleHttpServer</code>响应时间不断变小。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;线程作为操作系统调度的最小单元，多个线程能够同时执行，这将显著提升程序性能，在多核环境中表现得更加明显。&lt;/code&gt;</summary>
    
    
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
    <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
    <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
