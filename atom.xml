<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuYJ&#39;s Blog</title>
  
  <subtitle>HELLO WORLD</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuyunjie.top/"/>
  <updated>2021-05-17T14:28:09.000Z</updated>
  <id>https://wuyunjie.top/</id>
  
  <author>
    <name>wuyunjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java学习|Head_First_Java]--12 图形用户接口</title>
    <link href="https://wuyunjie.top/2021/05/17/JavaLearning_Head_First_Java_11_getting_gui.html"/>
    <id>https://wuyunjie.top/2021/05/17/JavaLearning_Head_First_Java_11_getting_gui.html</id>
    <published>2021-05-17T14:28:09.000Z</published>
    <updated>2021-05-17T14:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>面对现实，你得做出图形用户接口。<br><a id="more"></a></p></blockquote><h3 id="1-window"><a href="#1-window" class="headerlink" title="1. window"></a>1. window</h3><p><code>JFrame</code>是代表屏幕上window的对象，可以把<code>button</code>，<code>checkbox</code>，<code>text</code>字段等接口放在window上。标准的<code>menu</code>也可以加到上面。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;面对现实，你得做出图形用户接口。&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--3 垃圾收集器与内存分配策略</title>
    <link href="https://wuyunjie.top/2021/05/17/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_3_Garbage_collector_and_memory_allocation_strategy.html"/>
    <id>https://wuyunjie.top/2021/05/17/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_3_Garbage_collector_and_memory_allocation_strategy.html</id>
    <published>2021-05-17T02:35:27.000Z</published>
    <updated>2021-05-17T02:35:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code><br><a id="more"></a></p></blockquote><h3 id="1-对象”已死”？"><a href="#1-对象”已死”？" class="headerlink" title="1. 对象”已死”？"></a>1. 对象”已死”？</h3><p>垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（<code>“死去”即不可能再被任何途径使用的对象</code>）。</p><h4 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1 引用计数算法"></a>1.1 引用计数算法</h4><p>在对象中添加一个<code>引用计数器（Reference Counting）</code>，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；<strong>任何时刻计数器为零的对象就是不可能再被使用的</strong>。</p><blockquote><ul><li>占用了一些额外的内存空间来进行计数</li><li>原理简单，判定效率也很高</li></ul></blockquote><p>主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作。</p><blockquote><p>譬如单纯的引用计数就很难解决对象之间<code>相互循环引用</code>的问题。</p><ul><li>对象<code>objA</code>和<code>objB</code>都有字段<code>instance</code>；</li><li>赋值令 <code>objA.instance=objB</code>及<code>objB.instance=objA</code>，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问；</li><li>但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。</li></ul></blockquote><p>打印内存回收日志的参数设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails      //打印GC详细信息</span><br><span class="line">-Xms100M    //堆大小100M</span><br><span class="line">-Xmx200M   //堆最大占用内存</span><br><span class="line">-Xmn10M     //新生代 大小 </span><br><span class="line">-XX:SurvivorRatio=8   //Eden:Survivor1:Survivor2 = 8:1:1</span><br><span class="line">-XX:MaxPermSize30M   //永久代内存大小</span><br><span class="line">-XX:MetaspaceSize=30M  //元空间 初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</span><br><span class="line">-XX:MaxMetaspaceSize=300M //最大空间，默认是没有限制的。</span><br></pre></td></tr></table></figure><h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h4><p><code>可达性分析（Reachability Analysis）算法</code>的基本思路是：</p><blockquote><ul><li>通过 一系列称为<code>“GC Roots”</code>的根对象作为<strong>起始节点集</strong>，从这些节点开始，根据引用关系向下搜索；</li><li>搜索过程所走过的路径称为<code>“引用链”（Reference Chain）</code>，如果某个对象到<code>GC Roots</code>间没有任何引用链相连， 或者用图论的话来说就是从<code>GC Roots</code>到这个对象不可达时，则证明此对象是不可能再被使用的。</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Reachability_Analysis.PNG" alt="可达性分析算法"></p><p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是使用了可达性分析算法。固定可作为<code>GC Roots</code>的对象包括以下几种：</p><ul><li>在<code>虚拟机栈（栈帧中的本地变量表）中引用的对象</code>，譬如各个线程被调用的方法堆栈中使用到的<u>参数、局部变量、临时变量</u>等。</li><li>在<strong>方法区</strong>中<code>类静态属性引用的对象</code>，譬如Java类的引用类型静态变量。</li><li>在<strong>方法区</strong>中<code>常量引用的对象</code>，譬如字符串常量池（String Table）里的引用。</li><li>在<code>本地方法栈中JNI</code>（即通常所说的Native方法）引用的对象。</li><li><code>Java虚拟机内部的引用</code>，如基本数据类型对应的Class对象，一些常驻的<strong>异常对象</strong>（比如<code>NullPointExcepiton</code>、<code>OutOfMemoryError</code>）等，还有系统类加载器。</li><li>所有被<code>同步锁（synchronized关键字）持有的对象</code>。</li><li>反映Java虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI中注册的回调</code>、<code>本地代码缓存</code>等。</li></ul><p>除了这些<strong>固定</strong>的<code>GC Roots</code>集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象<strong>“临时性”</strong>地加入，共同构成完整<code>GC Roots</code>集合。</p><h4 id="1-3-引用的分类"><a href="#1-3-引用的分类" class="headerlink" title="1.3 引用的分类"></a>1.3 引用的分类</h4><p>在<code>JDK 1.2</code>版之后，Java对引用的概念进行了扩充，将引用分为<code>强引用（Strongly Re-ference）</code>、<code>软引用（Soft Reference）</code>、<code>弱引用（Weak Reference）</code>和<code>虚引用（Phantom Reference）</code>4种，这4种引用强度依次逐渐减弱。</p><ul><li><p>强引用是指在程序代码之中普遍存在的引用赋值，即类似<code>“Object obj=new Object()”</code>这种引用关系。</p><blockquote><p>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。`</p></blockquote></li><li><p>软引用是用来描述一些<strong>还有用，但非必须的对象</strong>。</p><blockquote><ul><li>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</li><li>在<code>JDK 1.2</code>版之后提供了<code>SoftReference</code>类来实现软引用。</li></ul></blockquote></li><li><p>弱引用也是用来描述那些<strong>非必须对象</strong>，但是它的强度比软引用更弱一些。</p><blockquote><p>被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><p>在<code>JDK 1.2</code>版之后提供了<code>WeakReference</code>类来实现弱引用。</p></blockquote></li><li><p>虚引用也称为<code>“幽灵引用”</code>或者<code>“幻影引用”</code>，它是最弱的一种引用关系。</p><blockquote><p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的<u>只是为了能在这个对象被收集器回收时收到一个系统通知</u>。</p><p>在<code>JDK 1.2</code>版之后提供 了<code>PhantomReference</code>类来实现虚引用。</p></blockquote></li></ul><h4 id="1-4-对象的死亡宣告"><a href="#1-4-对象的死亡宣告" class="headerlink" title="1.4 对象的死亡宣告"></a>1.4 对象的死亡宣告</h4><p>在可达性分析算法中判定为不可达的对象，至少要经历两次标记过程：</p><ol><li><p>如果对象在进行可达性分析后发现没有与<code>GC Roots</code>相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是<u>此对象是否有必要执行<code>finalize()</code>方法</u>。</p><ul><li><p>假如对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为<strong>“没有必要执行”</strong>。</p></li><li><p>如果这个对象被判定为确<strong>有必要执行<code>finalize()</code>方法</strong>，那么该对象将会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条由虚拟机<strong>自动建立的、低调度优先级</strong>的<code>Finalizer</code>线程去执行它们的<code>finalize()</code> 方法。</p><ul><li><code>“执行”</code>是<u>指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束</u>。</li></ul></li></ul></li><li><p>稍后收集器将对<code>F-Queue</code>中的对象进行<u>第二次小规模的标记</u>，如果对象要在<code>finalize()</code>中重新与引用链上的任何一个对象建立关联，那在第二次标记时它将被移出“即将回收”的集合。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此代码演示了两点：</span></span><br><span class="line"><span class="comment">* 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment">* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes, i am still alive :)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/FinalizeEscapeGC.PNG" alt="FinalizeEscapeGC运行结果"></p><p>代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败了。这是因为<strong>任何一个对象的finalize()方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p><blockquote><p><code>finalize()</code>是不推荐使用的语法</p></blockquote><h4 id="1-5-回收方法区"><a href="#1-5-回收方法区" class="headerlink" title="1.5 回收方法区"></a>1.5 回收方法区</h4><p>方法区的垃圾收集主要回收两部分内容：<code>废弃的常量</code>和<code>不再使用的类型</code>。</p><ul><li>回收废弃常量与回收 Java堆中的对象非常类似。</li><li>判定一个类型是否属于<code>“不再被使用的类”</code>需要同时满足下面三个条件：<ul><li><strong>该类所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li><strong>加载该类的类加载器已经被回收</strong>，这个条件则通常是很难达成。</li><li><strong>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li></ul></li></ul><h3 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h3><p>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为<code>“引用计数式垃圾收集”（Reference Counting GC）</code>和<code>“追踪式垃圾收集”（Tracing GC）</code>两大类，这两类也常被称作<code>“直接垃圾收集”</code>和<code>“间接垃圾收集”</code>。</p><h4 id="2-1-分代收集理论"><a href="#2-1-分代收集理论" class="headerlink" title="2.1 分代收集理论"></a>2.1 分代收集理论</h4><p><code>“分代收集”（Generational Collection）</code>建立在两个分代假说之上：</p><ol><li><code>弱分代假说（Weak Generational Hypothesis）</code>：绝大多数对象都是朝生夕灭的。</li><li><code>强分代假说（Strong Generational Hypothesis）</code>：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ol><p>设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（<strong>年龄即对象熬过垃圾收集过程的次数</strong>）分配到不同的区域之中存储。</p><blockquote><ul><li>如果一个区域中大多数对象都是朝生夕灭，那么把它们集中放在一起，每次回收时只关注如何保留少量存活，就能以较低代价回收到大量的空间；</li><li>如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域；</li><li>同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</li></ul></blockquote><p>设计者一般至少会把Java堆划分为<code>新生代（Young Generation）</code>和<code>老年代（Old Generation）</code>两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p><p>假如要现在进行一次只局限于新生代区域内的收集<code>（Minor GC）</code>，但新生代中的对象是完全有可能被老年代所引用的。需要对分代收集理论添加第三条经验法则：</p><ol><li><code>跨代引用假说（Intergenerational Reference Hypothesis）</code>：跨代引用相对于同代引用来说仅占极少数。</li></ol><p>依据这条假说，只需在新生代上建立一个全局的数据结构（该结构被称为<code>“记忆集”</code>，<code>Remembered Set</code>），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生<code>Minor GC</code>时，只有包含了跨代引用的小块内存里的对象才会被加入到<code>GC Roots</code>进行扫描。</p><blockquote><ul><li><code>部分收集（Partial GC）</code>：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul><li><code>新生代收集（Minor GC/Young GC）</code>：指目标只是新生代的垃圾收集。</li><li><code>老年代收集（Major GC/Old GC）</code>：指目标只是老年代的垃圾收集。</li><li><code>混合收集（Mixed GC）</code>：指目标是收集整个新生代以及部分老年代的垃圾收集。</li></ul></li><li><code>整堆收集（Full GC）</code>：收集整个Java堆和方法区的垃圾收集。</li></ul></blockquote><h4 id="2-2-标记-清除-Mark-Sweep-算法"><a href="#2-2-标记-清除-Mark-Sweep-算法" class="headerlink" title="2.2 标记-清除(Mark-Sweep)算法"></a>2.2 标记-清除(Mark-Sweep)算法</h4><p>算法分为<code>“标记”</code>和<code>“清除”</code>两个阶段：</p><ul><li>首先标记出所有需要回收的对象；</li><li>在标记完成后，统一回收掉所有被标记的对象；</li></ul><p>也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p><blockquote><p>主要缺点:</p><ol><li><strong>执行效率不稳定</strong>，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li><li><strong>内存空间的碎片化问题</strong>，标记、清除之后会产生大量不连续的内存碎片。</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Sweep.PNG" alt="“标记-清除”算法"></p><h4 id="2-3-标记-复制-Mark-Copying-算法"><a href="#2-3-标记-复制-Mark-Copying-算法" class="headerlink" title="2.3 标记-复制(Mark-Copying)算法"></a>2.3 标记-复制(Mark-Copying)算法</h4><p>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，标记-复制(Mark-Copying)算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。<u>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</u>。</p><blockquote><p>缺点：</p><ul><li>如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销；</li><li>这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一 点。</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Copying.PNG" alt="“标记-复制”算法"></p><p><code>Appel式回收</code>(<code>Andrew Appel</code>提出的一种更优化的<code>半区复制分代策略</code>)的具体做法是：</p><ul><li>把新生代分为一块较大的<code>Eden空间</code>和两块较小的<code>Survivor空间</code>，每次分配内存只使用<code>Eden</code>和其中一块<code>Survivor</code>。</li><li>发生垃圾搜集时，将<code>Eden</code>和<code>Survivor</code>中仍然存活的对象一次性复制到另外一块<code>Survivor</code>空间上，然后直接清理掉<code>Eden</code>和已用过的那块<code>Survivor</code>空间。</li></ul><p><code>HotSpot虚拟机</code>默认<code>Eden</code>和<code>Survivor</code>的大小比例是<code>8∶1</code>，也即每次新生代中可用内存空间为整个新生代容量的<strong>90%</strong>（<code>Eden</code>的<strong>80%</strong>加上一个<code>Survivor</code>的<strong>10%</strong>）。</p><blockquote><p><code>Appel式回收</code>还有一个充当罕见情况的<code>“逃生门”</code>的安全设计，当<code>Survivor</code>空间不足以容纳一次<code>Minor GC</code>之后存活的对象时，就需要依赖<strong>其他内存区域（实际上大多就是老年代）</strong>进行<code>分配担保（Handle Promotion）</code>。</p></blockquote><h4 id="2-4-标记-整理-Mark-Compact-算法"><a href="#2-4-标记-整理-Mark-Compact-算法" class="headerlink" title="2.4 标记-整理(Mark-Compact)算法"></a>2.4 标记-整理(Mark-Compact)算法</h4><p><code>“标记-整理”（Mark-Compact）算法</code>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Compact.PNG" alt="“标记-整理”算法"></p><p>是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。</p><h3 id="3-HotSpot的算法细节实现"><a href="#3-HotSpot的算法细节实现" class="headerlink" title="3. HotSpot的算法细节实现"></a>3. HotSpot的算法细节实现</h3><h4 id="3-1-根节点枚举"><a href="#3-1-根节点枚举" class="headerlink" title="3.1 根节点枚举"></a>3.1 根节点枚举</h4><p>所有收集器在根节点枚举这一步骤时都是<strong>必须暂停用户线程</strong>的，因此毫无疑问根节点枚举与整理内存碎片一样会面临相似的<code>“Stop The World”</code>的困扰。</p><p><code>HotSpot</code>使用一组称为<code>OopMap</code>的数据结构直接得到哪些地方存放着对象引用。（<code>普通对象指针（Ordinary Object Pointer，OOP）</code>）</p><blockquote><ul><li>一旦类加载动作完成的时候，就会把对象内什么偏移量上是什么类型的数据计算出来；</li><li>在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。</li></ul></blockquote><p>这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等<code>GC Roots</code>开始查找。</p><h4 id="3-2-安全点"><a href="#3-2-安全点" class="headerlink" title="3.2 安全点"></a>3.2 安全点</h4><p><code>HotSpot</code>没有为每条指令都生成<code>OopMap</code>，只是在<strong>“特定的位置”</strong>记录了这些信息，这些位置被称为<code>安全点（Safepoint）</code>。有了安全点的设定，强制要求必须执行到达安全点后才能够暂停下来开始垃圾收集。</p><blockquote><p>安全点位置的选取基本上是以“<code>是否具有让程序长时间执行的特征</code>”，<code>“长时间执行”</code>的最明显特征就是<strong>指令序列的复用</strong>，例如<u>方法调用、循环跳转、异常跳转</u>等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p></blockquote><p>如何在垃圾收集发生时让所有线程（这里其实<code>不包括执行JNI调用的线程</code>）都跑到最近的安全点，然后停顿下来。</p><blockquote><p><code>抢先式中断（Preemptive Suspension）</code>在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。</p><p><code>主动式中断（Voluntary Suspension）</code>当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一 个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。</p></blockquote><p><code>HotSpot</code>使用<code>内存保护陷阱</code>的方式，把轮询操作精简至只有一条汇编指令的程度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x01b6d62d: test %eax,0x160100</span><br></pre></td></tr></table></figure><p>当需要暂停用户线程时，虚拟机把<code>0x160100</code>的内存页设置为不可读，那线程执行到<code>test</code>指令时就会产生一个<code>自陷异常信号</code>，然后在预先注册的异常处理器中挂起线程实现等待。</p><h4 id="3-3-安全区域"><a href="#3-3-安全区域" class="headerlink" title="3.3 安全区域"></a>3.3 安全区域</h4><p><code>安全区域</code>是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。</p><blockquote><ul><li>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。</li><li>当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段）:<ul><li>如果完成了，那线程就当作没事发生过，继续执行；</li><li>否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</li></ul></li></ul></blockquote><h4 id="3-4-记忆集与卡表"><a href="#3-4-记忆集与卡表" class="headerlink" title="3.4 记忆集与卡表"></a>3.4 记忆集与卡表</h4><p><code>记忆集（Remembered Set）</code>是一种用于记录<u>从非收集区域指向收集区域的指针集合</u>的抽象数据结构。实现记忆集的一些可供选择（当然也可以选择这个范围以外的）的记录精度：</p><ul><li><strong>字长精度</strong>：每个记录精确到一个机器字长，该字包含跨代指针。</li><li><strong>对象精度</strong>：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li><li><strong>卡精度</strong>：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li></ul><p>“卡精度”所指的是用一种称为<code>“卡表”（Card Table）</code>的方式去实现记忆集，字节数组<code>CARD_TABLE</code>的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作<code>“卡页”（Card Page）</code>。</p><blockquote><p>只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为<code>1</code>，称为这个元素变脏（Dirty），没有则标识为<code>0</code>。</p></blockquote><h4 id="3-5-写屏障"><a href="#3-5-写屏障" class="headerlink" title="3.5  写屏障"></a>3.5  写屏障</h4><p>卡表元素何时变脏?</p><blockquote><p>有其他分代区域中对象引用了本区域对象时</p></blockquote><p>如何变脏?</p><blockquote><p>在<code>HotSpot</code>虚拟机里是通过<code>写屏障（Write Barrier）</code>技术维护卡表状态的。写屏障可以看作在虚拟机层面对<code>“引用类型字段赋值”</code>这个动作的<code>AOP切面</code></p><ul><li>在引用对象赋值时会产生一个<code>环形（Around）</code>通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。<ul><li>在赋值前的部分的写屏障叫作<code>写前屏障（Pre-Write Barrier）</code>；</li><li>在赋值后的则叫作<code>写后屏障（Post-Write Barrier）</code>。</li></ul></li></ul></blockquote><p><strong>“伪共享”（False Sharing）问题</strong></p><blockquote><p>现代中央处理器的缓存系统中是以<code>缓存行（Cache Line）</code>为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低。</p><p>为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏</p></blockquote><h4 id="3-6-并发的可达性分析"><a href="#3-6-并发的可达性分析" class="headerlink" title="3.6 并发的可达性分析"></a>3.6 并发的可达性分析</h4><p>可达性分析的停顿时间与Java堆容量直接成正比例关系，把遍历对象图过程中遇到的对象，按照<strong>“是否访问过”</strong>这个条件标记成以下三种颜色，演示并发出现<strong>“对象消失”</strong>问题：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Object_disappeared.PNG" alt="并发出现“对象消失”问题"></p><ul><li><strong>白色</strong>：表示对象尚未被垃圾收集器访问过。</li><li><strong>黑色</strong>：表示对象已经被垃圾收集器访问过，且这个对象的<u>所有引用都已经扫描过</u>。</li><li><strong>灰色</strong>：表示对象已经被垃圾收集器访问过，但这个对象上<u>至少存在一个引用还没有被扫描过</u>。</li></ul><p>当且仅当以下两个条件同时满足时，会产生“对象消失”的问题：</p><blockquote><ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li></ul></blockquote><p>产生了两种解决方案：</p><blockquote><ul><li><p><code>增量更新（Incremental Update）</code>破坏的是第一个条件。当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</p></li><li><p><code>原始快照（Snapshot At The Beginning，SATB）</code>破坏的是第二个条件。当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p></li></ul></blockquote><h3 id="4-经典垃圾收集器"><a href="#4-经典垃圾收集器" class="headerlink" title="4. 经典垃圾收集器"></a>4. 经典垃圾收集器</h3><p>七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Garbage_collector.PNG" alt="HotSpot虚拟机的垃圾收集器"></p><h4 id="4-1-新生代收集器"><a href="#4-1-新生代收集器" class="headerlink" title="4.1 新生代收集器"></a>4.1 新生代收集器</h4><h5 id="4-1-1-Serial收集器"><a href="#4-1-1-Serial收集器" class="headerlink" title="4.1.1 Serial收集器"></a>4.1.1 Serial收集器</h5><p><code>Serial收集器</code>是一个单线程工作的收集器，但它的“单线程”的意义是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/serial_collector.PNG" alt="Serial/Serial Old收集器运行示意图"></p><blockquote><p>它是所有收集器里<code>额外内存消耗（Memory Footprint）</code>最小的，简单而高效</p></blockquote><h5 id="4-1-2-ParNew收集器"><a href="#4-1-2-ParNew收集器" class="headerlink" title="4.1.2 ParNew收集器"></a>4.1.2 ParNew收集器</h5><p><code>ParNew收集器</code>实质上是<code>Serial收集器</code>的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为都与Serial收集器完全一致。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ParNew_collector.PNG" alt="ParNew/Serial Old收集器运行示意图l Old收集器运行示意图"></p><p>在谈论垃圾收集器的上下文语境中，<code>并行和并发</code>可以理解为：</p><ul><li><code>并行（Parallel）</code>：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态</li><li><code>并发（Concurrent）</code>：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。</li></ul><h5 id="4-1-3-Parallel-Scavenge收集器"><a href="#4-1-3-Parallel-Scavenge收集器" class="headerlink" title="4.1.3 Parallel Scavenge收集器"></a>4.1.3 Parallel Scavenge收集器</h5><p><code>Parallel Scavenge收集器</code>也是一款<code>新生代收集器</code>，它同样是基于<u>标记-复制算法</u>实现的收集器，也是能够并行收集的多线程收集器。Parallel Scavenge收集器的目标则是达到一个可控制的<code>吞吐量（Throughput）</code>，吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值：</p><script type="math/tex; mode=display">吞吐量 = \frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}</script><p>高吞吐量可以最高效率地利用处理器资源，尽快完成程序的运算任务，<em>主要适合在后台运算而不需要太多交互的分析任务</em>。</p><blockquote><p><code>自适应的调节策略（GC Ergonomics）</code>让虚拟机根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p></blockquote><h4 id="4-2-老年代收集器"><a href="#4-2-老年代收集器" class="headerlink" title="4.2 老年代收集器"></a>4.2 老年代收集器</h4><h5 id="4-2-1-Serial-Old收集器"><a href="#4-2-1-Serial-Old收集器" class="headerlink" title="4.2.1 Serial Old收集器"></a>4.2.1 Serial Old收集器</h5><p><code>Serial Old</code>是Serial收集器的老年代版本，它同样是一个单线程收集器，使用<u>标记-整理算法</u>。</p><h5 id="4-2-2-Parallel-Old收集器"><a href="#4-2-2-Parallel-Old收集器" class="headerlink" title="4.2.2 Parallel Old收集器"></a>4.2.2 Parallel Old收集器</h5><p><code>Parallel Old</code>是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于<u>标记-整理算法</u>实现。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Parallel_Old_collector.PNG" alt="ParNew/Serial Old收集器运行示意图"></p><blockquote><p>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p></blockquote><h5 id="4-2-3-CMS收集器"><a href="#4-2-3-CMS收集器" class="headerlink" title="4.2.3 CMS收集器"></a>4.2.3 CMS收集器</h5><p><code>CMS（Concurrent Mark Sweep）收集器</code>是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于<u>标记-清除算法</u>实现的，它的运作过程分为四个步骤：</p><ol><li><code>初始标记（CMS initial mark）</code>。只是标记一下<code>GC Roots</code>能<strong>直接</strong>关联到的对象，速度很快；</li><li><code>并发标记（CMS concurrent mark）</code>。从<code>GC Roots</code>的<u>直接关联对象</u>开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</li><li><code>重新标记（CMS remark）</code>。修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；</li><li><code>并发清除（CMS concurrent sweep）</code>。清理删除掉标记阶段判断的已经死亡的对象。</li></ol><p>初始标记、重新标记这两个步骤仍然需要<code>“Stop The World”</code>。在整个过程中<em>耗时最长</em>的<code>并发标记</code>和<code>并发清除</code>阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说<code>CMS收集器</code>的内存回收过程是与用户线程一起<strong>并发执行</strong>的。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Concurrent_Mark_Sweep.PNG" alt="Concurrent Mark Sweep收集器运行示意图"></p><blockquote><p>优点：并发收集、低停顿。也称之为<code>“并发低停顿收集器”（Concurrent Low Pause Collector）</code>。</p><p>缺点：</p><ul><li>CMS收集器对<code>处理器资源</code>非常敏感。</li><li>由于CMS收集器无法处理<code>“浮动垃圾”（Floating Garbage）</code>，有可能出现<code>“Con-current Mode Failure”</code>失败进而导致另一次完全<code>“Stop The World”</code>的<code>Full GC</code>的产生。<ul><li><code>“浮动垃圾”</code>：在CMS的<code>并发标记</code>和<code>并发清理</code>阶段，用户线程运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。</li><li><code>“并发失败”（Concurrent Mode Failure）</code>：CMS运行期间预留的内存无法满足程序分配新对象的需要。虚拟机将不得不启动<code>后备预案</code>：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集。</li></ul></li><li>CMS是一款基于“标记-清除”算法实现的收集器，收集结束时会有大量<code>空间碎片</code>产生。</li></ul></blockquote><h4 id="4-3-Garbage-First收集器"><a href="#4-3-Garbage-First收集器" class="headerlink" title="4.3 Garbage First收集器"></a>4.3 Garbage First收集器</h4><p><code>Garbage First（简称G1）收集器</code>开创了收集器<code>面向局部收集</code>的设计思路和<code>基于Region的内存布局</code>形式，也被Oracle官方称为<code>“全功能的垃圾收集器”（Fully-Featured Garbage Collector）</code>。</p><blockquote><p><code>“停顿时间模型”（Pause Prediction Model）</code>是能够支持指定在一个长度为<strong>M毫秒</strong>的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。</p></blockquote><p><code>G1</code>面向堆内存任何部分来组成<code>回收集（Collection Set，一般简称CSet）</code>进行回收，衡量标准是<u>哪块内存中存放的垃圾数量最多，回收收益最大</u>。这就是G1收集器的<code>Mixed GC模式</code>。</p><h5 id="4-3-1-基于Region的堆内存布局"><a href="#4-3-1-基于Region的堆内存布局" class="headerlink" title="4.3.1 基于Region的堆内存布局"></a>4.3.1 基于Region的堆内存布局</h5><p>G1不再坚持固定大小以及固定数量的分代区域划分，而是<u>把连续的Java堆划分为多个大小相等的<code>独立区域（Region）</code></u>，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理。</p><blockquote><p>Region中一类特殊的<code>Humongous区域</code>，专门用来存储大对象。只要大小超过了一个 Region容量一半的对象即可判定为大对象。</p></blockquote><h5 id="4-3-2-面向局部收集"><a href="#4-3-2-面向局部收集" class="headerlink" title="4.3.2 面向局部收集"></a>4.3.2 面向局部收集</h5><p>G1中新生代和老年代不再是固定的了，它们都是一系列区域（<strong>不需要连续</strong>）的<code>动态集合</code>。将Region作为单次回收的最小单元，可以有计划地避免<u>在整个Java堆中进行全区域的垃圾收集</u>。G1收集器跟踪各个Region里面的垃圾堆积的“价值”大小：</p><blockquote><p>价值即回收所获得的空间大小以及回收所需时间的经验值</p></blockquote><p>在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region。(“Garbage First”名字的由来)</p><h5 id="4-3-3-关键的细节问题"><a href="#4-3-3-关键的细节问题" class="headerlink" title="4.3.3 关键的细节问题"></a>4.3.3 关键的细节问题</h5><ul><li><u>将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？</u>使用记忆集避免全堆作为GC Roots扫描。G1的记忆集在存储结构的<u>本质上是一 种哈希表</u>，<code>Key</code>是别的Region的起始地址，<code>Value</code>是一个集合，里面存储的元素是卡表的索引号。</li><li><u>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</u>G1 收集器是通过<code>原始快照（SATB）算法</code>保证用户线程改变对象引用关系时，不能打破原本的对象图结构。此外，G1为每一个Region设计了两个名为<code>TAMS（Top at Mark Start）</code>的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li><li><u>怎样建立起可靠的停顿预测模型？</u>G1收集器的停顿预测模型是以<code>衰减均值（Decaying Average）</code>为理论基础来实现的。在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。衰减平均值更准确地代表“最近的”平均状态。</li></ul><h5 id="4-3-4-关键的细节问题"><a href="#4-3-4-关键的细节问题" class="headerlink" title="4.3.4 关键的细节问题"></a>4.3.4 关键的细节问题</h5><p>G1收集器的运作过程大致可划分为以下四个步骤：</p><ul><li><code>初始标记（Initial Marking）</code>。仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象，并且修改<code>TAMS</code>指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。</li><li><code>并发标记（Concurrent Marking）</code>。从<code>GC Root</code>开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。当对象图扫描完成以后，还要重新处理<code>原始快照SATB</code>记录下的在并发时有引用变动的对象。</li><li><code>最终标记（Final Marking）</code>。对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的<code>SATB记录</code>。</li><li><code>筛选回收（Live Data Counting and Evacuation）</code>。负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。<ul><li>这里的操作涉及存活对象的移动，是<strong>必须暂停用户线程</strong>，由多条收集器线程并行完成的。</li></ul></li></ul><p>G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/G1_collector.PNG" alt="G1收集器运行示意图"></p><blockquote><p>从G1开始，最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的<code>内存分配速率 （Allocation Rate）</code>，应用在分配，同时收集器在收集，只要收集的速度能跟得上对象分配的速度，那一切就能运作得很完美。</p></blockquote><p>优点：</p><ul><li>可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集</li><li>G1<strong>从整体来看是基于“标记-整理”算法</strong>实现的收集器，但<strong>从局部（两个Region之间）上看又是基于“标记-复制”</strong>算法实现，G1运作期间不会产生内存空间碎片。</li></ul><p>缺点：</p><ul><li>G1为了垃圾收集产生的内存占用（Footprint）比CMS要高。G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间；</li><li>G1程序运行时的额外执行负载（Overload）比CMS要高。G1除了使用写后屏障来进行卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。</li></ul><h3 id="5-低延迟垃圾收集器"><a href="#5-低延迟垃圾收集器" class="headerlink" title="5. 低延迟垃圾收集器"></a>5. 低延迟垃圾收集器</h3><p>衡量垃圾收集器的三项最重要的指标是：<code>内存占用（Footprint）</code>、<code>吞吐量（Throughput）</code>和<code>延迟 （Latency）</code>。两款目前仍处于实验状态的收集器<code>Shenandoah</code>和<code>ZGC</code>，被官方命名为<code>“低延迟垃圾收集器”（Low-Latency Garbage Collector或者Low-Pause-Time Garbage Collector）</code>。</p><h4 id="5-1-Shenandoah收集器"><a href="#5-1-Shenandoah收集器" class="headerlink" title="5.1 Shenandoah收集器"></a>5.1 Shenandoah收集器</h4><p><code>Shenandoah</code>是一款只有<code>OpenJDK</code>才会包含，而<code>OracleJDK</code>里反而不存在的收集器。Shenandoah反而更像是G1的下一代继承者，在管理堆内存方面，它与G1至少有三个明显的不同之处：</p><ul><li>支持并发的整理算法；</li><li>Shenandoah是默认不使用分代收集的；</li><li>Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为<code>“连接矩阵”（Connection Matrix）</code>的全局数据结构来记录<em>跨Region的引用关系</em>，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。</li></ul><p>Shenandoah收集器的工作过程大致可以划分为以下九个阶段：</p><ul><li><code>初始标记（Initial Marking）</code>。标记与<code>GC Roots</code>直接关联的对象，这个阶段仍是<code>“Stop The World”</code>的。</li><li><code>并发标记（Concurrent Marking）</code>。遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的。</li><li><code>最终标记（Final Marking）</code>。处理剩余的<code>SATB扫描</code>，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组<code>回收集（Collection Set）</code>。<em>会有一小段短暂的停顿</em>。</li><li><code>并发清理（Concurrent Cleanup）</code>。清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为<code>Immediate Garbage Region</code>）。</li><li><code>并发回收（Concurrent Evacuation）</code>。Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中，Shenandoah通过读屏障和被称为“<code>Brooks Pointers</code>”的转发指针来解决并发回收阶段遇到的困难。</li><li><code>初始引用更新（Initial Update Reference）</code>。把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务。<em>会产生一个非常短暂的停顿</em>。</li><li><code>并发引用更新（Concurrent Update Reference）</code>。按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值。<em>与用户线程一起并发的</em>。</li><li><code>最终引用更新（Final Update Reference）</code>。修正存在于<code>GC Roots</code>中的引用，这个阶段是Shenandoah的最后一次停顿。</li><li><code>并发清理（Concurrent Cleanup）</code>。经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成<code>Immediate Garbage Regions</code>了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</li></ul><p>三个最重要的并发阶段<strong>（并发标记、并发回收、并发引用更新）</strong>。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Shenandoah.PNG" alt="Shenandoah收集器的工作过程"></p><p>黄色的区域代表的是<em>被选入回收集的Region</em>，绿色部分就代表<em>还存活的对象</em>，蓝色就是<em>用户线程可以用来分配对象的内存Region</em>。</p><p><code>Brooks Pointer</code>。<code>Brooks</code>提出了使用<code>转发指针</code>（<code>Forwarding Pointer</code>，也常被称为<code>Indirection Pointer</code>）来实现对象移动与用户程序并发的一种解决方案。<code>Brooks</code>在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Brooks_Pointers.PNG" alt="Brooks Pointers示意图"></p><p>转发指针加入后带来的收益是当对象拥有了一份新的副本时，只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Brooks_Pointers2.PNG" alt="Brooks Pointers原理"></p><p><strong>Brooks转发指针的多线程竞争问题</strong>：</p><ul><li>收集器线程与用户线程发生的只是并发读取，那无论读到旧对象还是新对象上的字段，返回的结果都应该是一样的；</li><li>如果发生的是并发写入，就一定必须保证<code>写操作</code>只能发生在新复制的对象上。</li></ul><p>Shenandoah收集器是通过<code>比较并交换（Compare And Swap，CAS）操作</code>来保证并发时对象的访问正确性的。</p><h4 id="5-2-ZGC收集器"><a href="#5-2-ZGC收集器" class="headerlink" title="5.2 ZGC收集器"></a>5.2 ZGC收集器</h4><p><code>ZGC（Z Garbage Collector）</code>是一款在 <code>JDK 11</code>中新加入的具有实验性质的低延迟垃圾收集器。ZGC和Shenandoah的目标是高度相似的，都希望<u>在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</u>。</p><h5 id="5-2-1-ZGC的内存布局"><a href="#5-2-1-ZGC的内存布局" class="headerlink" title="5.2.1 ZGC的内存布局"></a>5.2.1 ZGC的内存布局</h5><p>ZGC也采用基于Region的堆内存布局（在一些官方资料中将它称为<code>Page</code>或者<code>ZPage</code>），ZGC的Region具有<strong>动态性</strong>——<u>动态创建和销毁，以及动态的区域容量大小</u>。ZGC的 Region可以有大、中、小三类容量：</p><ul><li><code>小型Region（Small Region）</code>：容量固定为<code>2MB</code>，用于放置<u>小于</u><code>256KB</code>的小对象。</li><li><code>中型Region（Medium Region）</code>：容量固定为<code>32MB</code>，用于放置<u>大于等于</u><code>256KB</code>但<u>小于</u><code>4MB</code>的对象。</li><li><code>大型Region（Large Region）</code>：容量不固定，可以动态变化，但必须为<code>2MB</code>的<strong>整数倍</strong>，用于放置<code>4MB</code>或以上的大对象。每个大型Region中只会存放一个大对象，大型Region在ZGC的实现中<strong>不会被重分配</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ZGC_memory.PNG" alt="ZGC的堆内存布局"></p><h5 id="5-2-2-ZGC的并发整理算法"><a href="#5-2-2-ZGC的并发整理算法" class="headerlink" title="5.2.2 ZGC的并发整理算法"></a>5.2.2 ZGC的并发整理算法</h5><p>ZGC收集器采用的<code>染色指针技术</code>（<code>Colored Pointer</code>，其他类似的技术中可能将它称为<code>Tag Pointer</code>或者<code>Version Pointer</code>）。染色指针直接把标记信息记在引用对象的指针上。</p><p>在64位系统中，理论可以访问的内存高达<code>16EB</code>（<code>2的64次幂</code>）字节。基于需求 、性能和成本的考虑，在<code>AMD64</code>架构中只支持到<code>52</code>位（<code>4PB</code>）的<u>地址总线</u>和<code>48</code>位（<code>256TB</code>）的<u>虚拟地址空间</u>。</p><blockquote><p>操作系统也还会施加自己的约束，64位的<code>Linux</code>则分别支持<code>47</code>位（<code>128TB</code>）的进程虚拟地址空间和<code>46</code>位（<code>64TB</code>）的物理地址空间，64位的<code>Windows</code>系统甚至只支持<code>44</code>位（<code>16TB</code>）的物理地址空间。</p></blockquote><p>Linux下64位指针的高18位不能用来寻址，ZGC的染色指针技术利用这剩下的46位指针宽度，将其<code>高4位</code>提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的<strong>三色标记状态</strong>、<strong>是否进入了重分配集</strong>（即被移动过）、<strong>是否只能通过finalize()方法才能被访问到</strong>。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Colored_Pointer.PNG" alt="染色指针"></p><blockquote><p>这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致ZGC能够管理的内存不可以超过<code>4TB</code></p></blockquote><p>染色指针的三大优势：</p><ul><li>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</li><li>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。</li><li>染色指针可以作为一种<code>可扩展</code>的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li></ul><h5 id="5-2-3-虚拟内存映射技术"><a href="#5-2-3-虚拟内存映射技术" class="headerlink" title="5.2.3 虚拟内存映射技术"></a>5.2.3 虚拟内存映射技术</h5><p>处理器会使用<code>分页管理机制</code>把线性地址空间和物理地址空间分别划分为大小相同的块，这样的内存块被称为<code>“页”（Page）</code>。通过在线性虚拟空间的页与物理地址空间的页之间建立的<code>映射表</code>，分页管理机制会进行线性地址到物理地址空间的映射，完成线性地址到物理地址的转换。</p><p><code>Linux/x86-64</code>平台上的ZGC使用了<code>多重映射（Multi-Mapping）</code>将<u>多个不同的虚拟内存地址映射到同一个物理内存地址上</u>，这是一种<strong>多对一映射</strong>，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。把染色指针中的标志位看作是<code>地址的分段符</code>，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Multi_Mapping.PNG" alt="多重映射下的寻址"></p><h5 id="5-2-4-ZGC的运作过程"><a href="#5-2-4-ZGC的运作过程" class="headerlink" title="5.2.4 ZGC的运作过程"></a>5.2.4 ZGC的运作过程</h5><p>ZGC的运作过程大致可划分为以下四个大的阶段。全部四个阶段<strong><u>都是可以并发执行</u></strong>的，仅是两个阶段中间会存在短暂的停顿小阶段，如初始化<code>GC Root</code>直接关联对象的<code>Mark Start</code>。</p><ul><li><code>并发标记（Concurrent Mark）</code>：并发标记是<strong>遍历对象图做可达性分析的阶段</strong>，前后也要经过初始标记、最终标记的短暂停顿。ZGC 的标记是在指针上进行的，标记阶段会更新染色指针中的<code>Marked0</code>、<code>Marked1</code>标志位。</li><li><code>并发预备重分配（Concurrent Prepare for Relocate）</code>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成<code>重分配集（Relocation Set）</code>。ZGC每次回收都会<strong>扫描所有的Region</strong>，用范围更大的扫描成本换取<u>省去G1中记忆集的维护成本</u>。</li><li><code>并发重分配（Concurrent Relocate）</code>：把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<code>转发表（Forward Table）</code>，<u>记录从旧对象到新对象的转向关系</u>。<ul><li>指针的<code>“自愈”（Self-Healing）</code>能力：ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被<code>预置的内存屏障</code>所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象。这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次。</li></ul></li><li><code>并发重映射（Concurrent Remap）</code>：重映射所做的就是<u>修正整个堆中指向重分配集中旧对象的所有引用</u>，但是ZGC重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。ZGC把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成。</li></ul><h5 id="5-2-5-“NUMA-Aware”的内存分配"><a href="#5-2-5-“NUMA-Aware”的内存分配" class="headerlink" title="5.2.5 “NUMA-Aware”的内存分配"></a>5.2.5 “NUMA-Aware”的内存分配</h5><p>ZGC支持<code>“NUMA-Aware”的内存分配</code>。<code>NUMA</code>（<code>Non-Uniform Memory Access</code>，<strong>非统一内存访问架构</strong>）是一种为多处理器或者多核处理器的计算机所设计的内存架构。在<code>NUMA</code>架构下，ZGC收集器会优先尝试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问。</p><h3 id="6-选择合适的垃圾收集器"><a href="#6-选择合适的垃圾收集器" class="headerlink" title="6. 选择合适的垃圾收集器"></a>6. 选择合适的垃圾收集器</h3><h4 id="6-1-Epsilon收集器"><a href="#6-1-Epsilon收集器" class="headerlink" title="6.1 Epsilon收集器"></a>6.1 Epsilon收集器</h4><p><code>Epsilon</code>这是一款以<u>不能够进行垃圾收集</u>为“卖点”的垃圾收集器。</p><blockquote><p>Epsilon收集器由<code>RedHat</code>公司在<code>JEP 318</code>中提出，在此提案里<code>Epsilon</code>被形容成一个<code>无操作的收集器（A No-Op Garbage Collector）</code>。</p></blockquote><p>一个垃圾收集器除了垃圾收集这个本职工作之外，它还要负责<u>堆的管理与布局</u>、<u>对象的分配</u>、<u>与解释器的协作</u>、<u>与编译器的协作</u>、<u>与监控子系统协作</u>等职责。Epsilon是垃圾收集器的统一接口，用于需要剥离垃圾收集器影响的性能测试和压力测试。</p><p>在实际生产环境中，不能进行垃圾收集的Epsilon也用于应对<code>短时间、小规模</code>的服务形式，只要Java虚拟机<u>能正确分配内存，在堆耗尽之前就会退出</u>，那显然运行负载极小、没有任何回收行为的Epsilon便是很恰当的选择。</p><h4 id="6-2-收集器的权衡"><a href="#6-2-收集器的权衡" class="headerlink" title="6.2 收集器的权衡"></a>6.2 收集器的权衡</h4><p>选择一款适合自己应用的收集器主要受以下三 个因素影响：</p><ul><li><code>应用程序的主要关注点是什么？</code><ul><li>如果是数据分析、科学计算类的任务，目标是能尽快算出结果， 那吞吐量就是主要关注点；</li><li>如果是<code>SLA（（Service Level Agreements））</code>应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点；</li><li>而如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的。</li></ul></li><li><code>运行应用的基础设施如何？</code><ul><li>譬如硬件规格，要涉及的系统架构；</li><li>处理器的数量多少，分配内存的大小；</li><li>选择的操作系统。</li></ul></li><li>使用JDK的发行商是什么？版本号是多少？是ZingJDK/Zulu、OracleJDK、Open-JDK、OpenJ9抑或是其他公司的发行版？该JDK对应了《Java虚拟机规范》的哪个版本？</li></ul><p>实战中切不可纸上谈兵，<strong>根据系统实际情况去测试才是选择收集器的最终依据</strong>。</p><h4 id="6-3-虚拟机及垃圾收集器日志"><a href="#6-3-虚拟机及垃圾收集器日志" class="headerlink" title="6.3 虚拟机及垃圾收集器日志"></a>6.3 虚拟机及垃圾收集器日志</h4><p><code>JDK 9</code>后，<code>HotSpot</code>所有功能的日志都收归到了<code>“-Xlog”</code>参数上，这个参数的能力也相应被极大拓展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog[:[selector][:[output][:[decorators][:output-options]]]]</span><br></pre></td></tr></table></figure><p>最关键的参数是<code>选择器（Selector）</code>，它由<code>标签（Tag）</code>和<code>日志级别（Level）</code>共同组成。</p><p>日志级别从低到高，共有<code>Trace，Debug，Info，Warning，Error，Off</code>六种级别，默认级别为<code>Info</code>。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Log_parameter.PNG" alt="JDK 9前后日志参数变化"></p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Log_parameter2.PNG" alt="JDK 9前后日志参数变化(续)"></p><h4 id="6-4-垃圾收集器参数总结"><a href="#6-4-垃圾收集器参数总结" class="headerlink" title="6.4 垃圾收集器参数总结"></a>6.4 垃圾收集器参数总结</h4><p>具体可以查看书籍，主要还是用到的时候查一下就行。</p><h3 id="7-内存分配与回收策略"><a href="#7-内存分配与回收策略" class="headerlink" title="7. 内存分配与回收策略"></a>7. 内存分配与回收策略</h3><p>Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：<u><strong>自动给对象分配内存</strong></u>以及<u><strong>自动回收分配给对象的内存</strong></u>。对象的内存分配，从概念上讲，应该都是在堆上分配（而实际上也有可能经过<code>即时编译</code>后被拆散为标量类型并间接地在栈上分配）。</p><h4 id="7-1-对象优先在Eden分配"><a href="#7-1-对象优先在Eden分配" class="headerlink" title="7.1 对象优先在Eden分配"></a>7.1 对象优先在Eden分配</h4><p>对象在新生代<code>Eden区</code>中分配。当<code>Eden区</code>没有足够空间进行分配时，虚拟机将发起 一次<code>Minor GC</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">// 出现一次Minor GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>testAllocation()</code>中分配<code>allocation4</code>对象的语句时会发生一次<code>Minor GC</code>，产生这次垃圾收集的原因是为<code>allocation4</code>分配内存时，发现 <code>Eden</code>已经被占用了<code>6MB</code>，剩余空间已不足以分配<code>allocation4</code>所需的<code>4MB</code>内存，因此发生<code>Minor GC</code>。</p><p>垃圾收集期间虚拟机又发现已有的三个<code>2MB</code>大小的对象全部无法放入<code>Survivor</code>空间（<strong>Survivor空间只有 1MB大小</strong>），所以只好通过分配担保机制提前转移到老年代去。</p><p>收集结束后，<code>4MB</code>的<code>allocation4</code>对象顺利分配在<code>Eden</code>中。因此程序执行完的结果是<code>Eden</code>占用 <code>4MB</code>（被<code>allocation4</code>占用），<code>Survivor</code>空闲，老年代被占用<code>6MB</code>（被<code>allocation1、2、3</code>占用）。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testAllocation.PNG" alt="testAllocation运行结果"></p><h4 id="7-2-大对象直接进入老年代"><a href="#7-2-大对象直接进入老年代" class="headerlink" title="7.2 大对象直接进入老年代"></a>7.2 大对象直接进入老年代</h4><p>最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。</p><blockquote><p>在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">* -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation;</span><br><span class="line">allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">//直接分配在老年代中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Eden空间几乎没有被使用，而老年代的<code>10MB</code>空间被使用了40%，也就是<code>4MB</code>的allocation对象<strong>直接就分配在老年代中</strong></p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testPretenureSizeThreshold.PNG" alt="testPretenureSizeThreshold运行结果"></p><h4 id="7-3-长期存活的对象将进入老年代"><a href="#7-3-长期存活的对象将进入老年代" class="headerlink" title="7.3 长期存活的对象将进入老年代"></a>7.3 长期存活的对象将进入老年代</h4><p>虚拟机给每个对象定义了一个<code>对象年龄（Age）计数器</code>，存储在对象头中。</p><p>对象通常在<code>Eden区</code>里诞生，如果经过第一次 <code>Minor GC</code>后仍然存活，并且能被<code>Survivor</code>容纳的话，该对象会被移动到<code>Survivor</code>空间中，并且将其对象年龄设为<code>1岁</code>。对象在<code>Survivor</code>区中每熬过一次<code>Minor GC</code>，年龄就增加<code>1岁</code>，当它的年龄增加到一定程度（默认为15），就会<strong>被晋升到老年代中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment">* -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>]; <span class="comment">// 什么时候进入老年代决定于XX:MaxTenuringThreshold设置</span></span><br><span class="line">allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">allocation3 = <span class="keyword">null</span>;</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当<code>-XX：MaxTenuringThreshold=1</code>时，<code>allocation1</code>对象在第二次<code>GC</code>发生时进入老年代， 新生代已使用的内存在垃圾收集以后非常干净地变成<code>0KB</code>。</li><li>当<code>-XX：MaxTenuringThreshold=15</code>时， 第二次<code>GC</code>发生后，<code>allocation1</code>对象则还留在新生代<code>Survivor</code>空间，这时候新生代仍然有<code>404KB</code>被占用。</li></ul><h4 id="7-4-动态对象年龄判定"><a href="#7-4-动态对象年龄判定" class="headerlink" title="7.4 动态对象年龄判定"></a>7.4 动态对象年龄判定</h4><p>如果在<code>Survivor</code>空间中相同年龄所有对象大小的总和大于<code>Survivor</code>空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><h4 id="7-5-空间分配担保"><a href="#7-5-空间分配担保" class="headerlink" title="7.5 空间分配担保"></a>7.5 空间分配担保</h4><p>在发生<code>Minor GC</code>之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间：</p><ul><li>如果这个条件成立，那这一次<code>Minor GC</code>可以确保是安全的；</li><li>如果不成立，会查看是否允许担保失败（Handle Promotion Failure）：<ul><li>如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次<code>Minor GC</code>，尽管这次<code>Minor GC</code>是有风险的；</li><li>如果小于，或设置不允许冒险，那这时就要改为进行一次<code>Full GC</code>。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[读书|2021阅读]--《如何阅读一本书》</title>
    <link href="https://wuyunjie.top/2021/05/14/Reading_2021--How_to_Read_a_Book.html"/>
    <id>https://wuyunjie.top/2021/05/14/Reading_2021--How_to_Read_a_Book.html</id>
    <published>2021-05-14T12:30:38.000Z</published>
    <updated>2021-05-14T12:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>如何阅读一本书<br><a id="more"></a></p></blockquote><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><iframe src='https://www.xmind.net/embed/3TzT/' width='750' height='1000' frameborder='0' scrolling='no' allowfullscreen="true"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如何阅读一本书&lt;br&gt;
    
    </summary>
    
      <category term="Reading" scheme="https://wuyunjie.top/categories/Reading/"/>
    
    
      <category term="Reading" scheme="https://wuyunjie.top/tags/Reading/"/>
    
      <category term="Book" scheme="https://wuyunjie.top/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--11 异常处理</title>
    <link href="https://wuyunjie.top/2021/05/14/JavaLearning_Head_First_Java_11_exception_handling.html"/>
    <id>https://wuyunjie.top/2021/05/14/JavaLearning_Head_First_Java_11_exception_handling.html</id>
    <published>2021-05-14T08:43:25.000Z</published>
    <updated>2021-05-14T08:43:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>倒霉的事情就算会发生。找不到文件、服务器出现故障。<br><a id="more"></a></p></blockquote><h3 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h3><p>需要对可能发生的异常情况进行处理，<strong>未雨绸缪</strong>！Java的<code>异常处理机制(exception-handling)</code>将处理错误状况的代码放在一个容易阅读的位置。如果知道调用某个方法可能会有异常情况，可以预先准备问题处理程序甚至从错误中恢复。</p><blockquote><p>异常是一种<code>Exception</code>类型的对象。</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/exceptionClass.PNG" alt="异常类"></p><ul><li><p><strong>抛出异常(throws)</strong>。使用<code>throws</code>语句来抛出异常。</p><p>在编写可能会抛出异常的方法时，必须先声明有异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeRisk</span><span class="params">()</span> <span class="keyword">throws</span> BadException </span>&#123; <span class="comment">// 声明会抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (abandonAllHope) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BadException(); <span class="comment">// 创建异常对象并抛出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意声明时是<code>throws</code>，抛出时是<code>throw</code>。</p></blockquote></li><li><p><strong>捕捉异常(catch)</strong>。使用<code>try/catch</code>块来捕捉处理异常。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 有风险的动作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>非<code>RuntimeExceptions</code>子类的异常由编译器检查，称作<code>检查异常(checked exceptions)</code>；<code>RuntimeExceptions</code>类称为<code>非检查异常</code>，编译器不会检查。编译器会确保：</p><ol><li>如果有抛出异常，一定使用了<code>throws</code>来声明</li><li>如果调用会抛出异常的方法，一定知道异常可能性。即会处理异常。</li></ol><h4 id="1-1-try-catch块"><a href="#1-1-try-catch块" class="headerlink" title="1.1 try/catch块"></a>1.1 try/catch块</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/tryCatchFlow.PNG" alt="try/catch块流程"></p><p><code>finally</code>块用来存放不管有没有异常都需要执行的程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     turnOvenOn();</span><br><span class="line">     x.bake(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (BakingException ex) &#123; </span><br><span class="line">     ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     turnOvenOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果try或catch块有<code>return</code>指令，<strong><code>finally</code>块还是会执行</strong>！流程会跳到<code>finally</code>块然后再回到return指令。</p></blockquote><h4 id="1-2-throws"><a href="#1-2-throws" class="headerlink" title="1.2 throws"></a>1.2 throws</h4><p>方法可以抛出多个异常，声明时必须要含有全部可能的检查异常。调用方法时，编译器会坚持是否处理了所有可能的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laundry</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> PantsException, LingerieException </span>&#123;</span><br><span class="line">         <span class="comment">// code that could throw either exception</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Laundry laundry = <span class="keyword">new</span> Laundry();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             laundry.doLaundry();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(PantsException pex) &#123;</span><br><span class="line">             <span class="comment">// recovery code</span></span><br><span class="line">         &#125; <span class="keyword">catch</span>(LingerieException lex) &#123;</span><br><span class="line">             <span class="comment">// recovery code</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常也是多态的，所以异常也可以用多态的方式引用。抛出异常时可以声明多个异常的共同父类，捕捉异常时也同理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     laundry.doLaundry();</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClothingException cex) &#123;</span><br><span class="line">     <span class="comment">// recovery code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的确可以用<code>Exception</code>来捕捉所有异常，但也会在处理异常时无法精确定位捕捉到了何种异常。使用<code>catch</code>来处理异常时，在继承数中高层次的异常不能放到低层次的异常之前。</p><h4 id="1-3-duck异常"><a href="#1-3-duck异常" class="headerlink" title="1.3 duck异常"></a>1.3 duck异常</h4><blockquote><p>如果不想处理异常，可以把它duck掉来避开。</p></blockquote><p>也就是不用try/catch处理异常，而是再度throw该异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Washer</span> </span>&#123;</span><br><span class="line">     Laundry laundry = <span class="keyword">new</span> Laundry();</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException </span>&#123; </span><br><span class="line">         laundry.doLaundry();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> ClothingException </span>&#123;</span><br><span class="line">         Washer a = <span class="keyword">new</span> Washer();</span><br><span class="line">         a.foo();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/duckException.PNG" alt="duck异常"></p><h4 id="1-4-异常处理规则"><a href="#1-4-异常处理规则" class="headerlink" title="1.4 异常处理规则"></a>1.4 异常处理规则</h4><ol><li><code>catch</code>与<code>finally</code>不能没有<code>try</code>；</li><li><code>try</code>与<code>catch</code>之间不能有程序；</li><li><code>try</code>一定要有<code>catch</code>或<code>finally</code>；</li><li>只带有<code>finally</code>的方法必须duck异常(即声明)。</li></ol><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/exceptionRules.PNG" alt="异常处理规则"></p><h3 id="2-创建MIDI音乐播放器"><a href="#2-创建MIDI音乐播放器" class="headerlink" title="2. 创建MIDI音乐播放器"></a>2. 创建<code>MIDI</code>音乐播放器</h3><p><code>MIDI</code>音乐播放器，类似一款乐队软件。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/MIDI.PNG" alt="`MIDI`音乐播放器"></p><h4 id="2-1-JavaSound-API"><a href="#2-1-JavaSound-API" class="headerlink" title="2.1 JavaSound API"></a>2.1 <code>JavaSound</code> API</h4><p><code>JavaSound</code> API是<code>Java 1.3</code>后加入的一组类和接口，分为两部分：<code>MIDI(Musical Instrument Digital Interface)</code>和<code>取样(sampled)</code>。<code>MIDI</code>是不同电子发声装置沟通的标准协议，可以想象成<code>乐谱</code>，可以输入到“高级多功能电子魔音琴”中。</p><blockquote><p><code>MIDI</code>本身不带有声音，它带有的是有MIDI播放功能装置的指令</p></blockquote><h4 id="2-2-Sequencer"><a href="#2-2-Sequencer" class="headerlink" title="2.2 Sequencer"></a>2.2 Sequencer</h4><p>先获取<code>Sequencer</code>对象，它会将所有MIDI数据送到正确的装置上，由装置来产生音乐。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sequencer sequencer = MidiSystem.getSequencer();</span><br></pre></td></tr></table></figure><p>直接调用无法通过编译，编译器显式需要处理异常。API中说明<code>getSequencer()</code>可能会抛出<code>MidiUnavailableException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MusicTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Sequencer sequencer = MidiSystem.getSequencer();</span><br><span class="line">            System.out.println(<span class="string">"We get a sequencer"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MidiUnavailableException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Bummer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MusicTest1 mt = <span class="keyword">new</span> MusicTest1();</span><br><span class="line">        mt.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以下是<code>JavaSound</code>的工作原理：</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JavaSoundWorkFlow.PNG" alt="`JavaSound`的工作原理"></p><ul><li>运行该播放器需要5个步骤：</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/fiveStepOfMIDI.PNG" alt="`JavaSound`的工作原理"></p><blockquote><p>第5步是开始播放：<code>player.start();</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniMiniMusicApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiniMiniMusicApp mini = <span class="keyword">new</span> MiniMiniMusicApp();</span><br><span class="line">        mini.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个Sequencer并打开</span></span><br><span class="line">            Sequencer player = MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            Sequence seq = <span class="keyword">new</span> Sequence(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取一道音轨</span></span><br><span class="line">            Track track = seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage a = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOn = <span class="keyword">new</span> MidiEvent(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            ShortMessage b = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOff = <span class="keyword">new</span> MidiEvent(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Sequence放到Sequencer上(相对于把CD放到CD机上)</span></span><br><span class="line">            player.setSequence(seq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始播放</span></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-制作MidiEvent"><a href="#2-3-制作MidiEvent" class="headerlink" title="2.3 制作MidiEvent"></a>2.3 制作<code>MidiEvent</code></h4><p><code>MidiEvent</code>是组合乐曲的指令，一连串<code>MidiEvent</code>如同乐谱。必须在<code>MidiEvent</code>中指定何时开始播放某个音符(<code>NOTE ON event</code>)以及何时停止(<code>NOTE OFF event</code>)。</p><p><code>Midi</code>指令实际上放在<code>Message</code>对象中，<code>MidiEvent</code>由<code>Message</code>和发音时机组成。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/MidiEvent.PNG" alt="MidiEvent"></p><p><code>Message</code>中信息的格式：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/AnatomyMessage.PNG" alt="信息的格式"></p><p>使用命令行参数版本的播放器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniMusicCmdLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiniMusicCmdLine mini = <span class="keyword">new</span> MiniMusicCmdLine();</span><br><span class="line"><span class="comment">//        if (args.length &lt; 2) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Don’t forget the instrument and note args");</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            int instrument = Integer.parseInt(args[0]);</span></span><br><span class="line"><span class="comment">//            int note = Integer.parseInt(args[1]);</span></span><br><span class="line"><span class="comment">//            mini.play(instrument, note);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Input the instrument and note"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                String instrumentS = <span class="keyword">null</span>;</span><br><span class="line">                instrumentS = is.readLine();</span><br><span class="line">                String noteS = <span class="keyword">null</span>;</span><br><span class="line">                noteS = is.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> instrument = Integer.parseInt(instrumentS);</span><br><span class="line">                <span class="keyword">int</span> note = Integer.parseInt(noteS);</span><br><span class="line">                mini.play(instrument, note);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(<span class="keyword">int</span> instrument, <span class="keyword">int</span> note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个Sequencer并打开</span></span><br><span class="line">            Sequencer player = MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            Sequence seq = <span class="keyword">new</span> Sequence(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line">            <span class="comment">// 获取一道音轨</span></span><br><span class="line">            Track track = seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage first = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            first.setMessage(<span class="number">192</span>, <span class="number">1</span>, instrument, <span class="number">0</span>);</span><br><span class="line">            MidiEvent changeInstrument = <span class="keyword">new</span> MidiEvent(first, <span class="number">1</span>);</span><br><span class="line">            track.add(changeInstrument);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage a = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOn = <span class="keyword">new</span> MidiEvent(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            ShortMessage b = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOff = <span class="keyword">new</span> MidiEvent(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Sequence放到Sequencer上(相对于把CD放到CD机上)</span></span><br><span class="line">            player.setSequence(seq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始播放</span></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;倒霉的事情就算会发生。找不到文件、服务器出现故障。&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--10 数字和静态</title>
    <link href="https://wuyunjie.top/2021/05/14/JavaLearning_Head_First_Java_10_numbers_and_statics.html"/>
    <id>https://wuyunjie.top/2021/05/14/JavaLearning_Head_First_Java_10_numbers_and_statics.html</id>
    <published>2021-05-14T04:53:28.000Z</published>
    <updated>2021-05-14T04:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>盘算一下。<br><a id="more"></a></p></blockquote><h3 id="1-静态（static）"><a href="#1-静态（static）" class="headerlink" title="1. 静态（static）"></a>1. 静态（static）</h3><h4 id="1-1-静态方法"><a href="#1-1-静态方法" class="headerlink" title="1.1 静态方法"></a>1.1 静态方法</h4><p>在<code>Java</code>中没有<code>全局(global)</code>方法。但有些类中的方法不需要实例变量，为这样的类在堆上建立实例时很浪费的。</p><blockquote><p><code>Math</code>方法是最接近全局的方法。</p></blockquote><p><code>Math</code>类中所有方法都不需要实例变量，这些方法都是<code>静态(static)</code>的。而且无需也无法创建<code>Math</code>实例，只会用到它的类本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = Math.round(<span class="number">42.2</span>);</span><br><span class="line"><span class="keyword">int</span> y = Math.min(<span class="number">56</span>,<span class="number">12</span>);</span><br><span class="line"><span class="keyword">int</span> z = Math.abs(-<span class="number">343</span>);</span><br></pre></td></tr></table></figure><p><code>Java</code>中使用<code>static</code>这一关键词来标记出不需要实例的方法。一个静态方法代表<u><strong>一种不依靠实例变量(对象)的行为</strong></u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">     <span class="comment">//returns the lesser of a and b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以类名调用静态方法，以引用变量名调用非静态方法。</p></blockquote><p>带有静态方法的类通常会被设置为不可初始化。除了把类定义为抽象类之外，也可以<strong>把构造函数标记为私有</strong>防止类被初始化。但带有静态方法的类也可以被初始化(比如带有<code>main()</code>函数的类，<code>main()</code>函数是一个静态方法)</p><blockquote><p>静态方法不能调用非静态的变量。静态方法无法引用到该类的任何实例变量，静态方法也不能调用非静态的方法。</p></blockquote><p>可以用实例变量来调用静态方法，但编译器会解析出原来的类，并不会知道是哪个对象引用调用的该静态方法。</p><h4 id="1-2-静态变量"><a href="#1-2-静态变量" class="headerlink" title="1.2 静态变量"></a>1.2 静态变量</h4><p>静态变量的值对所有实例来说都相同，而且该变量被所有实例共享。比如要计算当前<code>Duck</code>实例的数量，或许可以在构造函数中递增计算器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> duckCount = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         duckCount++;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于<code>duckCount</code>是实例变量，每个<code>Duck</code>对象都会将其初始化为0。而将其设置为静态变量可以实现所需要的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> duckCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         duckCount++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">         size = s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态变量只在类第一次载入时初始化。同一个类所有实例共享一份静态变量。</p></blockquote><p><code>Java</code>虚拟机会加载某个类主要因为第一次被尝试创建该类的实例，或使用该类的静态方法或变量时。静态项目的初始化又两项保证：</p><blockquote><ul><li>静态变量会在该类的任何对象创建前就完成初始化。</li><li>静态变量会在该类的任何静态方法执行前就初始化。</li></ul></blockquote><p>被标记为<code>final</code>的变量代表该变量初始化后就不会改动，是一个常数。而静态的<code>final</code>变量在类加载后就会一致维持原值。</p><blockquote><p><code>静态初始化程序(static initializer)</code>是一段在加载类时会执行的程序代码，会在其他程序可以使用该类前执行，所有适合放置<code>静态final变量</code>在该部分。</p><p>根据<code>命名惯例(naming convention)</code>，常数变量的名称应该都是大写字母！</p></blockquote><p><code>静态final变量</code>可以通过两种方法初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 在声明时初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FOO_X = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在静态初始化程序中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> BAR_SIGN;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">static</span> &#123; <span class="comment">// 这部分代码在类加载时就执行，早于任何方法或静态变量被使用之前</span></span><br><span class="line">         BAR_SIGN = (<span class="keyword">double</span>) Math.random();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若未使用上述方法为<code>静态final变量</code>初始化，编译器会报错。</p><blockquote><p><code>final</code>还可以修饰其他变量，方法甚至类</p><ul><li><code>final</code>变量代表不能改变它的值；</li><li><code>final</code>方法代表不能覆盖该方法；</li><li><code>final</code>类代表不能继承该类；</li></ul></blockquote><h3 id="2-数字"><a href="#2-数字" class="headerlink" title="2. 数字"></a>2. 数字</h3><h4 id="2-1-Math方法"><a href="#2-1-Math方法" class="headerlink" title="2.1 Math方法"></a>2.1 <code>Math</code>方法</h4><p>下面是对<code>Math</code>方法的一些结束：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/mathMethods.PNG" alt="`Math`方法"></p><h4 id="2-2-primitive主数据类型包装"><a href="#2-2-primitive主数据类型包装" class="headerlink" title="2.2 primitive主数据类型包装"></a>2.2 <code>primitive</code>主数据类型包装</h4><p>把<code>primitive</code>主数据类型当作对象来处理，需要一个包装该数据类型的类。每个<code>primitive</code>主数据类型都有一个包装类，存放在<code>java.lang</code>这个包中。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/wrapperClasses.PNG" alt="包装类"></p><p>包装类将<code>primitive</code>主数据类型名称第一个字母大写，以符合命名惯例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包装值</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">288</span>;</span><br><span class="line">Integer iWrap = <span class="keyword">new</span> Integer(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解开包装</span></span><br><span class="line"><span class="keyword">int</span> unWrapped = iWrap.intValue();</span><br></pre></td></tr></table></figure><h4 id="2-3-autoboxing"><a href="#2-3-autoboxing" class="headerlink" title="2.3 autoboxing"></a>2.3 <code>autoboxing</code></h4><p><code>java 5.0</code>以后加入了<code>autoboxing</code>，自动将<code>primitive</code>主数据类型转换成包装过的对象。</p><blockquote><p>但依旧无法直接声明<code>ArrayList&lt;int&gt;</code>，因为<code>generic</code>类型的规则是只能指定类或接口类型，因此<code>ArrayList&lt;int&gt;</code>无法通过编译。但可以把该包装对象的<code>primitive</code>主数据类型直接放入<code>ArrayList</code>中。</p></blockquote><p><code>autoboxing</code>除了在包装或解包<code>primitive</code>主数据类型给<code>collection</code>之外，还可以用到其他地方：</p><ul><li><p>方法的参数</p><p>参数是包装类型，可以传入相应的<code>primitive</code>主数据类型。反之亦然。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">takeNumber</span><span class="params">(Integer i)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>返回值</p><p>如果方法声明为返回某些<code>primitive</code>主数据类型，也可以返回兼容的包装类型。</p></li><li><p><code>boolean</code>表达式</p><p>可以使用<code>Boolean</code>包装类型</p></li><li><p>数值运算</p><p>可以直接对包装类型进行数值运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">42</span>); </span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">5</span>); </span><br><span class="line">Integer k = j + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>赋值</p><p>将包装类型赋值给<code>primitive</code>主数据类型或相反。</p></li></ul><p>包装内也有实用的静态方法，比如字符串和主数据类型的转化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = Integer.parseInt(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">double</span> d = Double.parseDouble(“<span class="number">420.24</span>”);</span><br></pre></td></tr></table></figure><blockquote><p>注意没有<code>Boolean.parseBoolean()</code>方法，但<code>Boolean</code>构造函数可以用<code>String</code>类型创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">42.5</span>;</span><br><span class="line">String doubleString = <span class="string">""</span> + d; <span class="comment">// "+"运算符是Java中唯一重载过的运算符，作为字符串拼接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">42.5</span>;</span><br><span class="line">String doubleString = Double.toString(d);</span><br></pre></td></tr></table></figure><h4 id="2-4-数字格式"><a href="#2-4-数字格式" class="headerlink" title="2.4 数字格式"></a>2.4 数字格式</h4><p>Java中数字与日期的<code>格式化</code>功能没有结合在输入/输出功能上。该功能在<code>java 5.0</code>以后由<code>java.lang</code>中的<code>Formatter</code>类来提供，该类的功能加入到了部分输入/输出类和<code>String</code>中。可以直接调用<strong>静态</strong>的<code>String.format()</code>来实现格式设定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = String.format(<span class="string">"%, d"</span>, <span class="number">1000000000</span>); <span class="comment">// 将数字以带逗号的形式格式化</span></span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p>格式化主要由两个主要部分组成：</p><ol><li><strong>格式指令</strong>。概述要输出的特殊格式。</li><li><strong>要格式化的值</strong>。</li></ol><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/formatString.PNG" alt="格式化"></p><p>格式化说明中，跟在<code>百分号(%)</code>后面包括类型指示(如<code>d</code>或<code>f</code>)的每个东西都是格式化指令，类型指示后的字符被视作直接输出的字符串。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/formatSpecifier.PNG" alt="格式化说明"></p><blockquote><p>类型是唯一的必填项</p><p><code>format()</code>使用<code>可变参数列表(variable argument lists, varargs)</code>来对应有不同数目排列组合的参数。</p></blockquote><h4 id="2-5-日期格式"><a href="#2-5-日期格式" class="headerlink" title="2.5 日期格式"></a>2.5 日期格式</h4><p><code>Date</code>类型是Java上表示时间用的，数值与日期时间格式化的主要差别在于日期格式的类型是用<code>&quot;t&quot;</code>开头的两个字符表示：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dateFormat.PNG" alt="日期格式"></p><p><code>java.util.Date</code>适合用于查看当前日期时间，但许多功能已经停用。更多功能推荐使用API <code>java.util.Calendar</code>。<code>Calendar</code>是一个抽象类，当需要<code>Calendar</code>类型时，需要从<code>JVM</code>获取一个子类实例。需要用到静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br></pre></td></tr></table></figure><p>通过调用<code>getInstance()</code>会返回一个具体子类的实例。一般默认返回<code>java.util.GregorianCalendar</code>的实例。<code>Calendar</code>类的几个关键特性：</p><ul><li>字段会保持状态。比如可以读取或设置<code>year</code>或<code>month</code>字段；</li><li>日期和时间可以运算。</li><li>日期与时间可以用<code>milliseconds</code>表示。即可以将日期转化为微秒，也可以将微秒转换为日期。(相对于<code>1970年1月1日</code>的微秒数)。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/CalendarExample.PNG" alt="Calendar示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;盘算一下。&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--9 构造器与垃圾收集器</title>
    <link href="https://wuyunjie.top/2021/05/13/JavaLearning_Head_First_Java_9_constructors_and_garbage_collection.html"/>
    <id>https://wuyunjie.top/2021/05/13/JavaLearning_Head_First_Java_9_constructors_and_garbage_collection.html</id>
    <published>2021-05-13T14:35:19.000Z</published>
    <updated>2021-05-14T04:53:44.341Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>对象有生死。<br><a id="more"></a></p></blockquote><h3 id="1-栈与堆"><a href="#1-栈与堆" class="headerlink" title="1. 栈与堆"></a>1. 栈与堆</h3><p><code>Java</code>中主要在意两种内存区域：对象的生存空间<code>堆(heap)</code>与方法调用及变量的生存空间<code>栈(stack)</code>。<code>Java</code>虚拟机启动时，会从底层操作系统取得一块内存，用于执行Java程序。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/stackHeap.PNG" alt="栈与堆"></p><p>几乎所有对象都存活于可垃圾回收的堆上，而变量根据它的类型判断存在于那一个内存区域。实例变量存在于堆中，而局部变量(也叫区域变量)存在于栈上，所以也叫栈变量。</p><blockquote><ul><li><code>实例变量</code>被声明在类中方法之外，代表每个独理对象的“字段”，存在于所属对象中。</li><li><code>局部变量</code>和<code>方法</code>被声明在方法中，是<code>暂时</code>的，生命周期只限于方法被放置于栈上这段时间(即方法调用到执行完毕)</li></ul></blockquote><h4 id="1-1-局部变量"><a href="#1-1-局部变量" class="headerlink" title="1.1 局部变量"></a>1.1 局部变量</h4><p>调用一个方法时，该方法会放在调用栈的栈顶。实际上放到栈顶的时<code>栈帧(stack frame)</code>，带有方法的状态，程序计数器及所有的局部变量值。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/twoMthodsStack.PNG" alt="放了两个方法的栈"></p><p>比如<code>foo()</code>调用了<code>bar()</code>，则<code>bar()</code>方法会放置在<code>foo()</code>上面。</p><h4 id="1-2-对象局部变量"><a href="#1-2-对象局部变量" class="headerlink" title="1.2 对象局部变量"></a>1.2 对象局部变量</h4><p>非<code>primitive</code>的变量只是保存对象的引用，对象放于堆上，而局部变量本身放于栈上。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/objectLocalVariable.PNG" alt="对象局部变量"></p><h4 id="1-3-实例变量"><a href="#1-3-实例变量" class="headerlink" title="1.3 实例变量"></a>1.3 实例变量</h4><p>实例变量存在于对象所属的堆空间上。</p><ul><li>如果实例变量全是<code>primitive</code>主数据类型，<code>Java</code>会根据其类型的大小为该实例变量留下空间</li><li>如果实例变量是一个对象，会留下对象引用所用到的空间，而不是对象本身。</li></ul><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><h4 id="2-1-创建对象"><a href="#2-1-创建对象" class="headerlink" title="2.1 创建对象"></a>2.1 创建对象</h4><p>声明对象和赋值的3个步骤：<code>声明引用变量</code>、<code>创建对象</code>、<code>连接对象和引用</code>。第二步<code>创建对象</code>看起来好像在调用类名的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duck myDuck = <span class="keyword">new</span> Duck();</span><br></pre></td></tr></table></figure><p>实际上调用的是<code>Duck</code>的构造函数。</p><blockquote><p>构造函数并不是方法，它带有<code>new</code>的时候会执行的程序代码，在初始化对象时执行。调用构造函数唯一的方法是通过<code>new</code>新建一个类对象。</p></blockquote><p>未写构造函数时，编译器会有一个默认构造函数。下面是一个默认构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>构造函数没有返回类型，名字必须与类名相同。</p></li><li><p>可以有与类同名的方法而不会变成构造函数。</p></li><li>构造函数不会被继承。</li></ul></blockquote><p>构造函数的一个关键特征是，在对象与引用连接前就执行，可以对对象进行预处理。大部分人使用构造函数来初始化对象的状态，也就是给对象的实例变量赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> size;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">(<span class="keyword">int</span> duckSize)</span> </span>&#123; <span class="comment">// 构造函数加上参数</span></span><br><span class="line">     System.out.println(“Quack”);</span><br><span class="line">    size = duckSize;</span><br><span class="line">     System.out.println(“size is “ + size);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseADuck</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Duck d = <span class="keyword">new</span> Duck(<span class="number">42</span>); <span class="comment">// 传值初始化类对象</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最好要有不需要参数的构造函数，来对应参数无法确定的默认情况。</p></blockquote><p>只有在完全没定义构造函数时，编译器才会帮忙编写默认构造函数。如果已经写了一个有参数的构造函数，编译器并不会增加无参数的构造函数，需要<code>手动编写</code>。</p><blockquote><p>构造函数可以是<code>公有</code>、<code>私有</code>或<code>不指定</code>的。</p></blockquote><h4 id="2-2-父类及继承与构造函数的关系"><a href="#2-2-父类及继承与构造函数的关系" class="headerlink" title="2.2 父类及继承与构造函数的关系"></a>2.2 父类及继承与构造函数的关系</h4><p>在创建新对象时，所有继承下来的构造函数都会执行。即每个父类的构造函数都会在子类对象创建时期执行。</p><blockquote><p>抽象类也有构造函数，只是无法对其执行<code>new</code>操作，他的构造函数会在子类创建实例时执行。</p></blockquote><p>如果<code>Hippo</code>对象继承<code>Animal</code>，<code>Animal</code>继承了<code>Object</code>，那么创建对象的过程被称为一个<code>&quot;构造函数链(Constructor Chaining)&quot;</code>。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/ConstructorChaining.PNG" alt="Hippo类构造函数调用"></p><blockquote><p>调用父类构造函数唯一的方法时调用<code>super()</code>。</p></blockquote><p>如果没有显式调用<code>super()</code>，编译器会自动加上<code>super()</code>的调用。且编译器自动加入的一定是<strong>没有参数的构造函数</strong>。</p><blockquote><p><code>super()</code>的调用必须是构造函数的第一个语句</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boop</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>();</span><br><span class="line">     size = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过要求父类的构造函数必须有名字，可以使得子类可以继承父类的<code>get</code>方法来访问私有的实例变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String theName)</span> </span>&#123;</span><br><span class="line">        name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hippo</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hippo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeHippo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hippo h = <span class="keyword">new</span> Hippo(<span class="string">"Buffy"</span>);</span><br><span class="line">        System.out.println(h.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类没有无参构造函数时，子类必须显式调用父类的构造函数，不然编译无法通过。</p><p>也可以在同一个类中调用另外的构造函数。比如多个构造函数有相同的工作部分，可以把这部分代码放在一个构造函数中，然后由其他构造函数调用。</p><blockquote><p>使用<code>this()</code>来从某个构造函数调用同一个类的另外一个构造函数。</p><p><code>this()</code>只能在构造函数中，且也必须时第一行语句。所以<code>super()</code>和<code>this()</code>不能在一个构造函数中同时调用。</p></blockquote><h4 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3 垃圾收集器"></a>3 垃圾收集器</h4><h4 id="3-1-对象的生命周期"><a href="#3-1-对象的生命周期" class="headerlink" title="3.1 对象的生命周期"></a>3.1 对象的生命周期</h4><p>对象的生命周期取决于引用到它的”引用”，引用变量的声明周期又看它是局部变量还是实例变量。</p><blockquote><ul><li>局部变量只会存活在声明该变量的方法中</li><li>实例变量的寿命与对象相同。</li></ul></blockquote><p><strong>“life”与”scope”的差别</strong></p><ul><li><strong>life</strong>。只要变量的堆栈块还存在于堆栈上，局部变量就算存活。</li><li><strong>scope</strong>。局部变量的范围只限于声明它的方法之内。当此方法调用其他方法时，该变量依旧存活，但不在目前执行范围内。</li></ul><p>如果对象的唯一引用解散，那么对象就会从堆中被抛弃，变成可回收的。</p><blockquote><p>若没有引用指向该对象，对象无法被获取，<code>垃圾收集器(GC)</code>会自动回收内存空间。</p></blockquote><p>有三种方法可以释放对象的引用：</p><ol><li><p>引用永久性的离开它的范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Life z = <span class="keyword">new</span> Life();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用被赋值到其他对象上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Life z = <span class="keyword">new</span> Life();</span><br><span class="line">z = <span class="keyword">new</span> Life();</span><br></pre></td></tr></table></figure></li><li><p>直接将引用设定为<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Life z = <span class="keyword">new</span> Life();</span><br><span class="line">z = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对象有生死。&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--8 接口与抽象类</title>
    <link href="https://wuyunjie.top/2021/05/13/JavaLearning_Head_First_Java_8_interfaces_and_abstract_classes.html"/>
    <id>https://wuyunjie.top/2021/05/13/JavaLearning_Head_First_Java_8_interfaces_and_abstract_classes.html</id>
    <published>2021-05-13T09:12:14.000Z</published>
    <updated>2021-05-13T09:12:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>继承只是个开始。<br><a id="more"></a></p></blockquote><h3 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1. 抽象类"></a>1. 抽象类</h3><h4 id="1-1-抽象类"><a href="#1-1-抽象类" class="headerlink" title="1.1 抽象类"></a>1.1 抽象类</h4><p>有些类不应该被初始化。比如如果尝试创建一个<code>Animal</code>对象，很难定义该对象或者说该对象并没有意义(没有一种叫做<code>Animal</code>的动物)。而又需要<code>Animal</code>类来继承和产生多态，需要<strong>限制只有它的子类才能被初始化</strong>。</p><p>通过标记类为<code>抽象类</code>，可以告诉编译器这个类不能创建任何类型实例。记让这个类不能被<code>&quot;nwe&quot;</code>出来。设计抽象类只需要在类前加入关键词<code>abstract</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Canie</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roam</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是可以用这种抽象类作为引用类型给多态使用。不是<code>抽象(abstract)</code>的类就被称为<code>具体(concrete)</code>类</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/abstractConcrete.PNG" alt="抽象与具体"></p><h4 id="1-2-抽象方法"><a href="#1-2-抽象方法" class="headerlink" title="1.2 抽象方法"></a>1.2 抽象方法</h4><p>方法也可以被标及为<code>abstract</code>。抽象类代表此类必须要被<code>extend</code>，抽象方法代表此方法必须要被覆盖。</p><blockquote><p><strong>抽象的方法没有实体</strong></p></blockquote><p>比如一个抽象的方法可以写作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>如果声明了一个抽象方法，那么这个类也必须被标记为抽象类。</p><blockquote><p>即<strong>非抽象类不能拥有抽象方法</strong></p></blockquote><p>抽象方法的意义是<u>就算无法实现出方法的内容，但还是可以定义出一组子类共同的协议</u>。由于抽象方法没有内容，只是为了标记出多态而存在，所以<strong>继承树下的第一个具体类必须要实现出所有的抽象方法</strong>。</p><p>一个抽象类继承另一个抽象类，不需要实现其抽象方法。但抽象类可以同时带有抽象和非抽象方法，所以如果有需要，也可以对抽象方法进行实现。</p><h4 id="1-3-多态范例"><a href="#1-3-多态范例" class="headerlink" title="1.3 多态范例"></a>1.3 多态范例</h4><p>如果要一个可以保持Dog对象的list，可以写一个专用的list类。但如果Cat也要用同样的方法，如果重新编写一个类似的类过于麻烦。可以利用多态的特点，编写一个<code>AnimalList</code>类来处理<code>Animal</code>的所有子类。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/animalList.PNG" alt="Animal List"></p><p>进一步，可以设计处理<code>Animal</code>之上的类，得到更通用、更抽象的类。</p><blockquote><p>Java中所有类都是从<code>Object</code>这个类继承出来的。<code>Object</code>是所有类的源头，即所有类的父类。</p></blockquote><p>没有直接继承过其他类的类会隐含地继承<code>Object</code>类。这样一个终极类(<code>ultra-super-megaclass</code>)需要带有一些每个对象都需要的行为。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/ultra-super-megaclass-Object.PNG" alt="终极类`Object`"></p><p><code>Object</code>不是一个正式的<code>Java</code>抽象类，也就是说可以创建<code>Object</code>对象。</p><blockquote><p><code>Object</code>对象的意义主要在于，有时需要一个<u>通用的、轻量化的</u>对象。比如在线程同步中。</p></blockquote><p><code>Object</code>类的主要目的是：</p><ul><li>作为多态让方法可以应付多种类型的机制；</li><li>提供Java在执行期间对任何对象都需要实现的程序代码。</li></ul><p>而如果使用<code>Object</code>类型的多态引用会带来一些问题：</p><ul><li>以<code>Object</code>类型作为引用时，<code>Java</code>会把它当作<code>Object</code>类型的实例，这代表只能调用由<code>Object</code>声明的方法。</li><li>任何重<code>ArrayList&lt;Object&gt;</code>取出的东西都会被当作<code>Object</code>类型的引用，也就导致无法复制给原来的类型。</li></ul><blockquote><p>编译器是<u>根据引用类型来判断有那些method可以调用，而不是<code>Object</code>的确实类型</u>。</p></blockquote><p>对象会带有从父类继承的所有东西。所以无论这个对象实际类型，它也是一个<code>Object</code>实例。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/snowboardObject.PNG" alt="内部`Object`"></p><p>但也有办法可以让<code>Object</code>引用恢复成原来的类，那就是使用<code>类型转化</code>。如果确定对象类型，可以直接转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog d = (Dog) o;</span><br></pre></td></tr></table></figure><p>如果无法确定类型，可以使用<code>instanceof</code>来检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">Dog d = (Dog) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h3><h4 id="2-1-接口"><a href="#2-1-接口" class="headerlink" title="2.1 接口"></a>2.1 接口</h4><p>如果想要修改<code>合约</code>，比如为Dog类加入Pet的方法，而又不影响其他非Pet类的使用，就需要<code>接口</code>。先看看没有<code>接口</code>会遇到的问题，可以用如下方式加入<code>Pet</code>方法进行修改：</p><ol><li>把<code>Pet</code>方法加入到<code>Animal</code>类中。<ul><li><code>优点</code>：所有子类马上继承<code>Pet</code>方法，无需改变子类程序代码。</li><li><code>缺点</code>：<code>非Pet</code>类也会继承到<code>Pet</code>方法</li></ul></li><li>把<code>Pet</code>方法加入到<code>Animal</code>类中，但把其设定为抽象的。<ul><li><code>优点</code>：<code>非Pet</code>类覆盖方法时，作出合理动作。</li><li><code>缺点</code>：所有子类都需要实现<code>Pet</code>方法，耗时。</li></ul></li><li>把方法添加到需要的子类中。<ul><li><code>优点</code>：<code>非Pet</code>类无需实现，更灵活。</li><li><code>缺点</code>：失去合约保证，且多态无法其作用。</li></ul></li></ol><p>真正需要的是：<code>Pet</code>方法只需要在宠物上实现；所有宠物类都有相同的方法定义；可以运用到多态。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/twoSuperClassesAtTop.PNG" alt="继承多个上次父类"></p><p>图中的<code>多重继承</code>会有被称为<code>”致命方块”（Deadly Diamond of Death）</code>的问题，而且Java也并不支持这种方式。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/DeadlyDiamondofDeath.PNG" alt="”致命方块”（Deadly Diamond of Death）"></p><p>·同名的实例变量和函数会导致冲突，带来更复杂的问题。</p><p>Java里使用<code>接口(interface)</code>来解决这一问题，接口把全部方法设为抽象的，所有子类都需要实现其方法。接口定义如下，使用<code>interface</code>代替<code>class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pet</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>接口实现如下，使用关键字<code>implements</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Canine</span> <span class="keyword">implements</span> <span class="title">Pet</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现某接口的类<code>必须实现它所有的方法</code>，因为这些方法都是<code>public</code>与<code>abstract</code>的。</p></blockquote><p>接口主要为<code>多态</code>服务，以接口取代具体的子类或抽象父类作为参数或返回值，<code>可以传入任何有实现该接口的东西</code>。此外，使用接口可以继承超过一个以上的来源。</p><blockquote><p>不同继承树的类也可以实现相同的接口</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceTreeInterface.PNG" alt="继承树中的接口"></p><p>用接口作为多态类型时，对象可以来自任何地方。唯一的条件是<strong>该对象必须是来自有实现此接口的类</strong>。类可以实现多个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Pet</span>, <span class="title">Saveable</span>, <span class="title">Paintable</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>可以把接口理解为<strong>类可以扮演的角色</strong>。</p><h4 id="2-2-Super的使用"><a href="#2-2-Super的使用" class="headerlink" title="2.2 Super的使用"></a>2.2 <code>Super</code>的使用</h4><p>如果子类不打算完全覆盖某个父类方法，又需要加入额外动作，可以使用<code>super</code>关键词来调用父类方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">runReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// set-up report </span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">printReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// generic printing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuzzwordsReport</span> <span class="keyword">extends</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.runReport();  <span class="comment">//调用父类方法</span></span><br><span class="line">buzzwordCompliance();</span><br><span class="line">printReport();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">buzzwordCompliance</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/superClass.PNG" alt="superClass"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;继承只是个开始。&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--2 Java内存区域与内存溢出异常</title>
    <link href="https://wuyunjie.top/2021/05/12/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_2_Java_memory_area.html"/>
    <id>https://wuyunjie.top/2021/05/12/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_2_Java_memory_area.html</id>
    <published>2021-05-12T15:03:54.000Z</published>
    <updated>2021-05-12T15:03:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code><br><a id="more"></a></p></blockquote><p>在<code>Java</code>虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的<code>delete/free</code>代码，不容易出现内存泄漏和内存溢出问题。</p><p>但也因此，如果不了解虚拟机是怎样使用内存的，一旦出现内存泄漏和溢出方面的问题，那排查错误、修正问题将会成为一项异常艰难的工作。</p><h3 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1 运行时数据区域"></a>1 运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为<strong>若干个不同的数据区域</strong>。这些区域有各自的用途，以及创建和销毁的时间，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/runtimeDataArea.PNG" alt="Java虚拟机运行时数据区"></p><h4 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h4><p><code>程序计数器（Program Counter Register）</code>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。字节码解释器工作时就是通过改变这个计数器的值来<strong>选取下一条需要执行的字节码指令</strong>。</p><blockquote><p>程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p></blockquote><p>Java虚拟机的多线程是通过<strong>线程轮流切换、分配处理器执行时间</strong>的方式来实现的，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</p><blockquote><p>这类内存区域为“线程<code>私有</code>”的内存</p></blockquote><p>如果线程正在执行的是一个<code>Java方法</code>，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<code>本地（Native）方法</code>，这个计数器值则应为空（Undefined）。</p><blockquote><p>此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何<code>OutOfMemoryError情况</code>的区域。</p></blockquote><h4 id="1-2-Java虚拟机栈"><a href="#1-2-Java虚拟机栈" class="headerlink" title="1.2 Java虚拟机栈"></a>1.2 Java虚拟机栈</h4><p><code>Java虚拟机栈（Java Virtual Machine Stack）</code>描述的是<strong>Java<code>方法</code>执行的线程内存模型</strong>：每个<code>方法</code>被执行的时候，Java虚拟机都会同步创建一个<code>栈帧（Stack Frame）</code>用于存储<em>局部变量表、操作数栈、动态连接、方法出口</em>等信息。</p><blockquote><p><code>Java虚拟机栈（Java Virtual Machine Stack）</code>也是线程<code>私有</code>的，它的生命周期与线程相同。</p></blockquote><p>有人把Java内存区域笼统地划分为<code>堆内存（Heap）</code>和<code>栈内存（Stack）</code>。<strong>“栈”通常就是指虚拟机栈</strong>，或者更多的情况下只是指虚拟机栈中<em>局部变量表部分</em>。</p><blockquote><p>局部变量表中的存储空间以<code>局部变量槽（Slot）</code>来表示，其中64位长度的<code>long</code>和<code>double</code>类型的数据会<em>占用两个变量槽</em>，其余的数据类型只占用一个。</p><p><strong>局部变量表所需的内存空间在编译期间完成分配</strong>，一个方法需要在栈帧中分配多大的局部变量空间是<strong>完全确定</strong>的，在方法运行期间不会改变局部变量表的大小(<em>“大小”是指变量槽的数量</em>)</p></blockquote><p>这个内存区域规定了两类异常状况：</p><blockquote><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError异常</code></li><li>如果Java虚拟机栈容量可以<em>动态扩展</em>，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError异常</code></li></ul></blockquote><h4 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h4><p><code>本地方法栈（Native Method Stacks）</code>与虚拟机栈所发挥的作用是非常相似的，其<strong>区别</strong>只是：</p><blockquote><p>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务；</p><p>本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p></blockquote><p>有的Java虚拟机（譬如<code>Hot-Spot虚拟机</code>）直接把<strong>本地方法栈和虚拟机栈合二为一</strong>。</p><blockquote><p>本地方法栈规定了<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p></blockquote><h4 id="1-4-Java堆"><a href="#1-4-Java堆" class="headerlink" title="1.4 Java堆"></a>1.4 Java堆</h4><p><code>Java堆（Java Heap）</code>唯一目的就是<strong>存放对象实例</strong>，Java世界里<em>“几乎”</em>所有的对象实例都在这里分配内存。Java堆是被所有线程<code>共享</code>的一块内存区域，在虚拟机启动时创建，也是虚拟机所管理的内存中<em>最大</em>的一块。</p><blockquote><p>在《Java虚拟机规范》中对Java堆的描述是：<code>“所有的对象实例以及数组都应当在堆上分配”</code></p></blockquote><p>Java堆是<strong>垃圾收集器管理的内存区域</strong>，因此它也被称作<code>“GC堆”（Garbage Collected Heap）</code>。如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个<strong>线程私有</strong>的<code>分配缓冲区 （Thread Local Allocation Buffer，TLAB）</code>。</p><p>Java堆可以处于<code>物理上不连续</code>的内存空间中，但在逻辑上它应该被视为连续的。</p><blockquote><p>如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出<code>OutOfMemoryError异常</code>。</p></blockquote><h4 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h4><p><code>方法区（Method Area）</code>用于存储<strong>已被虚拟机加载</strong>的<em>类型信息、常量、静态变量、即时编译器编译后的代码缓存</em>等数据。与Java堆一样，是各个线程<code>共享</code>的内存区域。</p><blockquote><p>《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作<code>“非堆”（Non-Heap）</code></p></blockquote><p>很多人都更愿意把方法区称为<code>“永久代”（Permanent Generation）</code>，或将两者混为一谈。<strong>本质上这两者并不是等价的</strong>，因为仅仅是<strong>使用永久代来实现方法区</strong>而已。</p><blockquote><ul><li>永久代来实现方法区导致了Java应用更容易遇到<code>内存溢出</code>的问题（永久代有<code>-XX：MaxPermSize</code>的上限，即使不设置也有默认大小)；</li><li>在JDK 6的时候HotSpot开发团队就有<strong>放弃永久代</strong>，逐步改为<strong>采用本地内存（Native Memory）</strong>来实现方法区的计划了；</li><li>JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出；</li><li>而到了JDK 8，终于<strong>完全废弃了永久代的概念</strong>，改用与JRockit、J9一样在本地内存中实现的<code>元空间（Meta-space）</code>来代替。</li></ul></blockquote><p>除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择<strong>不实现垃圾收集</strong>。</p><blockquote><p>这区域的内存回收目标主要是针<strong>对常量池的回收</strong>和<strong>对类型的卸载</strong></p><p>如果方法区无法满足新的内存分配需求时，将抛出 <code>OutOfMemoryError异常</code>。</p></blockquote><h4 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h4><p><code>运行时常量池（Runtime Constant Pool）</code>是<strong>方法区的一部分</strong>。<code>Class文件</code>中有一项信息是<code>常量池表（Constant Pool Table）</code>，用于存放编译期生成的各种<strong>字面量</strong>与<strong>符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><blockquote><p>Class文件中还包括类的<em>版本、字段、方法、接口等描述信息</em></p></blockquote><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，运行期间也可以将新的常量放入池中。</p><blockquote><p>当常量池无法再申请到内存时会抛出<code>OutOfMemoryError异常</code>。</p></blockquote><h4 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7 直接内存"></a>1.7 直接内存</h4><p><code>直接内存（Direct Memory）</code>并不是虚拟机运行时数据区的一部分。</p><blockquote><p>在<code>JDK 1.4</code>中新加入了<code>NIO（New Input/Output）类</code>，引入了一种基于<code>通道（Channel）</code>与<code>缓冲区 （Buffer）</code>的I/O方式，它可以使用<strong><code>Native函数库</code>直接分配堆外内存</strong>，然后通过一个存储在Java堆里面的<code>DirectByteBuffer</code>对象作为<strong>这块内存的引用</strong>进行操作。</p><p>避免了在<code>Java堆</code>和<code>Native堆</code>中来回复制数据。</p></blockquote><p>本机直接内存的分配不会受到Java堆大小的限制，但是肯定还是会受到本机总内存大小以及处理器寻址空间的限制：</p><blockquote><p>动态扩展时可能会出现 <code>OutOfMemoryError异常</code>。</p></blockquote><h3 id="2-HotSpot虚拟机对象探秘"><a href="#2-HotSpot虚拟机对象探秘" class="headerlink" title="2. HotSpot虚拟机对象探秘"></a>2. <code>HotSpot</code>虚拟机对象探秘</h3><h4 id="2-1-对象的创建"><a href="#2-1-对象的创建" class="headerlink" title="2.1 对象的创建"></a>2.1 对象的创建</h4><p>在虚拟机中<code>(普通)对象</code>的创建过程如下：</p><blockquote><ol><li>当Java虚拟机遇到一条<code>字节码new指令</code>时，首先将去检查这个指令的参数是否能在<code>常量池</code>中定位到一个类的<code>符号引用</code>，并且检查这个符号引用代表的类是否已被<strong>加载、解析和初始化</strong>过。如果没有，必须先执行相应的<strong>类加载过程</strong>。</li><li>在类加载检查通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。<em>对象所需内存的大小在类加载完成后便可完全确定</em>，为对象分配空间的任务实际上便等同于把一块<u>确定大小</u>的内存块从<code>Java堆</code>中划分出来。<ul><li><code>“指针碰撞”（Bump The Pointer）</code>。如果Java堆中内存是<strong>绝对规整</strong>的，所有被<u>使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器</u>。那所分配内存就仅仅是把指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</li><li><code>“空闲列表”（Free List）</code>。如果Java堆中的内存是<strong>不规整</strong>的，已被使用的内存和空闲的内存相互交错在一起，<u>虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</u>。</li><li>Java堆是否规整<u>由所采用的垃圾收集器是否带有<code>空间压缩整理（Compact）</code>的能力决定</u>。</li><li>为了保证对象创建过程<code>线程安全</code>，有两种方法：<ul><li>对分配内存空间的动作进行<code>同步处理</code>——实际上虚拟机是采用<code>CAS配上失败重试</code>的方式保证<strong>更新操作的原子性</strong>；</li><li><u>把内存分配的动作按照线程划分在不同的空间之中进行</u>，即每个线程在Java堆中<strong>预先分配一小块内存</strong>，称为<code>本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）</code>。线程要分配内存，就在该线程的本地缓冲区中分配，<u>只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定</u>。</li></ul></li></ul></li><li>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都<strong><code>初始化为零值</code></strong>，如果使用了<code>TLAB</code>，这一项工作也可以提前至<code>TLAB</code>分配时进行。</li><li>Java虚拟机对对象进行<strong>必要的设置</strong>，例如<u>对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的<code>GC</code>分代年龄等</u>信息。这些信息存放在对象的<code>对象头（Object Header）</code>之中。</li></ol></blockquote><p>从<code>虚拟机的视角</code>来看，一个新的对象已经产生了。但是从<code>Java程序的视角</code>看来，对象创建才<u>刚刚开始</u>:</p><blockquote><p><strong>构造函数</strong>，即<code>Class文件</code>中的<code>&lt;init&gt;()</code>方法还没有执行，<u>所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好</u>。</p></blockquote><h4 id="2-2-对象的内存布局"><a href="#2-2-对象的内存布局" class="headerlink" title="2.2 对象的内存布局"></a>2.2 对象的内存布局</h4><p>在<code>HotSpot虚拟机</code>里，对象在堆内存中的存储布局可以划分为三个部分：<code>对象头（Header）</code>、<code>实例数据（Instance Data）</code>和<code>对齐填充（Padding）</code>。</p><h5 id="2-2-1-对象头"><a href="#2-2-1-对象头" class="headerlink" title="2.2.1 对象头"></a>2.2.1 对象头</h5><p>对象头部分包括两类信息：</p><ol><li>第一类是用于存储<strong>对象自身的<code>运行时数据</code></strong>，如<u>哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</u>等。官方称它为<code>“Mark Word”</code>。</li></ol><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/markWord.PNG" alt="HotSpot虚拟机对象头`Mark Word`"></p><blockquote><p><code>Mark Word</code>被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p></blockquote><ol><li>另外一部分是<strong><code>类型指针</code></strong>，即<u>对象指向它的类型元数据的指针</u>，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</li></ol><blockquote><p>此外，如果对象是一个<code>Java数组</code>，那在对象头中还必须有一块用于<u>记录数组长度</u>的数据。</p></blockquote><h5 id="2-2-2-实例数据"><a href="#2-2-2-实例数据" class="headerlink" title="2.2.2 实例数据"></a>2.2.2 实例数据</h5><p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面<u>所定义的各种类型的字段内容</u>。</p><blockquote><p>存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</p><ul><li>HotSpot虚拟机默认的分配顺序为<code>longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs）</code>，相同宽度的字段总是被分配到一起存放</li><li>在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前</li></ul></blockquote><h5 id="2-2-3-对齐填充"><a href="#2-2-3-对齐填充" class="headerlink" title="2.2.3 对齐填充"></a>2.2.3 对齐填充</h5><p>对齐填充<em>不是必然存在</em>的，它仅仅起着<code>占位符</code>的作用。主要由于HotSpot虚拟机的自动内存管理系统要求<u>对象起始地址必须是8字节的整数倍</u>。</p><h4 id="2-3-对象的访问定位"><a href="#2-3-对象的访问定位" class="headerlink" title="2.3 对象的访问定位"></a>2.3 对象的访问定位</h4><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。主流的访问方式主要有<code>使用句柄</code>和<code>直接指针</code>两种：</p><ol><li><code>使用句柄</code>。Java堆中将可能会划分出一块内存来作为<code>句柄池</code>，<code>reference</code>中存储的就是对象的<code>句柄地址</code>，而句柄中包含了<u>对象实例数据与类型数据</u>各自具体的<strong>地址信息</strong>。</li></ol><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/handleAccess.PNG" alt="通过句柄访问对象"></p><blockquote><p>最大好处就是reference中存储的是稳定句柄地址，在对象被移动时<strong>只会改变句柄中的实例数据指针</strong>，而 <code>reference</code>本身不需要被修改。可以理解为只需要移动对象实例数据。</p></blockquote><ol><li><code>直接指针</code>。Java堆中对象的内存布局需要考虑<u>如何放置访问类型数据的相关信息</u>，<code>reference</code>中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li></ol><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/pointerAccess.PNG" alt="通过直接指针访问对象"></p><blockquote><p>最大的好处就是速度更快，它节省了一次指针定位的时间开销。</p></blockquote><h3 id="3-OutOfMemoryError异常处理"><a href="#3-OutOfMemoryError异常处理" class="headerlink" title="3. OutOfMemoryError异常处理"></a>3. <code>OutOfMemoryError</code>异常处理</h3><h4 id="3-1-Java堆溢出"><a href="#3-1-Java堆溢出" class="headerlink" title="3.1 Java堆溢出"></a>3.1 Java堆溢出</h4><p>为了捕捉堆溢出，书中实现了如下异常测试程序：</p><blockquote><p>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证<strong><code>GC Roots</code>到对象之间有可达路径</strong>来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>堆的<code>最小值-Xms</code>参数与<code>最大值-Xmx</code>参数设置为一样即可避免堆自动扩展</li><li>参数<code>-XX：+HeapDumpOnOutOf-MemoryError</code>可以让虚拟机在出现内存溢出异常的时候<strong>Dump出当前的内存堆转储快照</strong>以便进行事后分析</li></ul></blockquote><p>运行结果如下：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/heapOOM.PNG" alt="HeapOOM测试结果"></p><p>要解决这个内存区域的异常，常规的处理方法是首先通过内存映像分析工具对Dump出来的堆转储快照进行分析。</p><blockquote><p>这里使用的是<code>IDEA</code>的插件<code>jprofiler</code>，安装方法参考文章：<a href="https://blog.csdn.net/wytocsdn/article/details/79258247" target="_blank" rel="noopener">Intellij IDEA集成JProfiler性能分析神器</a></p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/heapOOMJprofiler.PNG" alt="HeapOOM Jprofiler结果"></p><p>第一步首先应确认内存中<code>导致OOM的对象是</code>否是必要的，也就是要先分清楚到底是出现了<code>内存泄漏（Memory Leak）</code>还是<code>内存溢出（Memory Overflow）</code>。</p><ul><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到<code>GC Roots</code>的<code>引用链</code></li><li>如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数设置，与机器的内存对比，看看是否还有向上调整的空间。</li></ul><h4 id="3-2-虚拟机栈和本地方法栈溢出"><a href="#3-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="3.2 虚拟机栈和本地方法栈溢出"></a>3.2 虚拟机栈和本地方法栈溢出</h4><p>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，<code>-Xoss参数</code>（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，<strong>栈容量只能由-<code>Xss参数</code>来设定</strong>。</p><p>先将实验范围限制在单线程中操作，尝试下面行为是否能让HotSpot虚拟机产生<code>OutOfMemoryError</code>异常：</p><ol><li>使用<code>-Xss参数</code>减少栈内存容量。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xss128k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaVMStackSOF.PNG" alt="JavaVMStackSOF结果"></p><blockquote><p>栈容量最小值主要取决于操作系统内存分页大小</p></blockquote><ol><li>定义大量的本地变量，增大此方法帧中本地变量表的长度。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> unused1, unused2, unused3, unused4, unused5,</span><br><span class="line">                unused6, unused7, unused8, unused9, unused10,</span><br><span class="line">                unused11, unused12, unused13, unused14, unused15,</span><br><span class="line">                unused16, unused17, unused18, unused19, unused20,</span><br><span class="line">                unused21, unused22, unused23, unused24, unused25,</span><br><span class="line">                unused26, unused27, unused28, unused29, unused30,</span><br><span class="line">                unused31, unused32, unused33, unused34, unused35,</span><br><span class="line">                unused36, unused37, unused38, unused39, unused40,</span><br><span class="line">                unused41, unused42, unused43, unused44, unused45,</span><br><span class="line">                unused46, unused47, unused48, unused49, unused50,</span><br><span class="line">                unused51, unused52, unused53, unused54, unused55,</span><br><span class="line">                unused56, unused57, unused58, unused59, unused60,</span><br><span class="line">                unused61, unused62, unused63, unused64, unused65,</span><br><span class="line">                unused66, unused67, unused68, unused69, unused70,</span><br><span class="line">                unused71, unused72, unused73, unused74, unused75,</span><br><span class="line">                unused76, unused77, unused78, unused79, unused80,</span><br><span class="line">                unused81, unused82, unused83, unused84, unused85,</span><br><span class="line">                unused86, unused87, unused88, unused89, unused90,</span><br><span class="line">                unused91, unused92, unused93, unused94, unused95,</span><br><span class="line">                unused96, unused97, unused98, unused99, unused100;</span><br><span class="line">        stackLength ++;</span><br><span class="line">        test();</span><br><span class="line">        unused1 = unused2 = unused3 = unused4 = unused5 =</span><br><span class="line">        unused6 = unused7 = unused8 = unused9 = unused10 =</span><br><span class="line">        unused11 = unused12 = unused13 = unused14 = unused15 =</span><br><span class="line">        unused16 = unused17 = unused18 = unused19 = unused20 =</span><br><span class="line">        unused21 = unused22 = unused23 = unused24 = unused25 =</span><br><span class="line">        unused26 = unused27 = unused28 = unused29 = unused30 =</span><br><span class="line">        unused31 = unused32 = unused33 = unused34 = unused35 =</span><br><span class="line">        unused36 = unused37 = unused38 = unused39 = unused40 =</span><br><span class="line">        unused41 = unused42 = unused43 = unused44 = unused45 =</span><br><span class="line">        unused46 = unused47 = unused48 = unused49 = unused50 =</span><br><span class="line">        unused51 = unused52 = unused53 = unused54 = unused55 =</span><br><span class="line">        unused56 = unused57 = unused58 = unused59 = unused60 =</span><br><span class="line">        unused61 = unused62 = unused63 = unused64 = unused65 =</span><br><span class="line">        unused66 = unused67 = unused68 = unused69 = unused70 =</span><br><span class="line">        unused71 = unused72 = unused73 = unused74 = unused75 =</span><br><span class="line">        unused76 = unused77 = unused78 = unused79 = unused80 =</span><br><span class="line">        unused81 = unused82 = unused83 = unused84 = unused85 =</span><br><span class="line">        unused86 = unused87 = unused88 = unused89 = unused90 =</span><br><span class="line">        unused91 = unused92 = unused93 = unused94 = unused95 =</span><br><span class="line">        unused96 = unused97 = unused98 = unused99 = unused100 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaVMStackSOF.PNG" alt="JavaVMStackSOF2结果"></p><blockquote><p>出现<code>StackOverflowError</code>异常时，会有明确错误堆栈可供分析，相对而言比较容易定位到问题所在。</p></blockquote><h4 id="3-3-方法区和运行时常量池溢出"><a href="#3-3-方法区和运行时常量池溢出" class="headerlink" title="3.3 方法区和运行时常量池溢出"></a>3.3 方法区和运行时常量池溢出</h4><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p><code>String::intern()</code>是一个本地方法，它的作用是：</p><ul><li>如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；</li><li>否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</li></ul><p>对于<code>JDK 6</code>来运行如下代码，会出现运行时常量池的内存溢出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-XX:PermSize=6M -XX:MaxPermSize=6M</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Set保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在short范围内足以让6MB的PermSize产生OOM了</span></span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有安装<code>JDK 6</code>就没测试了，按书中所述，会出现如下异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">at java.lang.String.intern(Native Method)</span><br><span class="line">at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java: <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p><code>“PermGen space”</code>说明运行时常量池的确是属于方法区的一部分。使用<code>JDK 7</code>或更高版本的<code>JDK</code>并不会得到相同的结果，因为自<code>JDK 7</code>起，原本<u>存放在永久代的字符串常量池被移至Java堆之中</u>，所以在<code>JDK 7</code>及以上版 本，限制方法区的容量对该测试用例来说是毫无意义的。</p><h5 id="字符串常量池的实现方式的影响"><a href="#字符串常量池的实现方式的影响" class="headerlink" title="字符串常量池的实现方式的影响"></a>字符串常量池的实现方式的影响</h5><p>对于字符串常量池的实现引出了对<code>String.intern()</code>这个方法的影响，见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1);</span><br><span class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>在<code>JDK 6</code>中运行，会得到<strong>两个<code>false</code></strong>。在<code>JDK 6</code>中，<code>intern()</code>方法会<strong>把首次遇到的字符串实例复制到永久代的字符串常量池中存储</strong>，返回的也是<u>永久代里面这个字符串实例</u>的引用，而由<code>StringBuilder</code>创建的字符串对象实例<strong>在Java堆</strong>上，所以必然不可能是同一个引用，结果将返回false。</p></li><li><p>在<code>JDK 7</code>中运行，会得到一个<code>true</code>和一个<code>false</code>。<code>JDK 7</code>的<code>intern()</code>方法<strong>不需要再拷贝字符串的实例到永久代</strong>，<u>字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可</u>，因此intern()返回的引用和由<code>StringBuilder</code>创建的那个字符串实例就是同一个。</p><ul><li>对<code>str2</code>比较返回<code>false</code>，这是因为<code>“java”</code>这个字符串在执行<code>StringBuilder.toString()</code>之前就已经出现过了，字符串常量池中已经有它的引用。<code>“java”</code>在加载<code>sun.misc.Version</code>这个类的时候进入常量池</li></ul></li></ul></blockquote><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>方法区的主要职责是用于存放类型的相关信息，如<u>类名、访问修饰符、常量池、字段描述、方法描述</u>等。对于这部分区域的测试，基本的思路是<strong>运行时产生大量的类去填满方法区，直到溢出为止</strong>。作者借助了<code>CGLib</code>直接操作字节码运行时生成了大量的动态类。</p><blockquote><p>类似这样的代码确实可能会<strong>出现在实际应用</strong>中：当前的很多主流框架，如<code>Spring</code>、<code>Hibernate</code>对类进行增强时，都会使用到<code>CGLib</code>这类字节码技术。</p></blockquote><p>一个类如果要被垃圾收集器回收，要达成的条件是<strong>比较苛刻</strong>的。在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。</p><p><code>JDK 8</code>以后，<code>元空间</code>作为<code>永久代</code>替代者登场。<code>HotSpot</code>还是提供了一 些参数作为元空间的防御措施：</p><blockquote><ul><li><code>-XX：MaxMetaspaceSize</code>：设置元空间最大值；</li><li><code>-XX：MetaspaceSize</code>：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整</li><li><code>-XX：MinMetaspaceFreeRatio</code>：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。</li></ul></blockquote><h4 id="3-4-本机直接内存溢出"><a href="#3-4-本机直接内存溢出" class="headerlink" title="3.4 本机直接内存溢出"></a>3.4 本机直接内存溢出</h4><p><code>直接内存（Direct Memory）</code>的容量大小可通过<code>-XX：MaxDirectMemorySize</code>参数来指定，如果不去指定，则默认与<code>Java堆最大值</code>（由<code>-Xmx</code>指定）一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通 过反射获取<code>Unsafe</code>实例进行内存分配，虽然使用<code>DirectByteBuffer</code>分配内存也会抛出<code>内存溢出异常</code>，但它抛出异常时并没有真正向操作系统申请分配内存，而是<u>通过计算得知内存无法分配就会在代码里手动抛出溢出异常</u>，真正申请分配内存的方法是<code>Unsafe::allocateMemory()</code>。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/DirectMemoryOOM.PNG" alt="DirectMemoryOOM结果"></p><p>如果发现内存溢出之后产生的<code>Dump文件</code>很小，而程序中又直接或间接使用了<code>DirectMemory</code>（<strong>典型的间接使用就是<code>NIO</code></strong>），可以考虑重点检查一下直接内存方面的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head First Java]--7 继承与多态</title>
    <link href="https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_7_inheritance_and_polymorphism.html"/>
    <id>https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_7_inheritance_and_polymorphism.html</id>
    <published>2021-05-12T11:38:08.000Z</published>
    <updated>2021-05-12T11:38:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>规划程序时要考虑未来。<br><a id="more"></a></p></blockquote><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h3><h4 id="1-1-继承"><a href="#1-1-继承" class="headerlink" title="1.1 继承"></a>1.1 继承</h4><p>设计<strong>继承</strong>时，会把共同程序代码放在某个类中，告诉其他类此类事他们的父类。当某个类继承另一个类的时候，也就是子类继承自父类。继承的关系意味着子类继承了父类的方法和实例变量。</p><p>如下一个例子</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceExample.PNG" alt="继承"></p><p><code>PantherMan</code>会自动继承<code>SuperHero</code>的实例变量和方法，且<code>PantherMan</code>也可以加入自己的方法和实例变量，或者覆盖掉继承的方法。而<code>FriedEggMan</code>不需要独特的行为，所以没有覆盖任何方法。</p><blockquote><p>实例变量无法覆盖是因为不需要，它们没有定义特殊的行为。</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceExample.PNG" alt="继承范例"></p><p>在这个继承范例中，<code>Family Doctor</code>增加了实例变量和方法，<code>Surgeon</code>覆盖了继承的方法并增加了一个新方法。</p><blockquote><ul><li><p>需要注意继承使用的关键词<code>extends</code></p></li><li><p>如果在子类中还打算引用父类的方法，可以使用<code>super</code>关键字：</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.roam();</span><br><span class="line">     <span class="comment">// my own roam stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-继承层次设计"><a href="#1-2-继承层次设计" class="headerlink" title="1.2 继承层次设计"></a>1.2 继承层次设计</h4><p>比如以设计动物仿真程序为例，主要有以下步骤：</p><ol><li>找出具有共同属性和行为的对象</li><li>设计代表共同状态与行为的类</li><li>决定子类是否需要让某项行为(即方法的实现)有特定不同的运作方式</li><li>通过寻找使用共同行为的子类来找出更多抽象化的机会</li><li>完成类的继承层次</li></ol><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/animalInheritanceTree.PNG" alt="动物类继承层次"></p><blockquote><p>当调用对象引用的方法时，会调用到与该对象类型最接近的方法。即<code>最低阶</code>会胜出。Java虚拟机会从树的叶节点开始往上寻找方法。</p></blockquote><p>所有子类与其任一个上层父类之间应该都是<code>IS-A</code>的关系。</p><h4 id="1-3-存取权限"><a href="#1-3-存取权限" class="headerlink" title="1.3 存取权限"></a>1.3 存取权限</h4><p>父类可以通过存取权限决定子类是否能够继承某些特定的成员。主要有以下4种存取权限，左边最受限制，越往右限制程度越小：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/accessLevels.PNG" alt="存取权限"></p><p><code>存取权限(Access levels)</code>控制谁可以接触什么：</p><blockquote><ul><li><code>public</code>类型的成员会被继承</li><li><code>private</code>类型的成员不会被继承</li></ul></blockquote><h4 id="1-4-继承的意义"><a href="#1-4-继承的意义" class="headerlink" title="1.4 继承的意义"></a>1.4 继承的意义</h4><p>通过继承，子类不需要重新编译就能运行到新版本的父类。此外通过继承可以：</p><ol><li><p>避免重复的程序代码</p><p>即可以在父类这一单一位置定义共同程序代码。</p></li><li><p>定义出共同的协议</p><p>继承可以确保每个父类下的所有类都会有父类所持有的全部(可继承的)方法。也就是说，通过继承来定义相关类之间的共同协议。</p></li></ol><h4 id="1-5-“私有类”"><a href="#1-5-“私有类”" class="headerlink" title="1.5 “私有类”"></a>1.5 “私有类”</h4><p>实际上没有”私有类”的概念，但有三种方法可以防止这个类被继承：</p><ol><li><p>存取控制。不能标记类为私有，但可以不标记为公有。非公有类只能被同一个包的类继承。</p></li><li><p>使用<code>final</code>修饰符。表示它是继承树的末端，不能被继承。</p><blockquote><p><code>final</code>表示符主要为保证安全，确保方法都是当前版本。</p><p>如果想防止特定方法被覆盖，可以在该方法前表示<code>final</code>修饰符。</p></blockquote></li><li><p>让类只拥有<code>private</code>的构造函数。</p></li></ol><h3 id="2-多态"><a href="#2-多态" class="headerlink" title="2. 多态"></a>2. 多态</h3><p>一般声明引用和创建对象时，重点在于要求引用类型与对象类型必须相符。而在多态下，引用与对象可以是不同类型：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphismExample.PNG" alt="多态"></p><p>运用多态时，引用类型可以时实际对象类型的父类。所以可以实现<code>多态数组(polymorphic arrays)</code>这一类东西：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphicArray.PNG" alt="多态数组"></p><p>参数和返回类型也可以用多态。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphicArgument.PNG" alt="参数多态"></p><h3 id="3-覆盖的规则"><a href="#3-覆盖的规则" class="headerlink" title="3. 覆盖的规则"></a>3. 覆盖的规则</h3><p>当要覆盖父类的方法时，必须遵守以下规则：</p><ol><li>参数必须一样，且返回类型必须兼容</li><li><strong>不能降低</strong>方法的存取权限</li></ol><h3 id="4-方法的重载-overload"><a href="#4-方法的重载-overload" class="headerlink" title="4. 方法的重载(overload)"></a>4. 方法的重载(overload)</h3><p>重载的意义是两个方法的名称相同，但参数不同。所以<strong>重载与多态毫无关系</strong>。</p><blockquote><p>重载的方法只是刚好有相同名字的不同方法，它与继承或多态无关</p></blockquote><p>重载的方法有更多的扩展性：</p><ol><li>返回类型可以不同</li><li>不能只改变返回类型。重载的条件是<strong>要使用不同的参数</strong>。</li><li>可以任意设定存取权限</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;规划程序时要考虑未来。&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head First Java]--6 认识Java的API</title>
    <link href="https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_6_Using_the_Java_Library.html"/>
    <id>https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_6_Using_the_Java_Library.html</id>
    <published>2021-05-12T07:33:45.000Z</published>
    <updated>2021-05-12T07:33:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>Java内置有数百个类。<br><a id="more"></a></p></blockquote><h3 id="1-解决上一章程序的bug"><a href="#1-解决上一章程序的bug" class="headerlink" title="1. 解决上一章程序的bug"></a>1. 解决上一章程序的bug</h3><p>上一章的简单版游戏中，一旦猜中了一格，可以持续攻击同一格结束游戏。需要一种机制判别之前是否已经猜中过。</p><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>使用第二个数组，一旦玩家猜中某格，就把对应的格设置为true，之后每次猜中都检查是否已经猜中过。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionOneForDotComBug.PNG" alt="方案一"></p><p>但这种方法过于耗时，每次猜中某一格，都必须检查或改变第二个数组的状态，且需要额外的空间。</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>只动用原来数组，将任何被命中的格子改为<code>-1</code>。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionTwoForDotComBug.PNG" alt="方案二"></p><p>但依旧不是很有效率，已经命中过的格子还是需要再次被搜索。</p><h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p>在命中某个格子后，就把它删掉，格子会越来越少。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionThreeForDotComBug.PNG" alt="方案三"></p><p>但数组大小无法改变，必须创建新数组并进行拷贝。如果有<em>可变数组</em>就可以解决这个问题。</p><h3 id="2-ArrayList类"><a href="#2-ArrayList类" class="headerlink" title="2. ArrayList类"></a>2. <code>ArrayList</code>类</h3><p><code>ArrayList</code>类是Java库函数中的一个类，是一个”边长的数组”。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/someMethodsArrayList.PNG" alt="`ArrayList`类部分方法"></p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/someMethodsArrayList2.PNG" alt="`ArrayList`的操作"></p><p><code>ArrayList</code>与一般数组的区别：</p><blockquote><ul><li>一般数组在创建时必须确定大小，但<code>ArrayList</code>只需要创建出该类型对象就可以。</li><li>存放对象时，一般数组需要指定位置；<code>ArrayList</code>可以使用方法<code>add()</code>。</li><li>一般数组使用<code>[]</code>来存取对象；<code>ArrayList</code>使用<code>get</code>方法。</li><li>在<code>Java 5.0</code>中<code>ArrayList</code>是<strong>参数化的(parameterized)</strong>，即<code>ArrayList&lt;Type&gt;</code>。<code>&lt;Type&gt;</code>是类型参数，代表<code>Type</code>类型的集合。</li></ul></blockquote><h3 id="3-完整版”Sink-a-Dot-Com”"><a href="#3-完整版”Sink-a-Dot-Com”" class="headerlink" title="3. 完整版”Sink a Dot Com”"></a>3. 完整版”Sink a Dot Com”</h3><p>需要对原来的三个类进行修改：</p><blockquote><ul><li><code>DotCom</code>类。原来的<code>SimpleDotCom</code>类。<ul><li>需要增加名称变量来保存<code>DotCom</code>的名字。</li></ul></li><li><code>DotComBust</code>类。原来的<code>SimpleDotComGame</code>类。<ul><li>需要创建多个<code>DotCom</code>对象。</li><li>将<code>DotCom</code>对象放到方阵上。</li><li>每次猜测要检查多个<code>DotCom</code>，所有都击沉后才能结束游戏。</li><li>脱离<code>main()</code>函数。</li></ul></li><li><code>GameHelper</code>类。</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/fullDotComGame.PNG" alt="完整版&quot;Sink a Dot Com&quot;类间关系"></p><h4 id="3-1-DotComBust类"><a href="#3-1-DotComBust类" class="headerlink" title="3.1 DotComBust类"></a>3.1 <code>DotComBust</code>类</h4><h5 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h5><p><code>DotComBust</code>类有3个任务：启动游戏，运行游戏以及结束游戏。可以对运行游戏任务分解，较小的方法更容易测试修改。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dotComBustPrepCode.PNG" alt="DotComBust伪码"></p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dotComBustPrepCodeContinued.PNG" alt="DotComBust伪码（续）"></p><h5 id="真实码"><a href="#真实码" class="headerlink" title="真实码"></a>真实码</h5><p><code>DotComBust</code>类Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotComBust</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GameHelper helper = <span class="keyword">new</span> GameHelper();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;DotCom&gt; dotComList = <span class="keyword">new</span> ArrayList&lt;DotCom&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfGuesses = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建dotCom实例，并加入到dotComList中</span></span><br><span class="line">        DotCom one = <span class="keyword">new</span> DotCom();</span><br><span class="line">        one.setName(<span class="string">"Pets.com"</span>);</span><br><span class="line">        dotComList.add(one);</span><br><span class="line"></span><br><span class="line">        DotCom two = <span class="keyword">new</span> DotCom();</span><br><span class="line">        two.setName(<span class="string">"eToys.com"</span>);</span><br><span class="line">        dotComList.add(two);</span><br><span class="line"></span><br><span class="line">        DotCom three = <span class="keyword">new</span> DotCom();</span><br><span class="line">        three.setName(<span class="string">"Go2.com"</span>);</span><br><span class="line">        dotComList.add(three);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出提示信息</span></span><br><span class="line">        System.out.println(<span class="string">"Your goal is to sink three dot coms."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Pets.com, eToys.com, Go2.com"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Try to sink them all in the fewest number of guesses"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化每个dotCom在棋盘中的位置</span></span><br><span class="line">        <span class="keyword">for</span> (DotCom dotComToSet: dotComList) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; newLocation = helper.placeDotCom(<span class="number">3</span>);</span><br><span class="line">            dotComToSet.setLocationCells(newLocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startPlaying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!dotComList.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取用户的猜测值</span></span><br><span class="line">            String userGuess = helper.getUserInput(<span class="string">"Enter a guess"</span>);</span><br><span class="line">            <span class="comment">// 检查玩家猜测值</span></span><br><span class="line">            checkUserGuess(userGuess);</span><br><span class="line">        &#125;</span><br><span class="line">        finishGame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkUserGuess</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        numOfGuesses++;</span><br><span class="line">        String result = <span class="string">"miss"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (DotCom dotComToSet: dotComList) &#123;</span><br><span class="line">            result = dotComToSet.checkYourself(userGuess);</span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"hit"</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"kill"</span>)) &#123;</span><br><span class="line">                dotComList.remove(dotComToSet);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"All Dot Coms are dead! Your stock is now worthless."</span>);</span><br><span class="line">        <span class="keyword">if</span> (numOfGuesses &lt;= <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"It only took you "</span> + numOfGuesses + <span class="string">" guesses."</span>);</span><br><span class="line">            System.out.println(<span class="string">" You got out before your options sank."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Took you long enough. "</span> + numOfGuesses + <span class="string">" guesses."</span>);</span><br><span class="line">            System.out.println(<span class="string">"Fish are dancing with your options."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotComBust game = <span class="keyword">new</span> DotComBust();</span><br><span class="line">        game.setUpGame();</span><br><span class="line">        game.startPlaying();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-DotCom类"><a href="#3-2-DotCom类" class="headerlink" title="3.2 DotCom类"></a>3.2 <code>DotCom</code>类</h4><p><code>DotCom</code>类Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotCom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; locationCells;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocationCells</span> <span class="params">(ArrayList&lt;String&gt; locations)</span> </span>&#123;</span><br><span class="line">        locationCells = locations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkYourself</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">"miss"</span>; <span class="comment">// 创建保存返回结果的变量, 以miss作为默认值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (locationCells.contains(userGuess)) &#123;</span><br><span class="line">            locationCells.remove(userGuess);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(locationCells.isEmpty()) &#123;</span><br><span class="line">                result = <span class="string">"kill"</span>;</span><br><span class="line">                System.out.println(<span class="string">"Ouch! You sunk "</span> + name + <span class="string">" :("</span>); <span class="comment">// 显式结果</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="string">"hit"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(result); // 显式结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-GameHelper类"><a href="#3-3-GameHelper类" class="headerlink" title="3.3 GameHelper类"></a>3.3 <code>GameHelper</code>类</h4><p><code>GameHelper</code>类除了获取玩家输入外，还增加了设置<code>DotCom</code>的位置这一功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String alphabet = <span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gridLength = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gridSize = <span class="number">49</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] grid = <span class="keyword">new</span> <span class="keyword">int</span>[gridSize];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> comCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInput</span><span class="params">(String prompt)</span> </span>&#123;</span><br><span class="line">        String inputLine = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(prompt + <span class="string">"  "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">            );</span><br><span class="line">            inputLine = is.readLine();</span><br><span class="line">            <span class="keyword">if</span> (inputLine.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inputLine.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">placeDotCom</span><span class="params">(<span class="keyword">int</span> comSize)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; alphaCells = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        String temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 现有字符串</span></span><br><span class="line">        <span class="keyword">int</span> [] coords = <span class="keyword">new</span> <span class="keyword">int</span> [comSize];</span><br><span class="line">        <span class="comment">// 目前测试的字符串</span></span><br><span class="line">        <span class="keyword">int</span> attempts = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到适合的位置吗？</span></span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 目前起点</span></span><br><span class="line">        <span class="keyword">int</span> location = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在处理到第n个dot com</span></span><br><span class="line">        comCount++;</span><br><span class="line">        <span class="comment">// incr是增量, 水平方向增量(+1), 垂直增量(+7, gridLength)</span></span><br><span class="line">        <span class="keyword">int</span> incr = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果是单数号dot com, 垂直增量</span></span><br><span class="line">        <span class="keyword">if</span> ((comCount % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            incr = gridLength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主要搜索循环</span></span><br><span class="line">        <span class="keyword">while</span> (!success &amp; attempts++ &lt; <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 随机起点</span></span><br><span class="line">            location = (<span class="keyword">int</span>) (Math.random() * gridSize);</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 假设是适合的位置</span></span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查找未使用的点</span></span><br><span class="line">            <span class="keyword">while</span> (success &amp;&amp; x &lt; comSize) &#123;</span><br><span class="line">                <span class="comment">// 若未使用</span></span><br><span class="line">                <span class="keyword">if</span> (grid[location] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 存储位置，尝试下一个点</span></span><br><span class="line">                    coords[x++] = location;</span><br><span class="line">                    location += incr;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 超出边缘, 失败, 不是适合的</span></span><br><span class="line">                    <span class="keyword">if</span> (location &gt;= gridSize) &#123;</span><br><span class="line">                        success = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 水平方向超出边缘, 失败</span></span><br><span class="line">                    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; (location % gridLength) == <span class="number">0</span>) &#123;</span><br><span class="line">                        success = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 该位置已经使用过</span></span><br><span class="line">                    success = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将位置转换为字符串</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(x &lt; comSize) &#123;</span><br><span class="line">            <span class="comment">// 标示格子已用</span></span><br><span class="line">            grid[coords[x]] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 行值</span></span><br><span class="line">            row = (<span class="keyword">int</span>) (coords[x] / gridLength);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 列值</span></span><br><span class="line">            column = coords[x] % gridLength;</span><br><span class="line">            temp = String.valueOf(alphabet.charAt(column));</span><br><span class="line"></span><br><span class="line">            alphaCells.add(temp.concat(Integer.toString(row)));</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  alphaCells;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-布尔表达式"><a href="#4-布尔表达式" class="headerlink" title="4. 布尔表达式"></a>4. 布尔表达式</h3><ol><li><p>“与”和“或”运算符(<code>&amp;&amp;</code>, <code>||</code>)</p></li><li><p>“不等于”运算符(<code>!=</code>和<code>!</code>)</p></li><li><p>短运算符(<code>&amp;&amp;</code>, <code>||</code>)</p><blockquote><p>比如<code>&amp;&amp;</code>表达式中，左右两边都为<code>true</code>这个表达式才为<code>true</code>。因此<code>Java</code>虚拟机发现左方表达式为<code>false</code>时不需要也不会计算右边表达式。<code>||</code>类似。基于这样的性质可以避免调用内容为<code>null</code>的引用变量：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (refVar != <span class="keyword">null</span> &amp;&amp; refVar.isValidType() ) &#123;</span><br><span class="line"> <span class="comment">// do ‘got a valid type’ stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>长运算符(<code>&amp;</code>, <code>|</code>)</p><p><code>&amp;</code>和 <code>|</code>运算符通常用于位运算，Java虚拟机会计算运算符两边的算式。</p></li></ol><h3 id="5-使用库函数-Java-API"><a href="#5-使用库函数-Java-API" class="headerlink" title="5. 使用库函数(Java API)"></a>5. 使用库函数(<code>Java API</code>)</h3><h4 id="5-1-库函数的使用"><a href="#5-1-库函数的使用" class="headerlink" title="5.1 库函数的使用"></a>5.1 库函数的使用</h4><p>在<code>Java API</code>中，类是包装在<code>包</code>中的。要使用<code>API</code>中的类，必须直到它在哪个包中。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/apiPakage.PNG" alt="在`Java API`中，类被包装在`包`中"></p><p>必须指明程序代码中所使用到的类的完整名称。(<strong>除了<code>java.lang</code>之外</strong>)</p><blockquote><p>比如<code>ArrayList</code>的完整名称应该是：<code>java.util.ArrayList</code></p></blockquote><p>主要有两种方法可以指定使用的是哪一个<code>ArrayList</code>：</p><ol><li><p><code>Import</code></p><p>在程序源文件最前面放上<code>import</code>述句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;... &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>Type</code></p><p>直接在程序代码中打出全名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line">java.util.ArrayList&lt;Dog&gt; list = <span class="keyword">new</span> java.util.ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用参数</span></span><br><span class="line">java.util.ArrayList&lt;Dog&gt; list = <span class="keyword">new</span> java.util.ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型</span></span><br><span class="line"><span class="keyword">public</span> java.util.<span class="function">ArrayList&lt;Dog&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><code>java.lang</code>是个预先被引用的包，因为<code>java.lang</code>是经常会被用到的基础包，所有可以不必指定名称。比如<code>java.lang.String</code>与<code>java.lang.System</code>都不需要<code>import</code>或写全名。</p></blockquote><h4 id="5-2-关于javax开头的包中x的含义"><a href="#5-2-关于javax开头的包中x的含义" class="headerlink" title="5.2 关于javax开头的包中x的含义"></a>5.2 关于<code>javax</code>开头的包中<code>x</code>的含义</h4><p><code>javax</code>作为开头的包是指标准版的扩展函数库。后来纳入到标准库中后，为了保持程序的兼容性，故而沿用了<code>javax</code>这一命名。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/javaxHistory.PNG" alt="`javax`中`x`的由来"></p><h4 id="5-3-如何查阅API"><a href="#5-3-如何查阅API" class="headerlink" title="5.3 如何查阅API"></a>5.3 如何查阅<code>API</code></h4><p>使用函数库必须知道：</p><ol><li>库中有哪些类</li><li>这些类是做什么的</li></ol><p>主要方法是：</p><ol><li>查阅参考书</li><li>查阅HTML API文档</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Java内置有数百个类。&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head First Java]--5 超强力方法</title>
    <link href="https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_5_Extra-Strength_Methods.html"/>
    <id>https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_5_Extra-Strength_Methods.html</id>
    <published>2021-05-12T04:57:22.000Z</published>
    <updated>2021-05-12T04:57:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>让方法产生更大的作用。创建一个类似战舰的游戏：攻击达康<br><a id="more"></a></p></blockquote><h3 id="1-创建一个类似战舰的游戏：攻击达康"><a href="#1-创建一个类似战舰的游戏：攻击达康" class="headerlink" title="1. 创建一个类似战舰的游戏：攻击达康"></a>1. 创建一个类似战舰的游戏：攻击达康</h3><h4 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1. 简介"></a>1.1. 简介</h4><p>一种棋盘类的战舰游戏，目标是猜测对方战舰的坐标，然后轮流开炮攻击，命中数发可以击沉对方战舰。</p><ul><li><strong>游戏目标</strong>：以最少的猜测次数打掉计算机安排的<code>达康公司(Dot Com)</code>网站。计算机根据表现来评分。</li><li><strong>初始设置</strong>：程序启动后，计算机会在虚拟的<code>7×7</code>方格上安排3个达康网站。然后开始要求猜坐标。</li><li><strong>进行游戏</strong>：目前先在命令栏上进行游戏。计算机根据输入所猜测的位置(比如<code>A3</code>或<code>C5</code>)等，返回命中<code>Hit</code>，未命中<code>Miss</code>或击沉<code>Sunk</code>等回应。清关所有网站后，会列出分数并结束。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/sunk_site.PNG" alt="攻击达康棋盘"></p><h4 id="1-2-顶层设计"><a href="#1-2-顶层设计" class="headerlink" title="1.2 顶层设计"></a>1.2 顶层设计</h4><p>首先，了解游戏流程。基本思路：</p><ol><li>玩家启动游戏</li></ol><blockquote><p>A. 计算机创建3个网站<br>B. 将3个网站停在虚拟战场(棋盘)上</p></blockquote><ol><li>游戏开始</li></ol><blockquote><p>重复以下操作直到所有网站被歼灭<br>A. 提示玩家输入坐标<br>B. 检查是否命中、未命中或击沉。命中删除格子，击沉删除网站。</p></blockquote><ol><li>游戏结束</li></ol><blockquote><p>根据猜测次数给分。</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/flow_of_sunk_dotcom.PNG" alt="游戏流程图"></p><h4 id="1-3-简单的开始"><a href="#1-3-简单的开始" class="headerlink" title="1.3 简单的开始"></a>1.3 简单的开始</h4><p>至少需要两个类：<code>Game</code>类和<code>DotCom</code>类。首先从一个简单版本开始。</p><blockquote><p>只使用一个横列作为棋盘(即一维数组)，并只设定一家达康公司。游戏目标依旧相同。</p></blockquote><p>要注意虚拟的横列是虚幻的，即并没有真正在程序中声明一个一维数组。只需要玩家和计算机直到有3个连续格子会出现在7格的横列中。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simple_sunk_site.PNG" alt="简单版游戏"></p><h3 id="2-开发类"><a href="#2-开发类" class="headerlink" title="2 开发类"></a>2 开发类</h3><p>在创建Java程序时，主要依照以下过程：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/process_of_create_javaapp.PNG" alt="Java程序开发基本流程"></p><blockquote><p>最后一条是认真的吗</p></blockquote><p>我们会为每个类写出：<code>伪码(prep code)</code>、<code>测试码(test code)</code>和<code>真实码(real code)</code></p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/prepTestReal.PNG" alt="`伪码`、`测试码`和`真实码`"></p><blockquote><p><strong>伪码</strong>：帮助我们专注于逻辑而无需考虑程序语法</p><p><strong>测试码</strong>：测试用的程序代码</p><p><strong>真实码</strong>：实际设计出的真正Java程序代码</p></blockquote><h4 id="2-1-SimpleDotCom类"><a href="#2-1-SimpleDotCom类" class="headerlink" title="2.1 SimpleDotCom类"></a>2.1 <code>SimpleDotCom</code>类</h4><h5 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h5><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComPrep.PNG" alt="`SimpleDotCom`类伪码"></p><p>伪码介于Java程序和正常英语之间，大致包括3个部分：实例变量的声明、方法的声明和方法的逻辑。</p><blockquote><p>伪码最重要的部分是<strong>方法的逻辑</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComPrepCode.PNG" alt="`SimpleDotCom`类伪码"></p><h5 id="测试码"><a href="#测试码" class="headerlink" title="测试码"></a>测试码</h5><p>编写方法的实现部分，实现可用的方法程序代码。先编写测试用代码的概念来自于<code>极限编程(Extreme Programming, XP)</code>方法论，可以使我们更快更任意写出程序代码。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/Extreme_Programming.PNG" alt="极限编程"></p><p>首先实现<code>SimpleDotCom</code>类中的方法，先实现<code>checkYourself()</code>这个方法。（至于<code>setLocationCells()</code>这个方法，可以很容易直到它是个<code>setter</code>方法）。首先要知道<code>checkYourself()</code>方法应该要测试的部分：</p><blockquote><ol><li><code>SimpleDotCom</code>对象的初始化；</li><li>赋值位置(即一个<code>int</code>数组)；</li><li>创建代表玩家猜测的字符串；</li><li>传入伪造的玩家猜测来调用<code>checkYourself()</code>方法；</li><li>列出结果观察结果是否正确。</li></ol></blockquote><p><code>SimpleDotCom</code>测试码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotComDrive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleDotCom dot = <span class="keyword">new</span> SimpleDotCom(); <span class="comment">// 初始化SimpleDotCom对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] locations = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// 创建 dot com 位置数组</span></span><br><span class="line">        dot.setLocationCells(locations); <span class="comment">// 调用 dot com 的 setter</span></span><br><span class="line"></span><br><span class="line">        String userGuess = <span class="string">"2"</span>; <span class="comment">// 假的猜测</span></span><br><span class="line">        String result = dot.checkYourself(userGuess); <span class="comment">// 调用被测试的方法, 传入假数据</span></span><br><span class="line">        String testResult = <span class="string">"failed"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.equals(<span class="string">"hit"</span>)) &#123;</span><br><span class="line">            testResult = <span class="string">"passed"</span>; <span class="comment">// 测试返回 "hit" 才算成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.println(testResult); <span class="comment">// 输出测试结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思索与编写测试用的程序代码能够帮助我们了解被测试的应用程序应该要做哪些事情。当实作代码完成时，也可以有准备好地测试代码进行验证。</p><p>理想上，先写出一点测试码，然后编写能够通过该测试的方法。之后再编写测试码，编写新的实现使其通过测试。如此循环，就可以证明新加入代码不会破坏原有已经测试过的部分。</p></blockquote><h5 id="真实码"><a href="#真实码" class="headerlink" title="真实码"></a>真实码</h5><p>从伪码到真正的Java程序代码之间，不会完美对应，需要有一些调整。下面使<code>checkYourself()</code>方法的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotCom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] locationCells;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfHIts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLocationCells</span> <span class="params">(<span class="keyword">int</span>[] locations)</span> </span>&#123;</span><br><span class="line">        locationCells = locations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkYourself</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> guess = Integer.parseInt(userGuess); <span class="comment">// 字符串转int</span></span><br><span class="line">        String result = <span class="string">"miss"</span>; <span class="comment">// 创建保存返回结果的变量, 以miss作为默认值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cell: locationCells) &#123; <span class="comment">// 对每个格子重复执行</span></span><br><span class="line">            <span class="keyword">if</span> (guess == cell) &#123; <span class="comment">// 比较格子与猜测值</span></span><br><span class="line">                result = <span class="string">"hit"</span>; <span class="comment">// 命中</span></span><br><span class="line">                numOfHIts++;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 离开循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numOfHIts == locationCells.length) &#123; <span class="comment">// 判断是否击沉</span></span><br><span class="line">            result = <span class="string">"kill"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result); <span class="comment">// 显式结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-SimpleDotComGame类"><a href="#2-2-SimpleDotComGame类" class="headerlink" title="2.2 SimpleDotComGame类"></a>2.2 <code>SimpleDotComGame</code>类</h4><h5 id="伪码-1"><a href="#伪码-1" class="headerlink" title="伪码"></a>伪码</h5><p><code>SimpleDotComGame</code>类伪码如下：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComGamePrepCode.PNG" alt="`SimpleDotComGame`类伪码"></p><p><code>SimpleDotComGame</code>类需要有以下功能：</p><blockquote><ol><li>创建出<code>SimpleDotCom</code>对象</li><li>初始化赋值该对象</li><li>要求玩家开始猜测</li><li>检查猜测值</li><li>重复猜测直到击沉为止</li><li>显示玩家猜测次数</li></ol></blockquote><h5 id="真实码-1"><a href="#真实码-1" class="headerlink" title="真实码"></a>真实码</h5><p>这里跳过了这个类的测试程序，因为次游戏测试程序只有一个<code>main</code>方法。其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotComGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfGuesses = <span class="number">0</span>; <span class="comment">// 记录玩家猜测次数</span></span><br><span class="line">        GameHelper helper = <span class="keyword">new</span> GameHelper(); <span class="comment">// 使用该类来获取玩家输入</span></span><br><span class="line"></span><br><span class="line">        SimpleDotCom theDotCom = <span class="keyword">new</span> SimpleDotCom();</span><br><span class="line">        <span class="keyword">int</span> randomNum = (<span class="keyword">int</span>) (Math.random() * <span class="number">5</span>); <span class="comment">// 随机数用作第一格的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] locations = &#123;randomNum, randomNum+<span class="number">1</span>, randomNum+<span class="number">2</span>&#125;;</span><br><span class="line">        theDotCom.setLocationCells(locations);</span><br><span class="line">        <span class="keyword">boolean</span> isAlive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(isAlive) &#123;</span><br><span class="line">            String guess = helper.getUserInput(<span class="string">"enter a guess number"</span>);</span><br><span class="line">            String result = theDotCom.checkYourself(guess);</span><br><span class="line">            numOfGuesses++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"kill"</span>)) &#123;</span><br><span class="line">                isAlive = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(<span class="string">"You took "</span> + numOfGuesses + <span class="string">" guesses!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一个带有<code>getUserInput</code>方法的类<code>GameHelper</code>。它可以从命令行获取输入，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInput</span><span class="params">(String prompt)</span> </span>&#123;</span><br><span class="line">        String inputLine = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(prompt + <span class="string">"  "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">            );</span><br><span class="line">            inputLine = is.readLine();</span><br><span class="line">            <span class="keyword">if</span> (inputLine.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inputLine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-要点"><a href="#2-3-要点" class="headerlink" title="2.3 要点"></a>2.3 要点</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/keyPointOfChapter5.PNG" alt="要点"></p><h3 id="3-关于for循环"><a href="#3-关于for循环" class="headerlink" title="3. 关于for循环"></a>3. 关于<code>for</code>循环</h3><h4 id="3-1-基本的for循环"><a href="#3-1-基本的for循环" class="headerlink" title="3.1 基本的for循环"></a>3.1 基本的<code>for</code>循环</h4><p>一个基本的<code>for</code>循环如下：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/regularForLoops.PNG" alt="基本的`for`循环"></p><p>即重复执行代码100次，编译器解释为:</p><blockquote><ol><li>创建变量<code>i</code>并赋值为<code>0</code>；</li><li>只要<code>i</code>小于<code>100</code>就重复执行；</li><li>每次重复过程最后把<code>i</code>加<code>1</code>。</li></ol></blockquote><p>主要分为三个部分：</p><h5 id="第一部分：初始化-initialization"><a href="#第一部分：初始化-initialization" class="headerlink" title="第一部分：初始化(initialization)"></a>第一部分：初始化(initialization)</h5><p>声明和初始化在循环体内的变量，通常将该变量作为<code>计数器</code>。</p><h5 id="第二部分：boolean测试-boolean-test"><a href="#第二部分：boolean测试-boolean-test" class="headerlink" title="第二部分：boolean测试(boolean test)"></a>第二部分：boolean测试(boolean test)</h5><p>测试条件计算出一个<code>boolean</code>值。可以使boolean表达式，或返回boolean值的方法。</p><h5 id="第三部分：重复表达式-iteration-expression"><a href="#第三部分：重复表达式-iteration-expression" class="headerlink" title="第三部分：重复表达式( iteration expression)"></a>第三部分：重复表达式( iteration expression)</h5><p>安置每趟循环完成后要执行的项目。</p><blockquote><p><code>whlie</code>循环与<code>for</code>循环的区别是，<code>while</code>循环只有<code>boolean</code>测试，它并没有内建的初始化或重复表达式。</p><ul><li><code>while</code>适合在不清楚循环次数的循环上；</li><li><code>for</code>相对来说更容易阅读。</li></ul></blockquote><p>此外，这里可以说明一下前置与后置的递增/递减操作符：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/IncrementDecrementOperator.PNG" alt="基本的`for`循环"></p><h4 id="3-2-加强版的for循环"><a href="#3-2-加强版的for循环" class="headerlink" title="3.2 加强版的for循环"></a>3.2 加强版的<code>for</code>循环</h4><p>从<code>Java 5.0</code>开始，有加强版的<code>for</code>循环，可以逐个运行数组或其他集合的元素。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/enhancedforloop.PNG" alt="加强版的`for`循环"></p><p>即对<code>nameArray</code>中每个元素执行一次，编译器解释为:</p><blockquote><ol><li>创建名称为<code>name</code>的<code>String</code>变量；</li><li>将<code>nameArray</code>的第一个元素赋值给<code>name</code>；</li><li>执行重复内容；</li><li>赋值给下一个元素<code>name</code>；</li><li>重复执行直到所有元素都被运行为止。</li></ol></blockquote><p>主要分为两个部分：</p><h5 id="第一部分：声明循环变量-iteration-variable-declaration"><a href="#第一部分：声明循环变量-iteration-variable-declaration" class="headerlink" title="第一部分：声明循环变量(iteration variable declaration)"></a>第一部分：声明循环变量(iteration variable declaration)</h5><p>声明和初始化用在循环体内的变量，循环过程中该变量的值会不断变化。此变量的类型需要与数组元素类型匹配。</p><h5 id="第二部分：要运行的集合-the-actual-collection"><a href="#第二部分：要运行的集合-the-actual-collection" class="headerlink" title="第二部分：要运行的集合(the actual collection)"></a>第二部分：要运行的集合(the actual collection)</h5><p>必须是对数组或其他集合的引用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;让方法产生更大的作用。创建一个类似战舰的游戏：攻击达康&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head First Java]--4 对象的行为</title>
    <link href="https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_4_behavior_of_objects.html"/>
    <id>https://wuyunjie.top/2021/05/12/JavaLearning_Head_First_Java_4_behavior_of_objects.html</id>
    <published>2021-05-12T02:08:12.000Z</published>
    <updated>2021-05-12T02:08:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>状态影响行为，行为影响变量。<br><a id="more"></a></p></blockquote><h3 id="1-对象参数"><a href="#1-对象参数" class="headerlink" title="1. 对象参数"></a>1. 对象参数</h3><h4 id="1-1-对象的状态与行为"><a href="#1-1-对象的状态与行为" class="headerlink" title="1.1. 对象的状态与行为"></a>1.1. 对象的状态与行为</h4><p>类是对象的蓝图。在编写类时，是在描述Java虚拟机应该如何制作该类型的对象。</p><blockquote><p>类所描述的是对象<code>知道什么与执行什么</code></p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/instance_and_method.PNG" alt="实例变量与方法"></p><p>同一个类型的对象能有不同的方法行为。每个实例有相同的方法，但方法可以根据实例变量的值变现不同行为。</p><h4 id="1-2-方法的参数"><a href="#1-2-方法的参数" class="headerlink" title="1.2. 方法的参数"></a>1.2. 方法的参数</h4><p>可以传值给方法。可以使用<code>实参(argument)</code>或<code>形参(parameter)</code>来调用传给方法的参数</p><blockquote><p>方法会运用形参，调用一方会传入实参</p><ul><li>实参是传给方法的值；</li><li>实参传入方法后就成为了形参；</li><li>参数跟局部变量一样。它也有类型和名称，可以在方法内运用</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/argument_and_parameter.PNG" alt="实参与形参"></p><h4 id="1-3-返回值"><a href="#1-3-返回值" class="headerlink" title="1.3. 返回值"></a>1.3. 返回值</h4><p>方法可以有返回值，每个方法都需要声明返回的类型。</p><blockquote><p><code>void</code>表示没有返回任何东西。</p></blockquote><p>比如可以声明一个返回<code>int</code>类型值的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">giveSecret</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果声明了方法有返回值，必须返回声明类型的值！</p><h4 id="1-4-多个参数"><a href="#1-4-多个参数" class="headerlink" title="1.4. 多个参数"></a>1.4. 多个参数</h4><p>方法可以有多个参数，声明和传入时都要以逗号分开。</p><blockquote><p>一定要以正确数量，类型和顺序来传递参数</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/multipe_argument.PNG" alt="多个参数"></p><h4 id="1-5-参数传递"><a href="#1-5-参数传递" class="headerlink" title="1.5. 参数传递"></a>1.5. 参数传递</h4><p>Java通过值传递，或者通过拷贝传递参数。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/argument_pass.PNG" alt="参数传递"></p><blockquote><p><strong>方法无法改变调用方所传入的参数。</strong></p></blockquote><h4 id="1-6-要点"><a href="#1-6-要点" class="headerlink" title="1.6. 要点"></a>1.6. 要点</h4><blockquote><ul><li>如果传入的参数是对象，那么<strong>实际上传入的是远程控制的拷贝</strong>。</li><li>方法只能声明单一返回值。如果需要返回多个返回值，可以使用数组。如需要返回混合不同类型值，可以使用<code>ArrayList</code></li></ul></blockquote><h3 id="2-封装-Encapsulation"><a href="#2-封装-Encapsulation" class="headerlink" title="2. 封装(Encapsulation)"></a>2. 封装(Encapsulation)</h3><p>不封装可能会导致数据泄露。比如直接通过圆点运算符(<code>.</code>)来存取实例变量，可能会出现异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theCat.height = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>需要创建<code>Setter</code>方法，使得在设置变量前可以进行检查。将程序实现从不良数据改成可以保护数据，且还能保持数据可修改，可以使用两个<code>存取修饰符(access modifier)</code>：公有修饰符<code>public</code>和私有修饰符<code>private</code>。封装的基本原则是：</p><blockquote><p>将实例变量标记为私有，提供公有的<code>getter</code>与<code>setter</code>方法来控制存取动作。</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/advantage_of_setter.PNG" alt="封装的好处"></p><h3 id="3-初始化实例变量"><a href="#3-初始化实例变量" class="headerlink" title="3. 初始化实例变量"></a>3. 初始化实例变量</h3><p>声明变量是需要名称和类型，也可以同时初始化变量(为变量赋值)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">256</span>;</span><br></pre></td></tr></table></figure><p>如果未明确初始化实例变量，会为实例变量设置默认值。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/init_variable.PNG" alt="实例变量默认值"></p><blockquote><p>这么看，<code>String</code>变量内存储的也是一个对象引用。</p></blockquote><h3 id="4-实例变量与局部变量"><a href="#4-实例变量与局部变量" class="headerlink" title="4. 实例变量与局部变量"></a>4. 实例变量与局部变量</h3><p>实例变量与局部变量的区别：</p><blockquote><ul><li>实例变量声明在类内而不是方法中；而局部变量声明在方法中</li><li>局部变量使用前必须初始化，即<strong>局部变量没有默认值！</strong>如果在初始化前被调用，编译器会报错。</li></ul></blockquote><p>方法参数基本上与局部变量是相同的。</p><h3 id="5-变量的比较"><a href="#5-变量的比较" class="headerlink" title="5. 变量的比较"></a>5. 变量的比较</h3><h4 id="5-1"><a href="#5-1" class="headerlink" title="5.1 =="></a>5.1 <code>==</code></h4><blockquote><p><code>==</code>用于比较两个变量的字节组合是否相等。</p></blockquote><p>可以使用<code>==</code>来比较两个<code>primitive</code>主数据类型是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123; <span class="comment">// true &#125;</span></span><br></pre></td></tr></table></figure><p>也可以用<code>==</code>来判断两个引用是否指向同一对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Foo a = <span class="keyword">new</span> Foo();</span><br><span class="line">Foo b = <span class="keyword">new</span> Foo();</span><br><span class="line">Foo c = a;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123; <span class="comment">// false &#125;</span></span><br><span class="line"><span class="keyword">if</span> (a == c) &#123; <span class="comment">// true &#125;</span></span><br><span class="line"><span class="keyword">if</span> (b == c) &#123; <span class="comment">// false &#125;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-equals"><a href="#5-2-equals" class="headerlink" title="5.2 equals()"></a>5.2 <code>equals()</code></h4><p>使用<code>equals()</code>方法来判断两个对象是否在含义上相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1,s2,s3 = <span class="string">"abc"</span>, s4 =<span class="string">"abc"</span> ;</span><br><span class="line">s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">s1==s2   是 <span class="keyword">false</span>      <span class="comment">//两个变量的内存地址不一样，也就是说它们指向的对象不一样，</span></span><br><span class="line"></span><br><span class="line">s1.equals(s2) 是 <span class="keyword">true</span>    <span class="comment">//两个变量的所包含的内容是abc，故相等。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;状态影响行为，行为影响变量。&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head First Java]--3 认识变量</title>
    <link href="https://wuyunjie.top/2021/05/11/JavaLearning_Head_First_Java_3_recognize_variables.html"/>
    <id>https://wuyunjie.top/2021/05/11/JavaLearning_Head_First_Java_3_recognize_variables.html</id>
    <published>2021-05-11T13:35:06.000Z</published>
    <updated>2021-05-11T13:35:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>变量有两种：<code>primitive</code>主数据类型和引用。<br><a id="more"></a></p></blockquote><h3 id="1-声明变量"><a href="#1-声明变量" class="headerlink" title="1. 声明变量"></a>1. 声明变量</h3><p><code>Java</code>中必须声明所有变量的类型。主要分为两种变量</p><blockquote><ul><li><code>primitive</code>主数据类型保存基本类型的值，包括<strong>整数、布尔和浮点数等</strong>；</li><li><code>对象引用</code>保存对象的引用</li></ul></blockquote><p>变量必须有<strong>类型</strong>和<strong>名称</strong>。（<strong><code>variables must have a type and a name</code></strong>）</p><h4 id="primitive主数据类型"><a href="#primitive主数据类型" class="headerlink" title="primitive主数据类型"></a><code>primitive</code>主数据类型</h4><p><code>primitive</code>主数据类型有不同大小和名称：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/variable_type_size.PNG" alt="`primitive`主数据类型有不同大小"></p><p>这里展示了<code>primitive</code>主数据类型的名称以及对应的位数：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/primitive_variable_type_size.PNG" alt="`primitive`主数据类型名称以及对应的位数"></p><blockquote><p>这里注意在声明浮点数时，除非加上<code>f</code>，否则所有带小数点的值都会被<code>Java</code>当作<code>double</code>处理。(比如<code>float f = 32.5f</code>)</p></blockquote><p><code>Java</code>编译器不允许将较大的类型值赋给较小类型，比如<code>int</code>类型值无法赋予<code>byte</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">byte</span> b = x;</span><br></pre></td></tr></table></figure><p>即使<code>byte</code>可以装下<code>24</code>，这条语句也不能通过编译。</p><h4 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h4><p>没有对象变量存在，只有<code>引用（reference）</code>到对象的变量。</p><blockquote><p>对象引用变量保存的是<strong>存取对象的方法</strong>；</p></blockquote><p>它不是对象的容器，而是类似于指向对象的指针或者说地址。</p><blockquote><p>但只有<code>Java</code>虚拟机知道如何使用引用来获取对象，我们并不知道引用变量中实际装载的是什么。</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/variable_object_reference.PNG" alt="对象引用"></p><p>对象的声明、创建与赋值有三个步骤：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/create_object.PNG" alt="对象的声明、创建与赋值"></p><blockquote><p><strong>数组也是对象</strong></p></blockquote><p>无论声明来承载<code>primitive</code>主数据类型还是对象引用，数组永远是对象。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/array_is_object.PNG" alt="数组也是对象"></p><h3 id="2-变量命名规范"><a href="#2-变量命名规范" class="headerlink" title="2. 变量命名规范"></a>2. 变量命名规范</h3><p>可以根据一下规则来为类、方法或变量命名：</p><blockquote><ul><li>名称必须以字母、下划线(<code>_</code>)或<code>$</code>符号开头，不能用数字开头；</li><li>除了第一个字符外，后面就可以用数字；</li><li>只要符合上述两条规则，就可以进行任意命名了。但要注意避开Java<code>保留字</code>。</li></ul></blockquote><p>这里的规则是最为基础的规则了，实际上为了命名规范，还有更多更复杂的要求。Java<code>保留字</code>一览表：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/reserved_word.PNG" alt="Java`保留字`一览表"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;变量有两种：&lt;code&gt;primitive&lt;/code&gt;主数据类型和引用。&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[读书|2021阅读]--《围城》</title>
    <link href="https://wuyunjie.top/2021/05/11/Reading_2021--Fortress_Besieged.html"/>
    <id>https://wuyunjie.top/2021/05/11/Reading_2021--Fortress_Besieged.html</id>
    <published>2021-05-11T04:58:19.000Z</published>
    <updated>2021-05-11T04:58:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>这个时间落伍的计时机无意中包涵对人生的讽刺和感伤，深于一切语言、一切啼笑。</code><br><a id="more"></a></p></blockquote><h4 id="《围城》"><a href="#《围城》" class="headerlink" title="《围城》"></a>《围城》</h4><p>早已听闻过《围城》的鼎鼎大名，尤其是那一句<code>&quot;城外的人想冲进去，城里的人想逃出来&quot;</code>听闻依旧，似乎暗含了人生至理，但对其也似懂非懂。这段时间也总算有些许空余时间，把这本讽刺小说给读完了。</p><p>初读第一章头几段就被钱钟书先生的辞藻，比喻给经验到了，有趣而又不失生动。对场景心境的描述都恰到好处，或许要比亲眼看见都更加形象，钟书先生不愧为文学大家，仿佛这些文字都信手拈来一般。这里摘几段对场景的描写：</p><blockquote><p>“红海早过了，船在印度洋面上开驶着，但是太阳依然不饶人地迟落早起，侵占去大部分的夜。夜仿佛纸浸了油，变成半透明体；它给太阳拥抱住了，分不出身来，也许是给太阳陶醉了，所以夕照晚霞隐褪后的夜色也带着酡红。”</p><p>“谁知道从冷盘到咖啡，没有一样东西可口：上来的汤是凉的，冰淇淋倒是热的；鱼像海军陆战队，已登陆了好几天；肉像潜水艇士兵，会长时期伏在水里；除醋以外，面包、牛油、红酒无一不酸。”</p><p>“满天的星又密又忙，它们声息全无，而看来只觉得天上热闹。一梳月亮像形容未长成的女孩子，但见人已不羞缩，光明和轮廓都清新刻露，渐渐可烘衬夜景。小园草地里的小虫琐琐屑屑地在夜谈。不知哪里的蛙群齐心协力地干号，像声浪给火煮得发沸。几只萤火虫游来游去，不像飞行，像在厚密的空气里漂浮，月光不到的阴黑处，一点萤火忽明，像夏夜的一只微绿的小眼睛。”</p></blockquote><p>这样的描述在书中很常见，我这样囫囵吞枣地读完，也不知道是不是能学到几分。除了用词外，钟书先生对人物心境的描写也是活灵活现，很容易引起我的共鸣，尤其是对爱而不得的失恋心态，入夜难眠的困扰，仕途不如意的烦躁……这些心境让人感觉，这好像就是我经历时候的想法，尽管经过百十年的变迁，现在看来这些人之常情的伤心困惑还是如出一辙，或者也可以说历史总是惊人的相似，我们所经历的不过都是历史的重演，并没有什么稀奇事。对自己来说它的确是痛苦万分，感觉难以熬过的坎，确实对每个人来说都是第一次经历。但从全景来看，这也不过是芸芸众生所共通的人生经历，那么平庸平凡，甚至没有一丝波澜。或许人生之事，尤其是感情上的事，无非也就那几分田地，无论多新式的现代自由恋爱观，也逃脱不了冥冥之中的定律。扯远了，来看看钱钟书先生对心理感受的描写吧.</p><p>比如对上台时紧张的心理变化，这不正是上台紧张忘词的状态吗。只能着急，但再着急都记不起自己的稿子。</p><blockquote><p>“拚命追忆，只像把筛子去盛水。一着急，注意力集中不起来，思想的线索要打成结又松散了。隐约还有些事实的影子，但好比在热闹地方等人，瞥眼人堆里像是他，走上去找，又不见了。“</p></blockquote><p>浑浑噩噩的人生状态：</p><blockquote><p>“早晨方醒，听见窗外树上鸟叫，无理由地高兴，无目的地期待，心似乎减轻重量，直升上去。可是这欢喜是空的，像小孩子放的气球，上去不到几尺，便爆裂归于乌有，只留下忽忽若失的无名怅惘。他坐立不安地要活动，却颓唐使不出劲来，好比杨花在春风里飘荡，而身轻无力，终飞不远。”</p></blockquote><p>对失恋后一段时间心态的描写，感觉很相似，真的失去一个人，就是这样感觉世界昏暗，自己也再也融不进去，与一切都格格不入，仿佛置身到了另一个世界。</p><blockquote><p>”方鸿渐把信还给唐小姐时，痴钝并无感觉。过些时，他才像从昏厥里醒过来，开始不住地心痛，就像因蜷曲而麻木的四肢，到伸直了血脉流通，就觉得刺痛。昨天囫囵吞地忍受的整块痛苦，当时没工夫辨别滋味，现在，牛反刍似的，零星断续，细嚼出深深没底的回味。卧室里的沙发书桌，卧室窗外的树木和草地，天天碰见的人，都跟往常一样，丝毫没变，对自己伤心丢脸这种大事全不理会似的。奇怪的是，他同时又觉得天地惨淡，至少自己的天地变了相。他个人的天地忽然从世人公共生活的天地里分出来，宛如与活人幽明隔绝的孤鬼，瞧着阳世的乐事，自己插不进，瞧着阳世的太阳，自己晒不到。人家的天地里，他进不去，而他的天地里，谁都可以进来。“</p></blockquote><p>也曾经有个这样的幻想，钱钟书先生倒是把所有可能，所有境遇都给补全了，这就是失恋人心理还存在着的不甘和侥幸吧：</p><blockquote><p>”每出门，心里总偷偷希望，在路上，在车子里，在电影院门口，会意外碰见唐小姐。碰见了怎样呢？有时理想自己冷淡、骄傲，对她视若无睹，使她受不了。有时理想中的自己是微笑地镇静，挑衅地多礼，对她客气招呼，她倒窘得不知所措。有时他的想像力愈雄厚了，跟一个比唐小姐更美的女人勾手同行，忽与尚无男友的唐小姐劈面相逢；可是，只要唐小姐有伤心绝望的表示，自己立刻甩了那女人来和她言归于好。理想里的唐小姐时而骂自己“残忍”，时而强抑情感，别转了脸，不让睫毛上眼泪给自己看见。“</p></blockquote><p>思恋与错过，爱而不得地无奈与痛苦:</p><blockquote><p>”心里仿佛黑牢里的禁锢者摸索着一根火柴，刚划亮，火柴就熄了，眼前没看清的一片又滑回黑暗里。譬如黑夜里两条船相迎擦过，一个在这条船上，瞥见对面船舱的灯光里正是自己梦寐不忘的脸，没来得及叫唤，彼此早距离远了。这一刹那的接近，反见得暌隔的渺茫。无抵抗、无救援地让痛苦蚕食虫蚀着他的心。“</p><p>”那种情感，追想起来也可怕，把人扰乱得做事吃饭睡觉都没有心思，一刻都不饶人，简直就是神经病，真要不得！不过，生这种病有它的快乐，有时宁可再生一次病。”</p></blockquote><p>或许多年以后回想起曾经，遇见故人，也会被时间冲淡，木然无动于衷。把曾经的感情或立碑志墓，或暴尸荒野。只是不知道这个时间对我来说会是多久。</p><blockquote><p>“等柔嘉睡熟了，他想现在想到重逢唐晓芙的可能性，木然无动于衷，真见了面，准也如此。缘故是一年前爱她的自己早死了，爱她、怕苏文纨、给鲍小姐诱惑这许多自己，一个个全死了。有几个死掉的自己埋葬在记忆里，立碑志墓，偶一凭吊，像对唐晓芙的一番情感。有几个自己，仿佛是路毙的，不去收拾，让它们烂掉化掉，给鸟兽吃掉——不过始终消灭不了，譬如向爱尔兰人买文凭的自己。”</p></blockquote><p>在文末，鸿渐悲伤到绝望麻木，或许也不过如此吧：</p><blockquote><p>鸿渐走出门，神经麻木，不感觉冷，意识里只有左颊在发烫。头脑里，情思弥漫纷乱像个北风飘雪片的天空。他信脚走着，彻夜不睡的路灯把他的影子一盏盏彼此递交。他仿佛另外有一个自己在说：“完了！完了！”散杂的心思立刻一撮似的集中，开始觉得伤心。左颊忽然星星作痛，他一摸湿腻腻的，以为是血，吓得心倒定了，腿里发软。走到灯下，瞧手指上没有痕迹，才知道流了眼泪。</p><p>不知不觉中黑地昏天合拢、裹紧，像灭尽灯火的夜，他睡着了。最初睡得脆薄，饥饿像镊子要镊破他的昏迷，他潜意识挡住它。渐渐这镊子松子、钝了，他的睡也坚实得镊不破了，没有梦，没有感觉，人生最原始的睡，同时也是死的样品。</p></blockquote><p>此外，本以为是书中金句应该出现得比较正式，至少是个什么深沉的感叹，隆重地引出这样的人生哲学。没想到确实一次开玩笑般的谈话里引出了，甚至不是主角所言，鸿渐这时候还在旁边插科打诨呢：</p><blockquote><p>慎明道：“关于Bertie结婚离婚的事，我也和他谈过。他引一句英国古话，说结婚仿佛金漆的鸟笼，笼子外面的鸟想住进去，笼内的鸟想飞出来；所以结而离，离而结，没有了局。”</p><p>苏小姐道：“法国也有这么一句话。不过，不说是鸟笼，说是被围困的城堡fortresse     assiégée，城外的人想冲进去，城里的人想逃出来。鸿渐，是不？”鸿渐摇头表示不知道。</p></blockquote><p>各个角色的形象性格也很鲜明，随着故事情节的发展愈发饱满。比较出乎意料的是赵辛楣，最初出场时与方鸿渐争风吃醋的情敌，或许是网络爽文看多了，把这样一个角色初步定位成了一个小反派，为了苏文纨故意刁难不爱苏文纨的方鸿渐，自以为出尽风头，反而弄巧成拙。看着就好像故意为了衬托方鸿渐而设置的一个悲剧角色。但愈到后面愈发感觉到赵辛楣可能是书中最为直率坦诚的人物了，也是我在里面最喜欢的角色。最初开始发生改观是他作为方鸿渐情敌，与之争论时发表的意见，语出惊人：</p><blockquote><p>“教书是开发民智，板报也是，两者都是精神动员，但论影响，还是教育来的深。”</p></blockquote><p>这么一看突然肃然起敬，没想法这个反派人物还有这样的思想高度，确实比网络爽文里面的无脑反派立体多了。看起来只是个因为爱情的醋意，冲昏头脑的有志青年。后面当他与方鸿渐和解，成为朋友后，大量的笔墨对他进行了进一步的描写。重情重义，为人坦诚，风趣可爱，这时候反过头看他开始的表现，反而感觉合情合理，衬托出他的深情与坦然直率。当然也并不是个完美人物，但这些已然让他散发出独特的人格魅力，不禁想跟他学习一些东西。说起来，书中看见他在喜欢了二十年的苏文纨结婚后，发表了这样一番话：</p><blockquote><p>“我没见过曹元朗，最初以为苏小姐赏识他，一定他比我强；我给人家比下去了，心上很难过。那天看见这样一个怪东西，苏小姐竟会看中他！老实说，眼光如此的女人就不配嫁我赵辛楣，我也不希罕她。”</p></blockquote><p>这时候对他肃然起敬，感觉这个豁达开朗，拿得起放得下。但后面看也不尽然，这里面或许还是有傲娇生气的成分在。后面还是是不是透露出对这份感情的悲伤遗憾，对其的执念，要不然也不会因为汪太太与苏文纨相似而迷了心，这也算是他的一份情深吧。此外，他对朋友的热情体贴，绅士风格也很让人钦佩。比如专门为朋友温牛奶，为鸿渐疏通工作，备厚礼等等，都感觉这是一个值得深交的好友。最后杨绛先生说到这个人物脱胎于一个五六岁男孩，小孩子的直率天真或许是我们逐渐失去，也奋力追求的事物。</p><p>不过除了正文部分，杨绛先生写的后记也生动有趣，感觉丝毫不弱于正文。反而看见她描述的带有“痴气”的钱钟书先生，感觉比正文更加精彩，或许正因为钱钟书先生的”顽皮”，才有了围城里面大量幽默风趣的描述。</p><p>全书围绕围城这一说法，或许婚姻是并不会如想象中那么美好，挤破头想进入婚姻的殿堂，最后反倒是柴米油盐酱醋茶的争吵，感情逐渐消磨，让人想逃离这样的困境。但尽管如此，我反而对这座围城有种更加的期待，那种点点滴滴的美好甜蜜也令人向往，或许我现在还是被美好冲昏了头脑，因为刚刚失去，反而更加憧憬希望，感觉自己可以妥善经营，将矛盾拒之门外。不过也可能是目前的一厢情愿了，真正面对时，可能又是另一番心态了。</p><p>最后全文以老钟的鸣响结束:</p><blockquote><p>那只祖传的老钟从容自在地打起来，仿佛积蓄了半天的时间，等夜深人静，搬出来一一细数：“当、当、当、当、当、当”响了六下。六点钟是五个钟头以前，那时候鸿渐在回家的路上走，蓄心要待柔嘉好，劝她别再为昨天的事弄得夫妇不欢；那时候，柔嘉在家里等鸿渐回来吃晚饭，希望他会跟姑母和好，到她厂里做事。这个时间落伍的计时机无意中包涵对人生的讽刺和感伤，深于一切语言、一切啼笑。</p></blockquote><p>生活就是这般讽刺，巧合。但一切却又只能随着老钟的鸣响，滴答滴答的往前行进，无论多么不舍不甘，多么令人啼笑皆非的错过误会，最终都会化为人生长河里的尘土，消散在过去，带不往未来。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/Fortress_Besieged.jpg" alt="围城"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;这个时间落伍的计时机无意中包涵对人生的讽刺和感伤，深于一切语言、一切啼笑。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Reading" scheme="https://wuyunjie.top/categories/Reading/"/>
    
    
      <category term="Reading" scheme="https://wuyunjie.top/tags/Reading/"/>
    
      <category term="Book" scheme="https://wuyunjie.top/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head First Java]--2 类与对象</title>
    <link href="https://wuyunjie.top/2021/04/27/JavaLearning_Head_First_Java_2_class_and_objects.html"/>
    <id>https://wuyunjie.top/2021/04/27/JavaLearning_Head_First_Java_2_class_and_objects.html</id>
    <published>2021-04-27T15:05:45.000Z</published>
    <updated>2021-04-27T15:05:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>有人告诉我那里遍地都是对象！<br><a id="more"></a></p></blockquote><h3 id="1-椅子大战——阿花的”对象”"><a href="#1-椅子大战——阿花的”对象”" class="headerlink" title="1. 椅子大战——阿花的”对象”"></a>1. 椅子大战——阿花的”对象”</h3><p>面向对象信徒阿花利用面向对象的思想赢得了椅子大战(但最后赢家是阿娇——老板娘的侄女，作者调皮了)。</p><h4 id="类与继承-inheritance"><a href="#类与继承-inheritance" class="headerlink" title="类与继承(inheritance)"></a>类与继承(inheritance)</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_inheritance.PNG" alt="继承(inheritance)"></p><h4 id="覆盖-override"><a href="#覆盖-override" class="headerlink" title="覆盖(override)"></a>覆盖(override)</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_override.PNG" alt="覆盖(override)"></p><h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h3><blockquote><p> <code>对象</code>是依靠类的模型塑造出来的，对象也可以叫做<code>实例</code>。可以把对象分为两部分看：</p><ul><li>对象是已知的事物<ul><li><code>实例变量</code>(instance variable)。对象本身已知的事物，代表对象的状态(数据)，且该类型的每一个对象都会独立地拥有一份该类型的值。</li></ul></li><li>对象会执行的当作<ul><li><code>方法</code>(methods)。对象可以执行的动作，读取或操作实例变量。</li></ul></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_override.PNG" alt="Java对象"></p><h4 id="类与对象的区别"><a href="#类与对象的区别" class="headerlink" title="类与对象的区别"></a>类与对象的区别</h4><blockquote><p>”<em>类不是对象，却是用来创建对象的模型</em>‘“。类是对象的<strong>蓝图</strong>，告诉虚拟机如何创建某种类型的对象。</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_object_relation.PNG" alt="类与对象"></p><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>创建对象后，使用<code>圆点(.)</code>符号所代表的操作数来<em>存取该对象的变量和方法</em>。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_create_object.PNG" alt="创建对象"></p><h4 id="逃出main"><a href="#逃出main" class="headerlink" title="逃出main()"></a>逃出main()</h4><blockquote><p><code>main()</code>的两种用途</p><ul><li>测试真正的类</li><li>启动JAVA应用程序</li></ul></blockquote><p>Java程序普遍只会让对象与对象交互，即相互调研方法。猜数字游戏示例：</p><blockquote><p><strong>摘要：</strong></p><p>涉及到<code>game</code>和<code>player</code>两个对象，<code>game</code>会产生介于0~9之间的随机数，3个<code>player</code>对象会猜测该数字。</p><p><strong>类：</strong></p><ul><li>GuessGame.class</li><li>Player.class</li><li>GameLauncher.class</li></ul><p><strong>程序逻辑：</strong></p><ol><li><code>GameLauncher</code>类带有<code>main()</code>方法，是应用程序<strong>入口点</strong>；</li><li><code>main()</code>中会创建<code>GuessGame</code>对象，并调用它的<code>startGame()</code>方法；</li><li><code>startGame()</code>方法是游戏的起点。它会创建3个player，然后挑出要猜测的随机数字。它会要求player猜测并检查结果，列出过程。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.schoolLearning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        number = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"I'm guessing "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    Player p1;</span><br><span class="line">    Player p2;</span><br><span class="line">    Player p3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        p1 = <span class="keyword">new</span> Player();</span><br><span class="line">        p2 = <span class="keyword">new</span> Player();</span><br><span class="line">        p3 = <span class="keyword">new</span> Player();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> guessp1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> guessp2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> guessp3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> p1isRight = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> p2isRight = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> p3isRight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetNumber = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"I'm thinking of a number between 0 and 9..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Number to guess is "</span> + targetNumber);</span><br><span class="line"></span><br><span class="line">            p1.guess();</span><br><span class="line">            p2.guess();</span><br><span class="line">            p3.guess();</span><br><span class="line"></span><br><span class="line">            guessp1 = p1.number;</span><br><span class="line">            System.out.println(<span class="string">"Player one guessed "</span> + guessp1);</span><br><span class="line">            guessp2 = p2.number;</span><br><span class="line">            System.out.println(<span class="string">"Player two guessed "</span> + guessp2);</span><br><span class="line">            guessp3 = p3.number;</span><br><span class="line">            System.out.println(<span class="string">"Player three guessed "</span> + guessp3);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (guessp1 == targetNumber) &#123;</span><br><span class="line">                p1isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp2 == targetNumber) &#123;</span><br><span class="line">                p2isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp3 == targetNumber) &#123;</span><br><span class="line">                p3isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p1isRight || p2isRight || p3isRight) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"We have a winner!"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Player one got it right? "</span> + p1isRight);</span><br><span class="line">                System.out.println(<span class="string">"Player two got it right? "</span> + p2isRight);</span><br><span class="line">                System.out.println(<span class="string">"Player three got it right? "</span> + p3isRight);</span><br><span class="line">                System.out.println(<span class="string">"Game is over."</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Players will have to try again."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameLauncher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GuessGame game = <span class="keyword">new</span> GuessGame();</span><br><span class="line">        game.startGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol><li><p>在创建类时，<code>.java</code>文件内只能有一个<code>public</code>声明的类，且类名需要与文件名一致，一般设定为包含<code>main()</code>函数的类。更规范的写法是为不同的类分别创建<code>.java</code>文件，维护各自的代码，通过文件之间的调用(<code>import</code>)实现交互。</p></li><li><p>Java垃圾回收。</p><p>创建对象时，不管对象如何创建的，它都会被存放于称为<code>堆</code>的内存区域，在Java中是<code>可回收垃圾的堆(Garbage-Collectible Heap)</code>。Java会根据对象的大小来分配内存空间，当Java虚拟机察觉到对象不再会被使用到时，该对象会被标记为可回收的。如果内存不足，垃圾收集器就会启动来清理垃圾、回收空间。</p></li><li><p>包装多个类成为单一应用程序形式。</p><p>可以把所有文件包装进依据<code>pkzip</code>格式来存档的<code>Java Archive-.jar文件</code>。在该<code>jar</code>文件中可以引入一个简单文字格式的文字文件，被称为<code>manifest</code>，里面有定义出<code>jar</code>中的哪一个文件带有启动应用程序的<code>main()</code>方法。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;有人告诉我那里遍地都是对象！&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-4-重建二叉树</title>
    <link href="https://wuyunjie.top/2021/04/26/JZ4-rebuild-binaryTree.html"/>
    <id>https://wuyunjie.top/2021/04/26/JZ4-rebuild-binaryTree.html</id>
    <published>2021-04-26T14:54:52.000Z</published>
    <updated>2021-04-26T14:54:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><a id="more"></a></p><p><strong>示例:</strong></p><blockquote><p>输入:   [1,2,3,4,5,6,7],[3,2,4,1,6,5,7]<br>返回值: {1,2,5,3,4,6,7}</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>考察二叉树很经典的题，需要理解前序遍历、中序遍历的方法，然后据此重建二叉树。</p><h4 id="二叉树的遍历方法"><a href="#二叉树的遍历方法" class="headerlink" title="二叉树的遍历方法"></a>二叉树的遍历方法</h4><blockquote><ol><li>前序遍历：根左右</li><li>中序遍历：左根右</li><li>后序遍历：左右根</li></ol></blockquote><p>一般使用递归方法实现遍历，在遍历过程中每个子树都可当作一颗新树递归处理。此外也可以利用栈实现非递归的遍历方法。</p><h4 id="方法1-递归方法"><a href="#方法1-递归方法" class="headerlink" title="方法1: 递归方法"></a>方法1: 递归方法</h4><p>对于任意一棵树，前序遍历的形式总是：</p><blockquote><p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</p></blockquote><p>中序遍历的形式总是：</p><blockquote><p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p></blockquote><p>所以在中序遍历中定位到根节点，就可以得到左子树和右子树的节点及节点数目。由此可以进一步在前序遍历结果中，分别得到左右子树。依次类推可以递归构造出子树的左右子树，知道最终左右子树都只剩一个节点，得到一颗完整的树。</p><blockquote><ol><li><p>在中序遍历中对根节点进行定位时，一种简单的方法是<strong>直接扫描整个中序遍历的结果并找出根节点</strong>，但这样做的时间复杂度较高。</p></li><li><p>考虑使用<code>哈希表</code>来快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，对中序遍历列表进行一遍扫描，构造出这个哈希映射。在此后构造二叉树的过程中，只需要 <code>O(1)</code> 的时间对根节点进行定位。</p></li></ol></blockquote><h4 id="方法2-非递归-迭代-方法"><a href="#方法2-非递归-迭代-方法" class="headerlink" title="方法2: 非递归(迭代)方法"></a>方法2: 非递归(迭代)方法</h4><p>根据前序遍历原理，对于前序遍历中的任意两个连续节点 <em>u</em> 和 <em>v</em>，只有两种可能的关系：</p><blockquote><ul><li><em>v</em> 是 <em>u</em> 的左儿子。因为在遍历到 <em>u</em> 之后，下一个遍历的节点就是 <em>u</em> 的左儿子，即 <em>v</em>；</li><li><em>u</em> 没有左儿子，并且 <em>v</em> 是 <em>u</em> 的某个祖先节点（或者 <em>u</em> 本身）的右儿子。<ul><li>如果 <em>u</em> 没有左儿子，那么下一个遍历的节点就是 <em>u</em> 的右儿子。</li><li>如果 <em>u</em> 没有右儿子，就会向上回溯，直到遇到第一个有右儿子（且 <em>u</em> 不在它的右儿子的子树中）的节点 <em>a</em>，那么 <em>v</em> 就是 <em>a</em> 的右儿子。</li></ul></li></ul></blockquote><p>用一个<code>栈 stack</code> 来维护<code>「当前节点的所有还没有考虑过右儿子的祖先节点」</code>，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，用一个<code>指针 index</code> 指向<strong>中序遍历</strong>的某个位置，初始值为 <code>0</code>。<code>index</code> 对应的节点是<code>「当前节点不断往左走达到的最终节点」</code>，这也是符合中序遍历。算法流程如下：</p><blockquote><ol><li><p>用一个<code>栈</code>和一个<code>指针</code>辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p></li><li><p>依次枚举前序遍历中除了第一个节点以外的每个节点。</p><ul><li>如果 <code>index</code> 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 <code>index</code>，并将当前节点作为最后一个弹出的节点的右儿子；</li><li>如果 <code>index</code> 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</li></ul></li><li>无论是哪一种情况，最后都将当前的节点入栈。</li></ol></blockquote><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol><li><p>解法1  递归方法(<strong>直接扫描</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> [] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startPre &gt; endPre) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == pre[startPre])&#123;</span><br><span class="line">                root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + i - startIn, in, startIn, startIn + i - <span class="number">1</span>);</span><br><span class="line">                root.right = reConstructBinaryTree(pre, startPre + i - startIn + <span class="number">1</span>, endPre, in, i + <span class="number">1</span>, endIn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法1  递归方法(<strong>哈希表</strong>)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            indexMap.put(in[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> [] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startPre &gt; endPre) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> inRoot = indexMap.get(pre[startPre]);</span><br><span class="line">        root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + inRoot - startIn, in, startIn, startIn + inRoot - <span class="number">1</span>);</span><br><span class="line">        root.right = reConstructBinaryTree(pre, startPre + inRoot - startIn + <span class="number">1</span>, endPre, in, inRoot + <span class="number">1</span>, endIn);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>解法2 迭代法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span> || pre.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> preVal = pre[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="comment">// 左子树</span></span><br><span class="line">            <span class="keyword">if</span> (node.val != in[inIndex]) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(preVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右子树</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == in[inIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(preVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol><li><p>思考：如果给你中序遍历序列和后序遍历序列<br>思路类似于中序遍历和前序遍历的情况，只是在从后续遍历找根节点时，从后序遍历数组末端元素开始。后序遍历的形式总是：</p><blockquote><p>[  [左子树的前序遍历结果], [右子树的前序遍历结果] ,根节点]</p></blockquote><p>伪代码表示为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设元素在数组v中，并且尾结点的下标为 root_index, first &lt; root_index &lt; last,</span></span><br><span class="line">TreeNode* build(<span class="keyword">int</span> first, <span class="keyword">int</span> last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt; last) <span class="keyword">return</span> nullptr;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(v[root_index]);</span><br><span class="line">    root-&gt;left = build(first, root_index - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = build(root_index + <span class="number">1</span>, last);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，这里中序遍历起到很重要的作用，基于中序遍历可以分隔开左右子树。而仅仅给定前序遍历和后序遍历时，是无法得到唯一子树的。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">树1：</span><br><span class="line">        3</span><br><span class="line">       /</span><br><span class="line">      9</span><br><span class="line">     /</span><br><span class="line">    8</span><br><span class="line">   / </span><br><span class="line">  5</span><br><span class="line"> /</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">树2：</span><br><span class="line">        3</span><br><span class="line">         \</span><br><span class="line">          9</span><br><span class="line">           \</span><br><span class="line">            8</span><br><span class="line">             \</span><br><span class="line">              5</span><br><span class="line">               \</span><br><span class="line">                4</span><br></pre></td></tr></table></figure><p>以上这两棵特殊的树，其前序遍历，后续遍历结果都是：[3, 9, 8, 5, 4]，[4, 5, 8, 9, 3]。难以构造出唯一的树。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">力扣官方题解——重建二叉树</a></p></blockquote></li></ol><p>[2] <a href="https://blog.nowcoder.net/n/c56eeb5b1845432a903db1c3c0cbc80a" target="_blank" rel="noopener">[编程题]重建二叉树</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--1 走近Java</title>
    <link href="https://wuyunjie.top/2021/04/23/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_1_Approaching_Java.html"/>
    <id>https://wuyunjie.top/2021/04/23/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_1_Approaching_Java.html</id>
    <published>2021-04-23T08:37:49.000Z</published>
    <updated>2021-04-23T08:37:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。</code><br><a id="more"></a></p></blockquote><h4 id="1-Java技术体系"><a href="#1-Java技术体系" class="headerlink" title="1. Java技术体系"></a>1. Java技术体系</h4><p><code>JCP(Java Community Process)</code>所定义的Java技术体系包括了以下几个组成部分：</p><ul><li>Java程序设计语言</li><li>各种硬件平台上的Java虚拟机实现</li><li>Class文件格式</li><li>Java类库API</li><li>来自商业机构和开源社区的第三方Java类库</li></ul><p><code>JDK(Java Development Kit)</code>是用于支持Java程序开发的最小环境，主要分为三部分：</p><ul><li>Java程序设计语言</li><li>Java虚拟机</li><li>Java类库</li></ul><p><code>JRE(Java Runtime Environment)</code>是支持Java程序运行的标准环境，主要包括：</p><ul><li>Java SE API子集</li><li>Java虚拟机</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Java_technology_system.PNG" alt="Java技术体系"></p><p>按照技术关注的重点业务来划分，可以分为以下四条主要的产品线：</p><ul><li><strong>Java Card</strong>：支持Java小程序（Applets）运行在<strong><code>小内存设备（如智能卡）</code></strong>上的平台。</li><li><strong>Java ME（Micro Edition）</strong>：支持Java程序运行在<strong><code>移动终端（手机、PDA）</code></strong>上的平台，对Java API 有所精简，并加入了移动终端的针对性支持，这条产品线在JDK 6以前被称为<code>J2ME</code>。</li><li><strong>Java SE（Standard Edition）</strong>：支持面向<strong><code>桌面级应用（如Windows下的应用程序）</code></strong>的Java平台，提 供了完整的Java核心API，这条产品线在JDK 6以前被称为<code>J2SE</code>。</li><li><strong>Java EE（Enterprise Edition）</strong>：支持<strong><code>使用多层架构的企业应用（如ERP、MIS、CRM应用）</code></strong>的 Java平台，除了提供Java SE API外，还对其做了大量有针对性的扩充，并提供了相关的部署支持， 这条产品线在JDK 6以前被称为<code>J2EE</code>；在JDK 10以后被Oracle放弃，捐献给Eclipse基金会管理，此后被 称为<code>Jakarta EE</code>。(PS:扩展一般以<code>javax.*</code>作为包名，而以<code>java.*</code>为包名的包都是Java SE API的核心包。一部分曾经是扩展包的API后来进入了核心包中，因此核心包中也包含了不少<code>javax.*</code>开头的包名)</li></ul><h4 id="2-Java虚拟机家族"><a href="#2-Java虚拟机家族" class="headerlink" title="2. Java虚拟机家族"></a>2. Java虚拟机家族</h4><h5 id="2-1-虚拟机始祖：Sun-Classic-Exact-VM"><a href="#2-1-虚拟机始祖：Sun-Classic-Exact-VM" class="headerlink" title="2.1 虚拟机始祖：Sun Classic/Exact VM"></a>2.1 虚拟机始祖：Sun Classic/Exact VM</h5><p><code>Classic VM</code>只能使用<strong>纯解释器方式</strong>来执行Java代码，如果要使用<strong>即时编译器</strong>就必须进行外挂，但是假如外挂了即时编译器的话，即时编译器就会完全接管虚拟机的执行系统，解释器便不能再工作了。由于解释器和编译器不能配合工作，这就意味着<code>如果要使用编译执行，编译器就不得不对每一个方法、每一行代码都进行编译，而无论它们执行的频率是否具有编译的价值</code>。</p><p><code>Exact VM</code>因它使用<code>准确式内存管理</code>（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management）而得名。准确式内存管理是指<code>虚拟机可以知道内存中某个位置的数据具体是什么类型</code>。已经具备现代高性能虚拟机雏形，如热点探测、两级即时编译器、编译器与解释器混合工作模式等。</p><h5 id="2-2-武林盟主：HotSpot-VM"><a href="#2-2-武林盟主：HotSpot-VM" class="headerlink" title="2.2 武林盟主：HotSpot VM"></a>2.2 武林盟主：HotSpot VM</h5><p><code>HotSpot VM</code>是Sun/OracleJDK和OpenJDK中的默认Java虚拟机，也是目前<em>使用范围最广</em>的Java虚拟机。</p><blockquote><p>它是由一家名为<code>“Longview Technologies”</code>的小公司设计；甚至这个虚拟机最初<em>并非是为Java语言而研发的</em>，它来源于<code>Strongtalk虚拟机</code>，而这款虚拟机中相当多的技术又是来源于一款为<em>支持Self语言</em>实现“达到C语言50%以上的执行效率”的目标而设计的Self虚拟机， 最终甚至可以追溯到20世纪80年代中期开发的<code>Berkeley Smalltalk</code>上。</p></blockquote><p>它名称中的HotSpot指的就是它的<code>热点代码探测技术</code>。</p><blockquote><p>HotSpot虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器<strong>以方法为单位进行编译</strong>。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发<code>标准即时编译和栈上替换编译（On-Stack Replacement，OSR）行为</code>。</p></blockquote><h5 id="2-3-小家碧玉：Mobile-Embedded-VM"><a href="#2-3-小家碧玉：Mobile-Embedded-VM" class="headerlink" title="2.3 小家碧玉：Mobile/Embedded VM"></a>2.3 小家碧玉：Mobile/Embedded VM</h5><p>面对移动和嵌入式市场，在Java ME这条产品线上的虚拟机名为CDC-HI（C Virtual Machine， CVM）和CLDC-HI（Monty VM）。</p><blockquote><p>CDC/CLDC全称是<code>Connected（Limited）Device Configuration</code>，HI则是<code>HotSpot Implementation</code>的缩写，但它们并不是由HotSpot直接裁剪而来，只是借鉴过其中一些技术，并没有血缘关系，充其量能叫有所渊源。</p></blockquote><h5 id="2-4-天下第二：BEA-JRockit-IBM-J9-VM"><a href="#2-4-天下第二：BEA-JRockit-IBM-J9-VM" class="headerlink" title="2.4 天下第二：BEA JRockit/IBM J9 VM"></a>2.4 天下第二：BEA JRockit/IBM J9 VM</h5><p>BEA System公司的<code>JRockit</code>与 IBM公司的<code>IBM J9</code>曾经与HotSpot并称<strong>“三大商业Java虚拟机”</strong>。</p><p>JRockit虚拟机曾经号称是“世界上速度最快的Java虚拟机”，BEA将其发展为一款<strong>专门为服务器硬件和服务端应用场景高度优化的虚拟机</strong>，由于专注于服务端应用，它可以不太关注于程序启动速度，因此JRockit内部<em>不包含解释器实现</em>，全部代码都靠<code>即时编译器编译后执行</code>。JRockit的<strong>垃圾收集器</strong>和<strong>Java Mission Control故障处理套件</strong>等部分的实现，在当时众多的Java虚拟机中也处于领先水平。</p><p>IBM J9虚拟机机最初是由IBM Ottawa实验室的一个<code>SmallTalk虚拟机</code>项目扩展而来。IBM J9虚拟机的市场定位与HotSpot比较接近，它是一款在<em>设计上全面考虑服务端、桌面应用，再到嵌入式的多用途虚拟机</em>。</p><blockquote><p>IBM J9虚拟机的<code>职责分离与模块化</code>做得比HotSpot更优秀，由J9 虚拟机中抽象封装出来的核心组件库（包括垃圾收集器、即时编译器、诊断监控子系统等）就单独构成了IBM OMR项目</p></blockquote><h5 id="2-5-软硬合璧：BEA-Liquid-VM-Azul-VM"><a href="#2-5-软硬合璧：BEA-Liquid-VM-Azul-VM" class="headerlink" title="2.5 软硬合璧：BEA Liquid VM/Azul VM"></a>2.5 软硬合璧：BEA Liquid VM/Azul VM</h5><p>一类<strong>与特定硬件平台绑定、软硬件配合工作的专有虚拟机</strong>，往往能够实现更高的执行性能，或提供某些特殊的功能特性。</p><blockquote><p>Liquid VM也被称为JRockit VE(Virtual Edition，VE)，BEA公司开发的可以直接运行在自家 Hypervisor系统上的JRockit虚拟机的虚拟化版本。Liquid VM不需要操作系统的支持，或者说<strong>它自己本身实现了一个专用操作系统的必要功能</strong>。</p><p>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的<strong>专有硬件Vega系统</strong>上的Java虚拟机。</p><p>Zing虚拟机(Azul Systems公司研发)是一个从HotSpot某旧版代码分支基础上独立出来重新开发的高性能Java虚拟机。在要求低延迟、快速预热等场景中，Zing VM都要比HotSpot表现得更好。Zing的PGC、 C4收集器可以轻易支持TB级别的Java堆内存，而且保证暂停时间仍然可以维持在不超过10毫秒的范围里。</p></blockquote><h5 id="2-6-挑战者：Apache-Harmony-Google-Android-Dalvik-VM"><a href="#2-6-挑战者：Apache-Harmony-Google-Android-Dalvik-VM" class="headerlink" title="2.6 挑战者：Apache Harmony/Google Android Dalvik VM"></a>2.6 挑战者：Apache Harmony/Google Android Dalvik VM</h5><p>Harmony虚拟机（准确地说是Harmony里的DRLVM）和Dalvik虚拟机<code>只能称作“虚拟 机”，而不能称作“Java虚拟机”</code>。</p><h5 id="2-7-没有成功，但并非失败：Microsoft-JVM及其他"><a href="#2-7-没有成功，但并非失败：Microsoft-JVM及其他" class="headerlink" title="2.7 没有成功，但并非失败：Microsoft JVM及其他"></a>2.7 没有成功，但并非失败：Microsoft JVM及其他</h5><p>微软为了在Internet Explorer 3浏览器中支持Java Applets应用而开发了自己的Java虚拟机，</p><h5 id="2-8-百家争鸣"><a href="#2-8-百家争鸣" class="headerlink" title="2.8 百家争鸣"></a>2.8 百家争鸣</h5><p>一些Java虚拟机是单纯为了用于生产，甚至在设计之初就仅仅是用于研究、验证某种技术和观点，又或者是作为一些规范的标准实现：</p><blockquote><ul><li>KVM。KVM中的K是“Kilobyte”的意思，它强调简单、轻量、高度可移植，但是运行速度比较慢。主要用于手机平台。</li><li>Java Card VM。JCVM必须精简到能放入智能卡、SIM卡、银行信用卡、借记卡内。</li><li>Squawk VM。运行于Sun SPOT（Sun Small Programmable Object Tech-nology，一种手持的Wi-Fi设备），也曾经运用于Java Card。</li><li>JavaInJava。试图以Java语言来实现Java语言本身的运行环境，既所谓的“元循环”（Meta-Circular，是指使用语言自身来实现其运行环境）虚拟机。</li><li>Maxine VM。也是一个几乎全部以Java代码实现（只有用于启动 Java虚拟机的加载器使用C语言编写）的元循环Java虚拟机。</li><li>Jikes RVM。是IBM开发的专门用来研究Java虚拟机实现技术的项目，也是一个元循环虚拟机。</li><li>IKVM.NET。基于微软.NET框架实现的Java虚拟机，并借助Mono获得一定的跨平台能力。</li></ul></blockquote><h4 id="3-实战：自己编译JDK"><a href="#3-实战：自己编译JDK" class="headerlink" title="3. 实战：自己编译JDK"></a>3. 实战：自己编译JDK</h4><h5 id="3-1-OpenJDK和OracleJDK"><a href="#3-1-OpenJDK和OracleJDK" class="headerlink" title="3.1 OpenJDK和OracleJDK"></a>3.1 OpenJDK和OracleJDK</h5><p>OpenJDK和 OracleJDK在程序上是非常接近的，两者共用了绝大部分相同的代码。在JDK 11以前，OracleJDK中还会存在一些OpenJDK没有的、闭源的功能，即OracleJDK 的“商业特性”。许多功能在JDK 11时全部开源到了OpenJDK中。到了这个阶段，已经可以认为OpenJDK与OracleJDK代码实质上已达到完全一致的程度。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OpenJDK_and_OracleJDK.PNG" alt="OpenJDK和 OracleJDK的关系"></p><p>OpenJDK内部不同版本之间的关系，按照开发习惯，新的功能或Bug修复通常是在最新分支上进行的，当功能或修复在最新分支上稳定之后会同步到其他老版本的维护分支上。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Relationship_between_OpenJDK_versions.PNG" alt="OpenJDK版本之间的关系"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[读书|2021阅读]--《月亮与六便士》</title>
    <link href="https://wuyunjie.top/2021/04/22/Reading_2021--The_Moon_and_Sixpence.html"/>
    <id>https://wuyunjie.top/2021/04/22/Reading_2021--The_Moon_and_Sixpence.html</id>
    <published>2021-04-22T12:27:36.000Z</published>
    <updated>2021-04-22T12:27:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>2021阅读开始啦，尽管之前也零零碎碎看了几本书，但我还是适合写写叙事类的小说吧，今年就从《月亮与六便士》开始了。<br><a id="more"></a></p></blockquote><h4 id="《月亮与六便士》"><a href="#《月亮与六便士》" class="headerlink" title="《月亮与六便士》"></a>《月亮与六便士》</h4><blockquote><p>阅读这本书的动机不大，只是最近失恋了，想多读读书提升自己，恰好这本书名声在外，没看书评和简介就开始读了。好巧不巧，这本书还真就包含了一部分爱情和梦想，跟预想的治愈心灵大相径庭，反而有种雪上加霜的感觉，这是天意吗/(ㄒoㄒ)/。</p><p>刚看开头枯燥难懂，讲的都是什么艺术家，什么艺术体系流派。咋一看真被唬住了，以为是一本介绍文艺复兴的纪实史，或者是针对开头介绍的人物的个人传记，会包含各种高深莫测的艺术赏析思想和术语，没想到到后面画风突变，又变成了一段爱恨情仇的小说。有人说这本书是讲追逐梦想的，也有人说这里面是包含了一种不正的爱情三观，只是被出版商的把戏炒成了畅销书。从我的角度来看，还是有收获的吧，这本书的故事并不轻松，甚至可以说有些沉重。结局也不好评判，对生活有不同态度的人会对结局有不同的看法吧。</p><p>首先从梦想的角度看吧，斯特里克兰依旧被塑造成为了一个性格怪异的传奇人物。尽管作者在文中提到:</p><blockquote><p><code>人类天生具有制造神话的特性，对于那些出类拔萃的人物，人们对发生在他们身上的奇闻逸事往往好奇心极强，编造出一个个传奇故事，然后对此深信不疑，达到近乎狂热的地步。这其实是浪漫主义对平庸生活的一种抗议。因此，一些传奇故事顺理成章地成为铸就不朽英雄的通行证。</code></p></blockquote><p>但实际上最后毛姆还是造就了一个与众不同的斯特里克兰，或许这样的大师本就与众不同，才能在芸芸众生之间鹤立鸡群。另一方面也或许正因为他们是大师/天才，业界传奇，所以他们的一切都被放大了，成为解释他们成功的理由。斯特里克兰四十多岁抛家弃子，放弃衣食无忧的生活走上了追逐艺术的道路，而且他很笃定，他不在意别人的看法，这是真的不在意，这是笃定地不断向前，不需要别人地认可，只是表达自己所想，活在自己自由的世界里。从生活环境的角度看，他是不幸的，大多数人都把梦想艺术看作酒足饭饱之后的精神满足，只有保证温饱后才能追求高层次的精神需求，这正式<code>马斯洛需求金字塔</code>，但斯特里克兰不一样，他似乎更看重自我实现上，当然这可能是我的片面理解。从这一点来说对主角很敬佩，但我也绝不大可能像主角一样放弃一切去逐梦，打破精神上的那层枷锁，实现自我。可能我是个大俗人吧。</p><p>如果看斯特里克兰的爱情，可以用一塌糊涂来形容吧。抛家弃子，拆散救命恩人的家庭，最后在孤岛上也留下苦命的妻女。可以说他似乎完全不在乎别人，他只在乎他自己还有他的画家梦，或者说是他对一种美，对一种精神上的追求，懵懵懂懂。但从他的绝情上看，确实描述得入木三分，对不爱的人那种绝情的言辞，真的让人很心痛，却又无懈可击，他这样的人活在自己想要的世界就已然足够了，别人的非议无关紧要，别人的生死哀愁痛苦也入不了他们的内心，可能连同情都没有，只有不屑一顾。从这方面来说，尽管敬佩他这样的处事态度，但这样的人却也是无论如何都喜欢不起来。</p><p>最后引用两段平常人的平庸爱情吧，感觉这是大多数人的人生：</p><blockquote><p>我能想象他们的生活，无灾无祸，日子过得踏实、体面，还有两个端庄、可爱的孩子，他们注定会弘扬良好的家风和地位。夫妻两个会在不知不觉中慢慢变老，看到一双儿女长大成人。到了适当的年龄他们的儿女便会结婚生子，漂亮的女儿将来会做个贤妻良母，生出健康活泼的孩子；而帅气的儿子也会成为英气逼人的男子汉，没准会成为一名军人。最后，这对夫妻开枝散叶后就会体面地隐退，子孙承欢膝下，过着充实、幸福的生活，到时寿终正寝，入土为安。</p></blockquote><hr><blockquote><p>爱情需要人们全神贯注，它使人忘掉自己去爱对方。最聪明的人虽然可能知道爱有尽头这道理，在实际中却不愿相信这一点。人们明知爱是虚幻，却还是为其放弃实实在在的东西，于他们而言，爱情胜过现实。爱情使一个人变得更强大，同时也使他变得更渺小。他们不再是自己。他们不再是人，而是成为一个物件、一个工具，要实现对于他们而言十分陌生的目的。</p></blockquote><hr><blockquote><p>“上帝的磨盘转得很慢，却也磨得很细。”<br>碰上这种情况一准会说：”魔鬼为达到目的总是会引用《圣经》。”</p></blockquote></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/The_Moon_and_Sixpence.jpg" alt="月亮与六便士"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;2021阅读开始啦，尽管之前也零零碎碎看了几本书，但我还是适合写写叙事类的小说吧，今年就从《月亮与六便士》开始了。&lt;br&gt;
    
    </summary>
    
      <category term="Reading" scheme="https://wuyunjie.top/categories/Reading/"/>
    
    
      <category term="Reading" scheme="https://wuyunjie.top/tags/Reading/"/>
    
      <category term="Book" scheme="https://wuyunjie.top/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-3-从尾到头打印链表</title>
    <link href="https://wuyunjie.top/2021/04/20/JZ3-print-LinkList-reverse.html"/>
    <id>https://wuyunjie.top/2021/04/20/JZ3-print-LinkList-reverse.html</id>
    <published>2021-04-20T14:01:35.000Z</published>
    <updated>2021-04-20T14:01:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>输入一个链表，按链表从尾到头的顺序返回一个<code>ArrayList</code>。<br><a id="more"></a></p><p><strong>示例:</strong></p><blockquote><p>输入:   {67,0,24,58}<br>返回值: [58,24,0,67]</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题也挺简单的，感觉都是考察基础啊，怎么都标为较难。思路很简单，就是遍历链表元素，存入新建的ArrayList对象，最后通过一个反转函数对ArrayList反转。此外还有基于递归的方法，或者先对链表反转，再存入ArrayList。</p><p>这里对反转链表操作简单复习一下，可以总结为先存储当前节点的下一节点，再反转当前节点的pnext指针，最后重置head头部。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ3/reverse_linklist.gif" alt="反转链表"></p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol><li>解法1 存入ArrayList后反转<br>1.1. 直接加入到ArrayList第一个位置实现反转<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; List = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            List.add(<span class="number">0</span>, listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> List;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>1.2. 调用<code>Collections.reverse()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; List = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            List.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(List);</span><br><span class="line">        <span class="keyword">return</span> List;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p>解法2 反转链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = listNode;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(pre.val);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法3  递归方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol><li><p>Java <code>ArrayList</code>类<br>ArrayList 类是一个<strong>可以动态修改</strong>的数组，与普通数组的区别就是它是<strong>没有固定大小的限制</strong>，我们可以添加或删除元素。ArrayList 类位于<code>java.util</code>包中，使用前需要引入它，语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 引入 ArrayList 类</span></span><br><span class="line">ArrayList&lt;E&gt; objectName =<span class="keyword">new</span> ArrayList&lt;&gt;();　 <span class="comment">// 初始化</span></span><br></pre></td></tr></table></figure><p>ArrayList 是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p></li><li><p>Collections<br><code>Collections</code>是JDK提供的工具类，同样位于<code>java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。</p></li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://www.runoob.com/java/java-arraylist.html" target="_blank" rel="noopener">String、StringBuffer和StringBuilder的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;输入一个链表，按链表从尾到头的顺序返回一个&lt;code&gt;ArrayList&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-2-替换空格</title>
    <link href="https://wuyunjie.top/2021/04/20/JZ2-replace-spaces.html"/>
    <id>https://wuyunjie.top/2021/04/20/JZ2-replace-spaces.html</id>
    <published>2021-04-20T11:01:03.000Z</published>
    <updated>2021-04-20T11:01:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成<code>&quot;%20&quot;</code>。例如，当字符串为<code>We Are Happy</code>，则经过替换之后的字符串为<code>We%20Are%20Happy</code>。<br><a id="more"></a></p><p><strong>示例:</strong></p><blockquote><p>输入:   “We Are Happy”<br>返回值: “We%20Are%20Happy”</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题挺简单的，就是逐个判断String数组的字符，然后基于拼接构建出要求的字符串。也有方法直接调用内置的替换函数，不知道为何难度为<strong>较难</strong>，可能还有特殊的优化解。</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol><li><p>解法1 暴力求法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">                result += <span class="string">"%20"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2 调用 <code>String.replaceAll()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">   <span class="keyword">return</span> s.replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法3 调用 <code>Spring.split()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        String[] strs = s.split(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">" "</span>.equals(str))</span><br><span class="line">                sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            sb.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol><li>String、StringBuffer和StringBuilder</li></ol><ul><li>String<br><code>String</code>类是<strong>不可变</strong>类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。通过一个字符串对象a的内存存储空间图对String类的不可变性理解。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ2/String.png" alt="`String`类不可变"></p><p>再次给a赋值时，并不是对原来堆中实例对象进行重新赋值，而是生成一个新的实例对象，并且指向“456”这个字符串，a则指向最新生成的实例对象，<em>之前的实例对象仍然存在，如果没有被再次引用，则会被垃圾回收</em>。</p><ul><li>StringBuffer<br><code>StringBuffer</code>对象则代表一个字符序列<strong>可变</strong>的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的<code>append()</code>、<code>insert()</code>、<code>reverse()</code>、<code>setCharAt()</code>、<code>setLength()</code>等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的<code>toString()</code>方法将其转换为一个String对象。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ2/StringBuffer.png" alt="`StringBuffer`类"></p><p>字符串连接的情况，方便和直接的方式是通过”+”符号来实现，但是这种方式达到目的的效率比较低，且<em>每执行一次都会创建一个String对象</em>，<strong>即耗时，又浪费空间</strong>。使用StringBuilder类就可以避免这种问题的发生</p><ul><li>StringBuilder<br><code>StringBuilder</code>类也代表<strong>可变</strong>字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：<strong>StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高</strong>。StringBuffer类中的方法都添加了<code>synchronized</code>关键字，也就是给这个方法添加了一个锁，用来保证线程安全。</li></ul><p><strong>Java9改进了字符串</strong>（包括String、StringBuffer、StringBuilder）的实现。在Java9以前字符串采用<code>char[]</code>数组来保存字符，因此字符串的每个字符占<code>2</code>字节；而Java9的字符串采用<code>byte[]</code>数组再加一个<code>encoding-flag</code>字段来保存字符，因此字符串的每个字符只占<code>1</code>字节。所以Java9的字符串更加节省空间，字符串的功能方法也没有受到影响。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://blog.csdn.net/csxypr/article/details/92378336" target="_blank" rel="noopener">String、StringBuffer和StringBuilder的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;请实现一个函数，将一个字符串中的每个空格替换成&lt;code&gt;&amp;quot;%20&amp;quot;&lt;/code&gt;。例如，当字符串为&lt;code&gt;We Are Happy&lt;/code&gt;，则经过替换之后的字符串为&lt;code&gt;We%20Are%20Happy&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
