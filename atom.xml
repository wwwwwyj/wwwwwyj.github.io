<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuYJ&#39;s Blog</title>
  
  <subtitle>wuyunjie的小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuyunjie.top/"/>
  <updated>2021-06-07T06:45:04.000Z</updated>
  <id>https://wuyunjie.top/</id>
  
  <author>
    <name>wuyunjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--13 线程安全与锁优化</title>
    <link href="https://wuyunjie.top/2021/06/07/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_13_Thread_safety_and_lock_optimization.html"/>
    <id>https://wuyunjie.top/2021/06/07/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_13_Thread_safety_and_lock_optimization.html</id>
    <published>2021-06-07T06:45:04.000Z</published>
    <updated>2021-06-07T06:45:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>首先需要保证并发的正确性，然后在此基础上来实现高效。<br><a id="more"></a></p></blockquote><h3 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1. 线程安全"></a>1. 线程安全</h3><blockquote><p><code>“线程安全”</code>是<code>“当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。”</code></p></blockquote><h4 id="1-1-Java语言中的线程安全"><a href="#1-1-Java语言中的线程安全" class="headerlink" title="1.1 Java语言中的线程安全"></a>1.1 Java语言中的线程安全</h4><p>将Java语言中各种操作共享的数据分为以下五类：<code>不可变</code>、<code>绝对线程安全</code>、<code>相对线程安全</code>、<code>线程兼容</code>和<code>线程对立</code>。</p><h5 id="1-1-1-不可变"><a href="#1-1-1-不可变" class="headerlink" title="1.1.1 不可变"></a>1.1.1 不可变</h5><p><code>不可变（Immutable）</code>的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。</p><ul><li>如果多线程共享的数据是一个<code>基本数据类型</code>，那么只要在定义时使用<code>final</code>关键字修饰它就可以保证它是不可变的。</li><li>如果共享数据是一个<code>对象</code>，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。<ul><li>Java类库<code>API</code>中<code>不可变</code>的类型，除了<code>String</code>外，常用的还有<code>枚举类型</code>及<code>java.lang.Number</code>的部分子类。</li></ul></li></ul><h5 id="1-1-2-绝对线程安全"><a href="#1-1-2-绝对线程安全" class="headerlink" title="1.1.2 绝对线程安全"></a>1.1.2 绝对线程安全</h5><p><code>绝对的线程安全</code>能够完全满足给出的线程安全的定义，但一个类要达到<code>“不管运行时环境如何，调用者都不需要任何额外的同步措施”</code>可能需要付出非常高昂的， 甚至不切实际的代价。</p><p>在<code>Java API</code>中标注自己是线程安全的类，大多数都<strong>不是绝对的线程安全</strong>。</p><h5 id="1-1-3-相对线程安全"><a href="#1-1-3-相对线程安全" class="headerlink" title="1.1.3 相对线程安全"></a>1.1.3 相对线程安全</h5><p><code>相对线程安全</code>就是通常意义上所讲的线程安全，它需要<u><strong>保证对这个对象单次的操作是线程安全的，在调用的时候不需要进行额外的保障措施</strong></u>，但是对于一些<strong>特定顺序的连续调用</strong>，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><h5 id="1-1-4-线程兼容"><a href="#1-1-4-线程兼容" class="headerlink" title="1.1.4 线程兼容"></a>1.1.4 线程兼容</h5><p><code>线程兼容</code>是指<u>对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用</u>。平常说一个类不是线程安全的，通常就是指这种情况。</p><h5 id="1-1-5-线程对立"><a href="#1-1-5-线程对立" class="headerlink" title="1.1.5 线程对立"></a>1.1.5 线程对立</h5><p><code>线程对立</code>是指<u>不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码</u>。</p><h4 id="1-2-线程安全的实现方法"><a href="#1-2-线程安全的实现方法" class="headerlink" title="1.2 线程安全的实现方法"></a>1.2 线程安全的实现方法</h4><h5 id="1-2-1-互斥同步"><a href="#1-2-1-互斥同步" class="headerlink" title="1.2.1 互斥同步"></a>1.2.1 互斥同步</h5><p><code>互斥同步（Mutual Exclusion &amp; Synchronization）</code>是一种最常见也是最主要的并发正确性保障手段。</p><ul><li><code>同步</code>是指<u>在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用</u>。</li><li><code>互斥</code>是实现同步的一种手段，<code>临界区（Critical Section）</code>、<code>互斥量（Mutex）</code>和<code>信号量（Semaphore）</code>都是常见的互斥实现方式。</li></ul><p>在<code>Java</code>里面，最基本的互斥同步手段就是<code>synchronized</code>关键字。</p><blockquote><p><code>synchronized</code>关键字经过<code>Javac</code>编译之后，会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令。这两个字节码指令都需要一个<code>reference</code>类型的参数来指明要锁定和解锁的对象。</p><ul><li>在执行<code>monitorenter</code>指令时，首先要去尝试获取对象的<code>锁</code>。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把<code>锁的计数器</code>的值增加一</li><li>在执行<code>monitorexit</code>指令时会将<code>锁计数器</code>的值减一。一旦计数器的值为零，锁随即就被释放了。</li><li>如果获取对象锁失败，那当前线程就应当被<code>阻塞等待</code>，直到请求锁定的对象被持有它的线程释放为止。</li></ul></blockquote><p>两个关于<code>synchronized</code>的直接推论：</p><ul><li>被<code>synchronized</code>修饰的同步块对<strong>同一条线程</strong>来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li><li>被<code>synchronized</code>修饰的同步块在<u>持有锁的线程执行完毕并释放锁之前</u>，会<strong>无条件地阻塞后面其他线程的进入</strong>。这意味着<u>无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁</u>；也<u>无法强制正在等待锁的线程中断等待或超时退出</u>。</li></ul><p>持有锁是一个<code>重量级（Heavy-Weight）</code>的操作，尤其是对于代码特别简单的同步块，状态转换消耗的时间甚至会比用户代码本身执行的时间还要长。<code>JDK 5</code>起提供了<code>java.util.concurrent.locks.Lock</code>接口，作为另一种全新的互斥同步手段。基于<code>Lock</code>接口，用户能够以<code>非块结构（Non-Block Structured）</code>来实现互斥同步，在<strong>类库层面去实现同步</strong>。</p><p><code>重入锁（ReentrantLock）</code>是<code>Lock</code>接口最常见的一种实现，它与<code>synchronized</code>一样是可重入的。主要增加了以下三项高级功能：</p><ul><li><code>等待可中断</code>：是指<u>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</u>。</li><li><code>公平锁</code>：是指<u>多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</u>；而<code>非公平锁</code>则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。<ul><li><code>synchronized</code>中的锁是非公平的；</li><li><code>ReentrantLock</code>在<strong>默认情况</strong>下也是非公平的，但可以通过构造函数要求使用公平锁。但一旦使用了公平锁，将会导致<code>ReentrantLock</code>的性能急剧下降，会明显影响吞吐量。 </li></ul></li><li><code>锁绑定多个条件</code>：是指<u><strong>一个<code>ReentrantLock</code>对象可以同时绑定多个<code>Condition</code>对象</strong></u>。</li></ul><h5 id="1-2-2-非阻塞同步"><a href="#1-2-2-非阻塞同步" class="headerlink" title="1.2.2 非阻塞同步"></a>1.2.2 非阻塞同步</h5><p>互斥同步面临的主要问题是进行线程<strong>阻塞</strong>和<strong>唤醒</strong>所带来的性能开销，因此这种同步也被称为<code>阻塞同步（Blocking Synchronization）</code>，互斥同步属于一种<strong>悲观的并发策略</strong>。</p><p>另外有一种基于<code>冲突检测</code>的<strong>乐观并发策略</strong>，通俗地说就是<u><strong>不管风险，先进行操作</strong></u>：</p><ul><li>如果<strong>没有</strong>其他线程争用共享数据，那操作就直接成功；</li><li>如果<strong>有</strong>其他线程争用共享数据，产生了冲突，再进行其他的补偿措施，比如不断地重试，直到出现没有竞争的共享数据为止。</li></ul><p>这种乐观并发策略的实现<strong><u>不再需要把线程阻塞挂起</u></strong>，因此这种同步操作被称为<code>非阻塞同步（Non-Blocking Synchronization）</code>，使用这种措施的代码也常被称为<code>无锁（Lock-Free）编程</code>。</p><p>乐观并发策略需要<code>“硬件指令集的发展”</code>，因为要求<code>操作</code>和<code>冲突检测</code>这两个步骤具备<strong>原子性</strong>。硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，这类指令常用的有：</p><ul><li><code>测试并设置（Test-and-Set）</code>；</li><li><code>获取并增加（Fetch-and-Increment）</code>；</li><li><code>交换（Swap）</code>；</li><li><code>比较并交换（Compare-and-Swap）</code>；</li><li><code>加载链接/条件储存（Load-Linked/Store-Conditional）</code>。</li></ul><h5 id="1-2-3-无同步方案"><a href="#1-2-3-无同步方案" class="headerlink" title="1.2.3 无同步方案"></a>1.2.3 无同步方案</h5><p>同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的：</p><ul><li><code>可重入代码（Reentrant Code）</code>：这种代码又称<code>纯代码（Pure Code）</code>，是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。<ul><li><code>可重入代码</code>有一些共同的特征，例如<u>不依赖全局变量、存储在堆上的数据和公用的系统资源</u>， 用到的状态量都由参数中传入，不调用非可重入的方法等。</li><li>如果一个方法的返回结果是<strong>可以预测的</strong>，那它就满足可重入性的要求。</li></ul></li><li><code>线程本地存储（Thread Local Storage）</code>：如果一段代码中所需要的数据必须与其他代码共享，如果能保证这些共享数据的代码在同一个线程中执行，就可以把共享数据的可见范围限制在同一个线程之内，无须同步也能保证线程之间不出现数据争用的问题。</li></ul><h3 id="2-锁优化"><a href="#2-锁优化" class="headerlink" title="2. 锁优化"></a>2. 锁优化</h3><h4 id="2-1-自旋锁与自适应自旋（Adaptive-Spinning）"><a href="#2-1-自旋锁与自适应自旋（Adaptive-Spinning）" class="headerlink" title="2.1 自旋锁与自适应自旋（Adaptive Spinning）"></a>2.1 自旋锁与自适应自旋（Adaptive Spinning）</h4><p>如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，就可以让后面请求锁的那个线程<code>“稍等一会”</code>，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，只须让线程执行一个<code>忙循环（自旋）</code>，这项技术就是所谓的<code>自旋锁</code>。</p><blockquote><ul><li>自旋等待本身虽然避免了<code>线程切换</code>的开销，但它需要<strong>占用处理器时间</strong>，所以如果锁被占用的时间很短，自旋等待的效果就会非常好；</li><li>反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。</li></ul></blockquote><p>自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。引入了<code>自适应的自旋</code>，自旋的时间不再是固定，而是由<u><strong>前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</strong></u>的。</p><h4 id="2-2-锁消除（Lock-Elimination）"><a href="#2-2-锁消除（Lock-Elimination）" class="headerlink" title="2.2 锁消除（Lock Elimination）"></a>2.2 锁消除（Lock Elimination）</h4><p>锁消除是指虚<u>拟机即时编译器在运行时，对一些代码要求同步，但是对<strong>被检测到不可能存在共享数据竞争的锁</strong>进行消除</u>。</p><blockquote><p>锁消除的主要判定依据来源于<code>逃逸分析</code>的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以认为它们是<code>线程私有</code>的。</p></blockquote><h4 id="2-3-锁粗化（Lock-Coarsening）"><a href="#2-3-锁粗化（Lock-Coarsening）" class="headerlink" title="2.3 锁粗化（Lock Coarsening）"></a>2.3 锁粗化（Lock Coarsening）</h4><p>如果一系列的<code>连续操作</code>都对<strong>同一个对象</strong>反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围<strong><code>扩展（粗化）</code>到整个操作序列的外部</strong>。</p><h4 id="2-4-轻量级锁（Lightweight-Locking）"><a href="#2-4-轻量级锁（Lightweight-Locking）" class="headerlink" title="2.4 轻量级锁（Lightweight Locking）"></a>2.4 轻量级锁（Lightweight Locking）</h4><p><code>HotSpot</code>虚拟机的<code>对象头（Object Header）</code>分为两部分：</p><ul><li>第一部分用于<strong><u>存储对象自身的运行时数据</u></strong>，如<code>哈希码（HashCode）</code>、<code>GC分代年龄（Generational GC Age）</code> 等，官方称为<code>“Mark Word”</code>。这部分是实现轻量级锁和偏向锁的关键。</li><li>另一部分用于<u><strong>存储指向方法区对象类型数据的指针</strong></u>，如果是数组对象，还会有一个额外的部分用于存储数组长度。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/HotSpotMarkWord.PNG" alt="HotSpot虚拟机对象头Mark Word"></p><p>轻量级锁的工作过程：</p><ul><li>在代码即将进入同步块的时候，如果此同步对象<strong>没有被锁定</strong>（锁标志位为<code>“01”</code>状态），虚拟机首先将在当前线程的栈帧中建立一个名为<code>锁记录（Lock Record）</code>的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝（即<code>Displaced Mark Word</code>）</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/BeforeCAS.PNG" alt="轻量级锁CAS操作之前堆栈与对象的状态"></p><ul><li>然后，虚拟机将使用<code>CAS</code>操作尝试把对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。<ul><li>如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象<code>Mark Word</code>的<code>锁标志位</code>将转变为<code>“00”</code>，表示此对象处于轻量级锁定状态。</li><li>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，<ul><li>如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行；</li><li>否则，就说明这个锁对象已经被其他线程抢占了。</li></ul></li><li>如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要<strong>膨胀为重量级锁</strong>，锁标志的状态值变为<code>“10”</code>，此时<code>Mark Word</code>中存储的就是指向<code>重量级锁（互斥量）</code>的指针，后面等待锁的线程也必须进入阻塞状态。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/AfterCAS.PNG" alt="轻量级锁CAS操作之后堆栈与对象的状态"></p><p>轻量级锁的解锁过程也同样是通过<code>CAS</code>操作来进行的：</p><ul><li>如果对象的<code>Mark Word</code>仍然指向线程的锁记录，那就用<code>CAS</code>操作把对象当前的<code>Mark Word</code>和线程中复制的<code>Displaced Mark Word</code>替换回来。</li><li>假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</li></ul><h4 id="2-5-偏向锁（Biased-Locking）"><a href="#2-5-偏向锁（Biased-Locking）" class="headerlink" title="2.5 偏向锁（Biased Locking）"></a>2.5 偏向锁（Biased Locking）</h4><p>偏向锁的目的是<u><strong>消除数据在无竞争情况下的同步原语</strong></u>， 进一步提高程序的运行性能。</p><blockquote><p>偏向锁是在无竞争的情况下把整个同步都消除掉，连<code>CAS</code>操作都不去做了。</p></blockquote><ul><li>假设当前虚拟机启用了偏向锁，那么当锁对象<strong>第一次</strong>被线程获取的时候，虚拟机将会把对象头中的<code>标志位</code>设置为<code>“01”</code>、把<code>偏向模式</code>设置为<code>“1”</code>，表示进入<strong>偏向模式</strong>。同时使用<code>CAS</code>操作把获取到这个锁的线程的<code>ID</code>记录在对象的<code>Mark Word</code>之中。如果<code>CAS</code>操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。</li><li>一旦出现另外一个线程去尝试获取这个锁的情况，<strong>偏向模式</strong>就<u>马上宣告结束</u>。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为<code>“0”</code>），撤销后标志位恢复到未锁定（标志位为<code>“01”</code>）或轻量级锁定（标志位为<code>“00”</code>）的状态，后续的同步操作就按照轻量级锁那样去执行。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/BiasedLocking.PNG" alt="偏向锁、轻量级锁的状态转化及对象Mark Word的关系"></p><ul><li>当一个对象已经计算过<code>一致性哈希码</code>后，它就再也无法进入偏向锁状态了；</li><li>当一个对象当前正处于<code>偏向锁</code>状态，又收到需要计算其<code>一致性哈希码</code>请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的<code>ObjectMonitor</code>类里有字段可以记录非加锁状态（标志位为<code>“01”</code>）下的<code>Mark Word</code>，其中自然可以存储原来的哈希码。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;首先需要保证并发的正确性，然后在此基础上来实现高效。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--12  Java内存模型与线程</title>
    <link href="https://wuyunjie.top/2021/06/06/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_12_Java_memory_model_and_threads.html"/>
    <id>https://wuyunjie.top/2021/06/06/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_12_Java_memory_model_and_threads.html</id>
    <published>2021-06-06T05:02:04.000Z</published>
    <updated>2021-06-06T05:02:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>并发处理是人类压榨计算机运算能力的最有力武器。<br><a id="more"></a></p></blockquote><h3 id="1-硬件的效率与一致性"><a href="#1-硬件的效率与一致性" class="headerlink" title="1. 硬件的效率与一致性"></a>1. 硬件的效率与一致性</h3><p>绝大多数的运算任务都不可能只靠处理器<code>“计算”</code>就能完成。处理器至少要与内存交互，如<u>读取运算数据</u>、 <u>存储运算结果</u>等，这个I/O操作很难消除（无法仅靠寄存器来完成所有运算任务）。</p><p>由于计算机的存储设备与处理器的运算速度有着几个<strong>数量级的差距</strong>，所以现代计算机系统都不得不加入<em>一层</em>或<em>多层</em>读写速度尽可能接近处理器运算速度的<code>高速缓存（Cache）</code>来作为内存与处理器之间的缓冲：</p><blockquote><p>将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p></blockquote><p>基于高速缓存的存储交互引入了一个新的问题：<code>缓存一致性（Cache Coherence）</code>。</p><blockquote><p>在多路处理器系统中，每 个处理器都有自己的高速缓存，而它们又共享同一<code>主内存（Main Memory）</code>，这种系统称为<code>共享内存多核系统（Shared Memory Multiprocessors System）</code>。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的<u><strong>缓存数据不一致</strong></u>。</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/SharedMemoryMultiprocessorsSystem.PNG" alt="处理器、高速缓存、主内存间的交互关系"></p><p>为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有<code>MSI</code>、<code>MESI（Illinois Protocol）</code>、<code>MOSI</code>、 <code>Synapse</code>、<code>Firefly</code>及<code>Dragon Protocol</code>等。</p><h3 id="2-Java内存模型"><a href="#2-Java内存模型" class="headerlink" title="2. Java内存模型"></a>2. Java内存模型</h3><p><code>“Java内存模型”</code>（<code>Java Memory Model，JMM</code>）用于<u><strong>屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果</strong></u>。</p><h4 id="2-1-主内存与工作内存"><a href="#2-1-主内存与工作内存" class="headerlink" title="2.1 主内存与工作内存"></a>2.1 主内存与工作内存</h4><p>Java内存模型的主要目的是定义程序中各种<code>变量（Variables）</code>的访问规则，即关注在虚拟机中把变量值<u><strong>存储到内存</strong></u>和<u><strong>从内存中取出</strong></u>变量值这样的底层细节。</p><blockquote><p>此处的变量<strong>包括</strong><u>实例字段</u>、<u>静态字段</u>和<u>构成数组对象的元素</u>，但是<strong>不包括</strong><u>局部变量</u>与<u>方法参数</u>，因为后者是<u><strong>线程私有</strong></u>的，不会被共享，不会存在竞争问题。</p></blockquote><p>Java内存模型规定了所有的变量都存储在<code>主内存（Main Memory）</code>中，每条线程还有自己的<code>工作内存（Working Memory）</code>，线程的工作内存中保存了被该线程<u><strong>使用的变量的主内存副本</strong></u>，线程对变量的所有操作（读取、赋值等）都<u><strong>必须在工作内存中进行，而不能直接读写主内存中的数据</strong></u>。不同的线程之间也无法直接访问对方工作内存中的变量，<u><strong>线程间变量值的传递均需要通过主内存来完成</strong></u>。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaMemoryModel.PNG" alt="线程、主内存、工作内存三者的交互关系"></p><h4 id="2-2-内存间交互操作"><a href="#2-2-内存间交互操作" class="headerlink" title="2.2 内存间交互操作"></a>2.2 内存间交互操作</h4><p>关于主内存与工作内存之间具体的交互协议，即一个变量<u>如何从主内存拷贝到工作内存</u>、<u>如何从工作内存同步回主内存</u>这一类的实现细节，Java内存模型中定义了以下8种操作来完成，每一种操作都是原子的、不可再分的：</p><ul><li><code>lock（锁定）</code>：作用于<strong>主内存</strong>的变量，它<strong>把一个变量标识为一条线程独占的状态</strong>。</li><li><code>unlock（解锁）</code>：作用于<strong>主内存</strong>的变量，它<strong>把一个处于锁定状态的变量释放出来</strong>，释放后的变量才可以被其他线程锁定。</li><li><code>read（读取）</code>：作用于<strong>主内存</strong>的变量，它<strong>把一个变量的值从主内存传输到线程的工作内存中</strong>，以便随后的<code>load</code>动作使用。</li><li><code>load（载入）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把<code>read</code>操作从主内存中得到的变量值放入工作内存的变量副本中</strong>。</li><li><code>use（使用）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把工作内存中一个变量的值传递给执行引擎</strong>，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><code>assign（赋值）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把一个从执行引擎接收的值赋给工作内存的变量</strong>， 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><code>store（存储）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把工作内存中一个变量的值传送到主内存中</strong>，以便随后的<code>write</code>操作使用。</li><li><code>write（写入）</code>：作用于<strong>主内存</strong>的变量，它<strong>把<code>store</code>操作从工作内存中得到的变量的值放入主内存的变量中</strong>。</li></ul><p>Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p><ul><li>不允许<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它最近的<code>assign</code>操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何<code>assign</code>操作）把数据从线程的工作内存同步回主内存中。</li><li>一个新的变量只能在<strong>主内存</strong>中<code>“诞生”</code>，不允许在工作内存中直接使用一个未被初始化（<code>load</code>或 <code>assign</code>）的变量，换句话说就是对一个变量实施<code>use</code>、<code>store</code>操作之前，必须先执行<code>assign</code>和<code>load</code>操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行<code>lock</code>操作，但<code>lock</code>操作可以被同一条线程重复执行多次，多次执行<code>lock</code>后，只有执行<strong>相同次数</strong>的<code>unlock</code>操作，变量才会被解锁。</li><li>如果对一个变量执行<code>lock</code>操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行<code>load</code>或<code>assign</code>操作以初始化变量的值。</li><li>如果一个变量事先没有被<code>lock</code>操作锁定，那就不允许对它执行<code>unlock</code>操作，也不允许去<code>unlock</code>一个被<strong>其他线程</strong>锁定的变量。</li><li>对一个变量执行<code>unlock</code>操作之前，必须先把此变量同步回主内存中（执行<code>store</code>、<code>write</code>操作）。</li></ul><p>Java内存模型的操作在最新的<code>JSR-133</code>文档中简化为<code>read</code>、<code>write</code>、<code>lock</code>和<code>unlock</code>四种，但这只是语言描述上的等价化简，Java内存模型的基础设计并未改变。</p><h4 id="2-3-对于volatile型变量的特殊规则"><a href="#2-3-对于volatile型变量的特殊规则" class="headerlink" title="2.3 对于volatile型变量的特殊规则"></a>2.3 对于volatile型变量的特殊规则</h4><p>关键字<code>volatile</code>可以说是Java虚拟机提供的<strong>最轻量级</strong>的<code>同步机制</code>，Java内存模型为<code>volatile</code>专门定义了一些特殊的访问规则，当一个变量被定义成<code>volatile</code>之后，它将具备两项特性：</p><h5 id="2-3-1-保证此变量对所有线程的可见性"><a href="#2-3-1-保证此变量对所有线程的可见性" class="headerlink" title="2.3.1 保证此变量对所有线程的可见性"></a>2.3.1 保证此变量对所有线程的<code>可见性</code></h5><p>这里的<code>“可见性”</code>是指<u>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</u>。而普通变量的值在线程间传递时均需要通过主内存来完成。</p><blockquote><p><code>volatile</code>变量依然有工作内存的拷贝，但是由于它<strong><u>特殊的操作顺序性规定</u></strong>，所以看起来如同直接在主内存中读写访问一般。</p></blockquote><p><code>volatile</code>变量在各个线程的工作内存中是不存在一致性问题的，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile变量自增运算测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码并不会获得期望的结果，而且每次运行程序输出的结果都不一样。用<code>Javap</code>反编译这段代码后发现<code>increase()</code>方法在<code>Class</code>文件中是由4条字节码指令构成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void increase();</span><br><span class="line">Code:</span><br><span class="line">Stack=2, Locals=0, Args_size=0</span><br><span class="line">0: getstatic #13; //Field race:I</span><br><span class="line">3: iconst_1</span><br><span class="line">4: iadd</span><br><span class="line">5: putstatic #13; //Field race:I</span><br><span class="line">8: return</span><br><span class="line">LineNumberTable:</span><br><span class="line">line 14: 0</span><br><span class="line">line 15: 8</span><br></pre></td></tr></table></figure><blockquote><p>并发失败的原因：当<code>getstatic</code>指令把<code>race</code>的值取到<strong>操作栈顶</strong>时，<code>volatile</code>关键字保证了<code>race</code>的值在此时是正确的，但是在执行<code>iconst_1</code>、<code>iadd</code>指令时，其他线程可能已经把<code>race</code>的值改变了，而操作栈顶的值就变成了<strong>过期的数据</strong>，所以<code>putstatic</code>指令执行后就可能把<strong>较小的race值</strong>同步回主内存之中。</p></blockquote><p>由于<code>volatile</code>变量只能保证可见性，在<strong><u>不符合</u></strong>以下两条规则的运算场景中，仍然要通过加锁来保证原子性：</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><h5 id="2-3-2-禁止指令重排序优化"><a href="#2-3-2-禁止指令重排序优化" class="headerlink" title="2.3.2 禁止指令重排序优化"></a>2.3.2 禁止指令重排序优化</h5><p>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而<u>不能保证变量赋值操作的顺序与程序代码中的执行顺序一致</u>，即<code>“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="comment">// 此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">// 模拟读取配置信息，当读取完成后</span></span><br><span class="line"><span class="comment">// 将initialized设置为true,通知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span> (!initialized) &#123;</span><br><span class="line">sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure><p>如果定义<code>initialized</code>变量时没有使用<code>volatile</code>修饰，就可能会由于<code>指令重排序的优化</code>，导致位于线程<code>A</code>中最后一条 代码<code>“initialized=true”</code>被提前执行（实际上<code>重排序优化</code>是<strong>机器级</strong>的优化操作），这样在线程<code>B</code>中使用配置信息的代码就可能出现错误。</p><p>下面是标准的<code>双锁检测（Double Check Lock，DCL）</code>单例的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有<code>volatile</code>修饰的变量，赋值后多执行了一个<code>“lock addl$0x0，(%esp)”</code>操作，这个操作的作用相当于一个<code>内存屏障</code>（<code>Memory Barrier</code>或<code>Memory Fence</code>，指重排序时不能把后面的指令重排序到内存屏障之前的位置）。</p><p><code>“addl$0x0，(%esp)”</code>（把ESP寄存器的值加0）是一个<strong>空操作</strong>。</p><blockquote><p>之所以用这个空操作而不是空操作专用指令<code>nop</code>，是因为<code>IA32</code>手册规定<code>lock</code>前缀不允许配合<code>nop</code>指令使用。</p></blockquote><p>它的作用是将本处理器的缓存写入了内存，该写入动作也会引起别的处理器或者别的内核<code>无效化（Invalidate）</code>其缓存。所以通过这样一个空操作，可让前面<code>volatile</code>变量的修改对其他处理器立即可见。</p><p>在volatile与锁中选择的<strong>唯一判断依据</strong>仅仅是<u><code>volatile</code>的语义能否满足使用场景的需求</u>。假定<code>T</code>表示一个线程，<code>V</code>和<code>W</code>分别表示两个<code>volatile</code>型变量，那么在进行<code>read</code>、<code>load</code>、<code>use</code>、<code>assign</code>、<code>store</code>和<code>write</code>操作时需要满足如下规则：</p><ul><li>在<strong>工作内存</strong>中，每次使用<code>V</code>前都必须先从<strong>主内存</strong><u>刷新最新的</u>值，用于保证能看见其他线程对变量V所做的修改。<ul><li>只有当线程<code>T</code>对变量<code>V</code>执行的前一个动作是<code>load</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>use</code>动作；</li><li>只有当线程<code>T</code>对变量<code>V</code>执行的后一个动作是<code>use</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>load</code>动作。</li><li>线程<code>T</code>对变量<code>V</code>的<code>use</code>动作可以认为是和线程<code>T</code>对变量<code>V</code>的<code>load</code>、<code>read</code>动作相关联的，必须连续且一起出现。</li></ul></li><li>在<strong>工作内存</strong>中，每次修改<code>V</code>后都必须<strong>立刻</strong>同步回<strong>主内存</strong>中，用于保证其他线程可以看到自己对变量V所做的修改。<ul><li>只有当线程<code>T</code>对变量<code>V</code>执行的前一个动作是<code>assign</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>store</code>动作；</li><li>只有当线程<code>T</code>对变量|V执行的后一个动作是<code>store</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>assign</code>动作。</li><li>线程<code>T</code>对变量<code>V</code>的<code>assign</code>动作可以认为是和线程<code>T</code>对变量<code>V</code>的<code>store</code>、<code>write</code>动作相关联的，必须连续且一起出现。</li></ul></li><li><code>volatile</code>修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。<ul><li>假定动作<code>A</code>是线程<code>T</code>对变量<code>V</code>实施的<code>use</code>或<code>assign</code>动作，假定动作<code>F</code>是和动作<code>A</code>相关联的<code>load</code>或<code>store</code>动 作，假定动作<code>P</code>是和动作<code>F</code>相应的对变量<code>V</code>的<code>read</code>或<code>write</code>动作；</li><li>假定动作<code>B</code>是线程<code>T</code>对变量<code>W</code>实施的<code>use</code>或<code>assign</code>动作，假定动作<code>G</code>是和动作<code>B</code>相关联的<code>load</code>或<code>store</code>动作，假定动作<code>Q</code>是和动作<code>G</code>相应的对变量<code>W</code>的<code>read</code>或<code>write</code>动作。</li><li><strong>如果<code>A</code>先于<code>B</code>，那么<code>P</code>先于<code>Q</code></strong>。</li></ul></li></ul><h4 id="2-4-针对long和double型变量的特殊规则"><a href="#2-4-针对long和double型变量的特殊规则" class="headerlink" title="2.4 针对long和double型变量的特殊规则"></a>2.4 针对long和double型变量的特殊规则</h4><p>Java内存模型要求上述八种操作都具有<code>原子性</code>， 但是对于<code>64</code>位的数据类型（<code>long</code>和<code>double</code>），在模型中特别定义了一条宽松的规定：</p><blockquote><p>允许虚拟机将<strong>没有</strong>被<code>volatile</code>修饰的<code>64</code>位数据的读写操作划分为两次<code>32</code>位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的<code>load</code>、<code>store</code>、<code>read</code>和<code>write</code>这四个操作的原子性，这就是所谓的<code>“long和double的非原子性协定”（Non-Atomic Treatment of double and long Variables）</code>。</p></blockquote><p>读取到<code>“半个变量”</code>的情况是非常罕见的，除非该数据有明确可知的线程竞争，否则在编写代码时一般不需要因为这个原因刻意把用到的<code>long</code>和<code>double</code>变量专门声明为<code>volatile</code>。</p><h4 id="2-5-原子性、可见性与有序性"><a href="#2-5-原子性、可见性与有序性" class="headerlink" title="2.5 原子性、可见性与有序性"></a>2.5 原子性、可见性与有序性</h4><p>Java内存模型是围绕着在并发过程中如何处理<code>原子性</code>、<code>可见性</code>和<code>有序性</code>这三个特征来建立的。</p><h5 id="2-5-1-原子性（Atomicity）"><a href="#2-5-1-原子性（Atomicity）" class="headerlink" title="2.5.1 原子性（Atomicity）"></a>2.5.1 <code>原子性（Atomicity）</code></h5><p>由Java内存模型来<strong>直接保证</strong>的原子性变量操作包括<code>read</code>、<code>load</code>、<code>assign</code>、<code>use</code>、<code>store</code>和<code>write</code>，基本数据类型的<strong>访问</strong>、<strong>读写</strong>都是具备原子性的。</p><p>Java内存模型提供了<code>lock</code>和<code>unlock</code>操作来满足更大范围的原子性保证，尽管虚拟机未把<code>lock</code>和<code>unlock</code>操作直接开放给用户使用，但是却提供了更高层次的字节码指令<code>monitorenter</code>和<code>monitorexit</code>来隐式地使用这两个操作。这两个字节码指令反映到Java 代码中就是同步块——<code>synchronized</code>关键字，因此在<code>synchronized</code>块之间的操作也具备原子性。</p><h5 id="2-5-2-可见性（Visibility）"><a href="#2-5-2-可见性（Visibility）" class="headerlink" title="2.5.2 可见性（Visibility）"></a>2.5.2 <code>可见性（Visibility）</code></h5><p>可见性就是指<u>当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改</u>。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。</p><blockquote><p>volatile的特殊规则保证了新值能<strong>立即同步到主内存</strong>，以及每次使用前<strong>立即从主内存刷新</strong>。</p></blockquote><p>除了<code>volatile</code>之外，<code>synchronized</code>和<code>final</code>两个关键字也能实现可见性。</p><ul><li><code>synchronized</code>同步块的可见性是由<code>“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”</code>这条规则获得的。</li><li><code>final</code>关键字的可见性是指：被<code>final</code>修饰的字段在构造器中一旦被初始化完成，并且构造器没有把<code>“this”</code>的引用传递出去，那么在其他线程中就能看见<code>final</code>字段的值。</li></ul><h5 id="2-5-3-有序性（Ordering）"><a href="#2-5-3-有序性（Ordering）" class="headerlink" title="2.5.3 有序性（Ordering）"></a>2.5.3 <code>有序性（Ordering）</code></h5><p>Java程序中天然的有序性即：</p><ul><li>如果在本线程内观察，所有的操作都是有序的，指<code>“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）</code>；</li><li>如果在一个线程中观察另一个线程， 所有的操作都是无序的，是指<code>“指令重排序”</code>现象和<code>“工作内存与主内存同步延迟”</code>现象。</li></ul><p>Java语言提供了<code>volatile</code>和<code>synchronized</code>两个关键字来保证线程之间操作的有序性。</p><h4 id="2-6-先行发生原则"><a href="#2-6-先行发生原则" class="headerlink" title="2.6 先行发生原则"></a>2.6 先行发生原则</h4><p>Java语言的<code>“先行发生”（Happens-Before）原则</code>，是判断<u>数据是否存在竞争</u>，<u>线程是否安全</u>的手段。</p><blockquote><p><code>先行发生</code>是Java内存模型中定义的两项操作之间的<code>偏序关系</code>，比如说<code>操作A</code>先行发生于<code>操作B</code>，其实就是说在发生<code>操作B</code>之前，<code>操作A</code>产生的影响能被<code>操作B</code>观察到，<code>“影响”</code>包括<u>修改了内存中共享变量的值</u>、<u>发送了消息</u>、<u>调用了方法</u>等。</p></blockquote><p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系<u>无须任何同步器协助就已经存在</u>，可以在编码中直接使用。</p><ul><li><code>程序次序规则（Program Order Rule）</code>：在一个线程内，按照<strong><u>控制流顺序</u></strong>，书写在前面的操作先行发生于书写在后面的操作。</li><li><code>管程锁定规则（Monitor Lock Rule）</code>：一个<code>unlock</code>操作先行发生于后面对<strong>同一个锁</strong>的<code>lock</code>操作。</li><li><code>volatile变量规则（Volatile Variable Rule）</code>：对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量 的读操作。</li><li><code>线程启动规则（Thread Start Rule）</code>：<code>Thread</code>对象的<code>start()</code>方法先行发生于此线程的每一个动作。</li><li><code>线程终止规则（Thread Termination Rule）</code>：线程中的所有操作都先行发生于对此线程的终止检测，可以通过<code>Thread::join()</code>方法是否结束、<code>Thread::isAlive()</code>的返回值等手段检测线程是否已经终止执行。</li><li><code>线程中断规则（Thread Interruption Rule）</code>：对线程<code>interrupt()</code>方法的调用先行发生于<u>被中断线程的代码检测到中断事件</u>的发生，可以通过<code>Thread::interrupted()</code>方法检测到是否有中断发生。</li><li><code>对象终结规则（Finalizer Rule）</code>：一个对象的初始化完成（构造函数执行结束）先行发生于它的<code>finalize()</code>方法的开始。</li><li><code>传递性（Transitivity）</code>：如果<code>操作A</code>先行发生于<code>操作B</code>，<code>操作B</code>先行发生于<code>操作C</code>，那就可以得出<u><code>操作A</code>先行发生于<code>操作C</code></u>的结论。</li></ul><p><code>时间先后顺序</code>与<code>先行发生原则</code>之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须<u><strong>以先行发生原则为准</strong></u>。</p><h3 id="3-Java与线程"><a href="#3-Java与线程" class="headerlink" title="3. Java与线程"></a>3. Java与线程</h3><p>线程是比进程<strong>更轻量级</strong>的<u>调度执行单位</u>，线程可以把一个进程的<code>资源分配</code>和<code>执行调度</code>分开，各个线程既可以<strong>共享进程资源</strong>（内存地址、文件I/O等），又可以<strong>独立调度</strong>。目前线程是Java里面进行处理器资源调度的<strong>最基本单位</strong>。</p><h4 id="3-1-线程的实现"><a href="#3-1-线程的实现" class="headerlink" title="3.1 线程的实现"></a>3.1 线程的实现</h4><p>实现线程主要有三种方式：使用<code>内核线程实现（1：1实现）</code>，使用<code>用户线程实现（1：N实现）</code>，使用用户线程加轻量级进程<code>混合实现（N：M实现）</code>。</p><h5 id="3-1-1-内核线程实现"><a href="#3-1-1-内核线程实现" class="headerlink" title="3.1.1 内核线程实现"></a>3.1.1 内核线程实现</h5><p><code>内核线程（Kernel-Level Thread，KLT）</code>就是<strong><u>直接由操作系统<code>内核（Kernel）</code>支持的线程</u></strong>。</p><blockquote><p>这种线程由内核来完成<code>线程切换</code>，内核通过操纵<code>调度器（Scheduler）</code>对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为<code>多线程内核（Multi-Threads Kernel）</code>。</p></blockquote><p>程序一般<strong>不会直接使用内核线程</strong>，而是使用内核线程的一种高级接口——<code>轻量级进程（Light Weight Process，LWP）</code>，由于每个轻量级进程都由一个内核线程支持，因此<strong>只有先支持内核线程，才能有轻量级进程</strong>。这种轻量级进程与内核线程之间<code>1：1</code>的关系称为一对一的线程模型。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/KernelLevelThread.PNG" alt="内核线程实现"></p><ul><li>优点：每个轻量级进程都成为一个<code>独立的调度单元</code>，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作。</li><li>局限性：<ul><li>由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的<strong>代价相对较高</strong>，需要在<code>用户态（User Mode）</code>和<code>内核态（Kernel Mode）</code>中来回切换。</li><li>每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要<strong>消耗一定的内核资源</strong>，因此一个系统支持轻量级进程的<strong>数量是有限</strong>的。</li></ul></li></ul><h5 id="3-1-2-用户线程实现"><a href="#3-1-2-用户线程实现" class="headerlink" title="3.1.2 用户线程实现"></a>3.1.2 用户线程实现</h5><p><strong>广义上</strong>，一个线程只要不是内核线程，都可以认为是<code>用户线程（User Thread，UT）</code>的一种。</p><p><strong>狭义上</strong>，用户线程指的是<strong>完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的</strong>。</p><blockquote><p>用户线程的建立、同步、销毁和调度完全在<code>用户态</code>中完成，<strong><u>不需要内核的帮助</u></strong>。</p></blockquote><p>这种进程与用户线程之间<code>1：N</code>的关系称为一对多的线程模型。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/UserThread.PNG" alt="用户线程实现"></p><ul><li>用优势在于不需要系统内核支援，如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量。</li><li>劣势也在于没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理。使用用户线程实现的程序通常都比较复杂，除了有明确的需求外，一般的应用程序都不倾向使用用户线程。但近年来许多以高并发为卖点的编程语言普遍支持了用户线程，譬如<code>Golang</code>、<code>Erlang</code>等。</li></ul><h5 id="3-1-3-混合实现"><a href="#3-1-3-混合实现" class="headerlink" title="3.1.3 混合实现"></a>3.1.3 混合实现</h5><p>线程除了<code>依赖内核线程实现</code>和<code>完全由用户程序自己实现</code>之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为<code>N：M</code>实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/HybridThread.PNG" alt="混合实现"></p><ul><li><strong><code>用户线程</code></strong><u>完全建立在用户空间中</u>，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。</li><li><strong><code>轻量级进程</code></strong>则作为<strong><code>用户线程</code></strong>和<strong><code>内核线程</code></strong>之间的桥梁， 这样可以<u>使用内核提供的线程调度功能及处理器映射</u>，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。</li></ul><h4 id="3-2-Java线程调度"><a href="#3-2-Java线程调度" class="headerlink" title="3.2 Java线程调度"></a>3.2 Java线程调度</h4><p>线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种：</p><ul><li><code>协同式（Cooperative Threads-Scheduling）线程调度</code>，线程的执行时间<u>由线程本身来控制</u>，线程把自己的工作执行完之后主动通知系统切换到另外一个线程上去。<ul><li>好处是实现简单，切换操作对线程自己是可知的，一般没有<code>线程同步</code>的问题。</li><li>坏处是<u><strong>线程执行时间不可控制</strong></u>，甚至如果线程一直不告知系统进行线程切换，那么程序就会一直阻塞。</li></ul></li><li><code>抢占式（Preemptive Threads-Scheduling）线程调度</code>，每个线程将<u>由系统来分配执行时间</u>，线程的切换不由线程本身来决定。<ul><li>好处是线程的<strong>执行时间是系统可控的</strong>，不会有一个线程导致整个进程甚至整个系统阻塞的问题。</li></ul></li></ul><p>Java使用的线程调度方式就是抢占式调度。虽然Java线程调度是系统自动完成的，但可以设置<code>线程优先级</code>给操作系统提供调度建议。Java设置了<code>10</code>个级别的线程优先级（<code>Thread.MIN_PRIORITY</code>至<code>Thread.MAX_PRIORITY</code>）。在两个线程同时处于<code>Ready</code>状态时，<strong>优先级越高的线程越容易被系统选择执行</strong>。</p><p><code>Windows</code>中就只有<code>七</code>种优先级，比Java线程优先级少，所以会出现几个线程优先级对应到同一个操作系统优先级的情况。</p><blockquote><p><code>Windows</code>平台的虚拟机中使用了除<code>THREAD_PRIORITY_IDLE</code>之外的其余<code>6</code>种线程优先级，因此在<code>Windows</code>下设置线程优先级为<code>1</code>和<code>2</code>、<code>3</code> 和<code>4</code>、<code>6</code>和<code>7</code>、<code>8</code>和<code>9</code>的效果是<strong>完全相同</strong>的。</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/THREAD_PRIORITY.PNG" alt="Java线程优先级与Windows线程优先级之间的对应关系"></p><p>线程优先级并不是一项稳定的调节手段，优先级可能会被系统自行改变，所以不能在程序中通过优先级来完全准确判断一组状态都为<code>Ready</code>的线程将会先执行哪一个。</p><h4 id="3-3-状态转换"><a href="#3-3-状态转换" class="headerlink" title="3.3 状态转换"></a>3.3 状态转换</h4><p>Java定义了<code>6</code>种线程状态，任意一个时间点中，一个线程<strong>只能有且只有其中的一种状态</strong>，可以通过特定的方法在不同状态之间转换：</p><ul><li><code>新建（New）</code>：创建后尚未启动的线程处于这种状态。</li><li><code>运行（Runnable）</code>：包括操作系统线程状态中的<code>Running</code>和<code>Ready</code>，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。</li><li><code>无限期等待（Waiting）</code>：处于这种状态的线程不会被分配处理器执行时间，它们要等待<strong>被其他线程显式唤醒</strong>。以下方法会让线程陷入无限期的等待状态：<ul><li>没有设置<code>Timeout</code>参数的<code>Object::wait()</code>方法；</li><li>没有设置<code>Timeout</code>参数的<code>Thread::join()</code>方法；</li><li><code>LockSupport::park()</code>方法。</li></ul></li><li><code>限期等待（Timed Waiting）</code>：处于这种状态的线程也不会被分配处理器执行时间，不过<strong>无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒</strong>。以下方法会让线程进入限期等待状态：<ul><li><code>Thread::sleep()</code>方法；</li><li>设置了<code>Timeout</code>参数的<code>Object::wait()</code>方法；</li><li>设置了<code>Timeout</code>参数的<code>Thread::join()</code>方法； </li><li><code>LockSupport::parkNanos()</code>方法；</li><li><code>LockSupport::parkUntil()</code>方法。</li></ul></li><li><code>阻塞（Blocked）</code>：线程被阻塞，<code>“阻塞状态”</code>与<code>“等待状态”</code>的区别是：<ul><li><code>“阻塞状态”</code>在等待着获取到一个<code>排它锁</code>，这个事件将在另外一个线程放弃这个锁的时候发生；</li><li><code>“等待状态”</code>则是在等待一段时间，或者唤醒动作的发生。</li><li>在程序等待进入同步区域的时候，线程将进入这种状态。</li></ul></li><li><code>结束（Terminated）</code>：已终止线程的线程状态，线程已经结束执行</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ThreadState.PNG" alt="线程状态转换关系"></p><h3 id="4-Java与协程"><a href="#4-Java与协程" class="headerlink" title="4. Java与协程"></a>4. Java与协程</h3><h4 id="4-1-内核线程的局限"><a href="#4-1-内核线程的局限" class="headerlink" title="4.1 内核线程的局限"></a>4.1 内核线程的局限</h4><ul><li><code>1：1</code>的内核线程模型是如今Java虚拟机线程实现的<strong>主流选择</strong>，但是天然的缺陷是<strong>切换、调度成本高昂</strong>，系统能<strong>容纳的线程数量也很有限</strong>。现在在每个请求本身的执行时间变得很短、数量变得很多的前提下， 用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费。</li><li>传统的<code>Java Web</code>服务器的线程池的容量通常在几十个到两百之间，当以百万计的请求往线程池里面灌时，系统即使能处理得过来，但其中的切换损耗也是相当可观的。</li></ul><h4 id="4-2-协程的复苏"><a href="#4-2-协程的复苏" class="headerlink" title="4.2 协程的复苏"></a>4.2 协程的复苏</h4><p>内核线程的调度成本主要来自于<strong>用户态与核心态之间的状态转换</strong>，而这两种状态转换的开销主要来自于<strong><code>响应中断</code>、<code>保护</code>和<code>恢复执行现场</code></strong>的成本。</p><blockquote><p>线程A -&gt; 系统中断 -&gt; 线程B</p></blockquote><p>当中断发生，从<code>线程A</code>切换到<code>线程B</code>去执行之前，操作系统首先要把<code>线程A</code>的上下文数据妥善保管好，然后把寄存器、内存分页等恢复到<code>线程B</code>挂起时候的状态，这样<code>线程B</code>被重新激活后才能仿佛从来没有被挂起过。这种<code>保护和恢复现场</code>的工 作，免不了涉及一系列数据在各种寄存器、缓存中的来回拷贝，当然不可能是一种轻量级的操作。</p><p>最初多数的用户线程是被设计成<code>协同式调度 （Cooperative Scheduling）</code>的，它也被叫做<code>“协程”（Coroutine）</code>。又由于这时候的协程会<u>完整地做调用栈的保护、恢复工作</u>，所以也被称为<code>“有栈协程”（Stackfull Coroutine）</code>。后来又出现比<code>有栈协程</code>恢复调用栈要轻量得多<code>“无栈协程”（Stackless Coroutine）</code>。</p><blockquote><p>一个协程的栈通常在<code>几百个字节</code>到<code>几KB</code>之间，所以Java虚拟机里线程池容量达到两百就已经不算小了，而很多支持协程的应用中，同时并存的协程数量可<code>以十万</code>计。</p></blockquote><h4 id="4-3-纤程（Fiber）"><a href="#4-3-纤程（Fiber）" class="headerlink" title="4.3 纤程（Fiber）"></a>4.3 纤程（Fiber）</h4><p>对于有栈协程，有一种特例实现名为<code>纤程（Fiber）</code>。在新并发模型下，一段使用纤程并发的代码会被分为两部分：</p><ul><li><code>执行过程（Continuation）</code>，主要用于维护执行现场，保护、恢复上下文状态；</li><li><code>调度器（Scheduler）</code>，负责编排所有要执行的代码的顺序。</li></ul><p>将调度程序与执行过程分离的好处是，用户可以选择自行控制其中的一个或者多个，而且Java中现有的调度器也可以被直接重用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;并发处理是人类压榨计算机运算能力的最有力武器。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--11 后端编译与优化</title>
    <link href="https://wuyunjie.top/2021/06/03/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_11_Back-end_compilation_and_optimization.html"/>
    <id>https://wuyunjie.top/2021/06/03/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_11_Back-end_compilation_and_optimization.html</id>
    <published>2021-06-03T14:31:10.000Z</published>
    <updated>2021-06-03T14:31:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>后端编译器的编译速度及编译结果质量高低，是衡量Java虚拟机性能最重要的一个指标。<br><a id="more"></a></p></blockquote><p>如果把字节码看作是程序语言的一种<code>中间表示形式（Intermediate Representation，IR）</code>， 那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的<code>后端</code>。</p><h3 id="1-即时编译器"><a href="#1-即时编译器" class="headerlink" title="1. 即时编译器"></a>1. 即时编译器</h3><p>目前主流的两款商用Java虚拟机（<code>HotSpot</code>、<code>OpenJ9</code>）里，Java程序最初都是通过<code>解释器（Interpreter）</code>进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为<code>“热点代码”（Hot Spot Code）</code>，为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为<strong><code>即时编译器</code></strong>。</p><h4 id="1-1-解释器与编译器"><a href="#1-1-解释器与编译器" class="headerlink" title="1.1 解释器与编译器"></a>1.1 解释器与编译器</h4><p>目前主流的商用Java虚拟机都采用<strong><u>解释器与编译器并存</u></strong>的运行架构，解释器与编译器两者各有优势：</p><ul><li>当程序需要<strong>迅速启动和执行</strong>的时候，解释器可以首先发挥作用，<u>省去编译的时间，立即运行</u>。</li><li>当程序启动后，随着时间的推移，编译器逐渐发挥作用，<u>把越来越多的代码编译成本地代码</u>，这样可以<strong>减少解释器的中间损耗，获得更高的执行效率</strong>。</li><li>当程序运行环境中<strong>内存资源限制较大</strong>，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。</li><li>解释器还可以作为编译器激进优化时后备的<code>“逃生门”</code>，让编译器根据概率选择一些不能保证所有情况都正确，但<u>大多数时候都能提升运行速度的优化手段</u>，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现<code>“罕见陷阱”（Uncommon Trap）</code>时可以通过<code>逆优化（Deoptimization）</code>退回到解释状态继续执行。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/InteractionBetweenInterpreterAndCompiler.PNG" alt="解释器与编译器的交互"></p><p><code>HotSpot</code>虚拟机中内置了两个（或三个）<code>即时编译器</code>：</p><ul><li>其中两个编译器存在已久，分别被称为<code>“客户端编译器”（Client Compiler）</code>和<code>“服务端编译器”（Server Compiler）</code>，或者简称为<code>C1编译器</code>和<code>C2编译器</code>（部分资料和JDK源码中<code>C2</code>也叫<code>Opto</code>编译器）</li><li>第三个是在<code>JDK 10</code>时才出现的、长期目标是代替<code>C2</code>的<code>Graal</code>编译器。目前还处于实验状态。</li></ul><p><code>分层编译（Tiered Compilation）</code>的工作模式出现以前，<code>HotSpot</code>虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作。</p><ul><li>解释器与编译器搭配使用的方式在虚拟机中被称为<code>“混合模式”（Mixed Mode）</code></li><li>用户可以使用参数<code>“-Xint”</code>强制虚拟机运行于<code>“解释模式”（Interpreted Mode）</code>，这时候编译器<strong>完全不介入</strong>工作，全部代码都使用解释方式执行。</li><li>也可以使用参数<code>“-Xcomp”</code>强制虚拟机运行于<code>“编译模式”（Compiled Mode）</code>，这时候将<strong>优先</strong>采用编译方式执行程序，但是<u>解释器仍然要在编译无法进行的情况下介入执行过程</u>。</li></ul><p>为了在<u>程序启动响应速度与运行效率</u>之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了<code>分层编译</code>的功能，分层编译根据编译器<u><strong>编译、优化的规模与耗时</strong></u>，划分出不同的编译层次：</p><ul><li>第0层。程序<strong>纯解释执行</strong>，并且解释器不开启<code>性能监控功能（Profiling）</code>。</li><li>第1层。使用<code>客户端编译器</code>将字节码编译为本地代码来运行，进行简单可靠的<u>稳定优化</u>，<u>不开启</u>性能监控功能。</li><li>第2层。使用<code>客户端编译器</code>执行，仅开启<u>方法及回边次数统计</u>等<strong>有限</strong>的性能监控功能。</li><li>第3层。使用<code>客户端编译器</code>执行，开启<strong>全部</strong>性能监控，还会收集如<u>分支跳转、虚方法调用版本</u>等全部的统计信息。</li><li>第4层。使用<code>服务端编译器</code>将字节码编译为本地代码，服务端编译器会启用更多<u>编译耗时更长的优化</u>，还会根据性能监控信息进行一些不可靠的<u>激进优化</u>。</li></ul><p>实施分层编译后，解释器、客户端编译器和服务端编译器就会<strong>同时工作</strong>，热点代码都可能会被多次编译：</p><ul><li>用客户端编译器获取更高的编译速度</li><li>用服务端编译器来获取更好的编译质量</li><li>在解释执行的时候也无须额外承担收集性能监控信息的任务</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/TieredCompilation.PNG" alt="分层编译的交互关系"></p><h4 id="1-2-编译对象与触发条件"><a href="#1-2-编译对象与触发条件" class="headerlink" title="1.2 编译对象与触发条件"></a>1.2 编译对象与触发条件</h4><h5 id="1-2-1-热点代码"><a href="#1-2-1-热点代码" class="headerlink" title="1.2.1 热点代码"></a>1.2.1 热点代码</h5><p>在运行过程中会被即时编译器编译的目标是<code>“热点代码”</code>，这里所指的热点代码主要有两类：</p><ul><li>被多次调用的<strong>方法</strong>。</li><li>被多次执行的<strong>循环体</strong>。</li></ul><p>对于这两种情况，编译的目标对象都是<strong><u>整个方法体</u></strong>，而不会是单独的循环体。由循环体所触发的热点只是方法的一部分，但编译器依然必须以整个方法作为编译对象，只是执行入口会稍有不同，编译时会传入执行入口点<code>字节码序号（Byte Code Index，BCI）</code>。</p><blockquote><p><code>“栈上替换”（On Stack Replacement，OSR）</code>，即方法的栈帧还在栈上，方法就被替换了。</p></blockquote><h5 id="1-2-2-热点探测判定方式"><a href="#1-2-2-热点探测判定方式" class="headerlink" title="1.2.2 热点探测判定方式"></a>1.2.2 热点探测判定方式</h5><p>要知道某段代码是不是<code>热点代码</code>，是不是需要触发<code>即时编译</code>，这个行为称为<code>“热点探测”（Hot Spot Code Detection）</code>，目前主流的热点探测判定方式有两种：</p><ul><li><code>基于采样的热点探测（Sample Based Hot Spot Code Detection）</code>。采用这种方法的虚拟机会<u>周期性地检查各个线程的<strong>调用栈顶</strong>，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是<code>“热点方法”</code></u>。<ul><li><strong>好处</strong>是实现简单高效，可以很容易地获取方法调用关系（将调用堆栈展开即可）</li><li><strong>缺点</strong>是很难精确地确认一个方法的热度，容易因为<strong>受到线程阻塞或别的外界因素的影响而扰乱热点探测</strong>。 </li></ul></li><li><code>基于计数器的热点探测（Counter Based Hot Spot Code Detection）</code>。采用这种方法的虚拟机会<u>为每个方法（甚至是代码块）建立<strong>计数器</strong>，统计方法的执行次数，如果执行次数超过一定的<code>阈值</code>就认为它是<code>“热点方法”</code>。</u><ul><li><strong>缺点</strong>是需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。</li><li><strong>优点</strong>是统计结果相对来说更加精确严谨。</li></ul></li></ul><h5 id="1-2-3-基于计数器的热点探测"><a href="#1-2-3-基于计数器的热点探测" class="headerlink" title="1.2.3 基于计数器的热点探测"></a>1.2.3 基于计数器的热点探测</h5><p><code>HotSpot虚拟机</code>中使用的是基于计数器的热点探测，<code>HotSpot</code>为每个方法准备了两类计数器：</p><ul><li><p><code>方法调用计数器（Invocation Counter）</code>。这个计数器就是<u>用于统计方法被调用的次数</u>。</p><ul><li><p>它的<code>默认阈值</code>在<strong>客户端模式</strong>下是<code>1500</code>次，在<strong>服务端模式</strong>下是<code>10000</code>次，这个阈值可以通过虚拟机参数<code>-XX：CompileThreshold</code>来人为设定。</p></li><li><p>当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的版本</p><ul><li>如果存在，则优先使用编译后的本地代码来执行。</li><li>如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后判断<u><strong>方法调用计数器与回边计数器值之和</strong></u>是否超过方法调用计数器的阈值。</li><li>一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。当编译工作完成后，这个方法的调用入口地址就会被系统自动改写成新值</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/InvocationCounter.PNG" alt="方法调用计数器触发即时编译"></p></li><li><p>方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<u>一段时间之内方法被调用的次数</u>。</p><ul><li>超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为<code>方法调用计数器热度的衰减（Counter Decay）</code>，而这段时间就称为此方法统计的<code>半衰周期（Counter Half Life Time）</code>。</li><li>热度衰减的动作是<u>在虚拟机进行垃圾收集时顺便进行的</u>。</li></ul></li></ul></li></ul><ul><li><p><code>回边计数器（Back Edge Counter）</code>，<code>“回边”</code>的意思就是指在循环边界往回跳转。这个计数器就是用于<u>统计一个方法中循环体代码执行的次数</u>。</p><ul><li><p>在字节码中遇到控制流向后跳转的指令就称为<code>“回边（Back Edge）</code>”，建立回边计数器统计的目的是为了<u>触发栈上的替换编译</u>。</p></li><li><p>当前的<code>HotSpot</code>虚拟机必须设置参数<code>-XX:OnStackReplacePercentage</code>来<strong>间接调整</strong>回边计数器的阈值，其计算公式有如下两种：</p><ul><li>虚拟机运行在<strong>客户端模式</strong>下，回边计数器阈值计算公式为：<script type="math/tex; mode=display">\frac{方法调用计数器阈值 \times OSR比率}{100}</script></li></ul><p><code>OSR比率（-XX：OnStackReplacePercentage）</code>默认值为<code>933</code></p><ul><li>虚拟机运行在<strong>服务端模式</strong>下，回边计数器阈值的计算公式为：</li></ul><script type="math/tex; mode=display">\frac{方法调用计数器阈值 \times (OSR比率-解释器监控比率)}{100}</script><p>其中<code>-XX：OnStackReplacePercentage</code>默认值为<code>140</code>，<code>- XX：InterpreterProfilePercentage</code>默认值为<code>33</code>。</p></li><li><p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本</p><ul><li>如果有，将会优先执行已编译的代码</li><li>否则就把回边计数器的值加一，然后判断<u><strong>方法调用计数器与回边计数器值之和</strong></u>是否超过回边计数器的阈值。</li><li>若超过阈值，将会提交一个<strong>栈上替换</strong>编译请求， 并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/BackEdgeCounter.PNG" alt="回边计数器触发即时编译"></p></li><li><p>回边计数器<u>没有计数热度衰减的过程</u>，因此这个计数器统计的就是该方法循环执行的<code>绝对次数</code>。</p></li></ul></li></ul><h4 id="1-3-编译过程"><a href="#1-3-编译过程" class="headerlink" title="1.3 编译过程"></a>1.3 编译过程</h4><p>虚拟机在编译器还未完成编译之前将按照解释方式继续执行代码，而编译动作则在<strong>后台的编译线程</strong>中进行。</p><h5 id="1-3-1-客户端编译器"><a href="#1-3-1-客户端编译器" class="headerlink" title="1.3.1 客户端编译器"></a>1.3.1 客户端编译器</h5><p>对于<strong>客户端编译器</strong>来说，主要的关注点在于<u>局部性的优化</u>，而放弃了许多耗时较长的全局优化手段：</p><ul><li>第一个阶段，一个<code>平台独立的前端</code>将字节码构造成一种<code>高级中间代码表示（High-Level Intermediate Representation，HIR</code>），即<u><strong>与目标机器指令集无关</strong></u>的中间表示。<ul><li><code>HIR</code>使用<code>静态单分配（Static Single Assignment，SSA）</code>的形式来代表代码值。</li><li>在字节码被构造成<code>HIR</code>之前，编译器已经会在字节码上完成一部分基础优化，如<u>方法内联</u>、<u>常量传播</u>等优。</li></ul></li><li>第二个阶段，一个<code>平台相关的后端</code>从<code>HIR</code>中产生<code>低级中间代码表示（Low-Level Intermediate Representation，LIR</code>，即<u><strong>与目标机器指令集相关</strong></u>的中间表示。<ul><li>而在此之前会在<code>HIR</code>上完成一些优化，如<u>空值检查消除</u>、<u>范围检查消除</u>等。</li></ul></li><li>最后的阶段，在<code>平台相关的后端</code>使用<code>线性扫描算法（Linear Scan Register Allocation）</code>在<code>LIR</code>上分配寄存器，并在<code>LIR</code>上做<code>窥孔（Peephole）</code>优化，然后产生机器代码。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ClientCompiler.PNG" alt="Client Compiler架构"></p><h5 id="1-3-2-服务端编译器"><a href="#1-3-2-服务端编译器" class="headerlink" title="1.3.2 服务端编译器"></a>1.3.2 服务端编译器</h5><p>服务端编译器是一个能容忍很高优化复杂度的高级编译器，会执行大部分经典的优化动作，如：</p><ul><li>无用代码消除（Dead Code Elimination）</li><li>循环展开（Loop Unrolling）</li><li>循环表达式外提（Loop Expression Hoisting）</li><li>消除公共子表达式（Common Subexpression Elimination）</li><li>常量传播（Constant Propagation）</li><li>基本块重排序（Basic Block Reordering）</li><li>等</li></ul><p>还会实施一些<strong>与Java语言特性密切相关的优化技术</strong>，如：</p><ul><li>范围检查消除（Range Check Elimination）</li><li>空值检查消除（Null Check Elimination）</li><li>等</li></ul><p>还可能根据解释器或客户端编译器提供的性能监控信息，进行一些<strong>不稳定的预测性激进优化</strong>，如：</p><ul><li>守护内联（Guarded Inlining）</li><li>分支频率预测 （Branch Frequency Prediction）</li><li>等</li></ul><p>服务端编译采用的<strong>寄存器分配器</strong>是一个<code>全局图着色分配器</code>，它可以充分利用某些处理器架构（如<code>RISC</code>）上的大寄存器集合。</p><h4 id="1-4-实战：查看及分析即时编译结果"><a href="#1-4-实战：查看及分析即时编译结果" class="headerlink" title="1.4 实战：查看及分析即时编译结果"></a>1.4 实战：查看及分析即时编译结果</h4><p>从外部观察Java虚拟机的即时编译行为。</p><ul><li>可以使用参数<code>-XX:+PrintCompilation</code>要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来。如下图所示（其中带有<code>“%”</code>的输出说明是由回边计数器触发的栈上替换编译）</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testJIT1.PNG" alt="被即时编译的代码(部分)"></p><ul><li><p>加上参数<code>-XX:+PrintInlining</code>要求虚拟机输出方法内联信息</p></li><li><p>可以使用<code>-XX:+PrintAssembly</code>参数要求虚拟机打印编译方法的汇编代码。如果没有<code>HSDIS</code>插件支持，也可以使用<code>-XX：+PrintOptoAssembly</code>（用于服务端模式的虚拟机） 或<code>-XX：+PrintLIR</code>（用于客户端模式的虚拟机）来输出比较接近最终结果的中间代码表示</p></li><li>可以使用参数<code>-XX：+PrintCFGToFile</code>（用于客户端编译器）或<code>-XX：PrintIdealGraphFile</code>（用于服务端编译器）要求Java虚拟机将编译过程中各个阶段的数据输出到文件中。可以使用<code>Java HotSpot Client Compiler Visualizer</code>（用于分析客户端编译器）或<code>Ideal Graph Visualizer</code>（用于分析服务端编译器）打开这些数据文件进行分析。</li></ul><h3 id="2-提前编译器"><a href="#2-提前编译器" class="headerlink" title="2. 提前编译器"></a>2. 提前编译器</h3><h4 id="2-1-提前编译的优劣得失"><a href="#2-1-提前编译的优劣得失" class="headerlink" title="2.1 提前编译的优劣得失"></a>2.1 提前编译的优劣得失</h4><p><code>提前编译</code>的研究有着两条明显的分支：</p><ul><li>一条分支是做与传统<code>C、C++</code>编译器类似的，<u>在程序运行之前把程序代码编译成机器码的静态翻译</u>工作。<ul><li>这是传统的提前编译应用形式，在Java中存在的价值是为了解决<u><strong>即时编译要占用程序运行时间和运算资源</strong></u>。</li></ul></li><li>另一条分支是<u>把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码时直接把它加载进来使用</u>。<ul><li>这种提前编译被称为<code>动态提前编译（Dynamic AOT）</code>或者<code>即时编译缓存（JIT Caching）</code>。</li><li>本质是给即时编译器做<strong>缓存加速</strong>，去改善Java程序的启动时间，以及需要一段时间预热后才能到达最高性能的问题。</li></ul></li></ul><p>即时编译器相对于提前编译器的天然优势：</p><ul><li><code>性能分析制导优化（Profile-Guided Optimization，PGO）</code>。</li><li><code>激进预测性优化（Aggressive Speculative Optimization）</code>，这也已经成为很多即时编译优化措施的基础。</li><li><code>链接时优化（Link-Time Optimization，LTO）</code>，Java语言天生就是动态链接的，一个个Class文件在运行期被加载到虚拟机内存当中，然后在即时编译器里产生优化后的本地代码。</li></ul><h4 id="2-2-实战：Jaotc的提前编译"><a href="#2-2-实战：Jaotc的提前编译" class="headerlink" title="2.2 实战：Jaotc的提前编译"></a>2.2 实战：<code>Jaotc</code>的提前编译</h4><p><code>JDK 9</code>引入了用于支持对Class文件和模块进行提前编译的工具<code>Jaotc</code>，以减少程序的启动时间和到达全速性能的预热时间，但这项功能必须针对特定物理机器和目标虚拟机的运行参数来使用。</p><p><code>Jaotc</code>做的提前编译属于<code>“第二条分支”</code>，即做即时编译的缓存；而<code>Substrate VM</code>则是选择的<code>“第一条分支”</code>，做的是传统的静态提前编译。</p><h3 id="3-编译器优化技术"><a href="#3-编译器优化技术" class="headerlink" title="3. 编译器优化技术"></a>3. 编译器优化技术</h3><p>编译器的目标虽然是做由程序代码翻译为本地机器码的工作，但<strong>输出代码优化质量的高低</strong>才是决定编译器优秀与否的关键。</p><h4 id="3-1-优化技术概览"><a href="#3-1-优化技术概览" class="headerlink" title="3.1 优化技术概览"></a>3.1 优化技术概览</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/PerformanceTacticIndex1.PNG" alt="即时编译器优化技术一览"></p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/PerformanceTacticIndex2.PNG" alt="即时编译器优化技术一览（续）"></p><p>即时编译器对这些代码优化变换是建立在<strong>代码的中间表示或者是机器码</strong>之上的，而不是直接在Java源码上去做的。使用Java语言的语法来表示优化技术所发挥的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优化前的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">y = b.get();</span><br><span class="line"><span class="comment">// ...do stuff...</span></span><br><span class="line">z = b.get();</span><br><span class="line">sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个要进行的优化是<code>方法内联</code>，它的主要目的有两个：</p><ul><li>一是去除方法调用的成本（如查找方法版本、建立栈帧等）；</li><li>二是为其他优化建立良好的基础。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内联后的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    z = b.value;</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步进行<code>冗余访问消除（Redundant Loads Elimination）</code>，也可以把这项优化看作一种<code>公共子表达式消除（Common Subexpression Elimination）</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冗余访问消除的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    z = y;</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步进行<code>复写传播（Copy Propagation）</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复写传播的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    y = y;</span><br><span class="line">    sum = y + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步进行<code>无用代码消除（Dead Code Elimination）</code>，无用代码可能是<u>永远不会被执行的代码</u>，也可能是<u>完全没有意义的代码</u>，因此它又被称为<code>“Dead Code”</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行无用代码消除的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    sum = y + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四种具有代表性的优化技术：</p><ul><li>最重要的优化技术之一：方法内联。</li><li>最前沿的优化技术之一：逃逸分析。</li><li>语言无关的经典优化技术之一：公共子表达式消除。</li><li>语言相关的经典优化技术之一：数组边界检查消除。</li></ul><h4 id="3-2-方法内联"><a href="#3-2-方法内联" class="headerlink" title="3.2 方法内联"></a>3.2 方法内联</h4><p>内联被业内戏称为<code>优化之母</code>，因为除了消除方法调用的成本之外，它更重要的意义是<u><strong>为其他优化手段建立良好的基础</strong></u>。</p><blockquote><p>方法内联的优化行为可以理解为<u><strong>把目标方法的代码原封不动地“复制”到发起调用的方法之中，避免发生真实的方法调用</strong></u>。但Java的虚方法调用都必须在运行时进行方法接收者的多态选择，它们都有可能存在多于一个版本的方法接收者，编译器静态地去做内联的时候很难确定应该使用哪个方法版本。</p></blockquote><p>为了解决虚方法的内联问题，Java虚拟机引入了<code>类型继承关系分析（Class Hierarchy Analysis，CHA）</code>技术。</p><blockquote><p>是<code>整个应用程序范围内</code>的类型分析技术，用于确定在目前已加载的类中，<u>某个接口是否有多于一种的实现</u>、<u>某个类是否存在子类</u>、<u>某个子类是否覆盖了父类的某个虚方法</u>等信息。</p></blockquote><ul><li>如果是非虚方法，直接进行内联；</li><li>如果是虚方法，则会向<code>CHA</code>查询此方法在当前程序状态下是否真的有多个目标版本可供选择<ul><li>如果查询到只有一个版本，那就可以假设<em>“应用程序的全貌就是现在运行的这个样子”</em>来进行内联，这种内联被称为<code>守护内联（Guarded Inlining）</code>。由于Java程序是动态连接的，可能会加载到新类型从而改变<code>CHA</code>结论，因此这种内联属于<code>激进预测性优化</code>，必须预留<code>“逃生门”</code>，即当假设条件不成立时的<code>“退路”（Slow Path）</code>。<ul><li>若在程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。</li><li>若加载了导致继承关系发生变化的新类，那么必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。</li></ul></li><li>如果向<code>CHA</code>查询出来的结果是该方法有多个版本的目标方法可供选择，即时编译器还将使用<code>内联缓存（Inline Cache）</code>的方式来缩减方法调用的开销。<code>内联缓存</code>是一个建立在<u><strong>目标方法正常入口之前</strong></u>的缓存，工作原理大致为：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。<ul><li>如果以后进来的每次调用的方法接收者版本都是一样的，那么这时它就是一种<code>单态内联缓存（Monomorphic Inline Cache）</code>。通过该缓存来调用，比用不内联的非虚方法调用，仅多了一次类型判断的开销。</li><li>如果出现方法接收者不一致，说明程序用到了方法的多态特性，这时候会退化成<code>超多态内联缓存（Megamorphic Inline Cache）</code>，其开销相当于真正查找虚方法表来进行方法分派。</li></ul></li></ul></li></ul><h4 id="3-3-逃逸分析"><a href="#3-3-逃逸分析" class="headerlink" title="3.3 逃逸分析"></a>3.3 逃逸分析</h4><p><code>逃逸分析（Escape Analysis）</code>与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。</p><blockquote><p>基本原理是：分析对象<code>动态作用域</code>，当一个对象在方法里面被定义后：</p><ul><li>可能被<strong>外部方法</strong>所引用，例如作为调用参数传递到其他方法中，这种称为<code>方法逃逸</code>；</li><li>可能被<strong>外部线程</strong>访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为<code>线程逃逸</code>；</li><li>从不逃逸、方法逃逸到线程逃逸，称为对象<strong>由低到高</strong>的不同<code>逃逸程度</code>。</li></ul></blockquote><p>根据<code>逃逸程度</code>可以为这个对象实例采取不同程度的优化：</p><ul><li><code>栈上分配（Stack Allocations）</code>：如果确定一个对象<strong>不会逃逸出线程</strong>之外，可以让这个对象<u>在栈上分配内存</u>，对象所占用的内存空间就可以随栈帧出栈而自动销毁，垃圾收集子系统的压力将会下降很多。<u>栈上分配可以支持方法逃逸，但不能支持线程逃逸</u>。</li><li><code>标量替换（Scalar Replacement）</code>：Java虚拟机中的原始数据类型都不能再进一步分解分解成更小的数据来表示，这些数据可以被称为<code>标量</code>。如果一个数据可以继续分解，那它就被称为<code>聚合量（Aggregate）</code>。<ul><li><u>把一个Java对象拆散，根据程序访问的情况，<strong>将其用到的成员变量恢复为原始类型来访问</strong></u>，这个过程就称为<code>标量替换</code>。</li><li>假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。对象拆分后可以让对象的成员变量在栈上 分配和读写，标量替换可以视作<code>栈上分配的一种特例</code>，实现更简单。</li><li><u><strong>它不允许对象逃逸出方法范围内</strong></u>。</li></ul></li><li><code>同步消除（Synchronization Elimination）</code>：如果逃逸分析能够确定一个变量<strong>不会逃逸出线程</strong>，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，<u>对这个变量实施的同步措施也就可以安全地消除掉</u>。</li></ul><p>逃逸分析的<u>计算成本非常高</u>，甚至不能保证逃逸分析带来的性能收益会高于它的消耗，但它是即时编译器优化技术的一个重要前进方向。</p><h4 id="3-4-公共子表达式消除"><a href="#3-4-公共子表达式消除" class="headerlink" title="3.4 公共子表达式消除"></a>3.4 公共子表达式消除</h4><p>公共子表达式消除是：如果一个表达式<code>E</code>之前已经被计算过了，并且从先前的计算到现在<code>E</code>中所有变量的值都没有发生变化，那么<code>E</code>的这次出现就称为<code>公共子表达式</code>。对于这种表达式，只需要直接用前面计算过的表达式结果代替<code>E</code>。</p><ul><li>如果这种优化仅限于<strong>程序基本块</strong>内，便可称为<code>局部公共子表达式消除（Local Common Subexpression Elimination）</code>；</li><li>如果这种优化的范围涵盖了<strong>多个基本块</strong>，那就称为<code>全局公共子表达式消除（Global Common Subexpression Elimination）</code>。</li></ul><h4 id="3-5-数组边界检查消除"><a href="#3-5-数组边界检查消除" class="headerlink" title="3.5 数组边界检查消除"></a>3.5 数组边界检查消除</h4><p><code>数组边界检查消除（Array Bounds Checking Elimination）</code>是语言相关的。Java语言是一门<code>动态安全</code>的语言，访问数组元素<code>foo[i]</code>时系统将会自动进行<u>上下界的范围检查</u>，即i必须满足<code>“i&gt;=0&amp;&amp;i&lt;foo.length”</code>的访问条件，所以每次数组元素的读写都带有一次隐含的条件判定操作。</p><ul><li>可以进行<code>数组边界检查优化</code>，尽可能把运行期检查提前到编译期完成。比如通过数据流分析就可以判定循环变量的取值范围是否在上下界区间内，如果在，可以把上下界检查消除掉。</li><li>还可以进行隐式异常处理。需要根据运行期收集到的性能监控信息选择最合适的方案</li></ul><h3 id="4-实战：深入理解Graal编译器"><a href="#4-实战：深入理解Graal编译器" class="headerlink" title="4. 实战：深入理解Graal编译器"></a>4. 实战：深入理解<code>Graal</code>编译器</h3><h4 id="4-1-Java虚拟机编译器接口"><a href="#4-1-Java虚拟机编译器接口" class="headerlink" title="4.1 Java虚拟机编译器接口"></a>4.1 Java虚拟机编译器接口</h4><p><code>Java虚拟机编译器接口（Java-Level JVM Compiler Interface，JVMCI）</code>使得<code>Graal</code>可以从<code>HotSpot</code>的代码中分离出来。<code>JVMCI</code>主要提供如下三种功能：</p><ul><li>响应<code>HotSpot</code>的编译请求，并将该请求分发给Java实现的即时编译器。</li><li>允许编译器访问<code>HotSpot</code>中<u>与即时编译相关的数据结构</u>，包括类、字段、方法及其性能监控数据等，并提供了一组这些数据结构在Java语言层面的抽象表示。</li><li>提供<code>HotSpot</code>代码缓存（<code>Code Cache</code>）的Java端抽象表示，允许编译器部署编译完成的二进制机器码。</li></ul><p><code>JVMCI</code>编译器接口输入要编译的方法的字节码，即<code>“用一个字节数组表示的代码”</code>。输出与方法对应的二进制机器码，二进制机器码也应该是<code>“用一个字节数组表示的代码”</code>。这样的话，<code>JVMCI</code>接口就应该类似于下面形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JVMCICompiler</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] compileMethod(<span class="keyword">byte</span>[] bytecode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上<code>JVMCI</code>接口只比上面这个稍微复杂一点，其输入除了字节码外，<code>HotSpot</code>还会向编译器提供各种该方法的相关信息，譬如<u>局部变量表中变量槽的个数</u>、<u>操作数栈的最大深度</u>，还有<u>分层编译在底层收集到的统计信息</u>等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JVMCICompiler</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compileMethod</span><span class="params">(CompilationRequest request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompilationRequest</span> </span>&#123;</span><br><span class="line"><span class="function">JavaMethod <span class="title">getMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JavaMethod</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] getCode();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxLocals</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxStackSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ProfilingInfo <span class="title">getProfilingInfo</span><span class="params">()</span></span>;</span><br><span class="line">... <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-代码中间表示"><a href="#4-2-代码中间表示" class="headerlink" title="4.2 代码中间表示"></a>4.2 代码中间表示</h4><p><code>Graal编译器</code>在采用了与<code>HotSpot</code>服务端编译器一致（略有差异但已经非常接近）的中间表示形式，也即是被称为<code>Sea-of-Nodes</code>的中间表示，或者与其等价的被称为<code>理想图</code>（<code>Ideal Graph</code>，在代码中称为<code>Structured Graph</code>）的<code>程序依赖图（Program Dependence Graph，PDG）</code>形式。</p><blockquote><p>从编译器内部来看理想图上翻译和优化输入代码的整体过程即：<code>字节码→理想图→优化→机器码</code></p></blockquote><p>理想图是一种<code>有向图</code>，用节点来表示<strong>程序中的元素</strong>，譬如变量、操作符、方法、字段等，而用边来表示<strong>数据</strong>或者<strong>控制流</strong>。如表达式：<code>x+y</code>，在理想图中可以表示为<code>x</code>、<code>y</code>两个节点的数据流流入加法操作符。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/IdealGraph1.PNG" alt="构造理想图"></p><p>把表达式<code>x+y</code>变为<code>getX()+getY()</code>，理想图除了需要表达数据流向之外，还必须要考虑方法调用的顺序。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/IdealGraph2.PNG" alt="构造理想图"></p><blockquote><p>理想图本质上就是这种将<code>数据流图</code>和<code>控制流图</code>以某种方式合并到一起，用一种边来表示数据流向，另一种边来表示控制流向的图形表示。</p></blockquote><h4 id="4-3-代码优化与生成"><a href="#4-3-代码优化与生成" class="headerlink" title="4.3 代码优化与生成"></a>4.3 代码优化与生成</h4><p><code>Graal编译器</code>中创建理想图的方法是<code>createGraph()</code>，<code>createGraph()</code>方法内调用了<code>StructuredGraph::Builder()</code>构造器来创建理想图。</p><h5 id="4-3-1-理想图本身的数据结构"><a href="#4-3-1-理想图本身的数据结构" class="headerlink" title="4.3.1 理想图本身的数据结构"></a>4.3.1 理想图本身的数据结构</h5><p>它是一组<strong>不为空</strong>的节点的集合，它的节点都是用<code>ValueNode</code>的不同类型的<strong>子类节点</strong>来表示的。如加法操作就由<code>AddNode</code>节点来表示，到加法操作是<code>二元算术操作节点（BinaryArithmeticNode&lt;OP&gt;）</code>的一种，而二元算术操作节点又是<code>二元操作符（BinaryNode）</code>的一种。</p><h5 id="4-3-2-从字节码转换到理想图"><a href="#4-3-2-从字节码转换到理想图" class="headerlink" title="4.3.2 从字节码转换到理想图"></a>4.3.2 从字节码转换到理想图</h5><p>该过程被封装在<code>BytecodeParser</code>类中，可以按照字节码解释器的思路去理解该解析器。<code>BytecodeParser::genArithmeticOp()</code>方法如下：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/genArithmeticOp.PNG" alt="genArithmeticOp方法"></p><p>其中，<code>genIntegerAdd()</code>方法中就只有一行代码，即调用<code>AddNode</code>节点的<code>create()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ValueNode <span class="title">genIntegerAdd</span><span class="params">(ValueNode x, ValueNode y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> AddNode.create(x, y, NodeView.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValueNode <span class="title">create</span><span class="params">(ValueNode x, ValueNode y, NodeView view)</span> </span>&#123;</span><br><span class="line">BinaryOp&lt;Add&gt; op = ArithmeticOpTable.forStamp(x.stamp(view)).getAdd();</span><br><span class="line">Stamp stamp = op.foldStamp(x.stamp(view), y.stamp(view));</span><br><span class="line">ConstantNode tryConstantFold = tryConstantFold(op, x, y, stamp, view);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tryConstantFold != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> tryConstantFold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x.isConstant() &amp;&amp; !y.isConstant()) &#123;</span><br><span class="line"><span class="keyword">return</span> canonical(<span class="keyword">null</span>, op, y, x, view);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> canonical(<span class="keyword">null</span>, op, x, y, view);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个理想图的节点都有两个共同的主要操作：</p><ul><li><strong>规范化</strong>（<code>Canonicalisation</code>），即代码优化。在理想图的基础上优化代码所要采取的措施，实现在<code>canonical()</code>方法中。</li><li><strong>生成机器码</strong>（<code>Generation</code>），即代码翻译。实现在<code>generate()</code>方法中。<code>Graal</code>并不是直接由理想图转换到机器码，而是会先生成<code>低级中间表示</code>（<code>LIR</code>，与具体机器指令集相关的中间表示），然后再由<code>HotSpot</code>统一后端来产生机器码。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;后端编译器的编译速度及编译结果质量高低，是衡量Java虚拟机性能最重要的一个指标。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--10 前端编译与优化</title>
    <link href="https://wuyunjie.top/2021/06/02/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_10_Front-end_compilation_and_optimization.html"/>
    <id>https://wuyunjie.top/2021/06/02/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_10_Front-end_compilation_and_optimization.html</id>
    <published>2021-06-02T08:38:04.000Z</published>
    <updated>2021-06-02T08:38:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>从计算机程序出现的第一天起，对效率的追逐就是程序员天生的坚定信仰，这个过程犹如一场没有终点、永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛车。<br><a id="more"></a></p></blockquote><p><code>Java</code>有<code>3</code>类编译过程：</p><ul><li><strong>前端编译器</strong>：<strong>“编译器的前端”</strong>，把<code>*.java</code>文件转变成<code>*.class</code>文件，比如<code>JDK</code>的<code>Javac</code>、<code>Eclipse JDT</code>中的增量式编译器（<code>ECJ</code>）。</li><li><strong>即时编译器</strong>：常称<code>JIT编译器</code>（<code>Just In Time Compiler</code>），运行期把字节码转变成本地机器码，比如<code>HotSpot</code>虚拟机的<code>C1</code>、<code>C2</code>编译器，<code>Graal</code>编译器。</li><li><strong>提前编译器</strong>：常称<code>AOT编译器</code>（<code>Ahead Of Time Compiler</code>），直接把程序编译成与目标机器指令集相关的二进制代码。<code>JDK</code>的<code>Jaotc</code>、<code>GNU Compiler for the Java（GCJ）</code>、<code>Excelsior JET</code>。</li></ul><p>Java中即时编译器在运行期的优化过程，支撑了<strong>程序执行效率的不断提升</strong>；而前端编译器在编译期的优化过程，则是支撑着<strong>程序员的编码效率和语言使用者的幸福感的提高</strong>。</p><h3 id="1-Javac编译器"><a href="#1-Javac编译器" class="headerlink" title="1. Javac编译器"></a>1. <code>Javac</code>编译器</h3><p><code>Javac</code>编译器不像<code>HotSpot</code>虚拟机那样使用<code>C++</code>语言（包含少量<code>C</code>语言）实现，它本身就是一个由<code>Java</code>语言编写的程序。</p><h4 id="1-1-Javac的源码与调试"><a href="#1-1-Javac的源码与调试" class="headerlink" title="1.1 Javac的源码与调试"></a>1.1 <code>Javac</code>的源码与调试</h4><p><code>javac</code>的发展历史：</p><ul><li><code>JDK 6</code>以前，<code>Javac</code>并不属于标准<code>Java SE API</code>，它实现代码单独存放在<code>tools.jar</code>中。</li><li><code>JDK 6</code>发布时通过了<code>JSR 199</code>编译器<code>API</code>的提案，使得<code>Javac</code>编译器的实现代码晋升成为标准Java类库之一，它的源码就改为放在<code>JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac</code>中</li><li><code>JDK 9</code>时，整个<code>JDK</code>所有的<code>Java</code>类库都采用模块化进行重构划分，<code>Javac</code>编译器就被挪到了<code>jdk.compiler</code>模块（路径为：<code>JDK_SRC_HOME/src/jdk.compiler/share/classes/com/sun/tools/javac</code>）里面</li></ul><p>从<code>Javac</code>代码的总体结构来看，编译过程大致可以分为<code>1</code>个准备过程和<code>3</code>个处理过程：</p><ol><li><strong>准备过程</strong>：初始化插入式注解处理器。</li><li><strong>解析与填充符号表过程</strong>，包括：<ul><li><strong>词法、语法分析</strong>。将源代码的字符流转变为标记集合，构造出抽象语法树。</li><li><strong>填充符号表</strong>。产生符号地址和符号信息。</li></ul></li><li><strong>插入式注解处理器的注解处理过程</strong>：插入式注解处理器的执行阶段。</li><li><strong>分析与字节码生成过程</strong>，包括：<ul><li><strong>标注检查</strong>。对语法的静态信息进行检查。</li><li><strong>数据流及控制流分析</strong>。对程序动态运行过程进行检查。</li><li><strong>解语法糖</strong>。将简化代码编写的语法糖还原为原有的形式。</li><li><strong>字节码生成</strong>。将前面各个步骤所生成的信息转化成字节码。</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/javacComplierProcess.PNG" alt="Javac的编译过程"></p><p>Javac编译动作的入口是<code>com.sun.tools.javac.main.JavaCompiler</code>类:</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/javacComplierCode.PNG" alt="Javac编译过程的主体代码"></p><h4 id="1-2-解析与填充符号表"><a href="#1-2-解析与填充符号表" class="headerlink" title="1.2 解析与填充符号表"></a>1.2 解析与填充符号表</h4><p>解析过程包括了<code>词法分析</code>和<code>语法分析</code>两个步骤：</p><h5 id="1-2-1-词法、语法分析"><a href="#1-2-1-词法、语法分析" class="headerlink" title="1.2.1 词法、语法分析"></a>1.2.1 词法、语法分析</h5><ul><li><strong>词法分析</strong>是将源代码的字符流转变为<code>标记（Token）</code>集合的过程，单个字符是<u>程序编写</u>时的最小元素，但标记才是<u>编译</u>时的最小元素。<ul><li>词法分析过程由<code>com.sun.tools.javac.parser.Scanner</code>类来实现。</li></ul></li><li><strong>语法分析</strong>是根据标记序列构造抽象语法树的过程，<code>抽象语法树（Abstract Syntax Tree，AST）</code>是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个<code>语法结构（Syntax Construct）</code>，例如<u>包、类型、修饰符、运算符、接口、返回值</u>甚至连<u>代码注释</u>等都可以是一种特定的语法结构。<ul><li>语法分析过程由<code>com.sun.tools.javac.parser.Parser</code>类实现的</li><li>抽象语法树是以<code>com.sun.tools.javac.tree.JCTree</code> 类表示的。</li></ul></li></ul><p>经过词法和语法分析生成语法树以后，编译器就不会再对源码字符流进行操作了，<u><strong>后续的操作都建立在抽象语法树之上</strong></u>。</p><h5 id="1-2-2-填充符号表"><a href="#1-2-2-填充符号表" class="headerlink" title="1.2.2 填充符号表"></a>1.2.2 填充符号表</h5><p><code>符号表（Symbol Table）</code>是由一组<u><strong>符号地址</strong></u>和<u><strong>符号信息</strong></u>构成的数据结构。符号表中所登记的信息在编译的不同阶段都要被用到。</p><ul><li>在语义分析的过程中，符号表所登记的内容将用于语义检查和产生中间代码</li><li>在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。</li><li>填充符号表的过程由<code>com.sun.tools.javac.comp.Enter</code>类实现。</li></ul><h4 id="1-3-注解处理器"><a href="#1-3-注解处理器" class="headerlink" title="1.3 注解处理器"></a>1.3 注解处理器</h4><p><code>注解（Annotations）</code>在设计上原本是与普通的Java代码一样，都只会在程序运行期间发挥作用的。但在<code>JDK 6</code>中设计了一组被称为<code>“插入式注解处理器”</code>的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。</p><ul><li><code>插入式注解处理器</code>可以看作是一组编译器的<strong>插件</strong>，它允许<strong>读取</strong>、<strong>修改</strong>、<strong>添加</strong>抽象语法树中的<strong>任意元素</strong>。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个<code>轮次（Round）</code>。</li></ul><h4 id="1-4-语义分析与字节码生成"><a href="#1-4-语义分析与字节码生成" class="headerlink" title="1.4 语义分析与字节码生成"></a>1.4 语义分析与字节码生成</h4><p>抽象语法树能够表示一个<code>结构正确</code>的源程序，但无法保证源程序的<code>语义是符合逻辑</code>的。语义分析的主要任务则是<u><strong>对结构上正确的源程序进行上下文相关性质的检查</strong></u>，譬如进行<u>类型检查</u>、<u>控制流检查</u>、<u>数据流检查</u>，等等。</p><h5 id="1-4-1-标注检查"><a href="#1-4-1-标注检查" class="headerlink" title="1.4.1 标注检查"></a>1.4.1 标注检查</h5><p>语义分析过程可分为<strong>标注检查</strong>和<strong>数据及控制流分析</strong>两个步骤。</p><p>标注检查步骤要检查的内容包括诸如<u>变量使用前是否已被声明</u>、<u>变量与赋值之间的数据类型是否能够匹配</u>，等等。还会顺便进行一个称为<code>常量折叠（Constant Folding）</code>的代码优化。</p><h5 id="1-4-2-数据及控制流分析"><a href="#1-4-2-数据及控制流分析" class="headerlink" title="1.4.2 数据及控制流分析"></a>1.4.2 数据及控制流分析</h5><p><code>数据流分析</code>和<code>控制流分析</code>是对程序上下文逻辑更进一步的验证，它可以检查出诸如<u>程序局部变量在使用前是否有赋值</u>、<u>方法的每条路径是否都有返回值</u>、<u>是否所有的受查异常都被正确处理</u>等问题。</p><h5 id="1-4-3-解语法糖"><a href="#1-4-3-解语法糖" class="headerlink" title="1.4.3 解语法糖"></a>1.4.3 解语法糖</h5><p><code>语法糖（Syntactic Sugar）</code>，也称<code>糖衣语法</code>，指的是在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响， 但是却能更方便程序员使用该语言。通常来说使用语法糖能够<em>减少代码量、增加程序的可读性</em>。</p><p>Java中最常见的语法糖包括了<strong><u>泛型</u></strong>、<u><strong>变长参数</strong></u>、<strong><u>自动装箱拆箱</u></strong>，等等，它们在编译阶段被还原回原始的基础语法结构，这个过程就称为<code>解语法糖</code>。</p><h5 id="1-4-4-字节码生成"><a href="#1-4-4-字节码生成" class="headerlink" title="1.4.4 字节码生成"></a>1.4.4 字节码生成</h5><p>字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了<u>少量的代码添加和转换工作</u>。</p><ul><li>实例构造器<code>&lt;init&gt;()</code>方法和类构造器<code>&lt;clinit&gt;()</code>方法就是在这个阶段被添加到语法树之中的。</li></ul><p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交到<code>com.sun.tools.javac.jvm.ClassWriter</code>类手上，由这个类的<code>writeClass()</code>方法输出字节码，生成最终的Class 文件。</p><h3 id="2-Java语法糖的味道"><a href="#2-Java语法糖的味道" class="headerlink" title="2. Java语法糖的味道"></a>2. Java语法糖的味道</h3><p>语法糖虽然不会提供实质性的功能改进，但是它们或能提高效率，或能提升语法的严谨性，或能减少编码出错的机会。</p><h4 id="2-1-泛型"><a href="#2-1-泛型" class="headerlink" title="2.1 泛型"></a>2.1 泛型</h4><p><code>泛型</code>的本质是<code>参数化类型（Parameterized Type）</code>或者<code>参数化多态（Parametric Polymorphism）</code>的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。</p><h5 id="2-1-1-Java与C-的泛型"><a href="#2-1-1-Java与C-的泛型" class="headerlink" title="2.1.1 Java与C#的泛型"></a>2.1.1 Java与C#的泛型</h5><p><code>Java</code>选择的泛型实现方式叫作<code>“类型擦除式泛型”（Type Erasure Generics）</code>，而<code>C#</code>选择的泛型实现方式是<code>“具现化式泛型”（Reified Generics）</code>。</p><ul><li><code>C#</code>里面泛型无论在程序源码里面、编译后的中间语言表示（<code>Intermediate Language</code>）里面，抑或是运行期的<code>CLR</code>里面都是切实存在的，有着自己独立的虚方法表和类型数据。</li><li><code>Java</code>语言中的泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的<code>裸类型（Raw Type）</code>，并且在相应的地方插入了强制转型代码。<ul><li>对于运行期的Java语言来说，<code>ArrayList&lt;int&gt;</code>与<code>ArrayList&lt;String&gt;</code>其实是同一个类型。</li></ul></li></ul><p>Java的类型<code>擦除式泛型</code>无论在使用效果上还是运行效率上，几乎是全面落后于<code>C#</code>的<code>具现化式泛型</code>，而它的<u><strong>唯一优势</strong></u>是：</p><blockquote><p><code>擦除式泛型</code>的实现几乎只需要在<code>Javac</code>编译器上做出改进即可，不需要改动字节码、不需要改动Java虚拟机，也保证了以前没有使用泛型的库可以直接运行在Java 5.0之上。</p></blockquote><h5 id="2-1-2-类型擦除"><a href="#2-1-2-类型擦除" class="headerlink" title="2.1.2 类型擦除"></a>2.1.2 类型擦除</h5><p>为了保证以前编译出来的<code>Class</code>文件可以在<code>Java 5.0</code>引入泛型之后继续运行，大体上有两条路可以选择：</p><ol><li>需要泛型化的类型（主要是容器类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型。</li><li>直接把已有的类型泛型化，即让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。</li></ol><p>Java选择了<u><strong>直接把已有的类型泛型化</strong></u>，譬如<code>ArrayList</code>原地泛型化后变成了<code>ArrayList&lt;T&gt;</code>。要保证以前直接用<code>ArrayList</code>的代码在泛型新版本里必须还能继续用这同一个容器，这就必须让所有泛型化的实例类型全部自动成为<code>ArrayList</code>的子类型才能可以，否则类型转换就是不安全的。由此就引出了<code>“裸类型”（Raw Type）</code>的概念。</p><blockquote><p><code>裸类型</code>应被视为所有该类型泛型化实例的<code>共同父类型（Super Type）</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ilist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; slist = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList list; <span class="comment">// 裸类型</span></span><br><span class="line">list = ilist;</span><br><span class="line">list = slist;</span><br></pre></td></tr></table></figure><p>如何实现裸类型又有两种选择：</p><ol><li>在运行期由<code>Java</code>虚拟机来自动地、真实地构造出<code>ArrayList&lt;Integer&gt;</code>这样的类型，并且自动实现从<code>ArrayList&lt;Integer&gt;</code>派生自<code>ArrayList</code>的继承关系来满足裸类型的定义；</li><li>简单粗暴地直接在编译时把<code>ArrayList&lt;Integer&gt;</code>还原回<code>ArrayList</code>，只在<u>元素访问</u>、<u>修改</u>时自动插入一些<u>强制类型转换和检查指令</u>。</li></ol><p>显然Java选择了后一种实现方式。可以看一个<code>Java</code>泛型擦除的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型擦除前的例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">    map.put(<span class="string">"how are you?"</span>, <span class="string">"吃了没？"</span>);</span><br><span class="line">    System.out.println(map.get(<span class="string">"hello"</span>));</span><br><span class="line">    System.out.println(map.get(<span class="string">"how are you?"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型擦除后的例子</span></span><br><span class="line"><span class="comment"> * 上一段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译的结果</span></span><br><span class="line"><span class="comment"> * 泛型类型都变回了裸类型，只在元素访问时插入了从Object到String的强制转型代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">    map.put(<span class="string">"how are you?"</span>, <span class="string">"吃了没？"</span>);</span><br><span class="line">    System.out.println((String) map.get(<span class="string">"hello"</span>));</span><br><span class="line">    System.out.println((String) map.get(<span class="string">"how are you?"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型擦除带来的缺陷：</p><ol><li><p>使用擦除法实现泛型直接导致了对<code>原始类型（Primitive Types）</code>数据的支持又成了新的麻烦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原始类型的泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ArrayList&lt;<span class="keyword">int</span>&gt; ilist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">ArrayList&lt;<span class="keyword">long</span>&gt; llist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line">ArrayList list;</span><br><span class="line">list = ilist;</span><br><span class="line">list = llist;</span><br></pre></td></tr></table></figure><p>由于Java不支持<code>int</code>、<code>long</code>与<code>Object</code>之间的强制转型，所以泛型擦除后在需要插入强制转型代码的地方就无法进行了。Java给出的解决方案简单粗暴：</p><blockquote><p>不支持原生类型的泛型，使用<code>ArrayList&lt;Integer&gt;</code>、<code>ArrayList&lt;Long&gt;</code>，遇到原生类型时自动装箱、拆箱。</p></blockquote></li><li><p>运行期无法取到泛型类型信息，会让一些代码变得相当啰嗦</p><p><code>Java</code>不支持如下泛型的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeErasureGenerics</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (item <span class="keyword">instanceof</span> E) &#123; <span class="comment">// 不合法，无法对泛型进行实例判断</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">E newItem = <span class="keyword">new</span> E(); <span class="comment">// 不合法，无法使用泛型创建对象</span></span><br><span class="line">E[] itemArray = <span class="keyword">new</span> E[<span class="number">10</span>]; <span class="comment">// 不合法，无法使用泛型创建数组</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些限制都是由于<u><strong>运行期Java虚拟机无法取得泛型类型</strong></u>而导致的，要实现类似操作，需要写一个泛型版本的从<code>List</code>到数组的转换方法，由于不能从<code>List</code>中取得参数化类型<code>T</code>，所以不得不从一个额外参数中再传入一个数组的组件类型进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] convert(List&lt;T&gt; list, Class&lt;T&gt; componentType) &#123;</span><br><span class="line">T[] array = (T[])Array.newInstance(componentType, list.size());</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>丧失了一些面向对象思想应有的优雅，带来了一些模棱两可的模糊状况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"invoke method(List&lt;String&gt; list)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"invoke method(List&lt;Integer&gt; list)"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为参数<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>编译之后都被擦除了，变成了同一种的裸类型<code>List</code>，类型擦除导致这两个方法的特征签名变得一模一样，无法重载。</p></li></ol><h5 id="2-1-3-值类型与未来的泛型"><a href="#2-1-3-值类型与未来的泛型" class="headerlink" title="2.1.3 值类型与未来的泛型"></a>2.1.3 值类型与未来的泛型</h5><p>Oracle建立了一个名为<code>Valhalla</code>的语言改进项目，希望改进Java语言留下的各种缺陷。</p><p>在<code>Valhalla</code>项目中规划了几种不同的新泛型实现方案，被称为<code>Model 1</code>到<code>Model 3</code>，泛型类型有可能被：</p><ul><li><strong>具现化</strong></li><li>继续维持<strong>类型擦除以</strong>保持兼容<ul><li>泛型的参数化类型也可以选择不被完全地擦除掉，而是相对完整地记录在Class文件中，能够在运行期被使用</li><li>也可以指定编译器默认要擦除哪些类型。</li></ul></li></ul><p>相对于使用不同方式实现泛型，目前比较明确的是未来的Java应该会提供<code>“值类型”（Value Type）</code>的语言层面的支持。</p><blockquote><ul><li><p><code>值类型</code>可以与<code>引用类型</code>一样，具有<u>构造函数</u>、<u>方法</u>或是<u>属性字段</u>，等等</p></li><li><p><code>值类型</code>与<code>引用类型</code>的区别在于<u><strong>它在赋值的时候通常是整体复制，而不是像引用类型那样传递引用的</strong></u>。</p></li><li>值类型的实例很容易实现分配在方法的调用栈上的，值类型可以随着当前方法的退出而自动释放，不会给垃圾收集子系统带来任何压力。</li></ul></blockquote><p>Java的值类型方案被称为<code>“内联类型”</code>，计划通过一个新的关键字<code>inline</code>来定义，字节码层面也有专门与原生类型对应的以<code>Q</code>开头的新的操作码（譬如<code>iload</code>对应<code>qload</code>）来支撑。</p><h4 id="2-2-自动装箱、拆箱与遍历循环"><a href="#2-2-自动装箱、拆箱与遍历循环" class="headerlink" title="2.2 自动装箱、拆箱与遍历循环"></a>2.2 自动装箱、拆箱与遍历循环</h4><p><code>自动装箱</code>、<code>自动拆箱</code>与<code>遍历循环</code>（<code>for-each循环</code>）是Java语言里面被使用最多的语法糖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动装箱、拆箱与遍历循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动装箱、拆箱与遍历循环编译之后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List list = Arrays.asList( <span class="keyword">new</span> Integer[] &#123;</span><br><span class="line">Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">Integer.valueOf(<span class="number">2</span>),</span><br><span class="line">Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">Integer.valueOf(<span class="number">4</span>) &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)localIterator.next()).intValue();</span><br><span class="line">        sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>自动装箱</code>、<code>拆箱</code>在编译之后被转化成了对应的包装和还原方法，如<code>Integer.valueOf()</code>与<code>Integer.intValue()</code>方法</li><li><code>遍历循环</code>则是把代码还原成了迭代器的实现</li><li><code>变长参数</code>在调用的时候变成了一个数组类型的参数</li></ul><p>自动装箱的陷阱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    Integer b = <span class="number">2</span>;</span><br><span class="line">    Integer c = <span class="number">3</span>;</span><br><span class="line">    Integer d = <span class="number">3</span>;</span><br><span class="line">    Integer e = <span class="number">321</span>;</span><br><span class="line">    Integer f = <span class="number">321</span>;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">    System.out.println(e == f);</span><br><span class="line">    System.out.println(c == (a + b));</span><br><span class="line">    System.out.println(c.equals(a + b));</span><br><span class="line">    System.out.println(g == (a + b));</span><br><span class="line">    System.out.println(g.equals(a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/TrapOfAutoBoxing.PNG" alt="自动装箱的陷阱"></p><ul><li><p>对于前两个结果，基于<code>==</code>比较，但返回结果不一样，查看Integer内部源码发现，有一个静态内部类的缓存池<code>IntegerCache</code>，缓存范在为<code>-128~127</code>的数，超过这个范围的<code>Integer</code>值都是<code>new</code>出来的新对象。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/IntegerValueOf.PNG" alt="ValueOf"></p><ul><li>直接使用<code>==</code>比较符，比较的是引用的堆地址，所以<code>c</code>与<code>d</code>都是同一个堆地址，返回<code>true</code>；<code>e</code>和<code>f</code>是创建的两个不同的对象，返回<code>false</code>。从变量表也可以看出来：</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/TrapOfAutoBoxingVariable.PNG" alt="变量表"></p><ul><li><code>Integer</code>缓存了<code>-128~127</code>之间的数，这是在类加载期间就完成的。以后需要的时候直接指向它就可以了，省去了构造对象的开支，提高了效率。</li></ul></li><li><p>包装类的<code>“==”</code>运算在不遇到算术运算的情况下不会自动拆箱，以及它们<code>equals()</code>方法不处理数据转型的关系</p></li></ul><h4 id="2-4-条件编译"><a href="#2-4-条件编译" class="headerlink" title="2.4 条件编译"></a>2.4 条件编译</h4><p>Java语言可以进行条件编译，方法就是使用条件为常量的<code>if</code>语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   System.out.println(<span class="string">"block 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反编译结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能使用条件为常量的<code>if</code>语句才能达到上述效果。根据布尔常量值的真假，编译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段（<code>com.sun.tools.javac.comp.Lower</code>类中）完成。</p><blockquote><p>条件编译的实现方式使用了<code>if</code>语句，所以它必须遵循最基本的Java语法，只能写在方法体内部，因此它只能实现语句<code>基本块（Block）</code>级别的条件编译，而没有办法实现根据条件调整整个Java类的结构。</p></blockquote><h3 id="3-实战：插入式注解处理器"><a href="#3-实战：插入式注解处理器" class="headerlink" title="3. 实战：插入式注解处理器"></a>3. 实战：插入式注解处理器</h3><h4 id="3-1-实战目标"><a href="#3-1-实战目标" class="headerlink" title="3.1 实战目标"></a>3.1 实战目标</h4><p>使用<code>注解处理器API</code>来编写一款拥有自己编码风格的校验工具：<code>NameCheckProcessor</code>。<code>NameCheckProcessor</code>的目标定为对Java程序命名进行检查，Java程序命名推荐（而不是强制）应当符合下列格式的书写规范：</p><ul><li><strong>类（或接口）</strong>：符合<u>驼式命名法</u>，<u>首字母大写</u>。</li><li><strong>方法</strong>：符合<u>驼式命名法</u>，<u>首字母小写</u>。</li><li><strong>字段</strong>：<ul><li><strong>类或实例变量</strong>。符合驼式命名法，首字母小写。</li><li><strong>常量</strong>。要求<strong>全部由大写字母或下划线</strong>构成，并且<u>第一个字符不能是下划线</u>。</li></ul></li></ul><h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><p>实现<code>注解处理器</code>的代码需要继承抽象类<code>javax.annotation.processing.AbstractProcessor</code>。</p><ul><li>这个抽象类中只有一个子类必须实现的抽象方法：<code>“process()”</code>，它是Javac编译器在执行注解处理器代码时要调用的过程。<ul><li>从这个方法的第一个参数<code>“annotations”</code>中获取到此<code>注解处理器</code>所要处理的<code>注解集合</code>。</li><li>从第二个参数<code>“roundEnv”</code>中访问到当前这个<code>轮次（Round）</code>中的抽象语法树节点，每个语法树节点在这里都表示为一个<code>Element</code>。</li></ul></li><li>实例变量<code>“processingEnv”</code>是<code>AbstractProcessor</code>中的一个<code>protected</code>变量，在注解处理器初始化的时候（<code>init()</code>方法执行的时候）创建，继承了<code>AbstractProcessor</code>的注解处理器代码可以直接访问它。它代表了注解处理器框架提供的一个<code>上下文环境</code>，要<u>创建新的代码</u>、<u>向编译器输出信息</u>、<u>获取其他工具类</u>等都需要用到这个实例变量。</li><li>还有两个经常配合着使用的注解，分别是：<ul><li><code>@SupportedAnnotationTypes</code>，代表了这个注解处理器对哪些注解感兴趣，可以使用星号<code>“*”</code>作为通配符代表对所有的注解都感兴趣</li><li><code>@SupportedSourceVersion</code>，指出这个注解处理器可以处理哪些版本的Java代码。</li></ul></li></ul><p>如果不需要改变或添加抽象语法树中的内容，<code>process()</code> 方法可以返回<code>false</code>，通知编译器这个轮次中的代码未发生变化，无须构造新的<code>JavaCompiler</code>实例。</p><p>注解处理器<code>NameCheckProcessor</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用"*"表示支持所有Annotations</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"*"</span>)</span><br><span class="line"><span class="comment">// 只支持JDK 6的Java代码</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NameChecker nameChecker;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化名称检查插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        nameChecker = <span class="keyword">new</span> NameChecker(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对输入的语法树的各个节点进行名称检查</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!roundEnv.processingOver()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Element element : roundEnv.getRootElements())</span><br><span class="line">                nameChecker.checkNames(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名检查器<code>NameChecker</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.processing.Messager;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.ProcessingEnvironment;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.ElementScanner6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.lang.model.element.ElementKind.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.lang.model.element.Modifier.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.tools.Diagnostic.Kind.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序名称规范的编译器插件：&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 如果程序命名不合规范，将会输出一个编译器的WARNING信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messager messager;</span><br><span class="line"></span><br><span class="line">    NameCheckScanner nameCheckScanner = <span class="keyword">new</span> NameCheckScanner();</span><br><span class="line"></span><br><span class="line">    NameChecker(ProcessingEnvironment processsingEnv) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messager = processsingEnv.getMessager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对Java程序命名进行检查，根据《Java语言规范》第三版第6.8节的要求，Java程序命名应当符合下列格式：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;类或接口：符合驼式命名法，首字母大写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;方法：符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;字段：</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;类、实例变量: 符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;常量: 要求全部大写。</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkNames</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        nameCheckScanner.scan(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称检查器实现类，继承了JDK 6中新提供的ElementScanner6&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 将会以Visitor模式访问抽象语法树中的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckScanner</span> <span class="keyword">extends</span> <span class="title">ElementScanner6</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此方法用于检查Java类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitType</span><span class="params">(TypeElement e, Void p)</span> </span>&#123;</span><br><span class="line">            scan(e.getTypeParameters(), p);</span><br><span class="line">            checkCamelCase(e, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">super</span>.visitType(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查方法命名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitExecutable</span><span class="params">(ExecutableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == METHOD) &#123;</span><br><span class="line">                Name name = e.getSimpleName();</span><br><span class="line">                <span class="keyword">if</span> (name.contentEquals(e.getEnclosingElement().getSimpleName()))</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"一个普通方法 “"</span> + name + <span class="string">"”不应当与类名重复，避免与构造函数产生混淆"</span>, e);</span><br><span class="line">                checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.visitExecutable(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查变量命名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitVariable</span><span class="params">(VariableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果这个Variable是枚举或常量，则按大写命名检查，否则按照驼式命名法规则检查</span></span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == ENUM_CONSTANT || e.getConstantValue() != <span class="keyword">null</span> || heuristicallyConstant(e))</span><br><span class="line">                checkAllCaps(e);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断一个变量是否是常量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">heuristicallyConstant</span><span class="params">(VariableElement e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getEnclosingElement().getKind() == INTERFACE)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e.getKind() == FIELD &amp;&amp; e.getModifiers().containsAll(EnumSet.of(PUBLIC, STATIC, FINAL)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查传入的Element是否符合驼式命名法，如果不符合，则输出警告信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCamelCase</span><span class="params">(Element e, <span class="keyword">boolean</span> initialCaps)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line">            <span class="keyword">boolean</span> previousUpper = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (Character.isUpperCase(firstCodePoint)) &#123;</span><br><span class="line">                previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当以小写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isLowerCase(firstCodePoint)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当以大写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (conventional) &#123;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (Character.isUpperCase(cp)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUpper) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        previousUpper = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!conventional)</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当符合驼式命名法（Camel Case Names）"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 大写命名检查，要求第一个字母必须是大写的英文字母，其余部分可以是下划线或大写字母</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkAllCaps</span><span class="params">(Element e)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isUpperCase(firstCodePoint))</span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (cp == (<span class="keyword">int</span>) <span class="string">'_'</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUnderscore) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        previousUnderscore = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!conventional)</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"常量“"</span> + name + <span class="string">"”应当全部以大写字母或下划线命名，并且以字母开头"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含了多处不规范命名的代码样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BADLY_NAMED_CODE</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> colors &#123;</span><br><span class="line">        red, blue, green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _FORTY_TWO = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> NOT_A_CONSTANT = _FORTY_TWO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">BADLY_NAMED_CODE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NOTcamelCASEmethodNAME</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>Javac</code>命令的<code>“-processor”</code>参数来执行编译时需要附带的注解处理器，还可以使用<code>-XprintRounds</code>和<code>-XprintProcessorInfo</code>参数来查看注解处理器运作的详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -processor JVMLearning.Complier.NameCheckProcessor JVMLearning\Complier\BADLY_NAMED_CODE.java</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;从计算机程序出现的第一天起，对效率的追逐就是程序员天生的坚定信仰，这个过程犹如一场没有终点、永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛车。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--9 类加载及执行子系统的案例与实战</title>
    <link href="https://wuyunjie.top/2021/05/31/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_9_Case_and_practice_of_class_loading_and_execution_subsystem.html"/>
    <id>https://wuyunjie.top/2021/05/31/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_9_Case_and_practice_of_class_loading_and_execution_subsystem.html</id>
    <published>2021-05-31T13:23:21.000Z</published>
    <updated>2021-05-31T13:23:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变。<br><a id="more"></a></p></blockquote><p>能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能。</p><h3 id="1-案例分析"><a href="#1-案例分析" class="headerlink" title="1. 案例分析"></a>1. 案例分析</h3><h4 id="1-1-Tomcat：正统的类加载器架构"><a href="#1-1-Tomcat：正统的类加载器架构" class="headerlink" title="1.1 Tomcat：正统的类加载器架构"></a>1.1 <code>Tomcat</code>：正统的类加载器架构</h4><p>主流的<code>Java Web服务器</code>，如<code>Tomcat</code>、<code>Jetty</code>、<code>WebLogic</code>、<code>WebSphere</code>等，都实现了自己定义的类加载器，而且一般不止一个。一个功能健全的Web服务器，要解决如下的这些问题：</p><ul><li>部署在<u>同一个服务器</u>上的两个Web应用程序所使用的Java类库可以实现<strong><u>相互隔离</u></strong>。</li><li>部署在<u>同一个服务器</u>上的两个Web应用程序所使用的Java类库可以<u><strong>互相共享</strong></u>。</li><li>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响。</li><li>支持<code>JSP</code>应用的Web服务器，十有八九都需要支持<code>HotSwap</code>功能。<code>JSP</code>文件由于其<u>纯文本存储</u>的特性，被运行时修改的概率远大于第三方类库或程序自己的Class文件。而且<code>ASP</code>、<code>PHP</code>和<code>JSP</code>这些网页应用也把<u><strong>修改后无须重启</strong></u>作为一 个很大的“优势”来看待，因此“主流”的Web服务器都会支持<code>JSP</code>生成类的<strong><code>热替换</code></strong>。</li></ul><p>由于存在上述问题，在部署Web应用时，各种Web服务器都提供了好几个有着不同含义的<code>ClassPath</code>路径供用户存放<u>第三方类库</u>，这些路径一般会以<code>“lib”</code>或<code>“classes”</code>命名。通常每一个目录都会有一个相应的<strong><code>自定义类加载器</code></strong>去加载放置在里面的Java类库。</p><h4 id="1-2-OSGi：灵活的类加载器架构"><a href="#1-2-OSGi：灵活的类加载器架构" class="headerlink" title="1.2 OSGi：灵活的类加载器架构"></a>1.2 <code>OSGi</code>：灵活的类加载器架构</h4><p><code>OSGi （Open Service Gateway Initiative）</code>是<code>OSGi联盟（OSGi Alliance）</code>制订的一个基于Java语言的<code>动态模块化规范</code>。<code>OSGi</code>中的每个模块（称为<code>Bundle</code>）与普通的Java类库区别并不太大，两者一般都以<code>JAR</code>格式进行封装，并且内部存储的都是Java的<code>Package</code>和<code>Class</code>。</p><ul><li>但是一个<code>Bundle</code>可以声明它所依赖的<code>Package</code>（通过<code>Import-Package</code>描述），也可以声明它允许导出发布的<code>Package</code>（通过<code>Export-Package</code>描述）。</li><li>在<code>OSGi</code>里面，<code>Bundle</code>之间的依赖关系从传统的上层模块依赖底层模块转变为<strong>平级模块之间的依赖</strong>，而且类库的可见性能得到非常精确的控制，一个模块里只有被<code>Export</code>过的<code>Package</code>才可能被外界访问，其他的<code>Package</code>和<code>Class</code>将会被隐藏起来。</li></ul><p>但引入<code>OSGi</code>的主要理由是基于<code>OSGi</code>架构的程序很可能会实现模块级的<strong><u>热插拔功能</u></strong>，该特性要归功于它灵活的类加载器架构：</p><ul><li><code>OSGi</code>的<code>Bundle</code>类加载器之间只有规则，没有固定的委派关系。例如，某个<code>Bundle</code>声明了一个它依赖的<code>Package</code>，如果有其他<code>Bundle</code>声明了发布这个<code>Package</code>后，那么所有对这个<code>Package</code>的类加载动作都会委派给发布它的<code>Bundle</code>类加载器去完成。</li><li>不涉及某个具体的Package时，各个Bundle加载器都是平级的关系，只有具体使用到某个<code>Package</code>和<code>Class</code>的时候，才会根据<code>Package</code><strong>导入导出定义</strong>来构造<code>Bundle</code>间的委派和依赖。</li><li>一个<code>Bundle</code>类加载器为其他<code>Bundle</code>提供服务时，会根据<code>Export-Package</code>列表严格控制访问范围。</li></ul><p>假设存在<code>Bundle A</code>、<code>Bundle B</code>、<code>Bundle C</code>这<code>3</code>个模块，并且这<code>3</code>个<code>Bundle</code>定义的依赖关系如下：</p><ul><li><code>Bundle A</code>：声明发布了<code>package A</code>，依赖了<code>java.*</code>的包；</li><li><code>Bundle B</code>：声明依赖了<code>package A</code>和<code>package C</code>，同时也依赖了<code>java.*</code>的包；</li><li><code>Bundle C</code>：声明发布了<code>package C</code>，依赖了<code>package A</code>。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OSGiClassloaderArchitecture.PNG" alt="OSGi的类加载器架构"></p><p>在 <code>OSGi</code>里，类加载时可能进行的查找规则如下：</p><ul><li>以<code>java.*</code>开头的类，委派给父类加载器加载。</li><li>否则，委派列表名单内的类，委派给父类加载器加载。</li><li>否则，<code>Import</code>列表中的类，委派给<code>Export</code>这个类的<code>Bundle</code>的类加载器加载。</li><li>否则，查找当前<code>Bundle</code>的<code>Classpath</code>，使用自己的类加载器加载。</li><li>否则，查找是否在自己的<code>Fragment Bundle</code>中，如果是则委派给<code>Fragment Bundle</code>的类加载器加载。</li><li>否则，查找<code>Dynamic Import</code>列表的<code>Bundle</code>，委派给对应<code>Bundle</code>的类加载器加载。</li><li>否则，类查找失败。</li></ul><h4 id="1-3-字节码生成技术与动态代理的实现"><a href="#1-3-字节码生成技术与动态代理的实现" class="headerlink" title="1.3 字节码生成技术与动态代理的实现"></a>1.3 字节码生成技术与动态代理的实现</h4><h5 id="1-3-1-字节码生成技术"><a href="#1-3-1-字节码生成技术" class="headerlink" title="1.3.1 字节码生成技术"></a>1.3.1 字节码生成技术</h5><p>要深入从Java源码到字节码编译过程，阅读<code>Javac</code>的源码是个很好的途径。在Java世界里面除了<code>Javac</code>和字节码类库外，使用到字节码生成的例子比比皆是：</p><ul><li>Web服务器中的<code>JSP编译器</code>，编译时植入的<code>AOP框架</code>；</li><li>动态代理技术；</li><li>使用反射的时候虚拟机有可能会在运行时生成字节码来提高执行速度。</li></ul><h5 id="1-3-2-动态代理技术"><a href="#1-3-2-动态代理技术" class="headerlink" title="1.3.2 动态代理技术"></a>1.3.2 动态代理技术</h5><p>动态代理的优势在于，<u>实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        Object originalObj;</span><br><span class="line"></span><br><span class="line">        <span class="function">Object <span class="title">bind</span><span class="params">(Object originalObj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.originalObj = originalObj;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"welcome"</span>);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(originalObj, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IHello hello = (IHello) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> Hello());</span><br><span class="line">        hello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy::newProxyInstance()</code>方法返回一个实现了<code>IHello</code>的接口，并且代理了<code>new Hello()</code>实例行为的对象，程序进行过验证、优化、缓存、同步、生成字节码、显式类加载等操作，它最后调用<code>sun.misc.ProxyGenerator::generateProxyClass()</code>方法来完成<code>生成字节码</code>的动作，这个方法会在运行时产生一个描述代理类的字节码<strong>byte[]数组</strong>。</p><h4 id="1-4-Backport工具：Java的时光机器"><a href="#1-4-Backport工具：Java的时光机器" class="headerlink" title="1.4 Backport工具：Java的时光机器"></a>1.4 <code>Backport</code>工具：Java的时光机器</h4><p>“Java逆向移植”的工具（<code>Java Backporting Tools</code>）用于把<strong>高版本JDK</strong>中编写的代码放到低版本JDK环境中去部署使用。<code>Retrotranslator</code>和<code>Retrolambda</code>是这类工具中的杰出代表。</p><ul><li><code>Retrotranslator</code>的作用是将<code>JDK 5</code>编译出来的Class文件转变为可以在<code>JDK 1.4</code>或<code>1.3</code>上部署的版本，它能很好地支持<u>自动装箱</u>、<u>泛型</u>、<u>动态注解</u>、<u>枚举</u>、<u>变长参数</u>、<u>遍历循环</u>、<u>静态导入</u>这些语法特性， 甚至还可以支持<code>JDK 5</code>中新增的<u>集合改进</u>、<u>并发包</u>及<u>对泛型、注解等的反射操作</u>。</li><li><code>Retrolambda</code>将<code>JDK 8</code>的<code>Lambda</code>表达式和<code>try-resources</code>语法转变为可以在<code>JDK 5</code>、<code>JDK 6</code>、<code>JDK 7</code>中使用的形式，同时也对<code>接口默认方法</code>提供了<strong>有限度</strong>的支持。</li></ul><p>JDK的每次升级新增的功能大致可以分为以下五类：</p><ol><li>对Java类库API的代码增强。</li><li>在前端编译器层面做的改进。</li><li>需要在字节码中进行支持的改动。</li><li>需要在JDK整体结构层面进行支持的改进。</li><li>集中在虚拟机内部的改进。</li></ol><p>上述的5类新功能中，逆向移植工具能比较完美地模拟了前两类。</p><h3 id="2-实战：自己动手实现远程执行功能"><a href="#2-实战：自己动手实现远程执行功能" class="headerlink" title="2. 实战：自己动手实现远程执行功能"></a>2. 实战：自己动手实现远程执行功能</h3><p>做程序维护的时候会遇到只要在服务中执行一小段程序代码，就可以定位或排除问题，但就是偏偏找不到可以让服务器执行时代码的途径。通常解决这类问题有以下几种途径：</p><ol><li>可以使用<code>BTrace</code>这类<code>JVMTI</code>工具去动态修改程序中某一部分的运行代码，类似的<code>JVMTI</code>工具还有阿里巴巴的<code>Arthas</code>等。</li><li>使用<code>JDK 6</code>之后提供了<code>Compiler API</code>，可以动态地编译Java程序，这样虽然达不到动态语言的灵活度，但让服务器执行临时代码的需求是可以得到解决的。</li><li>写一个<code>JSP文件</code>上传到服务器，然后在浏览器中运行它，或者在服务端程序中加入一个<code>BeanShell Script</code>、<code>JavaScript</code>等的执行引擎去执行动态脚本。</li><li>在应用程序中内置动态执行的功能。</li></ol><h4 id="2-1-目标"><a href="#2-1-目标" class="headerlink" title="2.1 目标"></a>2.1 目标</h4><p>希望最终的产品：</p><ul><li>不依赖某个JDK版本才加入的特性（包括<code>JVMTI</code>），能在目前还被普遍使用的JDK中部署。</li><li>不改变原有服务端程序的部署，不依赖任何第三方类库。</li><li>不侵入原有程序，即无须改动原程序的任何代码。也不会对原有程序的运行带来任何影响。</li><li>考虑到<code>BeanShell Script</code>或<code>JavaScript</code>等脚本与Java对象交互起来不太方便，<code>“临时代码”</code>应该直接支持Java语言。</li><li><code>“临时代码”</code>应当具备足够的自由度，不需要依赖特定的类或实现特定的接口。</li><li><code>“临时代码”</code>的执行结果能返回到客户端，执行结果可以包括程序中输出的信息及抛出的异常等。</li></ul><h4 id="2-2-思路"><a href="#2-2-思路" class="headerlink" title="2.2 思路"></a>2.2 思路</h4><p>需要解决以下3个问题：</p><ol><li>如何编译提交到服务器的Java代码？<ul><li>在服务器上编译，在<code>JDK 6</code>以后可以使用<code>Compiler API</code>，在<code>JDK 6</code>以前可以使用<code>tools.jar</code>包中的 <code>com.sun.tools.Javac.Main</code>类来编译Java文件。这种思路的缺点是引入了额外的依赖，而且把程序绑死在<strong>特定</strong>的<code>JDK</code>上了。</li><li>在客户端编译好，把<strong><u>字节码</u></strong>传到服务端。</li></ul></li><li>如何执行编译之后的Java代码？<ul><li>让类加载器加载这个类生成一个Class对象，然后反射调用一下某个方法；</li></ul></li><li>如何收集Java代码的执行结果？<ul><li>把程序往<code>标准输出（System.out）</code>和<code>标准错误输出（System.err）</code>中打印的信息收集起来。但会对原有程序产生影响：<u>会把其他线程向标准输出中打印的信息也收集了</u>。</li><li>直接在执行的类中把对<code>System.out</code>的符号引用替换为我们准备的<code>PrintStream</code>的符号引用。</li></ul></li></ol><h4 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h4><p>实现过程中需要用到的4个支持类：</p><h5 id="2-3-1-HotSwapClassLoader"><a href="#2-3-1-HotSwapClassLoader" class="headerlink" title="2.3.1 HotSwapClassLoader"></a>2.3.1 <code>HotSwapClassLoader</code></h5><p><code>HotSwapClassLoader</code>类于实现<code>“同一个类的代码可以被多次加载”</code>这个需求。<code>HotSwapClassLoader</code>所做的事情仅仅是公开父类（即<code>java.lang.ClassLoader</code>）中的<code>protected</code>方法<code>defineClass()</code>，我们将会使用这个方法<u><strong>把提交执行的Java类的<code>byte[]</code>数组转变为Class对象</strong></u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了多次载入执行类而加入的加载器</span></span><br><span class="line"><span class="comment"> * 把defineClass方法开放出来，只有外部显式调用的时候才会使用到loadByte方法</span></span><br><span class="line"><span class="comment"> * 由虚拟机调用时，仍然按照原有的双亲委派规则使用loadClass方法进行类加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotSwapClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HotSwapClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HotSwapClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadByte</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, classByte, <span class="number">0</span>, classByte.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-2-ClassModifier"><a href="#2-3-2-ClassModifier" class="headerlink" title="2.3.2 ClassModifier"></a>2.3.2 <code>ClassModifier</code></h5><p><code>ClassModifier</code>类实现将<code>java.lang.System</code>替换为我们自己定义的<code>HackSystem</code>类的过程，它<strong><u>直接修改符合Class文件格式的byte[]数组中的<code>常量池</code>部分，将常量池中指定内容的<code>CONSTANT_Utf8_info</code>常量替换为新的字符串</u></strong>。</p><p>经过<code>ClassModifier</code>处理后的<code>byte[]数组</code>才会传给<code>HotSwapClassLoader.loadByte()</code>方法进行类加载，<code>byte[]数组</code>在这里替换符号引用之后，与客户端直接在Java代码中引用<code>HackSystem</code>类再编译生成的Class是完全一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 修改Class文件，暂时只提供修改常量池常量的功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassModifier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class文件中常量池的起始偏移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_POOL_COUNT_INDEX = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CONSTANT_Utf8_info常量的tag标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_Utf8_info = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量池中11种常量所占的长度，CONSTANT_Utf8_info型常量除外，因为它不是定长的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] CONSTANT_ITEM_LENGTH = &#123; -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] classByte;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassModifier</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classByte = classByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改常量池中CONSTANT_Utf8_info常量的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldStr 修改前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newStr 修改后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 修改结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] modifyUTF8Constant(String oldStr, String newStr) &#123;</span><br><span class="line">        <span class="keyword">int</span> cpc = getConstantPoolCount();</span><br><span class="line">        <span class="keyword">int</span> offset = CONSTANT_POOL_COUNT_INDEX + u2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cpc; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tag = ByteUtils.bytes2Int(classByte, offset, u1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tag == CONSTANT_Utf8_info) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = ByteUtils.bytes2Int(classByte, offset + u1, u2);</span><br><span class="line">                offset += (u1 + u2);</span><br><span class="line">                String str = ByteUtils.bytes2String(classByte, offset, len);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (str.equalsIgnoreCase(oldStr)) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] strBytes = ByteUtils.string2Bytes(newStr);</span><br><span class="line">                    <span class="keyword">byte</span>[] strLen = ByteUtils.int2Bytes(newStr.length(), u2);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset - u2, u2, strLen);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset, len, strBytes);</span><br><span class="line">                    <span class="keyword">return</span> classByte;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    offset += len;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                offset += CONSTANT_ITEM_LENGTH[tag];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classByte;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取常量池中常量的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 常量池数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getConstantPoolCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ByteUtils.bytes2Int(classByte, CONSTANT_POOL_COUNT_INDEX, u2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-3-ByteUtils"><a href="#2-3-3-ByteUtils" class="headerlink" title="2.3.3 ByteUtils"></a>2.3.3 <code>ByteUtils</code></h5><p><code>ClassModifier</code>中涉及对<code>byte[]数组</code>操作的部分， 主要是将<code>byte[]</code>与<code>int</code>和<code>String</code>互相转换，以及把对<code>byte[]数据</code>的替换操作封装在<code>ByteUtils</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** Bytes数组处理工具</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bytes2Int</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = start + len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = ((<span class="keyword">int</span>) b[i]) &amp; <span class="number">0xff</span>;</span><br><span class="line">            n &lt;&lt;= (--len) * <span class="number">8</span>;</span><br><span class="line">            sum = n + sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] int2Bytes(<span class="keyword">int</span> value, <span class="keyword">int</span> len) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            b[len - i - <span class="number">1</span>] = (<span class="keyword">byte</span>) ((value &gt;&gt; <span class="number">8</span> * i) &amp; <span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytes2String</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(b, start, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] string2Bytes(String str) &#123;</span><br><span class="line">        <span class="keyword">return</span> str.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] bytesReplace(<span class="keyword">byte</span>[] originalBytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, <span class="keyword">byte</span>[] replaceBytes) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] newBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[originalBytes.length + (replaceBytes.length - len)];</span><br><span class="line">        System.arraycopy(originalBytes, <span class="number">0</span>, newBytes, <span class="number">0</span>, offset);</span><br><span class="line">        System.arraycopy(replaceBytes, <span class="number">0</span>, newBytes, offset, replaceBytes.length);</span><br><span class="line">        System.arraycopy(originalBytes, offset + len, newBytes, offset + replaceBytes.length, originalBytes.length - offset - len);</span><br><span class="line">        <span class="keyword">return</span> newBytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-HackSystem"><a href="#2-3-4-HackSystem" class="headerlink" title="2.3.4 HackSystem"></a>2.3.4 <code>HackSystem</code></h5><p>用来代替<code>java.lang.System</code>的<code>HackSystem</code>，主要把<code>out</code>和<code>err</code>两个静态变量改成使用<code>ByteArrayOutputStream</code>作为打印目标的同一个<code>PrintStream</code>对象，以及增加了<u><strong>读取</strong></u>、<u><strong>清理</strong></u><code>ByteArrayOutputStream</code>中内容的<code>getBufferString()</code>和 <code>clearBuffer()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为Javaclass劫持java.lang.System提供支持</span></span><br><span class="line"><span class="comment"> * 除了out和err外，其余的都直接转发给System处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HackSystem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> InputStream in = System.in;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out = <span class="keyword">new</span> PrintStream(buffer);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream err = out;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getBufferString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buffer.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSecurityManager</span><span class="params">(<span class="keyword">final</span> SecurityManager s)</span> </span>&#123;</span><br><span class="line">        System.setSecurityManager(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecurityManager <span class="title">getSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.getSecurityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(src, srcPos, dest, destPos, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">identityHashCode</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.identityHashCode(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面所有的方法都与java.lang.System的名称一样</span></span><br><span class="line">    <span class="comment">// 实现都是字节转调System的对应方法</span></span><br><span class="line">    <span class="comment">// 因版面原因，省略了其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-5-JavaclassExecuter"><a href="#2-3-5-JavaclassExecuter" class="headerlink" title="2.3.5 JavaclassExecuter"></a>2.3.5 <code>JavaclassExecuter</code></h5><p><code>JavaclassExecuter</code>是提供给外部调用的入口，调用前面几个支持类组装逻辑，完成类加载工作。</p><ul><li>用输入的符合Class文件格式的<code>byte[]数组</code>替换掉<code>java.lang.System</code>的符号引用后，使用<code>HotSwapClassLoader</code>加载生成一个Class对象；</li><li>然后<code>反射</code>调用这个Class对象的<code>main()</code>方法，如果期间出现任何异常，将异常信息打印到<code>HackSystem.out</code>中，</li><li>最后把缓冲区中的信息作为方法的结果来返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Javaclass执行工具</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaclassExecuter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行外部传过来的代表一个Java类的Byte数组&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 将输入类的byte数组中代表java.lang.System的CONSTANT_Utf8_info常量修改为劫持后的HackSystem类</span></span><br><span class="line"><span class="comment">     * 执行方法为该类的static main(String[] args)方法，输出结果为该类向System.out/err输出的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classByte 代表一个Java类的Byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">execute</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        HackSystem.clearBuffer();</span><br><span class="line">        ClassModifier cm = <span class="keyword">new</span> ClassModifier(classByte);</span><br><span class="line">        <span class="keyword">byte</span>[] modiBytes = cm.modifyUTF8Constant(<span class="string">"java/lang/System"</span>, <span class="string">"org/fenixsoft/classloading/execute/HackSystem"</span>);</span><br><span class="line">        HotSwapClassLoader loader = <span class="keyword">new</span> HotSwapClassLoader();</span><br><span class="line">        Class clazz = loader.loadByte(modiBytes);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = clazz.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[]&#123;String[]<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            method.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> String[]&#123; <span class="keyword">null</span> &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace(HackSystem.out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HackSystem.getBufferString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-验证"><a href="#2-4-验证" class="headerlink" title="2.4 验证"></a>2.4 验证</h4><p>写一个Java类，只要向<code>System.out</code>输出信息即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test executor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立一个测试代码，就可以在输出这个类的运行结果(原文是通过<code>JSP</code>来实现的，这里没有搭建服务器，就用这个小例子试试，可能不是那么合适的代替)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecuter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/Users/yunjiewu/IdeaProjects/JavaLearning/out/production/JavaLearning/JVMLearning/JavaclassExecuter/TestClass.class"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line">            is.close();</span><br><span class="line">            System.out.println(JavaclassExecuter.execute(b));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--8 虚拟机字节码执行引擎</title>
    <link href="https://wuyunjie.top/2021/05/28/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_8_Virtual_machine_bytecode_execution_engine.html"/>
    <id>https://wuyunjie.top/2021/05/28/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_8_Virtual_machine_bytecode_execution_engine.html</id>
    <published>2021-05-28T01:51:15.000Z</published>
    <updated>2021-05-28T01:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>执行引擎是Java虚拟机核心的组成部分之一。<br><a id="more"></a></p></blockquote><p>在不同的虚拟机实现中，执行引擎在执行字节码的时候，通常会有<code>解释执行（通过解释器执行）</code>和<code>编译执行（通过即时编译器产生本地代码执行）</code>两种，也可能两者兼备。</p><p>但从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：</p><ul><li>输入的是字节码二进制流；</li><li>处理过程是字节码解析执行的等效过程；</li><li>输出的是执行结果，</li></ul><h3 id="1-运行时栈帧结构"><a href="#1-运行时栈帧结构" class="headerlink" title="1. 运行时栈帧结构"></a>1. 运行时栈帧结构</h3><p>Java虚拟机<strong><u>以方法作为最基本的执行单元</u></strong>，<code>“栈帧”（Stack Frame）</code>则是用于支持虚拟机进行<strong>方法调用</strong>和<strong>方法执行</strong>背后的数据结构，它也是虚拟机运行时数据区中的<code>虚拟机栈（Virtual Machine Stack）</code>的栈元素。</p><blockquote><p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。一个栈帧需要分配多少内存仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/StackFrame.PNG" alt="栈帧结构"></p><h4 id="1-1-局部变量表"><a href="#1-1-局部变量表" class="headerlink" title="1.1 局部变量表"></a>1.1 局部变量表</h4><p><code>局部变量表（Local Variables Table）</code>是一组变量值的存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>。</p><blockquote><p>局部变量表的容量以<code>变量槽（Variable Slot）</code>为最小单位，一个变量槽应占用的内存空间大小未明确定义，每个变量槽都应该能存放一个<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>reference</code>或<code>returnAddress</code>类型的数据。对于64位的数据类型，Java虚拟机会以<strong>高位对齐</strong>的方式为其分配两个连续的变量槽空间。</p></blockquote><p>Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是<u><strong>从0开始至局部变量表最大的变量槽数量</strong></u>。</p><blockquote><p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成<u><strong>参数值到参数变量列表的传递过程， 即实参到形参的传递</strong></u>。</p><ul><li>如果执行的是实例方法，局部变量表中<strong><u>第0位索引</u></strong>的变量槽默认是<strong><u>用于传递方法所属对象实例的引用</u></strong>，在方法中可以通过关键字<code>“this”</code>来访问到这个隐含的参数。</li><li>其余参数则按照参数表顺序排列，占用<strong><u>从1开始</u></strong>的局部变量槽；</li><li>参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</li></ul></blockquote><p>为了尽可能节省栈帧耗用的内存空间，局部变量表中的变量槽是可以重用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 局部变量表Slot复用对垃圾收集的影响</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>placeholder</code>能否被回收的根本原因就是：局部变量表中的变量槽是否还存有关于<code>placeholder</code>数组对象的引用。</p><ul><li>未加入<code>int a = 0;</code>语句时，虽然已经离开了<code>placeholder</code>的作用域，<code>placeholder</code>原本所占用的变量槽还没有被其他变量所复用，所以作为<code>GC Roots</code>一部分的局部变量表仍然保持着对它的关联。所以<code>placeholder</code>数组对象不会被回收。</li><li>手动将其设置占用了大量内存但实际上已经不会再使用的变量为<code>null</code>值(代替那句<code>int a = 0;</code>)，可以作为一种在极特殊情形下的<code>“奇技”</code>来使用。</li></ul><p>此外，局部变量不像类变量那样存在“准备阶段”，即不会被系统初始化为默认值。</p><h4 id="1-2-操作数栈"><a href="#1-2-操作数栈" class="headerlink" title="1.2 操作数栈"></a>1.2 操作数栈</h4><p><code>操作数栈（Operand Stack）</code>也常被称为操作栈，它是一个<code>后入先出（Last In First Out，LIFO）</code>栈。</p><blockquote><p><code>Javac编译器</code>的<strong>数据流分析工作</strong>保证了在方法执行的任何时候，操作数栈的深度都不会超过在<code>max_stacks</code>数据项中设定的最大值。</p></blockquote><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OperandStackShareData.PNG" alt="栈帧之间的数据共享"></p><p>概念上，两个不同栈帧作为不同方法的虚拟机栈的元素，是<strong><u>完全相互独立</u></strong>的。但在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现<u>一部分重叠</u>。让<strong>下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起</strong>，这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了。</p><h4 id="1-3-动态连接"><a href="#1-3-动态连接" class="headerlink" title="1.3 动态连接"></a>1.3 动态连接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的<code>动态连接（Dynamic Linking）</code>。</p><h4 id="1-4-方法返回地址"><a href="#1-4-方法返回地址" class="headerlink" title="1.4 方法返回地址"></a>1.4 方法返回地址</h4><p>当一个方法开始执行后，只有两种方式退出这个方法：</p><ol><li>第一种方式是<u><strong>执行引擎遇到任意一个方法返回的字节码指令</strong></u>，这时候可能会有返回值传递给上层的方法调用者，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为<code>“正常调用完成”（Normal Method Invocation Completion）</code>。</li><li>另外一种是在<u><strong>方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理</strong></u>。无论是Java虚拟机内部产生的异常，还是代码中使用<code>athrow</code>字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为<code>“异常调用完成（Abrupt Method Invocation Completion）”</code>。一个方法使用异常完成出口的方式退出，是<strong><u>不会给它的上层调用者提供任何返回值的</u></strong>。</li></ol><p>方法退出之后必须返回到最初方法被调用时的位置，退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p><ul><li>方法正常退出时，<u><strong>主调方法的PC计数器的值就可以作为返回地址</strong></u>，栈帧中很可能会保存这个计数器值；</li><li>方法异常退出时，<u><strong>返回地址要通过异常处理器表来确定</strong></u>，栈帧中就一般不会保存这部分信息。</li></ul><h4 id="1-5-附加信息"><a href="#1-5-附加信息" class="headerlink" title="1.5 附加信息"></a>1.5 附加信息</h4><p>比如与调试、性能收集相关的信息。一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为<code>栈帧信息</code>。</p><h3 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h3><p><strong>方法调用并<u>不等同于</u>方法中的代码被执行</strong>，方法调用阶段唯一的任务就是<strong>确定被调用方法的版本</strong>。</p><h4 id="2-1-解析"><a href="#2-1-解析" class="headerlink" title="2.1 解析"></a>2.1 解析</h4><p>所有方法调用的目标方法在Class文件里面都是一个<strong>常量池中的符号引用</strong>，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：</p><ul><li>方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为<code>解析（Resolution）</code>。</li></ul><blockquote><p>在Java语言中符合<code>“编译期可知，运行期不可变”</code>这个要求的方法，主要有静态方法、私有方法、实例构造器、父类方法，再加上被<code>final</code>修饰的方法（尽管它使用<code>invokevirtual</code>指令调用），这5种方法调用会在<strong>类加载</strong>的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为<code>“非虚方法”（Non-Virtual Method）</code>，其他方法就被称为<code>“虚方法”（Virtual Method）</code>。</p></blockquote><p>解析调用一定是个<code>静态的过程</code>，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用。</p><h4 id="2-2-分派"><a href="#2-2-分派" class="headerlink" title="2.2 分派"></a>2.2 分派</h4><p><code>分派 （Dispatch）</code>调用可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。</p><h5 id="2-2-1-静态分派"><a href="#2-2-1-静态分派" class="headerlink" title="2.2.1 静态分派"></a>2.2.1 静态分派</h5><p>通过如下代码来定义两个关键概念：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure><ul><li><code>静态类型（Static Type）</code>。“Human”称为变量的<code>“静态类型”（Static Type）</code>，或者叫<code>“外观类型”（Apparent Type）</code>，静态类型的变化仅仅<u>在使用时发生</u>，变量本身的静态类型不会被改变，并且最终的静态类型是<u><strong>在编译期可知的</strong></u>；</li><li><code>实际类型（Actual Type）</code>。“Man”则被称为变量的<code>“实际类型”（Actual Type）</code>或者叫<code>“运行时类型”（Runtime Type）</code>，实际类型变化的结果<u>在运行期才可确定</u>，编译器<strong><u>在编译程序的时候并不知道</u></strong>一个对象的实际类型是什么。</li></ul><p>比如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line">Human human = (<span class="keyword">new</span> Random()).nextBoolean() ? <span class="keyword">new</span> Man() : <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">sr.sayHello((Man) human)</span><br><span class="line">sr.sayHello((Woman) human)</span><br></pre></td></tr></table></figure><ul><li>对象<code>human</code>的实际类型是可变的，到底是Man还是Woman，必须等到程序运行到这行的时候才能确定。</li><li>human的静态类型是Human，也可以在使用时（如<code>sayHello()</code>方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的</li></ul><p>在如下的例子中，使用哪个重载版本的<code>sayHello()</code>方法，完全取决于传入参数的数量和数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,guy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,gentleman!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,lady!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机（或者准确地说是编译器）在重载时是<strong><u>通过参数的静态类型而不是实际类型作为判定依据的</u></strong>，所以在编译阶段，<code>Javac</code>编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了<code>sayHello(Human)</code>作为调用目标。</p><blockquote><p>所有依赖<code>静态类型</code>来决定方法执行版本的分派动作，都称为<code>静态分派</code>。</p></blockquote><p>静态分派的最典型应用表现就是<code>方法重载</code>。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。从下面的示例代码可以看出方法重载中，选择重载版本的匹配优先级：</p><ul><li><p>如果注释掉 <code>sayHello(char arg)</code>方法，会输出：<code>hello int</code>。这时发生了一次自动类型转换，<code>&#39;a&#39;</code>转换为<code>int</code>类型。</p></li><li><p>继续注释掉<code>sayHello(int arg)</code>方法，那输出会变为：<code>hello long</code>。这时发生了两次自动类型转换，<code>&#39;a&#39;</code>转型为整数<code>97</code>之后，进一步转型为长整数<code>97L</code>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello int"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello long"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Serializable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动转型可以依<code>据char&gt;int&gt;long&gt;float&gt;double</code>的顺序转型进行匹配。</li><li>自动装箱为封装类型<code>java.lang.Character</code>，但是自动装箱的封装类型<code>java.lang.Character</code>不会转换为其他封装类型，比如<code>Integer</code>。</li><li>封装类型<code>java.lang.Character</code>只能安全地转型为它实现的接口(如<code>java.lang.Serializable</code>)或父类(如<code>Object</code>)。</li><li>可见变长参数的重载优先级是最低的，这里使用的是<code>char</code>类型的变长参数。</li></ul><h5 id="2-2-2-动态分派"><a href="#2-2-2-动态分派" class="headerlink" title="2.2.2 动态分派"></a>2.2.2 动态分派</h5><p>动态分派与<code>重写（Override）</code>有着密切关联，考虑如下方法的动态分派：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法动态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"woman say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里选择调用的方法版本不可能再根据静态类型来决定的，因为静态类型同样都是<code>Human</code>的两个变量<code>man</code>和<code>woman</code>在调用<code>sayHello()</code>方法时产生了不同的行为。导致这个现象的原因很明显，是因为这两个变量的<code>实际类型</code>不同。</p><p>从子节码看，这两条调用指令无论是指令（都是<code>invokevirtual</code>）还是参数都完全一样，但是这两句指令最终执行的目标方法并不相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span><br><span class="line">20: aload_2</span><br><span class="line">21: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span><br></pre></td></tr></table></figure><p><code>invokevirtual</code>指令的运行时解析过程大致分为以下几步：</p><ol><li>找到操作数栈顶的第一个元素所指向的对象的<code>实际类型</code>，记作<code>C</code>。</li><li>如果在类型<code>C</code>中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回<code>java.lang.IllegalAccessError</code>异常。</li><li>否则，按照继承关系从下往上依次对<code>C</code>的各个父类进行第二步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li></ol><p><code>invokevirtual</code>指令执行的第一步就是在运行期确定<code>接收者（Receiver）</code>的<code>实际类型</code>，所以两次调用中的 <code>invokevirtual</code>指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。</p><blockquote><p>把这种在运行期根据<code>实际类型</code>确定方法执行版本的分派过程称为<code>动态分派</code>。</p></blockquote><h5 id="2-2-3-单分派与多分派"><a href="#2-2-3-单分派与多分派" class="headerlink" title="2.2.3 单分派与多分派"></a>2.2.3 单分派与多分派</h5><p>方法的<code>接收者</code>与方法的<code>参数</code>统称为方法的<code>宗量</code>，根据分派基于多少种宗量，可以将分派划分为<code>单分派</code>和<code>多分派</code>两种。</p><ul><li><code>单分派</code>是根据一个宗量对目标方法进行选择；</li><li><code>多分派</code>则是根据多于一个宗量对目标方法进行选择。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单分派、多分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先是编译阶段中编译器的选择过程，也就是<code>静态分派</code>的过程。选择目标方法的依据有两点：</p><ul><li>一是静态类型是Father还是Son；</li><li>二是方法参数是QQ还是360。</li></ul></li><li><p>选择结果的最终产生了两条<code>invokevirtual</code>指令，两条指令的参数分别为常量池中指向<code>Father::hardChoice(360)</code>及<code>Father::hardChoice(QQ)</code>方法的符号引用。</p></li></ul><blockquote><p>因为是根据两个宗量进行选择，所以Java语言的<code>静态分派</code>属于<code>多分派</code>类型。</p></blockquote><ul><li>然后是运行阶段中虚拟机的选择，也就是动态分派的过程：<ul><li>执行<code>“son.hardChoice(new QQ())”</code>所对应的<code>invokevirtual</code>指令时，由于编译期已经决定目标方法的签名必须为<code>hardChoice(QQ)</code>，这时候参数的<code>静态类型</code>、<code>实际类型</code>都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有该方法的<code>接受者的实际类型</code>。</li></ul></li></ul><blockquote><p>因为只有一个宗量作为选择依据， 所以Java语言的<code>动态分派</code>属于<code>单分派</code>类型。</p></blockquote><p>如今的Java语言是一门<code>静态多分派</code>、<code>动态单分派</code>的语言。</p><h5 id="2-3-4-虚拟机动态分派的实现"><a href="#2-3-4-虚拟机动态分派的实现" class="headerlink" title="2.3.4 虚拟机动态分派的实现"></a>2.3.4 虚拟机动态分派的实现</h5><p>动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的<code>方法元数据</code>中搜索合适的目标方法。基于执行性能的考虑，一种基础而且常见的优化手段是使用<code>虚方法表索引</code>来代替元数据查找以提高性能。</p><ul><li>为类型在方法区中建立一个<code>虚方法表（Virtual Method Table</code>，也称为<code>vtable</code>）</li><li>在<code>invokeinterface</code>执行时也会用到接口方法表（<code>Interface Method Table</code>，简称<code>itable</code>）</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/MethodTable.PNG" alt="方法表结构"></p><p>虚方法表中存放着各个方法的<code>实际入口地址</code>。</p><ul><li>如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。</li><li>如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</li></ul><p>具有<code>相同签名</code>的方法，在父类、子类的虚方法表中都应当具有一样的<code>索引序号</code>，当类型变换时仅需要变更查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p><p>虚拟机除了使用虚方法表之外，为了进一步提高性能，还会使用<code>类型继承关系分析（Class Hierarchy Analysis，CHA）</code>、<code>守护内联（Guarded Inlining）</code>、<code>内联缓存（Inline Cache）</code>等多种非稳定的激进优化来争取更大的性能空间。</p><h3 id="3-动态类型语言支持"><a href="#3-动态类型语言支持" class="headerlink" title="3. 动态类型语言支持"></a>3. 动态类型语言支持</h3><p><code>invokedynamic</code>指令是为了实现<code>动态类型语言（Dynamically Typed Language）</code>支持而进行的改进。</p><h4 id="3-1-动态类型语言"><a href="#3-1-动态类型语言" class="headerlink" title="3.1 动态类型语言"></a>3.1 动态类型语言</h4><p><code>动态类型语言</code>的<u>关键特征</u>是<strong><u>它的类型检查的主体过程是在运行期而不是编译期进行的</u></strong>。在编译期就进行类型检查过程的语言（譬如C++和Java等）就是<code>静态类型语言</code>。</p><p>动态类型语言与<code>Java</code>有一个核心的差异就是<u><strong>变量本身并没有类型，变量的值才具有类型</strong></u>，所以编译器在编译时最多只能确定<u>方法名称</u>、<u>参数</u>、<u>返回值</u>这些信息，而不会去确定方法所在的具体类型（即方法接收者不固定）。</p><blockquote><p><code>“变量无类型而变量值才有类型”</code>是动态类型语言的一个核心特征。</p></blockquote><h4 id="3-2-Java与动态类型"><a href="#3-2-Java与动态类型" class="headerlink" title="3.2 Java与动态类型"></a>3.2 Java与动态类型</h4><p><code>JDK 7</code>以前的字节码指令集中，4条方法调用指令（<code>invokevirtual</code>、<code>invokespecial</code>、<code>invokestatic</code>、 <code>invokeinterface</code>）的第一个参数都是<code>被调用方法的符号引用</code>，方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定方法的接收者。</p><h4 id="3-3-java-lang-invoke包"><a href="#3-3-java-lang-invoke包" class="headerlink" title="3.3 java.lang.invoke包"></a>3.3 <code>java.lang.invoke</code>包</h4><p><code>JDK 7</code>时新加入的<code>java.lang.invoke</code>包的主要目的是<u><strong>在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制</strong></u>，称为<code>“方法句柄”（Method Handle）</code>。</p><p>拥有方法句柄之后，Java语言也可以拥有类似于<code>函数指针</code>或者<code>委托</code>的方法别名这样的工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JSR 292 MethodHandle基础用法演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> ClassA();</span><br><span class="line">        <span class="comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。</span></span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">"icyfenix"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和具体参数（methodType()第二个及以后的参数）。</span></span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</span></span><br><span class="line">        <span class="comment">// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情。</span></span><br><span class="line">        <span class="keyword">return</span> lookup().findVirtual(reveiver.getClass(), <span class="string">"println"</span>, mt).bindTo(reveiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getPrintlnMH()</code>方法实际上是模拟了<code>invokevirtual</code>指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个由用户设计的Java方法来实现。而这个方法本身的返回值 <code>（MethodHandle对象）</code>，可以视为对最终调用方法的一个<code>“引用”</code>。</p><p><code>MethodHandle</code>与<code>Reflection</code>的区别：</p><ul><li><code>Reflection</code>和<code>MethodHandle</code>机制本质上都是在<strong>模拟方法调用</strong>，但是<code>Reflection</code>是在<strong>模拟Java代码层次</strong>的方法调用，而<code>MethodHandle</code>是在<strong>模拟字节码层次</strong>的方法调用。</li><li><code>Reflection</code>中的<code>java.lang.reflect.Method</code>比<code>MethodHandle</code>中的 <code>java.lang.invoke.MethodHandle</code>对象所包含的信息多。<ul><li>前者是方法在Java端的全面映像，包含了方法的<u>签名</u>、<u>描述符</u>以及<u>方法属性表中各种属性的Java端表示方式</u>，还包含<u>执行权限等的运行期信息</u>。</li><li>后者仅包含执行该方法的相关信息。<code>Reflection</code>是重量级，而<code>MethodHandle</code> 是轻量级。</li></ul></li><li>理论上<code>MethodHandle</code>上也可以采用虚拟机在字节码层次的各种优化方法 （如方法内联），而通过反射去调用方法则几乎不可能直接去实施各类调用点优化措施。</li><li><code>Reflection API</code>的设计目标是只为Java语言服务的，而<code>MethodHandle</code>则设计为可服务于所有Java虚拟机之上的语言。</li></ul><h4 id="3-4-invokedynamic指令"><a href="#3-4-invokedynamic指令" class="headerlink" title="3.4 invokedynamic指令"></a>3.4 <code>invokedynamic</code>指令</h4><p><code>invokedynamic</code>指令与<code>MethodHandle</code>机制的作用是一样的，都是把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中。两者的思路也是可类比的，只是一个用<strong>上层代码和API</strong>来实现， 另一个用<strong>字节码和Class中其他属性、常量</strong>来完成。</p><p>每一处含有<code>invokedynamic</code>指令的位置都被称作<code>“动态调用点（Dynamically-Computed Call Site）”</code>，这条指令的第一个参数是<code>JDK 7</code>时新加入的<code>CONSTANT_InvokeDynamic_info</code>常量，从中可以得到3项信息：</p><ul><li><code>引导方法（Bootstrap Method）</code>，该方法存放在新增的<code>BootstrapMethods</code>属性中，有固定的参数，并且返回值规定是<code>java.lang.invoke.CallSite</code>对象，这个对象代表了真正要执行的目标方法调用；</li><li><code>方法类型（MethodType）</code>；</li><li><code>名称</code>。</li></ul><h3 id="4-基于栈的字节码解释执行引擎"><a href="#4-基于栈的字节码解释执行引擎" class="headerlink" title="4. 基于栈的字节码解释执行引擎"></a>4. 基于栈的字节码解释执行引擎</h3><h4 id="4-1-解释执行"><a href="#4-1-解释执行" class="headerlink" title="4.1 解释执行"></a>4.1 解释执行</h4><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过如下各个步骤</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/compileProcess.PNG" alt="编译过程"></p><h4 id="4-2-基于栈的指令集与基于寄存器的指令集"><a href="#4-2-基于栈的指令集与基于寄存器的指令集" class="headerlink" title="4.2 基于栈的指令集与基于寄存器的指令集"></a>4.2 基于栈的指令集与基于寄存器的指令集</h4><p><code>基于栈的指令集架构（Instruction Set Architecture，ISA）</code>，字节码指令流里面的指令大部分都是<strong><u>零地址指令</u></strong>，它们依赖操作数栈进行工作。<code>Javac</code>编译器输出的字节码指令流基本上是基于栈的指令集架构。</p><ul><li>主要优点是可移植，因为寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。还有一些其他的优点，如代码相对更加紧凑，编译器实现更加简单。</li><li>主要缺点是理论上执行速度相对来说会稍慢一些。完成相同功能所需的指令数量一般会比寄存器架构来得更多，更重要的是栈实现在内存中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。</li></ul><p><code>基于寄存器的指令集</code>，就是现在我们主流PC机中物理硬件直接支持的指令集架构，这些指令依赖寄存器进行工作。最典型的就是<code>x86</code>的<strong><u>二地址指令集</u></strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;执行引擎是Java虚拟机核心的组成部分之一。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--7 虚拟机类加载机制</title>
    <link href="https://wuyunjie.top/2021/05/27/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_7_Virtual_machine_class_loading_mechanism.html"/>
    <id>https://wuyunjie.top/2021/05/27/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_7_Virtual_machine_class_loading_mechanism.html</id>
    <published>2021-05-27T05:31:54.000Z</published>
    <updated>2021-05-27T05:31:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>在Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。<br><a id="more"></a></p></blockquote><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的<code>类加载机制</code>。</p><h3 id="1-类加载的时机"><a href="#1-类加载的时机" class="headerlink" title="1. 类加载的时机"></a>1. 类加载的时机</h3><p>一个类型<strong><u>从被加载到虚拟机内存中开始，到卸载出内存为止</u></strong>，它的整个生命周期将会经历七个阶段:</p><ul><li>加载（Loading）</li><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）</li><li>初始化 （Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><p>其中验证、准备、解析三个部分统称为连接（Linking）。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ClassLifeCycle.PNG" alt="类的生命周期"></p><blockquote><p>解析阶在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的<code>运行时绑定</code>特性（也称为<code>动态绑定</code>或<code>晚期绑定</code>）。</p></blockquote><p>只有六种情况必须立即对类进行<code>“初始化”</code>（而加载、验证、准备自然需要在此之前开始）：</p><ul><li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段；</li><li>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化；</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；<ul><li>一个<code>接口</code>在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li></ul></li><li>当虚拟机启动时，用户需要指定一个要执行的<code>主类（包含main()方法的那个类）</code>，虚拟机会先初始化这个主类；</li><li>当使用<code>JDK 7</code>新加入的<code>动态语言支持</code>时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析的方法句柄对应的类没有进行过初始化，则需要先触发其初始化；</li><li>当一个接口中定义了<code>JDK 8</code>新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化；</li></ul><h3 id="2-类加载的过程"><a href="#2-类加载的过程" class="headerlink" title="2. 类加载的过程"></a>2. 类加载的过程</h3><h4 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h4><p><code>“加载”（Loading）</code>阶段是整个<code>“类加载”（Class Loading）</code>过程中的一个阶段，在加载阶段，Java虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的<code>二进制字节流</code>。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的<code>findClass()</code>或<code>loadClass()</code>方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p><h4 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是<u>确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</u>。从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节 码验证和符号引用验证。</p><h5 id="2-2-1-文件格式验证"><a href="#2-2-1-文件格式验证" class="headerlink" title="2.2.1 文件格式验证"></a>2.2.1 文件格式验证</h5><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p><p>该验证阶段的主要目的是<u><strong>保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。</strong></u>这阶段的验证是<strong>基于二进制字节流进行的</strong>，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储。</p><h5 id="2-2-2-元数据验证"><a href="#2-2-2-元数据验证" class="headerlink" title="2.2.2 元数据验证"></a>2.2.2 元数据验证</h5><p>对字节码描述的信息进行<code>语义分析</code>，以保证其描述的信息符合《Java语言规范》的要求。</p><h5 id="2-2-3-字节码验证"><a href="#2-2-3-字节码验证" class="headerlink" title="2.2.3 字节码验证"></a>2.2.3 字节码验证</h5><p>通过<code>数据流分析</code>和<code>控制流分析</code>，确定程序语义是合法的、符合逻辑的。</p><p>这阶段对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。</p><h5 id="2-2-4-符号引用验证"><a href="#2-2-4-符号引用验证" class="headerlink" title="2.2.4 符号引用验证"></a>2.2.4 符号引用验证</h5><p>符号引用验证可以看作是<strong><u>对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验</u></strong>，即该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p><p>该校验过程发生在虚拟机<u>将符号引用转化为直接引用</u>的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</p><h4 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3 准备"></a>2.3 准备</h4><p>准备阶段是正式<u><strong>为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值</strong></u>的阶段。</p><p>两个容易产生混淆的概念：</p><ul><li>此时进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</li><li>这里所说的初始值“通常情况”下是<code>数据类型的零值</code>。<ul><li>比如对于<code>public static int value = 123;</code>，变量value在准备阶段过后的初始值为0，把 <code>value</code>赋值为<code>123</code>的<code>putstatic</code>指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中，所以把<code>value</code>赋值为<code>123</code>的动作要到<strong>类的初始化阶段</strong>才会被执行。</li><li>如果类字段的字段属性表中存在<code>ConstantValue</code>属性，那在准备阶段变量值就会被初始化为<code>ConstantValue</code>属性所指定的初始值(比如<code>public static final int value = 123;</code>)</li></ul></li></ul><h4 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 解析</h4><p>解析阶段是Java虚拟机<strong>将常量池内的符号引用替换为直接引用</strong>的过程。</p><ul><li><code>符号引用（Symbolic References）</code>：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的<strong>字面量</strong>，只要使用时能无歧义地定位到目标即可。<ul><li>符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。</li></ul></li><li><code>直接引用（Direct References）</code>：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。<ul><li>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</li><li>如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li></ul></li></ul><p>虚拟机实现可以对第一次解析的结果进行缓存(除<code>invokedynamic</code>指令以外)，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。无论是否真正执行了多次解析动作，Java虚拟机都需要保证的是在同一个实体中：</p><ul><li>如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功；</li><li>如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功加载进Java虚拟机内存之中。 </li></ul><p>对于<code>invokedynamic</code>指令，上面的规则就不成立了。当碰到某个前面已经由<code>invokedynamic</code>指令触发过解析的符号引用时，并不意味着这个解析结果对于其他<code>invokedynamic</code>指令也同样生效。</p><ul><li><code>invokedynamic</code>指令的目的本来就是用于动态语言支持，它对应的引用称为<code>“动态调用点限定符 （Dynamically-Computed Call Site Specifier）”</code>，这里<code>“动态”</code>的含义是指<u><strong>必须等到程序实际运行到这条指令时，解析动作才能进行</strong></u>。</li></ul><p>解析动作主要针对<u><strong>类或接口</strong></u>、<u><strong>字段</strong></u>、<u><strong>类方法</strong></u>、<u><strong>接口方法</strong></u>、<u><strong>方法类型</strong></u>、<u><strong>方法句柄</strong></u>和<u><strong>调用点限定符</strong></u>这7类符号引用进行。</p><h5 id="2-4-1-类或接口的解析"><a href="#2-4-1-类或接口的解析" class="headerlink" title="2.4.1 类或接口的解析"></a>2.4.1 类或接口的解析</h5><p>假设当前代码所处的类为<code>D</code>，如果要把一个从未解析过的符号引用<code>N</code>解析为一个类或接口<code>C</code>的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p><ol><li>如果<code>C</code>不是一个数组类型，那虚拟机将会把代表<code>N</code>的全限定名传递给<code>D</code>的类加载器去加载这个类<code>C</code>。</li><li>如果<code>C</code>是一个数组类型，并且数组的元素类型为对象，也就是<code>N</code>的描述符会是类似“<code>[Ljava/lang/Integer</code>”的形式，那将会按照第一点的规则加载数组元素类型。</li><li>如果上面两步没有出现任何异常，那么<code>C</code>在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认<code>D</code>是否具备对<code>C</code>的访问权限。如果发现不具备访问权限， 将抛出<code>java.lang.IllegalAccessError</code>异常。</li></ol><p>如果我们说一个<code>D</code>拥有<code>C</code>的访问权限，那就意味着以下3条规则中至少有其中一条成立：</p><ul><li>被访问类<code>C</code>是<code>public</code>的，并且与访问类<code>D</code>处于同一个模块。</li><li>被访问类<code>C</code>是<code>public</code>的，不与访问类<code>D</code>处于同一个模块，但是<code>被访问类C</code>的模块允许<code>访问类D</code>的模块进行访问。 </li><li>被访问类<code>C</code>不是<code>public</code>的，但是它与访问类<code>D</code>处于同一个包中。</li></ul><h5 id="2-4-2-字段解析"><a href="#2-4-2-字段解析" class="headerlink" title="2.4.2 字段解析"></a>2.4.2 字段解析</h5><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内<code>class_index</code>项中索引的<code>CONSTANT_Class_info</code>符号引用进行解析，也就是<strong><u>字段所属的类或接口的符号引用</u></strong>。</p><p>如果解析成功完成，那把这个字段所属的类或接口用<code>C</code>表示，按照如下步骤对C进行后续字段的搜索：</p><ol><li>如果<code>C</code>本身就包含了<strong>简单名称</strong>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>如果在<code>C</code>中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口， 如果接口中包含了<strong>简单名称</strong>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>如果<code>C</code>不是<code>java.lang.Object</code>的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了<code>简单名称</code>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，查找失败，抛出<code>java.lang.NoSuchFieldError</code>异常。</li></ol><p>如果查找过程成功返回了引用，将会对这个字段进行权限验证。</p><h5 id="2-4-3-方法解析"><a href="#2-4-3-方法解析" class="headerlink" title="2.4.3 方法解析"></a>2.4.3 方法解析</h5><p>方法解析的第一个步骤也是需要先解析出方法表的<code>class_index</code>项中索引的方法所属的类或接口的符号引用，如果解析成功，那么依然用<code>C</code>表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：</p><ol><li>由于Class文件格式中<strong><u>类的方法和接口的方法符号引用的常量类型定义是分开的</u></strong>，如果在类的方法表中发现<code>class_index</code>中索引的<code>C</code>是个接口的话，那就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li><li>在类<code>C</code>中查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>在类<code>C</code>的父类中递归查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>在类<code>C</code>实现的接口列表及它们的父接口之中递归查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果存在匹配的方法，说明类<code>C</code>是一个抽象类，这时候查找结束，抛出<code>java.lang.AbstractMethodError</code>异常。</li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>。 </li></ol><p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证。</p><h5 id="2-4-4-接口方法解析"><a href="#2-4-4-接口方法解析" class="headerlink" title="2.4.4 接口方法解析"></a>2.4.4 接口方法解析</h5><p>接口方法也是需要先解析出接口方法表的<code>class_index</code>项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用<code>C</code>表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p><ol><li>与类的方法解析相反，如果在接口方法表中发现<code>class_index</code>中的索引<code>C</code>是个类而不是接口，那么就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li><li>在接口<code>C</code>中查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>在接口<code>C</code>的父接口中递归查找，直到<code>java.lang.Object</code>类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。<ul><li>由于Java的<u>接口允许多重继承</u>，如果C的不同父接口中存有<u>多个</u><strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，不同发行商实现的<code>Javac</code>编译器有可能会按照<u><strong>更严格的约束拒绝编译这种代码来避免不确定性</strong></u>。</li></ul></li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</li></ol><blockquote><ul><li>在<code>JDK 9</code>之前，Java接口中的所有方法都<u>默认是<code>public</code>的</u>，也没有模块化的访问约束，所以不存在访问权限的问题。</li><li>但在<code>JDK 9</code>中增加了<u>接口的静态私有方法</u>，也有了模块化的访问约束，所以接口方法的访问也完全有可能因访问权限控制而出现<code>java.lang.IllegalAccessError</code>异常。</li></ul></blockquote><h4 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h4><blockquote><p>直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p></blockquote><p>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><blockquote><p><code>&lt;clinit&gt;()</code>并不是程序员在Java代码中直接编写的方法，它是<code>Javac</code>编译器的自动生成物。</p></blockquote><p><code>&lt;clinit&gt;()</code>方法是由编译器<u>自动收集</u>类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块（static{}块）中的语句</strong>合并产生的。</p><ul><li><code>&lt;clinit&gt;()</code>方法不需要显式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。意味着父类中定义的静态语句块要优先于子类的变量赋值操作；</li><li><code>&lt;clinit&gt;()</code>方法不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法</li><li>执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，接口的<strong><u>实现类</u></strong>在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法；</li><li>Java虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法方法在多线程环境中被正确地加锁同步。</li><li>同一个类加载器下，一个类型只会被初始化一次。</li></ul><h3 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3. 类加载器"></a>3. 类加载器</h3><p>实现<code>“通过一个类的全限定名来获取描述该类的二进制字节流”</code>这个动作的代码被称为<code>“类加载器”（Class Loader）</code>。</p><h4 id="3-1-类与类加载器"><a href="#3-1-类与类加载器" class="headerlink" title="3.1 类与类加载器"></a>3.1 类与类加载器</h4><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的<strong><u>唯一性</u></strong>，每一个类加载器都拥有一个独立的类名称空间。</p><blockquote><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，只要加载它们的类加载器不同，那这两个类就<strong>必定不相等</strong>。</p></blockquote><h4 id="3-2-双亲委派模型"><a href="#3-2-双亲委派模型" class="headerlink" title="3.2 双亲委派模型"></a>3.2 双亲委派模型</h4><p>Java虚拟机的角度来看，只存在两种不同的类加载器：</p><ul><li><code>启动类加载器（Bootstrap ClassLoader）</code>，这个类加载器是虚拟机自身的一部分；</li><li>其他所有的类加载器，这些类加载器都由Java语言实现，<strong><u>独立存在于虚拟机外部</u></strong>，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。</li></ul><p>Java开发人员的角度来看，类加载器是<code>三层类加载器</code>、<code>双亲委派</code>的类加载架构：</p><ul><li><code>启动类加载器（Bootstrap Class Loader）</code>：负责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用；</li><li><code>扩展类加载器（Extension Class Loader）</code>：负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库。这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoader</code>中以Java代码的形式实现的。</li><li><code>应用程序类加载器（Application Class Loader）</code>：负责加载用户类路径<code>（ClassPath）</code>上所有的类库，由 <code>sun.misc.Launcher$AppClassLoader</code>来实现。</li></ul><p><u><code>JDK 9</code>之前</u>的Java应用都是由这三种类加载器互相配合来完成加载的，用户可以加入自定义的类加载器来进行拓展，如：</p><ul><li>增加除了磁盘位置之外的Class文件来源</li><li>通过类加载器实现类的隔离、重载等功能。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ParentsDelegation.PNG" alt="双亲委派模型"></p><p><code>“双亲委派模型（Parents Delegation Model）”</code>要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p><blockquote><p>类加载器之间的父子关系一般不是以<code>继承（Inheritance）</code>来实现的，而是通常使用<code>组合（Composition）</code>关系来复用父加载器的代码。</p></blockquote><p>双亲委派模型的工作过程是：</p><ul><li>如果一个类加载器收到了类加载的请求，首先把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中；</li><li>只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</li></ul><h4 id="3-3-破坏双亲委派模型"><a href="#3-3-破坏双亲委派模型" class="headerlink" title="3.3 破坏双亲委派模型"></a>3.3 破坏双亲委派模型</h4><p>直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况：</p><ul><li>第一次“被破坏”其实发生在双亲委派模型出现之前——即<code>JDK 1.2</code>面世以前。</li><li>第二次“被破坏”是由这个模型自身的缺陷导致的，有基础类型要调用回用户的代码。</li><li>第三次“被破坏”是由于用户对程序动态性的追求而导致的。</li></ul><p><code>OSGi</code>实现模块化热部署的关键是<u><strong>它自定义的类加载器机制的实现</strong></u>：</p><ul><li>每一个程序模块（<code>OSGi</code>中称为<code>Bundle</code>）都有一个自己的类加载器，当需要更换一个<code>Bundle</code>时，就把<code>Bundle</code>连同类加载器一起换掉以实现代码的热替换。</li></ul><p>在<code>OSGi</code>环境下，类加载器发展为更加复杂的网状结构，当收到类加载请求时，<code>OSGi</code>将按照下面的顺序进行类搜索：</p><ol><li>将以<code>java.*</code>开头的类，委派给父类加载器加载。</li><li>否则，将委派列表名单内的类，委派给父类加载器加载。</li><li>否则，将<code>Import</code>列表中的类，委派给<code>Export</code>这个类的<code>Bundle</code>的类加载器加载。</li><li>否则，查找当前<code>Bundle</code>的<code>ClassPath</code>，使用自己的类加载器加载。</li><li>否则，查找类是否在自己的<code>Fragment Bundle</code>中，如果在，则委派给<code>Fragment Bundle</code>的类加载器加载。</li><li>否则，查找<code>Dynamic Import</code>列表的<code>Bundle</code>，委派给对应<code>Bundle</code>的类加载器加载。</li><li>否则，类查找失败。</li></ol><h3 id="4-Java模块化系统"><a href="#4-Java模块化系统" class="headerlink" title="4. Java模块化系统"></a>4. Java模块化系统</h3><p><code>JDK 9</code>中引入的<code>Java模块化系统（Java Platform Module System，JPMS）</code>能够实现模块化的关键目标——可配置的封装隔离机制。<code>JDK 9</code>的模块除了简单地充当代码的容器，还包含以下内容：</p><ul><li>依赖其他模块的列表。</li><li>导出的包列表，即其他模块可以使用的列表。</li><li>开放的包列表，即其他模块可反射访问模块的列表。</li><li>使用的服务列表。</li><li>提供服务的实现列表。</li></ul><p><u><strong>可配置的封装隔离机制</strong></u>解决了：</p><ul><li><code>JDK 9</code>之前基于<code>类路径（ClassPath）</code>来查找依赖的<strong>可靠性问题</strong>。</li><li>原来类路径上跨<code>JAR</code>文件的<code>public</code>类型的<strong>可访问性问题</strong>。</li></ul><h4 id="4-1-模块的兼容性"><a href="#4-1-模块的兼容性" class="headerlink" title="4.1 模块的兼容性"></a>4.1 模块的兼容性</h4><p><code>JDK 9</code>提出了与<code>“类路径”（ClassPath）</code>相对应的<code>“模块路径”（ModulePath）</code>的概念，使<u><strong>可配置的封装隔离机制</strong></u>能够兼容传统的类路径查找机制。</p><p>模块化系统将按照以下规则来保证使用传统类路径依赖的Java程序可以不经修改地直接运行在<code>JDK 9</code>及以后的Java版本上：</p><ul><li><strong>JAR文件在类路径的访问规则</strong>：所有类路径下的<code>JAR</code>文件及其他资源文件，都被视为自动打包在一个<code>匿名模块（Unnamed Module）</code>里，这个匿名模块<strong>几乎是没有任何隔离的</strong>，它可以看到和使用<u>类路径上所有的包</u>、<u>JDK系统模块中所有的导出包</u>，以及<u>模块路径上所有模块中导出的包</u>。</li><li><strong>模块在模块路径的访问规则</strong>：模块路径下的<code>具名模块（Named Module）</code>只能访问到它<u>依赖定义中列明依赖的模块和包</u>，匿名模块里所有的内容对具名模块来说都是不可见的，即<strong><u>具名模块看不见传统JAR包的内容</u></strong>。</li><li><strong>JAR文件在模块路径的访问规则</strong>：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个<code>自动模块（Automatic Module）</code>。尽管不包含<code>module-info.class</code>，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到<u>所有模块导出的</u>包，自动模块也<strong>默认导出自己所有的包</strong>。</li></ul><h4 id="4-2-模块化下的类加载器"><a href="#4-2-模块化下的类加载器" class="headerlink" title="4.2 模块化下的类加载器"></a>4.2 模块化下的类加载器</h4><p><code>JDK 9</code>为了模块化系统的顺利施行，模块化下的类加载器发生了一些变动，主要包括以下几个方面：</p><ul><li><code>扩展类加载器（Extension Class Loader）</code>被<code>平台类加载器（Platform Class Loader）</code>取代。</li><li><code>平台类加载器</code>和<code>应用程序类加载器</code>都不再派生自<code>java.net.URLClassLoader</code>，现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 <code>jdk.internal.loader.BuiltinClassLoader</code>。<code>BuiltinClassLoader</code>中实现了新的模块化架构下<u>类如何从模块中加载的逻辑</u>，以及<u>模块中资源可访问性的处理</u>。</li><li><code>JDK 9</code>中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。<ul><li>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类<u>是否能够归属到某一个系统模块中</u>，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JDK9ClassLoaderDelegation.PNG" alt="JDK 9后的类加载器委派关系"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--6 类文件结构</title>
    <link href="https://wuyunjie.top/2021/05/26/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_6_Class_file_structure.html"/>
    <id>https://wuyunjie.top/2021/05/26/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_6_Class_file_structure.html</id>
    <published>2021-05-26T13:23:04.000Z</published>
    <updated>2021-05-26T13:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</code><br><a id="more"></a></p></blockquote><h3 id="1-无关性的基石"><a href="#1-无关性的基石" class="headerlink" title="1. 无关性的基石"></a>1. 无关性的基石</h3><p>各种不同平台的Java虚拟机，以及所有平台都统一支持的<u>程序存储格式</u>——<code>字节码（Byte Code）</code>是构成平台无关性的基石。Java虚拟机<strong>不与包括Java语言在内的任何程序语言绑定，它只与<code>“Class文件”</code>这种特定的二进制文件格式所关联</strong>，<code>Class文件</code>中包含了<code>Java虚拟机指令集</code>、<code>符号表</code>以及<code>若干其他辅助信息</code>。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JVMLanguageIndependence.PNG" alt="Java虚拟机的语言无关性"></p><p>Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，这决定了<u>字节码指令所能提供的语言描述能力比Java语言本身更加强大</u>。</p><h3 id="2-Class类文件的结构"><a href="#2-Class类文件的结构" class="headerlink" title="2. Class类文件的结构"></a>2. Class类文件的结构</h3><p><code>Class文件</code>是一组以<code>8</code>个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，<strong>中间没有添加任何分隔符</strong>，这使得<u>整个Class文件中存储的内容几乎全部是程序运行的必要数据</u>，没有空隙存在。遇到需要占用8个字节以上空间的数据项时，则会<strong><code>按照高位在前的方式分割</code></strong>成若干个8个字节进行存储。</p><blockquote><p>任何一个Class文件都对应着唯一的一个类或接口的定义信息。反过来说，<strong>类或接口并不一定都得定义在文件里</strong>（譬如类或接口也可以动态生成，直接送入类加载器中）。</p></blockquote><p>Class文件格式采用一种类似于C语言结构体的<code>伪结构</code>来存储数据，这种伪结构中只有两种数据类型：<code>“无符号数”</code>和<code>“表”</code>。</p><ul><li><code>无符号数</code>属于<u><strong>基本的数据类型</strong></u>，以<code>u1</code>、<code>u2</code>、<code>u4</code>、<code>u8</code>来分别代表1个字节、2个字节、4个字节和8个 字节的无符号数，可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li><code>表</code>是<u><strong>由多个无符号数或者其他表作为数据项构成的复合数据类型</strong></u>，所有表的命名都习惯性地以<code>“_info”</code>结尾。表用于描述有层次关系的复合结构的数据，<strong><code>整个Class文件本质上也可以视作是一张表</code></strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ClassFileStructure.PNG" alt="Class文件格式"></p><h4 id="2-1-魔数与Class文件的版本"><a href="#2-1-魔数与Class文件的版本" class="headerlink" title="2.1 魔数与Class文件的版本"></a>2.1 魔数与Class文件的版本</h4><p>每个Class文件的头4个字节被称为<code>魔数（Magic Number）</code>，它的<strong>唯一作用</strong>是<u><strong>确定这个文件是否为一个能被虚拟机接受的Class文件</strong></u>。</p><blockquote><p>Class文件的魔数取得很有“浪漫气息”，值为<code>0xCAFEBABE</code>(咖啡宝贝?)</p></blockquote><p>第5和第6个字节是<code>次版本号（Minor Version）</code>，第7和第8个字节是<code>主版本号（Major Version）</code>。</p><blockquote><p>Java的版本号是从45开始的。在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p></blockquote><h4 id="2-2-常量池"><a href="#2-2-常量池" class="headerlink" title="2.2 常量池"></a>2.2 常量池</h4><p>常量池可以比喻为<code>Class</code>文件里的资源仓库，通常也是占用<code>Class</code>文件空间最大的数据项目之一，它还是在Class文件中第一个出现的<code>表类型数据项目</code>。</p><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项<code>u2</code>类型的数据，代表<code>常量池容量计数值（constant_pool_count）</code>。</p><blockquote><p>Class文件结构中只有常量池的容量计数是<strong>从1开始</strong>。将第0项常量空出来目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达<strong>“不引用任何一个常量池项目”</strong>的含义，可以把索引值设置为0来表示。</p></blockquote><p>常量池中主要存放两大类常量：<code>字面量（Literal）</code>和<code>符号引用（Symbolic References）</code>。</p><ul><li>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等；</li><li>符号引用则属于编译原理方面的概念，主要包括下面几类常量：<ul><li>被模块导出或者开放的包（Package）；</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul></li></ul><p>常量池中每一项常量都是一个表。这类表都有一个共同的特点，表结构起始的第一位是个<code>u1</code>类型的标志位（<code>tag</code>），代表着当前常量属于哪种常量类型。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ItemTypeOfConstantPool.PNG" alt="常量池的项目类型"></p><blockquote><p>可以使用用于分析Class文件字节码的工具：<code>javap</code>，输出的<code>TestClass.class</code>文件字节码内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose TestClass</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-3-访问标志"><a href="#2-3-访问标志" class="headerlink" title="2.3 访问标志"></a>2.3 访问标志</h4><p><code>访问标志（access_flags）</code>，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；等等。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/accessFlags.PNG" alt="访问标志"></p><p>举例：TestClass是一个普通Java类，它的<code>ACC_PUBLIC</code>、<code>ACC_SUPER</code>标志应当为真，其他为假，因此它的<code>access_flags</code>的值应为：<code>0x0001|0x0020=0x0021</code>。</p><h4 id="2-4-类索引、父类索引与接口索引集合"><a href="#2-4-类索引、父类索引与接口索引集合" class="headerlink" title="2.4 类索引、父类索引与接口索引集合"></a>2.4 类索引、父类索引与接口索引集合</h4><p><code>类索引（this_class）</code>和<code>父类索引（super_class）</code>都是一个<code>u2</code>类型的数据，而<code>接口索引集合（interfaces）</code>是一组<code>u2</code>类型的数据的集合，Class文件中由这三项数据来确定该<strong><u>类型的继承关系</u></strong>。</p><blockquote><ul><li>类索引用于确定这个类的全限定名</li><li>父类索引用于确定这个类的父类的全限定名。父类索引只有一个(不允许多重继承)</li><li>接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按<code>implements</code>关键字后的接口顺序从左到右排列在接口索引集合中。</li></ul></blockquote><p>类索引和父类索引用两个<code>u2</code>类型的索引值表示，它们各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过<code>CONSTANT_Class_info</code>类型的常量中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型的常量中的<code>全限定名字符串</code>。</p><p>对于接口索引集合，入口的第一项<code>u2</code>类型的数据为<code>接口计数器（interfaces_count）</code>，表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0。</p><h4 id="2-5-字段表集合"><a href="#2-5-字段表集合" class="headerlink" title="2.5 字段表集合"></a>2.5 字段表集合</h4><p><code>字段表（field_info）</code>用于描述接口或者类中声明的变量。<code>“字段”（Field）</code>包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/fieldInfo.PNG" alt="字段表结构"></p><p><code>name_index</code>和<code>descriptor_index</code>都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><ul><li><code>全限定名</code>和<code>简单名称</code>。比如<code>“org/fenixsoft/clazz/TestClass”</code>是类的<code>全限定名</code>；<code>简单名称</code>则就是指没有类型和参数修饰的方法或者字段名称，类中的<code>inc()</code>方法和<code>m</code>字段的简单名称分别就是“<code>inc</code>”和“<code>m</code>”。</li><li><code>描述符</code>的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。<ul><li>对于数组类型，每一维度将使用一个前置的<code>“[”</code>字符来描述。比如<code>“int[]”</code>将被记录成<code>“[I”</code>。</li><li>描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号<code>“()”</code>之内。<code>void inc()</code>的描述符为<code>“()V”</code>。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/descriptor.PNG" alt="描述符"></p><blockquote><p>字段表集合中不会列出从父类或者父接口中继承而来的字段</p></blockquote><h4 id="2-6-方法表集合"><a href="#2-6-方法表集合" class="headerlink" title="2.6 方法表集合"></a>2.6 方法表集合</h4><p>对方法的描述与对字段的描述采用了几乎完全一致的方式，依次包括<code>访问标志（access_flags）</code>、<code>名称索引（name_index）</code>、<code>描述符索引（descriptor_index）</code>、<code>属性表集合（attributes）</code>几项。</p><blockquote><p>父类方法在子类中没有被<code>重写（Override）</code>，方法表集合中就不会出现来自父类的方法信息。</p></blockquote><h4 id="2-7-属性表集合"><a href="#2-7-属性表集合" class="headerlink" title="2.7 属性表集合"></a>2.7 属性表集合</h4><p>Class文件、字段表、方法表都可以携带自己的<code>属性表集合（attribute_info）</code>。对于每一个属性，它的名称都要从常量池中引用一个<code>CONSTANT_Utf8_info</code>类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个<code>u4</code>的长度属性去说明属性值所占用的位数即可。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/attributeInfo.PNG" alt="属性表结构"></p><h5 id="2-7-1-Code属性"><a href="#2-7-1-Code属性" class="headerlink" title="2.7.1 Code属性"></a>2.7.1 Code属性</h5><p>Java程序方法体里面的代码经过<code>Javac</code>编译器处理之后，最终变为字节码指令存储在<code>Code属性</code>内。Code属性出现在方法表的属性集合之中。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/CodeAttributeInfo.PNG" alt="Code属性表的结构"></p><ul><li><code>attribute_name_index</code>是一项指向<code>CONSTANT_Utf8_info</code>型常量的索引，此常量值<strong>固定为<code>“Code”</code></strong>；</li><li><code>attribute_length</code>指示了属性值的长度；</li><li><code>max_stack</code>代表了<code>操作数栈（Operand Stack）</code>深度的最大值；</li><li><code>max_locals</code>代表了局部变量表所需的存储空间。<code>Javac</code>编译器会根据变量的作用域来分配变量槽给各个变量使用，根据<u><strong>同时生存的最大局部变量数量和类型</strong></u>计算出<code>max_locals</code>的大小。</li><li><code>code_length</code>和code用来存储Java源程序编译后生成的字节码指令。<code>code_length</code>代表字节码长度，虽然它是一个<code>u4</code>类型的长度值，理论上最大值可以达到<code>2的32次幂</code>。有可能<strong><u>因为方法生成字节码超长的原因而导致编译失败</u></strong>。</li><li>Code属性用于描述代码。<ul><li>Java语言里面的潜规则：在任何实例方法里面，都可以通过“<code>this”</code>关键字访问到此方法所属的对象。是通过在<code>Javac</code>编译器编译的时候把对<code>this</code>关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数。所以在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量。</li></ul></li><li>显式异常处理表对于Code属性来说并不是必须存在的。如果存在异常表，它包含<u>四个字段</u>，这些字段的含义为：如果当字节码从第<code>start_pc</code>行到第<code>end_pc</code>行之间（不含第<code>end_pc</code>行）出现了类型为<code>catch_type</code>或者其子类的异常（<code>catch_type</code>为指向一个<code>CONSTANT_Class_info</code>型常量的索引），则转到第<code>handler_pc</code>行继续处理。当 <code>catch_type</code>的值为0时，代表任意异常情况都需要转到<code>handler_pc</code>处进行处理。</li></ul><h5 id="2-7-2-Exceptions属性"><a href="#2-7-2-Exceptions属性" class="headerlink" title="2.7.2 Exceptions属性"></a>2.7.2 Exceptions属性</h5><p><code>Exceptions属性</code>是在方法表中与Code属性平级的一项属性，作用是列举出方法中可能抛出的<code>受查异常（Checked Excepitons）</code>。</p><h5 id="2-7-3-LineNumberTable属性"><a href="#2-7-3-LineNumberTable属性" class="headerlink" title="2.7.3 LineNumberTable属性"></a>2.7.3 LineNumberTable属性</h5><p><code>LineNumberTable</code>属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。</p><h5 id="2-7-4-LocalVariableTable及LocalVariableTypeTable属性"><a href="#2-7-4-LocalVariableTable及LocalVariableTypeTable属性" class="headerlink" title="2.7.4 LocalVariableTable及LocalVariableTypeTable属性"></a>2.7.4 LocalVariableTable及LocalVariableTypeTable属性</h5><ul><li><code>LocalVariableTable</code>属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。</li><li><code>LocalVariableTypeTable</code>把<code>LocalVariableTabl</code>字段描述符的<code>descriptor_index</code>替换成了字段的<code>特征签名（Signature）</code>。泛型引入之后，由于描述符中泛型的参数化类型<code>被擦除掉</code>，描述符就不能准确描述泛型类型了。因此出现了<code>LocalVariableTypeTable</code>属性，<strong><u>使用字段的特征签名来完成泛型的描述</u></strong>。</li></ul><h5 id="2-7-5-SourceFile及SourceDebugExtension属性"><a href="#2-7-5-SourceFile及SourceDebugExtension属性" class="headerlink" title="2.7.5 SourceFile及SourceDebugExtension属性"></a>2.7.5 SourceFile及SourceDebugExtension属性</h5><p><code>SourceFile</code>属性用于记录生成这个Class文件的源码文件名称。</p><p><code>SourceDebugExtension</code>属性用于存储额外的代码调试信息。</p><h5 id="2-7-6-ConstantValue属性"><a href="#2-7-6-ConstantValue属性" class="headerlink" title="2.7.6 ConstantValue属性"></a>2.7.6 ConstantValue属性</h5><p><code>ConstantValue</code>属性的作用是通知虚拟机自动为静态变量赋值。只有被<code>static</code>关键字修饰的变量（类变量）才可以使用这项属性。</p><h5 id="2-7-7-InnerClasses属性"><a href="#2-7-7-InnerClasses属性" class="headerlink" title="2.7.7 InnerClasses属性"></a>2.7.7 InnerClasses属性</h5><p><code>InnerClasses</code>属性用于记录内部类与宿主类之间的关联。</p><h5 id="2-7-8-Deprecated及Synthetic属性"><a href="#2-7-8-Deprecated及Synthetic属性" class="headerlink" title="2.7.8 Deprecated及Synthetic属性"></a>2.7.8 Deprecated及Synthetic属性</h5><ul><li><code>Deprecated</code>属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用<code>“@deprecated”</code>注解进行设置；</li><li><code>Synthetic</code>属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的。</li></ul><blockquote><p><code>Deprecated</code>和<code>Synthetic</code>两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</p></blockquote><h5 id="2-7-9-StackMapTable属性"><a href="#2-7-9-StackMapTable属性" class="headerlink" title="2.7.9 StackMapTable属性"></a>2.7.9 StackMapTable属性</h5><p><code>StackMapTable</code>属性会在虚拟机类加载的字节码验证阶段被<code>新类型检查验证器（Type Checker）</code>使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p><h5 id="5-7-10-Signature属性"><a href="#5-7-10-Signature属性" class="headerlink" title="5.7.10 Signature属性"></a>5.7.10 Signature属性</h5><p><code>Signature</code>属性记录泛型类型，是因为Java语言的泛型采用的是<code>擦除法</code>实现的伪泛型，字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。</p><blockquote><ul><li>使用擦除法的好处是实现简单（主要修改<code>Javac</code>编译器，虚拟机内部只做了很少的改动）、非常容易实现<code>Backport</code>，运行期也能够节省一些类型所占的内存空间。</li><li>坏处是运行期就无法像有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待</li></ul></blockquote><h5 id="2-7-11-BootstrapMethods属性"><a href="#2-7-11-BootstrapMethods属性" class="headerlink" title="2.7.11 BootstrapMethods属性"></a>2.7.11 BootstrapMethods属性</h5><p><code>BootstrapMethods</code>属性用于保存<code>invokedynamic</code>指令引用的引导方法限定符。</p><h5 id="2-7-12-MethodParameters属性"><a href="#2-7-12-MethodParameters属性" class="headerlink" title="2.7.12 MethodParameters属性"></a>2.7.12 MethodParameters属性</h5><p><code>MethodParameters</code>的作用是记录方法的各个形参名称和信息。</p><h5 id="2-7-13-模块化相关属性"><a href="#2-7-13-模块化相关属性" class="headerlink" title="2.7.13 模块化相关属性"></a>2.7.13 模块化相关属性</h5><p><code>模块描述文件（module-info.java）</code>最终是要编译成一个独立的Class文件来存储的，所以Class文件格式也扩展了<code>Module</code>、<code>ModulePackages</code>和<code>ModuleMainClass</code>三个属性用于支持Java模块化相关功能。</p><ul><li><code>Module</code>属性除了表示该模块的名称、版本、标志信息以外，还存储了这个模块requires、exports、opens、uses和provides定义的全部内容；</li><li><code>ModulePackages</code>用于描述该模块中所有的包</li><li><code>ModuleMainClass</code>用于确定该模块的<code>主类（Main Class）</code></li></ul><h5 id="2-7-14-运行时注解相关属性"><a href="#2-7-14-运行时注解相关属性" class="headerlink" title="2.7.14 运行时注解相关属性"></a>2.7.14 运行时注解相关属性</h5><p>为了存储源码中注解信息，Class文件同步增加了</p><ul><li><code>RuntimeVisibleAnnotations</code>；</li><li><code>RuntimeInvisibleAnnotations</code>；</li><li><code>RuntimeVisibleParameterAnnotations</code>；</li><li><code>RuntimeInvisibleParameterAnnotations</code></li></ul><p>后来又新增类型注解 （JSR 308）：</p><ul><li><code>RuntimeVisibleTypeAnnotations</code></li><li><code>RuntimeInvisibleTypeAnnotations</code></li></ul><p><code>RuntimeVisibleAnnotations</code>记录了类、字段或方法的声明上记录运行时可见注解，当我们使用<code>反射API</code>来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。</p><h3 id="3-字节码指令简介"><a href="#3-字节码指令简介" class="headerlink" title="3. 字节码指令简介"></a>3. 字节码指令简介</h3><p>Java虚拟机的指令由<u><strong>一个字节长度的</strong>、<strong>代表着某种特定操作含义</strong></u>的数字（称为<code>操作码，Opcode</code>）以及跟随其后的零至多个代表<strong>此操作所需的参数</strong>（称为<code>操作数，Operand</code>）构成。</p><p>如果不考虑异常处理的话，那Java虚拟机的解释器可以使用下面这段伪代码作为最基本的执行模型来理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    自动计算PC寄存器的值加<span class="number">1</span>;</span><br><span class="line">    根据PC寄存器指示的位置，从字节码流中取出操作码;</span><br><span class="line">    <span class="keyword">if</span> (字节码存在操作数) 从字节码流中取出操作数;</span><br><span class="line">    执行操作码所定义的操作;</span><br><span class="line">&#125; <span class="keyword">while</span> (字节码流长度 &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="3-1-字节码与数据类型"><a href="#3-1-字节码与数据类型" class="headerlink" title="3.1 字节码与数据类型"></a>3.1 字节码与数据类型</h4><p>Java虚拟机的指令集中，<strong>大多数指令都包含其操作所对应的数据类型信息</strong>。</p><blockquote><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：<code>i</code>代表对<code>int</code>类型的数据操作，<code>l</code>代表<code>long</code>，<code>s</code>代表<code>short</code>，<code>b</code>代表<code>byte</code>，<code>c</code>代表<code>char</code>，<code>f</code>代表<code>float</code>，<code>d</code>代表<code>double</code>，<code>a</code>代表<code>reference</code>。</p></blockquote><p>Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，即指令集将会被故意设计成非完全独立的。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</p><h4 id="3-2-加载和存储指令"><a href="#3-2-加载和存储指令" class="headerlink" title="3.2 加载和存储指令"></a>3.2 加载和存储指令</h4><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输：</p><ul><li>将一个局部变量加载到操作栈：<code>load</code>、<code>iload_&lt;n&gt;</code>、<code>lload</code>、<code>lload_&lt;n&gt;</code>、<code>fload</code>、<code>fload_&lt;n&gt;</code>、<code>dload</code>、<code>dload_&lt;n&gt;</code>、<code>aload</code>、<code>aload_&lt;n&gt;</code>；</li><li>将一个数值从操作数栈存储到局部变量表：<code>istore</code>、<code>istore_&lt;n&gt;</code>、<code>lstore</code>、<code>lstore_&lt;n&gt;</code>、<code>fstore</code>、<code>fstore_&lt;n&gt;</code>、<code>dstore</code>、<code>dstore_&lt;n&gt;</code>、<code>astore</code>、<code>astore_&lt;n&gt;</code>；</li><li>将一个常量加载到操作数栈：<code>bipush</code>、<code>sipush</code>、<code>ldc</code>、<code>ldc_w</code>、<code>ldc2_w</code>、<code>aconst_null</code>、<code>iconst_m1</code>、<code>iconst_&lt;i&gt;</code>、<code>lconst_&lt;l&gt;</code>、<code>fconst_&lt;f&gt;</code>、<code>dconst_&lt;d&gt;</code></li><li>扩充局部变量表的访问索引的指令：<code>wide</code></li></ul><p>是以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>）指令助记符实际上代表了一组指令，某个带有一个操作数的通用指令（例如<code>iload</code>）的特殊形式。省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中。</p><h4 id="3-3-运算指令"><a href="#3-3-运算指令" class="headerlink" title="3.3 运算指令"></a>3.3 运算指令</h4><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶：</p><ul><li>对整型数据进行运算的指令</li><li>对浮点型数据进行运算的指令</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ArithmeticInstructions.PNG" alt="算术指令"></p><h4 id="3-4-类型转换指令"><a href="#3-4-类型转换指令" class="headerlink" title="3.4 类型转换指令"></a>3.4 类型转换指令</h4><p>类型转换指令可以<strong><u>将两种不同的数值类型相互转换</u></strong>，这些转换操作一般用于：</p><ul><li>实现用户代码中的显式类型转换操作；</li><li>处理字节码指令集中数据类型相关指令无法与数据类型 一一对应的问题。</li></ul><p>Java虚拟机<strong><u>直接支持（即转换时无须显式的转换指令）</u></strong>以下数值类型的<code>宽化类型转换（Widening Numeric Conversion）</code>：</p><ul><li>int类型到long、float或者double类型</li><li>long类型到float、double类型</li><li>float类型到double类型</li></ul><p>处理<code>窄化类型转换（Narrowing Numeric Conversion）</code>时，就必须显式地使用转换指令来完成，这些转换指令包括<code>i2b</code>、<code>i2c</code>、<code>i2s</code>、<code>l2i</code>、<code>f2i</code>、<code>f2l</code>、<code>d2i</code>、<code>d2l</code>和<code>d2f</code>。</p><h4 id="3-5-对象创建与访问指令"><a href="#3-5-对象创建与访问指令" class="headerlink" title="3.5 对象创建与访问指令"></a>3.5 对象创建与访问指令</h4><p>对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ObjectInstructions.PNG" alt="对象创建与访问指令"></p><h4 id="3-6-操作数栈管理指令"><a href="#3-6-操作数栈管理指令" class="headerlink" title="3.6 操作数栈管理指令"></a>3.6 操作数栈管理指令</h4><p>Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p><ul><li>将操作数栈的栈顶一个或两个元素出栈：<code>pop</code>、<code>pop2</code></li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：<code>dup</code>、<code>dup2</code>、<code>dup_x1</code>、<code>dup2_x1</code>、<code>dup_x2</code>、<code>dup2_x2</code></li><li>将栈最顶端的两个数值互换：<code>swap</code></li></ul><h4 id="4-7-控制转移指令"><a href="#4-7-控制转移指令" class="headerlink" title="4.7 控制转移指令"></a>4.7 控制转移指令</h4><p>控制转移指令可以让Java虚拟机<strong><u>有条件</u></strong>或<strong><u>无条件</u></strong>地从指定位置指令（而不是控制转移指令）的下 一条指令继续执行程序。控制转移指令包括：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ControlTransferInstruction.PNG" alt="控制转移指令"></p><h4 id="4-8-方法调用和返回指令"><a href="#4-8-方法调用和返回指令" class="headerlink" title="4.8 方法调用和返回指令"></a>4.8 方法调用和返回指令</h4><p>方法调用（分派、执行过程）的指令：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/MethodCallAndReturnInstructions.PNG" alt="方法调用和返回指令"></p><h4 id="4-9-异常处理指令"><a href="#4-9-异常处理指令" class="headerlink" title="4.9 异常处理指令"></a>4.9 异常处理指令</h4><p>而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用<code>jsr</code>和 <code>ret</code>指令来实现，现在已经不用了），而是<strong><u>采用异常表来完成</u></strong>。</p><h4 id="4-10-同步指令"><a href="#4-10-同步指令" class="headerlink" title="4.10 同步指令"></a>4.10 同步指令</h4><p>支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用<code>管程</code>（<code>Monitor</code>，更常见的是直接将它称为<code>“锁”</code>）来实现的。</p><ul><li>方法级的同步是<strong>隐式的</strong>，<u>无须通过字节码指令来控制</u>，它实现在方法调用和返回操作之中。调用指令将会检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成时释放管程。</li><li>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持synchronized关键字的语义</li></ul><h3 id="5-公有设计，私有实现"><a href="#5-公有设计，私有实现" class="headerlink" title="5. 公有设计，私有实现"></a>5. 公有设计，私有实现</h3><p>任何一款Java虚拟机实现都必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。在此前提下，虚拟机实现者可以使用让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--5 调优案例分析与实战</title>
    <link href="https://wuyunjie.top/2021/05/26/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_5_Tuning_case_study_and_practice.html"/>
    <id>https://wuyunjie.top/2021/05/26/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_5_Tuning_case_study_and_practice.html</id>
    <published>2021-05-26T11:55:06.000Z</published>
    <updated>2021-05-26T11:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code><br><a id="more"></a></p></blockquote><h3 id="1-案例分析"><a href="#1-案例分析" class="headerlink" title="1. 案例分析"></a>1. 案例分析</h3><p>如何在不改变已有软硬件版本和规格的前提下，调整部署和配置策略去解决或者缓解问题。</p><h4 id="1-1-大内存硬件上的程序部署策略"><a href="#1-1-大内存硬件上的程序部署策略" class="headerlink" title="1.1 大内存硬件上的程序部署策略"></a>1.1 大内存硬件上的程序部署策略</h4><p>案例描述：</p><blockquote><p>升级网址服务器硬件后，<code>HotSpot</code>虚拟机是以服务端模式运行，默认使用的是吞吐量优先收集器，回收<code>12GB</code>的<code>Java</code>堆，一次<code>Full GC</code>的停顿时间就高达14秒。过大的堆内存进行回收时带来的长时间的停顿，将Java堆分配的内存重新缩小到<code>1.5GB</code>或者<code>2GB</code>，这样的确可以避免长时间停顿，但是在硬件上的投资就显得非常浪费。</p></blockquote><p>解决方式：</p><p>目前单体应用在较大内存的硬件上主要部署方式为：</p><blockquote><ol><li>通过一个<u>单独的Java虚拟机</u>实例来管理大量的Java堆内存。<ul><li>这种部署方式必须把应用的<code>Full GC</code>频率控制得足够低，至少要低到不会在用户使用过程中发生。这样可以通过在深夜执行<code>定时任务的方式触发Full GC</code>甚至是<code>自动重启应用服务器</code>来保持内存可用空间在一个稳定的水平。</li></ul></li><li>同时使用若干个Java虚拟机，建立<u>逻辑集群</u>来利用硬件资源。<ul><li>做法是在一台物理机器上启动多个应用服务器进程，为每个服务器进程分配不同端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。</li></ul></li></ol></blockquote><p>最后的部署方案是调整为建立<code>5</code>个<code>32</code>位<code>JDK</code>的逻辑集群，每个进程按<code>2GB</code>内存计算（其中堆固定为<code>1.5GB</code>），占用了 <code>10GB</code>内存。另外建立一个<code>Apache</code>服务作为前端均衡代理作为访问门户。</p><h4 id="1-2-集群间同步导致的内存溢出"><a href="#1-2-集群间同步导致的内存溢出" class="headerlink" title="1.2 集群间同步导致的内存溢出"></a>1.2 集群间同步导致的内存溢出</h4><p>案例描述：</p><blockquote><p>构成一个亲合式集群，使用<code>JBossCache</code>构建了一个全局缓存来解决数据库中<u>读写频繁、竞争激烈</u>对性能影响较大的问题，全局缓存启用后，服务正常使用了一段较长的时间，最近不定期出现多次的内存溢出问题。</p></blockquote><p>解决方式：</p><blockquote><ul><li><p><code>JBossCache</code>是基于自家的<code>JGroups</code>进行集群间的数据通信，<code>JGroups</code>使用协议栈的方式来实现收发数据包的各种所需特性自由组合，数据包接收和发送时要经过每层协议栈的<code>up()</code>和<code>down()</code>方法，其中的<code>NAKACK</code>栈用于<u>保障各个包的有效顺序以及重发</u>。</p></li><li><p>也有<code>MIS</code>系统实现方式上的缺陷。网络情况不能满足传输要求时，重发数据在内存中不断堆积，很快就产生了内存溢出。</p></li></ul></blockquote><h4 id="1-3-堆外内存导致的溢出错误"><a href="#1-3-堆外内存导致的溢出错误" class="headerlink" title="1.3 堆外内存导致的溢出错误"></a>1.3 堆外内存导致的溢出错误</h4><p>案例描述：</p><blockquote><p>基于<code>B/S</code>的电子考试系统服务端不定时抛出内存溢出异常。尝试过把堆内存调到最大，<code>32</code>位系统最多到 <code>1.6GB</code>基本无法再加大了，而且开大了基本没效果，抛出内存溢出异常好像还更加频繁。</p></blockquote><p>解决方式：</p><blockquote><p><code>Direct Memory</code>耗用的内存并不算入这<code>1.6GB</code>的堆之内，因此它最大也只能在剩余的<code>0.4GB</code>空间中再分出一部分而已。在此应用中导致溢出的关键是</p><ul><li><u>垃圾收集进行时，虚拟机虽然会对直接内存进行回收，但是直接内存只能等待老年代满后<code>Full GC</code>出现后，“顺便”帮它清理掉内存的废弃对象</u>。</li><li>否则需要等到抛出内存溢出异常时捕获到异常，再在Catch块里面通过<code>System.gc()</code>来触发垃圾收集。</li></ul></blockquote><p>下面这些区域还会占用较多的内存，内存总和受到操作系统进程最大内存的限制：</p><ul><li>直接内存：可通<code>过-XX：MaxDirectMemorySize</code>调整大小；</li><li>线程堆栈：可通过<code>-Xss</code>调整大小，内存不足时抛出<code>StackOverflowError</code>或者<code>OutOfMemoryError</code>；</li><li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，如果无法分配，可能会抛出<code>IOException：Too many open files</code>异常。</li><li>JNI代码：如果代码中使用了JNI调用本地库，占用的是Java虚拟机的本地方法栈和本地内存的。</li></ul><h4 id="1-4-外部命令导致系统缓慢"><a href="#1-4-外部命令导致系统缓慢" class="headerlink" title="1.4 外部命令导致系统缓慢"></a>1.4 外部命令导致系统缓慢</h4><p>案例描述：</p><blockquote><p>一个数字校园应用系统，发现请求响应时间比较慢，通过操作系统的<code>mpstat</code>工具发现处理器使用率很高，但是<u>系统中占用绝大多数处理器资源的程序并不是该应用本身</u>。通过<code>dtrace</code>脚本发现最消耗处理器资源的竟然是<code>“fork”</code>系统调用，<code>“fork”</code>系统调用是Linux用来产生新进程的，在Java虚拟机中，用户编写的Java代码通常最多只会创建新的线程，不应当有进程的产生。</p></blockquote><p>解决方式：</p><blockquote><p>每个用户请求的处理都需要执行一个外部<code>Shell</code>脚本来获得系统的一些信息。执行这个Shell脚本是通过Java的<code>Runtime.getRuntime().exec()</code>方法来调用的。即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也会非常可观。</p><p>去掉这个Shell脚本执行的语句，改为使用Java的<code>API</code>去获取这些信息后，系统很快恢复了正常。</p></blockquote><h4 id="1-5-服务器虚拟机进程崩溃"><a href="#1-5-服务器虚拟机进程崩溃" class="headerlink" title="1.5 服务器虚拟机进程崩溃"></a>1.5 服务器虚拟机进程崩溃</h4><p>案例描述：</p><blockquote><p>一个基于B/S的MIS系统，正常运行一段时间后，最近发现在运行期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下了一个<code>hs_err_pid###.log</code>文件后，虚拟机进程就消失了。</p></blockquote><p>解决方式：</p><blockquote><p>由于MIS系统的用户多，待办事项变化很快，为了不被<code>OA系统</code>速度拖累，使用了<strong>异步的方式</strong>调用 Web服务，但由于两边服务速度的完全不对等，时间越长就累积了越多Web服务没有调用完成，导致在等待的线程和Socket连接越来越多，最终超过虚拟机的承受能力后导致虚拟机进程崩溃。</p><p>修复<code>OA门户</code>无法使用的集成接口，并将异步调用改为<u>生产者/消费者模式</u>的消息队列实现后，系统恢复正常。</p></blockquote><h4 id="1-6-不恰当数据结构导致内存占用过大"><a href="#1-6-不恰当数据结构导致内存占用过大" class="headerlink" title="1.6 不恰当数据结构导致内存占用过大"></a>1.6 不恰当数据结构导致内存占用过大</h4><p>案例描述：</p><blockquote><p>一个后台<code>RPC</code>服务器，业务上需要每 10分钟加载一个约<code>80MB</code>的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个<code>HashMap&lt;Long，Long&gt;Entry</code>，在这段时间里面<code>Minor GC</code>就会造成超过<code>500毫秒</code>的停顿，对于这种长度的停顿时间就接受不了了。</p></blockquote><p>解决方式：</p><blockquote><ul><li>如果不修改程序，仅从GC调优的角度去解决这个问题，可以考虑直接将Survivor空间去掉，让新生代中存活的对象在第一次<code>Minor GC</code>后立即进入老年代，等到<code>Major GC</code>的时候再去清理它们。</li><li>这里产生问题的根本原因是用<code>HashMap&lt;Long, Long&gt;</code>结构来存储数据文件空间效率太低了，只有<code>Key</code>和<code>Value</code>所存放的两个长整型数据是有效数据，空间效率为有效数据除以全部内存空间，即16字节/88字节=18%。</li></ul></blockquote><h4 id="1-7-由Windows虚拟内存导致的长时间停顿"><a href="#1-7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="1.7 由Windows虚拟内存导致的长时间停顿"></a>1.7 由Windows虚拟内存导致的长时间停顿</h4><p>案例描述：</p><blockquote><p>一个带<code>心跳检测功能</code>的GUI桌面程序，每15秒会发送一次心跳检测信号，如果对方30秒以内都没有信号返回，那就认为和对方程序的连接已经断开。程序上线后发现心跳检测有误报的可能，原因是程序会偶尔出现间隔约一分钟的时间完全无日志输出，处于停顿状态。</p></blockquote><p>解决方式：</p><blockquote><ul><li>程序在最小化时它的工作内存被自动交换到磁盘的页面文件之中了，这样发生垃圾收集时就有可能因为恢复页面文件的操作导致不正常的垃圾收集停顿。在Java的GUI程序中要避免这种现象，可以加入参数“<code>-Dsun.awt.keepWorkingSetOnMinimize=true</code>”来解决。</li></ul></blockquote><h4 id="1-8-由安全点导致长时间停顿"><a href="#1-8-由安全点导致长时间停顿" class="headerlink" title="1.8 由安全点导致长时间停顿"></a>1.8 由安全点导致长时间停顿</h4><p>案例描述：</p><blockquote><p>一个比较大的承担公共计算任务的离线HBase集群，因为集群读写压力较大，而离线分析任务对延迟又不会特别敏感，所以将<code>-XX:MaxGCPauseMillis</code>参数设置到了<em>500毫秒</em>。不过运行一段时间后发现垃圾收集的停顿经常达到<em>3秒</em>以 上，而且实际垃圾收集器进行回收的动作就只占其中的几百毫秒。</p></blockquote><p>解决方式：</p><blockquote><ul><li>日志显示当前虚拟机的操作（VM Operation，VMOP）是等待所有用户线程进入到安全点，但是有两个线程特别慢，导致发生了很长时间的<code>自旋等待</code>。</li><li>使用int类型或范围更小 的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为<code>可数循环（Counted Loop）</code>，相对应地，使用long或者范围更大的数据类型作为索引值的循环就被称为<code>不可数循环（Uncounted Loop）</code>，将会被放置安全点。把循环索引的数据类型从int改为long即可。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-13-调整数组顺序使奇数位于偶数前面</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ13_the_odd_numbers_come_before_the_even_numbers.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ13_the_odd_numbers_come_before_the_even_numbers.html</id>
    <published>2021-05-26T05:51:46.000Z</published>
    <updated>2021-06-24T15:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一问题描述">一、问题描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 <a id="more"></a></p><p><strong>示例1</strong></p><blockquote><p>输入：[1,2,3,4] 返回值：[1,3,2,4]</p></blockquote><p><strong>示例2</strong></p><blockquote><p>输入：[2,4,6,5,7] 返回值：[5,7,2,4,6]</p></blockquote><h3 id="二解题思路">二、解题思路</h3><p>这个题还有一个简单版本，即只需要保证奇数在偶数之前，不需要保证相对位置不变，先考虑这种情况下的解法。主要有两种方法：<strong>首尾双指针</strong>和<strong>快慢双指针</strong>。都是利用<code>双指针</code>求解，只是方向不一样：</p><h4 id="首尾双指针">1. 首尾双指针</h4><p>定义头指针<code>low</code>，尾指针<code>high</code>。</p><ul><li><code>low</code>向右移动，直到指向的值为偶数，<code>high</code>一直往左移， 直到指向的值为奇数。交换 <code>nums[low]</code>和<code>nums[high]</code>。</li><li>重复上述操作，直到<code>low == high</code> .</li></ul><h4 id="快慢双指针">2. 快慢双指针</h4><p>思路与首尾双指针大致相同，只是此时两个指针向同一个方向移动。定义快慢双指针<code>fast</code>和<code>slow</code>，<code>fast</code>在前，<code>slow</code>在后。</p><ul><li><code>fast</code>向前搜索奇数位置，slow指向下一个奇数应当存放的位置。<code>fast</code>搜索到奇数时，将它和<code>nums[slow]</code>交换，此时<code>slow</code>向前移动一个位置。</li><li>重复上述操作，直到<code>fast</code>指向数组末尾。</li></ul><p>但是基于首位指针的方法会改变奇数和奇数，偶数和偶数之间的相对位置，所以并不适合于本题。主要有两种思路：</p><h4 id="基于插入排序的思想">3. 基于插入排序的思想</h4><p>第一种方法基于插入排序的思想，记录已经满足奇数在前面的位置（视为排序中的已经有序部分），然后向前搜索发现奇数进行插入。这种方法只需要少量的额外空间，但时间复杂度较高。</p><h4 id="开辟新空间存储排序数组">4. 开辟新空间存储排序数组</h4><p>另一种方法事声明一个与原数组相同大小的新数组，用来存储排序后的数组，同时保持相对位置。可以利用首尾双指针的思想，对数组进行一次遍历，头指针处理奇数，尾指针处理偶数。头指针将奇数按顺序放到新数组前，尾指针将偶数按顺序放到新数组后。</p><p>为了对空间进一步优化，可以使用一个队列，将偶数放入队列中，按顺序放在原数组中，最后将队列中数据放入剩余的原数组空间，这时只需要额外开辟偶数大小的空间用于存放数据。</p><h3 id="三代码实现">三、代码实现</h3><h4 id="首尾双指针-1">1. 首尾双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( low &lt; nums.length &amp;&amp; (nums[low] &amp; <span class="number">1</span>) == <span class="number">1</span>) low++;</span><br><span class="line">            <span class="keyword">while</span> ( high &gt;= <span class="number">0</span> &amp;&amp; (nums[high] &amp; <span class="number">1</span>) == <span class="number">0</span>) high--;</span><br><span class="line">            <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">                nums[low] ^= nums[high];</span><br><span class="line">                nums[high] ^= nums[low];</span><br><span class="line">                nums[low] ^= nums[high];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快慢双指针-1">2. 快慢双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (nums[fast] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[slow];</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                nums[fast] = temp;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于插入排序的思想-1">3. 基于插入排序的思想</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>( array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> array;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> oddIndex = <span class="number">0</span>;<span class="comment">//记录已经是奇数的位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (array[i] &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> k = i;</span><br><span class="line">                temp = array[k];</span><br><span class="line">                <span class="keyword">while</span>(k &gt; oddIndex)&#123;</span><br><span class="line">                    array[k] = array[k-<span class="number">1</span>];<span class="comment">//这区间整体向后移动一位</span></span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                array[k] = temp;</span><br><span class="line">                oddIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开辟原数组大小的额外空间">4.1 开辟原数组大小的额外空间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index_head = head;</span><br><span class="line">        <span class="keyword">int</span> index_tail = tail;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; array.length &amp;&amp; tail &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[head] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//奇数，放前面</span></span><br><span class="line">                nums[index_head] = array[head];</span><br><span class="line">                index_head++;</span><br><span class="line">            &#125;</span><br><span class="line">            head++;</span><br><span class="line">            <span class="keyword">if</span>(array[tail] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//从后到前，如果为偶数，则从后开始填</span></span><br><span class="line">                nums[index_tail] = array[tail];</span><br><span class="line">                index_tail--;</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开辟数组中偶数数量大小的额外空间">4.2 开辟数组中偶数数量大小的额外空间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index_head = head;</span><br><span class="line">        <span class="keyword">int</span> index_tail = tail;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; array.length &amp;&amp; tail &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[head] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//奇数，放前面</span></span><br><span class="line">                nums[index_head] = array[head];</span><br><span class="line">                index_head++;</span><br><span class="line">            &#125;</span><br><span class="line">            head++;</span><br><span class="line">            <span class="keyword">if</span>(array[tail] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//从后到前，如果为偶数，则从后开始填</span></span><br><span class="line">                nums[index_tail] = array[tail];</span><br><span class="line">                index_tail--;</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献">参考文献</h3><ol type="1"><li><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/solution/ti-jie-shou-wei-shuang-zhi-zhen-kuai-man-shuang-zh/" target="_blank" rel="noopener">【题解】：首尾双指针，快慢双指针</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一问题描述&quot;&gt;一、问题描述&lt;/h3&gt;
&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-12-数值的整数次方</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ12_Integer_power.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ12_Integer_power.html</id>
    <published>2021-05-26T05:21:51.000Z</published>
    <updated>2021-05-26T05:21:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>给定一个<code>double</code>类型的浮点数<code>base</code>和<code>int</code>类型的整数<code>exponent</code>。求<code>base</code>的<code>exponent</code>次方。</p><p>保证<code>base</code>和<code>exponent</code>不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面<code>0</code>的位数。<br><a id="more"></a></p><p><strong>示例1</strong></p><blockquote><p>输入：2.00000, 3<br>返回值：8.00000</p></blockquote><p><strong>示例2</strong></p><blockquote><p>输入：2.10000, 3<br>返回值：9.26100</p></blockquote><p><strong>示例3</strong></p><blockquote><p>输入：2.00000,-2<br>返回值：0.25000</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>根据题意，不需要考虑大数情况，并且<code>exponent</code>是整数，那么直接的方法就是先对<code>exponent</code>的正负判断：</p><ul><li>若为正整数，直接循环<code>exponent</code>次乘法求出结果</li><li>若为负整数，循环<code>-exponent</code>次乘法求出结果，然后对结果求倒数</li></ul><h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>假设我们求$x^{8}$，如果我们知道$x^{4}$，那么$x^{8} = (x^{4})^{2}$，$x^{n} = (x^{\frac{n}{2}})^{2}$。但是还有个小问题，如果n是偶数，那么上述没问题。如果$n$是奇数，$x^{n} = (x^{\frac{n}{2}})^{2}<em>x$，比如$x^{7} = (x^{3})^{2} </em> x$。</p><h4 id="非递归的快速幂"><a href="#非递归的快速幂" class="headerlink" title="非递归的快速幂"></a>非递归的快速幂</h4><p>假设求$x^{6}$,已知<code>6</code>可以表示成二进制<code>110</code><br>可以表示成$6 = 0<em>2^{0} + 1 </em> 2^{1} + 1 <em> 2^{2}$, 所以$x^{6}$可以表示成$x^{6} = x^ {0</em>2^{0} + 1<em>2^{1} + 1</em>2^{2}} = x^{0} <em> x^{1</em>2^{1}}<em>x^{1</em>2^{2}}$所以，对于二进制数，遇到位数是<code>1</code>的就乘到答案中。</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-直接法"><a href="#1-直接法" class="headerlink" title="1. 直接法"></a>1. 直接法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exponent; i++)</span><br><span class="line">                result *= base;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; -exponent; i++)</span><br><span class="line">                result *= base;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/result;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-快速幂-递归法"><a href="#2-快速幂-递归法" class="headerlink" title="2. 快速幂(递归法)"></a>2. 快速幂(递归法)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickPower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> res = quickPower(base, exponent/<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res * res * base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res * res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quickPower(base, exponent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-快速幂-非递归法"><a href="#3-快速幂-非递归法" class="headerlink" title="3. 快速幂(非递归法)"></a>3. 快速幂(非递归法)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> x = base;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (exponent != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res *= x; <span class="comment">// 二进制位数是1的，乘进答案。</span></span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            exponent &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;给定一个&lt;code&gt;double&lt;/code&gt;类型的浮点数&lt;code&gt;base&lt;/code&gt;和&lt;code&gt;int&lt;/code&gt;类型的整数&lt;code&gt;exponent&lt;/code&gt;。求&lt;code&gt;base&lt;/code&gt;的&lt;code&gt;exponent&lt;/code&gt;次方。&lt;/p&gt;
&lt;p&gt;保证&lt;code&gt;base&lt;/code&gt;和&lt;code&gt;exponent&lt;/code&gt;不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面&lt;code&gt;0&lt;/code&gt;的位数。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-11-二进制中1的个数</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ11_Number_of_1s_in_binary.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ11_Number_of_1s_in_binary.html</id>
    <published>2021-05-26T05:01:12.000Z</published>
    <updated>2021-05-26T05:01:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>输入一个整数，输出该数<code>32</code>位二进制表示中<code>1</code>的个数。其中负数用补码表示。<br><a id="more"></a></p><p><strong>示例1</strong></p><blockquote><p>输入：10<br>返回值：2</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><h4 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1. 位运算"></a>1. 位运算</h4><p>考查的应该就是位操作吧。实际上要统计<code>1</code>的个数很简单，只需要将整数逐位右移，统计最低位<code>1</code>的出现次数。判断最低为是否为<code>1</code>可以使用等式：<code>n &amp; 1</code>，结果为<code>1</code>即为<code>1</code>，否则为<code>0</code>。</p><p>这里有一个需要注意的点是，由于整数是补码表示，所以在右移的时候，若数字为负数会将高位自动补<code>1</code>。这里刚好之前学到<code>Java</code>里有一个无符号右移的运算符: <code>&gt;&gt;&gt;</code>，可以直接解决这个问题。</p><ul><li><a href="https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html">[Java学习|Head_First_Java]—十大遗珠之憾</a></li></ul><h4 id="2-技巧法"><a href="#2-技巧法" class="headerlink" title="2. 技巧法"></a>2. 技巧法</h4><p>考虑二进制数：<code>val :1101000</code>, <code>val-1: 1100111</code> 那么<code>val &amp; （val-1） : 1100000</code>。即：</p><blockquote><p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p></blockquote><p>把一个整数减去<code>1</code>，再和原整数做与运算，会把该整数最右边一个<code>1</code>变成<code>0</code>.那么一个整数的二进制有多少个<code>1</code>，就可以进行多少次这样的操作。</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-位运算-1"><a href="#1-位运算-1" class="headerlink" title="1. 位运算"></a>1. 位运算</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfOnes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            numOfOnes += (n &amp; <span class="number">1</span>);</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numOfOnes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-技巧法："><a href="#2-技巧法：" class="headerlink" title="2. 技巧法："></a>2. 技巧法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfOnes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            numOfOnes++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numOfOnes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;输入一个整数，输出该数&lt;code&gt;32&lt;/code&gt;位二进制表示中&lt;code&gt;1&lt;/code&gt;的个数。其中负数用补码表示。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-10-矩形覆盖</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ10_Rectangular_coverage.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ10_Rectangular_coverage.html</id>
    <published>2021-05-26T04:33:52.000Z</published>
    <updated>2021-05-26T04:33:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用<code>n</code>个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，从同一个方向看总共有多少种不同的方法？<br><a id="more"></a></p><p>比如<code>n=3</code>时，<code>2*3</code>的矩形块有<code>3</code>种不同的覆盖方法(从同一个方向看)：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ10/JZ10.png" alt="矩形覆盖"></p><p><strong>示例1</strong></p><blockquote><p>输入：0<br>返回值：0</p></blockquote><p><strong>示例2</strong></p><blockquote><p>输入：1<br>返回值：1</p></blockquote><p><strong>示例3</strong></p><blockquote><p>输入：4<br>返回值：5</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>实际上还是一个类似于斐波那契数列的问题(连续好几个题了)，初始化两个基本的组合，<code>1</code>个<code>2*1</code>的小矩形只有<code>1</code>种组合方式，<code>2</code>个这样的矩阵有两种组合方式，然后是这两个基本组合之上的不断叠加的组合方法。所以可以写为：</p><script type="math/tex; mode=display">F(1)=1\\F(2)=2\\F(n) = F(n-1) + F(n-2) (n \geq 3, n \in N^*)</script><p>剩下的就是利用之前的递归法，迭代法来实现该算法。</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1. 递归法"></a>1. 递归法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;=<span class="number">2</span>) <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rectCover(target-<span class="number">1</span>) + rectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-迭代法"><a href="#2-迭代法" class="headerlink" title="2. 迭代法"></a>2. 迭代法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;=<span class="number">2</span>) <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum = sum + one;</span><br><span class="line">            one = sum - one;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;我们可以用&lt;code&gt;2*1&lt;/code&gt;的小矩形横着或者竖着去覆盖更大的矩形。请问用&lt;code&gt;n&lt;/code&gt;个&lt;code&gt;2*1&lt;/code&gt;的小矩形无重叠地覆盖一个&lt;code&gt;2*n&lt;/code&gt;的大矩形，从同一个方向看总共有多少种不同的方法？&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-9-跳台阶扩展问题</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ9_Jumping_expanding.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ9_Jumping_expanding.html</id>
    <published>2021-05-26T02:32:29.000Z</published>
    <updated>2021-05-26T02:32:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><a id="more"></a></p><blockquote><p>输入：3<br>返回值：4</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><h4 id="1-迭代递归法"><a href="#1-迭代递归法" class="headerlink" title="1. 迭代递归法"></a>1. 迭代递归法</h4><p>还是可以转换为递归的形式，只是这里递归的计算需要改进为遍历所有小于等于n的台阶数：</p><script type="math/tex; mode=display">F(0)=1\\F(1)=1\\F(n) = F(n-1) + F(n-2) + \cdots + F(n-n) (n \geq 2, n \in N^*)</script><p>那么将最后的递归改进为一个循环，就可以继续利用递归算法来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">sum += jumpFloorII(target-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-等式推导"><a href="#2-等式推导" class="headerlink" title="2. 等式推导"></a>2. 等式推导</h4><p>可以将该等式化简成一个简单的形式：</p><script type="math/tex; mode=display">F(n) = F(n-1) + F(n-2) + \cdots + F(n-n) (n \geq 2, n \in N^*)</script><p>那么可以继续得到$F(n-1)$的计算等式：</p><script type="math/tex; mode=display">F(n-1) = F(n-2) + F(n-3) + \cdots + F(n-n) (n \geq 3, n \in N^*)</script><p>可以把上述两式合并得到：</p><script type="math/tex; mode=display">F(n) = F(n-1) \times 2</script><p>利用改等式，可以写出递归，迭代的算法。进一步优化可以将其简化为：</p><script type="math/tex; mode=display">F(n) = 2^{(n-1)}</script><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-递归方法"><a href="#1-递归方法" class="headerlink" title="1. 递归方法"></a>1. 递归方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum += jumpFloorII(target-i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-迭代方法"><a href="#2-迭代方法" class="headerlink" title="2. 迭代方法"></a>2. 迭代方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i ; j++)&#123;</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-等式推导-递归"><a href="#3-等式推导-递归" class="headerlink" title="3. 等式推导(递归)"></a>3. 等式推导(递归)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> jumpFloorII(target-<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-等式推导-迭代法"><a href="#4-等式推导-迭代法" class="headerlink" title="4. 等式推导(迭代法)"></a>4. 等式推导(迭代法)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-等式推导-最简化形式"><a href="#5-等式推导-最简化形式" class="headerlink" title="5. 等式推导(最简化形式)"></a>5. 等式推导(最简化形式)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-8-跳台阶</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ8_Step_up.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ8_Step_up.html</id>
    <published>2021-05-26T02:02:02.000Z</published>
    <updated>2021-05-26T02:02:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><a id="more"></a></p><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>转换一下思路，其实就是在一颗树上不断搜索，其实可以很容易转化位斐波那契数列的形式，依靠递归算法求解：</p><script type="math/tex; mode=display">F(1)=1\\F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)</script><p>那么进一步就可以利用斐波那契数列的优化方法，对该算法从时间复杂度和空间复杂度的角度，不断优化。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ8/JZ8.png" alt="递归树结构"></p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-递归方法"><a href="#1-递归方法" class="headerlink" title="1. 递归方法"></a>1. 递归方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> jumpFloor(target-<span class="number">1</span>) + jumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-迭代方法"><a href="#2-迭代方法" class="headerlink" title="2. 迭代方法"></a>2. 迭代方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum = sum + one;</span><br><span class="line">            one = sum - one;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-7-斐波那契数列</title>
    <link href="https://wuyunjie.top/2021/05/25/JZ7_Fibonacci_sequence.html"/>
    <id>https://wuyunjie.top/2021/05/25/JZ7_Fibonacci_sequence.html</id>
    <published>2021-05-25T09:28:54.000Z</published>
    <updated>2021-05-25T09:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。（<code>n≤39</code>）<br><a id="more"></a></p><p><strong>示例:</strong></p><blockquote><p>输入:  4<br>返回值: 3</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>斐波那契数列的标准公式为：</p><script type="math/tex; mode=display">F(1)=1\\F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)</script><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h4><p>可以发现很符合递归的定义，所以递归是一种直接的思路。但递归法的时间复杂度过高($O(2^n)$)。</p><h4 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h4><ul><li><p>另一种方法是直接利用循环，将$F(n), F(n-1), F(n-2)$保存在三个临时变量内，不断迭代计算出最终值。时间复杂度位($O(n)$)。</p></li><li><p>继续对空间进行优化，因为$F(n)$只在计算第$n$项的时候使用，所以可以只存储$F(n)$和$F(n-2)$，$F(n-1)$可以由$F(n)-F(n-2)$计算得到</p></li></ul><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1. 递归法"></a>1. 递归法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-迭代法"><a href="#2-迭代法" class="headerlink" title="2. 迭代法"></a>2. 迭代法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            FibArray_n = FibArray_n_1 + FibArray_n_2;</span><br><span class="line">            FibArray_n_2 = FibArray_n_1;</span><br><span class="line">            FibArray_n_1 = FibArray_n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FibArray_n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-优化的迭代法-只使用两个变量"><a href="#3-优化的迭代法-只使用两个变量" class="headerlink" title="3. 优化的迭代法(只使用两个变量)"></a>3. 优化的迭代法(只使用两个变量)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            FibArray_n = FibArray_n + FibArray_n_1;</span><br><span class="line">            FibArray_n_1 = FibArray_n - FibArray_n_1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FibArray_n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。（&lt;code&gt;n≤39&lt;/code&gt;）&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-6-旋转数组的最小数字</title>
    <link href="https://wuyunjie.top/2021/05/24/JZ6_rotate_the_smallest_number_of_the_array.html"/>
    <id>https://wuyunjie.top/2021/05/24/JZ6_rotate_the_smallest_number_of_the_array.html</id>
    <published>2021-05-24T12:25:51.000Z</published>
    <updated>2021-05-24T12:25:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br><strong>NOTE</strong>：给出的所有元素都大于0，若数组大小为0，请返回0。<br><a id="more"></a></p><p><strong>示例:</strong></p><blockquote><p>输入:   [3,4,5,1,2]<br>返回值: 1</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题应该是类似于查找的问题，其中数组为非递减序列是一个很关键的信息。</p><h4 id="1-暴力方法"><a href="#1-暴力方法" class="headerlink" title="1. 暴力方法"></a>1. 暴力方法</h4><p>对于查找类型的问题，都存在暴力方法，即将整个数组都遍历一遍，总会找到最小值。</p><h4 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h4><p>可以发现，选择数组中要找到的最小元素，即为分界线处的元素。即需要通过二分查找的方法，找到数组中的分界线。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ6/JZ61.png" alt="旋转数组"></p><p>在分界线左边的元素一定是要比分界线右边元素大的。所以可以基于二分查找方法，设定<code>low</code>和<code>high</code>的位置，然后判断<code>mid</code>位置是在数组的<code>左半部分</code>还是<code>右半部分</code>，逐渐缩小范围找到最小值。</p><ul><li>处于左半部分，<code>low</code>移到<code>mid</code>处</li><li>处于右半部分，<code>high</code>移到<code>mid</code>处</li><li>其他情况<code>low++</code></li></ul><p>但后来检测发现一个<code>bug</code>，遇到<code>[1, 0, 1, 1, 1]</code>这样的情况会出错：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ6/JZ62.png" alt="错过了最小值`0`"></p><p>为了解决该问题，只需要在提前检查数列，如果是非递减数列，返回最低位<code>low</code>的值。</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">1</span>) <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[low] &lt; array[high])</span><br><span class="line">                <span class="keyword">return</span> array[low];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((mid + <span class="number">1</span>) &lt; array.length &amp;&amp; array[mid] &gt; array[mid + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> array[mid + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>((mid - <span class="number">1</span>) &gt; -<span class="number">1</span> &amp;&amp; array[mid] &lt; array[mid - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> array[mid];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[low])</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; array[high])</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更简单的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rotateArray.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = rotateArray.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="comment">// 子数组是非递减的数组，10111</span></span><br><span class="line">        <span class="keyword">if</span> (rotateArray[low] &lt; rotateArray[high]) </span><br><span class="line">            <span class="keyword">return</span> rotateArray[low];</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[low])</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[high])</span><br><span class="line">            high = mid; <span class="comment">// 如果是mid-1，则可能会错过最小值，因为找的就是最小值</span></span><br><span class="line">        <span class="keyword">else</span> low++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rotateArray[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://blog.nowcoder.net/n/dcb0f2e6ffd44e1895b7a5297e362778" target="_blank" rel="noopener">【剑指offer T11】旋转数组的最小数字</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。&lt;br&gt;输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。&lt;br&gt;&lt;strong&gt;NOTE&lt;/strong&gt;：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-5-用两个栈实现队列</title>
    <link href="https://wuyunjie.top/2021/05/24/JZ5_implement_the_queue_with_two_stacks.html"/>
    <id>https://wuyunjie.top/2021/05/24/JZ5_implement_the_queue_with_two_stacks.html</id>
    <published>2021-05-24T11:43:12.000Z</published>
    <updated>2021-05-24T11:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><a id="more"></a></p><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>队列的特性是先进先出(<code>FIFO</code>)，栈的特点是先进后出(<code>FILO</code>)。很容易想到一个直观的方法：</p><ol><li>将队列数据先存入一个栈；</li><li>当需要<code>pop</code>出队列的元素时，将该栈元素逐个弹出存入另一个栈，然后弹出栈顶。</li></ol><p>但这样会有冗余操作，比如连续的<code>push</code>和连续的<code>pop</code>可以只在其中一个栈中操作，所以可以优化为：</p><ol><li>需要插入时，直接<code>push</code>到<code>stack1</code>；</li><li>需要弹出时，若<code>stack2</code>不为空，弹出<code>stack2</code>的栈顶元素；若<code>stack2</code>为空，将 <code>stack1</code> 中的全部数逐个出栈入栈 <code>stack2</code>，再弹出 <code>stack2</code> 栈顶元素</li></ol><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--4 虚拟机性能监控、故障处理工具</title>
    <link href="https://wuyunjie.top/2021/05/20/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_4_Performance_monitoring_fault_handling.html"/>
    <id>https://wuyunjie.top/2021/05/20/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_4_Performance_monitoring_fault_handling.html</id>
    <published>2021-05-20T14:41:12.000Z</published>
    <updated>2021-05-26T11:54:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code><br><a id="more"></a></p></blockquote><h3 id="1-基础故障处理工具"><a href="#1-基础故障处理工具" class="headerlink" title="1. 基础故障处理工具"></a>1. 基础故障处理工具</h3><p>除了编译和运行Java程序外，打包、部署、签名、调试、监控、运维等各种场景都可能会用到<code>JDK</code>的<code>bin</code>目录下的小工具。根据软件可用性和授权的不同，可以把它们划分成三类：</p><ul><li><strong>商业授权工具</strong>：主要是<code>JMC（Java Mission Control）</code>及它要使用到的<code>JFR（Java Flight Recorder）</code>；</li><li><strong>正式支持工具</strong>：这一类工具属于被长期支持的工具，不同平台、不同版本的<code>JDK</code>之间，这类工具可能会略有差异；</li><li><strong>实验性工具</strong>：这一类工具在它们的使用说明中被声明为“<code>没有技术支持，并且是实验性质的</code>”（<code>Unsupported and Experimental</code>）产品。</li></ul><h4 id="1-1-jps：虚拟机进程状况工具"><a href="#1-1-jps：虚拟机进程状况工具" class="headerlink" title="1.1 jps：虚拟机进程状况工具"></a>1.1 <code>jps</code>：虚拟机进程状况工具</h4><p><code>jps（JVM Process Status Tool）</code>功能和<code>UNIX</code>的<code>ps</code>命令类似：</p><blockquote><p>可以列出<code>正在运行</code>的虚拟机进程，并显示虚拟机<u><strong>执行主类（Main Class，main()函数所在的类）</strong></u>名称以及这些进程的<code>本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）</code>。</p></blockquote><p><code>jps</code>命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/jps.PNG" alt="jps参数"></p><h4 id="1-2-jstat：虚拟机统计信息监视工具"><a href="#1-2-jstat：虚拟机统计信息监视工具" class="headerlink" title="1.2 jstat：虚拟机统计信息监视工具"></a>1.2 <code>jstat</code>：虚拟机统计信息监视工具</h4><p><code>jstat（JVM Statistics Monitoring Tool）</code>是用于监视虚拟机各种运行状态信息的命令行工具。</p><blockquote><p>可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据</p></blockquote><h4 id="1-3-jinfo：Java配置信息工具"><a href="#1-3-jinfo：Java配置信息工具" class="headerlink" title="1.3 jinfo：Java配置信息工具"></a>1.3 <code>jinfo</code>：Java配置信息工具</h4><p><code>jinfo（Configuration Info for Java）</code>的作用是实时查看和调整虚拟机各项参数。</p><blockquote><p>使用<code>jps</code>命令的<code>-v</code>参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用<code>jinfo</code>的<code>-flag</code>选项进行查询了</p></blockquote><h4 id="1-4-jmap：Java内存映像工具"><a href="#1-4-jmap：Java内存映像工具" class="headerlink" title="1.4 jmap：Java内存映像工具"></a>1.4 <code>jmap</code>：Java内存映像工具</h4><p><code>jmap（Memory Map for Java）</code>命令用于生成<strong>堆转储快照</strong>（一般称为<code>heapdump</code>或<code>dump</code>文件）。</p><blockquote><p>还可以查询<u><code>finalize</code>执行队列</u>、<u>Java堆</u>和<u>方法区的详细信息</u>，如空间使用率、当前用的是哪种收集器等。</p></blockquote><h4 id="1-5-jhat：虚拟机堆转储快照分析工具"><a href="#1-5-jhat：虚拟机堆转储快照分析工具" class="headerlink" title="1.5 jhat：虚拟机堆转储快照分析工具"></a>1.5 <code>jhat</code>：虚拟机堆转储快照分析工具</h4><p><code>jhat（JVM Heap Analysis Tool）</code>命令与<code>jmap</code>搭配使用，来分析<code>jmap</code>生成的堆转储快照。</p><h4 id="1-6-jstack：Java堆栈跟踪工具"><a href="#1-6-jstack：Java堆栈跟踪工具" class="headerlink" title="1.6 jstack：Java堆栈跟踪工具"></a>1.6 <code>jstack</code>：Java堆栈跟踪工具</h4><p><code>jstack（Stack Trace for Java）</code>命令用于生成虚拟机当前时刻的线程快照（一般称为<code>threaddump</code>或者<code>javacore</code>文件）。</p><blockquote><p>线程快照就是当前虚拟机内每一条线程正在执行的<strong>方法堆栈</strong>的集合，生成线程快照的目的通常是<u>定位线程出现长时间停顿的原因</u>，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。</p></blockquote><h4 id="1-7-基础工具总结"><a href="#1-7-基础工具总结" class="headerlink" title="1.7 基础工具总结"></a>1.7 基础工具总结</h4><ul><li><strong>基础工具</strong>：用于支持基本的程序创建和运行</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/basicJavaTools.PNG" alt="基础工具"></p><ul><li><strong>安全</strong>：用于程序签名、设置安全测试等</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/securityJavaTools.PNG" alt="安全工具"></p><p>还有许多工具，就不一一列举了，需要的时候在查找学习就行。</p><h3 id="2-可视化故障处理工具"><a href="#2-可视化故障处理工具" class="headerlink" title="2. 可视化故障处理工具"></a>2. 可视化故障处理工具</h3><p>这类工具主要包括<code>JConsole</code>、 <code>JHSDB</code>、<code>VisualVM</code>和<code>JMC</code>四个。</p><h4 id="2-1-JHSDB：基于服务性代理的调试工具"><a href="#2-1-JHSDB：基于服务性代理的调试工具" class="headerlink" title="2.1  JHSDB：基于服务性代理的调试工具"></a>2.1  <code>JHSDB</code>：基于服务性代理的调试工具</h4><p><code>JHSDB</code>是一款基于<code>服务性代理（Serviceability Agent，SA）</code>实现的进程外调试工具。服务性代理是<code>HotSpot</code>虚拟机中一组用于映射<code>Java</code>虚拟机运行信息的、主要基于<code>Java</code>语言（含少量<code>JNI</code>代码）实现的<code>API</code>集合。</p><p>通过服务性代理的<code>API</code>，可以在一个独立的Java虚拟机的进程里分析其他<code>HotSpot</code>虚拟机的内部数据，或者从<code>HotSpot</code>虚拟机进程内存中<code>dump</code>出来的转储快照里还原出它的运行状态细节。</p><h4 id="2-2-JConsole：Java监视与管理控制台"><a href="#2-2-JConsole：Java监视与管理控制台" class="headerlink" title="2.2 JConsole：Java监视与管理控制台"></a>2.2 <code>JConsole</code>：Java监视与管理控制台</h4><p><code>JConsole（Java Monitoring and Management Console）</code>是一款基于<code>JMX（Java Manage-ment Extensions）</code>的可视化监视、管理工具。它的主要功能是通过<code>JMX</code>的<code>MBean（Managed Bean）</code>对系统进行信息收集和参数动态调整。</p><h4 id="2-3-VisualVM：多合-故障处理工具"><a href="#2-3-VisualVM：多合-故障处理工具" class="headerlink" title="2.3 VisualVM：多合-故障处理工具"></a>2.3 <code>VisualVM</code>：多合-故障处理工具</h4><p><code>VisualVM（All-in-One Java Troubleshooting Tool）</code>是功能最强大的运行监视和故障处理程序之一，除了常规的运行监视、故障处理外，还将提供其他方面的能力，譬如<code>性能分析（Profiling）</code>。</p><p><code>VisualVM</code>还有一个很大的<strong>优点</strong>：<u><strong>不需要被监视的程序基于特殊<code>Agent</code>去运行</strong></u>，因此它的通用性很强，对应用程序实际性能的影响也较小，使得它可以直接应用在生产环境中。</p><h4 id="2-4-Java-Mission-Control：可持续在线的监控工具"><a href="#2-4-Java-Mission-Control：可持续在线的监控工具" class="headerlink" title="2.4 Java Mission Control：可持续在线的监控工具"></a>2.4 <code>Java Mission Control</code>：可持续在线的监控工具</h4><p><code>JMC</code>最初是<code>BEA</code>公司的产品，选择了由<code>IBM</code>捐赠的<code>Eclipse RCP</code>作为基础框架，更常见的是作为Eclipse的插件来使用。</p><p><code>JMC</code>与虚拟机之间同样采取<code>JMX</code>协议进行通信，<code>JMC</code>一方面作为<code>JMX</code>控制台，显示来自虚拟机<code>MBean</code>提供的数据；另一方面作为<code>JFR</code>的分析工具，展示来自<code>JFR</code>的数据。</p><h3 id="3-HotSpot虚拟机插件及工具"><a href="#3-HotSpot虚拟机插件及工具" class="headerlink" title="3. HotSpot虚拟机插件及工具"></a>3. <code>HotSpot</code>虚拟机插件及工具</h3><p><code>HotSpot</code>的插件及工具存放在HotSpot源码<code>hotspot/src/share/tools</code>目录下，包括：</p><ul><li><code>Ideal Graph Visualizer</code>：用于可视化展示<code>C2</code>即时编译器是如何将字节码转化为理想图，然后转化为机器码的。</li><li><code>Client Compiler Visualizer</code>：用于查看<code>C1</code>即时编译器生成高级中间表示（<code>HIR</code>），转换成低级中间表示（<code>LIR</code>）和做物理寄存器分配的过程。</li><li><code>MakeDeps</code>：帮助处理<code>HotSpot</code>的编译依赖的工具。</li><li><code>Project Creator</code>：帮忙生成<code>Visual Studio</code>的<code>.project</code>文件的工具。</li><li><code>LogCompilation</code>：将<code>-XX：+LogCompilation</code>输出的日志整理成更容易阅读的格式的工具。</li><li><code>HSDIS</code>：即时编译器的反汇编插件。</li></ul><p><strong><code>HSDIS</code>：<code>JIT</code>生成代码反汇编</strong></p><p><code>HSDIS</code>是一个被官方推荐的<code>HotSpot</code>虚拟机即时编译代码的反汇编插件。<code>HSDIS</code>插件的作用是让<code>HotSpot</code>的<code>-XX：+PrintAssembly</code>指令调用它来把即时编译器动态生成的本地代码还原为<u>汇编代码</u>输出，同时还会自动产生大量非常有价值的注释，这样我们就可以通过输出的汇编代码来从最本质的角度分析问题。</p><p><code>JITWatch</code>是<code>HSDIS</code>经常搭配使用的可视化的编译日志分析工具，在<code>JITWatch</code>中加载日志后，就可以看到执行期间使用过的各种对象类型和对应调用过的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--十大遗珠之憾</title>
    <link href="https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html"/>
    <id>https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html</id>
    <published>2021-05-20T05:13:54.000Z</published>
    <updated>2021-05-20T05:13:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>什么！有完没完啊？这本书到底还要看多久？<br><a id="more"></a></p></blockquote><h3 id="1-枚举-又称为枚举类型或Enum"><a href="#1-枚举-又称为枚举类型或Enum" class="headerlink" title="1. 枚举(又称为枚举类型或Enum)"></a>1. 枚举(又称为枚举类型或<code>Enum</code>)</h3><p>枚举类型定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Members &#123; JERRY, BOBBY, PHIL &#125;;</span><br><span class="line"><span class="keyword">public</span> Members selectedBandMember;</span><br><span class="line"></span><br><span class="line"><span class="comment">// later in the code</span></span><br><span class="line"><span class="keyword">if</span> (selectedBandMember == Members.JERRY) &#123;</span><br><span class="line"><span class="comment">// do JERRY related stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在<code>enum</code>中加入构造函数、方法、变量和特定常量的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HfjEnum</span> </span>&#123;</span><br><span class="line"><span class="keyword">enum</span> Names &#123;</span><br><span class="line">        <span class="comment">// 传给下方定义构造函数的参数</span></span><br><span class="line">JERRY(“lead guitar”) &#123; <span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “plaintively”; &#125;&#125;,</span><br><span class="line">BOBBY(“rhythm guitar”) &#123; <span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “hoarsely”; &#125;&#125;,</span><br><span class="line">PHIL(“bass”);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String instrument;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// enum的构造函数，会对每个被声明的enum值执行一次</span></span><br><span class="line">        Names(String instrument) &#123;</span><br><span class="line">            <span class="keyword">this</span>.instrument = instrument;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInstrument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.instrument;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> “occasionally”;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Names n : Names.values()) &#123;</span><br><span class="line">            System.out.print(n);</span><br><span class="line">            System.out.print(“, instrument: “+ n.getInstrument());</span><br><span class="line">            System.out.println(“, sings: “ + n.sings());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-多维数组"><a href="#2-多维数组" class="headerlink" title="2. 多维数组"></a>2. 多维数组</h3><p>Java中，二维数组实际上是一个<strong><code>数组的数组</code></strong>。</p><h3 id="3-String-and-StringBuffer-StringBuilder-Methods"><a href="#3-String-and-StringBuffer-StringBuilder-Methods" class="headerlink" title="3. String and StringBuffer/StringBuilder Methods"></a>3. <code>String</code> and <code>StringBuffer/StringBuilder</code> Methods</h3><p><code>Java 5.0</code>起，应该用<code>StringBuilder</code>取代<code>StringBuffer</code>。<code>StringBuffer/StringBuilder</code> 来操作字符串更有效率。</p><h3 id="4-存取权限和存取修饰符"><a href="#4-存取权限和存取修饰符" class="headerlink" title="4. 存取权限和存取修饰符"></a>4. 存取权限和存取修饰符</h3><p><code>Java</code>有4种存取权限等级与3种存取修饰符。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/AccessLevelsModifiers.PNG" alt="存取权限和存取修饰符"></p><h3 id="5-Anonymous和Static-Nested-Classes"><a href="#5-Anonymous和Static-Nested-Classes" class="headerlink" title="5. Anonymous和Static Nested Classes"></a>5. <code>Anonymous</code>和<code>Static Nested Classes</code></h3><p><code>静态嵌套类</code>可以不需要外部类的实例就调用，但还是被看作外部类的一个成员，能够存取任何外部类的静态成员(包括私有)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooOuter</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarInner</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“method of a <span class="keyword">static</span> inner <span class="class"><span class="keyword">class</span>”)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FooOuter.BarInner foo = <span class="keyword">new</span> FooOuter.BarInner();</span><br><span class="line">        foo.sayIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>匿名的内部类</code>，是在需要传入一个实例的地方创建一个类，并把整个类作为参数传进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnon</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line">JButton button = <span class="keyword">new</span> JButton(“click”);</span><br><span class="line">frame.getContentPane().add(button);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// button.addActionListener(quitListener);</span></span><br><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent ev)</span> </span>&#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-连接的调用"><a href="#6-连接的调用" class="headerlink" title="6. 连接的调用"></a>6. 连接的调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"spring"</span>);</span><br><span class="line">sb = sb.delete(<span class="number">3</span>,<span class="number">6</span>).insert(<span class="number">2</span>,<span class="string">"umme"</span>).deleteCharAt(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>第二行程序从左到右执行。如下调用方法可以调用方法又不需要维护一个引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo().go();</span><br></pre></td></tr></table></figure><h3 id="7-块区域"><a href="#7-块区域" class="headerlink" title="7. 块区域"></a>7. 块区域</h3><p>区段程序代码通常在方法中，以<code>{}</code>字符来区分。在某个块区域中声明的变量，一旦离开块区域，就超出范围，无法再被使用。</p><h3 id="8-断言"><a href="#8-断言" class="headerlink" title="8. 断言"></a>8. 断言</h3><p>断言的使用类似<code>println()</code>，执行时未特别设定，被加入到程序中的<code>assert</code>命令会被Java虚拟机忽略。只有打开断言，才会输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> (height &gt; <span class="number">0</span>); </span><br><span class="line"><span class="comment">// if true, program continues normally</span></span><br><span class="line"><span class="comment">// if false, throw an AssertionError</span></span><br></pre></td></tr></table></figure><p>也可以加入信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> (height &gt; <span class="number">0</span>) : <span class="string">"height = "</span> + height + <span class="string">" weight = "</span> + weight;</span><br></pre></td></tr></table></figure><h3 id="9-不变性"><a href="#9-不变性" class="headerlink" title="9. 不变性"></a>9. 不变性</h3><p><code>String</code>的不变性，主要为了安全性和节省空间。比如下面的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = “<span class="number">0</span>”;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">     s = s + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上创建了<code>10</code>个<code>String</code>对象(“0”, “01”, …, “0123456789”)。创建新<code>String</code>时，<code>JVM</code>会把它放在<code>&quot;String Pool&quot;</code>的特殊存储区域，如果已经出现同值的<code>String</code>，JVM不会重复建立<code>String</code>，会引用已经存在的内容。因为<code>String</code>是不变的，引用变量无法改变其他参数变量引用到的同一个<code>String</code>值。</p><p><code>包装类</code>也具有不变性。</p><h3 id="10-位操作"><a href="#10-位操作" class="headerlink" title="10. 位操作"></a>10. 位操作</h3><ul><li>按位非运算：<code>~</code></li><li>按位与运算：<code>&amp;</code></li><li>按位或运算：<code>|</code></li><li>按位异或运算：<code>^</code></li><li>右移运算：<code>&gt;&gt;</code></li><li>无符号右移：<code>&gt;&gt;&gt;</code>。第一位补<code>0</code>，正负号可能改变。</li><li>左移运算符：<code>&lt;&lt;</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;什么！有完没完啊？这本书到底还要看多久？&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
</feed>
