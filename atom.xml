<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuYJ&#39;s Blog</title>
  
  <subtitle>wuyunjie的小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuyunjie.top/"/>
  <updated>2021-05-31T13:23:21.000Z</updated>
  <id>https://wuyunjie.top/</id>
  
  <author>
    <name>wuyunjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--9 类加载及执行子系统的案例与实战</title>
    <link href="https://wuyunjie.top/2021/05/31/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_9_Case_and_practice_of_class_loading_and_execution_subsystem.html"/>
    <id>https://wuyunjie.top/2021/05/31/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_9_Case_and_practice_of_class_loading_and_execution_subsystem.html</id>
    <published>2021-05-31T13:23:21.000Z</published>
    <updated>2021-05-31T13:23:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变。<br><a id="more"></a></p></blockquote><p>能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能。</p><h3 id="1-案例分析"><a href="#1-案例分析" class="headerlink" title="1. 案例分析"></a>1. 案例分析</h3><h4 id="1-1-Tomcat：正统的类加载器架构"><a href="#1-1-Tomcat：正统的类加载器架构" class="headerlink" title="1.1 Tomcat：正统的类加载器架构"></a>1.1 <code>Tomcat</code>：正统的类加载器架构</h4><p>主流的<code>Java Web服务器</code>，如<code>Tomcat</code>、<code>Jetty</code>、<code>WebLogic</code>、<code>WebSphere</code>等，都实现了自己定义的类加载器，而且一般不止一个。一个功能健全的Web服务器，要解决如下的这些问题：</p><ul><li>部署在<u>同一个服务器</u>上的两个Web应用程序所使用的Java类库可以实现<strong><u>相互隔离</u></strong>。</li><li>部署在<u>同一个服务器</u>上的两个Web应用程序所使用的Java类库可以<u><strong>互相共享</strong></u>。</li><li>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响。</li><li>支持<code>JSP</code>应用的Web服务器，十有八九都需要支持<code>HotSwap</code>功能。<code>JSP</code>文件由于其<u>纯文本存储</u>的特性，被运行时修改的概率远大于第三方类库或程序自己的Class文件。而且<code>ASP</code>、<code>PHP</code>和<code>JSP</code>这些网页应用也把<u><strong>修改后无须重启</strong></u>作为一 个很大的“优势”来看待，因此“主流”的Web服务器都会支持<code>JSP</code>生成类的<strong><code>热替换</code></strong>。</li></ul><p>由于存在上述问题，在部署Web应用时，各种Web服务器都提供了好几个有着不同含义的<code>ClassPath</code>路径供用户存放<u>第三方类库</u>，这些路径一般会以<code>“lib”</code>或<code>“classes”</code>命名。通常每一个目录都会有一个相应的<strong><code>自定义类加载器</code></strong>去加载放置在里面的Java类库。</p><h4 id="1-2-OSGi：灵活的类加载器架构"><a href="#1-2-OSGi：灵活的类加载器架构" class="headerlink" title="1.2 OSGi：灵活的类加载器架构"></a>1.2 <code>OSGi</code>：灵活的类加载器架构</h4><p><code>OSGi （Open Service Gateway Initiative）</code>是<code>OSGi联盟（OSGi Alliance）</code>制订的一个基于Java语言的<code>动态模块化规范</code>。<code>OSGi</code>中的每个模块（称为<code>Bundle</code>）与普通的Java类库区别并不太大，两者一般都以<code>JAR</code>格式进行封装，并且内部存储的都是Java的<code>Package</code>和<code>Class</code>。</p><ul><li>但是一个<code>Bundle</code>可以声明它所依赖的<code>Package</code>（通过<code>Import-Package</code>描述），也可以声明它允许导出发布的<code>Package</code>（通过<code>Export-Package</code>描述）。</li><li>在<code>OSGi</code>里面，<code>Bundle</code>之间的依赖关系从传统的上层模块依赖底层模块转变为<strong>平级模块之间的依赖</strong>，而且类库的可见性能得到非常精确的控制，一个模块里只有被<code>Export</code>过的<code>Package</code>才可能被外界访问，其他的<code>Package</code>和<code>Class</code>将会被隐藏起来。</li></ul><p>但引入<code>OSGi</code>的主要理由是基于<code>OSGi</code>架构的程序很可能会实现模块级的<strong><u>热插拔功能</u></strong>，该特性要归功于它灵活的类加载器架构：</p><ul><li><code>OSGi</code>的<code>Bundle</code>类加载器之间只有规则，没有固定的委派关系。例如，某个<code>Bundle</code>声明了一个它依赖的<code>Package</code>，如果有其他<code>Bundle</code>声明了发布这个<code>Package</code>后，那么所有对这个<code>Package</code>的类加载动作都会委派给发布它的<code>Bundle</code>类加载器去完成。</li><li>不涉及某个具体的Package时，各个Bundle加载器都是平级的关系，只有具体使用到某个<code>Package</code>和<code>Class</code>的时候，才会根据<code>Package</code><strong>导入导出定义</strong>来构造<code>Bundle</code>间的委派和依赖。</li><li>一个<code>Bundle</code>类加载器为其他<code>Bundle</code>提供服务时，会根据<code>Export-Package</code>列表严格控制访问范围。</li></ul><p>假设存在<code>Bundle A</code>、<code>Bundle B</code>、<code>Bundle C</code>这<code>3</code>个模块，并且这<code>3</code>个<code>Bundle</code>定义的依赖关系如下：</p><ul><li><code>Bundle A</code>：声明发布了<code>package A</code>，依赖了<code>java.*</code>的包；</li><li><code>Bundle B</code>：声明依赖了<code>package A</code>和<code>package C</code>，同时也依赖了<code>java.*</code>的包；</li><li><code>Bundle C</code>：声明发布了<code>package C</code>，依赖了<code>package A</code>。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OSGiClassloaderArchitecture.PNG" alt="OSGi的类加载器架构"></p><p>在 <code>OSGi</code>里，类加载时可能进行的查找规则如下：</p><ul><li>以<code>java.*</code>开头的类，委派给父类加载器加载。</li><li>否则，委派列表名单内的类，委派给父类加载器加载。</li><li>否则，<code>Import</code>列表中的类，委派给<code>Export</code>这个类的<code>Bundle</code>的类加载器加载。</li><li>否则，查找当前<code>Bundle</code>的<code>Classpath</code>，使用自己的类加载器加载。</li><li>否则，查找是否在自己的<code>Fragment Bundle</code>中，如果是则委派给<code>Fragment Bundle</code>的类加载器加载。</li><li>否则，查找<code>Dynamic Import</code>列表的<code>Bundle</code>，委派给对应<code>Bundle</code>的类加载器加载。</li><li>否则，类查找失败。</li></ul><h4 id="1-3-字节码生成技术与动态代理的实现"><a href="#1-3-字节码生成技术与动态代理的实现" class="headerlink" title="1.3 字节码生成技术与动态代理的实现"></a>1.3 字节码生成技术与动态代理的实现</h4><h5 id="1-3-1-字节码生成技术"><a href="#1-3-1-字节码生成技术" class="headerlink" title="1.3.1 字节码生成技术"></a>1.3.1 字节码生成技术</h5><p>要深入从Java源码到字节码编译过程，阅读<code>Javac</code>的源码是个很好的途径。在Java世界里面除了<code>Javac</code>和字节码类库外，使用到字节码生成的例子比比皆是：</p><ul><li>Web服务器中的<code>JSP编译器</code>，编译时植入的<code>AOP框架</code>；</li><li>动态代理技术；</li><li>使用反射的时候虚拟机有可能会在运行时生成字节码来提高执行速度。</li></ul><h5 id="1-3-2-动态代理技术"><a href="#1-3-2-动态代理技术" class="headerlink" title="1.3.2 动态代理技术"></a>1.3.2 动态代理技术</h5><p>动态代理的优势在于，<u>实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        Object originalObj;</span><br><span class="line"></span><br><span class="line">        <span class="function">Object <span class="title">bind</span><span class="params">(Object originalObj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.originalObj = originalObj;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"welcome"</span>);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(originalObj, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IHello hello = (IHello) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> Hello());</span><br><span class="line">        hello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy::newProxyInstance()</code>方法返回一个实现了<code>IHello</code>的接口，并且代理了<code>new Hello()</code>实例行为的对象，程序进行过验证、优化、缓存、同步、生成字节码、显式类加载等操作，它最后调用<code>sun.misc.ProxyGenerator::generateProxyClass()</code>方法来完成<code>生成字节码</code>的动作，这个方法会在运行时产生一个描述代理类的字节码<strong>byte[]数组</strong>。</p><h4 id="1-4-Backport工具：Java的时光机器"><a href="#1-4-Backport工具：Java的时光机器" class="headerlink" title="1.4 Backport工具：Java的时光机器"></a>1.4 <code>Backport</code>工具：Java的时光机器</h4><p>“Java逆向移植”的工具（<code>Java Backporting Tools</code>）用于把<strong>高版本JDK</strong>中编写的代码放到低版本JDK环境中去部署使用。<code>Retrotranslator</code>和<code>Retrolambda</code>是这类工具中的杰出代表。</p><ul><li><code>Retrotranslator</code>的作用是将<code>JDK 5</code>编译出来的Class文件转变为可以在<code>JDK 1.4</code>或<code>1.3</code>上部署的版本，它能很好地支持<u>自动装箱</u>、<u>泛型</u>、<u>动态注解</u>、<u>枚举</u>、<u>变长参数</u>、<u>遍历循环</u>、<u>静态导入</u>这些语法特性， 甚至还可以支持<code>JDK 5</code>中新增的<u>集合改进</u>、<u>并发包</u>及<u>对泛型、注解等的反射操作</u>。</li><li><code>Retrolambda</code>将<code>JDK 8</code>的<code>Lambda</code>表达式和<code>try-resources</code>语法转变为可以在<code>JDK 5</code>、<code>JDK 6</code>、<code>JDK 7</code>中使用的形式，同时也对<code>接口默认方法</code>提供了<strong>有限度</strong>的支持。</li></ul><p>JDK的每次升级新增的功能大致可以分为以下五类：</p><ol><li>对Java类库API的代码增强。</li><li>在前端编译器层面做的改进。</li><li>需要在字节码中进行支持的改动。</li><li>需要在JDK整体结构层面进行支持的改进。</li><li>集中在虚拟机内部的改进。</li></ol><p>上述的5类新功能中，逆向移植工具能比较完美地模拟了前两类。</p><h3 id="2-实战：自己动手实现远程执行功能"><a href="#2-实战：自己动手实现远程执行功能" class="headerlink" title="2. 实战：自己动手实现远程执行功能"></a>2. 实战：自己动手实现远程执行功能</h3><p>做程序维护的时候会遇到只要在服务中执行一小段程序代码，就可以定位或排除问题，但就是偏偏找不到可以让服务器执行时代码的途径。通常解决这类问题有以下几种途径：</p><ol><li>可以使用<code>BTrace</code>这类<code>JVMTI</code>工具去动态修改程序中某一部分的运行代码，类似的<code>JVMTI</code>工具还有阿里巴巴的<code>Arthas</code>等。</li><li>使用<code>JDK 6</code>之后提供了<code>Compiler API</code>，可以动态地编译Java程序，这样虽然达不到动态语言的灵活度，但让服务器执行临时代码的需求是可以得到解决的。</li><li>写一个<code>JSP文件</code>上传到服务器，然后在浏览器中运行它，或者在服务端程序中加入一个<code>BeanShell Script</code>、<code>JavaScript</code>等的执行引擎去执行动态脚本。</li><li>在应用程序中内置动态执行的功能。</li></ol><h4 id="2-1-目标"><a href="#2-1-目标" class="headerlink" title="2.1 目标"></a>2.1 目标</h4><p>希望最终的产品：</p><ul><li>不依赖某个JDK版本才加入的特性（包括<code>JVMTI</code>），能在目前还被普遍使用的JDK中部署。</li><li>不改变原有服务端程序的部署，不依赖任何第三方类库。</li><li>不侵入原有程序，即无须改动原程序的任何代码。也不会对原有程序的运行带来任何影响。</li><li>考虑到<code>BeanShell Script</code>或<code>JavaScript</code>等脚本与Java对象交互起来不太方便，<code>“临时代码”</code>应该直接支持Java语言。</li><li><code>“临时代码”</code>应当具备足够的自由度，不需要依赖特定的类或实现特定的接口。</li><li><code>“临时代码”</code>的执行结果能返回到客户端，执行结果可以包括程序中输出的信息及抛出的异常等。</li></ul><h4 id="2-2-思路"><a href="#2-2-思路" class="headerlink" title="2.2 思路"></a>2.2 思路</h4><p>需要解决以下3个问题：</p><ol><li>如何编译提交到服务器的Java代码？<ul><li>在服务器上编译，在<code>JDK 6</code>以后可以使用<code>Compiler API</code>，在<code>JDK 6</code>以前可以使用<code>tools.jar</code>包中的 <code>com.sun.tools.Javac.Main</code>类来编译Java文件。这种思路的缺点是引入了额外的依赖，而且把程序绑死在<strong>特定</strong>的<code>JDK</code>上了。</li><li>在客户端编译好，把<strong><u>字节码</u></strong>传到服务端。</li></ul></li><li>如何执行编译之后的Java代码？<ul><li>让类加载器加载这个类生成一个Class对象，然后反射调用一下某个方法；</li></ul></li><li>如何收集Java代码的执行结果？<ul><li>把程序往<code>标准输出（System.out）</code>和<code>标准错误输出（System.err）</code>中打印的信息收集起来。但会对原有程序产生影响：<u>会把其他线程向标准输出中打印的信息也收集了</u>。</li><li>直接在执行的类中把对<code>System.out</code>的符号引用替换为我们准备的<code>PrintStream</code>的符号引用。</li></ul></li></ol><h4 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h4><p>实现过程中需要用到的4个支持类：</p><h5 id="2-3-1-HotSwapClassLoader"><a href="#2-3-1-HotSwapClassLoader" class="headerlink" title="2.3.1 HotSwapClassLoader"></a>2.3.1 <code>HotSwapClassLoader</code></h5><p><code>HotSwapClassLoader</code>类于实现<code>“同一个类的代码可以被多次加载”</code>这个需求。<code>HotSwapClassLoader</code>所做的事情仅仅是公开父类（即<code>java.lang.ClassLoader</code>）中的<code>protected</code>方法<code>defineClass()</code>，我们将会使用这个方法<u><strong>把提交执行的Java类的<code>byte[]</code>数组转变为Class对象</strong></u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了多次载入执行类而加入的加载器</span></span><br><span class="line"><span class="comment"> * 把defineClass方法开放出来，只有外部显式调用的时候才会使用到loadByte方法</span></span><br><span class="line"><span class="comment"> * 由虚拟机调用时，仍然按照原有的双亲委派规则使用loadClass方法进行类加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotSwapClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HotSwapClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HotSwapClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadByte</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, classByte, <span class="number">0</span>, classByte.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-2-ClassModifier"><a href="#2-3-2-ClassModifier" class="headerlink" title="2.3.2 ClassModifier"></a>2.3.2 <code>ClassModifier</code></h5><p><code>ClassModifier</code>类实现将<code>java.lang.System</code>替换为我们自己定义的<code>HackSystem</code>类的过程，它<strong><u>直接修改符合Class文件格式的byte[]数组中的<code>常量池</code>部分，将常量池中指定内容的<code>CONSTANT_Utf8_info</code>常量替换为新的字符串</u></strong>。</p><p>经过<code>ClassModifier</code>处理后的<code>byte[]数组</code>才会传给<code>HotSwapClassLoader.loadByte()</code>方法进行类加载，<code>byte[]数组</code>在这里替换符号引用之后，与客户端直接在Java代码中引用<code>HackSystem</code>类再编译生成的Class是完全一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 修改Class文件，暂时只提供修改常量池常量的功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassModifier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class文件中常量池的起始偏移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_POOL_COUNT_INDEX = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CONSTANT_Utf8_info常量的tag标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_Utf8_info = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量池中11种常量所占的长度，CONSTANT_Utf8_info型常量除外，因为它不是定长的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] CONSTANT_ITEM_LENGTH = &#123; -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] classByte;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassModifier</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classByte = classByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改常量池中CONSTANT_Utf8_info常量的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldStr 修改前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newStr 修改后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 修改结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] modifyUTF8Constant(String oldStr, String newStr) &#123;</span><br><span class="line">        <span class="keyword">int</span> cpc = getConstantPoolCount();</span><br><span class="line">        <span class="keyword">int</span> offset = CONSTANT_POOL_COUNT_INDEX + u2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cpc; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tag = ByteUtils.bytes2Int(classByte, offset, u1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tag == CONSTANT_Utf8_info) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = ByteUtils.bytes2Int(classByte, offset + u1, u2);</span><br><span class="line">                offset += (u1 + u2);</span><br><span class="line">                String str = ByteUtils.bytes2String(classByte, offset, len);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (str.equalsIgnoreCase(oldStr)) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] strBytes = ByteUtils.string2Bytes(newStr);</span><br><span class="line">                    <span class="keyword">byte</span>[] strLen = ByteUtils.int2Bytes(newStr.length(), u2);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset - u2, u2, strLen);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset, len, strBytes);</span><br><span class="line">                    <span class="keyword">return</span> classByte;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    offset += len;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                offset += CONSTANT_ITEM_LENGTH[tag];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classByte;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取常量池中常量的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 常量池数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getConstantPoolCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ByteUtils.bytes2Int(classByte, CONSTANT_POOL_COUNT_INDEX, u2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-3-ByteUtils"><a href="#2-3-3-ByteUtils" class="headerlink" title="2.3.3 ByteUtils"></a>2.3.3 <code>ByteUtils</code></h5><p><code>ClassModifier</code>中涉及对<code>byte[]数组</code>操作的部分， 主要是将<code>byte[]</code>与<code>int</code>和<code>String</code>互相转换，以及把对<code>byte[]数据</code>的替换操作封装在<code>ByteUtils</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** Bytes数组处理工具</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bytes2Int</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = start + len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = ((<span class="keyword">int</span>) b[i]) &amp; <span class="number">0xff</span>;</span><br><span class="line">            n &lt;&lt;= (--len) * <span class="number">8</span>;</span><br><span class="line">            sum = n + sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] int2Bytes(<span class="keyword">int</span> value, <span class="keyword">int</span> len) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            b[len - i - <span class="number">1</span>] = (<span class="keyword">byte</span>) ((value &gt;&gt; <span class="number">8</span> * i) &amp; <span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytes2String</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(b, start, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] string2Bytes(String str) &#123;</span><br><span class="line">        <span class="keyword">return</span> str.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] bytesReplace(<span class="keyword">byte</span>[] originalBytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, <span class="keyword">byte</span>[] replaceBytes) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] newBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[originalBytes.length + (replaceBytes.length - len)];</span><br><span class="line">        System.arraycopy(originalBytes, <span class="number">0</span>, newBytes, <span class="number">0</span>, offset);</span><br><span class="line">        System.arraycopy(replaceBytes, <span class="number">0</span>, newBytes, offset, replaceBytes.length);</span><br><span class="line">        System.arraycopy(originalBytes, offset + len, newBytes, offset + replaceBytes.length, originalBytes.length - offset - len);</span><br><span class="line">        <span class="keyword">return</span> newBytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-HackSystem"><a href="#2-3-4-HackSystem" class="headerlink" title="2.3.4 HackSystem"></a>2.3.4 <code>HackSystem</code></h5><p>用来代替<code>java.lang.System</code>的<code>HackSystem</code>，主要把<code>out</code>和<code>err</code>两个静态变量改成使用<code>ByteArrayOutputStream</code>作为打印目标的同一个<code>PrintStream</code>对象，以及增加了<u><strong>读取</strong></u>、<u><strong>清理</strong></u><code>ByteArrayOutputStream</code>中内容的<code>getBufferString()</code>和 <code>clearBuffer()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为Javaclass劫持java.lang.System提供支持</span></span><br><span class="line"><span class="comment"> * 除了out和err外，其余的都直接转发给System处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HackSystem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> InputStream in = System.in;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out = <span class="keyword">new</span> PrintStream(buffer);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream err = out;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getBufferString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buffer.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSecurityManager</span><span class="params">(<span class="keyword">final</span> SecurityManager s)</span> </span>&#123;</span><br><span class="line">        System.setSecurityManager(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecurityManager <span class="title">getSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.getSecurityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(src, srcPos, dest, destPos, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">identityHashCode</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.identityHashCode(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面所有的方法都与java.lang.System的名称一样</span></span><br><span class="line">    <span class="comment">// 实现都是字节转调System的对应方法</span></span><br><span class="line">    <span class="comment">// 因版面原因，省略了其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-5-JavaclassExecuter"><a href="#2-3-5-JavaclassExecuter" class="headerlink" title="2.3.5 JavaclassExecuter"></a>2.3.5 <code>JavaclassExecuter</code></h5><p><code>JavaclassExecuter</code>是提供给外部调用的入口，调用前面几个支持类组装逻辑，完成类加载工作。</p><ul><li>用输入的符合Class文件格式的<code>byte[]数组</code>替换掉<code>java.lang.System</code>的符号引用后，使用<code>HotSwapClassLoader</code>加载生成一个Class对象；</li><li>然后<code>反射</code>调用这个Class对象的<code>main()</code>方法，如果期间出现任何异常，将异常信息打印到<code>HackSystem.out</code>中，</li><li>最后把缓冲区中的信息作为方法的结果来返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Javaclass执行工具</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaclassExecuter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行外部传过来的代表一个Java类的Byte数组&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 将输入类的byte数组中代表java.lang.System的CONSTANT_Utf8_info常量修改为劫持后的HackSystem类</span></span><br><span class="line"><span class="comment">     * 执行方法为该类的static main(String[] args)方法，输出结果为该类向System.out/err输出的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classByte 代表一个Java类的Byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">execute</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        HackSystem.clearBuffer();</span><br><span class="line">        ClassModifier cm = <span class="keyword">new</span> ClassModifier(classByte);</span><br><span class="line">        <span class="keyword">byte</span>[] modiBytes = cm.modifyUTF8Constant(<span class="string">"java/lang/System"</span>, <span class="string">"org/fenixsoft/classloading/execute/HackSystem"</span>);</span><br><span class="line">        HotSwapClassLoader loader = <span class="keyword">new</span> HotSwapClassLoader();</span><br><span class="line">        Class clazz = loader.loadByte(modiBytes);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = clazz.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[]&#123;String[]<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            method.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> String[]&#123; <span class="keyword">null</span> &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace(HackSystem.out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HackSystem.getBufferString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-验证"><a href="#2-4-验证" class="headerlink" title="2.4 验证"></a>2.4 验证</h4><p>写一个Java类，只要向<code>System.out</code>输出信息即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test executor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立一个测试代码，就可以在输出这个类的运行结果(原文是通过<code>JSP</code>来实现的，这里没有搭建服务器，就用这个小例子试试，可能不是那么合适的代替)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecuter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/Users/yunjiewu/IdeaProjects/JavaLearning/out/production/JavaLearning/JVMLearning/JavaclassExecuter/TestClass.class"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line">            is.close();</span><br><span class="line">            System.out.println(JavaclassExecuter.execute(b));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--8 虚拟机字节码执行引擎</title>
    <link href="https://wuyunjie.top/2021/05/28/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_8_Virtual_machine_bytecode_execution_engine.html"/>
    <id>https://wuyunjie.top/2021/05/28/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_8_Virtual_machine_bytecode_execution_engine.html</id>
    <published>2021-05-28T01:51:15.000Z</published>
    <updated>2021-05-28T01:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>执行引擎是Java虚拟机核心的组成部分之一。<br><a id="more"></a></p></blockquote><p>在不同的虚拟机实现中，执行引擎在执行字节码的时候，通常会有<code>解释执行（通过解释器执行）</code>和<code>编译执行（通过即时编译器产生本地代码执行）</code>两种，也可能两者兼备。</p><p>但从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：</p><ul><li>输入的是字节码二进制流；</li><li>处理过程是字节码解析执行的等效过程；</li><li>输出的是执行结果，</li></ul><h3 id="1-运行时栈帧结构"><a href="#1-运行时栈帧结构" class="headerlink" title="1. 运行时栈帧结构"></a>1. 运行时栈帧结构</h3><p>Java虚拟机<strong><u>以方法作为最基本的执行单元</u></strong>，<code>“栈帧”（Stack Frame）</code>则是用于支持虚拟机进行<strong>方法调用</strong>和<strong>方法执行</strong>背后的数据结构，它也是虚拟机运行时数据区中的<code>虚拟机栈（Virtual Machine Stack）</code>的栈元素。</p><blockquote><p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。一个栈帧需要分配多少内存仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/StackFrame.PNG" alt="栈帧结构"></p><h4 id="1-1-局部变量表"><a href="#1-1-局部变量表" class="headerlink" title="1.1 局部变量表"></a>1.1 局部变量表</h4><p><code>局部变量表（Local Variables Table）</code>是一组变量值的存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>。</p><blockquote><p>局部变量表的容量以<code>变量槽（Variable Slot）</code>为最小单位，一个变量槽应占用的内存空间大小未明确定义，每个变量槽都应该能存放一个<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>reference</code>或<code>returnAddress</code>类型的数据。对于64位的数据类型，Java虚拟机会以<strong>高位对齐</strong>的方式为其分配两个连续的变量槽空间。</p></blockquote><p>Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是<u><strong>从0开始至局部变量表最大的变量槽数量</strong></u>。</p><blockquote><p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成<u><strong>参数值到参数变量列表的传递过程， 即实参到形参的传递</strong></u>。</p><ul><li>如果执行的是实例方法，局部变量表中<strong><u>第0位索引</u></strong>的变量槽默认是<strong><u>用于传递方法所属对象实例的引用</u></strong>，在方法中可以通过关键字<code>“this”</code>来访问到这个隐含的参数。</li><li>其余参数则按照参数表顺序排列，占用<strong><u>从1开始</u></strong>的局部变量槽；</li><li>参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</li></ul></blockquote><p>为了尽可能节省栈帧耗用的内存空间，局部变量表中的变量槽是可以重用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 局部变量表Slot复用对垃圾收集的影响</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>placeholder</code>能否被回收的根本原因就是：局部变量表中的变量槽是否还存有关于<code>placeholder</code>数组对象的引用。</p><ul><li>未加入<code>int a = 0;</code>语句时，虽然已经离开了<code>placeholder</code>的作用域，<code>placeholder</code>原本所占用的变量槽还没有被其他变量所复用，所以作为<code>GC Roots</code>一部分的局部变量表仍然保持着对它的关联。所以<code>placeholder</code>数组对象不会被回收。</li><li>手动将其设置占用了大量内存但实际上已经不会再使用的变量为<code>null</code>值(代替那句<code>int a = 0;</code>)，可以作为一种在极特殊情形下的<code>“奇技”</code>来使用。</li></ul><p>此外，局部变量不像类变量那样存在“准备阶段”，即不会被系统初始化为默认值。</p><h4 id="1-2-操作数栈"><a href="#1-2-操作数栈" class="headerlink" title="1.2 操作数栈"></a>1.2 操作数栈</h4><p><code>操作数栈（Operand Stack）</code>也常被称为操作栈，它是一个<code>后入先出（Last In First Out，LIFO）</code>栈。</p><blockquote><p><code>Javac编译器</code>的<strong>数据流分析工作</strong>保证了在方法执行的任何时候，操作数栈的深度都不会超过在<code>max_stacks</code>数据项中设定的最大值。</p></blockquote><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OperandStackShareData.PNG" alt="栈帧之间的数据共享"></p><p>概念上，两个不同栈帧作为不同方法的虚拟机栈的元素，是<strong><u>完全相互独立</u></strong>的。但在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现<u>一部分重叠</u>。让<strong>下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起</strong>，这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了。</p><h4 id="1-3-动态连接"><a href="#1-3-动态连接" class="headerlink" title="1.3 动态连接"></a>1.3 动态连接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的<code>动态连接（Dynamic Linking）</code>。</p><h4 id="1-4-方法返回地址"><a href="#1-4-方法返回地址" class="headerlink" title="1.4 方法返回地址"></a>1.4 方法返回地址</h4><p>当一个方法开始执行后，只有两种方式退出这个方法：</p><ol><li>第一种方式是<u><strong>执行引擎遇到任意一个方法返回的字节码指令</strong></u>，这时候可能会有返回值传递给上层的方法调用者，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为<code>“正常调用完成”（Normal Method Invocation Completion）</code>。</li><li>另外一种是在<u><strong>方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理</strong></u>。无论是Java虚拟机内部产生的异常，还是代码中使用<code>athrow</code>字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为<code>“异常调用完成（Abrupt Method Invocation Completion）”</code>。一个方法使用异常完成出口的方式退出，是<strong><u>不会给它的上层调用者提供任何返回值的</u></strong>。</li></ol><p>方法退出之后必须返回到最初方法被调用时的位置，退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p><ul><li>方法正常退出时，<u><strong>主调方法的PC计数器的值就可以作为返回地址</strong></u>，栈帧中很可能会保存这个计数器值；</li><li>方法异常退出时，<u><strong>返回地址要通过异常处理器表来确定</strong></u>，栈帧中就一般不会保存这部分信息。</li></ul><h4 id="1-5-附加信息"><a href="#1-5-附加信息" class="headerlink" title="1.5 附加信息"></a>1.5 附加信息</h4><p>比如与调试、性能收集相关的信息。一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为<code>栈帧信息</code>。</p><h3 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h3><p><strong>方法调用并<u>不等同于</u>方法中的代码被执行</strong>，方法调用阶段唯一的任务就是<strong>确定被调用方法的版本</strong>。</p><h4 id="2-1-解析"><a href="#2-1-解析" class="headerlink" title="2.1 解析"></a>2.1 解析</h4><p>所有方法调用的目标方法在Class文件里面都是一个<strong>常量池中的符号引用</strong>，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：</p><ul><li>方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为<code>解析（Resolution）</code>。</li></ul><blockquote><p>在Java语言中符合<code>“编译期可知，运行期不可变”</code>这个要求的方法，主要有静态方法、私有方法、实例构造器、父类方法，再加上被<code>final</code>修饰的方法（尽管它使用<code>invokevirtual</code>指令调用），这5种方法调用会在<strong>类加载</strong>的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为<code>“非虚方法”（Non-Virtual Method）</code>，其他方法就被称为<code>“虚方法”（Virtual Method）</code>。</p></blockquote><p>解析调用一定是个<code>静态的过程</code>，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用。</p><h4 id="2-2-分派"><a href="#2-2-分派" class="headerlink" title="2.2 分派"></a>2.2 分派</h4><p><code>分派 （Dispatch）</code>调用可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。</p><h5 id="2-2-1-静态分派"><a href="#2-2-1-静态分派" class="headerlink" title="2.2.1 静态分派"></a>2.2.1 静态分派</h5><p>通过如下代码来定义两个关键概念：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure><ul><li><code>静态类型（Static Type）</code>。“Human”称为变量的<code>“静态类型”（Static Type）</code>，或者叫<code>“外观类型”（Apparent Type）</code>，静态类型的变化仅仅<u>在使用时发生</u>，变量本身的静态类型不会被改变，并且最终的静态类型是<u><strong>在编译期可知的</strong></u>；</li><li><code>实际类型（Actual Type）</code>。“Man”则被称为变量的<code>“实际类型”（Actual Type）</code>或者叫<code>“运行时类型”（Runtime Type）</code>，实际类型变化的结果<u>在运行期才可确定</u>，编译器<strong><u>在编译程序的时候并不知道</u></strong>一个对象的实际类型是什么。</li></ul><p>比如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line">Human human = (<span class="keyword">new</span> Random()).nextBoolean() ? <span class="keyword">new</span> Man() : <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">sr.sayHello((Man) human)</span><br><span class="line">sr.sayHello((Woman) human)</span><br></pre></td></tr></table></figure><ul><li>对象<code>human</code>的实际类型是可变的，到底是Man还是Woman，必须等到程序运行到这行的时候才能确定。</li><li>human的静态类型是Human，也可以在使用时（如<code>sayHello()</code>方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的</li></ul><p>在如下的例子中，使用哪个重载版本的<code>sayHello()</code>方法，完全取决于传入参数的数量和数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,guy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,gentleman!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,lady!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机（或者准确地说是编译器）在重载时是<strong><u>通过参数的静态类型而不是实际类型作为判定依据的</u></strong>，所以在编译阶段，<code>Javac</code>编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了<code>sayHello(Human)</code>作为调用目标。</p><blockquote><p>所有依赖<code>静态类型</code>来决定方法执行版本的分派动作，都称为<code>静态分派</code>。</p></blockquote><p>静态分派的最典型应用表现就是<code>方法重载</code>。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。从下面的示例代码可以看出方法重载中，选择重载版本的匹配优先级：</p><ul><li><p>如果注释掉 <code>sayHello(char arg)</code>方法，会输出：<code>hello int</code>。这时发生了一次自动类型转换，<code>&#39;a&#39;</code>转换为<code>int</code>类型。</p></li><li><p>继续注释掉<code>sayHello(int arg)</code>方法，那输出会变为：<code>hello long</code>。这时发生了两次自动类型转换，<code>&#39;a&#39;</code>转型为整数<code>97</code>之后，进一步转型为长整数<code>97L</code>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello int"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello long"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Serializable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动转型可以依<code>据char&gt;int&gt;long&gt;float&gt;double</code>的顺序转型进行匹配。</li><li>自动装箱为封装类型<code>java.lang.Character</code>，但是自动装箱的封装类型<code>java.lang.Character</code>不会转换为其他封装类型，比如<code>Integer</code>。</li><li>封装类型<code>java.lang.Character</code>只能安全地转型为它实现的接口(如<code>java.lang.Serializable</code>)或父类(如<code>Object</code>)。</li><li>可见变长参数的重载优先级是最低的，这里使用的是<code>char</code>类型的变长参数。</li></ul><h5 id="2-2-2-动态分派"><a href="#2-2-2-动态分派" class="headerlink" title="2.2.2 动态分派"></a>2.2.2 动态分派</h5><p>动态分派与<code>重写（Override）</code>有着密切关联，考虑如下方法的动态分派：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法动态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"woman say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里选择调用的方法版本不可能再根据静态类型来决定的，因为静态类型同样都是<code>Human</code>的两个变量<code>man</code>和<code>woman</code>在调用<code>sayHello()</code>方法时产生了不同的行为。导致这个现象的原因很明显，是因为这两个变量的<code>实际类型</code>不同。</p><p>从子节码看，这两条调用指令无论是指令（都是<code>invokevirtual</code>）还是参数都完全一样，但是这两句指令最终执行的目标方法并不相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span><br><span class="line">20: aload_2</span><br><span class="line">21: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span><br></pre></td></tr></table></figure><p><code>invokevirtual</code>指令的运行时解析过程大致分为以下几步：</p><ol><li>找到操作数栈顶的第一个元素所指向的对象的<code>实际类型</code>，记作<code>C</code>。</li><li>如果在类型<code>C</code>中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回<code>java.lang.IllegalAccessError</code>异常。</li><li>否则，按照继承关系从下往上依次对<code>C</code>的各个父类进行第二步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li></ol><p><code>invokevirtual</code>指令执行的第一步就是在运行期确定<code>接收者（Receiver）</code>的<code>实际类型</code>，所以两次调用中的 <code>invokevirtual</code>指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。</p><blockquote><p>把这种在运行期根据<code>实际类型</code>确定方法执行版本的分派过程称为<code>动态分派</code>。</p></blockquote><h5 id="2-2-3-单分派与多分派"><a href="#2-2-3-单分派与多分派" class="headerlink" title="2.2.3 单分派与多分派"></a>2.2.3 单分派与多分派</h5><p>方法的<code>接收者</code>与方法的<code>参数</code>统称为方法的<code>宗量</code>，根据分派基于多少种宗量，可以将分派划分为<code>单分派</code>和<code>多分派</code>两种。</p><ul><li><code>单分派</code>是根据一个宗量对目标方法进行选择；</li><li><code>多分派</code>则是根据多于一个宗量对目标方法进行选择。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单分派、多分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先是编译阶段中编译器的选择过程，也就是<code>静态分派</code>的过程。选择目标方法的依据有两点：</p><ul><li>一是静态类型是Father还是Son；</li><li>二是方法参数是QQ还是360。</li></ul></li><li><p>选择结果的最终产生了两条<code>invokevirtual</code>指令，两条指令的参数分别为常量池中指向<code>Father::hardChoice(360)</code>及<code>Father::hardChoice(QQ)</code>方法的符号引用。</p></li></ul><blockquote><p>因为是根据两个宗量进行选择，所以Java语言的<code>静态分派</code>属于<code>多分派</code>类型。</p></blockquote><ul><li>然后是运行阶段中虚拟机的选择，也就是动态分派的过程：<ul><li>执行<code>“son.hardChoice(new QQ())”</code>所对应的<code>invokevirtual</code>指令时，由于编译期已经决定目标方法的签名必须为<code>hardChoice(QQ)</code>，这时候参数的<code>静态类型</code>、<code>实际类型</code>都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有该方法的<code>接受者的实际类型</code>。</li></ul></li></ul><blockquote><p>因为只有一个宗量作为选择依据， 所以Java语言的<code>动态分派</code>属于<code>单分派</code>类型。</p></blockquote><p>如今的Java语言是一门<code>静态多分派</code>、<code>动态单分派</code>的语言。</p><h5 id="2-3-4-虚拟机动态分派的实现"><a href="#2-3-4-虚拟机动态分派的实现" class="headerlink" title="2.3.4 虚拟机动态分派的实现"></a>2.3.4 虚拟机动态分派的实现</h5><p>动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的<code>方法元数据</code>中搜索合适的目标方法。基于执行性能的考虑，一种基础而且常见的优化手段是使用<code>虚方法表索引</code>来代替元数据查找以提高性能。</p><ul><li>为类型在方法区中建立一个<code>虚方法表（Virtual Method Table</code>，也称为<code>vtable</code>）</li><li>在<code>invokeinterface</code>执行时也会用到接口方法表（<code>Interface Method Table</code>，简称<code>itable</code>）</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/MethodTable.PNG" alt="方法表结构"></p><p>虚方法表中存放着各个方法的<code>实际入口地址</code>。</p><ul><li>如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。</li><li>如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</li></ul><p>具有<code>相同签名</code>的方法，在父类、子类的虚方法表中都应当具有一样的<code>索引序号</code>，当类型变换时仅需要变更查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p><p>虚拟机除了使用虚方法表之外，为了进一步提高性能，还会使用<code>类型继承关系分析（Class Hierarchy Analysis，CHA）</code>、<code>守护内联（Guarded Inlining）</code>、<code>内联缓存（Inline Cache）</code>等多种非稳定的激进优化来争取更大的性能空间。</p><h3 id="3-动态类型语言支持"><a href="#3-动态类型语言支持" class="headerlink" title="3. 动态类型语言支持"></a>3. 动态类型语言支持</h3><p><code>invokedynamic</code>指令是为了实现<code>动态类型语言（Dynamically Typed Language）</code>支持而进行的改进。</p><h4 id="3-1-动态类型语言"><a href="#3-1-动态类型语言" class="headerlink" title="3.1 动态类型语言"></a>3.1 动态类型语言</h4><p><code>动态类型语言</code>的<u>关键特征</u>是<strong><u>它的类型检查的主体过程是在运行期而不是编译期进行的</u></strong>。在编译期就进行类型检查过程的语言（譬如C++和Java等）就是<code>静态类型语言</code>。</p><p>动态类型语言与<code>Java</code>有一个核心的差异就是<u><strong>变量本身并没有类型，变量的值才具有类型</strong></u>，所以编译器在编译时最多只能确定<u>方法名称</u>、<u>参数</u>、<u>返回值</u>这些信息，而不会去确定方法所在的具体类型（即方法接收者不固定）。</p><blockquote><p><code>“变量无类型而变量值才有类型”</code>是动态类型语言的一个核心特征。</p></blockquote><h4 id="3-2-Java与动态类型"><a href="#3-2-Java与动态类型" class="headerlink" title="3.2 Java与动态类型"></a>3.2 Java与动态类型</h4><p><code>JDK 7</code>以前的字节码指令集中，4条方法调用指令（<code>invokevirtual</code>、<code>invokespecial</code>、<code>invokestatic</code>、 <code>invokeinterface</code>）的第一个参数都是<code>被调用方法的符号引用</code>，方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定方法的接收者。</p><h4 id="3-3-java-lang-invoke包"><a href="#3-3-java-lang-invoke包" class="headerlink" title="3.3 java.lang.invoke包"></a>3.3 <code>java.lang.invoke</code>包</h4><p><code>JDK 7</code>时新加入的<code>java.lang.invoke</code>包的主要目的是<u><strong>在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制</strong></u>，称为<code>“方法句柄”（Method Handle）</code>。</p><p>拥有方法句柄之后，Java语言也可以拥有类似于<code>函数指针</code>或者<code>委托</code>的方法别名这样的工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JSR 292 MethodHandle基础用法演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> ClassA();</span><br><span class="line">        <span class="comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。</span></span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">"icyfenix"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和具体参数（methodType()第二个及以后的参数）。</span></span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</span></span><br><span class="line">        <span class="comment">// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情。</span></span><br><span class="line">        <span class="keyword">return</span> lookup().findVirtual(reveiver.getClass(), <span class="string">"println"</span>, mt).bindTo(reveiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getPrintlnMH()</code>方法实际上是模拟了<code>invokevirtual</code>指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个由用户设计的Java方法来实现。而这个方法本身的返回值 <code>（MethodHandle对象）</code>，可以视为对最终调用方法的一个<code>“引用”</code>。</p><p><code>MethodHandle</code>与<code>Reflection</code>的区别：</p><ul><li><code>Reflection</code>和<code>MethodHandle</code>机制本质上都是在<strong>模拟方法调用</strong>，但是<code>Reflection</code>是在<strong>模拟Java代码层次</strong>的方法调用，而<code>MethodHandle</code>是在<strong>模拟字节码层次</strong>的方法调用。</li><li><code>Reflection</code>中的<code>java.lang.reflect.Method</code>比<code>MethodHandle</code>中的 <code>java.lang.invoke.MethodHandle</code>对象所包含的信息多。<ul><li>前者是方法在Java端的全面映像，包含了方法的<u>签名</u>、<u>描述符</u>以及<u>方法属性表中各种属性的Java端表示方式</u>，还包含<u>执行权限等的运行期信息</u>。</li><li>后者仅包含执行该方法的相关信息。<code>Reflection</code>是重量级，而<code>MethodHandle</code> 是轻量级。</li></ul></li><li>理论上<code>MethodHandle</code>上也可以采用虚拟机在字节码层次的各种优化方法 （如方法内联），而通过反射去调用方法则几乎不可能直接去实施各类调用点优化措施。</li><li><code>Reflection API</code>的设计目标是只为Java语言服务的，而<code>MethodHandle</code>则设计为可服务于所有Java虚拟机之上的语言。</li></ul><h4 id="3-4-invokedynamic指令"><a href="#3-4-invokedynamic指令" class="headerlink" title="3.4 invokedynamic指令"></a>3.4 <code>invokedynamic</code>指令</h4><p><code>invokedynamic</code>指令与<code>MethodHandle</code>机制的作用是一样的，都是把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中。两者的思路也是可类比的，只是一个用<strong>上层代码和API</strong>来实现， 另一个用<strong>字节码和Class中其他属性、常量</strong>来完成。</p><p>每一处含有<code>invokedynamic</code>指令的位置都被称作<code>“动态调用点（Dynamically-Computed Call Site）”</code>，这条指令的第一个参数是<code>JDK 7</code>时新加入的<code>CONSTANT_InvokeDynamic_info</code>常量，从中可以得到3项信息：</p><ul><li><code>引导方法（Bootstrap Method）</code>，该方法存放在新增的<code>BootstrapMethods</code>属性中，有固定的参数，并且返回值规定是<code>java.lang.invoke.CallSite</code>对象，这个对象代表了真正要执行的目标方法调用；</li><li><code>方法类型（MethodType）</code>；</li><li><code>名称</code>。</li></ul><h3 id="4-基于栈的字节码解释执行引擎"><a href="#4-基于栈的字节码解释执行引擎" class="headerlink" title="4. 基于栈的字节码解释执行引擎"></a>4. 基于栈的字节码解释执行引擎</h3><h4 id="4-1-解释执行"><a href="#4-1-解释执行" class="headerlink" title="4.1 解释执行"></a>4.1 解释执行</h4><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过如下各个步骤</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/compileProcess.PNG" alt="编译过程"></p><h4 id="4-2-基于栈的指令集与基于寄存器的指令集"><a href="#4-2-基于栈的指令集与基于寄存器的指令集" class="headerlink" title="4.2 基于栈的指令集与基于寄存器的指令集"></a>4.2 基于栈的指令集与基于寄存器的指令集</h4><p><code>基于栈的指令集架构（Instruction Set Architecture，ISA）</code>，字节码指令流里面的指令大部分都是<strong><u>零地址指令</u></strong>，它们依赖操作数栈进行工作。<code>Javac</code>编译器输出的字节码指令流基本上是基于栈的指令集架构。</p><ul><li>主要优点是可移植，因为寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。还有一些其他的优点，如代码相对更加紧凑，编译器实现更加简单。</li><li>主要缺点是理论上执行速度相对来说会稍慢一些。完成相同功能所需的指令数量一般会比寄存器架构来得更多，更重要的是栈实现在内存中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。</li></ul><p><code>基于寄存器的指令集</code>，就是现在我们主流PC机中物理硬件直接支持的指令集架构，这些指令依赖寄存器进行工作。最典型的就是<code>x86</code>的<strong><u>二地址指令集</u></strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;执行引擎是Java虚拟机核心的组成部分之一。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--7 虚拟机类加载机制</title>
    <link href="https://wuyunjie.top/2021/05/27/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_7_Virtual_machine_class_loading_mechanism.html"/>
    <id>https://wuyunjie.top/2021/05/27/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_7_Virtual_machine_class_loading_mechanism.html</id>
    <published>2021-05-27T05:31:54.000Z</published>
    <updated>2021-05-27T05:31:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>在Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。<br><a id="more"></a></p></blockquote><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的<code>类加载机制</code>。</p><h3 id="1-类加载的时机"><a href="#1-类加载的时机" class="headerlink" title="1. 类加载的时机"></a>1. 类加载的时机</h3><p>一个类型<strong><u>从被加载到虚拟机内存中开始，到卸载出内存为止</u></strong>，它的整个生命周期将会经历七个阶段:</p><ul><li>加载（Loading）</li><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）</li><li>初始化 （Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><p>其中验证、准备、解析三个部分统称为连接（Linking）。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ClassLifeCycle.PNG" alt="类的生命周期"></p><blockquote><p>解析阶在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的<code>运行时绑定</code>特性（也称为<code>动态绑定</code>或<code>晚期绑定</code>）。</p></blockquote><p>只有六种情况必须立即对类进行<code>“初始化”</code>（而加载、验证、准备自然需要在此之前开始）：</p><ul><li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段；</li><li>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化；</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；<ul><li>一个<code>接口</code>在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li></ul></li><li>当虚拟机启动时，用户需要指定一个要执行的<code>主类（包含main()方法的那个类）</code>，虚拟机会先初始化这个主类；</li><li>当使用<code>JDK 7</code>新加入的<code>动态语言支持</code>时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析的方法句柄对应的类没有进行过初始化，则需要先触发其初始化；</li><li>当一个接口中定义了<code>JDK 8</code>新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化；</li></ul><h3 id="2-类加载的过程"><a href="#2-类加载的过程" class="headerlink" title="2. 类加载的过程"></a>2. 类加载的过程</h3><h4 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h4><p><code>“加载”（Loading）</code>阶段是整个<code>“类加载”（Class Loading）</code>过程中的一个阶段，在加载阶段，Java虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的<code>二进制字节流</code>。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的<code>findClass()</code>或<code>loadClass()</code>方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p><h4 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是<u>确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</u>。从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节 码验证和符号引用验证。</p><h5 id="2-2-1-文件格式验证"><a href="#2-2-1-文件格式验证" class="headerlink" title="2.2.1 文件格式验证"></a>2.2.1 文件格式验证</h5><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p><p>该验证阶段的主要目的是<u><strong>保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。</strong></u>这阶段的验证是<strong>基于二进制字节流进行的</strong>，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储。</p><h5 id="2-2-2-元数据验证"><a href="#2-2-2-元数据验证" class="headerlink" title="2.2.2 元数据验证"></a>2.2.2 元数据验证</h5><p>对字节码描述的信息进行<code>语义分析</code>，以保证其描述的信息符合《Java语言规范》的要求。</p><h5 id="2-2-3-字节码验证"><a href="#2-2-3-字节码验证" class="headerlink" title="2.2.3 字节码验证"></a>2.2.3 字节码验证</h5><p>通过<code>数据流分析</code>和<code>控制流分析</code>，确定程序语义是合法的、符合逻辑的。</p><p>这阶段对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。</p><h5 id="2-2-4-符号引用验证"><a href="#2-2-4-符号引用验证" class="headerlink" title="2.2.4 符号引用验证"></a>2.2.4 符号引用验证</h5><p>符号引用验证可以看作是<strong><u>对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验</u></strong>，即该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p><p>该校验过程发生在虚拟机<u>将符号引用转化为直接引用</u>的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</p><h4 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3 准备"></a>2.3 准备</h4><p>准备阶段是正式<u><strong>为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值</strong></u>的阶段。</p><p>两个容易产生混淆的概念：</p><ul><li>此时进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</li><li>这里所说的初始值“通常情况”下是<code>数据类型的零值</code>。<ul><li>比如对于<code>public static int value = 123;</code>，变量value在准备阶段过后的初始值为0，把 <code>value</code>赋值为<code>123</code>的<code>putstatic</code>指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中，所以把<code>value</code>赋值为<code>123</code>的动作要到<strong>类的初始化阶段</strong>才会被执行。</li><li>如果类字段的字段属性表中存在<code>ConstantValue</code>属性，那在准备阶段变量值就会被初始化为<code>ConstantValue</code>属性所指定的初始值(比如<code>public static final int value = 123;</code>)</li></ul></li></ul><h4 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 解析</h4><p>解析阶段是Java虚拟机<strong>将常量池内的符号引用替换为直接引用</strong>的过程。</p><ul><li><code>符号引用（Symbolic References）</code>：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的<strong>字面量</strong>，只要使用时能无歧义地定位到目标即可。<ul><li>符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。</li></ul></li><li><code>直接引用（Direct References）</code>：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。<ul><li>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</li><li>如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li></ul></li></ul><p>虚拟机实现可以对第一次解析的结果进行缓存(除<code>invokedynamic</code>指令以外)，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。无论是否真正执行了多次解析动作，Java虚拟机都需要保证的是在同一个实体中：</p><ul><li>如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功；</li><li>如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功加载进Java虚拟机内存之中。 </li></ul><p>对于<code>invokedynamic</code>指令，上面的规则就不成立了。当碰到某个前面已经由<code>invokedynamic</code>指令触发过解析的符号引用时，并不意味着这个解析结果对于其他<code>invokedynamic</code>指令也同样生效。</p><ul><li><code>invokedynamic</code>指令的目的本来就是用于动态语言支持，它对应的引用称为<code>“动态调用点限定符 （Dynamically-Computed Call Site Specifier）”</code>，这里<code>“动态”</code>的含义是指<u><strong>必须等到程序实际运行到这条指令时，解析动作才能进行</strong></u>。</li></ul><p>解析动作主要针对<u><strong>类或接口</strong></u>、<u><strong>字段</strong></u>、<u><strong>类方法</strong></u>、<u><strong>接口方法</strong></u>、<u><strong>方法类型</strong></u>、<u><strong>方法句柄</strong></u>和<u><strong>调用点限定符</strong></u>这7类符号引用进行。</p><h5 id="2-4-1-类或接口的解析"><a href="#2-4-1-类或接口的解析" class="headerlink" title="2.4.1 类或接口的解析"></a>2.4.1 类或接口的解析</h5><p>假设当前代码所处的类为<code>D</code>，如果要把一个从未解析过的符号引用<code>N</code>解析为一个类或接口<code>C</code>的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p><ol><li>如果<code>C</code>不是一个数组类型，那虚拟机将会把代表<code>N</code>的全限定名传递给<code>D</code>的类加载器去加载这个类<code>C</code>。</li><li>如果<code>C</code>是一个数组类型，并且数组的元素类型为对象，也就是<code>N</code>的描述符会是类似“<code>[Ljava/lang/Integer</code>”的形式，那将会按照第一点的规则加载数组元素类型。</li><li>如果上面两步没有出现任何异常，那么<code>C</code>在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认<code>D</code>是否具备对<code>C</code>的访问权限。如果发现不具备访问权限， 将抛出<code>java.lang.IllegalAccessError</code>异常。</li></ol><p>如果我们说一个<code>D</code>拥有<code>C</code>的访问权限，那就意味着以下3条规则中至少有其中一条成立：</p><ul><li>被访问类<code>C</code>是<code>public</code>的，并且与访问类<code>D</code>处于同一个模块。</li><li>被访问类<code>C</code>是<code>public</code>的，不与访问类<code>D</code>处于同一个模块，但是<code>被访问类C</code>的模块允许<code>访问类D</code>的模块进行访问。 </li><li>被访问类<code>C</code>不是<code>public</code>的，但是它与访问类<code>D</code>处于同一个包中。</li></ul><h5 id="2-4-2-字段解析"><a href="#2-4-2-字段解析" class="headerlink" title="2.4.2 字段解析"></a>2.4.2 字段解析</h5><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内<code>class_index</code>项中索引的<code>CONSTANT_Class_info</code>符号引用进行解析，也就是<strong><u>字段所属的类或接口的符号引用</u></strong>。</p><p>如果解析成功完成，那把这个字段所属的类或接口用<code>C</code>表示，按照如下步骤对C进行后续字段的搜索：</p><ol><li>如果<code>C</code>本身就包含了<strong>简单名称</strong>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>如果在<code>C</code>中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口， 如果接口中包含了<strong>简单名称</strong>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>如果<code>C</code>不是<code>java.lang.Object</code>的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了<code>简单名称</code>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，查找失败，抛出<code>java.lang.NoSuchFieldError</code>异常。</li></ol><p>如果查找过程成功返回了引用，将会对这个字段进行权限验证。</p><h5 id="2-4-3-方法解析"><a href="#2-4-3-方法解析" class="headerlink" title="2.4.3 方法解析"></a>2.4.3 方法解析</h5><p>方法解析的第一个步骤也是需要先解析出方法表的<code>class_index</code>项中索引的方法所属的类或接口的符号引用，如果解析成功，那么依然用<code>C</code>表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：</p><ol><li>由于Class文件格式中<strong><u>类的方法和接口的方法符号引用的常量类型定义是分开的</u></strong>，如果在类的方法表中发现<code>class_index</code>中索引的<code>C</code>是个接口的话，那就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li><li>在类<code>C</code>中查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>在类<code>C</code>的父类中递归查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>在类<code>C</code>实现的接口列表及它们的父接口之中递归查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果存在匹配的方法，说明类<code>C</code>是一个抽象类，这时候查找结束，抛出<code>java.lang.AbstractMethodError</code>异常。</li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>。 </li></ol><p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证。</p><h5 id="2-4-4-接口方法解析"><a href="#2-4-4-接口方法解析" class="headerlink" title="2.4.4 接口方法解析"></a>2.4.4 接口方法解析</h5><p>接口方法也是需要先解析出接口方法表的<code>class_index</code>项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用<code>C</code>表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p><ol><li>与类的方法解析相反，如果在接口方法表中发现<code>class_index</code>中的索引<code>C</code>是个类而不是接口，那么就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li><li>在接口<code>C</code>中查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>在接口<code>C</code>的父接口中递归查找，直到<code>java.lang.Object</code>类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。<ul><li>由于Java的<u>接口允许多重继承</u>，如果C的不同父接口中存有<u>多个</u><strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，不同发行商实现的<code>Javac</code>编译器有可能会按照<u><strong>更严格的约束拒绝编译这种代码来避免不确定性</strong></u>。</li></ul></li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</li></ol><blockquote><ul><li>在<code>JDK 9</code>之前，Java接口中的所有方法都<u>默认是<code>public</code>的</u>，也没有模块化的访问约束，所以不存在访问权限的问题。</li><li>但在<code>JDK 9</code>中增加了<u>接口的静态私有方法</u>，也有了模块化的访问约束，所以接口方法的访问也完全有可能因访问权限控制而出现<code>java.lang.IllegalAccessError</code>异常。</li></ul></blockquote><h4 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h4><blockquote><p>直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p></blockquote><p>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><blockquote><p><code>&lt;clinit&gt;()</code>并不是程序员在Java代码中直接编写的方法，它是<code>Javac</code>编译器的自动生成物。</p></blockquote><p><code>&lt;clinit&gt;()</code>方法是由编译器<u>自动收集</u>类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块（static{}块）中的语句</strong>合并产生的。</p><ul><li><code>&lt;clinit&gt;()</code>方法不需要显式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。意味着父类中定义的静态语句块要优先于子类的变量赋值操作；</li><li><code>&lt;clinit&gt;()</code>方法不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法</li><li>执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，接口的<strong><u>实现类</u></strong>在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法；</li><li>Java虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法方法在多线程环境中被正确地加锁同步。</li><li>同一个类加载器下，一个类型只会被初始化一次。</li></ul><h3 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3. 类加载器"></a>3. 类加载器</h3><p>实现<code>“通过一个类的全限定名来获取描述该类的二进制字节流”</code>这个动作的代码被称为<code>“类加载器”（Class Loader）</code>。</p><h4 id="3-1-类与类加载器"><a href="#3-1-类与类加载器" class="headerlink" title="3.1 类与类加载器"></a>3.1 类与类加载器</h4><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的<strong><u>唯一性</u></strong>，每一个类加载器都拥有一个独立的类名称空间。</p><blockquote><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，只要加载它们的类加载器不同，那这两个类就<strong>必定不相等</strong>。</p></blockquote><h4 id="3-2-双亲委派模型"><a href="#3-2-双亲委派模型" class="headerlink" title="3.2 双亲委派模型"></a>3.2 双亲委派模型</h4><p>Java虚拟机的角度来看，只存在两种不同的类加载器：</p><ul><li><code>启动类加载器（Bootstrap ClassLoader）</code>，这个类加载器是虚拟机自身的一部分；</li><li>其他所有的类加载器，这些类加载器都由Java语言实现，<strong><u>独立存在于虚拟机外部</u></strong>，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。</li></ul><p>Java开发人员的角度来看，类加载器是<code>三层类加载器</code>、<code>双亲委派</code>的类加载架构：</p><ul><li><code>启动类加载器（Bootstrap Class Loader）</code>：负责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用；</li><li><code>扩展类加载器（Extension Class Loader）</code>：负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库。这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoader</code>中以Java代码的形式实现的。</li><li><code>应用程序类加载器（Application Class Loader）</code>：负责加载用户类路径<code>（ClassPath）</code>上所有的类库，由 <code>sun.misc.Launcher$AppClassLoader</code>来实现。</li></ul><p><u><code>JDK 9</code>之前</u>的Java应用都是由这三种类加载器互相配合来完成加载的，用户可以加入自定义的类加载器来进行拓展，如：</p><ul><li>增加除了磁盘位置之外的Class文件来源</li><li>通过类加载器实现类的隔离、重载等功能。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ParentsDelegation.PNG" alt="双亲委派模型"></p><p><code>“双亲委派模型（Parents Delegation Model）”</code>要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p><blockquote><p>类加载器之间的父子关系一般不是以<code>继承（Inheritance）</code>来实现的，而是通常使用<code>组合（Composition）</code>关系来复用父加载器的代码。</p></blockquote><p>双亲委派模型的工作过程是：</p><ul><li>如果一个类加载器收到了类加载的请求，首先把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中；</li><li>只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</li></ul><h4 id="3-3-破坏双亲委派模型"><a href="#3-3-破坏双亲委派模型" class="headerlink" title="3.3 破坏双亲委派模型"></a>3.3 破坏双亲委派模型</h4><p>直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况：</p><ul><li>第一次“被破坏”其实发生在双亲委派模型出现之前——即<code>JDK 1.2</code>面世以前。</li><li>第二次“被破坏”是由这个模型自身的缺陷导致的，有基础类型要调用回用户的代码。</li><li>第三次“被破坏”是由于用户对程序动态性的追求而导致的。</li></ul><p><code>OSGi</code>实现模块化热部署的关键是<u><strong>它自定义的类加载器机制的实现</strong></u>：</p><ul><li>每一个程序模块（<code>OSGi</code>中称为<code>Bundle</code>）都有一个自己的类加载器，当需要更换一个<code>Bundle</code>时，就把<code>Bundle</code>连同类加载器一起换掉以实现代码的热替换。</li></ul><p>在<code>OSGi</code>环境下，类加载器发展为更加复杂的网状结构，当收到类加载请求时，<code>OSGi</code>将按照下面的顺序进行类搜索：</p><ol><li>将以<code>java.*</code>开头的类，委派给父类加载器加载。</li><li>否则，将委派列表名单内的类，委派给父类加载器加载。</li><li>否则，将<code>Import</code>列表中的类，委派给<code>Export</code>这个类的<code>Bundle</code>的类加载器加载。</li><li>否则，查找当前<code>Bundle</code>的<code>ClassPath</code>，使用自己的类加载器加载。</li><li>否则，查找类是否在自己的<code>Fragment Bundle</code>中，如果在，则委派给<code>Fragment Bundle</code>的类加载器加载。</li><li>否则，查找<code>Dynamic Import</code>列表的<code>Bundle</code>，委派给对应<code>Bundle</code>的类加载器加载。</li><li>否则，类查找失败。</li></ol><h3 id="4-Java模块化系统"><a href="#4-Java模块化系统" class="headerlink" title="4. Java模块化系统"></a>4. Java模块化系统</h3><p><code>JDK 9</code>中引入的<code>Java模块化系统（Java Platform Module System，JPMS）</code>能够实现模块化的关键目标——可配置的封装隔离机制。<code>JDK 9</code>的模块除了简单地充当代码的容器，还包含以下内容：</p><ul><li>依赖其他模块的列表。</li><li>导出的包列表，即其他模块可以使用的列表。</li><li>开放的包列表，即其他模块可反射访问模块的列表。</li><li>使用的服务列表。</li><li>提供服务的实现列表。</li></ul><p><u><strong>可配置的封装隔离机制</strong></u>解决了：</p><ul><li><code>JDK 9</code>之前基于<code>类路径（ClassPath）</code>来查找依赖的<strong>可靠性问题</strong>。</li><li>原来类路径上跨<code>JAR</code>文件的<code>public</code>类型的<strong>可访问性问题</strong>。</li></ul><h4 id="4-1-模块的兼容性"><a href="#4-1-模块的兼容性" class="headerlink" title="4.1 模块的兼容性"></a>4.1 模块的兼容性</h4><p><code>JDK 9</code>提出了与<code>“类路径”（ClassPath）</code>相对应的<code>“模块路径”（ModulePath）</code>的概念，使<u><strong>可配置的封装隔离机制</strong></u>能够兼容传统的类路径查找机制。</p><p>模块化系统将按照以下规则来保证使用传统类路径依赖的Java程序可以不经修改地直接运行在<code>JDK 9</code>及以后的Java版本上：</p><ul><li><strong>JAR文件在类路径的访问规则</strong>：所有类路径下的<code>JAR</code>文件及其他资源文件，都被视为自动打包在一个<code>匿名模块（Unnamed Module）</code>里，这个匿名模块<strong>几乎是没有任何隔离的</strong>，它可以看到和使用<u>类路径上所有的包</u>、<u>JDK系统模块中所有的导出包</u>，以及<u>模块路径上所有模块中导出的包</u>。</li><li><strong>模块在模块路径的访问规则</strong>：模块路径下的<code>具名模块（Named Module）</code>只能访问到它<u>依赖定义中列明依赖的模块和包</u>，匿名模块里所有的内容对具名模块来说都是不可见的，即<strong><u>具名模块看不见传统JAR包的内容</u></strong>。</li><li><strong>JAR文件在模块路径的访问规则</strong>：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个<code>自动模块（Automatic Module）</code>。尽管不包含<code>module-info.class</code>，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到<u>所有模块导出的</u>包，自动模块也<strong>默认导出自己所有的包</strong>。</li></ul><h4 id="4-2-模块化下的类加载器"><a href="#4-2-模块化下的类加载器" class="headerlink" title="4.2 模块化下的类加载器"></a>4.2 模块化下的类加载器</h4><p><code>JDK 9</code>为了模块化系统的顺利施行，模块化下的类加载器发生了一些变动，主要包括以下几个方面：</p><ul><li><code>扩展类加载器（Extension Class Loader）</code>被<code>平台类加载器（Platform Class Loader）</code>取代。</li><li><code>平台类加载器</code>和<code>应用程序类加载器</code>都不再派生自<code>java.net.URLClassLoader</code>，现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 <code>jdk.internal.loader.BuiltinClassLoader</code>。<code>BuiltinClassLoader</code>中实现了新的模块化架构下<u>类如何从模块中加载的逻辑</u>，以及<u>模块中资源可访问性的处理</u>。</li><li><code>JDK 9</code>中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。<ul><li>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类<u>是否能够归属到某一个系统模块中</u>，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JDK9ClassLoaderDelegation.PNG" alt="JDK 9后的类加载器委派关系"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--6 类文件结构</title>
    <link href="https://wuyunjie.top/2021/05/26/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_6_Class_file_structure.html"/>
    <id>https://wuyunjie.top/2021/05/26/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_6_Class_file_structure.html</id>
    <published>2021-05-26T13:23:04.000Z</published>
    <updated>2021-05-26T13:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</code><br><a id="more"></a></p></blockquote><h3 id="1-无关性的基石"><a href="#1-无关性的基石" class="headerlink" title="1. 无关性的基石"></a>1. 无关性的基石</h3><p>各种不同平台的Java虚拟机，以及所有平台都统一支持的<u>程序存储格式</u>——<code>字节码（Byte Code）</code>是构成平台无关性的基石。Java虚拟机<strong>不与包括Java语言在内的任何程序语言绑定，它只与<code>“Class文件”</code>这种特定的二进制文件格式所关联</strong>，<code>Class文件</code>中包含了<code>Java虚拟机指令集</code>、<code>符号表</code>以及<code>若干其他辅助信息</code>。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JVMLanguageIndependence.PNG" alt="Java虚拟机的语言无关性"></p><p>Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，这决定了<u>字节码指令所能提供的语言描述能力比Java语言本身更加强大</u>。</p><h3 id="2-Class类文件的结构"><a href="#2-Class类文件的结构" class="headerlink" title="2. Class类文件的结构"></a>2. Class类文件的结构</h3><p><code>Class文件</code>是一组以<code>8</code>个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，<strong>中间没有添加任何分隔符</strong>，这使得<u>整个Class文件中存储的内容几乎全部是程序运行的必要数据</u>，没有空隙存在。遇到需要占用8个字节以上空间的数据项时，则会<strong><code>按照高位在前的方式分割</code></strong>成若干个8个字节进行存储。</p><blockquote><p>任何一个Class文件都对应着唯一的一个类或接口的定义信息。反过来说，<strong>类或接口并不一定都得定义在文件里</strong>（譬如类或接口也可以动态生成，直接送入类加载器中）。</p></blockquote><p>Class文件格式采用一种类似于C语言结构体的<code>伪结构</code>来存储数据，这种伪结构中只有两种数据类型：<code>“无符号数”</code>和<code>“表”</code>。</p><ul><li><code>无符号数</code>属于<u><strong>基本的数据类型</strong></u>，以<code>u1</code>、<code>u2</code>、<code>u4</code>、<code>u8</code>来分别代表1个字节、2个字节、4个字节和8个 字节的无符号数，可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li><code>表</code>是<u><strong>由多个无符号数或者其他表作为数据项构成的复合数据类型</strong></u>，所有表的命名都习惯性地以<code>“_info”</code>结尾。表用于描述有层次关系的复合结构的数据，<strong><code>整个Class文件本质上也可以视作是一张表</code></strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ClassFileStructure.PNG" alt="Class文件格式"></p><h4 id="2-1-魔数与Class文件的版本"><a href="#2-1-魔数与Class文件的版本" class="headerlink" title="2.1 魔数与Class文件的版本"></a>2.1 魔数与Class文件的版本</h4><p>每个Class文件的头4个字节被称为<code>魔数（Magic Number）</code>，它的<strong>唯一作用</strong>是<u><strong>确定这个文件是否为一个能被虚拟机接受的Class文件</strong></u>。</p><blockquote><p>Class文件的魔数取得很有“浪漫气息”，值为<code>0xCAFEBABE</code>(咖啡宝贝?)</p></blockquote><p>第5和第6个字节是<code>次版本号（Minor Version）</code>，第7和第8个字节是<code>主版本号（Major Version）</code>。</p><blockquote><p>Java的版本号是从45开始的。在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p></blockquote><h4 id="2-2-常量池"><a href="#2-2-常量池" class="headerlink" title="2.2 常量池"></a>2.2 常量池</h4><p>常量池可以比喻为<code>Class</code>文件里的资源仓库，通常也是占用<code>Class</code>文件空间最大的数据项目之一，它还是在Class文件中第一个出现的<code>表类型数据项目</code>。</p><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项<code>u2</code>类型的数据，代表<code>常量池容量计数值（constant_pool_count）</code>。</p><blockquote><p>Class文件结构中只有常量池的容量计数是<strong>从1开始</strong>。将第0项常量空出来目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达<strong>“不引用任何一个常量池项目”</strong>的含义，可以把索引值设置为0来表示。</p></blockquote><p>常量池中主要存放两大类常量：<code>字面量（Literal）</code>和<code>符号引用（Symbolic References）</code>。</p><ul><li>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等；</li><li>符号引用则属于编译原理方面的概念，主要包括下面几类常量：<ul><li>被模块导出或者开放的包（Package）；</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul></li></ul><p>常量池中每一项常量都是一个表。这类表都有一个共同的特点，表结构起始的第一位是个<code>u1</code>类型的标志位（<code>tag</code>），代表着当前常量属于哪种常量类型。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ItemTypeOfConstantPool.PNG" alt="常量池的项目类型"></p><blockquote><p>可以使用用于分析Class文件字节码的工具：<code>javap</code>，输出的<code>TestClass.class</code>文件字节码内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose TestClass</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-3-访问标志"><a href="#2-3-访问标志" class="headerlink" title="2.3 访问标志"></a>2.3 访问标志</h4><p><code>访问标志（access_flags）</code>，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；等等。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/accessFlags.PNG" alt="访问标志"></p><p>举例：TestClass是一个普通Java类，它的<code>ACC_PUBLIC</code>、<code>ACC_SUPER</code>标志应当为真，其他为假，因此它的<code>access_flags</code>的值应为：<code>0x0001|0x0020=0x0021</code>。</p><h4 id="2-4-类索引、父类索引与接口索引集合"><a href="#2-4-类索引、父类索引与接口索引集合" class="headerlink" title="2.4 类索引、父类索引与接口索引集合"></a>2.4 类索引、父类索引与接口索引集合</h4><p><code>类索引（this_class）</code>和<code>父类索引（super_class）</code>都是一个<code>u2</code>类型的数据，而<code>接口索引集合（interfaces）</code>是一组<code>u2</code>类型的数据的集合，Class文件中由这三项数据来确定该<strong><u>类型的继承关系</u></strong>。</p><blockquote><ul><li>类索引用于确定这个类的全限定名</li><li>父类索引用于确定这个类的父类的全限定名。父类索引只有一个(不允许多重继承)</li><li>接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按<code>implements</code>关键字后的接口顺序从左到右排列在接口索引集合中。</li></ul></blockquote><p>类索引和父类索引用两个<code>u2</code>类型的索引值表示，它们各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过<code>CONSTANT_Class_info</code>类型的常量中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型的常量中的<code>全限定名字符串</code>。</p><p>对于接口索引集合，入口的第一项<code>u2</code>类型的数据为<code>接口计数器（interfaces_count）</code>，表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0。</p><h4 id="2-5-字段表集合"><a href="#2-5-字段表集合" class="headerlink" title="2.5 字段表集合"></a>2.5 字段表集合</h4><p><code>字段表（field_info）</code>用于描述接口或者类中声明的变量。<code>“字段”（Field）</code>包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/fieldInfo.PNG" alt="字段表结构"></p><p><code>name_index</code>和<code>descriptor_index</code>都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p><ul><li><code>全限定名</code>和<code>简单名称</code>。比如<code>“org/fenixsoft/clazz/TestClass”</code>是类的<code>全限定名</code>；<code>简单名称</code>则就是指没有类型和参数修饰的方法或者字段名称，类中的<code>inc()</code>方法和<code>m</code>字段的简单名称分别就是“<code>inc</code>”和“<code>m</code>”。</li><li><code>描述符</code>的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。<ul><li>对于数组类型，每一维度将使用一个前置的<code>“[”</code>字符来描述。比如<code>“int[]”</code>将被记录成<code>“[I”</code>。</li><li>描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号<code>“()”</code>之内。<code>void inc()</code>的描述符为<code>“()V”</code>。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/descriptor.PNG" alt="描述符"></p><blockquote><p>字段表集合中不会列出从父类或者父接口中继承而来的字段</p></blockquote><h4 id="2-6-方法表集合"><a href="#2-6-方法表集合" class="headerlink" title="2.6 方法表集合"></a>2.6 方法表集合</h4><p>对方法的描述与对字段的描述采用了几乎完全一致的方式，依次包括<code>访问标志（access_flags）</code>、<code>名称索引（name_index）</code>、<code>描述符索引（descriptor_index）</code>、<code>属性表集合（attributes）</code>几项。</p><blockquote><p>父类方法在子类中没有被<code>重写（Override）</code>，方法表集合中就不会出现来自父类的方法信息。</p></blockquote><h4 id="2-7-属性表集合"><a href="#2-7-属性表集合" class="headerlink" title="2.7 属性表集合"></a>2.7 属性表集合</h4><p>Class文件、字段表、方法表都可以携带自己的<code>属性表集合（attribute_info）</code>。对于每一个属性，它的名称都要从常量池中引用一个<code>CONSTANT_Utf8_info</code>类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个<code>u4</code>的长度属性去说明属性值所占用的位数即可。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/attributeInfo.PNG" alt="属性表结构"></p><h5 id="2-7-1-Code属性"><a href="#2-7-1-Code属性" class="headerlink" title="2.7.1 Code属性"></a>2.7.1 Code属性</h5><p>Java程序方法体里面的代码经过<code>Javac</code>编译器处理之后，最终变为字节码指令存储在<code>Code属性</code>内。Code属性出现在方法表的属性集合之中。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/CodeAttributeInfo.PNG" alt="Code属性表的结构"></p><ul><li><code>attribute_name_index</code>是一项指向<code>CONSTANT_Utf8_info</code>型常量的索引，此常量值<strong>固定为<code>“Code”</code></strong>；</li><li><code>attribute_length</code>指示了属性值的长度；</li><li><code>max_stack</code>代表了<code>操作数栈（Operand Stack）</code>深度的最大值；</li><li><code>max_locals</code>代表了局部变量表所需的存储空间。<code>Javac</code>编译器会根据变量的作用域来分配变量槽给各个变量使用，根据<u><strong>同时生存的最大局部变量数量和类型</strong></u>计算出<code>max_locals</code>的大小。</li><li><code>code_length</code>和code用来存储Java源程序编译后生成的字节码指令。<code>code_length</code>代表字节码长度，虽然它是一个<code>u4</code>类型的长度值，理论上最大值可以达到<code>2的32次幂</code>。有可能<strong><u>因为方法生成字节码超长的原因而导致编译失败</u></strong>。</li><li>Code属性用于描述代码。<ul><li>Java语言里面的潜规则：在任何实例方法里面，都可以通过“<code>this”</code>关键字访问到此方法所属的对象。是通过在<code>Javac</code>编译器编译的时候把对<code>this</code>关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数。所以在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量。</li></ul></li><li>显式异常处理表对于Code属性来说并不是必须存在的。如果存在异常表，它包含<u>四个字段</u>，这些字段的含义为：如果当字节码从第<code>start_pc</code>行到第<code>end_pc</code>行之间（不含第<code>end_pc</code>行）出现了类型为<code>catch_type</code>或者其子类的异常（<code>catch_type</code>为指向一个<code>CONSTANT_Class_info</code>型常量的索引），则转到第<code>handler_pc</code>行继续处理。当 <code>catch_type</code>的值为0时，代表任意异常情况都需要转到<code>handler_pc</code>处进行处理。</li></ul><h5 id="2-7-2-Exceptions属性"><a href="#2-7-2-Exceptions属性" class="headerlink" title="2.7.2 Exceptions属性"></a>2.7.2 Exceptions属性</h5><p><code>Exceptions属性</code>是在方法表中与Code属性平级的一项属性，作用是列举出方法中可能抛出的<code>受查异常（Checked Excepitons）</code>。</p><h5 id="2-7-3-LineNumberTable属性"><a href="#2-7-3-LineNumberTable属性" class="headerlink" title="2.7.3 LineNumberTable属性"></a>2.7.3 LineNumberTable属性</h5><p><code>LineNumberTable</code>属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。</p><h5 id="2-7-4-LocalVariableTable及LocalVariableTypeTable属性"><a href="#2-7-4-LocalVariableTable及LocalVariableTypeTable属性" class="headerlink" title="2.7.4 LocalVariableTable及LocalVariableTypeTable属性"></a>2.7.4 LocalVariableTable及LocalVariableTypeTable属性</h5><ul><li><code>LocalVariableTable</code>属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。</li><li><code>LocalVariableTypeTable</code>把<code>LocalVariableTabl</code>字段描述符的<code>descriptor_index</code>替换成了字段的<code>特征签名（Signature）</code>。泛型引入之后，由于描述符中泛型的参数化类型<code>被擦除掉</code>，描述符就不能准确描述泛型类型了。因此出现了<code>LocalVariableTypeTable</code>属性，<strong><u>使用字段的特征签名来完成泛型的描述</u></strong>。</li></ul><h5 id="2-7-5-SourceFile及SourceDebugExtension属性"><a href="#2-7-5-SourceFile及SourceDebugExtension属性" class="headerlink" title="2.7.5 SourceFile及SourceDebugExtension属性"></a>2.7.5 SourceFile及SourceDebugExtension属性</h5><p><code>SourceFile</code>属性用于记录生成这个Class文件的源码文件名称。</p><p><code>SourceDebugExtension</code>属性用于存储额外的代码调试信息。</p><h5 id="2-7-6-ConstantValue属性"><a href="#2-7-6-ConstantValue属性" class="headerlink" title="2.7.6 ConstantValue属性"></a>2.7.6 ConstantValue属性</h5><p><code>ConstantValue</code>属性的作用是通知虚拟机自动为静态变量赋值。只有被<code>static</code>关键字修饰的变量（类变量）才可以使用这项属性。</p><h5 id="2-7-7-InnerClasses属性"><a href="#2-7-7-InnerClasses属性" class="headerlink" title="2.7.7 InnerClasses属性"></a>2.7.7 InnerClasses属性</h5><p><code>InnerClasses</code>属性用于记录内部类与宿主类之间的关联。</p><h5 id="2-7-8-Deprecated及Synthetic属性"><a href="#2-7-8-Deprecated及Synthetic属性" class="headerlink" title="2.7.8 Deprecated及Synthetic属性"></a>2.7.8 Deprecated及Synthetic属性</h5><ul><li><code>Deprecated</code>属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用<code>“@deprecated”</code>注解进行设置；</li><li><code>Synthetic</code>属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的。</li></ul><blockquote><p><code>Deprecated</code>和<code>Synthetic</code>两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</p></blockquote><h5 id="2-7-9-StackMapTable属性"><a href="#2-7-9-StackMapTable属性" class="headerlink" title="2.7.9 StackMapTable属性"></a>2.7.9 StackMapTable属性</h5><p><code>StackMapTable</code>属性会在虚拟机类加载的字节码验证阶段被<code>新类型检查验证器（Type Checker）</code>使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p><h5 id="5-7-10-Signature属性"><a href="#5-7-10-Signature属性" class="headerlink" title="5.7.10 Signature属性"></a>5.7.10 Signature属性</h5><p><code>Signature</code>属性记录泛型类型，是因为Java语言的泛型采用的是<code>擦除法</code>实现的伪泛型，字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。</p><blockquote><ul><li>使用擦除法的好处是实现简单（主要修改<code>Javac</code>编译器，虚拟机内部只做了很少的改动）、非常容易实现<code>Backport</code>，运行期也能够节省一些类型所占的内存空间。</li><li>坏处是运行期就无法像有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待</li></ul></blockquote><h5 id="2-7-11-BootstrapMethods属性"><a href="#2-7-11-BootstrapMethods属性" class="headerlink" title="2.7.11 BootstrapMethods属性"></a>2.7.11 BootstrapMethods属性</h5><p><code>BootstrapMethods</code>属性用于保存<code>invokedynamic</code>指令引用的引导方法限定符。</p><h5 id="2-7-12-MethodParameters属性"><a href="#2-7-12-MethodParameters属性" class="headerlink" title="2.7.12 MethodParameters属性"></a>2.7.12 MethodParameters属性</h5><p><code>MethodParameters</code>的作用是记录方法的各个形参名称和信息。</p><h5 id="2-7-13-模块化相关属性"><a href="#2-7-13-模块化相关属性" class="headerlink" title="2.7.13 模块化相关属性"></a>2.7.13 模块化相关属性</h5><p><code>模块描述文件（module-info.java）</code>最终是要编译成一个独立的Class文件来存储的，所以Class文件格式也扩展了<code>Module</code>、<code>ModulePackages</code>和<code>ModuleMainClass</code>三个属性用于支持Java模块化相关功能。</p><ul><li><code>Module</code>属性除了表示该模块的名称、版本、标志信息以外，还存储了这个模块requires、exports、opens、uses和provides定义的全部内容；</li><li><code>ModulePackages</code>用于描述该模块中所有的包</li><li><code>ModuleMainClass</code>用于确定该模块的<code>主类（Main Class）</code></li></ul><h5 id="2-7-14-运行时注解相关属性"><a href="#2-7-14-运行时注解相关属性" class="headerlink" title="2.7.14 运行时注解相关属性"></a>2.7.14 运行时注解相关属性</h5><p>为了存储源码中注解信息，Class文件同步增加了</p><ul><li><code>RuntimeVisibleAnnotations</code>；</li><li><code>RuntimeInvisibleAnnotations</code>；</li><li><code>RuntimeVisibleParameterAnnotations</code>；</li><li><code>RuntimeInvisibleParameterAnnotations</code></li></ul><p>后来又新增类型注解 （JSR 308）：</p><ul><li><code>RuntimeVisibleTypeAnnotations</code></li><li><code>RuntimeInvisibleTypeAnnotations</code></li></ul><p><code>RuntimeVisibleAnnotations</code>记录了类、字段或方法的声明上记录运行时可见注解，当我们使用<code>反射API</code>来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。</p><h3 id="3-字节码指令简介"><a href="#3-字节码指令简介" class="headerlink" title="3. 字节码指令简介"></a>3. 字节码指令简介</h3><p>Java虚拟机的指令由<u><strong>一个字节长度的</strong>、<strong>代表着某种特定操作含义</strong></u>的数字（称为<code>操作码，Opcode</code>）以及跟随其后的零至多个代表<strong>此操作所需的参数</strong>（称为<code>操作数，Operand</code>）构成。</p><p>如果不考虑异常处理的话，那Java虚拟机的解释器可以使用下面这段伪代码作为最基本的执行模型来理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    自动计算PC寄存器的值加<span class="number">1</span>;</span><br><span class="line">    根据PC寄存器指示的位置，从字节码流中取出操作码;</span><br><span class="line">    <span class="keyword">if</span> (字节码存在操作数) 从字节码流中取出操作数;</span><br><span class="line">    执行操作码所定义的操作;</span><br><span class="line">&#125; <span class="keyword">while</span> (字节码流长度 &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="3-1-字节码与数据类型"><a href="#3-1-字节码与数据类型" class="headerlink" title="3.1 字节码与数据类型"></a>3.1 字节码与数据类型</h4><p>Java虚拟机的指令集中，<strong>大多数指令都包含其操作所对应的数据类型信息</strong>。</p><blockquote><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：<code>i</code>代表对<code>int</code>类型的数据操作，<code>l</code>代表<code>long</code>，<code>s</code>代表<code>short</code>，<code>b</code>代表<code>byte</code>，<code>c</code>代表<code>char</code>，<code>f</code>代表<code>float</code>，<code>d</code>代表<code>double</code>，<code>a</code>代表<code>reference</code>。</p></blockquote><p>Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，即指令集将会被故意设计成非完全独立的。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</p><h4 id="3-2-加载和存储指令"><a href="#3-2-加载和存储指令" class="headerlink" title="3.2 加载和存储指令"></a>3.2 加载和存储指令</h4><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输：</p><ul><li>将一个局部变量加载到操作栈：<code>load</code>、<code>iload_&lt;n&gt;</code>、<code>lload</code>、<code>lload_&lt;n&gt;</code>、<code>fload</code>、<code>fload_&lt;n&gt;</code>、<code>dload</code>、<code>dload_&lt;n&gt;</code>、<code>aload</code>、<code>aload_&lt;n&gt;</code>；</li><li>将一个数值从操作数栈存储到局部变量表：<code>istore</code>、<code>istore_&lt;n&gt;</code>、<code>lstore</code>、<code>lstore_&lt;n&gt;</code>、<code>fstore</code>、<code>fstore_&lt;n&gt;</code>、<code>dstore</code>、<code>dstore_&lt;n&gt;</code>、<code>astore</code>、<code>astore_&lt;n&gt;</code>；</li><li>将一个常量加载到操作数栈：<code>bipush</code>、<code>sipush</code>、<code>ldc</code>、<code>ldc_w</code>、<code>ldc2_w</code>、<code>aconst_null</code>、<code>iconst_m1</code>、<code>iconst_&lt;i&gt;</code>、<code>lconst_&lt;l&gt;</code>、<code>fconst_&lt;f&gt;</code>、<code>dconst_&lt;d&gt;</code></li><li>扩充局部变量表的访问索引的指令：<code>wide</code></li></ul><p>是以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>）指令助记符实际上代表了一组指令，某个带有一个操作数的通用指令（例如<code>iload</code>）的特殊形式。省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中。</p><h4 id="3-3-运算指令"><a href="#3-3-运算指令" class="headerlink" title="3.3 运算指令"></a>3.3 运算指令</h4><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶：</p><ul><li>对整型数据进行运算的指令</li><li>对浮点型数据进行运算的指令</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ArithmeticInstructions.PNG" alt="算术指令"></p><h4 id="3-4-类型转换指令"><a href="#3-4-类型转换指令" class="headerlink" title="3.4 类型转换指令"></a>3.4 类型转换指令</h4><p>类型转换指令可以<strong><u>将两种不同的数值类型相互转换</u></strong>，这些转换操作一般用于：</p><ul><li>实现用户代码中的显式类型转换操作；</li><li>处理字节码指令集中数据类型相关指令无法与数据类型 一一对应的问题。</li></ul><p>Java虚拟机<strong><u>直接支持（即转换时无须显式的转换指令）</u></strong>以下数值类型的<code>宽化类型转换（Widening Numeric Conversion）</code>：</p><ul><li>int类型到long、float或者double类型</li><li>long类型到float、double类型</li><li>float类型到double类型</li></ul><p>处理<code>窄化类型转换（Narrowing Numeric Conversion）</code>时，就必须显式地使用转换指令来完成，这些转换指令包括<code>i2b</code>、<code>i2c</code>、<code>i2s</code>、<code>l2i</code>、<code>f2i</code>、<code>f2l</code>、<code>d2i</code>、<code>d2l</code>和<code>d2f</code>。</p><h4 id="3-5-对象创建与访问指令"><a href="#3-5-对象创建与访问指令" class="headerlink" title="3.5 对象创建与访问指令"></a>3.5 对象创建与访问指令</h4><p>对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ObjectInstructions.PNG" alt="对象创建与访问指令"></p><h4 id="3-6-操作数栈管理指令"><a href="#3-6-操作数栈管理指令" class="headerlink" title="3.6 操作数栈管理指令"></a>3.6 操作数栈管理指令</h4><p>Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p><ul><li>将操作数栈的栈顶一个或两个元素出栈：<code>pop</code>、<code>pop2</code></li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：<code>dup</code>、<code>dup2</code>、<code>dup_x1</code>、<code>dup2_x1</code>、<code>dup_x2</code>、<code>dup2_x2</code></li><li>将栈最顶端的两个数值互换：<code>swap</code></li></ul><h4 id="4-7-控制转移指令"><a href="#4-7-控制转移指令" class="headerlink" title="4.7 控制转移指令"></a>4.7 控制转移指令</h4><p>控制转移指令可以让Java虚拟机<strong><u>有条件</u></strong>或<strong><u>无条件</u></strong>地从指定位置指令（而不是控制转移指令）的下 一条指令继续执行程序。控制转移指令包括：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ControlTransferInstruction.PNG" alt="控制转移指令"></p><h4 id="4-8-方法调用和返回指令"><a href="#4-8-方法调用和返回指令" class="headerlink" title="4.8 方法调用和返回指令"></a>4.8 方法调用和返回指令</h4><p>方法调用（分派、执行过程）的指令：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/MethodCallAndReturnInstructions.PNG" alt="方法调用和返回指令"></p><h4 id="4-9-异常处理指令"><a href="#4-9-异常处理指令" class="headerlink" title="4.9 异常处理指令"></a>4.9 异常处理指令</h4><p>而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用<code>jsr</code>和 <code>ret</code>指令来实现，现在已经不用了），而是<strong><u>采用异常表来完成</u></strong>。</p><h4 id="4-10-同步指令"><a href="#4-10-同步指令" class="headerlink" title="4.10 同步指令"></a>4.10 同步指令</h4><p>支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用<code>管程</code>（<code>Monitor</code>，更常见的是直接将它称为<code>“锁”</code>）来实现的。</p><ul><li>方法级的同步是<strong>隐式的</strong>，<u>无须通过字节码指令来控制</u>，它实现在方法调用和返回操作之中。调用指令将会检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成时释放管程。</li><li>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持synchronized关键字的语义</li></ul><h3 id="5-公有设计，私有实现"><a href="#5-公有设计，私有实现" class="headerlink" title="5. 公有设计，私有实现"></a>5. 公有设计，私有实现</h3><p>任何一款Java虚拟机实现都必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。在此前提下，虚拟机实现者可以使用让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--5 调优案例分析与实战</title>
    <link href="https://wuyunjie.top/2021/05/26/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_5_Tuning_case_study_and_practice.html"/>
    <id>https://wuyunjie.top/2021/05/26/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_5_Tuning_case_study_and_practice.html</id>
    <published>2021-05-26T11:55:06.000Z</published>
    <updated>2021-05-26T11:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code><br><a id="more"></a></p></blockquote><h3 id="1-案例分析"><a href="#1-案例分析" class="headerlink" title="1. 案例分析"></a>1. 案例分析</h3><p>如何在不改变已有软硬件版本和规格的前提下，调整部署和配置策略去解决或者缓解问题。</p><h4 id="1-1-大内存硬件上的程序部署策略"><a href="#1-1-大内存硬件上的程序部署策略" class="headerlink" title="1.1 大内存硬件上的程序部署策略"></a>1.1 大内存硬件上的程序部署策略</h4><p>案例描述：</p><blockquote><p>升级网址服务器硬件后，<code>HotSpot</code>虚拟机是以服务端模式运行，默认使用的是吞吐量优先收集器，回收<code>12GB</code>的<code>Java</code>堆，一次<code>Full GC</code>的停顿时间就高达14秒。过大的堆内存进行回收时带来的长时间的停顿，将Java堆分配的内存重新缩小到<code>1.5GB</code>或者<code>2GB</code>，这样的确可以避免长时间停顿，但是在硬件上的投资就显得非常浪费。</p></blockquote><p>解决方式：</p><p>目前单体应用在较大内存的硬件上主要部署方式为：</p><blockquote><ol><li>通过一个<u>单独的Java虚拟机</u>实例来管理大量的Java堆内存。<ul><li>这种部署方式必须把应用的<code>Full GC</code>频率控制得足够低，至少要低到不会在用户使用过程中发生。这样可以通过在深夜执行<code>定时任务的方式触发Full GC</code>甚至是<code>自动重启应用服务器</code>来保持内存可用空间在一个稳定的水平。</li></ul></li><li>同时使用若干个Java虚拟机，建立<u>逻辑集群</u>来利用硬件资源。<ul><li>做法是在一台物理机器上启动多个应用服务器进程，为每个服务器进程分配不同端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。</li></ul></li></ol></blockquote><p>最后的部署方案是调整为建立<code>5</code>个<code>32</code>位<code>JDK</code>的逻辑集群，每个进程按<code>2GB</code>内存计算（其中堆固定为<code>1.5GB</code>），占用了 <code>10GB</code>内存。另外建立一个<code>Apache</code>服务作为前端均衡代理作为访问门户。</p><h4 id="1-2-集群间同步导致的内存溢出"><a href="#1-2-集群间同步导致的内存溢出" class="headerlink" title="1.2 集群间同步导致的内存溢出"></a>1.2 集群间同步导致的内存溢出</h4><p>案例描述：</p><blockquote><p>构成一个亲合式集群，使用<code>JBossCache</code>构建了一个全局缓存来解决数据库中<u>读写频繁、竞争激烈</u>对性能影响较大的问题，全局缓存启用后，服务正常使用了一段较长的时间，最近不定期出现多次的内存溢出问题。</p></blockquote><p>解决方式：</p><blockquote><ul><li><p><code>JBossCache</code>是基于自家的<code>JGroups</code>进行集群间的数据通信，<code>JGroups</code>使用协议栈的方式来实现收发数据包的各种所需特性自由组合，数据包接收和发送时要经过每层协议栈的<code>up()</code>和<code>down()</code>方法，其中的<code>NAKACK</code>栈用于<u>保障各个包的有效顺序以及重发</u>。</p></li><li><p>也有<code>MIS</code>系统实现方式上的缺陷。网络情况不能满足传输要求时，重发数据在内存中不断堆积，很快就产生了内存溢出。</p></li></ul></blockquote><h4 id="1-3-堆外内存导致的溢出错误"><a href="#1-3-堆外内存导致的溢出错误" class="headerlink" title="1.3 堆外内存导致的溢出错误"></a>1.3 堆外内存导致的溢出错误</h4><p>案例描述：</p><blockquote><p>基于<code>B/S</code>的电子考试系统服务端不定时抛出内存溢出异常。尝试过把堆内存调到最大，<code>32</code>位系统最多到 <code>1.6GB</code>基本无法再加大了，而且开大了基本没效果，抛出内存溢出异常好像还更加频繁。</p></blockquote><p>解决方式：</p><blockquote><p><code>Direct Memory</code>耗用的内存并不算入这<code>1.6GB</code>的堆之内，因此它最大也只能在剩余的<code>0.4GB</code>空间中再分出一部分而已。在此应用中导致溢出的关键是</p><ul><li><u>垃圾收集进行时，虚拟机虽然会对直接内存进行回收，但是直接内存只能等待老年代满后<code>Full GC</code>出现后，“顺便”帮它清理掉内存的废弃对象</u>。</li><li>否则需要等到抛出内存溢出异常时捕获到异常，再在Catch块里面通过<code>System.gc()</code>来触发垃圾收集。</li></ul></blockquote><p>下面这些区域还会占用较多的内存，内存总和受到操作系统进程最大内存的限制：</p><ul><li>直接内存：可通<code>过-XX：MaxDirectMemorySize</code>调整大小；</li><li>线程堆栈：可通过<code>-Xss</code>调整大小，内存不足时抛出<code>StackOverflowError</code>或者<code>OutOfMemoryError</code>；</li><li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，如果无法分配，可能会抛出<code>IOException：Too many open files</code>异常。</li><li>JNI代码：如果代码中使用了JNI调用本地库，占用的是Java虚拟机的本地方法栈和本地内存的。</li></ul><h4 id="1-4-外部命令导致系统缓慢"><a href="#1-4-外部命令导致系统缓慢" class="headerlink" title="1.4 外部命令导致系统缓慢"></a>1.4 外部命令导致系统缓慢</h4><p>案例描述：</p><blockquote><p>一个数字校园应用系统，发现请求响应时间比较慢，通过操作系统的<code>mpstat</code>工具发现处理器使用率很高，但是<u>系统中占用绝大多数处理器资源的程序并不是该应用本身</u>。通过<code>dtrace</code>脚本发现最消耗处理器资源的竟然是<code>“fork”</code>系统调用，<code>“fork”</code>系统调用是Linux用来产生新进程的，在Java虚拟机中，用户编写的Java代码通常最多只会创建新的线程，不应当有进程的产生。</p></blockquote><p>解决方式：</p><blockquote><p>每个用户请求的处理都需要执行一个外部<code>Shell</code>脚本来获得系统的一些信息。执行这个Shell脚本是通过Java的<code>Runtime.getRuntime().exec()</code>方法来调用的。即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也会非常可观。</p><p>去掉这个Shell脚本执行的语句，改为使用Java的<code>API</code>去获取这些信息后，系统很快恢复了正常。</p></blockquote><h4 id="1-5-服务器虚拟机进程崩溃"><a href="#1-5-服务器虚拟机进程崩溃" class="headerlink" title="1.5 服务器虚拟机进程崩溃"></a>1.5 服务器虚拟机进程崩溃</h4><p>案例描述：</p><blockquote><p>一个基于B/S的MIS系统，正常运行一段时间后，最近发现在运行期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下了一个<code>hs_err_pid###.log</code>文件后，虚拟机进程就消失了。</p></blockquote><p>解决方式：</p><blockquote><p>由于MIS系统的用户多，待办事项变化很快，为了不被<code>OA系统</code>速度拖累，使用了<strong>异步的方式</strong>调用 Web服务，但由于两边服务速度的完全不对等，时间越长就累积了越多Web服务没有调用完成，导致在等待的线程和Socket连接越来越多，最终超过虚拟机的承受能力后导致虚拟机进程崩溃。</p><p>修复<code>OA门户</code>无法使用的集成接口，并将异步调用改为<u>生产者/消费者模式</u>的消息队列实现后，系统恢复正常。</p></blockquote><h4 id="1-6-不恰当数据结构导致内存占用过大"><a href="#1-6-不恰当数据结构导致内存占用过大" class="headerlink" title="1.6 不恰当数据结构导致内存占用过大"></a>1.6 不恰当数据结构导致内存占用过大</h4><p>案例描述：</p><blockquote><p>一个后台<code>RPC</code>服务器，业务上需要每 10分钟加载一个约<code>80MB</code>的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个<code>HashMap&lt;Long，Long&gt;Entry</code>，在这段时间里面<code>Minor GC</code>就会造成超过<code>500毫秒</code>的停顿，对于这种长度的停顿时间就接受不了了。</p></blockquote><p>解决方式：</p><blockquote><ul><li>如果不修改程序，仅从GC调优的角度去解决这个问题，可以考虑直接将Survivor空间去掉，让新生代中存活的对象在第一次<code>Minor GC</code>后立即进入老年代，等到<code>Major GC</code>的时候再去清理它们。</li><li>这里产生问题的根本原因是用<code>HashMap&lt;Long, Long&gt;</code>结构来存储数据文件空间效率太低了，只有<code>Key</code>和<code>Value</code>所存放的两个长整型数据是有效数据，空间效率为有效数据除以全部内存空间，即16字节/88字节=18%。</li></ul></blockquote><h4 id="1-7-由Windows虚拟内存导致的长时间停顿"><a href="#1-7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="1.7 由Windows虚拟内存导致的长时间停顿"></a>1.7 由Windows虚拟内存导致的长时间停顿</h4><p>案例描述：</p><blockquote><p>一个带<code>心跳检测功能</code>的GUI桌面程序，每15秒会发送一次心跳检测信号，如果对方30秒以内都没有信号返回，那就认为和对方程序的连接已经断开。程序上线后发现心跳检测有误报的可能，原因是程序会偶尔出现间隔约一分钟的时间完全无日志输出，处于停顿状态。</p></blockquote><p>解决方式：</p><blockquote><ul><li>程序在最小化时它的工作内存被自动交换到磁盘的页面文件之中了，这样发生垃圾收集时就有可能因为恢复页面文件的操作导致不正常的垃圾收集停顿。在Java的GUI程序中要避免这种现象，可以加入参数“<code>-Dsun.awt.keepWorkingSetOnMinimize=true</code>”来解决。</li></ul></blockquote><h4 id="1-8-由安全点导致长时间停顿"><a href="#1-8-由安全点导致长时间停顿" class="headerlink" title="1.8 由安全点导致长时间停顿"></a>1.8 由安全点导致长时间停顿</h4><p>案例描述：</p><blockquote><p>一个比较大的承担公共计算任务的离线HBase集群，因为集群读写压力较大，而离线分析任务对延迟又不会特别敏感，所以将<code>-XX:MaxGCPauseMillis</code>参数设置到了<em>500毫秒</em>。不过运行一段时间后发现垃圾收集的停顿经常达到<em>3秒</em>以 上，而且实际垃圾收集器进行回收的动作就只占其中的几百毫秒。</p></blockquote><p>解决方式：</p><blockquote><ul><li>日志显示当前虚拟机的操作（VM Operation，VMOP）是等待所有用户线程进入到安全点，但是有两个线程特别慢，导致发生了很长时间的<code>自旋等待</code>。</li><li>使用int类型或范围更小 的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为<code>可数循环（Counted Loop）</code>，相对应地，使用long或者范围更大的数据类型作为索引值的循环就被称为<code>不可数循环（Uncounted Loop）</code>，将会被放置安全点。把循环索引的数据类型从int改为long即可。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-13-调整数组顺序使奇数位于偶数前面</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ13_the_odd_numbers_come_before_the_even_numbers.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ13_the_odd_numbers_come_before_the_even_numbers.html</id>
    <published>2021-05-26T05:51:46.000Z</published>
    <updated>2021-05-26T05:51:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。<br><a id="more"></a></p><p><strong>示例1</strong></p><blockquote><p>输入：[1,2,3,4]<br>返回值：[1,3,2,4]</p></blockquote><p><strong>示例2</strong></p><blockquote><p>输入：[2,4,6,5,7]<br>返回值：[5,7,2,4,6]</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-12-数值的整数次方</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ12_Integer_power.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ12_Integer_power.html</id>
    <published>2021-05-26T05:21:51.000Z</published>
    <updated>2021-05-26T05:21:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>给定一个<code>double</code>类型的浮点数<code>base</code>和<code>int</code>类型的整数<code>exponent</code>。求<code>base</code>的<code>exponent</code>次方。</p><p>保证<code>base</code>和<code>exponent</code>不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面<code>0</code>的位数。<br><a id="more"></a></p><p><strong>示例1</strong></p><blockquote><p>输入：2.00000, 3<br>返回值：8.00000</p></blockquote><p><strong>示例2</strong></p><blockquote><p>输入：2.10000, 3<br>返回值：9.26100</p></blockquote><p><strong>示例3</strong></p><blockquote><p>输入：2.00000,-2<br>返回值：0.25000</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>根据题意，不需要考虑大数情况，并且<code>exponent</code>是整数，那么直接的方法就是先对<code>exponent</code>的正负判断：</p><ul><li>若为正整数，直接循环<code>exponent</code>次乘法求出结果</li><li>若为负整数，循环<code>-exponent</code>次乘法求出结果，然后对结果求倒数</li></ul><h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>假设我们求$x^{8}$，如果我们知道$x^{4}$，那么$x^{8} = (x^{4})^{2}$，$x^{n} = (x^{\frac{n}{2}})^{2}$。但是还有个小问题，如果n是偶数，那么上述没问题。如果$n$是奇数，$x^{n} = (x^{\frac{n}{2}})^{2}<em>x$，比如$x^{7} = (x^{3})^{2} </em> x$。</p><h4 id="非递归的快速幂"><a href="#非递归的快速幂" class="headerlink" title="非递归的快速幂"></a>非递归的快速幂</h4><p>假设求$x^{6}$,已知<code>6</code>可以表示成二进制<code>110</code><br>可以表示成$6 = 0<em>2^{0} + 1 </em> 2^{1} + 1 <em> 2^{2}$, 所以$x^{6}$可以表示成$x^{6} = x^ {0</em>2^{0} + 1<em>2^{1} + 1</em>2^{2}} = x^{0} <em> x^{1</em>2^{1}}<em>x^{1</em>2^{2}}$所以，对于二进制数，遇到位数是<code>1</code>的就乘到答案中。</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-直接法"><a href="#1-直接法" class="headerlink" title="1. 直接法"></a>1. 直接法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exponent; i++)</span><br><span class="line">                result *= base;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; -exponent; i++)</span><br><span class="line">                result *= base;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/result;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-快速幂-递归法"><a href="#2-快速幂-递归法" class="headerlink" title="2. 快速幂(递归法)"></a>2. 快速幂(递归法)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickPower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> res = quickPower(base, exponent/<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res * res * base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res * res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quickPower(base, exponent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-快速幂-非递归法"><a href="#3-快速幂-非递归法" class="headerlink" title="3. 快速幂(非递归法)"></a>3. 快速幂(非递归法)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> x = base;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (exponent != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res *= x; <span class="comment">// 二进制位数是1的，乘进答案。</span></span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            exponent &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;给定一个&lt;code&gt;double&lt;/code&gt;类型的浮点数&lt;code&gt;base&lt;/code&gt;和&lt;code&gt;int&lt;/code&gt;类型的整数&lt;code&gt;exponent&lt;/code&gt;。求&lt;code&gt;base&lt;/code&gt;的&lt;code&gt;exponent&lt;/code&gt;次方。&lt;/p&gt;
&lt;p&gt;保证&lt;code&gt;base&lt;/code&gt;和&lt;code&gt;exponent&lt;/code&gt;不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面&lt;code&gt;0&lt;/code&gt;的位数。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-11-二进制中1的个数</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ11_Number_of_1s_in_binary.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ11_Number_of_1s_in_binary.html</id>
    <published>2021-05-26T05:01:12.000Z</published>
    <updated>2021-05-26T05:01:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>输入一个整数，输出该数<code>32</code>位二进制表示中<code>1</code>的个数。其中负数用补码表示。<br><a id="more"></a></p><p><strong>示例1</strong></p><blockquote><p>输入：10<br>返回值：2</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><h4 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1. 位运算"></a>1. 位运算</h4><p>考查的应该就是位操作吧。实际上要统计<code>1</code>的个数很简单，只需要将整数逐位右移，统计最低位<code>1</code>的出现次数。判断最低为是否为<code>1</code>可以使用等式：<code>n &amp; 1</code>，结果为<code>1</code>即为<code>1</code>，否则为<code>0</code>。</p><p>这里有一个需要注意的点是，由于整数是补码表示，所以在右移的时候，若数字为负数会将高位自动补<code>1</code>。这里刚好之前学到<code>Java</code>里有一个无符号右移的运算符: <code>&gt;&gt;&gt;</code>，可以直接解决这个问题。</p><ul><li><a href="https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html">[Java学习|Head_First_Java]—十大遗珠之憾</a></li></ul><h4 id="2-技巧法"><a href="#2-技巧法" class="headerlink" title="2. 技巧法"></a>2. 技巧法</h4><p>考虑二进制数：<code>val :1101000</code>, <code>val-1: 1100111</code> 那么<code>val &amp; （val-1） : 1100000</code>。即：</p><blockquote><p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p></blockquote><p>把一个整数减去<code>1</code>，再和原整数做与运算，会把该整数最右边一个<code>1</code>变成<code>0</code>.那么一个整数的二进制有多少个<code>1</code>，就可以进行多少次这样的操作。</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-位运算-1"><a href="#1-位运算-1" class="headerlink" title="1. 位运算"></a>1. 位运算</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfOnes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            numOfOnes += (n &amp; <span class="number">1</span>);</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numOfOnes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-技巧法："><a href="#2-技巧法：" class="headerlink" title="2. 技巧法："></a>2. 技巧法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfOnes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            numOfOnes++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numOfOnes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;输入一个整数，输出该数&lt;code&gt;32&lt;/code&gt;位二进制表示中&lt;code&gt;1&lt;/code&gt;的个数。其中负数用补码表示。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-10-矩形覆盖</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ10_Rectangular_coverage.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ10_Rectangular_coverage.html</id>
    <published>2021-05-26T04:33:52.000Z</published>
    <updated>2021-05-26T04:33:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用<code>n</code>个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，从同一个方向看总共有多少种不同的方法？<br><a id="more"></a></p><p>比如<code>n=3</code>时，<code>2*3</code>的矩形块有<code>3</code>种不同的覆盖方法(从同一个方向看)：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ10/JZ10.png" alt="矩形覆盖"></p><p><strong>示例1</strong></p><blockquote><p>输入：0<br>返回值：0</p></blockquote><p><strong>示例2</strong></p><blockquote><p>输入：1<br>返回值：1</p></blockquote><p><strong>示例3</strong></p><blockquote><p>输入：4<br>返回值：5</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>实际上还是一个类似于斐波那契数列的问题(连续好几个题了)，初始化两个基本的组合，<code>1</code>个<code>2*1</code>的小矩形只有<code>1</code>种组合方式，<code>2</code>个这样的矩阵有两种组合方式，然后是这两个基本组合之上的不断叠加的组合方法。所以可以写为：</p><script type="math/tex; mode=display">F(1)=1\\F(2)=2\\F(n) = F(n-1) + F(n-2) (n \geq 3, n \in N^*)</script><p>剩下的就是利用之前的递归法，迭代法来实现该算法。</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1. 递归法"></a>1. 递归法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;=<span class="number">2</span>) <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rectCover(target-<span class="number">1</span>) + rectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-迭代法"><a href="#2-迭代法" class="headerlink" title="2. 迭代法"></a>2. 迭代法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;=<span class="number">2</span>) <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum = sum + one;</span><br><span class="line">            one = sum - one;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;我们可以用&lt;code&gt;2*1&lt;/code&gt;的小矩形横着或者竖着去覆盖更大的矩形。请问用&lt;code&gt;n&lt;/code&gt;个&lt;code&gt;2*1&lt;/code&gt;的小矩形无重叠地覆盖一个&lt;code&gt;2*n&lt;/code&gt;的大矩形，从同一个方向看总共有多少种不同的方法？&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-9-跳台阶扩展问题</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ9_Jumping_expanding.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ9_Jumping_expanding.html</id>
    <published>2021-05-26T02:32:29.000Z</published>
    <updated>2021-05-26T02:32:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><a id="more"></a></p><blockquote><p>输入：3<br>返回值：4</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><h4 id="1-迭代递归法"><a href="#1-迭代递归法" class="headerlink" title="1. 迭代递归法"></a>1. 迭代递归法</h4><p>还是可以转换为递归的形式，只是这里递归的计算需要改进为遍历所有小于等于n的台阶数：</p><script type="math/tex; mode=display">F(0)=1\\F(1)=1\\F(n) = F(n-1) + F(n-2) + \cdots + F(n-n) (n \geq 2, n \in N^*)</script><p>那么将最后的递归改进为一个循环，就可以继续利用递归算法来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">sum += jumpFloorII(target-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-等式推导"><a href="#2-等式推导" class="headerlink" title="2. 等式推导"></a>2. 等式推导</h4><p>可以将该等式化简成一个简单的形式：</p><script type="math/tex; mode=display">F(n) = F(n-1) + F(n-2) + \cdots + F(n-n) (n \geq 2, n \in N^*)</script><p>那么可以继续得到$F(n-1)$的计算等式：</p><script type="math/tex; mode=display">F(n-1) = F(n-2) + F(n-3) + \cdots + F(n-n) (n \geq 3, n \in N^*)</script><p>可以把上述两式合并得到：</p><script type="math/tex; mode=display">F(n) = F(n-1) \times 2</script><p>利用改等式，可以写出递归，迭代的算法。进一步优化可以将其简化为：</p><script type="math/tex; mode=display">F(n) = 2^{(n-1)}</script><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-递归方法"><a href="#1-递归方法" class="headerlink" title="1. 递归方法"></a>1. 递归方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum += jumpFloorII(target-i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-迭代方法"><a href="#2-迭代方法" class="headerlink" title="2. 迭代方法"></a>2. 迭代方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i ; j++)&#123;</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-等式推导-递归"><a href="#3-等式推导-递归" class="headerlink" title="3. 等式推导(递归)"></a>3. 等式推导(递归)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> jumpFloorII(target-<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-等式推导-迭代法"><a href="#4-等式推导-迭代法" class="headerlink" title="4. 等式推导(迭代法)"></a>4. 等式推导(迭代法)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-等式推导-最简化形式"><a href="#5-等式推导-最简化形式" class="headerlink" title="5. 等式推导(最简化形式)"></a>5. 等式推导(最简化形式)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-8-跳台阶</title>
    <link href="https://wuyunjie.top/2021/05/26/JZ8_Step_up.html"/>
    <id>https://wuyunjie.top/2021/05/26/JZ8_Step_up.html</id>
    <published>2021-05-26T02:02:02.000Z</published>
    <updated>2021-05-26T02:02:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><a id="more"></a></p><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>转换一下思路，其实就是在一颗树上不断搜索，其实可以很容易转化位斐波那契数列的形式，依靠递归算法求解：</p><script type="math/tex; mode=display">F(1)=1\\F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)</script><p>那么进一步就可以利用斐波那契数列的优化方法，对该算法从时间复杂度和空间复杂度的角度，不断优化。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ8/JZ8.png" alt="递归树结构"></p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-递归方法"><a href="#1-递归方法" class="headerlink" title="1. 递归方法"></a>1. 递归方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> jumpFloor(target-<span class="number">1</span>) + jumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-迭代方法"><a href="#2-迭代方法" class="headerlink" title="2. 迭代方法"></a>2. 迭代方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum = sum + one;</span><br><span class="line">            one = sum - one;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-7-斐波那契数列</title>
    <link href="https://wuyunjie.top/2021/05/25/JZ7_Fibonacci_sequence.html"/>
    <id>https://wuyunjie.top/2021/05/25/JZ7_Fibonacci_sequence.html</id>
    <published>2021-05-25T09:28:54.000Z</published>
    <updated>2021-05-25T09:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。（<code>n≤39</code>）<br><a id="more"></a></p><p><strong>示例:</strong></p><blockquote><p>输入:  4<br>返回值: 3</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>斐波那契数列的标准公式为：</p><script type="math/tex; mode=display">F(1)=1\\F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)</script><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h4><p>可以发现很符合递归的定义，所以递归是一种直接的思路。但递归法的时间复杂度过高($O(2^n)$)。</p><h4 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h4><ul><li><p>另一种方法是直接利用循环，将$F(n), F(n-1), F(n-2)$保存在三个临时变量内，不断迭代计算出最终值。时间复杂度位($O(n)$)。</p></li><li><p>继续对空间进行优化，因为$F(n)$只在计算第$n$项的时候使用，所以可以只存储$F(n)$和$F(n-2)$，$F(n-1)$可以由$F(n)-F(n-2)$计算得到</p></li></ul><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1. 递归法"></a>1. 递归法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-迭代法"><a href="#2-迭代法" class="headerlink" title="2. 迭代法"></a>2. 迭代法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            FibArray_n = FibArray_n_1 + FibArray_n_2;</span><br><span class="line">            FibArray_n_2 = FibArray_n_1;</span><br><span class="line">            FibArray_n_1 = FibArray_n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FibArray_n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-优化的迭代法-只使用两个变量"><a href="#3-优化的迭代法-只使用两个变量" class="headerlink" title="3. 优化的迭代法(只使用两个变量)"></a>3. 优化的迭代法(只使用两个变量)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            FibArray_n = FibArray_n + FibArray_n_1;</span><br><span class="line">            FibArray_n_1 = FibArray_n - FibArray_n_1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FibArray_n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。（&lt;code&gt;n≤39&lt;/code&gt;）&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-6-旋转数组的最小数字</title>
    <link href="https://wuyunjie.top/2021/05/24/JZ6_rotate_the_smallest_number_of_the_array.html"/>
    <id>https://wuyunjie.top/2021/05/24/JZ6_rotate_the_smallest_number_of_the_array.html</id>
    <published>2021-05-24T12:25:51.000Z</published>
    <updated>2021-05-24T12:25:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br><strong>NOTE</strong>：给出的所有元素都大于0，若数组大小为0，请返回0。<br><a id="more"></a></p><p><strong>示例:</strong></p><blockquote><p>输入:   [3,4,5,1,2]<br>返回值: 1</p></blockquote><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题应该是类似于查找的问题，其中数组为非递减序列是一个很关键的信息。</p><h4 id="1-暴力方法"><a href="#1-暴力方法" class="headerlink" title="1. 暴力方法"></a>1. 暴力方法</h4><p>对于查找类型的问题，都存在暴力方法，即将整个数组都遍历一遍，总会找到最小值。</p><h4 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h4><p>可以发现，选择数组中要找到的最小元素，即为分界线处的元素。即需要通过二分查找的方法，找到数组中的分界线。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ6/JZ61.png" alt="旋转数组"></p><p>在分界线左边的元素一定是要比分界线右边元素大的。所以可以基于二分查找方法，设定<code>low</code>和<code>high</code>的位置，然后判断<code>mid</code>位置是在数组的<code>左半部分</code>还是<code>右半部分</code>，逐渐缩小范围找到最小值。</p><ul><li>处于左半部分，<code>low</code>移到<code>mid</code>处</li><li>处于右半部分，<code>high</code>移到<code>mid</code>处</li><li>其他情况<code>low++</code></li></ul><p>但后来检测发现一个<code>bug</code>，遇到<code>[1, 0, 1, 1, 1]</code>这样的情况会出错：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ6/JZ62.png" alt="错过了最小值`0`"></p><p>为了解决该问题，只需要在提前检查数列，如果是非递减数列，返回最低位<code>low</code>的值。</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">1</span>) <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[low] &lt; array[high])</span><br><span class="line">                <span class="keyword">return</span> array[low];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((mid + <span class="number">1</span>) &lt; array.length &amp;&amp; array[mid] &gt; array[mid + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> array[mid + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>((mid - <span class="number">1</span>) &gt; -<span class="number">1</span> &amp;&amp; array[mid] &lt; array[mid - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> array[mid];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[low])</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; array[high])</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更简单的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rotateArray.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = rotateArray.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="comment">// 子数组是非递减的数组，10111</span></span><br><span class="line">        <span class="keyword">if</span> (rotateArray[low] &lt; rotateArray[high]) </span><br><span class="line">            <span class="keyword">return</span> rotateArray[low];</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[low])</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[high])</span><br><span class="line">            high = mid; <span class="comment">// 如果是mid-1，则可能会错过最小值，因为找的就是最小值</span></span><br><span class="line">        <span class="keyword">else</span> low++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rotateArray[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://blog.nowcoder.net/n/dcb0f2e6ffd44e1895b7a5297e362778" target="_blank" rel="noopener">【剑指offer T11】旋转数组的最小数字</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。&lt;br&gt;输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。&lt;br&gt;&lt;strong&gt;NOTE&lt;/strong&gt;：给出的所有元素都大于0，若数组大小为0，请返回0。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-5-用两个栈实现队列</title>
    <link href="https://wuyunjie.top/2021/05/24/JZ5_implement_the_queue_with_two_stacks.html"/>
    <id>https://wuyunjie.top/2021/05/24/JZ5_implement_the_queue_with_two_stacks.html</id>
    <published>2021-05-24T11:43:12.000Z</published>
    <updated>2021-05-24T11:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><a id="more"></a></p><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>队列的特性是先进先出(<code>FIFO</code>)，栈的特点是先进后出(<code>FILO</code>)。很容易想到一个直观的方法：</p><ol><li>将队列数据先存入一个栈；</li><li>当需要<code>pop</code>出队列的元素时，将该栈元素逐个弹出存入另一个栈，然后弹出栈顶。</li></ol><p>但这样会有冗余操作，比如连续的<code>push</code>和连续的<code>pop</code>可以只在其中一个栈中操作，所以可以优化为：</p><ol><li>需要插入时，直接<code>push</code>到<code>stack1</code>；</li><li>需要弹出时，若<code>stack2</code>不为空，弹出<code>stack2</code>的栈顶元素；若<code>stack2</code>为空，将 <code>stack1</code> 中的全部数逐个出栈入栈 <code>stack2</code>，再弹出 <code>stack2</code> 栈顶元素</li></ol><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题描述&quot;&gt;&lt;a href=&quot;#一、问题描述&quot; class=&quot;headerlink&quot; title=&quot;一、问题描述&quot;&gt;&lt;/a&gt;一、问题描述&lt;/h3&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://wuyunjie.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://wuyunjie.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="刷题记录" scheme="https://wuyunjie.top/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--4 虚拟机性能监控、故障处理工具</title>
    <link href="https://wuyunjie.top/2021/05/20/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_4_Performance_monitoring_fault_handling.html"/>
    <id>https://wuyunjie.top/2021/05/20/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_4_Performance_monitoring_fault_handling.html</id>
    <published>2021-05-20T14:41:12.000Z</published>
    <updated>2021-05-26T11:54:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code><br><a id="more"></a></p></blockquote><h3 id="1-基础故障处理工具"><a href="#1-基础故障处理工具" class="headerlink" title="1. 基础故障处理工具"></a>1. 基础故障处理工具</h3><p>除了编译和运行Java程序外，打包、部署、签名、调试、监控、运维等各种场景都可能会用到<code>JDK</code>的<code>bin</code>目录下的小工具。根据软件可用性和授权的不同，可以把它们划分成三类：</p><ul><li><strong>商业授权工具</strong>：主要是<code>JMC（Java Mission Control）</code>及它要使用到的<code>JFR（Java Flight Recorder）</code>；</li><li><strong>正式支持工具</strong>：这一类工具属于被长期支持的工具，不同平台、不同版本的<code>JDK</code>之间，这类工具可能会略有差异；</li><li><strong>实验性工具</strong>：这一类工具在它们的使用说明中被声明为“<code>没有技术支持，并且是实验性质的</code>”（<code>Unsupported and Experimental</code>）产品。</li></ul><h4 id="1-1-jps：虚拟机进程状况工具"><a href="#1-1-jps：虚拟机进程状况工具" class="headerlink" title="1.1 jps：虚拟机进程状况工具"></a>1.1 <code>jps</code>：虚拟机进程状况工具</h4><p><code>jps（JVM Process Status Tool）</code>功能和<code>UNIX</code>的<code>ps</code>命令类似：</p><blockquote><p>可以列出<code>正在运行</code>的虚拟机进程，并显示虚拟机<u><strong>执行主类（Main Class，main()函数所在的类）</strong></u>名称以及这些进程的<code>本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）</code>。</p></blockquote><p><code>jps</code>命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/jps.PNG" alt="jps参数"></p><h4 id="1-2-jstat：虚拟机统计信息监视工具"><a href="#1-2-jstat：虚拟机统计信息监视工具" class="headerlink" title="1.2 jstat：虚拟机统计信息监视工具"></a>1.2 <code>jstat</code>：虚拟机统计信息监视工具</h4><p><code>jstat（JVM Statistics Monitoring Tool）</code>是用于监视虚拟机各种运行状态信息的命令行工具。</p><blockquote><p>可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据</p></blockquote><h4 id="1-3-jinfo：Java配置信息工具"><a href="#1-3-jinfo：Java配置信息工具" class="headerlink" title="1.3 jinfo：Java配置信息工具"></a>1.3 <code>jinfo</code>：Java配置信息工具</h4><p><code>jinfo（Configuration Info for Java）</code>的作用是实时查看和调整虚拟机各项参数。</p><blockquote><p>使用<code>jps</code>命令的<code>-v</code>参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用<code>jinfo</code>的<code>-flag</code>选项进行查询了</p></blockquote><h4 id="1-4-jmap：Java内存映像工具"><a href="#1-4-jmap：Java内存映像工具" class="headerlink" title="1.4 jmap：Java内存映像工具"></a>1.4 <code>jmap</code>：Java内存映像工具</h4><p><code>jmap（Memory Map for Java）</code>命令用于生成<strong>堆转储快照</strong>（一般称为<code>heapdump</code>或<code>dump</code>文件）。</p><blockquote><p>还可以查询<u><code>finalize</code>执行队列</u>、<u>Java堆</u>和<u>方法区的详细信息</u>，如空间使用率、当前用的是哪种收集器等。</p></blockquote><h4 id="1-5-jhat：虚拟机堆转储快照分析工具"><a href="#1-5-jhat：虚拟机堆转储快照分析工具" class="headerlink" title="1.5 jhat：虚拟机堆转储快照分析工具"></a>1.5 <code>jhat</code>：虚拟机堆转储快照分析工具</h4><p><code>jhat（JVM Heap Analysis Tool）</code>命令与<code>jmap</code>搭配使用，来分析<code>jmap</code>生成的堆转储快照。</p><h4 id="1-6-jstack：Java堆栈跟踪工具"><a href="#1-6-jstack：Java堆栈跟踪工具" class="headerlink" title="1.6 jstack：Java堆栈跟踪工具"></a>1.6 <code>jstack</code>：Java堆栈跟踪工具</h4><p><code>jstack（Stack Trace for Java）</code>命令用于生成虚拟机当前时刻的线程快照（一般称为<code>threaddump</code>或者<code>javacore</code>文件）。</p><blockquote><p>线程快照就是当前虚拟机内每一条线程正在执行的<strong>方法堆栈</strong>的集合，生成线程快照的目的通常是<u>定位线程出现长时间停顿的原因</u>，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。</p></blockquote><h4 id="1-7-基础工具总结"><a href="#1-7-基础工具总结" class="headerlink" title="1.7 基础工具总结"></a>1.7 基础工具总结</h4><ul><li><strong>基础工具</strong>：用于支持基本的程序创建和运行</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/basicJavaTools.PNG" alt="基础工具"></p><ul><li><strong>安全</strong>：用于程序签名、设置安全测试等</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/securityJavaTools.PNG" alt="安全工具"></p><p>还有许多工具，就不一一列举了，需要的时候在查找学习就行。</p><h3 id="2-可视化故障处理工具"><a href="#2-可视化故障处理工具" class="headerlink" title="2. 可视化故障处理工具"></a>2. 可视化故障处理工具</h3><p>这类工具主要包括<code>JConsole</code>、 <code>JHSDB</code>、<code>VisualVM</code>和<code>JMC</code>四个。</p><h4 id="2-1-JHSDB：基于服务性代理的调试工具"><a href="#2-1-JHSDB：基于服务性代理的调试工具" class="headerlink" title="2.1  JHSDB：基于服务性代理的调试工具"></a>2.1  <code>JHSDB</code>：基于服务性代理的调试工具</h4><p><code>JHSDB</code>是一款基于<code>服务性代理（Serviceability Agent，SA）</code>实现的进程外调试工具。服务性代理是<code>HotSpot</code>虚拟机中一组用于映射<code>Java</code>虚拟机运行信息的、主要基于<code>Java</code>语言（含少量<code>JNI</code>代码）实现的<code>API</code>集合。</p><p>通过服务性代理的<code>API</code>，可以在一个独立的Java虚拟机的进程里分析其他<code>HotSpot</code>虚拟机的内部数据，或者从<code>HotSpot</code>虚拟机进程内存中<code>dump</code>出来的转储快照里还原出它的运行状态细节。</p><h4 id="2-2-JConsole：Java监视与管理控制台"><a href="#2-2-JConsole：Java监视与管理控制台" class="headerlink" title="2.2 JConsole：Java监视与管理控制台"></a>2.2 <code>JConsole</code>：Java监视与管理控制台</h4><p><code>JConsole（Java Monitoring and Management Console）</code>是一款基于<code>JMX（Java Manage-ment Extensions）</code>的可视化监视、管理工具。它的主要功能是通过<code>JMX</code>的<code>MBean（Managed Bean）</code>对系统进行信息收集和参数动态调整。</p><h4 id="2-3-VisualVM：多合-故障处理工具"><a href="#2-3-VisualVM：多合-故障处理工具" class="headerlink" title="2.3 VisualVM：多合-故障处理工具"></a>2.3 <code>VisualVM</code>：多合-故障处理工具</h4><p><code>VisualVM（All-in-One Java Troubleshooting Tool）</code>是功能最强大的运行监视和故障处理程序之一，除了常规的运行监视、故障处理外，还将提供其他方面的能力，譬如<code>性能分析（Profiling）</code>。</p><p><code>VisualVM</code>还有一个很大的<strong>优点</strong>：<u><strong>不需要被监视的程序基于特殊<code>Agent</code>去运行</strong></u>，因此它的通用性很强，对应用程序实际性能的影响也较小，使得它可以直接应用在生产环境中。</p><h4 id="2-4-Java-Mission-Control：可持续在线的监控工具"><a href="#2-4-Java-Mission-Control：可持续在线的监控工具" class="headerlink" title="2.4 Java Mission Control：可持续在线的监控工具"></a>2.4 <code>Java Mission Control</code>：可持续在线的监控工具</h4><p><code>JMC</code>最初是<code>BEA</code>公司的产品，选择了由<code>IBM</code>捐赠的<code>Eclipse RCP</code>作为基础框架，更常见的是作为Eclipse的插件来使用。</p><p><code>JMC</code>与虚拟机之间同样采取<code>JMX</code>协议进行通信，<code>JMC</code>一方面作为<code>JMX</code>控制台，显示来自虚拟机<code>MBean</code>提供的数据；另一方面作为<code>JFR</code>的分析工具，展示来自<code>JFR</code>的数据。</p><h3 id="3-HotSpot虚拟机插件及工具"><a href="#3-HotSpot虚拟机插件及工具" class="headerlink" title="3. HotSpot虚拟机插件及工具"></a>3. <code>HotSpot</code>虚拟机插件及工具</h3><p><code>HotSpot</code>的插件及工具存放在HotSpot源码<code>hotspot/src/share/tools</code>目录下，包括：</p><ul><li><code>Ideal Graph Visualizer</code>：用于可视化展示<code>C2</code>即时编译器是如何将字节码转化为理想图，然后转化为机器码的。</li><li><code>Client Compiler Visualizer</code>：用于查看<code>C1</code>即时编译器生成高级中间表示（<code>HIR</code>），转换成低级中间表示（<code>LIR</code>）和做物理寄存器分配的过程。</li><li><code>MakeDeps</code>：帮助处理<code>HotSpot</code>的编译依赖的工具。</li><li><code>Project Creator</code>：帮忙生成<code>Visual Studio</code>的<code>.project</code>文件的工具。</li><li><code>LogCompilation</code>：将<code>-XX：+LogCompilation</code>输出的日志整理成更容易阅读的格式的工具。</li><li><code>HSDIS</code>：即时编译器的反汇编插件。</li></ul><p><strong><code>HSDIS</code>：<code>JIT</code>生成代码反汇编</strong></p><p><code>HSDIS</code>是一个被官方推荐的<code>HotSpot</code>虚拟机即时编译代码的反汇编插件。<code>HSDIS</code>插件的作用是让<code>HotSpot</code>的<code>-XX：+PrintAssembly</code>指令调用它来把即时编译器动态生成的本地代码还原为<u>汇编代码</u>输出，同时还会自动产生大量非常有价值的注释，这样我们就可以通过输出的汇编代码来从最本质的角度分析问题。</p><p><code>JITWatch</code>是<code>HSDIS</code>经常搭配使用的可视化的编译日志分析工具，在<code>JITWatch</code>中加载日志后，就可以看到执行期间使用过的各种对象类型和对应调用过的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--十大遗珠之憾</title>
    <link href="https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html"/>
    <id>https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html</id>
    <published>2021-05-20T05:13:54.000Z</published>
    <updated>2021-05-20T05:13:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>什么！有完没完啊？这本书到底还要看多久？<br><a id="more"></a></p></blockquote><h3 id="1-枚举-又称为枚举类型或Enum"><a href="#1-枚举-又称为枚举类型或Enum" class="headerlink" title="1. 枚举(又称为枚举类型或Enum)"></a>1. 枚举(又称为枚举类型或<code>Enum</code>)</h3><p>枚举类型定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Members &#123; JERRY, BOBBY, PHIL &#125;;</span><br><span class="line"><span class="keyword">public</span> Members selectedBandMember;</span><br><span class="line"></span><br><span class="line"><span class="comment">// later in the code</span></span><br><span class="line"><span class="keyword">if</span> (selectedBandMember == Members.JERRY) &#123;</span><br><span class="line"><span class="comment">// do JERRY related stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在<code>enum</code>中加入构造函数、方法、变量和特定常量的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HfjEnum</span> </span>&#123;</span><br><span class="line"><span class="keyword">enum</span> Names &#123;</span><br><span class="line">        <span class="comment">// 传给下方定义构造函数的参数</span></span><br><span class="line">JERRY(“lead guitar”) &#123; <span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “plaintively”; &#125;&#125;,</span><br><span class="line">BOBBY(“rhythm guitar”) &#123; <span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “hoarsely”; &#125;&#125;,</span><br><span class="line">PHIL(“bass”);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String instrument;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// enum的构造函数，会对每个被声明的enum值执行一次</span></span><br><span class="line">        Names(String instrument) &#123;</span><br><span class="line">            <span class="keyword">this</span>.instrument = instrument;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInstrument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.instrument;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> “occasionally”;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Names n : Names.values()) &#123;</span><br><span class="line">            System.out.print(n);</span><br><span class="line">            System.out.print(“, instrument: “+ n.getInstrument());</span><br><span class="line">            System.out.println(“, sings: “ + n.sings());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-多维数组"><a href="#2-多维数组" class="headerlink" title="2. 多维数组"></a>2. 多维数组</h3><p>Java中，二维数组实际上是一个<strong><code>数组的数组</code></strong>。</p><h3 id="3-String-and-StringBuffer-StringBuilder-Methods"><a href="#3-String-and-StringBuffer-StringBuilder-Methods" class="headerlink" title="3. String and StringBuffer/StringBuilder Methods"></a>3. <code>String</code> and <code>StringBuffer/StringBuilder</code> Methods</h3><p><code>Java 5.0</code>起，应该用<code>StringBuilder</code>取代<code>StringBuffer</code>。<code>StringBuffer/StringBuilder</code> 来操作字符串更有效率。</p><h3 id="4-存取权限和存取修饰符"><a href="#4-存取权限和存取修饰符" class="headerlink" title="4. 存取权限和存取修饰符"></a>4. 存取权限和存取修饰符</h3><p><code>Java</code>有4种存取权限等级与3种存取修饰符。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/AccessLevelsModifiers.PNG" alt="存取权限和存取修饰符"></p><h3 id="5-Anonymous和Static-Nested-Classes"><a href="#5-Anonymous和Static-Nested-Classes" class="headerlink" title="5. Anonymous和Static Nested Classes"></a>5. <code>Anonymous</code>和<code>Static Nested Classes</code></h3><p><code>静态嵌套类</code>可以不需要外部类的实例就调用，但还是被看作外部类的一个成员，能够存取任何外部类的静态成员(包括私有)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooOuter</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarInner</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“method of a <span class="keyword">static</span> inner <span class="class"><span class="keyword">class</span>”)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FooOuter.BarInner foo = <span class="keyword">new</span> FooOuter.BarInner();</span><br><span class="line">        foo.sayIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>匿名的内部类</code>，是在需要传入一个实例的地方创建一个类，并把整个类作为参数传进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnon</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line">JButton button = <span class="keyword">new</span> JButton(“click”);</span><br><span class="line">frame.getContentPane().add(button);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// button.addActionListener(quitListener);</span></span><br><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent ev)</span> </span>&#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-连接的调用"><a href="#6-连接的调用" class="headerlink" title="6. 连接的调用"></a>6. 连接的调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"spring"</span>);</span><br><span class="line">sb = sb.delete(<span class="number">3</span>,<span class="number">6</span>).insert(<span class="number">2</span>,<span class="string">"umme"</span>).deleteCharAt(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>第二行程序从左到右执行。如下调用方法可以调用方法又不需要维护一个引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo().go();</span><br></pre></td></tr></table></figure><h3 id="7-块区域"><a href="#7-块区域" class="headerlink" title="7. 块区域"></a>7. 块区域</h3><p>区段程序代码通常在方法中，以<code>{}</code>字符来区分。在某个块区域中声明的变量，一旦离开块区域，就超出范围，无法再被使用。</p><h3 id="8-断言"><a href="#8-断言" class="headerlink" title="8. 断言"></a>8. 断言</h3><p>断言的使用类似<code>println()</code>，执行时未特别设定，被加入到程序中的<code>assert</code>命令会被Java虚拟机忽略。只有打开断言，才会输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> (height &gt; <span class="number">0</span>); </span><br><span class="line"><span class="comment">// if true, program continues normally</span></span><br><span class="line"><span class="comment">// if false, throw an AssertionError</span></span><br></pre></td></tr></table></figure><p>也可以加入信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> (height &gt; <span class="number">0</span>) : <span class="string">"height = "</span> + height + <span class="string">" weight = "</span> + weight;</span><br></pre></td></tr></table></figure><h3 id="9-不变性"><a href="#9-不变性" class="headerlink" title="9. 不变性"></a>9. 不变性</h3><p><code>String</code>的不变性，主要为了安全性和节省空间。比如下面的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = “<span class="number">0</span>”;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">     s = s + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上创建了<code>10</code>个<code>String</code>对象(“0”, “01”, …, “0123456789”)。创建新<code>String</code>时，<code>JVM</code>会把它放在<code>&quot;String Pool&quot;</code>的特殊存储区域，如果已经出现同值的<code>String</code>，JVM不会重复建立<code>String</code>，会引用已经存在的内容。因为<code>String</code>是不变的，引用变量无法改变其他参数变量引用到的同一个<code>String</code>值。</p><p><code>包装类</code>也具有不变性。</p><h3 id="10-位操作"><a href="#10-位操作" class="headerlink" title="10. 位操作"></a>10. 位操作</h3><ul><li>按位非运算：<code>~</code></li><li>按位与运算：<code>&amp;</code></li><li>按位或运算：<code>|</code></li><li>按位异或运算：<code>^</code></li><li>右移运算：<code>&gt;&gt;</code></li><li>无符号右移：<code>&gt;&gt;&gt;</code>。第一位补<code>0</code>，正负号可能改变。</li><li>左移运算符：<code>&lt;&lt;</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;什么！有完没完啊？这本书到底还要看多久？&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--18 远程部署的RMI</title>
    <link href="https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_18_remote%20deployment_with_RMI.html"/>
    <id>https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_18_remote deployment_with_RMI.html</id>
    <published>2021-05-20T02:44:05.000Z</published>
    <updated>2021-05-20T02:44:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>分布式计算，距离不是问题。<br><a id="more"></a></p></blockquote><h3 id="1-远程过程调用的设计"><a href="#1-远程过程调用的设计" class="headerlink" title="1. 远程过程调用的设计"></a>1. 远程过程调用的设计</h3><p>远程过程调用(<code>Remote Method Invocation, RMI</code>)要建出4种东西：<code>服务器</code>、<code>客户端</code>、<code>服务器辅助设施</code>和<code>客户端辅助设施</code>。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/remoteMethod.PNG" alt="远程过程调用的设计"></p><h4 id="1-1-辅助设施的任务"><a href="#1-1-辅助设施的任务" class="headerlink" title="1.1 辅助设施的任务"></a>1.1 <code>辅助设施</code>的任务</h4><p>辅助设施是个在实际上执行通信的对象，会让客户端对象看起来在调用远程的方法。辅助设施会去连接服务器，将调用的信息传送过去，然后等待服务器的响应。</p><p>服务器的辅助设施会接受客户端辅助设施打包的信息，调用真正的服务，然后取得返回值送回客户端辅助设施。</p><h4 id="1-2-创建远程服务"><a href="#1-2-创建远程服务" class="headerlink" title="1.2 创建远程服务"></a>1.2 创建远程服务</h4><p>创建远程服务有5个步骤：</p><ol><li><p>创建<code>Remote</code>接口。远程接口定义了客户端可以远程调用的方法，是一个作为服务的多态化类。stub和服务都会实现此接口。</p><ul><li><p>继承<code>java.rmi.Remote</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRemote</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明所有方法都会抛出<code>RemoteException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRemote</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确定参数和返回值都是<code>primitive主数据类型</code>或<code>Serializable</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol><li><p>实现<code>Remote</code>。真正执行的类，实现定义在该接口上的方法。</p><ul><li><p>实现<code>Remote</code>接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRemoteImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">MyRemote</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “Server says, ‘Hey’”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// more code in class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>继承<code>UnicastRemoteObject</code>。对象必须要有远程相关功能，最简单的方式就是继承<code>UnicastRemoteObject</code>类来处理。</p></li><li><p>编写声明<code>RemoteException</code>的无参数构造函数；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyRemoteImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>向<code>RMI registry</code> 注册服务。将服务初始化并加入<code>RMI registry</code> ，<code>RMI</code>系统会把<code>stub</code>加到<code>registry</code>中。使用<code>java.rmi.Naming</code>的<code>rebind</code>方法来注册服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    MyRemote service = <span class="keyword">new</span> MyRemoteImpl();</span><br><span class="line">    <span class="comment">// 帮助服务命名，并向RMI registry注册</span></span><br><span class="line">    Naming.rebind(“Remote Hello”, service);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>用<code>rmic</code>产生<code>stub</code>与<code>skeleton</code>。由<code>JDK</code>附带的<code>rmic</code>工具自动处理。</p><ul><li><p>对实现出的类执行<code>rmic</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmic MyRemoteImpl</span><br></pre></td></tr></table></figure><p><code>Java software development kit(JDK)</code>中的<code>rmic</code>工具会以服务的实现产生连个新类：<code>stub</code>和<code>skeleton</code>。</p></li></ul></li></ol><ol><li><p>启动<code>RMI registry</code> (<code>rmiregistry</code>)。用户从此处获取代理。</p><ul><li><p>在命令行启动<code>rmiregistry</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmiregistry</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol><li><p>启动远程服务。实现服务的类会启动服务的实例并向<code>RMI registry</code> 注册，要有注册才能对用户提供服务。</p><ul><li><p>启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java MyRemoteImpl</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="1-3-客户端获取stub"><a href="#1-3-客户端获取stub" class="headerlink" title="1.3 客户端获取stub"></a>1.3 客户端获取<code>stub</code></h4><p>客户端需要获取<code>stub</code>对象，这需要<code>RMI registry</code>，客户端从上面查询得到有相符名称的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyRemote service = (MyRemote) Naming.lookup(<span class="string">"rmi://127.0.0.1/Remote Hello"</span>);</span><br></pre></td></tr></table></figure><ul><li><p>客户端查询<code>RMI registry</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Naming.lookup(<span class="string">"rmi://127.0.0.1/Remote Hello"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>RMI registry</code>返回<code>stub</code>对象，<code>RMI</code>会自动将<code>stub</code>解序列化。</p></li><li><p>客户端可以调用<code>stub</code>上的方法</p></li></ul><h3 id="2-Servlets"><a href="#2-Servlets" class="headerlink" title="2. Servlets"></a>2. Servlets</h3><p><code>Servlets</code>是放在<code>Http Web</code>服务上面运行的Java程序，用户通过浏览器与网页交互时，如果请求需要Java的<code>Servlets</code>时，服务器会执行或调用已经执行的<code>Servlets</code>程序代码。</p><blockquote><p><code>Servlets</code>只运行在服务器上。</p></blockquote><ul><li>用户在网页上填写表格并提交，<code>HTTP</code>服务器受到请求，判断需要<code>Servlets</code>就传送该请求</li><li><code>Servlets</code>开始执行，把数据存入数据库，然后返回内容给浏览器。</li></ul><p>创建并执行<code>Servlets</code>的步骤：</p><ol><li><p>找出可以存放<code>Servlets</code>的地方</p></li><li><p>取得<code>Servlets.jar</code>并添加到<code>classpath</code>上。<code>Servlets</code>不是标准库的一部分，需要单独下载。</p></li><li><p>通过继承<code>HttpServlet</code>来编写<code>Servlet</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletA</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>编写<code>HTML</code>来调用<code>Servlet</code></p></li><li><p>给服务器设定HTML网页和<code>Servlet</code></p></li></ol><h3 id="3-Enterprise-JavaBeans"><a href="#3-Enterprise-JavaBeans" class="headerlink" title="3. Enterprise JavaBeans"></a>3. Enterprise JavaBeans</h3><p><code>Enterprise JavaBeans(EJB)</code>服务器作用与<code>RMI</code>调用和服务层之间，支持交易管理、安全性、并发性、数据库和网络功能等。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/EJB.PNG" alt="EJB架构的一部分"></p><h3 id="4-Jini"><a href="#4-Jini" class="headerlink" title="4. Jini"></a>4. Jini</h3><p><code>Jini</code>也是使用<code>RMI</code>，但有几个关键功能：</p><ol><li>自适应探索(<code>Adaptive discovery</code>)</li><li>自恢复网络(<code>Self-healing networks</code>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;分布式计算，距离不是问题。&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--17 包、jar存档文件和部署</title>
    <link href="https://wuyunjie.top/2021/05/19/JavaLearning_Head_First_Java_17_package_jars_and_deployment.html"/>
    <id>https://wuyunjie.top/2021/05/19/JavaLearning_Head_First_Java_17_package_jars_and_deployment.html</id>
    <published>2021-05-19T15:21:49.000Z</published>
    <updated>2021-05-19T15:21:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>该放手了。<br><a id="more"></a></p></blockquote><h3 id="1-部署应用程序"><a href="#1-部署应用程序" class="headerlink" title="1. 部署应用程序"></a>1. 部署应用程序</h3><p>可以有多种部署选择：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/DeploymentOptions.PNG" alt="部署选择"></p><p>首先需要将源代码与<code>class</code>文件分离，关键在于结合<code>-d</code>这个编译选项和目录组织的结构。</p><blockquote><p>将源代码(<code>.java</code>)存储在<code>source</code>目录下，将编译输出的类文件(<code>.class</code>)放入<code>classes</code>目录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/<span class="built_in">source</span></span><br><span class="line">javac -d ../classes MyApp.java</span><br></pre></td></tr></table></figure><h4 id="1-1-把程序打包为JAR"><a href="#1-1-把程序打包为JAR" class="headerlink" title="1.1 把程序打包为JAR"></a>1.1 把程序打包为JAR</h4><p><code>JAR</code>即<code>Java ARchive</code>，这种文件是<code>pkzip</code>格式的文件，能把一组类文件包装起来。创建可执行的<code>JAR</code>分为以下步骤：</p><ol><li><p>确定所有的类文件都在<code>classes</code>目录下；</p></li><li><p>创建<code>manifest.txt</code>文件描述哪个类带有<code>main()</code>方法，该文件带有下面一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Main-Class: MyApp</span><br></pre></td></tr></table></figure><p>此行后面要有换行，该文件放入<code>classes</code>目录</p></li><li><p>执行<code>jar</code>工具来创建带有<strong>所有类</strong>以及<code>manifest</code>的<code>JAR</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/classes </span><br><span class="line">jar -cvmf manifest.txt app1.jar *.class</span><br><span class="line">OR</span><br><span class="line">jar -cvmf manifest.txt app1.jar MyApp.class</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/makingJAR.PNG" alt="创建JAR"></p><p><code>JVM</code>能从<code>JAR</code>中载入类，并调用该类的<code>main()</code>方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar app1.jar</span><br></pre></td></tr></table></figure><p>可以用包防止类名称的冲突。<code>Sun</code>建议加上所取得的域名(<code>domain</code>)名称来保证包名称不会重复。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/domainPackageNames.PNG" alt="使用域名的包名称"></p><p>需要把类放在与包层次结构相对应的目录结构下：</p><ol><li><p>选择包名称。</p></li><li><p>在类中加入包指令。这必须是程序源码的第一个语句，在<code>import</code>之上。每个源文件中只能有一个包指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.headfirstjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageExercise</span> </span>&#123;</span><br><span class="line">     <span class="comment">// life-altering code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设定相对应的目录结构。按照包层次结构来放置类文件</p></li></ol><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/packageHierarchy.PNG" alt="包层次结构"></p><ol><li><p>编译和执行<code>JAR</code></p><ul><li><p>加上<code>-d</code>选项来编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">%编译器把输出放到class目录下正确的位置</span><br><span class="line">javac -d ../classes com/headfirstjava/PackageExercise.java</span><br><span class="line"></span><br><span class="line">%编译com.headfirstjava包下所有.java文件</span><br><span class="line">javac -d ../classes com/headfirstjava/*.java</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/classes</span><br><span class="line">java com.headfirstjava.PackageExercise</span><br></pre></td></tr></table></figure><p>一旦类被包进包中后，就不能使用“简写”名称来调用它，必须在命令栏指定要执行<code>main()</code>的类完整名称。</p></li></ul><p>还可以条列和解压<code>JAR</code>包：</p><ul><li><p>将<code>JAR</code>内容列出，<code>-tf</code>代表<code>Table File</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -tf packEx.jar</span><br></pre></td></tr></table></figure></li><li><p>解压<code>JAR</code>内容，<code>-xf</code>代表<code>eXtract File</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Skyler</span><br><span class="line">jar -xf packEx.jar</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-Java-Web-Start"><a href="#1-2-Java-Web-Start" class="headerlink" title="1.2 Java Web Start"></a>1.2 Java Web Start</h4><p><code>Java Web Start(JWS)</code>可以让用户从浏览器上执行首次启动，一旦程序下载后就可以独立于浏览器执行。</p><ul><li><code>JWS</code>下载程序时会调用程序的<code>main()</code>，然后用户可以通过<code>JWS helper app</code>启动应用程序而无需回到网页</li><li><code>JWS</code>能偶检测服务器上应用程序局部更新，自动下载和整合更新过的程序</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JWS.PNG" alt="Java Web Start工作方式"></p><p><code>.jnlp</code>(<code>Java  Network Launch Protocol</code>)文件用于创建JWS应用程序，<code>JWS</code>会读取文件来寻找<code>JAR</code>并启动应用程序，<code>.jnlp</code>是个简单的<code>XML</code>文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;该放手了。&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--16 集合与泛型</title>
    <link href="https://wuyunjie.top/2021/05/19/JavaLearning_Head_First_Java_16_collections_and_generics.html"/>
    <id>https://wuyunjie.top/2021/05/19/JavaLearning_Head_First_Java_16_collections_and_generics.html</id>
    <published>2021-05-19T04:55:36.000Z</published>
    <updated>2021-05-19T04:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>排序在Java中只是雕虫小技。<br><a id="more"></a></p></blockquote><h3 id="1-集合"><a href="#1-集合" class="headerlink" title="1. 集合"></a>1. 集合</h3><p><code>ArrayList</code>是最常用的集合，此外还有一些较为重要的集合：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/collector.PNG" alt="一些集合类"></p><p>可以使用<code>TreeSet</code>或<code>Collections.sort()</code>方法对集合元素排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(songList);</span><br></pre></td></tr></table></figure><p>若将<code>ArrayList</code>声明为自定义类(如<code>Song</code>)的数组，使用<code>Collections.sort()</code>将无法通过编译。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/sortMethod.PNG" alt="sort方法定义"></p><blockquote><p><code>sort()</code>方法取只能接受<code>Comparable</code>对象的<code>list</code>。</p></blockquote><h4 id="1-1-Collections接口"><a href="#1-1-Collections接口" class="headerlink" title="1.1 Collections接口"></a>1.1 Collections接口</h4><p><code>Collections</code>主要有<code>3</code>个接口：<code>List</code>，<code>Set</code>和<code>Map</code>。</p><ul><li><code>List</code>是一种知道索引位置的集合，可以存在重复元素。</li><li><code>Set</code>知道某物是否存在于集合中，它不允许重复。</li><li><code>Map</code>使用成对的键值(<code>key</code>)和数据值(<code>value</code>)，<code>key</code>可以引用相同的对象，但<code>key</code>自身不能重复。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/collectorTree.PNG" alt="Collection API"></p><h4 id="1-2-对象等价"><a href="#1-2-对象等价" class="headerlink" title="1.2 对象等价"></a>1.2 对象等价</h4><ul><li><code>引用相等性</code>。堆上同一对象的两个引用，引用对堆上同一个对象的两个引用时相等的。如果这两个引用调用<code>hashCode</code>，会得到相同的结果。使用<code>==</code>来比较变量上的子节组合，判断引用是否相等。</li><li><code>对象相等性</code>。堆上的两个不同对象在意义上是相同的，要把两个不同的对象视为相等，需要覆盖<code>hashCode</code>方法与<code>equals</code>方法。</li></ul><blockquote><p>要让<code>set</code>把对象视为重复的，必须满足<code>equals</code>和<code>hashCode</code>返回两对象相等。</p></blockquote><p><code>equals</code>和<code>hashCode</code>的相关规定：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/hashCodeEquals.PNG" alt="`equals`和`hashCode`"></p><h4 id="1-3-TreeSet"><a href="#1-3-TreeSet" class="headerlink" title="1.3 TreeSet"></a>1.3 TreeSet</h4><p>使用<code>TreeSet</code>必须使得以下一项为真：</p><ul><li><p>集合中的元素必须是有实现<code>Comparable</code>的类型；</p></li><li><p>使用重载、取用<code>Comparator</code>参数的构造函数创建<code>TreeSet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BookCompare bCompare = <span class="keyword">new</span> BookCompare();</span><br><span class="line">TreeSet&lt;Book&gt; tree = <span class="keyword">new</span> TreeSet&lt;Book&gt;(bCompare);</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-4-Map"><a href="#1-4-Map" class="headerlink" title="1.4 Map"></a>1.4 Map</h4><p><code>Map</code>的元素实际上是两个对象：关键词(key)和值(value)。值可以重复，但key不能重复。通过<code>Map</code>可以用名称来取值等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; scores = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">scores.put(“Kathy”, <span class="number">42</span>);</span><br><span class="line">scores.put(“Bert”, <span class="number">343</span>);</span><br><span class="line">scores.put(“Skyler”, <span class="number">420</span>);</span><br></pre></td></tr></table></figure><h3 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2. 泛型"></a>2. 泛型</h3><p><code>&lt;&gt;</code>符号代表<code>泛型(generic)</code>正在起作用，它是从<code>Java 5.0</code>开始加入的特质。泛型的主要目的是能够获取有<u>更好的类型安全性的集合</u>。</p><blockquote><p>在泛型出现前，没有办法什么<code>ArrayList</code>的类型，所以只能用<code>Object</code>来操作。各种对象以引用的形式加入到<code>ArrayList</code>中，出来时会是<code>Object</code>类型的引用。</p></blockquote><p>使用泛型后，能定义<code>ArrayList</code>类型，在取出时还是该类型的引用。此外也不能在该<code>ArrayList</code>中加入非该类的对象。关于泛型几件重要的事：</p><ol><li><p>创建被泛型化类的实例。比如创建<code>ArrayList</code>时必须指定它所容许的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ArrayList&lt;Song&gt;()</span><br></pre></td></tr></table></figure></li><li><p>声明与指定泛型类型的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Song&gt; songList = <span class="keyword">new</span> ArrayList&lt;Song&gt;()</span><br></pre></td></tr></table></figure></li><li><p>声明(与调用)取用泛型类型的方法。</p></li></ol><h4 id="2-1-泛型的类"><a href="#2-1-泛型的类" class="headerlink" title="2.1 泛型的类"></a>2.1 泛型的类</h4><p>查看泛型化类型，有两个关键的部分：</p><ol><li>类的声明。</li><li>新增元素的方法的声明。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; ... </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>E</code>部分会用所声明和创建的真正类型来取代，<code>E</code>代指<code>Element</code>。在新增元素的方法中，也用<code>E</code>指示可以加入<code>ArrayList</code>的元素类型。</li><li>这里<code>E</code>并不是关键词，硬性规定的。也可以用其他合法字符串来当作类型参数。习惯用法是以单一字母表示。</li></ul></blockquote><h4 id="2-2-泛型的方法"><a href="#2-2-泛型的方法" class="headerlink" title="2.2 泛型的方法"></a>2.2 泛型的方法</h4><p>泛型的类代表类的声明用到类型参数。泛型的方法代表方法的声明特征用到类型参数。</p><ol><li><p>使用定义在类声明的类型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; ... </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>声明类的类型参数后，就可以直接把该类或接口类型用在任何地方。</p></li><li><p>使用未定义在类声明的类型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure><p>如果类本身未使用类型参数，可以通过在返回类型之前指定给该方法。<code>&lt;T extends Animal&gt;</code>意味着<code>T</code>可以是任意一种<code>Animal</code>。</p></li></ol><p>这里需要注意的是，以下两种方法的声明合法，但意义不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;Animal&gt; list)</span></span></span><br></pre></td></tr></table></figure><p><code>&lt;T extends Animal&gt;</code>是方法声明的一部分，表示任何被声明未<code>Animal</code>或<code>Animal</code>的子类型的<code>ArrayList</code>是合法的。可以使用<strong>任意一种</strong><code>Animal</code>的<code>ArrayList</code>。</p><p>但下面的方法中<code>ArrayList&lt;Animal&gt; list</code>代表只有<code>ArrayList&lt;Animal&gt;</code>是合法的，也就是它<strong>只能使用</strong><code>Animal</code>的<code>ArrayList</code>。</p><h4 id="2-3-sort-方法中的泛型"><a href="#2-3-sort-方法中的泛型" class="headerlink" title="2.3 sort()方法中的泛型"></a>2.3 <code>sort()</code>方法中的泛型</h4><p>回到<code>sort()</code>方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure><p>实际上<code>Comparable</code>是一个接口，但以泛型的观点，<code>extends</code>代表<code>extends</code>或<code>implement</code>。所以必须实现<code>Comparable</code>才能把类的<code>ArrayList</code>传给<code>sort</code>。只有一个方法需要实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compareTo</code>方法会判别在排序位置上某个对象是高于、低于或等于另一个对象。<code>sort()</code>有重载方法，可以取用称为<code>Comparator</code>的参数。<code>Comparator</code>是独立的类，因此可以实现不同的比较方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用规则如下：</p><ul><li>调用单一参数的<code>sort(List o)</code>方法代表由<code>List</code>元素上的<code>compareTo</code>方法来决定顺序，需要实现<code>Comparable</code>接口。</li><li>调用<code>sort(List o, Comparator c)</code>方法代表不会调用<code>list</code>元素的<code>compareTo</code>方法，而会使用<code>Comparator</code>的<code>compare</code>方法，这种情况下list元素不需要实现<code>Comparable</code>接口。</li></ul><h4 id="2-4-多态与泛型"><a href="#2-4-多态与泛型" class="headerlink" title="2.4 多态与泛型"></a>2.4 多态与泛型</h4><p>在普通的多态中，定义如下函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(Animal a: animals) &#123;</span><br><span class="line">         a.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法只能取用<code>ArrayList&lt;Animal&gt;</code>参数，而不能传入<code>ArrayList&lt;Dog&gt;</code>或<code>ArrayList&lt;Cat&gt;</code>，以为如果程序执行如下代码时，会出现类型错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">animals.add(<span class="keyword">new</span> Cat());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数换成数组时尽管能通过编译，但在执行时也会出错。</p><blockquote><p>数组的类型在运行期间检查，集合的类型检查只发生在编译期间。</p></blockquote><p>可以使用泛型的<code>万用字符(wildcard)</code>来解决这个问题。创建出可以接受<code>Animal</code>子类型参数的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;? extends Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(Animal a: animals) &#123;</span><br><span class="line">     a.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用带有<code>&lt;?&gt;</code>的声明时，编译器会组织任何可能破坏引用参数所指集合的行为。</p><ul><li>可以调用<code>list</code>中任何元素的方法，但不能加入元素。即可以操作集合元素，但不能新增集合元素，以保证安全性。</li></ul><p>两种不同的语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;? extends Animal&gt; list)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;排序在Java中只是雕虫小技。&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Head_First_Java]--15 网络与线程</title>
    <link href="https://wuyunjie.top/2021/05/18/JavaLearning_Head_First_Java_15_networking_and_threads.html"/>
    <id>https://wuyunjie.top/2021/05/18/JavaLearning_Head_First_Java_15_networking_and_threads.html</id>
    <published>2021-05-18T10:46:26.000Z</published>
    <updated>2021-05-18T10:46:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>连接到外面的世界。<br><a id="more"></a></p></blockquote><h3 id="1-客户端-Client-与服务器-Server"><a href="#1-客户端-Client-与服务器-Server" class="headerlink" title="1. 客户端(Client)与服务器(Server)"></a>1. 客户端(Client)与服务器(Server)</h3><p>客户端必须要认识服务器，服务器必须要认识所有的客户端。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientAndServer.PNG" alt="客户端与服务器"></p><p>工作方式如下：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientAndServerWorks.PNG" alt="客户端与服务器工作方式"></p><p>连接、传送与接受：</p><p>客户端要连接服务器需要做三件事：</p><ol><li>建立客户端与服务器之间的初始连接</li><li>传送信息到服务器</li><li>接受来自服务器的信息</li></ol><p>Java API的网络功能包(<code>java.net</code>)对底层工作细节进行了封装。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientConnectServer.PNG" alt="客户端"></p><h4 id="1-1-Socket连接"><a href="#1-1-Socket连接" class="headerlink" title="1.1 Socket连接"></a>1.1 Socket连接</h4><p>连接到其他机器需要<code>Socket连接</code>，<code>Socket</code>是代表两台机器间网络连接的对象(<code>java.net.Socket</code>)。创建Socket连接需要两项关于<strong>服务器</strong>的信息：<code>IP地址</code>和<code>端口号</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"196.164.1.103"</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>Socket连接的建立代表两台机器间有对方的信息(包括<code>IP地址</code>和<code>端口号</code>)</p><p><code>TCP</code>端口是一个<code>16</code>位宽、用来识别服务器上特定程序的数字。一个地址可以有<code>65536</code>个不同的端口号可用。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/wellKnownTCPPort.PNG" alt="常用的TCP端口号"></p><blockquote><p><code>0~1023</code>的<code>TCP</code>端口号预留给已知特定服务使用，可以从<code>1024~65535</code>中选择端口号用于自定义程序</p></blockquote><p>不同程序不能共享一个端口，使用(也叫绑定)某个已被占用的端口，会受到<code>BindException</code>异常。</p><h4 id="1-2-读取Socket数据"><a href="#1-2-读取Socket数据" class="headerlink" title="1.2 读取Socket数据"></a>1.2 读取Socket数据</h4><p>可以用串流来通过Socket连接沟通，即使用<code>BufferedReader</code>从<code>Socket</code>上读取数据，而不管串流来自文件还是Socket。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 建立对服务器的Socket连接</span></span><br><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立连接到Socket上低层输入串流的InputStreamReader</span></span><br><span class="line">InputStreamReader stream = <span class="keyword">new</span> InputStreamReader(chatSocket.getInputStream());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 建立BufferedReader来读取</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(stream);</span><br><span class="line">String message = reader.readLine();</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/readFromSocket.PNG" alt="读取Socket数据"></p><h4 id="1-3-向Socket写入数据"><a href="#1-3-向Socket写入数据" class="headerlink" title="1.3 向Socket写入数据"></a>1.3 向Socket写入数据</h4><p>利用<code>PrintWriter</code>向Socket写入数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 对服务器建立Socket连接</span></span><br><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立连接到Socket的PrintWriter</span></span><br><span class="line">PrintWriter writer = <span class="keyword">new</span> PrintWriter(chatSocket.getOutputStream());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 写入数据</span></span><br><span class="line">writer.println(<span class="string">"message to send"</span>);</span><br><span class="line">writer.print(<span class="string">"another message"</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/PrintWriterToSocket.PNG" alt="向Socket写入数据"></p><h4 id="1-4-客户端"><a href="#1-4-客户端" class="headerlink" title="1.4 客户端"></a>1.4 客户端</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/client.PNG" alt="客户端"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyAdviceClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket s = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">4242</span>);</span><br><span class="line">            InputStreamReader streamReader = <span class="keyword">new</span> InputStreamReader(s.getInputStream());</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(streamReader);</span><br><span class="line">            String advice = reader.readLine();</span><br><span class="line">            System.out.println(<span class="string">"Today you should: "</span> + advice);</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DailyAdviceClient client = <span class="keyword">new</span> DailyAdviceClient();</span><br><span class="line">        client.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-服务器"><a href="#1-5-服务器" class="headerlink" title="1.5 服务器"></a>1.5 服务器</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/server.PNG" alt="客户端"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyAdviceServer</span> </span>&#123;</span><br><span class="line">    String[] adviceList = &#123;<span class="string">"Take smaller bites"</span>, <span class="string">"Go for the tight jeans. No they do NOT make you look fat."</span>, <span class="string">"One word: inappropriate"</span>, <span class="string">"Just for today, be honest. Tell your boss what you *really* think"</span>, <span class="string">"You might want to rethink that haircut."</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSock = <span class="keyword">new</span> ServerSocket(<span class="number">4242</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket sock = serverSock.accept();</span><br><span class="line"></span><br><span class="line">                PrintWriter writer = <span class="keyword">new</span> PrintWriter(sock.getOutputStream());</span><br><span class="line">                String advice = getAdvice();</span><br><span class="line">                writer.println(advice);</span><br><span class="line">                writer.close();</span><br><span class="line">                System.out.println(advice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// close go</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> random = (<span class="keyword">int</span>) (Math.random() * adviceList.length);</span><br><span class="line">        <span class="keyword">return</span> adviceList[random];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DailyAdviceServer server = <span class="keyword">new</span> DailyAdviceServer();</span><br><span class="line">        server.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>每个线程有独立的<code>执行空间(stack)</code>。Java内置有<code>多线程(Multithreading)</code>功能，但只有一种<code>Thread</code>类。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/javaThread.PNG" alt="Thread类"></p><h4 id="2-1-新建线程"><a href="#2-1-新建线程" class="headerlink" title="2.1 新建线程"></a>2.1 新建线程</h4><p>每个Java应用程序会启动一个主线程，将<code>main()</code>函数放在执行空间最开始处。Java虚拟机负责主线程的启动。自定义建立的线程，需要在程序中启动。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JVMThread.PNG" alt="主线程与自建线程"></p><p>启动新线程主要有以下几个步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 建立Runnable对象(线程的任务)，此类是对线程要执行的任务的定义</span></span><br><span class="line">Runnable threadJob = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立Thread对象(执行工人)并赋值Runnable对象</span></span><br><span class="line"><span class="comment">// 告诉Thread对象把Runnable的run()方法放到执行空间执行</span></span><br><span class="line">Thread myThread = <span class="keyword">new</span> Thread(threadJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 启动线程Thread</span></span><br><span class="line"><span class="comment">// 真正到执行空间执行run()方法</span></span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure><blockquote><p><code>Thread</code>是个工人，<code>Runnable</code>是这个工人的工作。</p></blockquote><p><code>Runnable</code>是一个<strong>接口</strong>，只有<code>run()</code>这一个方法。<code>Runnable</code>带有会放在执行空间的第一项方法：<code>run()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// code that will be run by the new thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-线程的状态"><a href="#2-2-线程的状态" class="headerlink" title="2.2 线程的状态"></a>2.2 线程的状态</h4><p>新建线程的3个状态：</p><ol><li><p>等待启动(新建线程)。Thread实例已经创建，但还未启动。即未处于执行中的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br></pre></td></tr></table></figure></li><li><p>可执行线程。启动线程时，变成可执行状态，已经布置好了执行空间，轮到它就可以执行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.start();</span><br></pre></td></tr></table></figure></li><li><p>执行中线程。线程占用资源开始执行，该过程只能依靠JVM的线程调度机制来决定。</p></li></ol><blockquote><p>一旦线程进入可执行状态，会不断在可执行与执行中两种状态切换。也可有另一种状态：暂时不可执行(<code>阻塞状态</code>)</p></blockquote><ul><li>典型的可执行/执行中循环。即JVM线程调度器会把不断切换线程，给予不同线程执行机会。</li><li>暂时被阻挡。<code>调度器(scheduler)</code>会在特殊情况下把线程阻塞，比如线程执行到等待<code>Socket</code>输入流的程序段，但又无数据可读，调度器会把线程移出可执行状态。或者<code>Sleep()</code>函数、调用某个被<code>锁住(locked)</code>的对象等等。</li></ul><h4 id="2-3-线程调度器"><a href="#2-3-线程调度器" class="headerlink" title="2.3 线程调度器"></a>2.3 线程调度器</h4><p><code>线程调度器(Thread Scheduler)</code>会<u>决定哪个线程从等待状态中被挑出来运行，以及何时把哪个线程送回等待被执行的状态</u>。</p><blockquote><p>调度是无法被控制的</p></blockquote><p>可以通过<code>sleep</code>强制要求线程睡眠，暂时不被唤醒。但调度器是不可预测的，线程之间可能有多个不同的执行顺序，每次执行可能得到不同的结果。</p><blockquote><p>Thread对象不能重复使用，一旦线程的run()方法完成后，线程就不能再重新启动。</p></blockquote><h4 id="2-4-sleep"><a href="#2-4-sleep" class="headerlink" title="2.4 sleep()"></a>2.4 <code>sleep()</code></h4><p>确保线程有机会执行，可以让它们周期性地进入<code>睡眠</code>状态。当线程醒来时，会进入可执行状态等待被调度器调度执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p><code>sleep</code>方法可能会抛出<code>InterruptedException</code>异常，所以对它的调用需要放在<code>try/catch</code>块中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">     ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-建立与启动多个线程"><a href="#2-5-建立与启动多个线程" class="headerlink" title="2.5 建立与启动多个线程"></a>2.5 建立与启动多个线程</h4><p>可以为线程命名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunThreads</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunThreads runner = <span class="keyword">new</span> RunThreads();</span><br><span class="line">        Thread alpha = <span class="keyword">new</span> Thread(runner);</span><br><span class="line">        Thread beta = <span class="keyword">new</span> Thread(runner);</span><br><span class="line">        alpha.setName(<span class="string">"Alpha thread"</span>);</span><br><span class="line">        beta.setName(<span class="string">"Beta thread"</span>);</span><br><span class="line">        alpha.start();</span><br><span class="line">        beta.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(threadName + <span class="string">" is running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-线程的并发性问题"><a href="#2-6-线程的并发性问题" class="headerlink" title="2.6 线程的并发性问题"></a>2.6 线程的并发性问题</h4><p>线程的<code>并发性(Concurrency)</code>问题会引发<code>竞争状态(race condition)</code>。竞争状态可能会引起数据的损毁。需要对线程间的共享数据增加一道锁，以保证数据的安全。</p><p>要使得具有安全问题的方法<code>原子化</code>，比如对账户操作的方法<code>makeWithdrawal()</code>。确定线程一旦进入这个方法后，就必须能够在其他线程进入之前把任务执行完毕。</p><blockquote><p>使用<code>synchronized</code>关键词来修饰方法使它每次只能被单一线程存取。</p><ul><li><code>synchronized</code>关键词代表线程需要钥匙来存取被<code>同步化(synchronized)</code>过的线程。</li><li>要保护数据，就把作用在数据上的方法同步化</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">makeWithdrawal</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (account.getBalance() &gt;= amount) &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ is about to withdraw”);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             System.out.println(Thread.currentThread().getName() + “ is going to sleep”);</span><br><span class="line">             Thread.sleep(<span class="number">500</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;ex.printStackTrace(); &#125;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ woke up.”);</span><br><span class="line">         account.withdraw(amount);</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ completes the withdrawl”);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(“Sorry, not enough <span class="keyword">for</span> “ + Thread.currentThread().getName());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>锁不是配在方法上的，而是配在对象上的。这意味着对象有两个同步化的方法，就表示两个线程无法进入同一个方法，也表示两个线程无法进入不同的方法。</p></blockquote><p>同步化除了可以保证数据的安全，但同时也存在一些影响或潜在问题：</p><ul><li>同步化方法会带来额外的开销(查询钥匙等)</li><li>同步化方法会强制线程排队，影响并行性</li><li>同步化方法可能会导致死锁</li></ul><p>原则上只做最少量的同步化，可以用<code>synchronized</code>来修饰一行或数行指令而不必同步化整个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     doStuff();</span><br><span class="line">     <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">         criticalStuff();</span><br><span class="line">         moreCriticalStuff();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于静态方法，每个被载入的类也有锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;连接到外面的世界。&lt;br&gt;
    
    </summary>
    
      <category term="headFirstJava" scheme="https://wuyunjie.top/categories/headFirstJava/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
  </entry>
  
</feed>
