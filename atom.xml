<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuYJ&#39;s Blog</title>
  
  <subtitle>wuyunjie的小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuyunjie.top/"/>
  <updated>2021-07-21T12:19:57.000Z</updated>
  <id>https://wuyunjie.top/</id>
  
  <author>
    <name>wuyunjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--9 Java中的线程池</title>
    <link href="https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-9-Java-thread-pool.html"/>
    <id>https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-9-Java-thread-pool.html</id>
    <published>2021-07-21T12:19:57.000Z</published>
    <updated>2021-07-21T12:19:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。 <a id="more"></a></p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。使用线程池可以进行统一分配、调优和监控。</li></ul><h3 id="线程池的实现原理">1. 线程池的实现原理</h3><p>当提交一个新任务到线程池时，线程池的处理流程如下。</p><ul><li>线程池判断<u><strong>核心线程池是否已满</strong></u>。<ul><li>如果不是，则创建一个新的工作线程来执行任务。</li><li>如果是，则进入下个流程。</li></ul></li><li>线程池判断<strong><u>工作队列是否已经满</u></strong>。</li><li>如果工作队列没有满，则将新提交的任务存储在这个工作队列里。</li><li>如果工作队列满了，则进入下个流程。</li><li>线程池判断<strong><u>线程池是否已满</u></strong>。<ul><li>如果没有，则创建一个新的工作线程来执行任务。</li><li>如果已经满了，则交给饱和策略来处理这个任务。</li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter9/thradPoolFlow.PNG" alt="线程池的主要处理流程" /><figcaption aria-hidden="true">线程池的主要处理流程</figcaption></figure><p><code>ThreadPoolExecutor</code>执行<code>execute()</code>方法有四种情况：</p><ol type="1"><li>如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（<strong><u>需要获取全局锁</u></strong>）。</li><li>如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li><li>如果无法将任务加入<code>BlockingQueue</code>（队列已满），则创建新的线程来处理任务（<strong><u>需要获取全局锁</u></strong>）。</li><li>如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并调用 <code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ol><p>在<code>ThreadPoolExecutor</code>完成预热之后（当前运行的线程数大于等于<code>corePoolSize</code>），几乎所有的<code>execute()</code>方法调用都是执行步骤<code>2</code>，而步骤<code>2</code>不需要获取全局锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="comment">// 如果线程数小于基本线程数，则创建线程并执行当前任务</span></span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line"><span class="comment">// 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span></span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，</span></span><br><span class="line"><span class="comment">// 则创建一个线程执行任务。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line"><span class="comment">// 抛出RejectedExecutionException异常</span></span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter9/thradPoolExecute.PNG" alt="ThreadPoolExecutor" /><figcaption aria-hidden="true">ThreadPoolExecutor</figcaption></figure><p>线程池创建线程时，会将线程封装成工作线程<code>Worker</code>，<code>Worker</code>在执行完任务后，还会循环获取工作队列里的任务来执行。线程池中的线程执行任务分两种情况。</p><ol type="1"><li>在<code>execute()</code>方法中创建一个线程时，会让这个线程执行当前任务。</li><li>这个线程执行完<code>1</code>的任务后，会反复从<code>BlockingQueue</code>获取任务来执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Worker类的run()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Runnable task = firstTask;</span><br><span class="line">        firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            runTask(task);task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        workerDone(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池的使用">2 线程池的使用</h3><h4 id="线程池的创建">2.1 线程池的创建</h4><p>通过<code>ThreadPoolExecutor</code>来创建一个线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);</span><br></pre></td></tr></table></figure><p>输入几个参数介绍如下：</p><ul><li><code>corePoolSize</code>：线程池的基本大小。<ul><li>需要执行的任务数小于线程池基本大小时，即使其他空闲的基本线程能够执行新任务，线程池会先创建一个线程来执行任务。</li><li>如果调用了线程池的<code>prestartAllCoreThreads()</code>方法，线程池会<strong><u>提前</u></strong>创建并启动所有基本线程。</li></ul></li><li><code>runnableTaskQueue</code>：任务队列。用于保存等待执行的任务的阻塞队列。可以选择的阻塞队列有：<ul><li><code>ArrayBlockingQueue</code>；</li><li><code>LinkedBlockingQueue</code>。静态方法<code>Executors.newFixedThreadPool()</code>使用这个队列。</li><li><code>SynchronousQueue</code>。静态方法<code>Executors.newCachedThreadPool</code>使用这个队列。</li><li><code>PriorityBlockingQueue</code>。</li></ul></li><li><code>maximumPoolSize</code>：线程池允许创建的最大线程数。<ul><li>如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</li></ul></li><li><code>ThreadFactory</code>：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li><li><code>RejectedExecutionHandler</code>：饱和策略。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。策略默认情况下是<code>AbortPolicy</code>，表示无法处理新任务时抛出异常。Java线程池框架提供了以下4种策略。<ul><li><code>AbortPolicy</code>：直接抛出异常。</li><li><code>CallerRunsPolicy</code>：用调用者所在线程来运行任务。</li><li><code>DiscardOldestPolicy</code>：丢弃队列里最近的一个任务，并执行当前任务。</li><li><code>DiscardPolicy</code>：不处理，直接丢弃掉。</li><li>也可以实现<code>RejectedExecutionHandler</code>接口自定义策略</li></ul></li><li><code>keepAliveTime</code>：线程活动保持时间。线程池的工作线程空闲后，保持存活的时间。</li><li><code>TimeUnit</code>：线程活动保持时间的单位。可选的单位有<code>天（DAYS）</code>、<code>小时（HOURS）</code>、<code>分钟（MINUTES）</code>、<code>毫秒（MILLISECONDS）</code>、<code>微秒（MICROSECONDS）</code>和<code>纳秒（NANOSECONDS）</code>。</li></ul><h4 id="向线程池提交任务">2.2 向线程池提交任务</h4><p>可以使用两个方法向线程池提交任务：</p><ul><li><p><code>execute()</code>方法。用于提交<u><strong>不需要返回值</strong></u>的任务，所以无法判断任务是否被线程池执行成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>submit()</code>方法。用于提交<u><strong>需要返回值</strong></u>的任务，线程池会返回一个<code>future</code>类型的对象，通过该<code>future</code>对象可以判断任务是否执行成功，并可以通过<code>future</code>的<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Object s = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 处理中断异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="关闭线程池">2.3 关闭线程池</h4><p>通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。</p><blockquote><p>原理是<strong><u>遍历线程池中的工作线程</u></strong>，然后逐个调用线程的<code>interrupt</code>方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p></blockquote><ul><li><p><code>shutdownNow</code>首先将线程池的状态设置成<code>STOP</code>，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表；</p></li><li><p><code>shutdown</code>只是将线程池的状态设置成<code>SHUTDOWN</code>状态，然后中断所有<strong><u>没有正在执行任务</u></strong>的线程。</p></li><li><p>只要调用了关闭方法，<code>isShutdown</code>方法就会返回<code>true</code>。</p></li><li><p>当所有的任务都已关闭后，才表示线程池关闭成功，这时调用<code>isTerminaed</code>方法会返回<code>true</code>。</p></li></ul><h4 id="合理地配置线程池">2.4 合理地配置线程池</h4><ul><li>性质不同的任务可以用不同规模的线程池分开处理。</li><li>优先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理。</li><li>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</li><li><strong><u>建议使用有界队列</u></strong>。有界队列能增加系统的稳定性和预警能力。</li></ul><h4 id="线程池的监控">2.5 线程池的监控</h4><p>可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。</p><ul><li><code>taskCount</code>：线程池需要执行的任务数量。</li><li><code>completedTaskCount</code>：线程池在运行过程中已完成的任务数量，小于或等于<code>taskCount</code>。</li><li><code>largestPoolSize</code>：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。</li><li><code>getPoolSize</code>：线程池的线程数量。<u>如果线程池不销毁的话，线程池里的线程不会自动销毁</u>，所以这个大小<strong><u>只增不减</u></strong>。</li><li><code>getActiveCount</code>：获取活动的线程数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--8 Java中的并发工具类</title>
    <link href="https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-8-Java-concurrent-tools.html"/>
    <id>https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-8-Java-concurrent-tools.html</id>
    <published>2021-07-21T09:14:21.000Z</published>
    <updated>2021-07-21T09:14:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>CountDownLatch</code>、<code>CyclicBarrier</code>和<code>Semaphore</code>工具类提供了一种<strong><u>并发流程控制</u></strong>的手段，<code>Exchanger</code>工具类则提供了在<strong><u>线程间交换数据</u></strong>的一种手段。 <a id="more"></a></p></blockquote><h3 id="等待多线程完成的countdownlatch">1. 等待多线程完成的<code>CountDownLatch</code></h3><p>要实现主线程等待所有线程完成操作，最简单的做法是使用<code>join()</code>方法。<code>join</code>用于让当前执行线程等待<code>join</code>线程执行结束。原理是不停检查<code>join</code>线程是否存活，如果<code>join</code>线程存活则让当前线程永远等待。<code>join</code>线程中止后，线程的<code>this.notifyAll()</code>方法会被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CountDownLatch</code>允许一个或多个线程等待其他线程完成操作，比<code>join</code>的功能更多。</p><ul><li><code>CountDownLatch</code>的构造函数接收一个<code>int</code>类型的参数作为计数器，表示需要等待<code>N</code>个点完成。</li><li>调用<code>CountDownLatch</code>的<code>countDown</code>方法时，<code>N</code>就会减<code>1</code>；</li><li><code>CountDownLatch</code>的<code>await</code>方法会阻塞当前线程，直到<code>N</code>变成零。</li></ul><blockquote><p>由于<code>countDown</code>方法可以用在<strong><u>任何地方</u></strong>，所以这里说的<code>N</code>个点，可以是<code>N</code>个线程，也可以是<code>1</code>个线程里的<code>N</code>个执行步骤。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        c.await();</span><br><span class="line">        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步屏障cyclicbarrier">2. 同步屏障<code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code>的字面意思是<strong><u>可循环使用（Cyclic）</u></strong>的<u><strong>屏障（Barrier）</strong></u>。让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><h4 id="cyclicbarrier简介">2.1 <code>CyclicBarrier</code>简介</h4><p><code>CyclicBarrier</code>默认的构造方法是<code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉<code>CyclicBarrier</code>我已经到达了屏障，然后当前线程被阻塞。</p><p><code>CyclicBarrier</code>还提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行<code>barrierAction</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment"> * given number of parties (threads) are waiting upon it, and which</span></span><br><span class="line"><span class="comment"> * will execute the given barrier action when the barrier is tripped,</span></span><br><span class="line"><span class="comment"> * performed by the last thread entering the barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties the number of threads that must invoke &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment"> *        before the barrier is tripped</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> barrierAction the command to execute when the barrier is</span></span><br><span class="line"><span class="comment"> *        tripped, or &#123;<span class="doctag">@code</span> null&#125; if there is no action</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties&#125; is less than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment"> * given number of parties (threads) are waiting upon it, and</span></span><br><span class="line"><span class="comment"> * does not perform a predefined action when the barrier is tripped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties the number of threads that must invoke &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment"> *        before the barrier is tripped</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties&#125; is less than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>CyclicBarrier</code>可以用于<u><strong>多线程计算数据，最后合并计算结果的场景</strong></u>。</p></blockquote><h4 id="cyclicbarrier和countdownlatch的区别">2.2 <code>CyclicBarrier</code>和<code>CountDownLatch</code>的区别</h4><p><code>CountDownLatch</code>的计数器只能使用一次，<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置。<code>CyclicBarrier</code>还提供其他有用的方法：</p><ul><li><code>getNumberWaiting</code>方法可以获得<code>CyclicBarrier</code>阻塞的线程数量。</li><li><code>isBroken()</code>方法用来了解阻塞的线程是否被中断。</li></ul><h3 id="控制并发线程数的semaphore">3. 控制并发线程数的<code>Semaphore</code></h3><p><code>Semaphore（信号量）</code>是用来控制<strong><u>同时访问特定资源的线程数量</u></strong>，它通过协调各个线程，以保证合理的使用公共资源。</p><h4 id="应用场景">3.1 应用场景</h4><p><code>Semaphore</code>可以用于做<strong><u>流量控制</u></strong>，特别是公用资源有限的应用场景，比如数据库连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println(<span class="string">"save data"</span>);</span><br><span class="line">                        s.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他方法">3.2 其他方法</h4><ul><li><code>intavailablePermits()</code>：返回此信号量中当前可用的许可证数。</li><li><code>intgetQueueLength()</code>：返回正在等待获取许可证的线程数。</li><li><code>booleanhasQueuedThreads()</code>：是否有线程正在等待获取许可证。</li><li><code>void reducePermits(int reduction)</code>：减少<code>reduction</code>个许可证，是个<code>protected</code>方法。</li><li><code>Collection getQueuedThreads()</code>：返回所有等待获取许可证的线程集合，是个<code>protected</code>方法。</li></ul><h3 id="线程间交换数据的exchanger">4. 线程间交换数据的<code>Exchanger</code></h3><p><code>Exchanger（交换者）</code>是一个用于<strong><u>线程间协作</u></strong>的工具类。<code>Exchanger</code>用于进行<strong><u>线程间的数据交换</u></strong>。</p><ul><li>它提供一个<code>同步点</code>，在这个同步点，两个线程通过<code>exchange</code>方法交换彼此的数据，如果第一个线程先执行<code>exchange()</code>方法，它会一直等待第二个线程也执行<code>exchange</code>方法；</li><li>当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方；</li><li>可以使用<code>exchange(V x，longtimeout，TimeUnit unit)</code>设置最大等待时长。</li></ul><h4 id="应用场景-1">4.1 应用场景</h4><ul><li><code>Exchanger</code>可以用于<strong><u>遗传算法</u></strong>，遗传算法里需要选出两个人作为配对对象，这时候会交换两人的数据。</li><li><code>Exchanger</code>也可以用于<strong><u>校对工作</u></strong>。如对两份录入数据进行校对，看看是否录入一致。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String A = <span class="string">"银行流水A"</span>; <span class="comment">// A录入银行流水数据</span></span><br><span class="line">                    String B = exgr.exchange(A);</span><br><span class="line">                    System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span>+ A + <span class="string">"，B录入是："</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String B = <span class="string">"银行流水B"</span>; <span class="comment">// B录入银行流水数据</span></span><br><span class="line">                    String A = exgr.exchange(<span class="string">"B"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span>+ A + <span class="string">"，B录入是："</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;CyclicBarrier&lt;/code&gt;和&lt;code&gt;Semaphore&lt;/code&gt;工具类提供了一种&lt;strong&gt;&lt;u&gt;并发流程控制&lt;/u&gt;&lt;/strong&gt;的手段，&lt;code&gt;Exchanger&lt;/code&gt;工具类则提供了在&lt;strong&gt;&lt;u&gt;线程间交换数据&lt;/u&gt;&lt;/strong&gt;的一种手段。
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--7 Java中的13个原子操作类</title>
    <link href="https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-7-Java-atomic-class.html"/>
    <id>https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-7-Java-atomic-class.html</id>
    <published>2021-07-21T08:06:12.000Z</published>
    <updated>2021-07-21T08:06:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>java.util.concurrent.atomic</code>包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。<code>Atomic</code>包里的类基本都是<u>使用<code>Unsafe</code>实现的包装类</u>。 <a id="more"></a></p></blockquote><h3 id="原子更新基本类型类">1. 原子更新基本类型类</h3><p><code>Atomic</code>包提供了3个类更新基本类型：</p><ul><li><code>AtomicBoolean</code>：原子更新布尔类型。</li><li><code>AtomicInteger</code>：原子更新整型。</li><li><code>AtomicLong</code>：原子更新长整型。</li></ul><p>以上3个类提供的方法几乎一模一样，常用方法有：</p><ul><li><p><code>int addAndGet(int delta)</code>：以原子方式将输入的数值与实例中的值（<code>AtomicInteger</code>里的<code>value</code>）相加，并返回结果。</p></li><li><p><code>boolean compareAndSet(int expect，int update)</code>：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>int getAndIncrement()</code>：以原子方式将当前值加<code>1</code>，返回的是自增前的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk 1.8 实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>void lazySet(int newValue)</code>：最终会设置成<code>newValue</code>，使用<code>lazySet</code>设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</p></li><li><p><code>int getAndSet(int newValue)</code>：以原子方式设置为<code>newValue</code>的值，并返回旧值。</p></li></ul><p><code>Atomic</code>包里的类基本都是使用<code>Unsafe</code>实现的。<code>Unsafe</code>只提供了<code>3</code>种<code>CAS</code>方法，<code>AtomicBoolean</code>先把<code>Boolean</code>转换成<strong>整型</strong>，再使用<code>compareAndSwapInt</code>进行<code>CAS</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果当前数值是expected，则原子的将Java变量更新成x</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果更新成功则返回true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object expected, Object x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> expected, <span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="原子更新数组">2. 原子更新数组</h3><p>Atomic包提供了4个类更新数组里的某个元素：</p><ul><li><code>AtomicIntegerArray</code>：原子更新整型数组里的元素。</li><li><code>AtomicLongArray</code>：原子更新长整型数组里的元素。</li><li><code>AtomicReferenceArray</code>：原子更新引用类型数组里的元素。</li><li><code>AtomicBooleanArray</code> ：原子更新布尔类型数组的元素。</li></ul><p>其常用方法如下：</p><ul><li><p><code>int addAndGet(int i，int delta)</code>：以原子方式将输入值与数组中索引<code>i</code>的元素相加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getAndAdd(i, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index "</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.getAndAddInt(array, checkedByteOffset(i), delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>boolean compareAndSet(int i，int expect，int update)</code>：如果当前值等于预期值，则以原子方式将数组位置<code>i</code>的元素设置成<code>update</code>值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基于已有数组创建<code>AtomicIntegerArray</code>对象时，构造函数会将当前数组复制一份，所以当<code>AtomicIntegerArray</code>对内部的数组元素进行修改时，不会影响原数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Visibility guaranteed by final field guarantees</span></span><br><span class="line">    <span class="keyword">this</span>.array = array.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="原子更新引用类型">3. 原子更新引用类型</h3><p>Atomic包提供了3个类原子更新引用类型：</p><ul><li><p><code>AtomicReference</code>：原子更新引用类型。</p></li><li><p><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段。</p></li><li><p><code>AtomicMarkableReference</code>：原子更新带有标记位的引用类型。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更新的仅仅只是引用，引用的对象并未改变。</p></blockquote><h3 id="原子更新字段类">4. 原子更新字段类</h3><p>Atomic包提供了3个类进行原子字段更新。</p><ul><li><code>AtomicIntegerFieldUpdater</code>：原子更新整型的字段的更新器。</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器。</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。可以解决使用<code>CAS</code>进行原子更新时可能出现的<code>ABA</code>问题。</li></ul><p>原子地更新字段类需要两步。</p><ul><li>第一步，必须使用静态方法<code>newUpdater()</code>创建一个更新器，并且需要设置想要更新的类和属性。</li><li>第 二步，更新类的字段（属性）必须使用<code>public volatile</code>修饰符。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建原子更新器，并设置需要更新的对象类和对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.</span><br><span class="line">        newUpdater(User.class, "old");</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置柯南的年龄是10岁</span></span><br><span class="line">        User conan = <span class="keyword">new</span> User(<span class="string">"conan"</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 柯南长了一岁，但是仍然会输出旧的年龄</span></span><br><span class="line">        System.out.println(a.getAndIncrement(conan));</span><br><span class="line">        <span class="comment">// 输出柯南现在的年龄</span></span><br><span class="line">        System.out.println(a.get(conan));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> old;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.old = old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt;包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。&lt;code&gt;Atomic&lt;/code&gt;包里的类基本都是&lt;u&gt;使用&lt;code&gt;Unsafe&lt;/code&gt;实现的包装类&lt;/u&gt;。
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--6 Java并发容器和框架</title>
    <link href="https://wuyunjie.top/2021/07/20/JavaLearning_The_art_of_concurrent_programming_in_Java-6-Java-concurrent-container-and-framework.html"/>
    <id>https://wuyunjie.top/2021/07/20/JavaLearning_The_art_of_concurrent_programming_in_Java-6-Java-concurrent-container-and-framework.html</id>
    <published>2021-07-20T12:56:06.000Z</published>
    <updated>2021-07-20T12:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>并发编程大师Doug Lea不遗余力地为Java开发者提供了非常多的并发容器和框架</code> <a id="more"></a></p></blockquote><h3 id="concurrenthashmap的实现原理">1. <code>ConcurrentHashMap</code>的实现原理</h3><p>在并发编程中使用<code>HashMap</code>可能导致程序死循环，而使用线程安全的<code>HashTable</code>效率又非常低下。<code>ConcurrentHashMap</code>是线程安全且高效的<code>HashMap</code>。</p><ul><li><p><strong>线程不安全的<code>HashMap</code></strong>。在多线程环境下，使用<code>HashMap</code>进行<code>put</code>操作会引起死循环。</p></li><li><p><strong>效率低下的<code>HashTable</code></strong>。<code>HashTable</code>容器使用<code>synchronized</code>来保证线程安全，但在线程竞争激烈的情况下<code>HashTable</code>的效率非常低下。</p></li><li><p><code>ConcurrentHashMap</code>的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p></li></ul><h4 id="concurrenthashmap的结构">1.1 <code>ConcurrentHashMap</code>的结构</h4><p><code>ConcurrentHashMap</code>是由<code>Segment</code>数组结构和<code>HashEntry</code>数组结构组成。</p><ul><li><code>Segment</code>是一种<strong>可重入锁</strong>（<code>ReentrantLock</code>），一个<code>ConcurrentHashMap</code>里包含一个<code>Segment</code>数组；<ul><li><code>Segment</code>的结构和<code>HashMap</code>类似，是一种<strong>数组和链表结构</strong>；</li><li>一个<code>Segment</code>里包含一个<code>HashEntry</code>数组，每个<code>Segment</code>守护着一个<code>HashEntry</code>数组里的元素，当对<code>HashEntry</code>数组的数据进行修改时，必须首先获得与它对应的<code>Segment</code>锁。</li></ul></li><li><code>HashEntry</code>则用于存储键值对数据，每个<code>HashEntry</code>是一个<strong>链表结构</strong>的元素。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentHashMapClass.PNG" alt="ConcurrentHashMap类图" /><figcaption aria-hidden="true">ConcurrentHashMap类图</figcaption></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentHashMapStructure.PNG" alt="ConcurrentHashMap结构" /><figcaption aria-hidden="true">ConcurrentHashMap结构</figcaption></figure><h4 id="concurrenthashmap的初始化">1.2 <code>ConcurrentHashMap</code>的初始化</h4><p><code>ConcurrentHashMap</code>初始化方法是通过<code>initialCapacity</code>、<code>loadFactor</code>和<code>concurrencyLevel</code>等几个参数来初始化<code>segment</code>数组、段偏移量<code>segmentShift</code>、段掩码<code>segmentMask</code>和每个<code>segment</code>里的<code>HashEntry</code>数组来实现的。</p><h5 id="初始化segments数组">1.2.1 初始化<code>segments</code>数组</h5><p><code>segments</code>数组的长度<code>ssize</code>是通过<code>concurrencyLevel</code>计算得出的：</p><ul><li>为了能通过<code>按位与的散列算法</code>来定位<code>segments</code>数组的索引，必须保证<code>segments</code>数组的长度是<code>2</code>的<code>N</code>次方，所以必须计算出一个大于或等于<code>concurrencyLevel</code>的最小的2的N次方值来作为<code>segments</code>数组的长度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure><h5 id="初始化segmentshift和segmentmask">1.2.2 初始化<code>segmentShift</code>和<code>segmentMask</code></h5><p>这两个全局变量需要在定位<code>segment</code>时的散列算法里使用：</p><ul><li><code>sshift</code>等于<code>ssize</code>从1向左移位的次数。<code>segmentShift</code>用于<u><strong>定位参与散列运算的位数</strong></u>，<code>segmentShift</code>等于<code>32</code>减<code>sshift</code>，这里之所以用32是因为<code>ConcurrentHashMap</code>里的<code>hash()</code>方法输出的最大数是32位的。</li><li><code>segmentMask</code>是散列运算的掩码，等于<code>ssize</code>减<code>1</code>，掩码的二进制各个位的值都是<code>1</code>。</li></ul><h5 id="初始化每个segment">1.2.3 初始化每个<code>segment</code></h5><p>输入参数<code>initialCapacity</code>是<code>ConcurrentHashMap</code>的<strong>初始化容量</strong>，<code>loadfactor</code>是每个<code>segment</code>的<strong>负载因子</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">++c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line"><span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);</span><br></pre></td></tr></table></figure><ul><li>变量<code>cap</code>是<code>segment</code>里<code>HashEntry</code>数组的长度，它等于<code>initialCapacity</code>除以<code>ssize</code>的倍数<code>c</code>。</li><li><code>segment</code>的容量<code>threshold＝（int）cap*loadFactor</code>。</li></ul><h4 id="定位segment">1.3 定位<code>Segment</code></h4><p>在<strong>插入和获取</strong>元素的时候，必须先通过散列算法定位到<code>Segment</code>。</p><ul><li><code>ConcurrentHashMap</code>会首先使用<code>Wang/Jenkins hash</code>的变种算法对元素的<code>hashCode</code>进行一次再散列。目的是<strong><u>减少散列冲突</u></strong>，使元素能够均匀地分布在不同的<code>Segment</code>上， 从而提高容器的存取效率。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种再散列能让数字的每一位都参加到散列运算当中，从而减少散列冲突。<code>ConcurrentHashMap</code>通过以下散列算法定位<code>segment</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="concurrenthashmap的操作">1.4 <code>ConcurrentHashMap</code>的操作</h4><h5 id="get操作">1.4.1 <code>get</code>操作</h5><p><code>Segment</code>的<code>get</code>操作先经过一次再散列，然后使用这个散列值通过散列运算定位到<code>Segment</code>，再通过散列算法定位到元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line"><span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get</code>操作的高效之处在于<u><strong>整个<code>get</code>过程不需要加锁，除非读到的值是空才会加锁重读</strong></u>。</p><ul><li><p><code>get</code>方法里将要使用的共享变量都定义成<code>volatile</code>类型，如用于统计当前<code>Segement</code>大小的<code>count</code>字段和用于存储值的<code>HashEntry</code>的<code>value</code>。这是用volatile替换锁的经典应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">volatile</span> V value;</span><br></pre></td></tr></table></figure></li><li><p>定位<code>Segment</code>使用的是元素的<code>hashcode</code>通过再散列后得到的值的高位，而定位<code>HashEntry</code>直接使用的是再散列后的值。其目的是避免两次散列后的值一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask <span class="comment">// 定位Segment所使用的hash算法</span></span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); <span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="put操作">1.4.2 <code>put</code>操作</h5><p><code>put</code>方法首先定位到<code>Segment</code>，然后在<code>Segment</code>里进行插入操作。插入操作需要经历两个步骤</p><ul><li>第一步判断是否需要对<code>Segment</code>里的<code>HashEntry</code>数组进行扩容；<ul><li>在<strong><u>插入元素前</u></strong>先判断<code>Segment</code>里的<code>HashEntry</code>数组是否超过<code>容量（threshold）</code>，如果超过阈值，则对数组进行扩容。扩容的时候首先会创建一个容量是<strong><u>原来容量两倍</u></strong>的数组，然后将原数组里的元素进行<u><strong>再散列后插入</strong></u>到新的数组里。</li><li><code>HashMap</code>是在<strong><u>插入元素后</u></strong>判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时<code>HashMap</code>就进行了一次无效的扩容。</li></ul></li><li>第二步定位添加元素的位置，然后将其放在<code>HashEntry</code>数组里。</li></ul><h5 id="size操作">1.4.3 <code>size</code>操作</h5><p><code>ConcurrentHashMap</code>统计<code>size</code>时，先尝试<code>2</code>次通过<strong>不锁住</strong><code>Segment</code>的方式来统计各个<code>Segment</code>大小，如果统计的过程中，容器的<code>count</code>发生了变化，则再采用<strong>加锁</strong>的方式来统计所有<code>Segment</code>的大小。</p><h3 id="concurrentlinkedqueue">2. <code>ConcurrentLinkedQueue</code></h3><p>实现一个线程安全的队列有两种方式：</p><ul><li><strong>使用阻塞算法</strong>。用一个<strong>锁</strong>（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</li><li><strong>使用非阻塞算法</strong>。使用循环<code>CAS</code>的方式来实现。</li></ul><p><code>ConcurrentLinkedQueue</code>是一个基于链接节点的<strong>无界线程安全队列</strong>。它采用了<code>“wait-free”算法</code>（即<code>CAS</code>算法）来实现。</p><h4 id="concurrentlinkedqueue的结构">2.1 <code>ConcurrentLinkedQueue</code>的结构</h4><p><code>ConcurrentLinkedQueue</code>由<code>head</code>节点和<code>tail</code>节点组成。</p><ul><li>每个节点（Node）由节点元素（item）和 指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一 张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail = head;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentLinkedQueueClass.PNG" alt="ConcurrentLinkedQueue类图" /><figcaption aria-hidden="true">ConcurrentLinkedQueue类图</figcaption></figure><h4 id="入队列">2.2 入队列</h4><h5 id="入队列的过程">2.2.1 入队列的过程</h5><p>入队列就是将入队节点添加到队列的尾部。入队主要做两件事情：</p><ul><li>将<strong>入队节点</strong>设置成当前队列尾节点的下一个节点；</li><li>更新<code>tail</code>节点，如果<code>tail</code>节点的<code>next</code>节点不为空，则将入队节点设置成<code>tail</code>节点，如果<code>tail</code>节点的<code>next</code>节点为空，则将入队节点设置成<code>tail</code>的<code>next</code>节点，<u><strong>所以<code>tail</code>节点不总是尾节点</strong></u>。</li></ul><p>多个线程同时进行入队操作时，使用<code>CAS</code>算法来入队：</p><ul><li>首先定位出尾节点；</li><li>然后使用<code>CAS</code>算法将入队节点设置成尾节点的<code>next</code>节点，如不成功则重试。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 入队前，创建一个入队节点</span></span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    </span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 死循环，入队不成功反复入队。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 创建一个指向tail节点的引用</span></span><br><span class="line">        Node&lt;E&gt; t = tail;</span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class="line">        Node&lt;E&gt; p = t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">            <span class="comment">// 获得p节点的下一个节点。</span></span><br><span class="line">            Node&lt;E&gt; next = succ(p);</span><br><span class="line">            <span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;</span><br><span class="line">                <span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</span></span><br><span class="line"><span class="comment">                  更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt;= HOPS)</span><br><span class="line">                    casTail(t, n); <span class="comment">// 更新tail节点，允许失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = succ(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>入队方法永远返回<code>true</code>，所以不要通过返回值判断入队是否成功。</p></blockquote><h5 id="定位尾节点">2.2.2 定位尾节点</h5><p><code>tail</code>节点并不总是尾节点，所以每次入队都必须先通过<code>tail</code>节点来找到尾节点。</p><blockquote><p>尾节点可能是<code>tail</code>节点，也可能是<code>tail</code>节点的<code>next</code>节点。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">Node&lt;E&gt; next = p.getNext();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取tail节点的next节点需要注意的是 p 节点等于 p 的 next 节点的情况，</span></span><br><span class="line"><span class="comment">     * 此时p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="设置入队节点为尾节点">2.2.3 设置入队节点为尾节点</h5><p><code>p.casNext(null，n)</code>方法用于将入队节点设置为当前队列尾节点的<code>next</code>节点：</p><ul><li>如果<code>p</code>是<code>null</code>， 表示<code>p</code>是当前队列的尾节点；</li><li>如果不为<code>null</code>，表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</li></ul><h5 id="hops的设计">2.2.4 <code>HOPS</code>的设计</h5><p>使用<code>hops</code>变量来<strong><u>控制并减少<code>tail</code>节点的更新频率</u></strong>。</p><ul><li>不是每次节点入队后都将<code>tail</code>节点更新成尾节点，而是当<code>tail</code>节点和尾节点的距离大于等于常量<code>HOPS</code>的值（默认等于1）时才更新<code>tail</code>节点。<strong><u><code>tail</code>和尾节点的距离越长，使用<code>CAS</code>更新<code>tail</code>节点的次数就会越少</u></strong>；</li><li>但是距离越长带来的<strong>负面效果</strong>就是<u>每次入队时定位尾节点的时间就越长</u>，因为循环体需要多循环一次来定位出尾节点。但是这样仍然能提高入队的效率，因为<u><strong>通过增加对<code>volatile</code>变量的读操作来减少对<code>volatile</code>变量的写操作</strong></u>，而对volatile变量的写操作开销要远远大于读操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOPS = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="出队列">2.3 出队列</h4><p><strong>出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用</strong>。与入队列类似，<u>不是每次出队时都更新<code>head</code>节点</u>，通过<code>hops</code>变量来减少使用<code>CAS</code>更新<code>head</code>节点的消耗。</p><ul><li>当<code>head</code>节点里<strong>有元素</strong>时，直接弹出<code>head</code>节点里的元素，而不会更新<code>head</code>节点。</li><li>只有当<code>head</code>节点里<strong>没有元素</strong>时，出队操作才会更新<code>head</code> 节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">// p表示头节点，需要出队的节点</span></span><br><span class="line">    Node&lt;E&gt; p = h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">        <span class="comment">// 获取p节点的元素</span></span><br><span class="line">        E item = p.getItem();</span><br><span class="line">        <span class="comment">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</span></span><br><span class="line">        <span class="comment">// 如果成功则返回p节点的元素。</span></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hops &gt;= HOPS) &#123;</span><br><span class="line">                <span class="comment">// 将p节点下一个节点设置成head节点</span></span><br><span class="line">                Node&lt;E&gt; q = p.getNext();</span><br><span class="line">                updateHead(h, (q != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</span></span><br><span class="line">        <span class="comment">// 一个线程修改了。那么获取p节点的下一个节点</span></span><br><span class="line">        Node&lt;E&gt; next = succ(p);</span><br><span class="line">        <span class="comment">// 如果p的下一个节点也为空，说明这个队列已经空了</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 更新头节点。</span></span><br><span class="line">            updateHead(h, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span></span><br><span class="line">        p = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个线程同时进行出队操作时，使用<code>CAS</code>算法来出队：</p><ul><li>首先获取<strong>头节点的元素</strong>，然后判断<strong>头节点元素</strong>是否为空；</li><li>如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走；</li><li>如果不为空，则使用<code>CAS</code>的方式将头节点的引用设置成<code>null</code>；<ul><li>如果<code>CAS</code>成功，则直接返回头节点的元素；</li><li>如果不成功，表示另外一个线程已经进行了一次出队操作更新了<code>head</code>节点，需要重新获取头节点。</li></ul></li></ul><h3 id="java中的阻塞队列">3. Java中的阻塞队列</h3><h4 id="阻塞队列介绍">3.1 阻塞队列介绍</h4><p><code>阻塞队列（BlockingQueue）</code>支持阻塞的插入和移除方法。</p><ul><li><strong>支持阻塞的插入方法</strong>：当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li><li><strong>支持阻塞的移除方法</strong>：在队列为空时，获取元素的线程会等待队列变为非空。</li></ul><p>在阻塞队列不可用时，这两个附加操作提供了4种处理方式：</p><ul><li><strong>抛出异常</strong>：当队列满时，如果再往队列里插入元素，会抛出<code>IllegalStateException("Queue full")</code>异常。当队列空时，从队列里获取元素会抛出<code>NoSuchElementException</code>异常。主要方法有：<code>add(e), remove(), element()</code>。</li><li><strong>返回特殊值</strong>：当往队列插入元素时，会返回元素是否插入成功，成功返回<code>true</code>。如果是移除方法，则是从队列里取出一个元素，如果没有则返回<code>null</code>。主要方法有：<code>offer(e), poll(), peek()</code>。</li><li><strong>一直阻塞</strong>：当阻塞队列满时，如果生产者线程往队列里<code>put</code>元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里<code>take</code>元素，队列会阻塞住消费者线程，直到队列不为空。主要方法有：<code>put(e), take()</code>。</li><li><strong>超时退出</strong>：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。主要方法有：<code>offer(e, time, unit), poll(time, unit)</code>。</li></ul><blockquote><p>无界阻塞队列<strong>不可能会出现满</strong>的情况，所以使用<code>put</code>或<code>offer</code>方法永远不会被阻塞，而且使用<code>offer</code>方法时，该方法永远返回<code>true</code>。</p></blockquote><h4 id="java里的阻塞队列">3.2 Java里的阻塞队列</h4><p><code>JDK 7</code>提供了<code>7</code>个阻塞队列。</p><h5 id="arrayblockingqueue">3.2.1 <code>ArrayBlockingQueue</code></h5><p>一个由<strong><u>数组结构</u></strong>组成的<strong>有界</strong>阻塞队列，默认情况下不保证线程公平的访问队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="linkedblockingqueue">3.2.2 <code>LinkedBlockingQueue</code></h5><p>一个由<strong><u>链表结构</u></strong>组成的<strong>有界</strong>阻塞队列。此队列的默认和最大长度为<code>Integer.MAX_VALUE</code>。</p><h5 id="priorityblockingqueue">3.2.3 <code>PriorityBlockingQueue</code></h5><p>一个<strong><u>支持优先级排序</u></strong>的<strong>无界</strong>阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现<code>compareTo()</code>方法来指定元素排序规则，或者初始化<code>PriorityBlockingQueue</code>时，指定构造参数<code>Comparator</code>来对元素进行排序。</p><blockquote><p>不能保证同优先级元素的顺序。</p></blockquote><h5 id="delayqueue">3.2.4 <code>DelayQueue</code></h5><p>一个使用<u><strong>优先级队列(<code>PriorityQueue</code>)</strong></u>实现的<strong>无界</strong>阻塞队列，支持<strong><u>延时获取元素</u></strong>。</p><ul><li>队列中的元素必须实现<code>Delayed</code>接口，在创建元素时可以指定多久才能从队列中获取当前元素。</li><li>只有在延迟期满时才能从队列中提取元素。</li></ul><h6 id="delayed接口实现">3.2.4.1 <code>Delayed</code>接口实现</h6><p>参考<code>ScheduledThreadPoolExecutor</code>里<code>ScheduledFutureTask</code>类的实现。</p><ul><li>第一步：在对象创建的时候，初始化基本数据。使用<code>time</code>记录当前对象延迟到什么时候可以使用，使用<code>sequenceNumber</code>来标识元素在队列中的先后顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二步：实现<code>getDelay</code>方法，该方法返回当前元素还需要延时多长时间，单位是纳秒。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三步：实现<code>compareTo</code>方法来指定元素的顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero ONLY if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;&gt; x = (ScheduledFutureTask&lt;&gt;)other;</span><br><span class="line">        <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// othter 不是 ScheduledFutureTask 对象时</span></span><br><span class="line">    <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) - other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">    <span class="keyword">return</span> (d == <span class="number">0</span>) ? <span class="number">0</span> : ( (d &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="实现延时阻塞队列">3.2.4.2 实现延时阻塞队列</h6><p>当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> q.poll();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">    available.await();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    Thread thisThread = Thread.currentThread();</span><br><span class="line">    leader = thisThread;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        available.awaitNanos(delay);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>leader</code>是一个<u><strong>等待获取队列头部元素的线程</strong></u>。</p><ul><li>如果<code>leader</code>不等于空，表示<u>已经有线程在等待获取队列的头元素</u>。使用<code>await()</code>方法让当前线程等待信号；</li><li>如果<code>leader</code>等于空，则把当前线程设置成<code>leader</code>，并使用<code>awaitNanos()</code>方法让当前线程等待接收信号或等待<code>delay</code>时间。</li></ul><h6 id="delayqueue应用场景">3.2.4.3 <code>DelayQueue</code>应用场景</h6><ul><li><strong>缓存系统的设计</strong>：用<code>DelayQueue</code>保存缓存元素的<u>有效期</u>，使用一个线程循环查询<code>DelayQueue</code>，一旦能从<code>DelayQueue</code>中获取元素时，表示缓存有效期到了。</li><li><strong>定时任务调度</strong>：使用<code>DelayQueue</code>保存当天将会执行的任务和执行时间，一旦从<code>DelayQueue</code>中获取到任务就开始执行，比如<code>TimerQueue</code>就是使用<code>DelayQueue</code>实现的。</li></ul><h5 id="synchronousqueue">3.2.5 <code>SynchronousQueue</code></h5><p>一个<strong><u>不存储元素</u></strong>的阻塞队列。每一个<code>put</code>操作<strong><u>必须等待</u></strong>一个<code>take</code>操作， 否则不能继续添加元素。默认情况下线程采用非公平性策略访问队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">transferer = fair ? <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列本身并不存储任何元素，非常适合传递性场景。</p><ul><li><code>SynchronousQueue</code>的吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>。</li></ul><h5 id="linkedtransferqueue">3.2.6 <code>LinkedTransferQueue</code></h5><p>一个由<strong><u>链表结构</u></strong>组成的<strong>无界</strong>阻塞队列。<code>LinkedTransferQueue</code>增加了<code>tryTransfer</code>和<code>transfer</code>方法。</p><ol type="1"><li><p><code>transfer</code>方法</p><ul><li>如果当前有消费者正在等待接收元素，<code>transfer</code>方法可以把生产者传入的元素立刻<code>transfer</code>（传输）给消费者。</li><li>如果没有消费者在等待接收元素，<code>transfer</code>方法会将元素存放在队列的<code>tail</code>节点，并等到该元素被消费者消费了才返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试图把存放当前元素的s节点作为tail节点</span></span><br><span class="line">Node pred = tryAppend(s, haveData);</span><br><span class="line"><span class="comment">// 让CPU自旋等待消费者消费元素</span></span><br><span class="line"><span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br></pre></td></tr></table></figure></li><li><p><code>tryTransfer</code>方法</p><p>用来试探生产者传入的元素是否能直接传给消费者。</p><ul><li>如果没有消费者等待接收元素，则返回<code>false</code>；</li><li><code>tryTransfer</code>方法无论消费者是否接收，方法<u><strong>立即返回</strong></u>；<code>transfer</code>方法是<u><strong>必须等到消费者消费了才返回</strong></u>。</li><li>带有时间限制的<code>tryTransfer(E e, long timeout, TimeUnit unit)</code>方法，如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false；如果在超时时间内消费了元素，则返回true。</li></ul></li></ol><h5 id="linkedblockingdeque">3.2.7 <code>LinkedBlockingDeque</code></h5><p>一个由<strong><u>链表结构</u></strong>组成的<strong><u>双向</u></strong>阻塞队列。在初始化<code>LinkedBlockingDeque</code>时可以设置容量防止其过度膨胀。</p><blockquote><p>双向阻塞队列可以运用在<code>“工作窃取”模式</code>中。</p></blockquote><h4 id="阻塞队列的实现">3.3 阻塞队列的实现</h4><p>使用<strong><u>通知模式</u></strong>实现阻塞队列。如<code>ArrayBlockingQueue</code>使用了<code>Condition</code>来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        insert(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> extract();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    putIndex = inc(putIndex);</span><br><span class="line">    ++count;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞生产者主要通过 <code>LockSupport.park(this)</code>来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程加入等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步状态，也就是释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 调用setBlocker先保存一下将要阻塞的线程</span></span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    <span class="comment">// 调用unsafe.park阻塞当前线程</span></span><br><span class="line">    unsafe.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unsafe.park是个native方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure><p><code>park</code>方法会阻塞当前线程，只有以下4种情况中的一种发生时，该方法才会返回：</p><ul><li>与<code>park</code>对应的<code>unpark</code>执行或已经执行时。<code>“已经执行”</code>是指<u><code>unpark</code>先执行，然后再执行<code>park</code></u>的情况。</li><li>线程被中断时。</li><li>等待完<code>time</code>参数指定的毫秒数时。</li><li>异常现象发生时，这个异常现象没有任何原因。</li></ul><p><code>Linux</code>下使用的是系统方法<code>pthread_cond_wait</code>实现<code>park</code>方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> os::PlatformEvent::park() &#123;</span><br><span class="line">    <span class="keyword">int</span> v ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        v = _Event ;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg (v<span class="number">-1</span>, &amp;_Event, v) == v) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    guarantee (v &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// Do this the hard way by blocking ...</span></span><br><span class="line">        <span class="keyword">int</span> status = pthread_mutex_lock(_mutex);</span><br><span class="line">        assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_lock"</span>);</span><br><span class="line">        guarantee(_nParked == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">        ++ _nParked;</span><br><span class="line">        <span class="keyword">while</span> (_Event &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// pthread_cond_wait是一个多线程的条件变量函数</span></span><br><span class="line">            status = pthread_cond_wait(_cond, _mutex);</span><br><span class="line"><span class="comment">// for some reason, under 2.7 lwp_cond_wait() may return ETIME ...</span></span><br><span class="line"><span class="comment">// Treat this the same as if the wait was interrupted</span></span><br><span class="line">            <span class="keyword">if</span> (status == ETIME) &#123; status = EINTR; &#125;</span><br><span class="line">            assert_status(status == <span class="number">0</span> || status == EINTR, status, <span class="string">"cond_wait"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        -- _nParked ;</span><br><span class="line"><span class="comment">// In theory we could move the ST of 0 into _Event past the unlock(),</span></span><br><span class="line"><span class="comment">// but then we'd need a MEMBAR after the ST.</span></span><br><span class="line">        _Event = <span class="number">0</span> ;</span><br><span class="line">        status = pthread_mutex_unlock(_mutex);</span><br><span class="line">        assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_unlock"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    guarantee (_Event &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="forkjoin框架">4. Fork/Join框架</h3><h4 id="forkjoin框架介绍">4.1 Fork/Join框架介绍</h4><p><code>Fork/Join框架</code>是<code>Java 7</code>提供的一个<strong><u>用于并行执行任务</u></strong>的框架。它<u>把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果</u>。</p><ul><li><code>Fork</code>就是把一个大任务切分为若干子任务并行的执行；</li><li><code>Join</code>就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li></ul><h4 id="工作窃取算法">4.2 工作窃取算法</h4><p><code>工作窃取（work-stealing）</code>算法是指<u><strong>某个线程从其他队列里窃取任务来执行</strong></u>。</p><ul><li>把大任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。</li><li>但某个线程先完成自己队列里的任务，而其他线程对应的队列里还有任务等待处理，它会去其他线程的队列里窃取一个任务来执行。</li><li>为了减少窃取任务线程和被窃取任务线程之间的竞争，通常使用<strong><u>双端队列</u></strong>，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</li></ul><p><strong>工作窃取算法的优点</strong>：充分利用线程进行并行计算，减少了线程间的竞争。</p><p><strong>工作窃取算法的缺点</strong>：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。且会消耗更多的系统资源。</p><h4 id="forkjoin框架的设计">4.3 Fork/Join框架的设计</h4><p>Fork/Join框架主要有两个步骤：</p><ul><li><strong>步骤1 分割任务</strong>。首先需要一个<code>fork类</code>来把大任务分割成子任务。</li><li><strong>步骤2 执行任务并合并结果</strong>。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。<u>子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据</u>。</li></ul><blockquote><p>很像<code>MapReduce</code>算法，都是任务分解(Map)，然后聚合结果(Reduce)</p></blockquote><p><code>Fork/Join</code>使用两个类来完成以上两件事情：</p><ul><li><code>ForkJoinTask</code>：首先创建一个<code>ForkJoin</code>任务。它提供在任务中执行<code>fork()</code>和<code>join()</code>操作的机制。一般不需要直接继承<code>ForkJoinTask</code>类，<strong>Fork/Join框架</strong>提供了两个子类。<ul><li><code>RecursiveAction</code>：用于<strong><u>没有返回结果</u></strong>的任务。</li><li><code>RecursiveTask</code>：用于<strong><u>有返回结果</u></strong>的任务。</li></ul></li><li><code>ForkJoinPool</code>：<code>ForkJoinTask</code>需要通过<code>ForkJoinPool</code>来执行。</li></ul><h4 id="使用forkjoin框架">4.4 使用Fork/Join框架</h4><p><code>ForkJoinTask</code>需要实现<code>compute</code>方法，在这个方法里首先需要判断任务是否足够小：</p><ul><li>如果足够小就直接执行任务。</li><li>如果不足够小，就必须分割成两个子任务，每个子任务在调用<code>fork</code>方法时，又会进入<code>compute</code>方法。</li></ul><p>使用<code>join</code>方法会等待子任务执行完并得到其结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>; <span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forkjoin框架的异常处理">4.5 Fork/Join框架的异常处理</h4><p><code>ForkJoinTask</code>提供了<code>isCompletedAbnormally()</code>方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过<code>ForkJoinTask</code>的<code>getException</code>方法获取异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(task.isCompletedAbnormally()) &#123;</span><br><span class="line">System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forkjoin框架的实现">4.6 Fork/Join框架的实现</h4><p><code>ForkJoinPool</code>由<code>ForkJoinTask</code>数组和<code>ForkJoinWorkerThread</code>数组组成：</p><ul><li><code>ForkJoinTask</code>数组负责将存放程序提交给<code>ForkJoinPool</code>的任务；</li><li><code>ForkJoinWorkerThread</code>数组负责执行这些任务。</li></ul><h5 id="forkjointask的fork方法">4.6.1 ForkJoinTask的fork方法</h5><p>调用<code>ForkJoinTask</code>的<code>fork</code>方法时</p><ul><li>首先调用<code>ForkJoinWorkerThread</code>的<code>pushTask</code>方法<strong><u>异步地执行</u></strong>这个任务。</li><li><code>pushTask</code>方法把当前任务存放在<code>ForkJoinTask</code>数组队列里。然后再调用<code>ForkJoinPool</code>的<code>signalWork()</code>方法唤醒或创建一个工作线程来执行任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">((ForkJoinWorkerThread) Thread.currentThread()).pushTask(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pushTask</span><span class="params">(ForkJoinTask&lt;&gt; t)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;&gt;[] q; </span><br><span class="line">    <span class="keyword">int</span> s, m;</span><br><span class="line">    <span class="keyword">if</span> ((q = queue) != <span class="keyword">null</span>) &#123; <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="comment">// 计算t放到队列中的位置，即u</span></span><br><span class="line">        <span class="keyword">long</span> u = (((s = queueTop) &amp; (m = q.length - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="comment">// 加入队列</span></span><br><span class="line">        UNSAFE.putOrderedObject(q, u, t);</span><br><span class="line">        queueTop = s + <span class="number">1</span>; <span class="comment">// or use putOrderedInt</span></span><br><span class="line">        <span class="comment">// 激活或创建工作线程</span></span><br><span class="line">        <span class="keyword">if</span> ((s -= queueBase) &lt;= <span class="number">2</span>)</span><br><span class="line">            pool.signalWork();</span><br><span class="line">        <span class="comment">// 队列已满</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == m)</span><br><span class="line">            growQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="forkjointask的join方法">4.6.2 ForkJoinTask的join方法</h5><p><code>Join</code>方法的主要作用是阻塞当前线程并等待获取结果。</p><ul><li>首先通过<code>doJoin()</code>方法得到当前任务的状态。任务状态有4种：<code>已完成（NORMAL）</code>、<code>被取消（CANCELLED）</code>、<code>信号（SIGNAL）</code>和<code>出现异常（EXCEPTIONAL）</code>。<ul><li>如果任务状态是已完成，则直接返回任务状态；</li><li>如果没有执行完，则从任务数组里取出任务并执行；</li><li>如果任务顺利执行完成，则设置任务状态为<code>NORMAL</code>；</li><li>如果出现异常，则记录异常，并将任务状态设置为<code>EXCEPTIONAL</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (doJoin() != NORMAL)</span><br><span class="line">        <span class="keyword">return</span> reportResult();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t; ForkJoinWorkerThread w; <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                completed = exec();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (completed)</span><br><span class="line">                <span class="keyword">return</span> setCompletion(NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w.joinTask(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> externalAwaitDone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">reportResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Throwable ex;</span><br><span class="line">    <span class="comment">// 如果任务状态是被取消，则直接抛出CancellationException</span></span><br><span class="line">    <span class="keyword">if</span> ((s = status) == CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="comment">// 如果任务状态是抛出异常，则直接抛出对应的异常</span></span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.throwException(ex);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;并发编程大师Doug Lea不遗余力地为Java开发者提供了非常多的并发容器和框架&lt;/code&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--5 Java中的锁</title>
    <link href="https://wuyunjie.top/2021/07/19/JavaLearning_The_art_of_concurrent_programming_in_Java-5-Java-lock.html"/>
    <id>https://wuyunjie.top/2021/07/19/JavaLearning_The_art_of_concurrent_programming_in_Java-5-Java-lock.html</id>
    <published>2021-07-19T14:37:39.000Z</published>
    <updated>2021-07-19T14:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。</code> <a id="more"></a></p></blockquote><h3 id="lock接口">1. Lock接口</h3><p><code>Java SE 5</code>之后，<strong>并发包</strong>中新增了<code>Lock</code>接口（以及相关实现类）用来实现锁功能。</p><ul><li>提供了与<code>synchronized</code>关键字类似的同步功能，在使用时需要<strong>显式地</strong>获取和释放锁。</li><li>拥有<strong>锁获取与释放</strong>的<code>可操作性</code>、<code>可中断的获取锁</code>以及<code>超时获取锁</code>等多种synchronized关键字所不具备的同步特性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 保证在获取到锁之后，最终能够被释放</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/LockFeature.PNG" alt="Lock接口提供的主要特性" /><figcaption aria-hidden="true">Lock接口提供的主要特性</figcaption></figure><p>Lock接口定义了锁获取和释放的基本操作：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/LockAPI.PNG" alt="Lock API" /><figcaption aria-hidden="true">Lock API</figcaption></figure><h3 id="队列同步器">2. 队列同步器</h3><p>队列同步器<code>AbstractQueuedSynchronizer</code>，是用来构建锁或者其他同步组件的基础框架。</p><blockquote><p>使用了一个i<strong>nt成员变量</strong>表示<code>同步状态</code>，通过内置的<code>FIFO</code>队列来完成<u>资源获取线程的排队工作</u>。</p></blockquote><p>子类通过继承同步器并实现它的抽象方法来管理同步状态，同步器提供3个方法对同步状态进行更改，保证状态的改变是安全的：</p><ul><li><code>getState()</code>，获取当前同步状态；</li><li><code>setState(int newState)</code>，设置当前同步状态；</li><li><code>compareAndSetState(int expect, int update)</code>，使用CAS设置当前状态，该方法能够保证状态设置的<strong>原子性</strong>。</li></ul><p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义：</p><ul><li>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；</li><li>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</li></ul><h4 id="队列同步器的接口与示例">2.1 队列同步器的接口与示例</h4><p>使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法。同步器可重写的方法如下：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/AQSMethod.PNG" alt="同步器可重写的方法" /><figcaption aria-hidden="true">同步器可重写的方法</figcaption></figure><p>同步器提供的模板方法基本上分为3类：</p><ul><li><p>独占式获取与释放同步状态；</p></li><li><p>共享式获取与释放同步状态；</p></li><li><p>查询同步队列中的等待线程情况。</p></li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/AQSMethodTemplate.PNG" alt="同步器提供的模板方法" /><figcaption aria-hidden="true">同步器提供的模板方法</figcaption></figure><p><code>独占锁</code>是<u><strong>在同一时刻只能有一个线程获取到锁</strong>，而其他获取锁的线程只能处于同步队列中等待</u>，只有获取锁的线程释放了锁，后继的线程才能够获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类，自定义同步器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否处于占用状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当状态为0的时候获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁，将状态设置为0</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅需要将操作代理到Sync上即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用户使用<code>Mutex</code>时并不会直接和内部同步器的实现打交道，而是调用<code>Mutex</code>提供的方法；</li><li>在Mutex的实现中，只需要在方法实现中调用同步器的模板方法即可，当前线程调用该方法获取同步状态失败后会被加入到同步队列中等待。</li></ul><h4 id="队列同步器的实现">2.2 队列同步器的实现</h4><h5 id="同步队列">2.2.1 同步队列</h5><p>同步器依赖内部的同步队列来完成<strong>同步状态的管理</strong>：</p><ul><li>当前线程获取同步状态失败时，同步器会将<strong><u>当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列</u></strong>，同时会阻塞当前线程；</li><li>当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/AQSNode.PNG" alt="同步队列中的节点（Node）" /><figcaption aria-hidden="true">同步队列中的节点（Node）</figcaption></figure><p>同步器拥有<code>首节点（head）</code>和<code>尾节点（tail）</code>，没有成功获取同步状态的线程将会成为节点加入该队列的尾部。</p><ul><li>同步器提供了一个基于<code>CAS</code>的设置尾节点的方法：<code>compareAndSetTail(Node expect, Node update)</code>，需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</li><li>首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是<u><strong>通过获取同步状态成功的线程来完成的</strong></u>，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/SynchronizedQueue.PNG" alt="同步队列" /><figcaption aria-hidden="true">同步队列</figcaption></figure><h5 id="独占式同步状态获取与释放">2.2.2 独占式同步状态获取与释放</h5><p>同步器的<code>acquire(int arg)</code>方法可以获取同步状态，该方法对中断不敏感。主要完成<strong>同步状态获取</strong>、<strong>节点构造</strong>、<strong>加入同步队列</strong>以及<strong>在同步队列中自旋等待</strong>的相关工作。</p><ul><li>首先调用自定义同步器实现的<code>tryAcquire(int arg)</code>方法，该方法保证<strong>线程安全的获取同步状态</strong>；</li><li>如果同步状态获取失败，则构造同步节点（独占式<code>Node.EXCLUSIVE</code>，同一时刻只能有一个线程成功获取同步状态）；</li><li>通过<code>addWaiter(Node node)</code> 方法将该节点加入到同步队列的尾部；</li><li>最后调用<code>acquireQueued(Node node, int arg)</code>方法，使得该节点以<strong>“死循环”</strong>的方式获取同步状态；</li><li>如果获取不到则<u><strong>阻塞节点中的线程</strong></u>，而被阻塞线程的<strong>唤醒</strong><u>主要依靠前驱节点的出队或阻塞线程被中断来实现</u>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 快速尝试在尾部添加</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用 compareAndSetTail 方法来确保节点能够被线程安全添加</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">    pred.next = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同步器通过“死循环”来保证节点的正确添加</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// 通过CAS将节点设置成为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">            tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点进入同步队列之后，就进入了一个自旋的过程</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 只有前驱节点是头节点才能够尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/acquireFlow.PNG" alt="独占式同步状态获取流程" /><figcaption aria-hidden="true">独占式同步状态获取流程</figcaption></figure><p>同步器的<code>release(int arg)</code>方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// unparkSuccessor(Node node)方法使用LockSupport来唤醒处于等待状态的线程。</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="共享式同步状态获取与释放">2.2.3 共享式同步状态获取与释放</h5><p><strong>共享式获取</strong>与<strong>独占式获取</strong>最主要的区别：<u><strong>在于同一时刻能否有多个线程同时获取到同步状态</strong></u>。</p><ul><li>共享式访问资源时，<u>其他<strong>共享式</strong>的访问均被允许</u>，而<strong>独占式</strong>访问被阻塞；</li><li>独占式访问资源时，同一时刻其他访问均被阻塞。</li></ul><p>同步器的<code>acquireShared(int arg)</code>方法可以共享式地获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquireShared 方法尝试获取同步状态，</span></span><br><span class="line">    <span class="comment">// tryAcquireShared 方法返回值为int类型，</span></span><br><span class="line">    <span class="comment">// 当返回值大于等于0时，表示能够获取到同步状态</span></span><br><span class="line"><span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果当前节点的前驱为头节点时，尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 获取同步状态成功，从自旋过程中退出</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            setHeadAndPropagate(node, r);</span><br><span class="line">            p.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用<code>releaseShared(int arg)</code>方法可以释放同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryReleaseShared 必须确保同步状态（或者资源数）线程安全释放，</span></span><br><span class="line">    <span class="comment">// 一般是通过循环和CAS来保证的</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="独占式超时获取同步状态">2.2.4 独占式超时获取同步状态</h5><p>同步器的<code>doAcquireNanos(int arg, long nanosTimeout)</code>方法可以超时获取同步状态，<code>doAcquireNanos</code>方法在<strong><u>支持响应中断</u></strong>的基础上，增加了<u><strong>超时获取</strong></u>的特性。</p><ul><li><strong>支持响应中断</strong>。在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出<code>InterruptedException</code>。</li><li><strong>超时获取</strong>。即在指定的时间段内获取同步状态，如果获取到同步状态则返回<code>true</code>；否则，返回<code>false</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> lastTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 计算时间，当前时间now减去睡眠之前的时间lastTime得到已经睡眠</span></span><br><span class="line">            <span class="comment">// 的时间delta，然后被原有超时时间nanosTimeout减去，得到了</span></span><br><span class="line">            <span class="comment">// 还应该睡眠的时间</span></span><br><span class="line">            nanosTimeout -= now - lastTime;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/doAcquireNanosFlow.PNG" alt="独占式超时获取同步状态流程" /><figcaption aria-hidden="true">独占式超时获取同步状态流程</figcaption></figure><h5 id="自定义同步组件twinslock">2.2.5 自定义同步组件——<code>TwinsLock</code></h5><p><code>TwinsLock</code>要求在同一时刻，只允许<strong><u>至多两个</u></strong>线程同时访问，超过两个线程的访问将被阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count must large than zero."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current - reduceCount;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> returnCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current + returnCount;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步器作为一个桥梁，连接<strong>线程访问</strong>以及<strong>同步状态控制</strong>等底层技术与不同并发组件的接口语义。</p><h3 id="重入锁">3 重入锁</h3><p>重入锁<code>ReentrantLock</code>，即支持重进入的锁，该锁能够支持<u><strong>一个线程对资源的重复加锁</strong></u>。</p><ul><li>在调用<code>lock()</code>方法时，<strong>已经获取到锁</strong>的线程，能够<strong>再次调用</strong><code>lock()</code>方法获取锁而<u>不被阻塞</u>。</li></ul><p>该锁的还支持获取锁时的公平和非公平性选择。</p><ul><li>在<strong>绝对时间</strong>上，先对锁进行获取的请求一定先被满足，那么这个锁是<code>公平</code>的；</li><li>反之，是<code>不公平</code>的。</li></ul><h4 id="实现重进入">3.1 实现重进入</h4><p>重进入是指<u><strong>任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞</strong></u>：</p><ul><li><strong>线程再次获取锁</strong>。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</li><li><strong>锁的最终释放</strong>。线程重复<code>n</code>次获取了锁，随后在第<code>n</code>次释放该锁后，其他线程能够获取到该锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 再次获取同步状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 将同步状态值进行增加并返回true，表示获取同步状态成功</span></span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在释放同步状态时减少同步状态值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公平与非公平获取锁">3.2 公平与非公平获取锁</h4><ul><li>对于非公平锁，<code>nonfairTryAcquire</code>方法，只要<code>CAS</code>设置同步状态成功，则表示当前线程获取了锁；</li><li>对于公平锁，<code>tryAcquire</code>方法为判断条件增加了<code>hasQueuedPredecessors()</code>方法，判断同步队列中当前节点是否有前驱节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察公平和非公平锁在获取锁时的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairAndUnfairTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock fairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock unfairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//    @Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(fairLock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    @Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(unfairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动10个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Job w = <span class="keyword">new</span> Job(lock);</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FairAndUnfairTest test = <span class="keyword">new</span> FairAndUnfairTest();</span><br><span class="line">        test.testLock(fairLock);</span><br><span class="line"><span class="comment">//        test.testLock(unfairLock);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Lock lock;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.print(<span class="string">"Lock by ["</span> + Thread.currentThread().getName() + <span class="string">"], Waiting by ["</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Thread t : ((ReentrantLock2) lock).getQueuedThreads()) &#123;</span><br><span class="line">                    System.out.print(t.getName() + <span class="string">", "</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"]"</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock2</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            List&lt;Thread&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="keyword">super</span>.getQueuedThreads());</span><br><span class="line">            Collections.reverse(arrayList);</span><br><span class="line">            <span class="keyword">return</span> arrayList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平性锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁出现了一个线程连续获取锁的情况。</p><blockquote><p>非公平性锁可能使线程<code>“饥饿”</code>，但被设定成默认的实现</p></blockquote><p>非公平性锁虽然可能造成线程“饥饿”，但线程切换极少，减小了线程上下文切换带来的开销，保证了其更大的吞吐量。</p><h3 id="读写锁">4. 读写锁</h3><p><code>读写锁</code>维护了<strong>一对锁</strong>，一个<code>读锁</code>和一个<code>写锁</code>，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p><ul><li>读操作时获取读锁；</li><li>写操作时获取写锁。写锁被获取到时，后续（非当前写 操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行。</li></ul><p>Java并发包提供读写锁的实现是<code>ReentrantReadWriteLock</code>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ReentrantReadWriteLock.PNG" alt="ReentrantReadWriteLock特性" /><figcaption aria-hidden="true">ReentrantReadWriteLock特性</figcaption></figure><h4 id="读写锁的接口">4.1 读写锁的接口</h4><p><code>ReadWriteLock</code>仅定义了<strong>获取</strong>读锁和写锁的两个方法，即<code>readLock()</code>方法和<code>writeLock()</code>方法；<code>ReentrantReadWriteLock</code>除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ReentrantReadWriteLockMthods.PNG" alt="ReentrantReadWriteLock方法" /><figcaption aria-hidden="true">ReentrantReadWriteLock方法</figcaption></figure><h4 id="读写锁的实现">4.2 读写锁的实现</h4><h5 id="读写状态的设计">4.2.1 读写状态的设计</h5><p>读写锁同样依赖<strong>自定义同步器</strong>来实现同步功能，而<strong>读写状态</strong>就是其同步器的同步状态。</p><ul><li>读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态。</li></ul><p>读写锁将变量切分成了两个部分，<u><strong>高16位表示读</strong>，<strong>低16位表示写</strong></u>。读写锁通过<code>位运算</code>迅速确定读和写各自的状态。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ReadWriteLockStatus.PNG" alt="读写锁状态的划分" /><figcaption aria-hidden="true">读写锁状态的划分</figcaption></figure><h5 id="写锁的获取与释放">4.2.2 写锁的获取与释放</h5><p>写锁是一个支持重进入的<strong>排它锁</strong>。</p><ul><li>如果当前线程已经获取了写锁，则增加写状态。</li><li>如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程， 则当前线程进入等待状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">        <span class="comment">// c != 0 且 w == 0，代表存在读锁</span></span><br><span class="line">    <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 写锁超过最大值</span></span><br><span class="line">    <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">    <span class="comment">// 设置写锁(此时该线程已经获取过写锁，所以无需CAS也是线程安全的)</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为加锁，尝试获取写锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁成功</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写锁的释放与<code>ReentrantLock</code>的释放过程基本类似，每次释放均减少写状态，当写状态为<code>0</code>时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁。</p><h5 id="读锁的获取与释放">4.2.3 读锁的获取与释放</h5><p>读锁是一个支持重进入的<strong>共享锁</strong>。</p><ul><li>能够被<u>多个线程</u>同时获取，在没有其他<u>写线程访问</u>（或者写状态为0）时，读锁总会被成功地获取，只需增加读状态。</li><li>如果当前线程已经获取了<strong>读锁或写锁</strong>，则增加读状态。</li><li>如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</li><li>读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在<code>ThreadLocal</code>中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; c)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="锁降级">4.2.4 锁降级</h5><p><code>锁降级</code>指的是<strong><u>写锁降级成为读锁</u></strong>。线程已经持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程，即<code>锁降级</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">        <span class="comment">// 必须先释放读锁</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">// 锁降级从写锁获取到开始</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">                <span class="comment">// 准备数据的流程（略）</span></span><br><span class="line">                update = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            readLock.lock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 锁降级完成，写锁降级为读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">// 使用数据的流程（略）</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁降级中读锁的获取主要是为了保证数据的可见性。</p><ul><li>如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。</li><li>如果当前线程获取读锁，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进 行数据更新。</li></ul><h3 id="locksupport工具">5. <code>LockSupport</code>工具</h3><p>当需要<strong>阻塞</strong>或<strong>唤醒</strong>一个线程的时候，都会使用<code>LockSupport</code>工具类来完成相应工作。<code>LockSupport</code>定义了一组的<strong><u>公共静态方法</u></strong>，这些方法提供了最基本的线程阻塞和唤醒功能，而<code>LockSupport</code>也成为构建同步组件的基础工具。</p><ul><li>以<code>park</code>开头的方法用来<strong><u>阻塞当前线程</u></strong>；</li><li><code>unpark(Thread thread)</code> 方法来<u><strong>唤醒一个被阻塞的线程</strong></u>。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/LockSupportMethods.PNG" alt="读写锁状态的划分" /><figcaption aria-hidden="true">读写锁状态的划分</figcaption></figure><p><code>Java 6</code>中，<code>LockSupport</code>增加了<code>park(Object blocker)</code>、<code>parkNanos(Object blocker, long nanos)</code>和<code>parkUntil(Object blocker, long deadline)</code>3个方法，用于实现阻塞当前线程的功能，其中参数<code>blocker</code>是用来<u><strong>标识当前线程在等待的对象</strong></u>（以下称为阻塞对象）。</p><h3 id="condition接口">6. <code>Condition</code>接口</h3><p><code>Condition</code>接口也提供了类似<code>Object</code>的<strong>监视器</strong>方法，与<code>Lock</code>配合可以实现等待/通知模式。</p><h4 id="condition接口与示例">6.1 Condition接口与示例</h4><p><code>Condition</code>定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要<strong><u>提前获取</u></strong>到<code>Condition</code>对象关联的锁。<code>Condition</code>对象是由<code>Lock</code>对象（调用Lock对象的<code>newCondition()</code>方法）创建出来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 一般都会将Condition对象作为成员变量</span></span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用await()方法后，当前线程会释放锁并在此等待</span></span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 其他线程调用Condition对象的signal()方法，</span></span><br><span class="line">        <span class="comment">// 通知当前线程后，当前线程才从await()方法返回，</span></span><br><span class="line">        <span class="comment">// 并且在返回前已经获取了锁。</span></span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ConditionMethods.PNG" alt="Condition的方法" /><figcaption aria-hidden="true">Condition的方法</figcaption></figure><p>基于<code>Condition</code>实现的有界队列：</p><ul><li>当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素；</li><li>当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] items;</span><br><span class="line">    <span class="comment">// 添加的下标，删除的下标和数组当前数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addIndex, removeIndex, count;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个元素，如果数组满，则添加线程进入等待状态，直到有"空位"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[addIndex] = t;</span><br><span class="line">            <span class="keyword">if</span> (++addIndex == items.length)</span><br><span class="line">                addIndex = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[removeIndex];</span><br><span class="line">            <span class="keyword">if</span> (++removeIndex == items.length)</span><br><span class="line">                removeIndex = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> (T) x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="condition的实现">6.2 Condition的实现</h4><p><code>ConditionObject</code>是同步器<code>AbstractQueuedSynchronizer</code>的内部类。每个<code>Condition</code>对象都包含着一个队列（等待队列），该队列是<code>Condition</code>对象实现<strong><u>等待/通知功能</u></strong>的关键。</p><h5 id="等待队列">6.2.1 等待队列</h5><p>等待队列是一个<code>FIFO</code>的队列，在队列中的每个节点都包含了一个<strong><code>线程引用</code></strong>，该线程就是在<code>Condition</code>对象上等待的线程：</p><ul><li>同步队列和等待队列中节点类型都是同步器的静态内部类<code>AbstractQueuedSynchronizer.Node</code>。</li><li><code>Lock</code>（同步器）拥有一个同步队列和多个等待队列</li></ul><p>同理，<code>Condition</code>拥有<code>首节点（firstWaiter）</code>和<code>尾节点（lastWaiter）</code>。</p><ul><li>当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。节点引用更新的过程并<strong><u>没有使用</u></strong><code>CAS</code>保证，原因在于调用<code>await()</code>方法的线程必定是获取了锁的线程。</li></ul><h5 id="等待">6.2.2 等待</h5><p>调用<code>Condition</code>的<code>await()</code>方法，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。从await()方法返回时，当前线程<u><strong>一定获取了<code>Condition</code>相关联的锁</strong></u>。</p><ul><li>被唤醒后的线程，将从<code>await()</code>方法中的while循环中退出（<code>isOnSyncQueue(Node node)</code>方法返回true，节点已经在同步队列中）；</li><li>进而调用同步器的<code>acquireQueued()</code>方法加入到获取同步状态的竞争中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程加入等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步状态，也就是释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于<u><strong>同步队列的<code>首节点</code>（获取了锁的节点）移动到Condition的<code>等待队列</code>中</strong></u>。</p><h5 id="通知">6.2.3 通知</h5><p>调用Condition的<code>signal()</code>方法，将会唤醒在等待队列中<u><strong>等待时间最长</strong></u>的节点（<code>首节点</code>），在唤醒节点之前，会将节点移到同步队列中。</p><ul><li>调用该方法的前置条件是当前线程必须获取了锁；</li><li>通过调用同步器的<code>enq(Node node)</code>方法，等待队列中的头节点线程安全地移动到同步队列。</li><li>当节点移动到同步队列后，当前线程再使用<code>LockSupport</code>唤醒该节点的线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用该方法的前置条件是当前线程必须获取了锁</span></span><br><span class="line"><span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line"><span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。&lt;/code&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--4  Java并发编程基础</title>
    <link href="https://wuyunjie.top/2021/07/18/JavaLearning_The_art_of_concurrent_programming_in_Java-4-Java-concurrent-programming-basics.html"/>
    <id>https://wuyunjie.top/2021/07/18/JavaLearning_The_art_of_concurrent_programming_in_Java-4-Java-concurrent-programming-basics.html</id>
    <published>2021-07-18T14:31:47.000Z</published>
    <updated>2021-07-18T14:31:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>线程作为操作系统调度的最小单元，多个线程能够同时执行，这将显著提升程序性能，在多核环境中表现得更加明显。</code> <a id="more"></a></p></blockquote><h3 id="线程简介">1. 线程简介</h3><h4 id="线程定义">1.1 线程定义</h4><p>现代操作系统<strong>调度的最小单元</strong>是线程，也叫<code>轻量级进程（Light Weight Process）</code>，在一个进程里可以创建多个线程，这些线程都拥有<u>各自的计数器、堆栈和局部变量</u>等属性，并且能够访问共享的内存变量。</p><blockquote><p>Java程序<u>天生就是多线程程序</u>，因为执行<code>main()</code>方法的是一个名称为main的线程。</p></blockquote><p>一个Java程序的运行是main线程和多个其他线程的同时运行。</p><h4 id="多线程">1.2 多线程</h4><p>使用多线程的原因主要有以下几点：</p><ol type="1"><li><strong>更多的处理器核心</strong>。使用多线程技术将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。</li><li><strong>更快的响应时间</strong>。使用多线程技术，将数据一致性不强的操作派发给其他线程处理，缩短响应时间。</li><li><strong>更好的编程模型</strong>。</li></ol><h4 id="线程优先级">1.3 线程优先级</h4><p>线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。在Java线程中，通过一个整型成员变量<code>priority</code>来控制优先级，优先级的范围从<code>1~10</code>，在线程构建的时候可以通过<code>setPriority(int)</code>方法来修改优先级，默认优先级是<code>5</code>。</p><blockquote><p>优先级只是一个建议，实际执行时可能会忽略对线程优先级的设定。</p></blockquote><h4 id="线程的状态">1.4 线程的状态</h4><p>Java线程在运行的生命周期中可能处于<code>6</code>种不同的状态，且在给定的一个时刻，线程<u><strong>只能处于其中的一个状态</strong></u>：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter4/threadState.PNG" alt="线程状态" /><figcaption aria-hidden="true">线程状态</figcaption></figure><p>可以使用<code>jps</code>查看进程<code>ID</code>，然后用<code>"jstack 进程ID"</code>查看运行时的线程信息。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter4/threadStateChange.PNG" alt="Java线程状态变迁" /><figcaption aria-hidden="true">Java线程状态变迁</figcaption></figure><h4 id="daemon线程">1.5 Daemon线程</h4><p><code>Daemon</code>线程是一种<strong>支持型线程</strong>，因为它主要被用作程序中<u>后台调度以及支持性工作</u>。</p><blockquote><p>当一个Java虚拟机中<strong>不存在非Daemon线程</strong>的时候，Java虚拟机将会退出。</p></blockquote><p>通过调用<code>Thread.setDaemon(true)</code>将线程设置为Daemon线程，<u>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置</u>。</p><blockquote><p>在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</p></blockquote><p>实际上经过测试，甚至Daemon线程中<code>run()</code>内的代码都不一定会被执行，。main线程（非 Daemon线程）在启动了线程<code>DaemonRunner</code>之后随着main方法执行完毕而终止，而此时Java虚拟机中已经没有非Daemon线程，虚拟机需要退出。Java虚拟机中的所有Daemon线程都需要立即终止，因此<code>DaemonRunner</code>立即终止，但是<code>DaemonRunner</code>中的finally块并没有执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(), <span class="string">"DaemonRunner"</span>);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"DaemonThread finally run."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"DaemonThread finally run."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"DaemonThread finally run."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动和终止线程">2. 启动和终止线程</h3><h4 id="构造线程">2.1 构造线程</h4><p>线程对象在构造的时候需要提供线程所需要的属性，如线程所属的<strong>线程组</strong>、<strong>线程优先级</strong>、<strong>是否是Daemon线程</strong>等信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程就是该线程的父线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将daemon、priority属性设置为父线程的对应属性</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将父线程的InheritableThreadLocal复制过来</span></span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">// 分配一个线程ID</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个新构造的线程对象是由其parent线程来进行空间分配的。</p><h4 id="启动线程">2.2 启动线程</h4><p>线程对象在初始化完成之后，调用<code>start()</code>方法启动这个线程：<u><strong>当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用<code>start()</code>方法的线程</strong></u>。</p><h4 id="中断">2.3 中断</h4><p><code>中断</code>可以理解为线程的一个<strong>标识位属性</strong>，它表示<u>一个运行中的线程是否被其他线程进行了中断操作</u>。</p><ul><li>其他线程通过调用该线程的<code>interrupt()</code>方法对其进行中断操作；</li><li>线程通过方法<code>isInterrupted()</code>来进行判断自身是否被中断；<ul><li>如果该线程已经处于<strong><u>终结状态</u></strong>，即使该线程被中断过，在调用该线程对象的<code>isInterrupted()</code>时依旧会返回<code>false</code>；</li><li>方法在抛出<code>InterruptedException</code>之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出<code>InterruptedException</code>，此时调用<code>isInterrupted()</code>方法将会返回<code>false</code>。</li></ul></li><li>可以调用静态方法<code>Thread.interrupted()</code>对当前线程的中断标识位进行复位；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeWaiting(), <span class="string">"TimeWaitingThread"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Waiting(), <span class="string">"WaitingThread"</span>).start();</span><br><span class="line">        <span class="comment">// 使用两个Blocked线程，一个获取锁成功，另一个被阻塞</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该线程不断地进行睡眠</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该线程在Waiting.class实例上等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Waiting<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Waiting<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该线程在Blocked.class实例上加锁后，不会释放该锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Blocked<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(<span class="keyword">long</span> seconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过期deprecated的suspendresume和stop">2.4 过期(<code>deprecated</code>)的<code>suspend()</code>、<code>resume()</code>和<code>stop()</code></h4><p><code>suspend()</code>、<code>resume()</code>和<code>stop()</code>方法完成线程的<strong>暂停</strong>、<strong>恢复</strong>和<strong>终止</strong>工作。但是这些<code>API</code>是过期的，已经不建议使用，因为这些方法会带来副作用：</p><ul><li>在调用<code>suspend()</code>后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发<strong>死锁问题</strong>；</li><li><code>stop()</code>方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</li></ul><h4 id="安全地终止线程">2.5 安全地终止线程</h4><p>中断操作是一种适合用来取消或停止任务的交互方式。除了中断以外，还可以利用一个boolean变量来控制<u>是否需要停止任务并终止该线程</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shutdown</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread countThread = <span class="keyword">new</span> Thread(one, <span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line"></span><br><span class="line">        Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">        countThread = <span class="keyword">new</span> Thread(two, <span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Count i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种通过<strong>标识位</strong>或者<strong>中断操作</strong>的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止。</p><h3 id="线程间通信">3. 线程间通信</h3><h4 id="volatile和synchronized关键字">3.1 <code>volatile</code>和<code>synchronized</code>关键字</h4><ul><li>关键字<code>volatile</code>可以用来修饰字段（成员变量），告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</li><li>关键字<code>synchronized</code>可以修饰方法或者以同步块的形式来进行使用，它确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</li></ul><h4 id="等待通知机制">3.2 等待/通知机制</h4><p>等待/通知的相关方法是<u><strong>任意Java对象都具备的</strong></u>，因为这些方法被定义在所有对象的超类<code>java.lang.Object</code>上。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter4/WaitAndNotify.PNG" alt="等待/通知方法" /><figcaption aria-hidden="true">等待/通知方法</figcaption></figure><p>等待/通知机制通过对象O来完成线程之间的交互：</p><ul><li>一个线程A调用了对象O的<code>wait()</code>方法进入等待状态；</li><li>另一个线程B调用了对象O的<code>notify()</code>或者<code>notifyAll()</code>方法，线程A收到通知后从对象O的<code>wait()</code>方法返回，进而执行后续操作。</li><li>对象上的<code>wait()</code>和<code>notify/notifyAll()</code>的关系就如同开关信号，用来完成等待方和通知方之间的交互工作。</li></ul><p>调用<code>wait()</code>、<code>notify()</code>以及<code>notifyAll()</code>时需要注意的细节：</p><ol type="1"><li>使用<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>时需要先对调用<strong>对象加锁</strong>。</li><li>调用<code>wait()</code>方法后，线程状态由<code>RUNNING</code>变为<code>WAITING</code>，并将当前线程放置到对象的等待队列。</li><li><code>notify()</code>或<code>notifyAll()</code>方法调用后，<u><strong>等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回</strong></u>。</li><li><code>notify()</code>方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而<code>notifyAll()</code>方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为 BLOCKED。</li><li>从<code>wait()</code>方法返回的<strong>前提</strong>是<u>获得了调用对象的锁</u>。</li></ol><h4 id="等待通知的经典范式">3.3 等待/通知的经典范式</h4><p><strong>等待/通知的经典范式</strong>分为两部分，分别针对<strong>等待方（消费者）</strong>和<strong>通知方（生产者）</strong>：</p><ul><li><strong>等待方</strong>遵循如下原则：<ol type="1"><li>获取对象的锁；</li><li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件；</li><li>条件满足则执行对应的逻辑；</li></ol></li><li><strong>通知方</strong>遵循如下原则：<ol type="1"><li>获得对象的锁；</li><li>改变条件；</li><li>通知所有等待在对象上的线程。</li></ol></li></ul><h4 id="管道输入输出流">3.4 管道输入/输出流</h4><p>管道输入/输出流主要用于<strong>线程</strong>之间的数据传输，而<u>传输的媒介为内存</u>。主要包括4种具体实现：</p><ul><li>面向字节：<code>PipedOutputStream</code>、<code>PipedInputStream</code></li><li>面向字符：<code>PipedReader</code>、<code>PipedWriter</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        <span class="comment">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</span></span><br><span class="line">        out.connect(in);</span><br><span class="line"></span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">"PrintThread"</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader in;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="thread.join的使用">3.5 <code>Thread.join()</code>的使用</h4><p>一个线程A执行<code>thread.join()</code>后，当前线程A等待thread线程终止之后才从<code>thread.join()</code>返回。线程Thread除了提供<code>join()</code>方法之外，还提供了<code>join(long millis)</code>和<code>join(long millis, int nanos)</code>两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁当前线程对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 条件不满足，继续等待</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件符合，方法返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="threadlocal的使用">3.6 <code>ThreadLocal</code>的使用</h4><p><code>ThreadLocal</code>，即线程变量，是一个<u>以<code>ThreadLocal</code>对象为<strong>键</strong></u>、<u>任意对象为<strong>值</strong></u>的存储结构。一个线程可以根据一个<code>ThreadLocal</code>对象查询到绑定在这个线程上的一个值。</p><ul><li>可以通过<code>set(T)</code>方法来设置一个值；</li><li>在当前线程下再通过<code>get()</code>方法获取到原先设置的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程应用实例">4. 线程应用实例</h3><h4 id="等待超时模式">4.1 等待超时模式</h4><p>在<strong>等待/通知的经典范式</strong>上加入<strong>超时等待</strong>，可以使得该模式更具有灵活性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对当前对象加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line"><span class="keyword">long</span> remaining = mills;</span><br><span class="line">    <span class="comment">// 当超时大于0并且result返回值不满足要求</span></span><br><span class="line">    <span class="keyword">while</span> ((result == <span class="keyword">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    wait(remaining);</span><br><span class="line">        remaining = future - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据库连接池示例">4.2 数据库连接池示例</h4><p>使用等待超时模式来构造一个简单的<code>数据库连接池</code>，从连接池中<strong>获取</strong>、<strong>使用</strong>和<strong>释放连接</strong>，而客户端获取连接的过程被设定为等待超时的模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">                <span class="comment">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span></span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在mills内无法获取到连接，将会返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">            <span class="comment">// 完全超时</span></span><br><span class="line">            <span class="keyword">if</span> (mills &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty()) &#123;</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">                <span class="keyword">long</span> remaining = mills;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                Connection result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (!pool.isEmpty()) &#123;</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在资源一定的情况下（连接池中的10个连接），随着客户端线程的逐步增加，客户端出现超时无法获取连接的比率会不断升高。</p><h4 id="线程池技术及其示例">4.3 线程池技术及其示例</h4><p>对于服务端的程序，经常面对的是客户端传入的<strong>短小（执行时间短、工作内容较为单一）</strong>任务，需要服务端快速处理并返回结果。如果采用一个任务一个线程的方式，任务过多时会创建大量线程，线程上下文切换会增加系统的负载。</p><p><code>线程池技术</code>预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。</p><ul><li>一方面，消除了频繁创建和消亡线程的系统资源开销；</li><li>另一方面，面对过量任务的提交能够平缓的劣化。</li></ul><p>一个简单的线程池接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 执行一个Job，这个Job需要实现Runnable</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 增加工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 减少工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 得到正在等待执行的任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端可以通过<code>execute(Job)</code>方法将<code>Job</code><strong><u>提交入线程池执行</u></strong>，而客户端自身不用等待<code>Job</code>的执行完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 线程池最大限制数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 线程池默认的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 线程池最小的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这是一个工作列表，将会向里面插入工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;Job&gt;();</span><br><span class="line">    <span class="comment">// 工作者列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Worker&gt;());</span><br><span class="line">    <span class="comment">// 工作者线程的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">    <span class="comment">// 线程编号生成</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong threadNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initializeWokers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;</span><br><span class="line">        initializeWokers(workerNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加一个工作，然后进行通知</span></span><br><span class="line">            <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="comment">// 限制新增的Worker数量不能超过最大值</span></span><br><span class="line">            <span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWokers(num);</span><br><span class="line">            <span class="keyword">this</span>.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="keyword">this</span>.workerNum) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"beyond workNum"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 按照给定的数量停止Worker</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程工作者</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWokers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">"ThreadPool-Worker-"</span> + threadNum.incrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作者，负责消费任务</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否工作</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                    <span class="comment">// 如果工作者列表是空的，那么就wait</span></span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                            <span class="comment">// 感知到外部对WorkerThread的中断操作，返回</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 取出一个Job</span></span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        job.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        <span class="comment">// 忽略Job执行中的Exception</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的本质就是使用了一个线程安全的工作队列连接工作者线程和客户端线程：</p><ul><li>客户端线程将任务放入工作队列后便返回；</li><li>工作者线程则不断地从工作队列上取出工作并执行。</li></ul><h4 id="基于线程池技术的简单web服务器">4.4 基于线程池技术的简单Web服务器</h4><p>常用的Java Web服务器，如<code>Tomcat</code>、<code>Jetty</code>，在其处理请求的过程中都使用到了线程池技术。</p><p>构造一个简单的Web服务器，这个Web服务器用来处理<code>HTTP</code>请求，使用<code>main</code>线程不断地接受客户端<code>Socket</code>的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理HttpRequest的线程池</span></span><br><span class="line">    <span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool&lt;HttpRequestHandler&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// SimpleHttpServer的根路径</span></span><br><span class="line">    <span class="keyword">static</span> String basePath;</span><br><span class="line">    <span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="comment">// 服务监听端口</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (port &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span><span class="params">(String basePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (basePath != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> File(basePath).exists() &amp;&amp; <span class="keyword">new</span> File(basePath).isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动SimpleHttpServer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">            InputStream in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 由相对路径计算出绝对路径</span></span><br><span class="line">                String filePath = basePath + header.split(<span class="string">" "</span>)[<span class="number">1</span>];</span><br><span class="line">                out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">"jpg"</span>) || filePath.endsWith(<span class="string">"ico"</span>)) &#123;</span><br><span class="line">                    in = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: image/jpeg"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Length: "</span> + array.length);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(filePath)));</span><br><span class="line">                    out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: text/html; charset=UTF-8"</span>);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                out.println(<span class="string">"HTTP/1.1 500"</span>);</span><br><span class="line">                out.println(<span class="string">""</span>);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(br, in, reader, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭流或者Socket</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeables != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable closeable : closeables) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SimpleHttpServer</code>在建立了与客户端的连接之后，并不会处理客户端的请求，而是将其包装成<code>HttpRequestHandler</code>并交由线程池处理。启动服务的测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHttpServer newSever = <span class="keyword">new</span> SimpleHttpServer();</span><br><span class="line">        newSever.setBasePath(<span class="string">"..\\src\\Concurrency\\Chapter4\\DefaultThreadPool"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newSever.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<code>Apache HTTP server benchmarking tool</code>来测试不同线程数下，<code>SimpleHttpServer</code>的吞吐量表现。</p><blockquote><p><a href="https://www.cnblogs.com/cjsblog/p/9038838.html" target="_blank" rel="noopener">Apache HTTP server benchmarking tool</a>是服务器压力测试工具，可以参考链接查看使用方法。</p></blockquote><p>随着线程池中线程数量的增加，<code>SimpleHttpServer</code>响应时间不断变小。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;线程作为操作系统调度的最小单元，多个线程能够同时执行，这将显著提升程序性能，在多核环境中表现得更加明显。&lt;/code&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--3 Java内存模型</title>
    <link href="https://wuyunjie.top/2021/07/17/JavaLearning_The_art_of_concurrent_programming_in_Java-3-Java-memory-model.html"/>
    <id>https://wuyunjie.top/2021/07/17/JavaLearning_The_art_of_concurrent_programming_in_Java-3-Java-memory-model.html</id>
    <published>2021-07-17T08:14:02.000Z</published>
    <updated>2021-07-17T08:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>Java线程之间的通信对程序员完全透明，内存可见性问题很容易困扰Java程序员</code> <a id="more"></a></p></blockquote><h3 id="java内存模型的基础">1. <code>Java</code>内存模型的基础</h3><h4 id="并发编程模型的两个关键问题">1.1 并发编程模型的两个关键问题</h4><p>在并发编程中，需要处理两个关键问题：</p><ul><li><strong>线程之间如何通信</strong>。线程之间的通信机制有两种：<code>共享内存</code>和<code>消息传递</code>。<ul><li><code>共享内存</code>是线程之间共享程序的公共状态，通过<u>写-读内存中的公共状态</u>进行<strong>隐式</strong>通信。</li><li><code>消息传递</code>是线程之间通过<u>发送消息</u>来<strong>显式</strong>进行通信。</li></ul></li><li><strong>线程之间如何同步</strong>。<ul><li>在<code>共享内存</code>并发模型里，同步是<strong>显式</strong>进行的。必须显式指定某个方法或某段代码需要在线程之间互斥执行。</li><li>在<code>消息传递</code>并发模型里，同步是<strong>隐式</strong>进行的。消息的发送必须在消息的接收之前。</li></ul></li></ul><p>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行。</p><h4 id="java内存模型的抽象结构">1.2 Java内存模型的抽象结构</h4><p>Java中所有<code>实例域</code>、<code>静态域</code>和<code>数组元素</code>都存储在<strong>堆内存</strong>中，<strong><u>堆内存在线程之间共享</u></strong>。Java内存模型（为<code>JMM</code>）<u>决定一个线程对共享变量的写入何时对另一个线程可见</u>。<code>JMM</code>定义了线程和主内存之间的抽象关系：</p><blockquote><p>线程之间的共享变量存储在<code>主内存（Main Memory）</code>中，每个线程都有一个私有的<code>本地内存（Local Memory）</code>，本地内存中存储了该线程以读/写共享变量的副本。本地内存是<code>JMM</code>的一个<strong>抽象概念</strong>，并不真实存在。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/JMMStructure.PNG" alt="Java内存模型的抽象结构" /><figcaption aria-hidden="true">Java内存模型的抽象结构</figcaption></figure><p>Java线程之间的通信过程必须要经过<code>主内存</code>。<code>JMM</code>通过控制主内存与每个线程的本地内存之间的交互，来提供<strong>内存可见性保证</strong>。</p><h4 id="从源代码到指令序列的重排序">1.3 从源代码到指令序列的重排序</h4><p>为了提高性能，编译器和处理器常常会对指令做<code>重排序</code>。<code>重排序</code>分3种类型：</p><ol type="1"><li><code>编译器优化的重排序</code>。<strong>编译器</strong>在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li><code>指令级并行的重排序</code>。现代<strong>处理器</strong>采用了<code>指令级并行技术（Instruction-Level Parallelism，ILP）</code>来<u>将多条指令重叠执行</u>。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li><code>内存系统的重排序</code>。由于<strong>处理器</strong>使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>重排序可能会导致<strong>多线程程序</strong>出现<strong>内存可见性问题</strong>。JMM属于<u>语言级</u>的内存模型，通过<u>禁止<strong>特定类型</strong>的编译器重排序和处理器重排序，提供一致的内存可见性保证</u>。</p><h4 id="并发编程模型的分类">1.4 并发编程模型的分类</h4><p>现代的处理器使用<strong>写缓冲区</strong>临时保存<u>向内存写入的数据</u>，它可以</p><ul><li>避免由于处理器停顿下来<u>等待向内存写入数据而产生的延迟</u>。</li><li>以<strong>批处理</strong>的方式刷新写缓冲区，合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。</li></ul><p>每个处理器上的写缓冲区，仅仅对它所在的处理器可见，这会它会导致<u>处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致</u>。为了保证<strong>内存可见性</strong>，Java编译器在生成指令序列的适当位置会插入<code>内存屏障</code>指令来<u>禁止特定类型的处理器重排序</u>。<code>JMM</code>把内存屏障指令分为4类：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/MemoryBarriers.PNG" alt="内存屏障类型" /><figcaption aria-hidden="true">内存屏障类型</figcaption></figure><p><code>StoreLoad Barriers</code>是一个<code>“全能型”</code>的屏障，同时具有其他3个屏障的效果。但<u>执行该屏障开销会很昂贵</u>，因为当前处理器通常要把写缓冲区中的数据<code>全部刷新到内存中（Buffer Fully Flush）</code>。</p><h4 id="happens-before">1.5 <code>happens-before</code></h4><p><code>happens-before</code>用于表示操作之间的<code>内存可见性</code>。在<code>JMM</code>中，如果<u>一个操作执行的<strong>结果</strong>需要对另一个操作可见</u>，那么这两个操作之间必须要存在<code>happens-before</code>关系。</p><ul><li><code>程序顺序规则</code>：一个线程中的每个操作，<code>happens-before</code>于该线程中的任意后续操作。</li><li><code>监视器锁规则</code>：对一个锁的解锁，<code>happens-before</code>于随后对这个锁的加锁。</li><li><code>volatile变量规则</code>：对一个volatile域的写，<code>happens-before</code>于任意后续对这个volatile域的读。</li><li><code>传递性</code>：如果A <code>happens-before</code> B，且B <code>happens-before</code> C，那么A <code>happens-before</code> C。</li></ul><p>一个<code>happens-before</code>规则对应于一个或多个<strong>编译器和处理器重排序规则</strong>。</p><h3 id="重排序">2. 重排序</h3><h4 id="数据依赖性">2.1 数据依赖性</h4><p>如果两个操作访问<strong>同一个变量</strong>，且这两个操作中<strong>有一个为写操作</strong>，此时这两个操作之间就存在<code>数据依赖性</code>。只要重排序两个操作的执行顺序，程序的执行结果就会被改变。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/DataDependency.PNG" alt="数据依赖类型" /><figcaption aria-hidden="true">数据依赖类型</figcaption></figure><p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p><h4 id="as-if-serial语义">2.2 <code>as-if-serial</code>语义</h4><p><code>as-if-serial</code>语义的意思是：不管怎么重排序，（单线程）程序的执行结果不能被改变。如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><h4 id="程序顺序规则">2.3 程序顺序规则</h4><p>如果<code>A happens-before B</code>，<code>JMM</code>并不要求A一定要在B之前执行。JMM仅仅要求<u>前一个操作（执行的结果）对后一个操作可见</u>，且<u>前一个操作按顺序排在第二个操作之前</u>。</p><p>若操作A的执行结果<strong>不需要对操作B可见</strong>，而且重排序操作A和操作B后的执行结果，与操作A和操作B按<code>happens-before</code>顺序<strong>执行的结果一致</strong>，<code>JMM</code>会允许这种重排序。</p><h4 id="重排序对多线程的影响">2.4 重排序对多线程的影响</h4><p>重排序可能会改变多线程程序的执行结果。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Public <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f?lag) &#123; <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">int</span> i = a * a; <span class="comment">// 4</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序。如果操作1和操作2做了重排序，程序执行时</p><ul><li>线程A首先写标记变量<code>flag</code>；</li><li>随后线程B读变量<code>flag</code>；</li><li>由于条件判断为真，线程B将读取变量<code>a</code>。此时，变量<code>a</code>还没有被线程A写入，此时多线程程序的语义被重排序破坏。</li></ul><p>同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。操作3和操作4存在<code>控制依赖关系</code>。编译器和处理器会采用<code>猜测（Speculation）执行</code>来克服控制相关性<u>对并行度的影响</u>。</p><ul><li>执行线程B的处理器可以提前读取并计算<code>a*a</code>；</li><li>然后把计算结果临时保存到一个名为<code>重排序缓冲（Reorder Buffer，ROB）</code>的<strong>硬件缓存</strong>中；</li><li>当操作3的条件判断为真时，就把该计算结果写入变量<code>i</code>中。在此时，重排序也破坏了多线程程序的语义。</li></ul><h3 id="顺序一致性">3. 顺序一致性</h3><h4 id="数据竞争与顺序一致性">3.1 数据竞争与顺序一致性</h4><p><code>Java内存模型规范</code>把<code>数据竞争</code>的定义为：</p><blockquote><p><strong>在一个线程中写一个变量，另一个线程读同一个变量，而且写和读没有通过同步来排序。</strong></p></blockquote><p><code>JMM</code>对正确同步的多线程程序的内存一致性保证：</p><blockquote><p>如果程序是正确同步的，程序的执行将具有<code>顺序一致性（Sequentially Consistent）</code>——即<u>程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同</u>。</p></blockquote><h4 id="顺序一致性内存模型">3.2 顺序一致性内存模型</h4><p>顺序一致性内存模型有两大特性：</p><ol type="1"><li>一个线程中的所有操作必须<u>按照程序的顺序来执行</u>。</li><li>（不管程序是否同步）所有线程都<u>只能看到一个单一的操作执行顺序</u>。在顺序一致性内存模型中，每个操作都必须<strong>原子执行且立刻对所有线程可见</strong>。</li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/SequentiallyConsistent.PNG" alt="顺序一致性内存模型" /><figcaption aria-hidden="true">顺序一致性内存模型</figcaption></figure><p>顺序一致性内存模型是一个<strong>理论参考模型</strong>，在概念上顺序一致性模型有一个<u><strong>单一的全局内存</strong></u>，这个内存通过一个<u>左右摆动的开关</u>可以连接到任意一个线程，同时每一个线程<strong>必须按照程序的顺序</strong>来执行内存读/写操作。</p><p>未同步程序在<code>JMM</code>中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。</p><ul><li>在当前线程把写过的数据缓存在<code>本地内存</code>中，在没有刷新到<code>主内存</code>之前，这个写操作仅对当前线程可见；</li><li>从其他线程的角度来观察，会认为这个写操作根本没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。</li><li>当前线程和其他线程看到的操作执行顺序将不一致。</li></ul><h4 id="同步程序的顺序一致性效果">3.3 同步程序的顺序一致性效果</h4><ul><li><p>顺序一致性模型中，所有操作完全按程序的顺序串行执行。</p></li><li><p>而在<code>JMM</code>中，<u>临界区内的代码可以重排序</u>（但JMM不允许临界区内的代码<code>“逸出”</code>到临界区之外，那样会破坏监视器的语义）。虽然线程A在临界区内做了重排序，但由于<u>监视器互斥执行</u>的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。</p></li></ul><h4 id="未同步程序的执行特性">3.4 未同步程序的执行特性</h4><p>对于未同步或未正确同步的多线程程序，<code>JMM</code>只提供<u><strong>最小安全性</strong></u>：</p><blockquote><p>线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，Null，False），JMM保证<u><strong>线程读操作读取到的值不会<code>无中生有（Out Of Thin Air）</code>的冒出来</strong></u>。</p></blockquote><p>JMM不保证未同步程序的<strong>执行结果</strong>与该程序在顺序一致性模型中的执行结果一致，整体上是无序的，其执行结果无法预知。两个模型中的执行特性有如下几个差异：</p><ol type="1"><li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行。</li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。</li><li>JMM不保证对64位的<code>long</code>型和<code>double</code>型变量的<code>写操作</code>具有<strong>原子性</strong>，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li></ol><h3 id="volatile的内存语义">4. <code>volatile</code>的内存语义</h3><h4 id="volatile的特性">4.1 volatile的特性</h4><p>理解<code>volatile</code>特性的一个好方法是把对<code>volatile</code>变量的单个读/写，看成是使用<strong>同一个锁</strong>对这些<strong>单个读/写操作</strong>做了同步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> vl = <span class="number">0L</span>; <span class="comment">// 使用volatile声明64位的long型变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">vl = l; <span class="comment">// 单个volatile变量的写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">vl++; <span class="comment">// 复合（多个）volatile变量的读/写</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vl; <span class="comment">// 单个volatile变量的读</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个程序在语义上等价。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> vl = <span class="number">0L</span>; <span class="comment">// 64位的long型普通变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123; <span class="comment">// 对单个的普通变量的写用同一个锁同步</span></span><br><span class="line">vl = l;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123; <span class="comment">// 普通方法调用</span></span><br><span class="line">        <span class="keyword">long</span> temp = get(); <span class="comment">// 调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>; <span class="comment">// 普通写操作</span></span><br><span class="line">        set(temp); <span class="comment">// 调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// 对单个的普通变量的读用同一个锁同步</span></span><br><span class="line">        <span class="keyword">return</span> vl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>volatile</code>变量自身具有下列特性：</p><ul><li><strong>可见性</strong>。锁的<code>happens-before</code>规则保证释放锁和获取锁的两个线程之间的<strong>内存可见性</strong>，这意味着对一个<code>volatile</code>变量的读，总是能看到（任意线程）对这个<code>volatile</code>变量<u><strong>最后的写入</strong></u>。</li><li><strong>原子性</strong>。锁的语义决定了临界区代码的执行具有<strong>原子性</strong>，对任意单个volatile变量的读/写具有原子性。</li></ul><h4 id="volatile写-读建立的happens-before关系">4.2 <code>volatile</code>写-读建立的<code>happens-before</code>关系</h4><p><code>volatile</code>变量的<strong>写-读</strong>可以实现线程之间的通信。<code>volatile</code>的<strong>写-读</strong>与<code>锁</code>的<strong>释放-获取</strong>有相同的内存效果：</p><ul><li><code>volatile写</code>和<code>锁的释放</code>有相同的内存语义；</li><li><code>volatile读</code>与<code>锁的获取</code>有相同的内存语义。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123; <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">int</span> i = a; <span class="comment">// 4</span></span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A执行<code>writer()</code>方法之后，线程B执行<code>reader()</code>方法。根据<code>happens-before</code>规则，这个过程建立的<code>happens-before</code>关系可以分为3类：</p><ol type="1"><li>根据<strong>程序次序规则</strong>，<strong>1</strong> <code>happens-before</code> <strong>2</strong>；<strong>3</strong> <code>happens-before</code> <strong>4</strong>。</li><li>根据<code>volatile规则</code>，<strong>2</strong> <code>happens-before</code> <strong>3</strong>。</li><li>根据<code>happens-before</code>的<strong>传递性规则</strong>，<strong>1</strong> <code>happens-before</code> <strong>4</strong>。</li></ol><h4 id="volatile写-读的内存语义">4.3 volatile写-读的内存语义</h4><ul><li><code>volatile写</code>的内存语义即：当写一个volatile变量时，JMM会<strong><u>把该线程对应的本地内存中的共享变量值刷新到主内存</u></strong>。</li><li><code>volatile读</code>的内存语义即：当读一个volatile变量时，JMM会<strong><u>把该线程对应的本地内存置为无效</u></strong>。线程接下来将从主内存中读取共享变量。</li></ul><p>把<code>volatile写</code>和<code>volatile读</code>两个步骤综合起来看，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将<strong><u>立即变得对读线程B可见</u></strong>。</p><ul><li>·线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ul><h4 id="volatile内存语义的实现">4.4 volatile内存语义的实现</h4><p>JMM针对<strong>编译器</strong>制定的volatile重排序规则：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/volatileReorderRule.PNG" alt="volatile重排序规则表" /><figcaption aria-hidden="true">volatile重排序规则表</figcaption></figure><ul><li>当<strong>第二个操作是volatile写</strong>时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li><li>当<strong>第一个操作是volatile读</strong>时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li><li>当<strong>第一个操作是volatile写，第二个操作是volatile读</strong>时，不能重排序。</li></ul><p>JMM采取保守策略插入内存屏障：</p><ul><li>在每个volatile写操作的<strong>前面</strong>插入一个<code>StoreStore</code>屏障。</li><li>在每个volatile写操作的<strong>后面</strong>插入一个<code>StoreLoad</code>屏障。</li><li>在每个volatile读操作的<strong>后面</strong>插入一个<code>LoadLoad</code>屏障。</li><li>在每个volatile读操作的<strong>后面</strong>插入一个<code>LoadStore</code>屏障。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/volatileWrite.PNG" alt="volatile写指令序列" /><figcaption aria-hidden="true">volatile写指令序列</figcaption></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/volatileRead.PNG" alt="volatile读指令序列" /><figcaption aria-hidden="true">volatile读指令序列</figcaption></figure><p>在实际执行时，只要不改变 volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。</p><h3 id="锁的内存语义">5. 锁的内存语义</h3><h4 id="锁的释放-获取建立的happens-before关系">5.1 锁的释放-获取建立的happens-before关系</h4><p>锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123; <span class="comment">// 1</span></span><br><span class="line">        a++; <span class="comment">// 2</span></span><br><span class="line">    &#125; <span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123; <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">int</span> i = a; <span class="comment">// 5</span></span><br><span class="line">        ……</span><br><span class="line">    &#125; <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A执行<code>writer()</code>方法，随后线程B执行<code>reader()</code>方法。根据happens-before规则，这个过程包含的happens-before关系可以分为3类。</p><ol type="1"><li>根据<strong>程序次序规则</strong>，<strong>1</strong> <code>happens-before</code> <strong>2</strong>, <strong>2</strong> <code>happens-before</code> <strong>3</strong>; <strong>4</strong> <code>happens-before</code> <strong>5</strong>,<strong>5</strong> <code>happens-before</code> <strong>6</strong>。</li><li>根据<strong>监视器锁规则</strong>，<strong>3</strong> <code>happens-before</code> <strong>4</strong>。</li><li>根据<strong>happens-before的传递性</strong>，<strong>2</strong> <code>happens-before</code> <strong>5</strong>。</li></ol><h4 id="锁的释放和获取的内存语义">5.2 锁的释放和获取的内存语义</h4><ul><li>当线程<strong>释放锁</strong>时，JMM会<u><strong>把该线程对应的本地内存中的共享变量刷新到主内存中</strong></u>。</li><li>当线程<strong>获取锁</strong>时，JMM会<strong><u>把该线程对应的本地内存置为无效</u></strong>。从而使得被监视器保护的临界区代码<strong><u>必须从主内存中读取共享变量</u></strong>。</li></ul><h4 id="锁内存语义的实现">5.3 锁内存语义的实现</h4><p>在<code>ReentrantLock</code>中，调用<code>lock()</code>方法获取锁；调用<code>unlock()</code>方法释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        a++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = a;</span><br><span class="line">            ……</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code>的实现依赖于Java同步器框架<code>AbstractQueuedSynchronizer</code>（<code>AQS</code>）。<code>AQS</code>使用一个<strong>整型的volatile变量</strong>（命名为state）来维护同步状态。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/ReentrantLockPKG.PNG" alt="ReentrantLock的类图" /><figcaption aria-hidden="true">ReentrantLock的类图</figcaption></figure><p><code>ReentrantLock</code>分为<code>公平锁</code>和<code>非公平锁</code>。</p><h5 id="公平锁">5.3.1 公平锁</h5><p>使用<code>公平锁</code>时，加锁方法<code>lock()</code>调用轨迹为：</p><ol type="1"><li><code>ReentrantLock:lock()</code>；</li><li><code>FairSync:lock()</code>；</li><li><code>AbstractQueuedSynchronizer:acquire(int arg)</code>；</li><li><code>ReentrantLock:tryAcquire(int acquires)</code>，真正开始加锁，加锁方法首先<strong>读</strong>volatile变量<code>state</code>；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">// 获取锁的开始，首先读volatile变量state</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个锁，使用CAS操作进行加锁</span></span><br><span class="line">        <span class="keyword">if</span> (isFirst(current) &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 已经获取过锁</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 增加锁数量</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 超出锁的数量，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁解锁方法<code>unlock()</code>调用轨迹为：</p><ol type="1"><li><code>ReentrantLock:unlock()</code>；</li><li><code>AbstractQueuedSynchronizer:release(int arg)</code>；</li><li><code>Sync:tryRelease(int releases)</code>，真正开始释放锁，释放锁的最后<strong>写</strong>volatile变量<code>state</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读volatile变量state，尝试释放</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程未获取锁，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// c == 0 该线程所有锁已经释放</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放锁的最后，写volatile变量state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>volatile</code>的happens-before规则：释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。</p><h5 id="非公平锁">5.3.2 非公平锁</h5><p>非公平锁加锁方法<code>lock()</code>调用轨迹为：</p><ol type="1"><li><code>ReentrantLock:lock()</code>；</li><li><code>NonfairSync:lock()</code>；</li><li><code>AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)</code>，真正开始加锁，以<strong>原子操作</strong>的方式更新state变量。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值</span></span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁的释放和公平锁完全一样。</p><ul><li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li><li>公平锁获取时，首先会去读volatile变量。</li><li>非公平锁获取时，首先会用<code>CAS</code>更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。</li></ul><p>为了同时实现<code>volatile读</code>和<code>volatile写的</code>内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。</p><p><strong>锁释放-获取</strong>的内存语义的实现至少有下面两种方式：</p><ul><li>利用volatile变量的写-读所具有的内存语义。</li><li>利用<code>CAS</code>所附带的volatile读和volatile写的内存语义。</li></ul><h4 id="concurrent包的实现">5.4 concurrent包的实现</h4><p>由于Java的<code>CAS</code>同时具有<code>volatile读</code>和<code>volatile写</code>的内存语义，因此Java线程之间的通信有4种方式：</p><ul><li>A线程写volatile变量，随后B线程读这个volatile变量。</li><li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li></ul><p>Java的<code>CAS</code>会使用现代处理器上提供的高效机器级别的<strong>原子指令</strong>，这些原子指令以原子方式对内存执行<code>读-改-写操作</code>。<code>concurrent</code>包一个通用化的实现模式：</p><ul><li>首先，声明共享变量为volatile。</li><li>然后，使用CAS的原子条件更新来实现线程之间的<strong>同步</strong>。</li><li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的<strong>通信</strong>。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/concurrentPackage.PNG" alt="concurrent包的实现示意图" /><figcaption aria-hidden="true">concurrent包的实现示意图</figcaption></figure><h3 id="final域的内存语义">6. final域的内存语义</h3><h4 id="final域的重排序规则">6.1 final域的重排序规则</h4><p>对于<code>final</code>域，编译器和处理器要遵守两个重排序规则。</p><ol type="1"><li>在<strong>构造函数</strong>内对一个<code>final</code>域的<strong>写入</strong>，与随后<u>把这个被构造对象的引用赋值给一个引用变量</u>，这两个操作之间不能重排序。</li><li><strong>初次读</strong>一个<u>包含<code>final</code>域的对象的引用</u>，与随后<strong>初次读</strong>这个<u><code>final</code>域</u>，这两个操作之间不能重排序。</li></ol><h4 id="写final域的重排序规则">6.2 写final域的重排序规则</h4><p>写final域的重排序规则<u>禁止把final域的写重排序到<strong>构造函数</strong>之外</u>。</p><ol type="1"><li>JMM禁止编译器把final域的写重排序到构造函数之外。</li><li>编译器会在final域的写之后，构造函数return之前，插入一个<code>StoreStore</code>屏障。这个屏障<u>禁止处理器把final域的写重排序到构造函数之外</u>。</li></ol><p>写final域的重排序规则可以确保：<u>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了</u>，而普通域不具有这个保障。</p><h4 id="读final域的重排序规则">6.3 读final域的重排序规则</h4><p>读final域的重排序规则是，在一个线程中，<u>初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作</u>。</p><ul><li>编译器会在读final域操作的前面插入一个<code>LoadLoad</code>屏障。</li></ul><p>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在<strong>间接依赖关系</strong>。</p><p>读final域的重排序规则可以确保：<u>在读一个对象的final域之前，一定会先读包含这个final 域的对象的引用</u>。</p><h4 id="final域为引用类型">6.4 final域为引用类型</h4><p>对于<code>引用类型</code>，写final域的重排序规则对编译器和处理器<strong>增加了</strong>如下约束：</p><ul><li>在<strong>构造函数</strong>内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li></ul><p>JMM可以确保读final引用对象时，至少能看到<strong>构造函数</strong>中<u>对final引用对象的成员域的写入</u>。(可以理解为<strong><u>构造函数</u></strong>中对引用对象的操作看作一个整体)。</p><h4 id="final引用不能从构造函数内逸出">6.5 final引用不能从构造函数内<code>“逸出”</code></h4><p>要实现<code>“在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了”</code>， 还需要一个前提：</p><ul><li>在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中<code>“逸出”</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>; <span class="comment">// 1写final域</span></span><br><span class="line">        obj = <span class="keyword">this</span>; <span class="comment">// 2 this引用在此"逸出"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> FinalReferenceEscapeExample ();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">int</span> temp = obj.i; <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="final语义在处理器中的实现">6.6 final语义在处理器中的实现</h4><ul><li>写final域的重排序规则会要求编译器在final域的写之后，构造函数return之前插入一个<code>StoreStore</code>障屏。</li><li>读final域的重排序规则要求编译器在读final域的操作前面插入一个<code>LoadLoad</code>屏障。</li></ul><h3 id="happens-before-1">7. happens-before</h3><h4 id="jmm的设计">7.1 JMM的设计</h4><p><strong>JSR-133专家组</strong>在设计JMM时的核心目标就是找到一个好的平衡点：</p><ul><li>一方面，要为程序员提供足够强的内存可见性保证；</li><li>另一方面，对编译器和处理器的限制要尽可能地放松。</li></ul><p>JMM对这两种不同性质的重排序，采取了不同的策略：</p><ul><li>对于<strong><u>会改变程序执行结果的重排序</u></strong>，JMM要求编译器和处理器<strong>必须禁止</strong>这种重排序。</li><li>对于<strong><u>不会改变程序执行结果的重排序</u></strong>，JMM对编译器和处理器不做要求（JMM<u>允许</u>这种重排序）。</li></ul><h4 id="happens-before的定义">7.2 happens-before的定义</h4><p><code>《JSR-133:Java Memory Model and Thread Specification》</code>对happens-before关系的定义如下。</p><ol type="1"><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ol><p><code>as-if-serial</code>语义和<code>happens-before</code>的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</p><h4 id="happens-before规则">7.3 happens-before规则</h4><p><code>《JSR-133:Java Memory Model and Thread Specification》</code>定义了如下<code>happens-before</code>规则：</p><ol type="1"><li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li><li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li></ol><h3 id="双重检查锁定与延迟初始化">8. 双重检查锁定与延迟初始化</h3><p><strong>双重检查锁定</strong>是常见的<strong>延迟初始化</strong>技术，但它是一个<u>错误</u>的用法。</p><h4 id="双重检查锁定的由来">8.1 双重检查锁定的由来</h4><p>有时候可能需要推迟一些<strong><u>高开销</u></strong>的对象初始化操作，并且只有在使用这些对象时才进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非线程安全的延迟初始化对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeLazyInitialization</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">// 1：A线程执行</span></span><br><span class="line">        instance = <span class="keyword">new</span> Instance(); <span class="comment">// 2：B线程执行</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以对getInstance()方法做同步处理来实现线程安全的延迟初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeLazyInitialization</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronized将导致性能开销</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">// 1：A线程执行</span></span><br><span class="line">        instance = <span class="keyword">new</span> Instance(); <span class="comment">// 2：B线程执行</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>早期的JVM中<code>synchronized</code>（甚至是<u>无竞争</u>的<code>synchronized</code>）存在巨大的性能开销。因此，人们想通过<code>双重检查锁定（Double-Checked Locking）</code>来降低同步的开销：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLocking</span> </span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance; <span class="comment">// 2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 4:第一次检查</span></span><br><span class="line">        <span class="keyword">synchronized</span> (DoubleCheckedLocking<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">// 5:加锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">// 6:第二次检查</span></span><br><span class="line">        instance = <span class="keyword">new</span> Instance(); <span class="comment">// 7:问题的根源出在这里</span></span><br><span class="line">        &#125; <span class="comment">// 8</span></span><br><span class="line">        &#125; <span class="comment">// 9</span></span><br><span class="line">        <span class="keyword">return</span> instance; <span class="comment">// 10</span></span><br><span class="line">    &#125; <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果第一次检查instance不为null，那么就<u>不需要执行下面的加锁和初始化操作</u>。因此，可以大幅降低<code>synchronized</code>带来的性能开销。<code>但这是一个错误的优化！</code>在线程执行到第4行，代码读取到instance不为null时，<u><strong>instance引用的对象有可能还没有完成初始化</strong></u>。</p><p>双重检查锁定的第7行（<code>instance = new Instance();</code>）创建了一个对象。这一行代码可以分解为3行伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">// 1：分配对象的内存空间</span></span><br><span class="line">ctorInstance(memory); <span class="comment">// 2：初始化对象</span></span><br><span class="line">instance = memory; <span class="comment">// 3：设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure><p>上面3行伪代码中的2和3之间，可能会被重排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">// 1：分配对象的内存空间</span></span><br><span class="line">instance = memory; <span class="comment">// 3：设置instance指向刚分配的内存地址</span></span><br><span class="line"><span class="comment">// 注意，此时对象还没有被初始化！</span></span><br><span class="line">ctorInstance(memory); <span class="comment">// 2：初始化对象</span></span><br></pre></td></tr></table></figure><p>如果发生重排序，另一个并发执行的线程B就有可能访问到未被A线程初始化的instance对象：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/DoubleCheckedLock.PNG" alt="双重检查锁定问题的根源" /><figcaption aria-hidden="true">双重检查锁定问题的根源</figcaption></figure><p>本质上还是因为创建了一个对象的过程是非原子性的。</p><h4 id="基于volatile的解决方案">8.2 基于volatile的解决方案</h4><p>基于<code>volatile</code>可以禁止2和3重排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeDoubleCheckedLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SafeDoubleCheckedLocking<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">    instance = <span class="keyword">new</span> Instance(); <span class="comment">// instance为volatile，现在没问题了</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于类初始化的解决方案">8.3 基于类初始化的解决方案</h4><p>允许2和3重排序，但不允许其他线程“看到”这个重排序。</p><p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会去获取一个锁。基于这个特性，可以实现另一种线程安全的延迟初始化方案：<code>Initialization On Demand Holder idiom</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> InstanceHolder.instance ; <span class="comment">// 这里将导致InstanceHolder类被初始化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化一个类，包括执行这个类的<strong>静态初始化</strong>和初始化在这个类中声明的<strong>静态字段</strong>。根据Java语言规范，在<code>首次发生</code>下列任意一种情况时，一个类或接口类型<code>T</code>将被立即初始化。</p><ol type="1"><li><code>T</code>是一个类，而且一个<code>T</code>类型的实例被创建。</li><li><code>T</code>是一个类，且<code>T</code>中声明的一个静态方法被调用。</li><li><code>T</code>中声明的一个静态字段被赋值。</li><li><code>T</code>中声明的一个静态字段被使用，而且<u><strong>这个字段不是一个常量字段</strong></u>。</li><li><code>T</code>是一个顶级类（Top Level Class），而且一个<strong>断言语句</strong>嵌套在<code>T</code>内部被执行。</li></ol><p>Java语言规范规定，对于每一个类或接口都有一个唯一的初始化锁与之对应。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了。Java初始化一个类或接口的处理过程如下：</p><ul><li>第1阶段：通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化。这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。</li><li>第2阶段：线程A执行类的初始化，同时线程B在初始化锁对应的condition上等待。</li><li>第3阶段：线程A设置state=initialized，然后唤醒在condition中等待的所有线程。</li><li>第4阶段：线程B结束类的初始化处理。</li><li>第5阶段：线程C执行类的初始化的处理。在第3阶段之后，类已经完成了初始化。因此线程C在第5阶段的类初始化处理过程相对简单一些（线程C的类初始化处理只需要经历一次锁获取-锁释放）。</li></ul><p>字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。在大多数时候，正常的初始化要优于延迟初始化。</p><h3 id="java内存模型综述">9. Java内存模型综述</h3><h4 id="处理器的内存模型">9.1 处理器的内存模型</h4><p>根据<u><strong>对不同类型的读/写操作组合的执行顺序的放松</strong></u>，可以把常见处理器的内存模型划分为如下几种类型。</p><ul><li>放松程序中<code>写-读操作</code>的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）。</li><li>在上面的基础上，继续放松程序中<code>写-写操作</code>的顺序，由此产生了Partial Store Order内存模型（简称为PSO）。</li><li>在前面两条的基础上，继续放松程序中<code>读-写</code>和<code>读-读</code>操作的顺序，由此产生了Relaxed Memory Order内存模型（简称为RMO）和PowerPC内存模型。</li></ul><h4 id="jmm的内存可见性保证">9.2 JMM的内存可见性保证</h4><p>按程序类型，Java程序的内存可见性保证可以分为下列3类。</p><ul><li><strong>单线程程序</strong>。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li><li><strong>正确同步的多线程程序</strong>。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。</li><li><strong>未同步/未正确同步的多线程程序</strong>。JMM为它们提供了<u>最小安全性保障</u>：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java线程之间的通信对程序员完全透明，内存可见性问题很容易困扰Java程序员&lt;/code&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--2 Java并发机制的底层实现原理</title>
    <link href="https://wuyunjie.top/2021/07/13/JavaLearning_The_art_of_concurrent_programming_in_Java-2-The-underlying-implementation-principle.html"/>
    <id>https://wuyunjie.top/2021/07/13/JavaLearning_The_art_of_concurrent_programming_in_Java-2-The-underlying-implementation-principle.html</id>
    <published>2021-07-13T02:01:19.000Z</published>
    <updated>2021-07-13T02:01:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>Java中所使用的并发机制依赖于JVM的实现和CPU的指令</code> <a id="more"></a></p></blockquote><h3 id="volatile的应用">1. <code>volatile</code>的应用</h3><p><code>volatile</code>是<strong>轻量级</strong>的<code>synchronized</code>，它在多处理器开发中保证了共享变量的<code>“可见性”</code>。</p><blockquote><p><code>可见性</code>是<u>当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值</u>。</p></blockquote><h4 id="volatile的定义与实现原理">1.1 <code>volatile</code>的定义与实现原理</h4><p>Java编程语言允许线程访问共享变量，为了确保共享变量能被<code>准确</code>和<code>一致</code>地更新，线程应该确保通过<code>排他锁</code>单独获得这个变量。如果一个字段被声明成<code>volatile</code>，Java线程内存模型确保<u>所有线程看到这个变量的值是一致的</u>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/CPUTerm.png" alt="CPU的术语定义" /><figcaption aria-hidden="true">CPU的术语定义</figcaption></figure><p>有<code>volatile</code>变量修饰的共享变量进行写操作时会有一行<code>Lock</code>前缀的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x01a3de1d: movb $0×0,0×1104800(%esi);</span><br><span class="line">0x01a3de24: lock addl $0×0,(%esp);</span><br></pre></td></tr></table></figure><p><code>Lock</code>指令在多核处理器下会:</p><ul><li>将当前处理器缓存行的数据<strong>写回到系统内存</strong>。</li><li>写回内存的操作会使在其他CPU里缓存了该内存地址的数据<strong>无效</strong>。在多处理器下，理由<code>缓存一致性协议</code>保证各个处理器的缓存是一致的，每个处理器通过<strong>嗅探</strong>在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成<code>无效状态</code>，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</li></ul><p><code>volatile</code>的两条实现原则：</p><ul><li><code>Lock</code>前缀指令会引起处理器缓存回写到内存。</li><li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</li></ul><h4 id="volatile的使用优化">1.2 <code>volatile</code>的使用优化</h4><p>队列集合类<code>LinkedTransferQueue</code>在使用<code>volatile</code>变量时，用一种追加字节的方式来优化队列出队和入队的性能。<code>LinkedTransferQueue</code>的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 队列中的头部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"><span class="comment">/** 队列中的尾部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedAtomicReference</span> &lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 使用很多4个字节的引用追加到64个字节</span></span><br><span class="line">Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;</span><br><span class="line"></span><br><span class="line">    PaddedAtomicReference(T r) &#123;</span><br><span class="line"><span class="keyword">super</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span> &lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>类<code>LinkedTransferQueue</code>使用一个内部类<code>PaddedAtomicReference</code>来定义队列的<strong>头节点（head）</strong>和<strong>尾节点（tail）</strong>，这个内部类相对于父类 <code>AtomicReference</code>只将共享变量追加到<code>64</code>字节。</p><p>主要原因是一些处理器的<code>L1</code>、<code>L2</code>或<code>L3</code>缓存的高速缓存行是64个字节宽，不支持部分填充缓存行。如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都<strong><u>读到同一个高速缓存行中</u></strong>，当一 个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，严重影响到队列的入队和出队效率。</p><p>通过追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。但在两种场景下不应该使用这种方式：</p><ul><li>缓存行非64字节宽的处理器。</li><li>共享变量不会被频繁地写。</li></ul><blockquote><p><code>Java 7</code>会淘汰或重新排列无用字段，需要使用其他追加字节的方式</p></blockquote><h3 id="synchronized的实现原理与应用">2. <code>synchronized</code>的实现原理与应用</h3><p><code>synchronized</code>被称呼为<strong>重量级锁</strong>。随着<code>Java SE 1.6</code>对<code>synchronized</code>的优化，它变得轻量级了。下利用<code>synchronized</code>实现同步的基础：<strong>Java中的每一个对象都可以作为锁</strong>。</p><ul><li>对于<strong>普通同步方法</strong>，锁是当前实例对象。</li><li>对于<strong>静态同步方法</strong>，锁是当前类的<code>Class</code>对象。</li><li>对于<strong>同步方法块</strong>，锁是<code>Synchonized</code>括号里配置的对象。</li></ul><p>当一个线程试图<u>访问同步代码块</u>时，它首先<strong>必须得到锁，退出或抛出异常时必须释放锁</strong>。<code>JVM</code>基于进入和退出<code>Monitor对象</code>来实现<strong>方法同步</strong>和<strong>代码块同步</strong>：</p><ul><li><code>代码块同步</code>是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的；<ul><li><code>monitorenter</code>指令是在编译后插入到同步代码块的开始位置；</li><li><code>monitorexit</code>是插入到方法结束处和异常处；</li><li><code>JVM</code>要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对；</li><li>任何对象都有一个<code>monitor</code>与之关联，当且仅当一个<code>monitor</code>被持有后，它将处于<strong>锁定状态</strong>。线程执行到<code>monitorenter</code>指令时，将会尝试获取对象所对应的<code>monitor</code>的所有权，即尝试获得对象的锁。</li></ul></li><li><code>方法同步</code>是使用另外一种方式实现的，细节在<strong>JVM规范</strong>里并没有详细说明。方法的同步同样可以使用这两个指令来实现。</li></ul><h4 id="java对象头">2.1 Java对象头</h4><p><code>synchronized</code>用的锁是存在<strong>Java对象</strong>头里的。Java对象头里的<code>Mark Word</code>里默认存储对象的<code>HashCode</code>、分代年龄和锁标记位。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/objectHeadLength.PNG" alt="Java对象头的长度" /><figcaption aria-hidden="true">Java对象头的长度</figcaption></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/objectHeadStructure.PNG" alt="Java对象头的存储结构" /><figcaption aria-hidden="true">Java对象头的存储结构</figcaption></figure><p>在运行期间，<code>Mark Word</code>里存储的数据会随着锁标志位的变化而变化。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/objectHeadMarkWord.PNG" alt="Mark Word的状态变化" /><figcaption aria-hidden="true">Mark Word的状态变化</figcaption></figure><p><code>64位虚拟机</code>下，<code>Mark Word</code>是<code>64bit</code>大小的，其存储结构如下：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/objectHeadMarkWord64.PNG" alt="Mark Word的状态变化(64bits)" /><figcaption aria-hidden="true">Mark Word的状态变化(64bits)</figcaption></figure><h4 id="锁的升级与对比">2.2 锁的升级与对比</h4><p>在<code>Java SE 1.6</code>中，锁一共有<code>4</code>种状态，级别从低到高依次是：<code>无锁状态</code>、<code>偏向锁状态</code>、<code>轻量级锁状态</code>和<code>重量级锁状态</code>，这几个状态会随着竞争情况逐渐升级。</p><blockquote><ul><li><p><strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。</p></li><li><p>引入了<code>“偏向锁”</code>和<code>“轻量级锁”</code>，是为了<u>减少获得锁和释放锁带来的性能消耗</u>。</p></li></ul></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/BiasedLock.PNG" alt="偏向锁" /><figcaption aria-hidden="true">偏向锁</figcaption></figure><h5 id="偏向锁">2.2.1 偏向锁</h5><p>大多数情况下，锁不仅不存在多线程竞争，而且<u><strong>总是由同一线程多次获得</strong></u>，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储<strong>锁偏向的线程ID</strong>，以后该线程在进入和退出同步块时不需要进行<code>CAS</code>操作来加锁和解锁，只需简单地测试一下对象头的<code>Mark Word</code>里<u><strong>是否存储着指向当前线程的偏向锁</strong></u>。</p><ul><li>如果测试成功，表示线程已经获得了锁。</li><li>如果测试失败，则需要再测试一下<code>Mark Word</code>中偏向锁的标识是否设置成<code>1</code>（表示当前是偏向锁）。如果没有设置，则使用<code>CAS</code>竞争锁；如果设置了，则尝试使用<code>CAS</code>将对象头的偏向锁指向当前线程。</li></ul><p>偏向锁使用了一种<u>等到竞争出现才释放锁的机制</u>，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待<strong>全局安全点</strong>（在这个时间点上没有正在执行的字节码）。</p><ul><li>首先暂停拥有偏向锁的线程；</li><li>然后检查持有偏向锁的线程是否活着：<ul><li>如果线程不处于活动状态，则将对象头设置成无锁状态；</li><li>如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的<code>Mark Word</code>要么重新偏向于其他 线程，要么恢复到无锁或者标记对象不适合作为偏向锁。</li></ul></li><li>最后唤醒暂停的线程。</li></ul><h5 id="轻量级锁">2.2.2 轻量级锁</h5><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/LightweightLock.PNG" alt="轻量级锁" /><figcaption aria-hidden="true">轻量级锁</figcaption></figure><h6 id="轻量级锁加锁">2.2.2.1 轻量级锁加锁</h6><p>线程在执行同步块之前，<code>JVM</code>会先在当前线程的<strong>栈桢</strong>中创建<u>用于存储锁记录</u>的空间，并将对象头中的<code>Mark Word</code>复制到锁记录中，官方称为<code>Displaced Mark Word</code>。然后线程尝试使用<code>CAS</code>将对象头中的<code>Mark Word</code>替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋</strong>来获取锁。</p><h6 id="轻量级锁解锁">2.2.2.2 轻量级锁解锁</h6><p>轻量级解锁时，会使用原子的<code>CAS</code>操作将<code>Displaced Mark Word</code>替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会<strong>膨胀</strong>成重量级锁。因为<code>自旋</code>会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。</p><h4 id="锁的优缺点对比">2.2.3 锁的优缺点对比</h4><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/LockAdAndDisad.PNG" alt="锁的优缺点的对比" /><figcaption aria-hidden="true">锁的优缺点的对比</figcaption></figure><h3 id="原子操作的实现原理">3. 原子操作的实现原理</h3><p>原子操作（atomic operation）指“不可被中断的一个或一系列操作”。</p><h4 id="术语定义">3.1 术语定义</h4><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/CPUTerm2.PNG" alt="术语定义" /><figcaption aria-hidden="true">术语定义</figcaption></figure><h4 id="实现原子操作">3.2 实现原子操作</h4><p><code>32位IA-32处理器</code>使用<strong><u>基于对缓存加锁</u></strong>或<strong><u>总线加锁</u></strong>的方式来实现多处理器之间的原子操作。</p><ul><li>首先处理器会自动保证<strong>基本的内存操作</strong>的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，即当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。</li><li>但是处理器不能自动保证<strong>复杂的内存操作</strong>的原子性，比如<u>跨总线宽度</u>、<u>跨多个缓存行</u>和<u>跨页表</u>的访问。</li></ul><p>处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来<u>保证复杂内存操作的原子性</u>。</p><h5 id="总线锁保证原子性">3.2.1 总线锁保证原子性</h5><p>总线锁就是使用处理器提供的一个<code>LOCK＃</code>信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以<strong>独占共享内存</strong>。</p><h5 id="缓存锁保证原子性">3.2.2 缓存锁保证原子性</h5><p>同一时刻只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，锁定期间其他处理器<u><strong>不能操作其他内存地址的数据</strong></u>，所以总线锁定的开销比较大，目前处理器在某些场合下<u>使用缓存锁定代替总线锁定来进行优化</u>。</p><p><code>“缓存锁定”</code>是指内存区域如果被缓存在处理器的缓存行中，并且在<code>Lock</code>操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言<code>LOCK＃</code>信号，而是<strong><u>修改内部的内存地址</u></strong>，并允许它的缓存一致性机制来保证操作的原子 性，因为<u>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</u>，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p><p><strong>有两种情况下处理器不会使用缓存锁定</strong>：</p><ul><li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，处理器会调用总线锁定。</li><li>有些处理器不支持缓存锁定。</li></ul><h4 id="java实现原子操作">3.3 Java实现原子操作</h4><p>在<code>Java</code>中可以通过<strong>锁</strong>和<strong>循环CAS</strong>的方式来实现原子操作：</p><h5 id="使用循环cas实现原子操作">3.3.1 使用<code>循环CAS</code>实现原子操作</h5><p>JVM中的<code>CAS操作</code>利用了处理器提供的<code>CMPXCHG</code>指令实现的，自旋CAS实现的基本思路是<u><strong>循环进行CAS操作直到成功为止</strong></u>。从<code>Java 1.5</code>开始，<code>JDK</code>的并发包里提供了一些类来支持原子操作，如<code>AtomicBoolean</code>、<code>AtomicInteger</code>和<code>AtomicLong</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger atomicI = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/** * 使用CAS实现线程安全计数器 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">int</span> i = atomicI.get();</span><br><span class="line"><span class="keyword">boolean</span> suc = atomicI.compareAndSet(i, ++i);</span><br><span class="line"><span class="keyword">if</span> (suc) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="cas实现原子操作的三大问题">3.3.2 CAS实现原子操作的三大问题</h5><ol type="1"><li><strong>ABA问题</strong>。因为<code>CAS</code>需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是<code>A</code>，变成了<code>B</code>，又变成了<code>A</code>，那么使用<code>CAS</code>进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是<strong><u>使用版本号</u></strong>。<code>JDK</code>的<code>Atomic</code>包里提供了一个类<code>AtomicStampedReference</code>来解决<code>ABA</code>问题。这个类的<code>compareAndSet</code>方法：<ul><li>首先检查当前引用是否等于预期引用；</li><li>然后检查当前标志是否等于预期标志；</li><li>如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li></ul></li><li><strong>循环时间长开销大</strong>。自旋<code>CAS</code>如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持<code>pause指令</code>，那么效率会有一定的提升。pause指令有两个作用：<ul><li><strong>延迟流水线执行指令（de-pipeline）</strong>，使CPU不会消耗过多的执行资源；</li><li>避免在退出循环的时候因<code>内存顺序冲突（Memory Order Violation）</code>而引起<code>CPU流水线被清空（CPU Pipeline Flush）</code>，从而提高CPU的执行效率。</li></ul></li><li><strong>只能保证一个共享变量的原子操作</strong>。对多个共享变量操作时，循环<code>CAS</code>就无法保证操作的原子性，这个时候就可以用<strong>锁</strong>。JDK也提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行<code>CAS操作</code>。</li></ol><h5 id="使用锁机制实现原子操作">3.3.3 使用锁机制实现原子操作</h5><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。除了<code>偏向锁</code>，JVM实现锁的方式都用了<code>循环 CAS</code>，即当一个线程想进入同步块的时候<strong>使用循环CAS的方式来<u>获取锁</u></strong>，当它退出同步块的时候<strong>使用循环CAS<u>释放锁</u></strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java中所使用的并发机制依赖于JVM的实现和CPU的指令&lt;/code&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--1 并发编程的挑战</title>
    <link href="https://wuyunjie.top/2021/07/12/JavaLearning_The_art_of_concurrent_programming_in_Java-1-Challenges-of-concurrent-programming.html"/>
    <id>https://wuyunjie.top/2021/07/12/JavaLearning_The_art_of_concurrent_programming_in_Java-1-Challenges-of-concurrent-programming.html</id>
    <published>2021-07-12T13:15:56.000Z</published>
    <updated>2021-07-12T13:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p><code>并发编程的目的是为了让程序运行得更快。在进行并发编程时，如果希望通过多线程执行任务让程序运行得更快，会 面临非常多的挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题</code> <a id="more"></a></p></blockquote><h3 id="上下文切换">1. 上下文切换</h3><p>CPU通过<u>给每个线程分配CPU时间片来实现多线程</u>。<strong>时间片</strong>是<code>CPU</code>分配给各个线程的时间，一般是几十毫秒（ms）。<code>CPU</code>通过时间片分配算法来循环执行任务，在切换任务前会保存上一个任务的状态，以便下次切换回来时可以再加载这个任务的状态。所以<u>任务从保存到再加载的过程</u>就是一次<strong>上下文切换（CS，<code>Content Switch</code>）</strong>。</p><h4 id="多线程的效率">1.1 多线程的效率</h4><p>并发执行并不一定比串行执行快，比如下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Concurrency.Chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> count = <span class="number">1000000l</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        concurrency();</span><br><span class="line">        serial();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concurrency</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    a += <span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">"concurrency :"</span> + time+<span class="string">"ms,b="</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            a += <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">"serial:"</span> + time+<span class="string">"ms,b="</span>+b+<span class="string">",a="</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当并发执行累加操作<strong>不超过百万次</strong>时，速度会比串行执行累加操作要慢。因为<code>线程有创建和上下文切换的开销</code>。</p><h4 id="上下文切换次数和时长">1.2 上下文切换次数和时长</h4><p>可以度量上下文切换带来的消耗的工具：</p><ul><li><code>Lmbench3</code>：可以测量上下文切换的<strong>时长</strong>。</li><li><code>vmstat</code>：可以测量上下文切换的<strong>次数</strong>。</li></ul><h4 id="减少上下文切换">1.3 减少上下文切换</h4><p>减少上下文切换的方法有<code>无锁并发编程</code>、<code>CAS算法</code>、使用<code>最少线程</code>和使用<code>协程</code>。</p><ul><li><code>无锁并发编程</code>。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一 些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li><li><code>CAS算法</code>。Java的<code>Atomic</code>包使用<code>CAS算法</code>来更新数据，而不需要加锁。</li><li>使用<code>最少线程</code>。避免创建不需要的线程，创建过多线程会造成大量线程都处于等待状态。</li><li><code>协程</code>。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul><h3 id="死锁">2. 死锁</h3><p>一旦产生死锁，就会造成系统功能不可用。如下代码会引发死锁，使线程<code>t1</code>和线程<code>t2</code>互相等待对方释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Concurrency.Chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String A = <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String B = <span class="string">"B"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DeadLockDemo().deadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免死锁的几个常见方法。</p><ul><li>避免一个线程同时获取多个锁。</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li><li>尝试使用定时锁，使用<code>lock.tryLock(timeout)</code>来替代使用内部锁机制。</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li></ul><h3 id="资源限制的挑战">3. 资源限制的挑战</h3><h4 id="资源限制">3.1 资源限制</h4><p>资源限制是指在进行并发编程时，<u>程序的执行速度受限于计算机硬件资源或软件资源</u>。</p><ul><li>硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。</li><li>软件资源限制有数据库的连接数和socket连接数等。</li></ul><h4 id="资源限制引发的问题">3.2 资源限制引发的问题</h4><p>如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为<code>增加了上下文切换和资源调度的时间</code>。</p><h4 id="何解决资源限制的问题">3.3 何解决资源限制的问题</h4><ul><li>对于硬件资源限制，可以考虑<strong>使用集群</strong>并行执行程序。</li><li>对于软件资源限制，可以考虑<strong>使用资源池</strong>将资源复用。</li></ul><h4 id="资源限制情况下并发编程">3.4 资源限制情况下并发编程</h4><p>根据不同的资源限制调整程序的并发度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;并发编程的目的是为了让程序运行得更快。在进行并发编程时，如果希望通过多线程执行任务让程序运行得更快，会 面临非常多的挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题&lt;/code&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|二叉树的构建和相关操作]</title>
    <link href="https://wuyunjie.top/2021/06/30/Data_structure_and_algorithm_binary_tree.html"/>
    <id>https://wuyunjie.top/2021/06/30/Data_structure_and_algorithm_binary_tree.html</id>
    <published>2021-06-30T12:17:55.000Z</published>
    <updated>2021-06-30T12:17:55.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://wuyunjie.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|各种排序算法原理及实现]</title>
    <link href="https://wuyunjie.top/2021/06/30/Data_structure_and_algorithm_sorting_algorithm.html"/>
    <id>https://wuyunjie.top/2021/06/30/Data_structure_and_algorithm_sorting_algorithm.html</id>
    <published>2021-06-30T12:11:46.000Z</published>
    <updated>2021-06-30T12:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序问题的形式定义">1. 排序问题的形式定义</h3><p>可以将<strong>排序问题</strong>形式化定义为如下：</p><blockquote><p><strong>输入</strong>: <span class="math inline">\(n\)</span> 个数的一个序列 <span class="math inline">\(\left\langle a_{1}, a_{2}, \cdots, a_{n}\right\rangle\)</span>。 <strong>输出</strong>: 输入序列的一个排列 <span class="math inline">\(\left\langle a_{1}^{\prime}, a_{2}^{\prime}, \cdots, a_{n}^{\prime}\right\rangle\)</span>, 满足 <span class="math inline">\(a_{1}^{\prime} \leqslant a_{2}^{\prime} \leqslant \cdots \leqslant a_{n}^{\prime}\)</span> 。</p></blockquote><p>希望排序的数也称为<strong>关键词</strong>。</p><h3 id="排序算法">2. 排序算法</h3><h4 id="插入排序">2.1 插入排序</h4><h5 id="插入排序算法介绍">2.1.1 插入排序算法介绍</h5><p>对于少量元素的排序，插入排序是一种有效的算法。插入排序的伪代码如下，输入是数组<span class="math inline">\(A[1.. n]\)</span>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line">for j = 2 to A.length</span><br><span class="line">key = A[j]</span><br><span class="line">// Insert A[j] into the sorted sequence A[1 .. j-1].</span><br><span class="line">i = j - 1</span><br><span class="line">while i &gt; 0 and A[i] &gt; key</span><br><span class="line">A[ i + i ] = A[i]</span><br><span class="line">i = i - 1</span><br><span class="line">A[ i + 1 ] = key</span><br></pre></td></tr></table></figure><h5 id="循环不变式与插入排序的正确性">2.1.2 循环不变式与插入排序的正确性</h5><p>下图式对数组<span class="math inline">\(A=&lt;5, 2, 4, 6, 1, 3&gt;\)</span>的插入排序：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/sort/insertSortExample.PNG" alt="插入排序示例" /><figcaption aria-hidden="true">插入排序示例</figcaption></figure><p>在<code>for</code>循环每次迭代开始时，子数组<span class="math inline">\(A[1.. j-1]\)</span>由原来在<span class="math inline">\(A[1.. j-1]\)</span>中的元素组成，但已按顺序排列，即<strong><code>循环不变式</code></strong>。<strong><code>循环不变式</code></strong>用于帮助理解算法地正确性。关于循环不变式需要证明三条性质：</p><ul><li><strong>初始化</strong>：循环的第一次迭代之前，它为真。</li><li><strong>保持</strong>：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。</li><li><strong>终止</strong>：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。</li></ul><h5 id="插入排序算法的分析">2.1.3 插入排序算法的分析</h5><p>这里是基于<strong>算法导论</strong>中算法分析给出的计算方法，做一个示例：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/sort/insertSortTimeAnalysis.PNG" alt="插入排序运行时间分析" /><figcaption aria-hidden="true">插入排序运行时间分析</figcaption></figure><p>算法运行时间是职校每条语句的执行时间之和： <span class="math display">\[T(n)=c_{1} n+c_{2}(n-1)+c_{4}(n-1)+c_{5} \sum_{j=2}^{n} t_{j}+c_{6} \sum_{j=2}^{n}\left(t_{j}-1\right)+c_{7} \sum_{j=2}^{n}\left(t_{j}-1\right)+c_{8}(n-1)\]</span> 当输入数组已经排好序时，出现最佳情况，使得<span class="math inline">\(t_j=1\)</span>，则最佳情况下的运行时间为： <span class="math display">\[\begin{aligned}T(n) &amp;=c_{1} n+c_{2}(n-1)+c_{4}(n-1)+c_{5}(n-1)+c_{8}(n-1) \\&amp;=\left(c_{1}+c_{2}+c_{4}+c_{5}+c_{8}\right) n-\left(c_{2}+c_{4}+c_{5}+c_{8}\right)\end{aligned}\]</span> 可以将其表示为<span class="math inline">\(an+b\)</span>，因此它是<span class="math inline">\(n\)</span>的<strong>线性函数</strong>。若输出数组是反向排序，即按递减排好序，此时出现最坏情况，有<span class="math inline">\(t_j=j\)</span>，由于有： <span class="math display">\[\begin{aligned}&amp;\sum_{j=2}^{n} j=\frac{n(n+1)}{2}-1 \\&amp;\sum_{j=2}^{n}(j-1)=\frac{n(n-1)}{2}\end{aligned}\]</span> 最坏情况下，插入排序运行时间为： <span class="math display">\[\begin{aligned}T(n)=&amp; c_{1} n+c_{2}(n-1)+c_{4}(n-1)+c_{5}\left(\frac{n(n+1)}{2}-1\right) \\&amp;+c_{6}\left(\frac{n(n-1)}{2}\right)+c_{7}\left(\frac{n(n-1)}{2}\right)+c_{8}(n-1) \\=&amp;\left(\frac{c_{5}}{2}+\frac{c_{6}}{2}+\frac{c_{7}}{2}\right) n^{2}+\left(c_{1}+c_{2}+c_{4}+\frac{c_{5}}{2}-\frac{c_{6}}{2}-\frac{c_{7}}{2}+c_{8}\right) n \\&amp;-\left(c_{2}+c_{4}+c_{5}+c_{8}\right)\end{aligned}\]</span> 可以将其表示为<span class="math inline">\(an^2+bn+c\)</span>，因此它是<span class="math inline">\(n\)</span>的<strong>二次函数</strong>。一般只求<strong>最坏情况运行时间</strong>，记插入排序具有最坏情况运行时间<span class="math inline">\(O(n^2)\)</span>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;排序问题的形式定义&quot;&gt;1. 排序问题的形式定义&lt;/h3&gt;
&lt;p&gt;可以将&lt;strong&gt;排序问题&lt;/strong&gt;形式化定义为如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;: &lt;span class=&quot;math inli
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="https://wuyunjie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序算法" scheme="https://wuyunjie.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|算法分析]</title>
    <link href="https://wuyunjie.top/2021/06/30/Data_structure_and_algorithm_algorithm_analysis.html"/>
    <id>https://wuyunjie.top/2021/06/30/Data_structure_and_algorithm_algorithm_analysis.html</id>
    <published>2021-06-30T12:09:23.000Z</published>
    <updated>2021-06-30T12:42:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法介绍">1. 算法介绍</h3><h4 id="算法">1.1. 算法</h4><blockquote><p>非形式地说，<strong>算法</strong>（algorithm）就说任何<code>良定义</code>地计算过程，该过程取某个值或值的集合作为<strong>输入</strong>，并产生某个值或值的集合作为<strong>输出</strong>。即算法就是<u>把输入转化为输出的计算步骤的一个序列</u>。</p></blockquote><a id="more"></a><p>若对每个输入实例算法都以正确的输出<strong>停机</strong>，则称该算法是<strong>正确的</strong>，并称正确的算法<strong>解决了</strong>给定的计算问题。不正确的算法对某些输入实例可能根本<strong>不停机</strong>，也可能以不正确的回答停机。</p><h4 id="数据结构">1.2. 数据结构</h4><blockquote><p><strong>数据结构</strong>（data structure）是一种存储和组织数据的方式，旨在便于访问和修改。</p></blockquote><h3 id="分析算法">2. 分析算法</h3><p>分析算法的结果意味着预测算法需要的资源，通常度量的是<strong>计算时间</strong>。一般来说，算法需要的时间与<strong>输入规模</strong>同步增长，所以通常把一个程序的运行时间描述为<u>其输入规模的函数</u>。</p><h4 id="最坏情况与平均情况分析">2.1. 最坏情况与平均情况分析</h4><p>一般只求<strong>最坏情况运行时间</strong>，主要有三个理由：</p><ul><li>一个算法的最坏情况运行时间给出了任何输入运行时间的一个<strong>上界</strong>。</li><li>对某些算法，最坏情况经常出现。</li><li>“平均情况”往往与最坏情况大致一样差。</li></ul><h4 id="增长量级">2.2. 增长量级</h4><p>可以将运行时间就行更简化的抽象，即运行时间的<strong>增长率</strong>或<strong>增长量级</strong>。</p><ul><li><p>只考虑运行时间公式中最重要的项(比如，<span class="math inline">\(an^2+bn+c\)</span>中的<span class="math inline">\(an^2\)</span>)，因为<span class="math inline">\(n\)</span>很大时，低阶项相对来说不太重要。</p></li><li><p>同时也忽略最重要项的常系数，因为在确定计算效率时常量因子不如增长率重要。</p></li></ul><p>比如记插入排序具有最坏情况运行时间<span class="math inline">\(\Theta(n^2)\)</span>。<u>如果一个算法的最坏情况运行时间具有比另一个算法更低的增长量级，那么通常认为前者比后者更有效</u>。</p><h3 id="函数的增长">3. 函数的增长</h3><h4 id="渐近记号">3.1. 渐近记号</h4><p>主要使用渐近记号来描述算法的运行时间，渐近记号实际上应用于函数。</p><h5 id="theta记号">3.1.1 <span class="math inline">\(\Theta\)</span>记号</h5><p>比如插入排序的最坏情况运行时间为<span class="math inline">\(T(n)=\Theta(n^2)\)</span>，对这个记号定义。对一个给定的函数<span class="math inline">\(g(n)\)</span>，用 <span class="math inline">\(\Theta(g(n))\)</span>来表示以下函数的集合: <span class="math display">\[\begin{aligned}\Theta(g(n))=\left\{f(n) \text { :存在正常量 } c_{1}, c_{2} \text { 和 } n_{0}, \text { 使得对所有 } n \geqslant n_{0}, \text { 有 } 0 \leqslant c_{1} g(n) \leqslant f(n) \leqslant c_{2} g(n)\right\}\end{aligned}\]</span> 所以 <span class="math inline">\(\Theta(g(n))\)</span>是一个集合，可以记<span class="math inline">\(f(n) \in \Theta(g(n))\)</span>以指出<span class="math inline">\(f(n)\)</span>是<span class="math inline">\(\Theta(g(n))\)</span>的成员。称<span class="math inline">\(g(n)\)</span>是<span class="math inline">\(f(n)\)</span>的一个<strong>渐近紧确界</strong>。</p><h5 id="o记号">3.1.2 <span class="math inline">\(O\)</span>记号</h5><p>当只有一个<strong>渐近上界</strong>时，使用<span class="math inline">\(O\)</span>记号。对于给定的函数<span class="math inline">\(g(n)\)</span>，用<span class="math inline">\(O(g(n))\)</span>来表示以下函数的集合： <span class="math display">\[\begin{aligned}O(g(n))=\left\{f(n): \text { 存在正常量 } c \text { 和 } n_{0}, \text { 使得对所有 } n \geqslant n_{0}, \text { 有 } 0 \leqslant f(n) \leqslant c g(n)\right\}\end{aligned}\]</span></p><h5 id="omega记号">3.1.3 <span class="math inline">\(\Omega\)</span>记号</h5><p>当只有一个<strong>渐近下界</strong>时，使用<span class="math inline">\(\Omega\)</span>记号。对于给定的函数<span class="math inline">\(g(n)\)</span>，用<span class="math inline">\(\Omega(g(n))\)</span>来表示以下函数的集合： <span class="math display">\[\begin{aligned}\Omega(g(n))=\left\{f(n): \text { 存在正常量 } c \text { 和 } n_{0}, \text { 使得对所有 } n \geqslant n_{0}, \text { 有 } 0 \leqslant c g(n) \leqslant f(n)\right\}\end{aligned}\]</span> <img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/algorithm/algorithmTime.PNG" alt="记号图例" /></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法介绍&quot;&gt;1. 算法介绍&lt;/h3&gt;
&lt;h4 id=&quot;算法&quot;&gt;1.1. 算法&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;非形式地说，&lt;strong&gt;算法&lt;/strong&gt;（algorithm）就说任何&lt;code&gt;良定义&lt;/code&gt;地计算过程，该过程取某个值或值的集合作为&lt;strong&gt;输入&lt;/strong&gt;，并产生某个值或值的集合作为&lt;strong&gt;输出&lt;/strong&gt;。即算法就是&lt;u&gt;把输入转化为输出的计算步骤的一个序列&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="https://wuyunjie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[Java|String,StringBuffer与StringBuilder的区别与用法]</title>
    <link href="https://wuyunjie.top/2021/06/25/JavaLearning_String_StringBuffer_and_StringBuilder.html"/>
    <id>https://wuyunjie.top/2021/06/25/JavaLearning_String_StringBuffer_and_StringBuilder.html</id>
    <published>2021-06-25T02:05:01.000Z</published>
    <updated>2021-06-25T02:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>字符串在<code>Java</code>中被广泛应用，学习一下<code>String</code>、<code>StringBuilder</code>和<code>StringBuffer</code>这几个类之间的异同和适用场景。 <a id="more"></a></p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/javaString.png" alt="String、StringBuilder和StringBuffer继承树" /><figcaption aria-hidden="true"><code>String</code>、<code>StringBuilder</code>和<code>StringBuffer</code>继承树</figcaption></figure><h3 id="string-类">1. <code>String</code> 类</h3><p>在 Java 中字符串属于<strong><code>对象</code></strong>，Java 提供了 <code>String</code> 类来创建和操作字符串。</p><h4 id="实例化">1.1 实例化</h4><p>主要有两种方法：直接赋值和构造法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>; <span class="comment">//直接赋值</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>); <span class="comment">//构造法</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>字符串常量是String的匿名对象</strong>。Java 本身没有提供<code>字符串常量</code>的概念，所有使用<code>""</code>定义的内容本质上来讲都是<code>String</code>的<code>匿名对象</code>。</p></blockquote><p>String 创建的字符串存储在<strong><code>公共池</code></strong>中，而 <code>new</code> 创建的字符串对象在<strong><code>堆</code></strong>上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Runoob"</span>;              <span class="comment">// String 直接创建</span></span><br><span class="line">String s2 = <span class="string">"Runoob"</span>;              <span class="comment">// String 直接创建</span></span><br><span class="line">String s3 = s1;                    <span class="comment">// 相同引用</span></span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"Runoob"</span>);   <span class="comment">// String 对象创建</span></span><br><span class="line">String s5 = <span class="keyword">new</span> String(<span class="string">"Runoob"</span>);   <span class="comment">// String 对象创建</span></span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/javaStringPublicPool.png" alt="公共池和堆" /><figcaption aria-hidden="true">公共池和堆</figcaption></figure><p>String 类是<code>final</code>类，<strong>不可以继承</strong>。对String类型最好的重用方式是<strong>组合</strong>而不是继承。其构造函数源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// copyOf(source[],length); 从源数组的0位置拷贝length个；</span></span><br><span class="line"><span class="comment">// copyOf是用System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength))实现的。</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断offset，count,offset+count是否越界之后</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用StringBuffer/StringBuilder类型初始化String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>String s = new String("xyz");</code> 创建两个对象，一个静态存储区<code>“xyz”</code>，一个用<code>new</code>创建在堆上的对象。但这种说法是片面的。可以参考<a href="https://www.iteye.com/blog/rednaxelafx-774673" target="_blank" rel="noopener">请别再拿“String s = new String("xyz");创建了多少个String实例”来面试了吧</a></p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/javaNew.jpg" alt="String的new反编译" /><figcaption aria-hidden="true"><code>String</code>的new反编译</figcaption></figure><p><code>new</code>只调用了一次，也就是说<strong><u>只创建了一个对象</u></strong>。这段代码在运行期间确实只创建了一个对象，即在堆上创建了<code>"abc"</code>对象。但在类加载的过程中，确实在运行时常量池中创建了一个<code>"abc"</code>对象，而在代码执行过程中确实只创建了一个<code>String</code>对象。因此更准确的说法是 <code>String str = new String("abc")</code> 涉及到2个<code>String</code>对象。</p><blockquote><p>一个是字符串字面量<code>"abc"</code>所对应的、驻留（<code>intern</code>）在一个<strong><u>全局共享的字符串常量池</u></strong>中的实例，另一个是通过<code>new String(String)</code>创建并初始化的、内容与<code>"abc"</code>相同的实例</p></blockquote><h4 id="不可变性">1.2 不可变性</h4><blockquote><p>String 类是<strong>不可改变</strong>的，所以你一旦创建了 String 对象，<u>那它的值就无法改变了</u>。</p></blockquote><p><code>String</code>类中使用<code>“final”</code>修饰的字符数组保存字符串，所以<code>string</code>对象是不可变的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><blockquote><p>“对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex - beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == count)) ? <span class="keyword">this</span> :</span><br><span class="line">        <span class="keyword">new</span> String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[count + otherLen];</span><br><span class="line">    getChars(<span class="number">0</span>, count, buf, <span class="number">0</span>);</span><br><span class="line">    str.getChars(<span class="number">0</span>, otherLen, buf, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(<span class="number">0</span>, count + otherLen, buf);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = count;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line">        <span class="keyword">int</span> off = offset;   <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val[off + i] == oldChar) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; i ; j++) &#123;</span><br><span class="line">            buf[j] = val[off+j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = val[off + i];</span><br><span class="line">            buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(<span class="number">0</span>, len, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub</code>、<code>concat</code>、<code>replace</code>操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。</p><h4 id="多线程安全">1.3 多线程安全</h4><p><code>String</code>中的对象是不可变的，可以理解为常量，<strong>显然线程安全</strong>。</p><h4 id="intern方法">1.4 <code>intern</code>方法</h4><p>在<code>String</code>类中，<code>intern</code>方法是一个本地方法，在<code>JAVA SE6</code>之前，<code>intern</code>方法会<strong><u>在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用，如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用。</u></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"hello"</span>;</span><br><span class="line">        String b =  <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">        String c =  <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">        String d = b.intern();</span><br><span class="line">         </span><br><span class="line">        System.out.println(a==b);</span><br><span class="line">        System.out.println(b==c);</span><br><span class="line">        System.out.println(b==d);</span><br><span class="line">        System.out.println(a==d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h4 id="string类中常用方法">1.5 String类中常用方法</h4><ul><li><p><code>char charAt(int index)</code></p><p>返回指定索引处的 char 值。</p></li><li><p><code>int compareTo(String anotherString)</code> 按字典顺序比较两个字符串。实际上返回的是字符ASCII码的差值，但通常只关心正负还是0</p></li><li><p><code>boolean contains(CharSequence s)</code> 当且仅当此字符串包含指定的 char 值序列时，返回 true。</p></li><li><p><code>boolean startsWith(String prefix)</code> 测试此字符串是否以指定的前缀开始。还可以指定开始检测位置下标</p></li><li><p><code>boolean endsWith(String suffix)</code> 测试此字符串是否以指定的后缀结束。</p></li><li><p><code>boolean equals(Object anObject)</code> 将此字符串与指定的对象比较。已覆写，比较内容是否相等</p></li><li><p><code>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code> 将字符从此字符串复制到目标字符数组。</p></li><li><p><code>int hashCode()</code> 返回此字符串的哈希码。</p></li><li><p><code>int indexOf(int ch)</code> 返回指定字符在此字符串中第一次出现处的索引。 没有则返回-1</p></li><li><p><code>int indexOf(int ch, int fromIndex)</code> 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</p></li><li><p><code>int indexOf(String str)</code> 返回指定子字符串在此字符串中第一次出现处的索引。</p></li><li><p><code>int indexOf(String str, int fromIndex)</code> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</p></li><li><p><code>int lastIndexOf(int ch)</code> 返回指定字符在此字符串中最后一次出现处的索引。</p></li><li><p><code>int lastIndexOf(int ch, int fromIndex)</code> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</p></li><li><p><code>int lastIndexOf(String str)</code> 返回指定子字符串在此字符串中最右边出现处的索引。</p></li><li><p><code>int lastIndexOf(String str, int fromIndex)</code> 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</p></li><li><p><code>int length()</code> 返回此字符串的长度。</p></li><li><p><code>boolean matches(String regex)</code> 告知此字符串是否匹配给定的正则表达式。</p></li><li><p><code>String replace(char oldChar, char newChar)</code> 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</p></li><li><p><code>String replace(CharSequence target, CharSequence replacement)</code> 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</p></li><li><p><code>String replaceAll(String regex, String replacement)</code> 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</p></li><li><p><code>String[] split(String regex)</code> 根据给定正则表达式的匹配拆分此字符串。</p></li><li><p><code>String[] split(String regex, int limit)</code> 根据匹配给定的正则表达式来拆分此字符串。</p></li><li><p><code>String substring(int beginIndex)</code> 返回一个新的字符串，它是此字符串的一个子字符串。</p></li><li><p><code>String substring(int beginIndex, int endIndex)</code> 返回一个新字符串，它是此字符串的一个子字符串。</p></li><li><p><code>char[] toCharArray()</code> 将此字符串转换为一个新的字符数组。</p></li><li><p><code>String toLowerCase()</code> 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</p></li><li><p><code>String toLowerCase(Locale locale)</code> 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</p></li><li><p><code>String toUpperCase()</code> 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</p></li><li><p><code>String toUpperCase(Locale locale)</code> 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写</p></li><li><p><code>String toString()</code> 返回此对象本身。</p></li><li><p><code>isEmpty()</code></p><p>判断字符串是否为空。</p></li></ul><h3 id="stringbuffer-类">2. <code>StringBuffer</code> 类</h3><p>如果需要对字符串对象进行修改，需要使用 <code>StringBuffer</code> 和 <code>StringBuilder</code> 类。和 <code>String</code> 类不同的是，<code>StringBuffer</code> 和 <code>StringBuilder</code> 类是可变的，即对象能够被多次的修改，并且不产生新的未使用对象。</p><blockquote><p>在使用 <code>StringBuffer</code> 类时，每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。</p></blockquote><h4 id="可变性">2.2 可变性</h4><p><code>StringBuilder</code>与<code>StringBuffer</code>都继承自<code>AbstractStringBuilder</code>类，在<code>AbstractStringBuilder</code>中也是使用字符数组保存字符串，但无<code>“final”</code>修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure><h4 id="缓冲区">2.3 缓冲区</h4><p>每个<code>StringBuffer</code>对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer();<span class="comment">//分配长16字节的字符缓冲区</span></span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer(<span class="number">512</span>); <span class="comment">//分配长512字节的字符缓冲区</span></span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer(<span class="string">"this is a test"</span>); <span class="comment">//在缓冲区中存放了字符串，并在后面预留了16字节的空缓冲区。</span></span><br></pre></td></tr></table></figure><h4 id="多线程安全-1">2.4 多线程安全</h4><p><code>StringBuffer</code>对方法加了<code>同步锁</code>或者对调用的方法加了<code>同步锁</code>，所以是<strong>线程安全的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.reverse();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);  <span class="comment">//存在 public synchronized int indexOf(String str, int fromIndex) 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主要方法">2.5 主要方法</h4><ul><li><p><code>public StringBuffer append(String s)</code></p><p>将指定的字符串追加到此字符序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) str = <span class="string">"null"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);<span class="comment">//查看使用空间满足，不满足扩展空间</span></span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);<span class="comment">//getChars就是利用native的array copy,性能高效</span></span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>public StringBuffer reverse()</code></p><p>将此字符序列用其反转形式取代。</p></li><li><p><code>public delete(int start, int end)</code></p><p>移除此序列的子字符串中的字符。</p></li><li><p><code>public insert(int offset, int i)</code></p><p>将 int 参数的字符串表示形式插入此序列中。</p></li><li><p><code>insert(int offset, String str)</code></p><p>将 str 参数的字符串插入此序列中。</p></li><li><p><code>replace(int start, int end, String str)</code></p><p>使用给定 String 中的字符替换此序列的子字符串中的字符。</p></li><li><p><code>void setCharAt(int index, char ch)</code></p><p>将给定索引处的字符设置为 <code>ch</code>。</p></li><li><p><code>void setLength(int newLength)</code></p><p>设置字符序列的长度。</p></li><li><p><code>String toString()</code></p></li></ul><p>返回此序列中数据的字符串表示形式。</p><h3 id="stringbuilder-类">3. <code>StringBuilder</code> 类</h3><p><code>StringBuilder</code> 类在 <strong><code>Java 5</code></strong> 中被提出，它和 <code>StringBuffer</code>类功能基本相似，主要区别在于 <code>StringBuilder</code> 的方法不是线程安全的（不能同步访问）。</p><h4 id="可变性-1">3.2 可变性</h4><p><code>StringBuilder</code>与<code>StringBuffer</code>相同，是可变的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure><h4 id="多线程安全-2">3.3 多线程安全</h4><p><code>StringBuilder</code>没有对方法进行加同步锁，所以是<strong>非线程安全的</strong>。</p><blockquote><p>如果程序不是多线程的，那么使用<code>StringBuilder</code>效率高于<code>StringBuffer</code>。</p></blockquote><h3 id="主要区别与适用场景">4. 主要区别与适用场景</h3><p>主要区别是：</p><ul><li><code>String</code>：是<strong>不可改变</strong>的量，也就是创建后就不能在修改了。</li><li><code>StringBuffer</code>：是一个<strong>可变</strong>字符串序列。</li><li><code>StringBuilder</code>：与 <code>StringBuffer</code> 类基本相同，都是可变字符换字符串序列，不同点是 <code>StringBuffer</code> 是<strong>线程安全</strong>的，<code>StringBuilder</code> 是<strong>非线程安全</strong>的。</li></ul><p>适用场景：</p><ul><li><code>String</code> 类：在字符串不经常变化的场景中可以使用 <code>String</code> 类，例如常量的声明、少量的变量运算。</li><li><code>StringBuffer</code> 类：在频繁进行字符串运算（如拼接、替换、删除等），并且运行在<strong>多线程环境</strong>中，则可以考虑使用 <code>StringBuffer</code>，例如 <code>HTTP</code> 参数解析和封装。</li><li><code>StringBuilder</code> 类：在频繁进行字符串运算（如拼接、替换、和删除等），并且运行在<strong>单线程</strong>的环境中，则可以考虑使用 <code>StringBuilder</code>，如 <code>JSON</code> 封装等。</li></ul><p>性能：</p><p><code>String</code> 类的操作是<strong><u>产生新的 <code>String</code> 对象</u></strong>，而 <code>StringBuilder</code> 和 <code>StringBuffer</code> 是一个<strong>字符数组的扩容</strong>，所以 <code>String</code> 类的操作要远慢于 <code>StringBuffer</code> 和 <code>StringBuilder</code>。</p><ul><li>对 <code>String</code> 类型进行改变的时候其实都等同于<code>生成了一个新的 String 对象</code>，<code>然后将指针指向新的 String 对象</code>。所以经常改变内容的字符串会因<code>频繁生成对象对系统性能产生影响，内存不够时JVM 的 GC 就会开始工作</code>。</li><li><code>StringBuffer</code>每次结果都会对 <code>StringBuffer</code> 对象本身进行操作。</li><li>某些特别情况下， <code>String</code> 对象的字符串拼接其实是被 <code>JVM</code> 解释成了 <code>StringBuffer</code> 对象的拼接，所以这些时候 <code>String</code> 对象的速度并不会比 <code>StringBuffer</code> 对象慢。</li></ul><h3 id="参考文献">参考文献</h3><ol type="1"><li><a href="https://www.runoob.com/java/java-string.html" target="_blank" rel="noopener">Java String 类</a></li><li><a href="https://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="noopener">Java StringBuffer 和 StringBuilder 类</a></li><li><a href="https://www.jb51.net/article/33398.htm" target="_blank" rel="noopener">全面解释java中StringBuilder、StringBuffer、String类之间的关系</a></li><li><a href="https://segmentfault.com/a/1190000002683782" target="_blank" rel="noopener">浅谈 Java 字符串（String, StringBuffer, StringBuilder）</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3778589.html" target="_blank" rel="noopener">探秘Java中的String、StringBuilder以及StringBuffer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;字符串在&lt;code&gt;Java&lt;/code&gt;中被广泛应用，学习一下&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;StringBuilder&lt;/code&gt;和&lt;code&gt;StringBuffer&lt;/code&gt;这几个类之间的异同和适用场景。
    
    </summary>
    
      <category term="Java" scheme="https://wuyunjie.top/categories/Java/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="String" scheme="https://wuyunjie.top/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--13 线程安全与锁优化</title>
    <link href="https://wuyunjie.top/2021/06/07/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_13_Thread_safety_and_lock_optimization.html"/>
    <id>https://wuyunjie.top/2021/06/07/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_13_Thread_safety_and_lock_optimization.html</id>
    <published>2021-06-07T06:45:04.000Z</published>
    <updated>2021-06-07T06:45:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>首先需要保证并发的正确性，然后在此基础上来实现高效。 <a id="more"></a></p></blockquote><h3 id="线程安全">1. 线程安全</h3><blockquote><p><code>“线程安全”</code>是<code>“当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。”</code></p></blockquote><h4 id="java语言中的线程安全">1.1 Java语言中的线程安全</h4><p>将Java语言中各种操作共享的数据分为以下五类：<code>不可变</code>、<code>绝对线程安全</code>、<code>相对线程安全</code>、<code>线程兼容</code>和<code>线程对立</code>。</p><h5 id="不可变">1.1.1 不可变</h5><p><code>不可变（Immutable）</code>的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。</p><ul><li>如果多线程共享的数据是一个<code>基本数据类型</code>，那么只要在定义时使用<code>final</code>关键字修饰它就可以保证它是不可变的。</li><li>如果共享数据是一个<code>对象</code>，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。<ul><li>Java类库<code>API</code>中<code>不可变</code>的类型，除了<code>String</code>外，常用的还有<code>枚举类型</code>及<code>java.lang.Number</code>的部分子类。</li></ul></li></ul><h5 id="绝对线程安全">1.1.2 绝对线程安全</h5><p><code>绝对的线程安全</code>能够完全满足给出的线程安全的定义，但一个类要达到<code>“不管运行时环境如何，调用者都不需要任何额外的同步措施”</code>可能需要付出非常高昂的， 甚至不切实际的代价。</p><p>在<code>Java API</code>中标注自己是线程安全的类，大多数都<strong>不是绝对的线程安全</strong>。</p><h5 id="相对线程安全">1.1.3 相对线程安全</h5><p><code>相对线程安全</code>就是通常意义上所讲的线程安全，它需要<u><strong>保证对这个对象单次的操作是线程安全的，在调用的时候不需要进行额外的保障措施</strong></u>，但是对于一些<strong>特定顺序的连续调用</strong>，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><h5 id="线程兼容">1.1.4 线程兼容</h5><p><code>线程兼容</code>是指<u>对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用</u>。平常说一个类不是线程安全的，通常就是指这种情况。</p><h5 id="线程对立">1.1.5 线程对立</h5><p><code>线程对立</code>是指<u>不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码</u>。</p><h4 id="线程安全的实现方法">1.2 线程安全的实现方法</h4><h5 id="互斥同步">1.2.1 互斥同步</h5><p><code>互斥同步（Mutual Exclusion &amp; Synchronization）</code>是一种最常见也是最主要的并发正确性保障手段。</p><ul><li><code>同步</code>是指<u>在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用</u>。</li><li><code>互斥</code>是实现同步的一种手段，<code>临界区（Critical Section）</code>、<code>互斥量（Mutex）</code>和<code>信号量（Semaphore）</code>都是常见的互斥实现方式。</li></ul><p>在<code>Java</code>里面，最基本的互斥同步手段就是<code>synchronized</code>关键字。</p><blockquote><p><code>synchronized</code>关键字经过<code>Javac</code>编译之后，会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令。这两个字节码指令都需要一个<code>reference</code>类型的参数来指明要锁定和解锁的对象。</p><ul><li>在执行<code>monitorenter</code>指令时，首先要去尝试获取对象的<code>锁</code>。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把<code>锁的计数器</code>的值增加一</li><li>在执行<code>monitorexit</code>指令时会将<code>锁计数器</code>的值减一。一旦计数器的值为零，锁随即就被释放了。</li><li>如果获取对象锁失败，那当前线程就应当被<code>阻塞等待</code>，直到请求锁定的对象被持有它的线程释放为止。</li></ul></blockquote><p>两个关于<code>synchronized</code>的直接推论：</p><ul><li>被<code>synchronized</code>修饰的同步块对<strong>同一条线程</strong>来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li><li>被<code>synchronized</code>修饰的同步块在<u>持有锁的线程执行完毕并释放锁之前</u>，会<strong>无条件地阻塞后面其他线程的进入</strong>。这意味着<u>无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁</u>；也<u>无法强制正在等待锁的线程中断等待或超时退出</u>。</li></ul><p>持有锁是一个<code>重量级（Heavy-Weight）</code>的操作，尤其是对于代码特别简单的同步块，状态转换消耗的时间甚至会比用户代码本身执行的时间还要长。<code>JDK 5</code>起提供了<code>java.util.concurrent.locks.Lock</code>接口，作为另一种全新的互斥同步手段。基于<code>Lock</code>接口，用户能够以<code>非块结构（Non-Block Structured）</code>来实现互斥同步，在<strong>类库层面去实现同步</strong>。</p><p><code>重入锁（ReentrantLock）</code>是<code>Lock</code>接口最常见的一种实现，它与<code>synchronized</code>一样是可重入的。主要增加了以下三项高级功能：</p><ul><li><code>等待可中断</code>：是指<u>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</u>。</li><li><code>公平锁</code>：是指<u>多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</u>；而<code>非公平锁</code>则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。<ul><li><code>synchronized</code>中的锁是非公平的；</li><li><code>ReentrantLock</code>在<strong>默认情况</strong>下也是非公平的，但可以通过构造函数要求使用公平锁。但一旦使用了公平锁，将会导致<code>ReentrantLock</code>的性能急剧下降，会明显影响吞吐量。</li></ul></li><li><code>锁绑定多个条件</code>：是指<u><strong>一个<code>ReentrantLock</code>对象可以同时绑定多个<code>Condition</code>对象</strong></u>。</li></ul><h5 id="非阻塞同步">1.2.2 非阻塞同步</h5><p>互斥同步面临的主要问题是进行线程<strong>阻塞</strong>和<strong>唤醒</strong>所带来的性能开销，因此这种同步也被称为<code>阻塞同步（Blocking Synchronization）</code>，互斥同步属于一种<strong>悲观的并发策略</strong>。</p><p>另外有一种基于<code>冲突检测</code>的<strong>乐观并发策略</strong>，通俗地说就是<u><strong>不管风险，先进行操作</strong></u>：</p><ul><li>如果<strong>没有</strong>其他线程争用共享数据，那操作就直接成功；</li><li>如果<strong>有</strong>其他线程争用共享数据，产生了冲突，再进行其他的补偿措施，比如不断地重试，直到出现没有竞争的共享数据为止。</li></ul><p>这种乐观并发策略的实现<strong><u>不再需要把线程阻塞挂起</u></strong>，因此这种同步操作被称为<code>非阻塞同步（Non-Blocking Synchronization）</code>，使用这种措施的代码也常被称为<code>无锁（Lock-Free）编程</code>。</p><p>乐观并发策略需要<code>“硬件指令集的发展”</code>，因为要求<code>操作</code>和<code>冲突检测</code>这两个步骤具备<strong>原子性</strong>。硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，这类指令常用的有：</p><ul><li><code>测试并设置（Test-and-Set）</code>；</li><li><code>获取并增加（Fetch-and-Increment）</code>；</li><li><code>交换（Swap）</code>；</li><li><code>比较并交换（Compare-and-Swap）</code>；</li><li><code>加载链接/条件储存（Load-Linked/Store-Conditional）</code>。</li></ul><h5 id="无同步方案">1.2.3 无同步方案</h5><p>同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的：</p><ul><li><code>可重入代码（Reentrant Code）</code>：这种代码又称<code>纯代码（Pure Code）</code>，是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。<ul><li><code>可重入代码</code>有一些共同的特征，例如<u>不依赖全局变量、存储在堆上的数据和公用的系统资源</u>， 用到的状态量都由参数中传入，不调用非可重入的方法等。</li><li>如果一个方法的返回结果是<strong>可以预测的</strong>，那它就满足可重入性的要求。</li></ul></li><li><code>线程本地存储（Thread Local Storage）</code>：如果一段代码中所需要的数据必须与其他代码共享，如果能保证这些共享数据的代码在同一个线程中执行，就可以把共享数据的可见范围限制在同一个线程之内，无须同步也能保证线程之间不出现数据争用的问题。</li></ul><h3 id="锁优化">2. 锁优化</h3><h4 id="自旋锁与自适应自旋adaptive-spinning">2.1 自旋锁与自适应自旋（Adaptive Spinning）</h4><p>如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，就可以让后面请求锁的那个线程<code>“稍等一会”</code>，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，只须让线程执行一个<code>忙循环（自旋）</code>，这项技术就是所谓的<code>自旋锁</code>。</p><blockquote><ul><li>自旋等待本身虽然避免了<code>线程切换</code>的开销，但它需要<strong>占用处理器时间</strong>，所以如果锁被占用的时间很短，自旋等待的效果就会非常好；</li><li>反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。</li></ul></blockquote><p>自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。引入了<code>自适应的自旋</code>，自旋的时间不再是固定，而是由<u><strong>前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</strong></u>的。</p><h4 id="锁消除lock-elimination">2.2 锁消除（Lock Elimination）</h4><p>锁消除是指虚<u>拟机即时编译器在运行时，对一些代码要求同步，但是对<strong>被检测到不可能存在共享数据竞争的锁</strong>进行消除</u>。</p><blockquote><p>锁消除的主要判定依据来源于<code>逃逸分析</code>的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以认为它们是<code>线程私有</code>的。</p></blockquote><h4 id="锁粗化lock-coarsening">2.3 锁粗化（Lock Coarsening）</h4><p>如果一系列的<code>连续操作</code>都对<strong>同一个对象</strong>反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围<strong><code>扩展（粗化）</code>到整个操作序列的外部</strong>。</p><h4 id="轻量级锁lightweight-locking">2.4 轻量级锁（Lightweight Locking）</h4><p><code>HotSpot</code>虚拟机的<code>对象头（Object Header）</code>分为两部分：</p><ul><li>第一部分用于<strong><u>存储对象自身的运行时数据</u></strong>，如<code>哈希码（HashCode）</code>、<code>GC分代年龄（Generational GC Age）</code> 等，官方称为<code>“Mark Word”</code>。这部分是实现轻量级锁和偏向锁的关键。</li><li>另一部分用于<u><strong>存储指向方法区对象类型数据的指针</strong></u>，如果是数组对象，还会有一个额外的部分用于存储数组长度。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/HotSpotMarkWord.PNG" alt="HotSpot虚拟机对象头Mark Word" /><figcaption aria-hidden="true">HotSpot虚拟机对象头Mark Word</figcaption></figure><p>轻量级锁的工作过程：</p><ul><li>在代码即将进入同步块的时候，如果此同步对象<strong>没有被锁定</strong>（锁标志位为<code>“01”</code>状态），虚拟机首先将在当前线程的栈帧中建立一个名为<code>锁记录（Lock Record）</code>的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝（即<code>Displaced Mark Word</code>）</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/BeforeCAS.PNG" alt="轻量级锁CAS操作之前堆栈与对象的状态" /><figcaption aria-hidden="true">轻量级锁CAS操作之前堆栈与对象的状态</figcaption></figure><ul><li>然后，虚拟机将使用<code>CAS</code>操作尝试把对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。<ul><li>如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象<code>Mark Word</code>的<code>锁标志位</code>将转变为<code>“00”</code>，表示此对象处于轻量级锁定状态。</li><li>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，<ul><li>如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行；</li><li>否则，就说明这个锁对象已经被其他线程抢占了。</li></ul></li><li>如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要<strong>膨胀为重量级锁</strong>，锁标志的状态值变为<code>“10”</code>，此时<code>Mark Word</code>中存储的就是指向<code>重量级锁（互斥量）</code>的指针，后面等待锁的线程也必须进入阻塞状态。</li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/AfterCAS.PNG" alt="轻量级锁CAS操作之后堆栈与对象的状态" /><figcaption aria-hidden="true">轻量级锁CAS操作之后堆栈与对象的状态</figcaption></figure><p>轻量级锁的解锁过程也同样是通过<code>CAS</code>操作来进行的：</p><ul><li>如果对象的<code>Mark Word</code>仍然指向线程的锁记录，那就用<code>CAS</code>操作把对象当前的<code>Mark Word</code>和线程中复制的<code>Displaced Mark Word</code>替换回来。</li><li>假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</li></ul><h4 id="偏向锁biased-locking">2.5 偏向锁（Biased Locking）</h4><p>偏向锁的目的是<u><strong>消除数据在无竞争情况下的同步原语</strong></u>， 进一步提高程序的运行性能。</p><blockquote><p>偏向锁是在无竞争的情况下把整个同步都消除掉，连<code>CAS</code>操作都不去做了。</p></blockquote><ul><li>假设当前虚拟机启用了偏向锁，那么当锁对象<strong>第一次</strong>被线程获取的时候，虚拟机将会把对象头中的<code>标志位</code>设置为<code>“01”</code>、把<code>偏向模式</code>设置为<code>“1”</code>，表示进入<strong>偏向模式</strong>。同时使用<code>CAS</code>操作把获取到这个锁的线程的<code>ID</code>记录在对象的<code>Mark Word</code>之中。如果<code>CAS</code>操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。</li><li>一旦出现另外一个线程去尝试获取这个锁的情况，<strong>偏向模式</strong>就<u>马上宣告结束</u>。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为<code>“0”</code>），撤销后标志位恢复到未锁定（标志位为<code>“01”</code>）或轻量级锁定（标志位为<code>“00”</code>）的状态，后续的同步操作就按照轻量级锁那样去执行。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/BiasedLocking.PNG" alt="偏向锁、轻量级锁的状态转化及对象Mark Word的关系" /><figcaption aria-hidden="true">偏向锁、轻量级锁的状态转化及对象Mark Word的关系</figcaption></figure><ul><li>当一个对象已经计算过<code>一致性哈希码</code>后，它就再也无法进入偏向锁状态了；</li><li>当一个对象当前正处于<code>偏向锁</code>状态，又收到需要计算其<code>一致性哈希码</code>请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的<code>ObjectMonitor</code>类里有字段可以记录非加锁状态（标志位为<code>“01”</code>）下的<code>Mark Word</code>，其中自然可以存储原来的哈希码。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;首先需要保证并发的正确性，然后在此基础上来实现高效。
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--12  Java内存模型与线程</title>
    <link href="https://wuyunjie.top/2021/06/06/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_12_Java_memory_model_and_threads.html"/>
    <id>https://wuyunjie.top/2021/06/06/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_12_Java_memory_model_and_threads.html</id>
    <published>2021-06-06T05:02:04.000Z</published>
    <updated>2021-06-06T05:02:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>并发处理是人类压榨计算机运算能力的最有力武器。 <a id="more"></a></p></blockquote><h3 id="硬件的效率与一致性">1. 硬件的效率与一致性</h3><p>绝大多数的运算任务都不可能只靠处理器<code>“计算”</code>就能完成。处理器至少要与内存交互，如<u>读取运算数据</u>、 <u>存储运算结果</u>等，这个I/O操作很难消除（无法仅靠寄存器来完成所有运算任务）。</p><p>由于计算机的存储设备与处理器的运算速度有着几个<strong>数量级的差距</strong>，所以现代计算机系统都不得不加入<em>一层</em>或<em>多层</em>读写速度尽可能接近处理器运算速度的<code>高速缓存（Cache）</code>来作为内存与处理器之间的缓冲：</p><blockquote><p>将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p></blockquote><p>基于高速缓存的存储交互引入了一个新的问题：<code>缓存一致性（Cache Coherence）</code>。</p><blockquote><p>在多路处理器系统中，每 个处理器都有自己的高速缓存，而它们又共享同一<code>主内存（Main Memory）</code>，这种系统称为<code>共享内存多核系统（Shared Memory Multiprocessors System）</code>。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的<u><strong>缓存数据不一致</strong></u>。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/SharedMemoryMultiprocessorsSystem.PNG" alt="处理器、高速缓存、主内存间的交互关系" /><figcaption aria-hidden="true">处理器、高速缓存、主内存间的交互关系</figcaption></figure><p>为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有<code>MSI</code>、<code>MESI（Illinois Protocol）</code>、<code>MOSI</code>、 <code>Synapse</code>、<code>Firefly</code>及<code>Dragon Protocol</code>等。</p><h3 id="java内存模型">2. Java内存模型</h3><p><code>“Java内存模型”</code>（<code>Java Memory Model，JMM</code>）用于<u><strong>屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果</strong></u>。</p><h4 id="主内存与工作内存">2.1 主内存与工作内存</h4><p>Java内存模型的主要目的是定义程序中各种<code>变量（Variables）</code>的访问规则，即关注在虚拟机中把变量值<u><strong>存储到内存</strong></u>和<u><strong>从内存中取出</strong></u>变量值这样的底层细节。</p><blockquote><p>此处的变量<strong>包括</strong><u>实例字段</u>、<u>静态字段</u>和<u>构成数组对象的元素</u>，但是<strong>不包括</strong><u>局部变量</u>与<u>方法参数</u>，因为后者是<u><strong>线程私有</strong></u>的，不会被共享，不会存在竞争问题。</p></blockquote><p>Java内存模型规定了所有的变量都存储在<code>主内存（Main Memory）</code>中，每条线程还有自己的<code>工作内存（Working Memory）</code>，线程的工作内存中保存了被该线程<u><strong>使用的变量的主内存副本</strong></u>，线程对变量的所有操作（读取、赋值等）都<u><strong>必须在工作内存中进行，而不能直接读写主内存中的数据</strong></u>。不同的线程之间也无法直接访问对方工作内存中的变量，<u><strong>线程间变量值的传递均需要通过主内存来完成</strong></u>。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaMemoryModel.PNG" alt="线程、主内存、工作内存三者的交互关系" /><figcaption aria-hidden="true">线程、主内存、工作内存三者的交互关系</figcaption></figure><h4 id="内存间交互操作">2.2 内存间交互操作</h4><p>关于主内存与工作内存之间具体的交互协议，即一个变量<u>如何从主内存拷贝到工作内存</u>、<u>如何从工作内存同步回主内存</u>这一类的实现细节，Java内存模型中定义了以下8种操作来完成，每一种操作都是原子的、不可再分的：</p><ul><li><code>lock（锁定）</code>：作用于<strong>主内存</strong>的变量，它<strong>把一个变量标识为一条线程独占的状态</strong>。</li><li><code>unlock（解锁）</code>：作用于<strong>主内存</strong>的变量，它<strong>把一个处于锁定状态的变量释放出来</strong>，释放后的变量才可以被其他线程锁定。</li><li><code>read（读取）</code>：作用于<strong>主内存</strong>的变量，它<strong>把一个变量的值从主内存传输到线程的工作内存中</strong>，以便随后的<code>load</code>动作使用。</li><li><code>load（载入）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把<code>read</code>操作从主内存中得到的变量值放入工作内存的变量副本中</strong>。</li><li><code>use（使用）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把工作内存中一个变量的值传递给执行引擎</strong>，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><code>assign（赋值）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把一个从执行引擎接收的值赋给工作内存的变量</strong>， 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><code>store（存储）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把工作内存中一个变量的值传送到主内存中</strong>，以便随后的<code>write</code>操作使用。</li><li><code>write（写入）</code>：作用于<strong>主内存</strong>的变量，它<strong>把<code>store</code>操作从工作内存中得到的变量的值放入主内存的变量中</strong>。</li></ul><p>Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p><ul><li>不允许<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它最近的<code>assign</code>操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何<code>assign</code>操作）把数据从线程的工作内存同步回主内存中。</li><li>一个新的变量只能在<strong>主内存</strong>中<code>“诞生”</code>，不允许在工作内存中直接使用一个未被初始化（<code>load</code>或 <code>assign</code>）的变量，换句话说就是对一个变量实施<code>use</code>、<code>store</code>操作之前，必须先执行<code>assign</code>和<code>load</code>操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行<code>lock</code>操作，但<code>lock</code>操作可以被同一条线程重复执行多次，多次执行<code>lock</code>后，只有执行<strong>相同次数</strong>的<code>unlock</code>操作，变量才会被解锁。</li><li>如果对一个变量执行<code>lock</code>操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行<code>load</code>或<code>assign</code>操作以初始化变量的值。</li><li>如果一个变量事先没有被<code>lock</code>操作锁定，那就不允许对它执行<code>unlock</code>操作，也不允许去<code>unlock</code>一个被<strong>其他线程</strong>锁定的变量。</li><li>对一个变量执行<code>unlock</code>操作之前，必须先把此变量同步回主内存中（执行<code>store</code>、<code>write</code>操作）。</li></ul><p>Java内存模型的操作在最新的<code>JSR-133</code>文档中简化为<code>read</code>、<code>write</code>、<code>lock</code>和<code>unlock</code>四种，但这只是语言描述上的等价化简，Java内存模型的基础设计并未改变。</p><h4 id="对于volatile型变量的特殊规则">2.3 对于volatile型变量的特殊规则</h4><p>关键字<code>volatile</code>可以说是Java虚拟机提供的<strong>最轻量级</strong>的<code>同步机制</code>，Java内存模型为<code>volatile</code>专门定义了一些特殊的访问规则，当一个变量被定义成<code>volatile</code>之后，它将具备两项特性：</p><h5 id="保证此变量对所有线程的可见性">2.3.1 保证此变量对所有线程的<code>可见性</code></h5><p>这里的<code>“可见性”</code>是指<u>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</u>。而普通变量的值在线程间传递时均需要通过主内存来完成。</p><blockquote><p><code>volatile</code>变量依然有工作内存的拷贝，但是由于它<strong><u>特殊的操作顺序性规定</u></strong>，所以看起来如同直接在主内存中读写访问一般。</p></blockquote><p><code>volatile</code>变量在各个线程的工作内存中是不存在一致性问题的，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile变量自增运算测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码并不会获得期望的结果，而且每次运行程序输出的结果都不一样。用<code>Javap</code>反编译这段代码后发现<code>increase()</code>方法在<code>Class</code>文件中是由4条字节码指令构成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void increase();</span><br><span class="line">Code:</span><br><span class="line">Stack=2, Locals=0, Args_size=0</span><br><span class="line">0: getstatic #13; //Field race:I</span><br><span class="line">3: iconst_1</span><br><span class="line">4: iadd</span><br><span class="line">5: putstatic #13; //Field race:I</span><br><span class="line">8: return</span><br><span class="line">LineNumberTable:</span><br><span class="line">line 14: 0</span><br><span class="line">line 15: 8</span><br></pre></td></tr></table></figure><blockquote><p>并发失败的原因：当<code>getstatic</code>指令把<code>race</code>的值取到<strong>操作栈顶</strong>时，<code>volatile</code>关键字保证了<code>race</code>的值在此时是正确的，但是在执行<code>iconst_1</code>、<code>iadd</code>指令时，其他线程可能已经把<code>race</code>的值改变了，而操作栈顶的值就变成了<strong>过期的数据</strong>，所以<code>putstatic</code>指令执行后就可能把<strong>较小的race值</strong>同步回主内存之中。</p></blockquote><p>由于<code>volatile</code>变量只能保证可见性，在<strong><u>不符合</u></strong>以下两条规则的运算场景中，仍然要通过加锁来保证原子性：</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><h5 id="禁止指令重排序优化">2.3.2 禁止指令重排序优化</h5><p>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而<u>不能保证变量赋值操作的顺序与程序代码中的执行顺序一致</u>，即<code>“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="comment">// 此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">// 模拟读取配置信息，当读取完成后</span></span><br><span class="line"><span class="comment">// 将initialized设置为true,通知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span> (!initialized) &#123;</span><br><span class="line">sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure><p>如果定义<code>initialized</code>变量时没有使用<code>volatile</code>修饰，就可能会由于<code>指令重排序的优化</code>，导致位于线程<code>A</code>中最后一条 代码<code>“initialized=true”</code>被提前执行（实际上<code>重排序优化</code>是<strong>机器级</strong>的优化操作），这样在线程<code>B</code>中使用配置信息的代码就可能出现错误。</p><p>下面是标准的<code>双锁检测（Double Check Lock，DCL）</code>单例的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有<code>volatile</code>修饰的变量，赋值后多执行了一个<code>“lock addl$0x0，(%esp)”</code>操作，这个操作的作用相当于一个<code>内存屏障</code>（<code>Memory Barrier</code>或<code>Memory Fence</code>，指重排序时不能把后面的指令重排序到内存屏障之前的位置）。</p><p><code>“addl$0x0，(%esp)”</code>（把ESP寄存器的值加0）是一个<strong>空操作</strong>。</p><blockquote><p>之所以用这个空操作而不是空操作专用指令<code>nop</code>，是因为<code>IA32</code>手册规定<code>lock</code>前缀不允许配合<code>nop</code>指令使用。</p></blockquote><p>它的作用是将本处理器的缓存写入了内存，该写入动作也会引起别的处理器或者别的内核<code>无效化（Invalidate）</code>其缓存。所以通过这样一个空操作，可让前面<code>volatile</code>变量的修改对其他处理器立即可见。</p><p>在volatile与锁中选择的<strong>唯一判断依据</strong>仅仅是<u><code>volatile</code>的语义能否满足使用场景的需求</u>。假定<code>T</code>表示一个线程，<code>V</code>和<code>W</code>分别表示两个<code>volatile</code>型变量，那么在进行<code>read</code>、<code>load</code>、<code>use</code>、<code>assign</code>、<code>store</code>和<code>write</code>操作时需要满足如下规则：</p><ul><li>在<strong>工作内存</strong>中，每次使用<code>V</code>前都必须先从<strong>主内存</strong><u>刷新最新的</u>值，用于保证能看见其他线程对变量V所做的修改。<ul><li>只有当线程<code>T</code>对变量<code>V</code>执行的前一个动作是<code>load</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>use</code>动作；</li><li>只有当线程<code>T</code>对变量<code>V</code>执行的后一个动作是<code>use</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>load</code>动作。</li><li>线程<code>T</code>对变量<code>V</code>的<code>use</code>动作可以认为是和线程<code>T</code>对变量<code>V</code>的<code>load</code>、<code>read</code>动作相关联的，必须连续且一起出现。</li></ul></li><li>在<strong>工作内存</strong>中，每次修改<code>V</code>后都必须<strong>立刻</strong>同步回<strong>主内存</strong>中，用于保证其他线程可以看到自己对变量V所做的修改。<ul><li>只有当线程<code>T</code>对变量<code>V</code>执行的前一个动作是<code>assign</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>store</code>动作；</li><li>只有当线程<code>T</code>对变量|V执行的后一个动作是<code>store</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>assign</code>动作。</li><li>线程<code>T</code>对变量<code>V</code>的<code>assign</code>动作可以认为是和线程<code>T</code>对变量<code>V</code>的<code>store</code>、<code>write</code>动作相关联的，必须连续且一起出现。</li></ul></li><li><code>volatile</code>修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。<ul><li>假定动作<code>A</code>是线程<code>T</code>对变量<code>V</code>实施的<code>use</code>或<code>assign</code>动作，假定动作<code>F</code>是和动作<code>A</code>相关联的<code>load</code>或<code>store</code>动 作，假定动作<code>P</code>是和动作<code>F</code>相应的对变量<code>V</code>的<code>read</code>或<code>write</code>动作；</li><li>假定动作<code>B</code>是线程<code>T</code>对变量<code>W</code>实施的<code>use</code>或<code>assign</code>动作，假定动作<code>G</code>是和动作<code>B</code>相关联的<code>load</code>或<code>store</code>动作，假定动作<code>Q</code>是和动作<code>G</code>相应的对变量<code>W</code>的<code>read</code>或<code>write</code>动作。</li><li><strong>如果<code>A</code>先于<code>B</code>，那么<code>P</code>先于<code>Q</code></strong>。</li></ul></li></ul><h4 id="针对long和double型变量的特殊规则">2.4 针对long和double型变量的特殊规则</h4><p>Java内存模型要求上述八种操作都具有<code>原子性</code>， 但是对于<code>64</code>位的数据类型（<code>long</code>和<code>double</code>），在模型中特别定义了一条宽松的规定：</p><blockquote><p>允许虚拟机将<strong>没有</strong>被<code>volatile</code>修饰的<code>64</code>位数据的读写操作划分为两次<code>32</code>位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的<code>load</code>、<code>store</code>、<code>read</code>和<code>write</code>这四个操作的原子性，这就是所谓的<code>“long和double的非原子性协定”（Non-Atomic Treatment of double and long Variables）</code>。</p></blockquote><p>读取到<code>“半个变量”</code>的情况是非常罕见的，除非该数据有明确可知的线程竞争，否则在编写代码时一般不需要因为这个原因刻意把用到的<code>long</code>和<code>double</code>变量专门声明为<code>volatile</code>。</p><h4 id="原子性可见性与有序性">2.5 原子性、可见性与有序性</h4><p>Java内存模型是围绕着在并发过程中如何处理<code>原子性</code>、<code>可见性</code>和<code>有序性</code>这三个特征来建立的。</p><h5 id="原子性atomicity">2.5.1 <code>原子性（Atomicity）</code></h5><p>由Java内存模型来<strong>直接保证</strong>的原子性变量操作包括<code>read</code>、<code>load</code>、<code>assign</code>、<code>use</code>、<code>store</code>和<code>write</code>，基本数据类型的<strong>访问</strong>、<strong>读写</strong>都是具备原子性的。</p><p>Java内存模型提供了<code>lock</code>和<code>unlock</code>操作来满足更大范围的原子性保证，尽管虚拟机未把<code>lock</code>和<code>unlock</code>操作直接开放给用户使用，但是却提供了更高层次的字节码指令<code>monitorenter</code>和<code>monitorexit</code>来隐式地使用这两个操作。这两个字节码指令反映到Java 代码中就是同步块——<code>synchronized</code>关键字，因此在<code>synchronized</code>块之间的操作也具备原子性。</p><h5 id="可见性visibility">2.5.2 <code>可见性（Visibility）</code></h5><p>可见性就是指<u>当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改</u>。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。</p><blockquote><p>volatile的特殊规则保证了新值能<strong>立即同步到主内存</strong>，以及每次使用前<strong>立即从主内存刷新</strong>。</p></blockquote><p>除了<code>volatile</code>之外，<code>synchronized</code>和<code>final</code>两个关键字也能实现可见性。</p><ul><li><code>synchronized</code>同步块的可见性是由<code>“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”</code>这条规则获得的。</li><li><code>final</code>关键字的可见性是指：被<code>final</code>修饰的字段在构造器中一旦被初始化完成，并且构造器没有把<code>“this”</code>的引用传递出去，那么在其他线程中就能看见<code>final</code>字段的值。</li></ul><h5 id="有序性ordering">2.5.3 <code>有序性（Ordering）</code></h5><p>Java程序中天然的有序性即：</p><ul><li>如果在本线程内观察，所有的操作都是有序的，指<code>“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）</code>；</li><li>如果在一个线程中观察另一个线程， 所有的操作都是无序的，是指<code>“指令重排序”</code>现象和<code>“工作内存与主内存同步延迟”</code>现象。</li></ul><p>Java语言提供了<code>volatile</code>和<code>synchronized</code>两个关键字来保证线程之间操作的有序性。</p><h4 id="先行发生原则">2.6 先行发生原则</h4><p>Java语言的<code>“先行发生”（Happens-Before）原则</code>，是判断<u>数据是否存在竞争</u>，<u>线程是否安全</u>的手段。</p><blockquote><p><code>先行发生</code>是Java内存模型中定义的两项操作之间的<code>偏序关系</code>，比如说<code>操作A</code>先行发生于<code>操作B</code>，其实就是说在发生<code>操作B</code>之前，<code>操作A</code>产生的影响能被<code>操作B</code>观察到，<code>“影响”</code>包括<u>修改了内存中共享变量的值</u>、<u>发送了消息</u>、<u>调用了方法</u>等。</p></blockquote><p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系<u>无须任何同步器协助就已经存在</u>，可以在编码中直接使用。</p><ul><li><code>程序次序规则（Program Order Rule）</code>：在一个线程内，按照<strong><u>控制流顺序</u></strong>，书写在前面的操作先行发生于书写在后面的操作。</li><li><code>管程锁定规则（Monitor Lock Rule）</code>：一个<code>unlock</code>操作先行发生于后面对<strong>同一个锁</strong>的<code>lock</code>操作。</li><li><code>volatile变量规则（Volatile Variable Rule）</code>：对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量 的读操作。</li><li><code>线程启动规则（Thread Start Rule）</code>：<code>Thread</code>对象的<code>start()</code>方法先行发生于此线程的每一个动作。</li><li><code>线程终止规则（Thread Termination Rule）</code>：线程中的所有操作都先行发生于对此线程的终止检测，可以通过<code>Thread::join()</code>方法是否结束、<code>Thread::isAlive()</code>的返回值等手段检测线程是否已经终止执行。</li><li><code>线程中断规则（Thread Interruption Rule）</code>：对线程<code>interrupt()</code>方法的调用先行发生于<u>被中断线程的代码检测到中断事件</u>的发生，可以通过<code>Thread::interrupted()</code>方法检测到是否有中断发生。</li><li><code>对象终结规则（Finalizer Rule）</code>：一个对象的初始化完成（构造函数执行结束）先行发生于它的<code>finalize()</code>方法的开始。</li><li><code>传递性（Transitivity）</code>：如果<code>操作A</code>先行发生于<code>操作B</code>，<code>操作B</code>先行发生于<code>操作C</code>，那就可以得出<u><code>操作A</code>先行发生于<code>操作C</code></u>的结论。</li></ul><p><code>时间先后顺序</code>与<code>先行发生原则</code>之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须<u><strong>以先行发生原则为准</strong></u>。</p><h3 id="java与线程">3. Java与线程</h3><p>线程是比进程<strong>更轻量级</strong>的<u>调度执行单位</u>，线程可以把一个进程的<code>资源分配</code>和<code>执行调度</code>分开，各个线程既可以<strong>共享进程资源</strong>（内存地址、文件I/O等），又可以<strong>独立调度</strong>。目前线程是Java里面进行处理器资源调度的<strong>最基本单位</strong>。</p><h4 id="线程的实现">3.1 线程的实现</h4><p>实现线程主要有三种方式：使用<code>内核线程实现（1：1实现）</code>，使用<code>用户线程实现（1：N实现）</code>，使用用户线程加轻量级进程<code>混合实现（N：M实现）</code>。</p><h5 id="内核线程实现">3.1.1 内核线程实现</h5><p><code>内核线程（Kernel-Level Thread，KLT）</code>就是<strong><u>直接由操作系统<code>内核（Kernel）</code>支持的线程</u></strong>。</p><blockquote><p>这种线程由内核来完成<code>线程切换</code>，内核通过操纵<code>调度器（Scheduler）</code>对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为<code>多线程内核（Multi-Threads Kernel）</code>。</p></blockquote><p>程序一般<strong>不会直接使用内核线程</strong>，而是使用内核线程的一种高级接口——<code>轻量级进程（Light Weight Process，LWP）</code>，由于每个轻量级进程都由一个内核线程支持，因此<strong>只有先支持内核线程，才能有轻量级进程</strong>。这种轻量级进程与内核线程之间<code>1：1</code>的关系称为一对一的线程模型。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/KernelLevelThread.PNG" alt="内核线程实现" /><figcaption aria-hidden="true">内核线程实现</figcaption></figure><ul><li>优点：每个轻量级进程都成为一个<code>独立的调度单元</code>，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作。</li><li>局限性：<ul><li>由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的<strong>代价相对较高</strong>，需要在<code>用户态（User Mode）</code>和<code>内核态（Kernel Mode）</code>中来回切换。</li><li>每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要<strong>消耗一定的内核资源</strong>，因此一个系统支持轻量级进程的<strong>数量是有限</strong>的。</li></ul></li></ul><h5 id="用户线程实现">3.1.2 用户线程实现</h5><p><strong>广义上</strong>，一个线程只要不是内核线程，都可以认为是<code>用户线程（User Thread，UT）</code>的一种。</p><p><strong>狭义上</strong>，用户线程指的是<strong>完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的</strong>。</p><blockquote><p>用户线程的建立、同步、销毁和调度完全在<code>用户态</code>中完成，<strong><u>不需要内核的帮助</u></strong>。</p></blockquote><p>这种进程与用户线程之间<code>1：N</code>的关系称为一对多的线程模型。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/UserThread.PNG" alt="用户线程实现" /><figcaption aria-hidden="true">用户线程实现</figcaption></figure><ul><li>用优势在于不需要系统内核支援，如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量。</li><li>劣势也在于没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理。使用用户线程实现的程序通常都比较复杂，除了有明确的需求外，一般的应用程序都不倾向使用用户线程。但近年来许多以高并发为卖点的编程语言普遍支持了用户线程，譬如<code>Golang</code>、<code>Erlang</code>等。</li></ul><h5 id="混合实现">3.1.3 混合实现</h5><p>线程除了<code>依赖内核线程实现</code>和<code>完全由用户程序自己实现</code>之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为<code>N：M</code>实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/HybridThread.PNG" alt="混合实现" /><figcaption aria-hidden="true">混合实现</figcaption></figure><ul><li><strong><code>用户线程</code></strong><u>完全建立在用户空间中</u>，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。</li><li><strong><code>轻量级进程</code></strong>则作为<strong><code>用户线程</code></strong>和<strong><code>内核线程</code></strong>之间的桥梁， 这样可以<u>使用内核提供的线程调度功能及处理器映射</u>，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。</li></ul><h4 id="java线程调度">3.2 Java线程调度</h4><p>线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种：</p><ul><li><code>协同式（Cooperative Threads-Scheduling）线程调度</code>，线程的执行时间<u>由线程本身来控制</u>，线程把自己的工作执行完之后主动通知系统切换到另外一个线程上去。<ul><li>好处是实现简单，切换操作对线程自己是可知的，一般没有<code>线程同步</code>的问题。</li><li>坏处是<u><strong>线程执行时间不可控制</strong></u>，甚至如果线程一直不告知系统进行线程切换，那么程序就会一直阻塞。</li></ul></li><li><code>抢占式（Preemptive Threads-Scheduling）线程调度</code>，每个线程将<u>由系统来分配执行时间</u>，线程的切换不由线程本身来决定。<ul><li>好处是线程的<strong>执行时间是系统可控的</strong>，不会有一个线程导致整个进程甚至整个系统阻塞的问题。</li></ul></li></ul><p>Java使用的线程调度方式就是抢占式调度。虽然Java线程调度是系统自动完成的，但可以设置<code>线程优先级</code>给操作系统提供调度建议。Java设置了<code>10</code>个级别的线程优先级（<code>Thread.MIN_PRIORITY</code>至<code>Thread.MAX_PRIORITY</code>）。在两个线程同时处于<code>Ready</code>状态时，<strong>优先级越高的线程越容易被系统选择执行</strong>。</p><p><code>Windows</code>中就只有<code>七</code>种优先级，比Java线程优先级少，所以会出现几个线程优先级对应到同一个操作系统优先级的情况。</p><blockquote><p><code>Windows</code>平台的虚拟机中使用了除<code>THREAD_PRIORITY_IDLE</code>之外的其余<code>6</code>种线程优先级，因此在<code>Windows</code>下设置线程优先级为<code>1</code>和<code>2</code>、<code>3</code> 和<code>4</code>、<code>6</code>和<code>7</code>、<code>8</code>和<code>9</code>的效果是<strong>完全相同</strong>的。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/THREAD_PRIORITY.PNG" alt="Java线程优先级与Windows线程优先级之间的对应关系" /><figcaption aria-hidden="true">Java线程优先级与Windows线程优先级之间的对应关系</figcaption></figure><p>线程优先级并不是一项稳定的调节手段，优先级可能会被系统自行改变，所以不能在程序中通过优先级来完全准确判断一组状态都为<code>Ready</code>的线程将会先执行哪一个。</p><h4 id="状态转换">3.3 状态转换</h4><p>Java定义了<code>6</code>种线程状态，任意一个时间点中，一个线程<strong>只能有且只有其中的一种状态</strong>，可以通过特定的方法在不同状态之间转换：</p><ul><li><code>新建（New）</code>：创建后尚未启动的线程处于这种状态。</li><li><code>运行（Runnable）</code>：包括操作系统线程状态中的<code>Running</code>和<code>Ready</code>，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。</li><li><code>无限期等待（Waiting）</code>：处于这种状态的线程不会被分配处理器执行时间，它们要等待<strong>被其他线程显式唤醒</strong>。以下方法会让线程陷入无限期的等待状态：<ul><li>没有设置<code>Timeout</code>参数的<code>Object::wait()</code>方法；</li><li>没有设置<code>Timeout</code>参数的<code>Thread::join()</code>方法；</li><li><code>LockSupport::park()</code>方法。</li></ul></li><li><code>限期等待（Timed Waiting）</code>：处于这种状态的线程也不会被分配处理器执行时间，不过<strong>无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒</strong>。以下方法会让线程进入限期等待状态：<ul><li><code>Thread::sleep()</code>方法；</li><li>设置了<code>Timeout</code>参数的<code>Object::wait()</code>方法；</li><li>设置了<code>Timeout</code>参数的<code>Thread::join()</code>方法；</li><li><code>LockSupport::parkNanos()</code>方法；</li><li><code>LockSupport::parkUntil()</code>方法。</li></ul></li><li><code>阻塞（Blocked）</code>：线程被阻塞，<code>“阻塞状态”</code>与<code>“等待状态”</code>的区别是：<ul><li><code>“阻塞状态”</code>在等待着获取到一个<code>排它锁</code>，这个事件将在另外一个线程放弃这个锁的时候发生；</li><li><code>“等待状态”</code>则是在等待一段时间，或者唤醒动作的发生。</li><li>在程序等待进入同步区域的时候，线程将进入这种状态。</li></ul></li><li><code>结束（Terminated）</code>：已终止线程的线程状态，线程已经结束执行</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ThreadState.PNG" alt="线程状态转换关系" /><figcaption aria-hidden="true">线程状态转换关系</figcaption></figure><h3 id="java与协程">4. Java与协程</h3><h4 id="内核线程的局限">4.1 内核线程的局限</h4><ul><li><code>1：1</code>的内核线程模型是如今Java虚拟机线程实现的<strong>主流选择</strong>，但是天然的缺陷是<strong>切换、调度成本高昂</strong>，系统能<strong>容纳的线程数量也很有限</strong>。现在在每个请求本身的执行时间变得很短、数量变得很多的前提下， 用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费。</li><li>传统的<code>Java Web</code>服务器的线程池的容量通常在几十个到两百之间，当以百万计的请求往线程池里面灌时，系统即使能处理得过来，但其中的切换损耗也是相当可观的。</li></ul><h4 id="协程的复苏">4.2 协程的复苏</h4><p>内核线程的调度成本主要来自于<strong>用户态与核心态之间的状态转换</strong>，而这两种状态转换的开销主要来自于<strong><code>响应中断</code>、<code>保护</code>和<code>恢复执行现场</code></strong>的成本。</p><blockquote><p>线程A -&gt; 系统中断 -&gt; 线程B</p></blockquote><p>当中断发生，从<code>线程A</code>切换到<code>线程B</code>去执行之前，操作系统首先要把<code>线程A</code>的上下文数据妥善保管好，然后把寄存器、内存分页等恢复到<code>线程B</code>挂起时候的状态，这样<code>线程B</code>被重新激活后才能仿佛从来没有被挂起过。这种<code>保护和恢复现场</code>的工 作，免不了涉及一系列数据在各种寄存器、缓存中的来回拷贝，当然不可能是一种轻量级的操作。</p><p>最初多数的用户线程是被设计成<code>协同式调度 （Cooperative Scheduling）</code>的，它也被叫做<code>“协程”（Coroutine）</code>。又由于这时候的协程会<u>完整地做调用栈的保护、恢复工作</u>，所以也被称为<code>“有栈协程”（Stackfull Coroutine）</code>。后来又出现比<code>有栈协程</code>恢复调用栈要轻量得多<code>“无栈协程”（Stackless Coroutine）</code>。</p><blockquote><p>一个协程的栈通常在<code>几百个字节</code>到<code>几KB</code>之间，所以Java虚拟机里线程池容量达到两百就已经不算小了，而很多支持协程的应用中，同时并存的协程数量可<code>以十万</code>计。</p></blockquote><h4 id="纤程fiber">4.3 纤程（Fiber）</h4><p>对于有栈协程，有一种特例实现名为<code>纤程（Fiber）</code>。在新并发模型下，一段使用纤程并发的代码会被分为两部分：</p><ul><li><code>执行过程（Continuation）</code>，主要用于维护执行现场，保护、恢复上下文状态；</li><li><code>调度器（Scheduler）</code>，负责编排所有要执行的代码的顺序。</li></ul><p>将调度程序与执行过程分离的好处是，用户可以选择自行控制其中的一个或者多个，而且Java中现有的调度器也可以被直接重用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;并发处理是人类压榨计算机运算能力的最有力武器。
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--11 后端编译与优化</title>
    <link href="https://wuyunjie.top/2021/06/03/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_11_Back-end_compilation_and_optimization.html"/>
    <id>https://wuyunjie.top/2021/06/03/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_11_Back-end_compilation_and_optimization.html</id>
    <published>2021-06-03T14:31:10.000Z</published>
    <updated>2021-06-03T14:31:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>后端编译器的编译速度及编译结果质量高低，是衡量Java虚拟机性能最重要的一个指标。 <a id="more"></a></p></blockquote><p>如果把字节码看作是程序语言的一种<code>中间表示形式（Intermediate Representation，IR）</code>， 那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的<code>后端</code>。</p><h3 id="即时编译器">1. 即时编译器</h3><p>目前主流的两款商用Java虚拟机（<code>HotSpot</code>、<code>OpenJ9</code>）里，Java程序最初都是通过<code>解释器（Interpreter）</code>进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为<code>“热点代码”（Hot Spot Code）</code>，为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为<strong><code>即时编译器</code></strong>。</p><h4 id="解释器与编译器">1.1 解释器与编译器</h4><p>目前主流的商用Java虚拟机都采用<strong><u>解释器与编译器并存</u></strong>的运行架构，解释器与编译器两者各有优势：</p><ul><li>当程序需要<strong>迅速启动和执行</strong>的时候，解释器可以首先发挥作用，<u>省去编译的时间，立即运行</u>。</li><li>当程序启动后，随着时间的推移，编译器逐渐发挥作用，<u>把越来越多的代码编译成本地代码</u>，这样可以<strong>减少解释器的中间损耗，获得更高的执行效率</strong>。</li><li>当程序运行环境中<strong>内存资源限制较大</strong>，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。</li><li>解释器还可以作为编译器激进优化时后备的<code>“逃生门”</code>，让编译器根据概率选择一些不能保证所有情况都正确，但<u>大多数时候都能提升运行速度的优化手段</u>，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现<code>“罕见陷阱”（Uncommon Trap）</code>时可以通过<code>逆优化（Deoptimization）</code>退回到解释状态继续执行。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/InteractionBetweenInterpreterAndCompiler.PNG" alt="解释器与编译器的交互" /><figcaption aria-hidden="true">解释器与编译器的交互</figcaption></figure><p><code>HotSpot</code>虚拟机中内置了两个（或三个）<code>即时编译器</code>：</p><ul><li>其中两个编译器存在已久，分别被称为<code>“客户端编译器”（Client Compiler）</code>和<code>“服务端编译器”（Server Compiler）</code>，或者简称为<code>C1编译器</code>和<code>C2编译器</code>（部分资料和JDK源码中<code>C2</code>也叫<code>Opto</code>编译器）</li><li>第三个是在<code>JDK 10</code>时才出现的、长期目标是代替<code>C2</code>的<code>Graal</code>编译器。目前还处于实验状态。</li></ul><p><code>分层编译（Tiered Compilation）</code>的工作模式出现以前，<code>HotSpot</code>虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作。</p><ul><li>解释器与编译器搭配使用的方式在虚拟机中被称为<code>“混合模式”（Mixed Mode）</code></li><li>用户可以使用参数<code>“-Xint”</code>强制虚拟机运行于<code>“解释模式”（Interpreted Mode）</code>，这时候编译器<strong>完全不介入</strong>工作，全部代码都使用解释方式执行。</li><li>也可以使用参数<code>“-Xcomp”</code>强制虚拟机运行于<code>“编译模式”（Compiled Mode）</code>，这时候将<strong>优先</strong>采用编译方式执行程序，但是<u>解释器仍然要在编译无法进行的情况下介入执行过程</u>。</li></ul><p>为了在<u>程序启动响应速度与运行效率</u>之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了<code>分层编译</code>的功能，分层编译根据编译器<u><strong>编译、优化的规模与耗时</strong></u>，划分出不同的编译层次：</p><ul><li>第0层。程序<strong>纯解释执行</strong>，并且解释器不开启<code>性能监控功能（Profiling）</code>。</li><li>第1层。使用<code>客户端编译器</code>将字节码编译为本地代码来运行，进行简单可靠的<u>稳定优化</u>，<u>不开启</u>性能监控功能。</li><li>第2层。使用<code>客户端编译器</code>执行，仅开启<u>方法及回边次数统计</u>等<strong>有限</strong>的性能监控功能。</li><li>第3层。使用<code>客户端编译器</code>执行，开启<strong>全部</strong>性能监控，还会收集如<u>分支跳转、虚方法调用版本</u>等全部的统计信息。</li><li>第4层。使用<code>服务端编译器</code>将字节码编译为本地代码，服务端编译器会启用更多<u>编译耗时更长的优化</u>，还会根据性能监控信息进行一些不可靠的<u>激进优化</u>。</li></ul><p>实施分层编译后，解释器、客户端编译器和服务端编译器就会<strong>同时工作</strong>，热点代码都可能会被多次编译：</p><ul><li>用客户端编译器获取更高的编译速度</li><li>用服务端编译器来获取更好的编译质量</li><li>在解释执行的时候也无须额外承担收集性能监控信息的任务</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/TieredCompilation.PNG" alt="分层编译的交互关系" /><figcaption aria-hidden="true">分层编译的交互关系</figcaption></figure><h4 id="编译对象与触发条件">1.2 编译对象与触发条件</h4><h5 id="热点代码">1.2.1 热点代码</h5><p>在运行过程中会被即时编译器编译的目标是<code>“热点代码”</code>，这里所指的热点代码主要有两类：</p><ul><li>被多次调用的<strong>方法</strong>。</li><li>被多次执行的<strong>循环体</strong>。</li></ul><p>对于这两种情况，编译的目标对象都是<strong><u>整个方法体</u></strong>，而不会是单独的循环体。由循环体所触发的热点只是方法的一部分，但编译器依然必须以整个方法作为编译对象，只是执行入口会稍有不同，编译时会传入执行入口点<code>字节码序号（Byte Code Index，BCI）</code>。</p><blockquote><p><code>“栈上替换”（On Stack Replacement，OSR）</code>，即方法的栈帧还在栈上，方法就被替换了。</p></blockquote><h5 id="热点探测判定方式">1.2.2 热点探测判定方式</h5><p>要知道某段代码是不是<code>热点代码</code>，是不是需要触发<code>即时编译</code>，这个行为称为<code>“热点探测”（Hot Spot Code Detection）</code>，目前主流的热点探测判定方式有两种：</p><ul><li><code>基于采样的热点探测（Sample Based Hot Spot Code Detection）</code>。采用这种方法的虚拟机会<u>周期性地检查各个线程的<strong>调用栈顶</strong>，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是<code>“热点方法”</code></u>。<ul><li><strong>好处</strong>是实现简单高效，可以很容易地获取方法调用关系（将调用堆栈展开即可）</li><li><strong>缺点</strong>是很难精确地确认一个方法的热度，容易因为<strong>受到线程阻塞或别的外界因素的影响而扰乱热点探测</strong>。</li></ul></li><li><code>基于计数器的热点探测（Counter Based Hot Spot Code Detection）</code>。采用这种方法的虚拟机会<u>为每个方法（甚至是代码块）建立<strong>计数器</strong>，统计方法的执行次数，如果执行次数超过一定的<code>阈值</code>就认为它是<code>“热点方法”</code>。</u><ul><li><strong>缺点</strong>是需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。</li><li><strong>优点</strong>是统计结果相对来说更加精确严谨。</li></ul></li></ul><h5 id="基于计数器的热点探测">1.2.3 基于计数器的热点探测</h5><p><code>HotSpot虚拟机</code>中使用的是基于计数器的热点探测，<code>HotSpot</code>为每个方法准备了两类计数器：</p><ul><li><p><code>方法调用计数器（Invocation Counter）</code>。这个计数器就是<u>用于统计方法被调用的次数</u>。</p><ul><li><p>它的<code>默认阈值</code>在<strong>客户端模式</strong>下是<code>1500</code>次，在<strong>服务端模式</strong>下是<code>10000</code>次，这个阈值可以通过虚拟机参数<code>-XX：CompileThreshold</code>来人为设定。</p></li><li><p>当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的版本</p><ul><li>如果存在，则优先使用编译后的本地代码来执行。</li><li>如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后判断<u><strong>方法调用计数器与回边计数器值之和</strong></u>是否超过方法调用计数器的阈值。</li><li>一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。当编译工作完成后，这个方法的调用入口地址就会被系统自动改写成新值</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/InvocationCounter.PNG" alt="方法调用计数器触发即时编译" /><figcaption aria-hidden="true">方法调用计数器触发即时编译</figcaption></figure></li><li><p>方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<u>一段时间之内方法被调用的次数</u>。</p><ul><li>超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为<code>方法调用计数器热度的衰减（Counter Decay）</code>，而这段时间就称为此方法统计的<code>半衰周期（Counter Half Life Time）</code>。</li><li>热度衰减的动作是<u>在虚拟机进行垃圾收集时顺便进行的</u>。</li></ul></li></ul></li><li><p><code>回边计数器（Back Edge Counter）</code>，<code>“回边”</code>的意思就是指在循环边界往回跳转。这个计数器就是用于<u>统计一个方法中循环体代码执行的次数</u>。</p><ul><li><p>在字节码中遇到控制流向后跳转的指令就称为<code>“回边（Back Edge）</code>”，建立回边计数器统计的目的是为了<u>触发栈上的替换编译</u>。</p></li><li><p>当前的<code>HotSpot</code>虚拟机必须设置参数<code>-XX:OnStackReplacePercentage</code>来<strong>间接调整</strong>回边计数器的阈值，其计算公式有如下两种：</p><ul><li>虚拟机运行在<strong>客户端模式</strong>下，回边计数器阈值计算公式为： <span class="math display">\[\frac{方法调用计数器阈值 \times OSR比率}{100}\]</span></li></ul><p><code>OSR比率（-XX：OnStackReplacePercentage）</code>默认值为<code>933</code></p><ul><li>虚拟机运行在<strong>服务端模式</strong>下，回边计数器阈值的计算公式为：</li></ul><p><span class="math display">\[\frac{方法调用计数器阈值 \times (OSR比率-解释器监控比率)}{100}\]</span></p><p>其中<code>-XX：OnStackReplacePercentage</code>默认值为<code>140</code>，<code>- XX：InterpreterProfilePercentage</code>默认值为<code>33</code>。</p></li><li><p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本</p><ul><li>如果有，将会优先执行已编译的代码</li><li>否则就把回边计数器的值加一，然后判断<u><strong>方法调用计数器与回边计数器值之和</strong></u>是否超过回边计数器的阈值。</li><li>若超过阈值，将会提交一个<strong>栈上替换</strong>编译请求， 并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/BackEdgeCounter.PNG" alt="回边计数器触发即时编译" /><figcaption aria-hidden="true">回边计数器触发即时编译</figcaption></figure></li><li><p>回边计数器<u>没有计数热度衰减的过程</u>，因此这个计数器统计的就是该方法循环执行的<code>绝对次数</code>。</p></li></ul></li></ul><h4 id="编译过程">1.3 编译过程</h4><p>虚拟机在编译器还未完成编译之前将按照解释方式继续执行代码，而编译动作则在<strong>后台的编译线程</strong>中进行。</p><h5 id="客户端编译器">1.3.1 客户端编译器</h5><p>对于<strong>客户端编译器</strong>来说，主要的关注点在于<u>局部性的优化</u>，而放弃了许多耗时较长的全局优化手段：</p><ul><li>第一个阶段，一个<code>平台独立的前端</code>将字节码构造成一种<code>高级中间代码表示（High-Level Intermediate Representation，HIR</code>），即<u><strong>与目标机器指令集无关</strong></u>的中间表示。<ul><li><code>HIR</code>使用<code>静态单分配（Static Single Assignment，SSA）</code>的形式来代表代码值。</li><li>在字节码被构造成<code>HIR</code>之前，编译器已经会在字节码上完成一部分基础优化，如<u>方法内联</u>、<u>常量传播</u>等优。</li></ul></li><li>第二个阶段，一个<code>平台相关的后端</code>从<code>HIR</code>中产生<code>低级中间代码表示（Low-Level Intermediate Representation，LIR</code>，即<u><strong>与目标机器指令集相关</strong></u>的中间表示。<ul><li>而在此之前会在<code>HIR</code>上完成一些优化，如<u>空值检查消除</u>、<u>范围检查消除</u>等。</li></ul></li><li>最后的阶段，在<code>平台相关的后端</code>使用<code>线性扫描算法（Linear Scan Register Allocation）</code>在<code>LIR</code>上分配寄存器，并在<code>LIR</code>上做<code>窥孔（Peephole）</code>优化，然后产生机器代码。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ClientCompiler.PNG" alt="Client Compiler架构" /><figcaption aria-hidden="true">Client Compiler架构</figcaption></figure><h5 id="服务端编译器">1.3.2 服务端编译器</h5><p>服务端编译器是一个能容忍很高优化复杂度的高级编译器，会执行大部分经典的优化动作，如：</p><ul><li>无用代码消除（Dead Code Elimination）</li><li>循环展开（Loop Unrolling）</li><li>循环表达式外提（Loop Expression Hoisting）</li><li>消除公共子表达式（Common Subexpression Elimination）</li><li>常量传播（Constant Propagation）</li><li>基本块重排序（Basic Block Reordering）</li><li>等</li></ul><p>还会实施一些<strong>与Java语言特性密切相关的优化技术</strong>，如：</p><ul><li>范围检查消除（Range Check Elimination）</li><li>空值检查消除（Null Check Elimination）</li><li>等</li></ul><p>还可能根据解释器或客户端编译器提供的性能监控信息，进行一些<strong>不稳定的预测性激进优化</strong>，如：</p><ul><li>守护内联（Guarded Inlining）</li><li>分支频率预测 （Branch Frequency Prediction）</li><li>等</li></ul><p>服务端编译采用的<strong>寄存器分配器</strong>是一个<code>全局图着色分配器</code>，它可以充分利用某些处理器架构（如<code>RISC</code>）上的大寄存器集合。</p><h4 id="实战查看及分析即时编译结果">1.4 实战：查看及分析即时编译结果</h4><p>从外部观察Java虚拟机的即时编译行为。</p><ul><li>可以使用参数<code>-XX:+PrintCompilation</code>要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来。如下图所示（其中带有<code>“%”</code>的输出说明是由回边计数器触发的栈上替换编译）</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testJIT1.PNG" alt="被即时编译的代码(部分)" /><figcaption aria-hidden="true">被即时编译的代码(部分)</figcaption></figure><ul><li><p>加上参数<code>-XX:+PrintInlining</code>要求虚拟机输出方法内联信息</p></li><li><p>可以使用<code>-XX:+PrintAssembly</code>参数要求虚拟机打印编译方法的汇编代码。如果没有<code>HSDIS</code>插件支持，也可以使用<code>-XX：+PrintOptoAssembly</code>（用于服务端模式的虚拟机） 或<code>-XX：+PrintLIR</code>（用于客户端模式的虚拟机）来输出比较接近最终结果的中间代码表示</p></li><li><p>可以使用参数<code>-XX：+PrintCFGToFile</code>（用于客户端编译器）或<code>-XX：PrintIdealGraphFile</code>（用于服务端编译器）要求Java虚拟机将编译过程中各个阶段的数据输出到文件中。可以使用<code>Java HotSpot Client Compiler Visualizer</code>（用于分析客户端编译器）或<code>Ideal Graph Visualizer</code>（用于分析服务端编译器）打开这些数据文件进行分析。</p></li></ul><h3 id="提前编译器">2. 提前编译器</h3><h4 id="提前编译的优劣得失">2.1 提前编译的优劣得失</h4><p><code>提前编译</code>的研究有着两条明显的分支：</p><ul><li>一条分支是做与传统<code>C、C++</code>编译器类似的，<u>在程序运行之前把程序代码编译成机器码的静态翻译</u>工作。<ul><li>这是传统的提前编译应用形式，在Java中存在的价值是为了解决<u><strong>即时编译要占用程序运行时间和运算资源</strong></u>。</li></ul></li><li>另一条分支是<u>把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码时直接把它加载进来使用</u>。<ul><li>这种提前编译被称为<code>动态提前编译（Dynamic AOT）</code>或者<code>即时编译缓存（JIT Caching）</code>。</li><li>本质是给即时编译器做<strong>缓存加速</strong>，去改善Java程序的启动时间，以及需要一段时间预热后才能到达最高性能的问题。</li></ul></li></ul><p>即时编译器相对于提前编译器的天然优势：</p><ul><li><code>性能分析制导优化（Profile-Guided Optimization，PGO）</code>。</li><li><code>激进预测性优化（Aggressive Speculative Optimization）</code>，这也已经成为很多即时编译优化措施的基础。</li><li><code>链接时优化（Link-Time Optimization，LTO）</code>，Java语言天生就是动态链接的，一个个Class文件在运行期被加载到虚拟机内存当中，然后在即时编译器里产生优化后的本地代码。</li></ul><h4 id="实战jaotc的提前编译">2.2 实战：<code>Jaotc</code>的提前编译</h4><p><code>JDK 9</code>引入了用于支持对Class文件和模块进行提前编译的工具<code>Jaotc</code>，以减少程序的启动时间和到达全速性能的预热时间，但这项功能必须针对特定物理机器和目标虚拟机的运行参数来使用。</p><p><code>Jaotc</code>做的提前编译属于<code>“第二条分支”</code>，即做即时编译的缓存；而<code>Substrate VM</code>则是选择的<code>“第一条分支”</code>，做的是传统的静态提前编译。</p><h3 id="编译器优化技术">3. 编译器优化技术</h3><p>编译器的目标虽然是做由程序代码翻译为本地机器码的工作，但<strong>输出代码优化质量的高低</strong>才是决定编译器优秀与否的关键。</p><h4 id="优化技术概览">3.1 优化技术概览</h4><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/PerformanceTacticIndex1.PNG" alt="即时编译器优化技术一览" /><figcaption aria-hidden="true">即时编译器优化技术一览</figcaption></figure><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/PerformanceTacticIndex2.PNG" alt="即时编译器优化技术一览（续）" /><figcaption aria-hidden="true">即时编译器优化技术一览（续）</figcaption></figure><p>即时编译器对这些代码优化变换是建立在<strong>代码的中间表示或者是机器码</strong>之上的，而不是直接在Java源码上去做的。使用Java语言的语法来表示优化技术所发挥的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优化前的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">y = b.get();</span><br><span class="line"><span class="comment">// ...do stuff...</span></span><br><span class="line">z = b.get();</span><br><span class="line">sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个要进行的优化是<code>方法内联</code>，它的主要目的有两个：</p><ul><li>一是去除方法调用的成本（如查找方法版本、建立栈帧等）；</li><li>二是为其他优化建立良好的基础。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内联后的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    z = b.value;</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步进行<code>冗余访问消除（Redundant Loads Elimination）</code>，也可以把这项优化看作一种<code>公共子表达式消除（Common Subexpression Elimination）</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冗余访问消除的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    z = y;</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步进行<code>复写传播（Copy Propagation）</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复写传播的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    y = y;</span><br><span class="line">    sum = y + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步进行<code>无用代码消除（Dead Code Elimination）</code>，无用代码可能是<u>永远不会被执行的代码</u>，也可能是<u>完全没有意义的代码</u>，因此它又被称为<code>“Dead Code”</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行无用代码消除的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    sum = y + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四种具有代表性的优化技术：</p><ul><li>最重要的优化技术之一：方法内联。</li><li>最前沿的优化技术之一：逃逸分析。</li><li>语言无关的经典优化技术之一：公共子表达式消除。</li><li>语言相关的经典优化技术之一：数组边界检查消除。</li></ul><h4 id="方法内联">3.2 方法内联</h4><p>内联被业内戏称为<code>优化之母</code>，因为除了消除方法调用的成本之外，它更重要的意义是<u><strong>为其他优化手段建立良好的基础</strong></u>。</p><blockquote><p>方法内联的优化行为可以理解为<u><strong>把目标方法的代码原封不动地“复制”到发起调用的方法之中，避免发生真实的方法调用</strong></u>。但Java的虚方法调用都必须在运行时进行方法接收者的多态选择，它们都有可能存在多于一个版本的方法接收者，编译器静态地去做内联的时候很难确定应该使用哪个方法版本。</p></blockquote><p>为了解决虚方法的内联问题，Java虚拟机引入了<code>类型继承关系分析（Class Hierarchy Analysis，CHA）</code>技术。</p><blockquote><p>是<code>整个应用程序范围内</code>的类型分析技术，用于确定在目前已加载的类中，<u>某个接口是否有多于一种的实现</u>、<u>某个类是否存在子类</u>、<u>某个子类是否覆盖了父类的某个虚方法</u>等信息。</p></blockquote><ul><li>如果是非虚方法，直接进行内联；</li><li>如果是虚方法，则会向<code>CHA</code>查询此方法在当前程序状态下是否真的有多个目标版本可供选择<ul><li>如果查询到只有一个版本，那就可以假设<em>“应用程序的全貌就是现在运行的这个样子”</em>来进行内联，这种内联被称为<code>守护内联（Guarded Inlining）</code>。由于Java程序是动态连接的，可能会加载到新类型从而改变<code>CHA</code>结论，因此这种内联属于<code>激进预测性优化</code>，必须预留<code>“逃生门”</code>，即当假设条件不成立时的<code>“退路”（Slow Path）</code>。<ul><li>若在程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。</li><li>若加载了导致继承关系发生变化的新类，那么必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。</li></ul></li><li>如果向<code>CHA</code>查询出来的结果是该方法有多个版本的目标方法可供选择，即时编译器还将使用<code>内联缓存（Inline Cache）</code>的方式来缩减方法调用的开销。<code>内联缓存</code>是一个建立在<u><strong>目标方法正常入口之前</strong></u>的缓存，工作原理大致为：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。<ul><li>如果以后进来的每次调用的方法接收者版本都是一样的，那么这时它就是一种<code>单态内联缓存（Monomorphic Inline Cache）</code>。通过该缓存来调用，比用不内联的非虚方法调用，仅多了一次类型判断的开销。</li><li>如果出现方法接收者不一致，说明程序用到了方法的多态特性，这时候会退化成<code>超多态内联缓存（Megamorphic Inline Cache）</code>，其开销相当于真正查找虚方法表来进行方法分派。</li></ul></li></ul></li></ul><h4 id="逃逸分析">3.3 逃逸分析</h4><p><code>逃逸分析（Escape Analysis）</code>与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。</p><blockquote><p>基本原理是：分析对象<code>动态作用域</code>，当一个对象在方法里面被定义后：</p><ul><li>可能被<strong>外部方法</strong>所引用，例如作为调用参数传递到其他方法中，这种称为<code>方法逃逸</code>；</li><li>可能被<strong>外部线程</strong>访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为<code>线程逃逸</code>；</li><li>从不逃逸、方法逃逸到线程逃逸，称为对象<strong>由低到高</strong>的不同<code>逃逸程度</code>。</li></ul></blockquote><p>根据<code>逃逸程度</code>可以为这个对象实例采取不同程度的优化：</p><ul><li><code>栈上分配（Stack Allocations）</code>：如果确定一个对象<strong>不会逃逸出线程</strong>之外，可以让这个对象<u>在栈上分配内存</u>，对象所占用的内存空间就可以随栈帧出栈而自动销毁，垃圾收集子系统的压力将会下降很多。<u>栈上分配可以支持方法逃逸，但不能支持线程逃逸</u>。</li><li><code>标量替换（Scalar Replacement）</code>：Java虚拟机中的原始数据类型都不能再进一步分解分解成更小的数据来表示，这些数据可以被称为<code>标量</code>。如果一个数据可以继续分解，那它就被称为<code>聚合量（Aggregate）</code>。<ul><li><u>把一个Java对象拆散，根据程序访问的情况，<strong>将其用到的成员变量恢复为原始类型来访问</strong></u>，这个过程就称为<code>标量替换</code>。</li><li>假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。对象拆分后可以让对象的成员变量在栈上 分配和读写，标量替换可以视作<code>栈上分配的一种特例</code>，实现更简单。</li><li><u><strong>它不允许对象逃逸出方法范围内</strong></u>。</li></ul></li><li><code>同步消除（Synchronization Elimination）</code>：如果逃逸分析能够确定一个变量<strong>不会逃逸出线程</strong>，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，<u>对这个变量实施的同步措施也就可以安全地消除掉</u>。</li></ul><p>逃逸分析的<u>计算成本非常高</u>，甚至不能保证逃逸分析带来的性能收益会高于它的消耗，但它是即时编译器优化技术的一个重要前进方向。</p><h4 id="公共子表达式消除">3.4 公共子表达式消除</h4><p>公共子表达式消除是：如果一个表达式<code>E</code>之前已经被计算过了，并且从先前的计算到现在<code>E</code>中所有变量的值都没有发生变化，那么<code>E</code>的这次出现就称为<code>公共子表达式</code>。对于这种表达式，只需要直接用前面计算过的表达式结果代替<code>E</code>。</p><ul><li>如果这种优化仅限于<strong>程序基本块</strong>内，便可称为<code>局部公共子表达式消除（Local Common Subexpression Elimination）</code>；</li><li>如果这种优化的范围涵盖了<strong>多个基本块</strong>，那就称为<code>全局公共子表达式消除（Global Common Subexpression Elimination）</code>。</li></ul><h4 id="数组边界检查消除">3.5 数组边界检查消除</h4><p><code>数组边界检查消除（Array Bounds Checking Elimination）</code>是语言相关的。Java语言是一门<code>动态安全</code>的语言，访问数组元素<code>foo[i]</code>时系统将会自动进行<u>上下界的范围检查</u>，即i必须满足<code>“i&gt;=0&amp;&amp;i&lt;foo.length”</code>的访问条件，所以每次数组元素的读写都带有一次隐含的条件判定操作。</p><ul><li>可以进行<code>数组边界检查优化</code>，尽可能把运行期检查提前到编译期完成。比如通过数据流分析就可以判定循环变量的取值范围是否在上下界区间内，如果在，可以把上下界检查消除掉。</li><li>还可以进行隐式异常处理。需要根据运行期收集到的性能监控信息选择最合适的方案</li></ul><h3 id="实战深入理解graal编译器">4. 实战：深入理解<code>Graal</code>编译器</h3><h4 id="java虚拟机编译器接口">4.1 Java虚拟机编译器接口</h4><p><code>Java虚拟机编译器接口（Java-Level JVM Compiler Interface，JVMCI）</code>使得<code>Graal</code>可以从<code>HotSpot</code>的代码中分离出来。<code>JVMCI</code>主要提供如下三种功能：</p><ul><li>响应<code>HotSpot</code>的编译请求，并将该请求分发给Java实现的即时编译器。</li><li>允许编译器访问<code>HotSpot</code>中<u>与即时编译相关的数据结构</u>，包括类、字段、方法及其性能监控数据等，并提供了一组这些数据结构在Java语言层面的抽象表示。</li><li>提供<code>HotSpot</code>代码缓存（<code>Code Cache</code>）的Java端抽象表示，允许编译器部署编译完成的二进制机器码。</li></ul><p><code>JVMCI</code>编译器接口输入要编译的方法的字节码，即<code>“用一个字节数组表示的代码”</code>。输出与方法对应的二进制机器码，二进制机器码也应该是<code>“用一个字节数组表示的代码”</code>。这样的话，<code>JVMCI</code>接口就应该类似于下面形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JVMCICompiler</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] compileMethod(<span class="keyword">byte</span>[] bytecode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上<code>JVMCI</code>接口只比上面这个稍微复杂一点，其输入除了字节码外，<code>HotSpot</code>还会向编译器提供各种该方法的相关信息，譬如<u>局部变量表中变量槽的个数</u>、<u>操作数栈的最大深度</u>，还有<u>分层编译在底层收集到的统计信息</u>等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JVMCICompiler</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compileMethod</span><span class="params">(CompilationRequest request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompilationRequest</span> </span>&#123;</span><br><span class="line"><span class="function">JavaMethod <span class="title">getMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JavaMethod</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] getCode();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxLocals</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxStackSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ProfilingInfo <span class="title">getProfilingInfo</span><span class="params">()</span></span>;</span><br><span class="line">... <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码中间表示">4.2 代码中间表示</h4><p><code>Graal编译器</code>在采用了与<code>HotSpot</code>服务端编译器一致（略有差异但已经非常接近）的中间表示形式，也即是被称为<code>Sea-of-Nodes</code>的中间表示，或者与其等价的被称为<code>理想图</code>（<code>Ideal Graph</code>，在代码中称为<code>Structured Graph</code>）的<code>程序依赖图（Program Dependence Graph，PDG）</code>形式。</p><blockquote><p>从编译器内部来看理想图上翻译和优化输入代码的整体过程即：<code>字节码→理想图→优化→机器码</code></p></blockquote><p>理想图是一种<code>有向图</code>，用节点来表示<strong>程序中的元素</strong>，譬如变量、操作符、方法、字段等，而用边来表示<strong>数据</strong>或者<strong>控制流</strong>。如表达式：<code>x+y</code>，在理想图中可以表示为<code>x</code>、<code>y</code>两个节点的数据流流入加法操作符。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/IdealGraph1.PNG" alt="构造理想图" /><figcaption aria-hidden="true">构造理想图</figcaption></figure><p>把表达式<code>x+y</code>变为<code>getX()+getY()</code>，理想图除了需要表达数据流向之外，还必须要考虑方法调用的顺序。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/IdealGraph2.PNG" alt="构造理想图" /><figcaption aria-hidden="true">构造理想图</figcaption></figure><blockquote><p>理想图本质上就是这种将<code>数据流图</code>和<code>控制流图</code>以某种方式合并到一起，用一种边来表示数据流向，另一种边来表示控制流向的图形表示。</p></blockquote><h4 id="代码优化与生成">4.3 代码优化与生成</h4><p><code>Graal编译器</code>中创建理想图的方法是<code>createGraph()</code>，<code>createGraph()</code>方法内调用了<code>StructuredGraph::Builder()</code>构造器来创建理想图。</p><h5 id="理想图本身的数据结构">4.3.1 理想图本身的数据结构</h5><p>它是一组<strong>不为空</strong>的节点的集合，它的节点都是用<code>ValueNode</code>的不同类型的<strong>子类节点</strong>来表示的。如加法操作就由<code>AddNode</code>节点来表示，到加法操作是<code>二元算术操作节点（BinaryArithmeticNode&lt;OP&gt;）</code>的一种，而二元算术操作节点又是<code>二元操作符（BinaryNode）</code>的一种。</p><h5 id="从字节码转换到理想图">4.3.2 从字节码转换到理想图</h5><p>该过程被封装在<code>BytecodeParser</code>类中，可以按照字节码解释器的思路去理解该解析器。<code>BytecodeParser::genArithmeticOp()</code>方法如下：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/genArithmeticOp.PNG" alt="genArithmeticOp方法" /><figcaption aria-hidden="true">genArithmeticOp方法</figcaption></figure><p>其中，<code>genIntegerAdd()</code>方法中就只有一行代码，即调用<code>AddNode</code>节点的<code>create()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ValueNode <span class="title">genIntegerAdd</span><span class="params">(ValueNode x, ValueNode y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> AddNode.create(x, y, NodeView.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValueNode <span class="title">create</span><span class="params">(ValueNode x, ValueNode y, NodeView view)</span> </span>&#123;</span><br><span class="line">BinaryOp&lt;Add&gt; op = ArithmeticOpTable.forStamp(x.stamp(view)).getAdd();</span><br><span class="line">Stamp stamp = op.foldStamp(x.stamp(view), y.stamp(view));</span><br><span class="line">ConstantNode tryConstantFold = tryConstantFold(op, x, y, stamp, view);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tryConstantFold != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> tryConstantFold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x.isConstant() &amp;&amp; !y.isConstant()) &#123;</span><br><span class="line"><span class="keyword">return</span> canonical(<span class="keyword">null</span>, op, y, x, view);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> canonical(<span class="keyword">null</span>, op, x, y, view);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个理想图的节点都有两个共同的主要操作：</p><ul><li><strong>规范化</strong>（<code>Canonicalisation</code>），即代码优化。在理想图的基础上优化代码所要采取的措施，实现在<code>canonical()</code>方法中。</li><li><strong>生成机器码</strong>（<code>Generation</code>），即代码翻译。实现在<code>generate()</code>方法中。<code>Graal</code>并不是直接由理想图转换到机器码，而是会先生成<code>低级中间表示</code>（<code>LIR</code>，与具体机器指令集相关的中间表示），然后再由<code>HotSpot</code>统一后端来产生机器码。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;后端编译器的编译速度及编译结果质量高低，是衡量Java虚拟机性能最重要的一个指标。
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--10 前端编译与优化</title>
    <link href="https://wuyunjie.top/2021/06/02/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_10_Front-end_compilation_and_optimization.html"/>
    <id>https://wuyunjie.top/2021/06/02/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_10_Front-end_compilation_and_optimization.html</id>
    <published>2021-06-02T08:38:04.000Z</published>
    <updated>2021-06-02T08:38:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>从计算机程序出现的第一天起，对效率的追逐就是程序员天生的坚定信仰，这个过程犹如一场没有终点、永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛车。 <a id="more"></a></p></blockquote><p><code>Java</code>有<code>3</code>类编译过程：</p><ul><li><strong>前端编译器</strong>：<strong>“编译器的前端”</strong>，把<code>*.java</code>文件转变成<code>*.class</code>文件，比如<code>JDK</code>的<code>Javac</code>、<code>Eclipse JDT</code>中的增量式编译器（<code>ECJ</code>）。</li><li><strong>即时编译器</strong>：常称<code>JIT编译器</code>（<code>Just In Time Compiler</code>），运行期把字节码转变成本地机器码，比如<code>HotSpot</code>虚拟机的<code>C1</code>、<code>C2</code>编译器，<code>Graal</code>编译器。</li><li><strong>提前编译器</strong>：常称<code>AOT编译器</code>（<code>Ahead Of Time Compiler</code>），直接把程序编译成与目标机器指令集相关的二进制代码。<code>JDK</code>的<code>Jaotc</code>、<code>GNU Compiler for the Java（GCJ）</code>、<code>Excelsior JET</code>。</li></ul><p>Java中即时编译器在运行期的优化过程，支撑了<strong>程序执行效率的不断提升</strong>；而前端编译器在编译期的优化过程，则是支撑着<strong>程序员的编码效率和语言使用者的幸福感的提高</strong>。</p><h3 id="javac编译器">1. <code>Javac</code>编译器</h3><p><code>Javac</code>编译器不像<code>HotSpot</code>虚拟机那样使用<code>C++</code>语言（包含少量<code>C</code>语言）实现，它本身就是一个由<code>Java</code>语言编写的程序。</p><h4 id="javac的源码与调试">1.1 <code>Javac</code>的源码与调试</h4><p><code>javac</code>的发展历史：</p><ul><li><code>JDK 6</code>以前，<code>Javac</code>并不属于标准<code>Java SE API</code>，它实现代码单独存放在<code>tools.jar</code>中。</li><li><code>JDK 6</code>发布时通过了<code>JSR 199</code>编译器<code>API</code>的提案，使得<code>Javac</code>编译器的实现代码晋升成为标准Java类库之一，它的源码就改为放在<code>JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac</code>中</li><li><code>JDK 9</code>时，整个<code>JDK</code>所有的<code>Java</code>类库都采用模块化进行重构划分，<code>Javac</code>编译器就被挪到了<code>jdk.compiler</code>模块（路径为：<code>JDK_SRC_HOME/src/jdk.compiler/share/classes/com/sun/tools/javac</code>）里面</li></ul><p>从<code>Javac</code>代码的总体结构来看，编译过程大致可以分为<code>1</code>个准备过程和<code>3</code>个处理过程：</p><ol type="1"><li><strong>准备过程</strong>：初始化插入式注解处理器。</li><li><strong>解析与填充符号表过程</strong>，包括：<ul><li><strong>词法、语法分析</strong>。将源代码的字符流转变为标记集合，构造出抽象语法树。</li><li><strong>填充符号表</strong>。产生符号地址和符号信息。</li></ul></li><li><strong>插入式注解处理器的注解处理过程</strong>：插入式注解处理器的执行阶段。</li><li><strong>分析与字节码生成过程</strong>，包括：<ul><li><strong>标注检查</strong>。对语法的静态信息进行检查。</li><li><strong>数据流及控制流分析</strong>。对程序动态运行过程进行检查。</li><li><strong>解语法糖</strong>。将简化代码编写的语法糖还原为原有的形式。</li><li><strong>字节码生成</strong>。将前面各个步骤所生成的信息转化成字节码。</li></ul></li></ol><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/javacComplierProcess.PNG" alt="Javac的编译过程" /><figcaption aria-hidden="true">Javac的编译过程</figcaption></figure><p>Javac编译动作的入口是<code>com.sun.tools.javac.main.JavaCompiler</code>类:</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/javacComplierCode.PNG" alt="Javac编译过程的主体代码" /><figcaption aria-hidden="true">Javac编译过程的主体代码</figcaption></figure><h4 id="解析与填充符号表">1.2 解析与填充符号表</h4><p>解析过程包括了<code>词法分析</code>和<code>语法分析</code>两个步骤：</p><h5 id="词法语法分析">1.2.1 词法、语法分析</h5><ul><li><strong>词法分析</strong>是将源代码的字符流转变为<code>标记（Token）</code>集合的过程，单个字符是<u>程序编写</u>时的最小元素，但标记才是<u>编译</u>时的最小元素。<ul><li>词法分析过程由<code>com.sun.tools.javac.parser.Scanner</code>类来实现。</li></ul></li><li><strong>语法分析</strong>是根据标记序列构造抽象语法树的过程，<code>抽象语法树（Abstract Syntax Tree，AST）</code>是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个<code>语法结构（Syntax Construct）</code>，例如<u>包、类型、修饰符、运算符、接口、返回值</u>甚至连<u>代码注释</u>等都可以是一种特定的语法结构。<ul><li>语法分析过程由<code>com.sun.tools.javac.parser.Parser</code>类实现的</li><li>抽象语法树是以<code>com.sun.tools.javac.tree.JCTree</code> 类表示的。</li></ul></li></ul><p>经过词法和语法分析生成语法树以后，编译器就不会再对源码字符流进行操作了，<u><strong>后续的操作都建立在抽象语法树之上</strong></u>。</p><h5 id="填充符号表">1.2.2 填充符号表</h5><p><code>符号表（Symbol Table）</code>是由一组<u><strong>符号地址</strong></u>和<u><strong>符号信息</strong></u>构成的数据结构。符号表中所登记的信息在编译的不同阶段都要被用到。</p><ul><li>在语义分析的过程中，符号表所登记的内容将用于语义检查和产生中间代码</li><li>在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。</li><li>填充符号表的过程由<code>com.sun.tools.javac.comp.Enter</code>类实现。</li></ul><h4 id="注解处理器">1.3 注解处理器</h4><p><code>注解（Annotations）</code>在设计上原本是与普通的Java代码一样，都只会在程序运行期间发挥作用的。但在<code>JDK 6</code>中设计了一组被称为<code>“插入式注解处理器”</code>的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。</p><ul><li><code>插入式注解处理器</code>可以看作是一组编译器的<strong>插件</strong>，它允许<strong>读取</strong>、<strong>修改</strong>、<strong>添加</strong>抽象语法树中的<strong>任意元素</strong>。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个<code>轮次（Round）</code>。</li></ul><h4 id="语义分析与字节码生成">1.4 语义分析与字节码生成</h4><p>抽象语法树能够表示一个<code>结构正确</code>的源程序，但无法保证源程序的<code>语义是符合逻辑</code>的。语义分析的主要任务则是<u><strong>对结构上正确的源程序进行上下文相关性质的检查</strong></u>，譬如进行<u>类型检查</u>、<u>控制流检查</u>、<u>数据流检查</u>，等等。</p><h5 id="标注检查">1.4.1 标注检查</h5><p>语义分析过程可分为<strong>标注检查</strong>和<strong>数据及控制流分析</strong>两个步骤。</p><p>标注检查步骤要检查的内容包括诸如<u>变量使用前是否已被声明</u>、<u>变量与赋值之间的数据类型是否能够匹配</u>，等等。还会顺便进行一个称为<code>常量折叠（Constant Folding）</code>的代码优化。</p><h5 id="数据及控制流分析">1.4.2 数据及控制流分析</h5><p><code>数据流分析</code>和<code>控制流分析</code>是对程序上下文逻辑更进一步的验证，它可以检查出诸如<u>程序局部变量在使用前是否有赋值</u>、<u>方法的每条路径是否都有返回值</u>、<u>是否所有的受查异常都被正确处理</u>等问题。</p><h5 id="解语法糖">1.4.3 解语法糖</h5><p><code>语法糖（Syntactic Sugar）</code>，也称<code>糖衣语法</code>，指的是在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响， 但是却能更方便程序员使用该语言。通常来说使用语法糖能够<em>减少代码量、增加程序的可读性</em>。</p><p>Java中最常见的语法糖包括了<strong><u>泛型</u></strong>、<u><strong>变长参数</strong></u>、<strong><u>自动装箱拆箱</u></strong>，等等，它们在编译阶段被还原回原始的基础语法结构，这个过程就称为<code>解语法糖</code>。</p><h5 id="字节码生成">1.4.4 字节码生成</h5><p>字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了<u>少量的代码添加和转换工作</u>。</p><ul><li>实例构造器<code>&lt;init&gt;()</code>方法和类构造器<code>&lt;clinit&gt;()</code>方法就是在这个阶段被添加到语法树之中的。</li></ul><p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交到<code>com.sun.tools.javac.jvm.ClassWriter</code>类手上，由这个类的<code>writeClass()</code>方法输出字节码，生成最终的Class 文件。</p><h3 id="java语法糖的味道">2. Java语法糖的味道</h3><p>语法糖虽然不会提供实质性的功能改进，但是它们或能提高效率，或能提升语法的严谨性，或能减少编码出错的机会。</p><h4 id="泛型">2.1 泛型</h4><p><code>泛型</code>的本质是<code>参数化类型（Parameterized Type）</code>或者<code>参数化多态（Parametric Polymorphism）</code>的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。</p><h5 id="java与c的泛型">2.1.1 Java与C#的泛型</h5><p><code>Java</code>选择的泛型实现方式叫作<code>“类型擦除式泛型”（Type Erasure Generics）</code>，而<code>C#</code>选择的泛型实现方式是<code>“具现化式泛型”（Reified Generics）</code>。</p><ul><li><code>C#</code>里面泛型无论在程序源码里面、编译后的中间语言表示（<code>Intermediate Language</code>）里面，抑或是运行期的<code>CLR</code>里面都是切实存在的，有着自己独立的虚方法表和类型数据。</li><li><code>Java</code>语言中的泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的<code>裸类型（Raw Type）</code>，并且在相应的地方插入了强制转型代码。<ul><li>对于运行期的Java语言来说，<code>ArrayList&lt;int&gt;</code>与<code>ArrayList&lt;String&gt;</code>其实是同一个类型。</li></ul></li></ul><p>Java的类型<code>擦除式泛型</code>无论在使用效果上还是运行效率上，几乎是全面落后于<code>C#</code>的<code>具现化式泛型</code>，而它的<u><strong>唯一优势</strong></u>是：</p><blockquote><p><code>擦除式泛型</code>的实现几乎只需要在<code>Javac</code>编译器上做出改进即可，不需要改动字节码、不需要改动Java虚拟机，也保证了以前没有使用泛型的库可以直接运行在Java 5.0之上。</p></blockquote><h5 id="类型擦除">2.1.2 类型擦除</h5><p>为了保证以前编译出来的<code>Class</code>文件可以在<code>Java 5.0</code>引入泛型之后继续运行，大体上有两条路可以选择：</p><ol type="1"><li>需要泛型化的类型（主要是容器类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型。</li><li>直接把已有的类型泛型化，即让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。</li></ol><p>Java选择了<u><strong>直接把已有的类型泛型化</strong></u>，譬如<code>ArrayList</code>原地泛型化后变成了<code>ArrayList&lt;T&gt;</code>。要保证以前直接用<code>ArrayList</code>的代码在泛型新版本里必须还能继续用这同一个容器，这就必须让所有泛型化的实例类型全部自动成为<code>ArrayList</code>的子类型才能可以，否则类型转换就是不安全的。由此就引出了<code>“裸类型”（Raw Type）</code>的概念。</p><blockquote><p><code>裸类型</code>应被视为所有该类型泛型化实例的<code>共同父类型（Super Type）</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ilist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; slist = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList list; <span class="comment">// 裸类型</span></span><br><span class="line">list = ilist;</span><br><span class="line">list = slist;</span><br></pre></td></tr></table></figure><p>如何实现裸类型又有两种选择：</p><ol type="1"><li>在运行期由<code>Java</code>虚拟机来自动地、真实地构造出<code>ArrayList&lt;Integer&gt;</code>这样的类型，并且自动实现从<code>ArrayList&lt;Integer&gt;</code>派生自<code>ArrayList</code>的继承关系来满足裸类型的定义；</li><li>简单粗暴地直接在编译时把<code>ArrayList&lt;Integer&gt;</code>还原回<code>ArrayList</code>，只在<u>元素访问</u>、<u>修改</u>时自动插入一些<u>强制类型转换和检查指令</u>。</li></ol><p>显然Java选择了后一种实现方式。可以看一个<code>Java</code>泛型擦除的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型擦除前的例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">    map.put(<span class="string">"how are you?"</span>, <span class="string">"吃了没？"</span>);</span><br><span class="line">    System.out.println(map.get(<span class="string">"hello"</span>));</span><br><span class="line">    System.out.println(map.get(<span class="string">"how are you?"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型擦除后的例子</span></span><br><span class="line"><span class="comment"> * 上一段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译的结果</span></span><br><span class="line"><span class="comment"> * 泛型类型都变回了裸类型，只在元素访问时插入了从Object到String的强制转型代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">    map.put(<span class="string">"how are you?"</span>, <span class="string">"吃了没？"</span>);</span><br><span class="line">    System.out.println((String) map.get(<span class="string">"hello"</span>));</span><br><span class="line">    System.out.println((String) map.get(<span class="string">"how are you?"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型擦除带来的缺陷：</p><ol type="1"><li><p>使用擦除法实现泛型直接导致了对<code>原始类型（Primitive Types）</code>数据的支持又成了新的麻烦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原始类型的泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ArrayList&lt;<span class="keyword">int</span>&gt; ilist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">ArrayList&lt;<span class="keyword">long</span>&gt; llist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line">ArrayList list;</span><br><span class="line">list = ilist;</span><br><span class="line">list = llist;</span><br></pre></td></tr></table></figure><p>由于Java不支持<code>int</code>、<code>long</code>与<code>Object</code>之间的强制转型，所以泛型擦除后在需要插入强制转型代码的地方就无法进行了。Java给出的解决方案简单粗暴：</p><blockquote><p>不支持原生类型的泛型，使用<code>ArrayList&lt;Integer&gt;</code>、<code>ArrayList&lt;Long&gt;</code>，遇到原生类型时自动装箱、拆箱。</p></blockquote></li><li><p>运行期无法取到泛型类型信息，会让一些代码变得相当啰嗦</p><p><code>Java</code>不支持如下泛型的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeErasureGenerics</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (item <span class="keyword">instanceof</span> E) &#123; <span class="comment">// 不合法，无法对泛型进行实例判断</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">E newItem = <span class="keyword">new</span> E(); <span class="comment">// 不合法，无法使用泛型创建对象</span></span><br><span class="line">E[] itemArray = <span class="keyword">new</span> E[<span class="number">10</span>]; <span class="comment">// 不合法，无法使用泛型创建数组</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些限制都是由于<u><strong>运行期Java虚拟机无法取得泛型类型</strong></u>而导致的，要实现类似操作，需要写一个泛型版本的从<code>List</code>到数组的转换方法，由于不能从<code>List</code>中取得参数化类型<code>T</code>，所以不得不从一个额外参数中再传入一个数组的组件类型进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] convert(List&lt;T&gt; list, Class&lt;T&gt; componentType) &#123;</span><br><span class="line">T[] array = (T[])Array.newInstance(componentType, list.size());</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>丧失了一些面向对象思想应有的优雅，带来了一些模棱两可的模糊状况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"invoke method(List&lt;String&gt; list)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"invoke method(List&lt;Integer&gt; list)"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为参数<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>编译之后都被擦除了，变成了同一种的裸类型<code>List</code>，类型擦除导致这两个方法的特征签名变得一模一样，无法重载。</p></li></ol><h5 id="值类型与未来的泛型">2.1.3 值类型与未来的泛型</h5><p>Oracle建立了一个名为<code>Valhalla</code>的语言改进项目，希望改进Java语言留下的各种缺陷。</p><p>在<code>Valhalla</code>项目中规划了几种不同的新泛型实现方案，被称为<code>Model 1</code>到<code>Model 3</code>，泛型类型有可能被：</p><ul><li><strong>具现化</strong></li><li>继续维持<strong>类型擦除以</strong>保持兼容<ul><li>泛型的参数化类型也可以选择不被完全地擦除掉，而是相对完整地记录在Class文件中，能够在运行期被使用</li><li>也可以指定编译器默认要擦除哪些类型。</li></ul></li></ul><p>相对于使用不同方式实现泛型，目前比较明确的是未来的Java应该会提供<code>“值类型”（Value Type）</code>的语言层面的支持。</p><blockquote><ul><li><p><code>值类型</code>可以与<code>引用类型</code>一样，具有<u>构造函数</u>、<u>方法</u>或是<u>属性字段</u>，等等</p></li><li><p><code>值类型</code>与<code>引用类型</code>的区别在于<u><strong>它在赋值的时候通常是整体复制，而不是像引用类型那样传递引用的</strong></u>。</p></li><li><p>值类型的实例很容易实现分配在方法的调用栈上的，值类型可以随着当前方法的退出而自动释放，不会给垃圾收集子系统带来任何压力。</p></li></ul></blockquote><p>Java的值类型方案被称为<code>“内联类型”</code>，计划通过一个新的关键字<code>inline</code>来定义，字节码层面也有专门与原生类型对应的以<code>Q</code>开头的新的操作码（譬如<code>iload</code>对应<code>qload</code>）来支撑。</p><h4 id="自动装箱拆箱与遍历循环">2.2 自动装箱、拆箱与遍历循环</h4><p><code>自动装箱</code>、<code>自动拆箱</code>与<code>遍历循环</code>（<code>for-each循环</code>）是Java语言里面被使用最多的语法糖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动装箱、拆箱与遍历循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动装箱、拆箱与遍历循环编译之后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List list = Arrays.asList( <span class="keyword">new</span> Integer[] &#123;</span><br><span class="line">Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">Integer.valueOf(<span class="number">2</span>),</span><br><span class="line">Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">Integer.valueOf(<span class="number">4</span>) &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)localIterator.next()).intValue();</span><br><span class="line">        sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>自动装箱</code>、<code>拆箱</code>在编译之后被转化成了对应的包装和还原方法，如<code>Integer.valueOf()</code>与<code>Integer.intValue()</code>方法</li><li><code>遍历循环</code>则是把代码还原成了迭代器的实现</li><li><code>变长参数</code>在调用的时候变成了一个数组类型的参数</li></ul><p>自动装箱的陷阱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    Integer b = <span class="number">2</span>;</span><br><span class="line">    Integer c = <span class="number">3</span>;</span><br><span class="line">    Integer d = <span class="number">3</span>;</span><br><span class="line">    Integer e = <span class="number">321</span>;</span><br><span class="line">    Integer f = <span class="number">321</span>;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">    System.out.println(e == f);</span><br><span class="line">    System.out.println(c == (a + b));</span><br><span class="line">    System.out.println(c.equals(a + b));</span><br><span class="line">    System.out.println(g == (a + b));</span><br><span class="line">    System.out.println(g.equals(a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/TrapOfAutoBoxing.PNG" alt="自动装箱的陷阱" /><figcaption aria-hidden="true">自动装箱的陷阱</figcaption></figure><ul><li><p>对于前两个结果，基于<code>==</code>比较，但返回结果不一样，查看Integer内部源码发现，有一个静态内部类的缓存池<code>IntegerCache</code>，缓存范在为<code>-128~127</code>的数，超过这个范围的<code>Integer</code>值都是<code>new</code>出来的新对象。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/IntegerValueOf.PNG" alt="ValueOf" /><figcaption aria-hidden="true">ValueOf</figcaption></figure><ul><li>直接使用<code>==</code>比较符，比较的是引用的堆地址，所以<code>c</code>与<code>d</code>都是同一个堆地址，返回<code>true</code>；<code>e</code>和<code>f</code>是创建的两个不同的对象，返回<code>false</code>。从变量表也可以看出来：</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/TrapOfAutoBoxingVariable.PNG" alt="变量表" /><figcaption aria-hidden="true">变量表</figcaption></figure><ul><li><code>Integer</code>缓存了<code>-128~127</code>之间的数，这是在类加载期间就完成的。以后需要的时候直接指向它就可以了，省去了构造对象的开支，提高了效率。</li></ul></li><li><p>包装类的<code>“==”</code>运算在不遇到算术运算的情况下不会自动拆箱，以及它们<code>equals()</code>方法不处理数据转型的关系</p></li></ul><h4 id="条件编译">2.4 条件编译</h4><p>Java语言可以进行条件编译，方法就是使用条件为常量的<code>if</code>语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   System.out.println(<span class="string">"block 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反编译结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能使用条件为常量的<code>if</code>语句才能达到上述效果。根据布尔常量值的真假，编译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段（<code>com.sun.tools.javac.comp.Lower</code>类中）完成。</p><blockquote><p>条件编译的实现方式使用了<code>if</code>语句，所以它必须遵循最基本的Java语法，只能写在方法体内部，因此它只能实现语句<code>基本块（Block）</code>级别的条件编译，而没有办法实现根据条件调整整个Java类的结构。</p></blockquote><h3 id="实战插入式注解处理器">3. 实战：插入式注解处理器</h3><h4 id="实战目标">3.1 实战目标</h4><p>使用<code>注解处理器API</code>来编写一款拥有自己编码风格的校验工具：<code>NameCheckProcessor</code>。<code>NameCheckProcessor</code>的目标定为对Java程序命名进行检查，Java程序命名推荐（而不是强制）应当符合下列格式的书写规范：</p><ul><li><strong>类（或接口）</strong>：符合<u>驼式命名法</u>，<u>首字母大写</u>。</li><li><strong>方法</strong>：符合<u>驼式命名法</u>，<u>首字母小写</u>。</li><li><strong>字段</strong>：<ul><li><strong>类或实例变量</strong>。符合驼式命名法，首字母小写。</li><li><strong>常量</strong>。要求<strong>全部由大写字母或下划线</strong>构成，并且<u>第一个字符不能是下划线</u>。</li></ul></li></ul><h4 id="代码实现">3.2 代码实现</h4><p>实现<code>注解处理器</code>的代码需要继承抽象类<code>javax.annotation.processing.AbstractProcessor</code>。</p><ul><li>这个抽象类中只有一个子类必须实现的抽象方法：<code>“process()”</code>，它是Javac编译器在执行注解处理器代码时要调用的过程。<ul><li>从这个方法的第一个参数<code>“annotations”</code>中获取到此<code>注解处理器</code>所要处理的<code>注解集合</code>。</li><li>从第二个参数<code>“roundEnv”</code>中访问到当前这个<code>轮次（Round）</code>中的抽象语法树节点，每个语法树节点在这里都表示为一个<code>Element</code>。</li></ul></li><li>实例变量<code>“processingEnv”</code>是<code>AbstractProcessor</code>中的一个<code>protected</code>变量，在注解处理器初始化的时候（<code>init()</code>方法执行的时候）创建，继承了<code>AbstractProcessor</code>的注解处理器代码可以直接访问它。它代表了注解处理器框架提供的一个<code>上下文环境</code>，要<u>创建新的代码</u>、<u>向编译器输出信息</u>、<u>获取其他工具类</u>等都需要用到这个实例变量。</li><li>还有两个经常配合着使用的注解，分别是：<ul><li><code>@SupportedAnnotationTypes</code>，代表了这个注解处理器对哪些注解感兴趣，可以使用星号<code>“*”</code>作为通配符代表对所有的注解都感兴趣</li><li><code>@SupportedSourceVersion</code>，指出这个注解处理器可以处理哪些版本的Java代码。</li></ul></li></ul><p>如果不需要改变或添加抽象语法树中的内容，<code>process()</code> 方法可以返回<code>false</code>，通知编译器这个轮次中的代码未发生变化，无须构造新的<code>JavaCompiler</code>实例。</p><p>注解处理器<code>NameCheckProcessor</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用"*"表示支持所有Annotations</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"*"</span>)</span><br><span class="line"><span class="comment">// 只支持JDK 6的Java代码</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NameChecker nameChecker;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化名称检查插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        nameChecker = <span class="keyword">new</span> NameChecker(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对输入的语法树的各个节点进行名称检查</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!roundEnv.processingOver()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Element element : roundEnv.getRootElements())</span><br><span class="line">                nameChecker.checkNames(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名检查器<code>NameChecker</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.processing.Messager;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.ProcessingEnvironment;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.ElementScanner6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.lang.model.element.ElementKind.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.lang.model.element.Modifier.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.tools.Diagnostic.Kind.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序名称规范的编译器插件：&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 如果程序命名不合规范，将会输出一个编译器的WARNING信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messager messager;</span><br><span class="line"></span><br><span class="line">    NameCheckScanner nameCheckScanner = <span class="keyword">new</span> NameCheckScanner();</span><br><span class="line"></span><br><span class="line">    NameChecker(ProcessingEnvironment processsingEnv) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messager = processsingEnv.getMessager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对Java程序命名进行检查，根据《Java语言规范》第三版第6.8节的要求，Java程序命名应当符合下列格式：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;类或接口：符合驼式命名法，首字母大写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;方法：符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;字段：</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;类、实例变量: 符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;常量: 要求全部大写。</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkNames</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        nameCheckScanner.scan(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称检查器实现类，继承了JDK 6中新提供的ElementScanner6&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 将会以Visitor模式访问抽象语法树中的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckScanner</span> <span class="keyword">extends</span> <span class="title">ElementScanner6</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此方法用于检查Java类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitType</span><span class="params">(TypeElement e, Void p)</span> </span>&#123;</span><br><span class="line">            scan(e.getTypeParameters(), p);</span><br><span class="line">            checkCamelCase(e, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">super</span>.visitType(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查方法命名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitExecutable</span><span class="params">(ExecutableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == METHOD) &#123;</span><br><span class="line">                Name name = e.getSimpleName();</span><br><span class="line">                <span class="keyword">if</span> (name.contentEquals(e.getEnclosingElement().getSimpleName()))</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"一个普通方法 “"</span> + name + <span class="string">"”不应当与类名重复，避免与构造函数产生混淆"</span>, e);</span><br><span class="line">                checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.visitExecutable(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查变量命名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitVariable</span><span class="params">(VariableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果这个Variable是枚举或常量，则按大写命名检查，否则按照驼式命名法规则检查</span></span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == ENUM_CONSTANT || e.getConstantValue() != <span class="keyword">null</span> || heuristicallyConstant(e))</span><br><span class="line">                checkAllCaps(e);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断一个变量是否是常量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">heuristicallyConstant</span><span class="params">(VariableElement e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getEnclosingElement().getKind() == INTERFACE)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e.getKind() == FIELD &amp;&amp; e.getModifiers().containsAll(EnumSet.of(PUBLIC, STATIC, FINAL)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查传入的Element是否符合驼式命名法，如果不符合，则输出警告信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCamelCase</span><span class="params">(Element e, <span class="keyword">boolean</span> initialCaps)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line">            <span class="keyword">boolean</span> previousUpper = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (Character.isUpperCase(firstCodePoint)) &#123;</span><br><span class="line">                previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当以小写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isLowerCase(firstCodePoint)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当以大写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (conventional) &#123;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (Character.isUpperCase(cp)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUpper) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        previousUpper = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!conventional)</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当符合驼式命名法（Camel Case Names）"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 大写命名检查，要求第一个字母必须是大写的英文字母，其余部分可以是下划线或大写字母</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkAllCaps</span><span class="params">(Element e)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isUpperCase(firstCodePoint))</span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (cp == (<span class="keyword">int</span>) <span class="string">'_'</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUnderscore) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        previousUnderscore = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!conventional)</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"常量“"</span> + name + <span class="string">"”应当全部以大写字母或下划线命名，并且以字母开头"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含了多处不规范命名的代码样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BADLY_NAMED_CODE</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> colors &#123;</span><br><span class="line">        red, blue, green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _FORTY_TWO = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> NOT_A_CONSTANT = _FORTY_TWO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">BADLY_NAMED_CODE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NOTcamelCASEmethodNAME</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>Javac</code>命令的<code>“-processor”</code>参数来执行编译时需要附带的注解处理器，还可以使用<code>-XprintRounds</code>和<code>-XprintProcessorInfo</code>参数来查看注解处理器运作的详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -processor JVMLearning.Complier.NameCheckProcessor JVMLearning\Complier\BADLY_NAMED_CODE.java</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;从计算机程序出现的第一天起，对效率的追逐就是程序员天生的坚定信仰，这个过程犹如一场没有终点、永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛车。
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--9 类加载及执行子系统的案例与实战</title>
    <link href="https://wuyunjie.top/2021/05/31/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_9_Case_and_practice_of_class_loading_and_execution_subsystem.html"/>
    <id>https://wuyunjie.top/2021/05/31/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_9_Case_and_practice_of_class_loading_and_execution_subsystem.html</id>
    <published>2021-05-31T13:23:21.000Z</published>
    <updated>2021-05-31T13:23:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变。 <a id="more"></a></p></blockquote><p>能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能。</p><h3 id="案例分析">1. 案例分析</h3><h4 id="tomcat正统的类加载器架构">1.1 <code>Tomcat</code>：正统的类加载器架构</h4><p>主流的<code>Java Web服务器</code>，如<code>Tomcat</code>、<code>Jetty</code>、<code>WebLogic</code>、<code>WebSphere</code>等，都实现了自己定义的类加载器，而且一般不止一个。一个功能健全的Web服务器，要解决如下的这些问题：</p><ul><li>部署在<u>同一个服务器</u>上的两个Web应用程序所使用的Java类库可以实现<strong><u>相互隔离</u></strong>。</li><li>部署在<u>同一个服务器</u>上的两个Web应用程序所使用的Java类库可以<u><strong>互相共享</strong></u>。</li><li>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响。</li><li>支持<code>JSP</code>应用的Web服务器，十有八九都需要支持<code>HotSwap</code>功能。<code>JSP</code>文件由于其<u>纯文本存储</u>的特性，被运行时修改的概率远大于第三方类库或程序自己的Class文件。而且<code>ASP</code>、<code>PHP</code>和<code>JSP</code>这些网页应用也把<u><strong>修改后无须重启</strong></u>作为一 个很大的“优势”来看待，因此“主流”的Web服务器都会支持<code>JSP</code>生成类的<strong><code>热替换</code></strong>。</li></ul><p>由于存在上述问题，在部署Web应用时，各种Web服务器都提供了好几个有着不同含义的<code>ClassPath</code>路径供用户存放<u>第三方类库</u>，这些路径一般会以<code>“lib”</code>或<code>“classes”</code>命名。通常每一个目录都会有一个相应的<strong><code>自定义类加载器</code></strong>去加载放置在里面的Java类库。</p><h4 id="osgi灵活的类加载器架构">1.2 <code>OSGi</code>：灵活的类加载器架构</h4><p><code>OSGi （Open Service Gateway Initiative）</code>是<code>OSGi联盟（OSGi Alliance）</code>制订的一个基于Java语言的<code>动态模块化规范</code>。<code>OSGi</code>中的每个模块（称为<code>Bundle</code>）与普通的Java类库区别并不太大，两者一般都以<code>JAR</code>格式进行封装，并且内部存储的都是Java的<code>Package</code>和<code>Class</code>。</p><ul><li>但是一个<code>Bundle</code>可以声明它所依赖的<code>Package</code>（通过<code>Import-Package</code>描述），也可以声明它允许导出发布的<code>Package</code>（通过<code>Export-Package</code>描述）。</li><li>在<code>OSGi</code>里面，<code>Bundle</code>之间的依赖关系从传统的上层模块依赖底层模块转变为<strong>平级模块之间的依赖</strong>，而且类库的可见性能得到非常精确的控制，一个模块里只有被<code>Export</code>过的<code>Package</code>才可能被外界访问，其他的<code>Package</code>和<code>Class</code>将会被隐藏起来。</li></ul><p>但引入<code>OSGi</code>的主要理由是基于<code>OSGi</code>架构的程序很可能会实现模块级的<strong><u>热插拔功能</u></strong>，该特性要归功于它灵活的类加载器架构：</p><ul><li><code>OSGi</code>的<code>Bundle</code>类加载器之间只有规则，没有固定的委派关系。例如，某个<code>Bundle</code>声明了一个它依赖的<code>Package</code>，如果有其他<code>Bundle</code>声明了发布这个<code>Package</code>后，那么所有对这个<code>Package</code>的类加载动作都会委派给发布它的<code>Bundle</code>类加载器去完成。</li><li>不涉及某个具体的Package时，各个Bundle加载器都是平级的关系，只有具体使用到某个<code>Package</code>和<code>Class</code>的时候，才会根据<code>Package</code><strong>导入导出定义</strong>来构造<code>Bundle</code>间的委派和依赖。</li><li>一个<code>Bundle</code>类加载器为其他<code>Bundle</code>提供服务时，会根据<code>Export-Package</code>列表严格控制访问范围。</li></ul><p>假设存在<code>Bundle A</code>、<code>Bundle B</code>、<code>Bundle C</code>这<code>3</code>个模块，并且这<code>3</code>个<code>Bundle</code>定义的依赖关系如下：</p><ul><li><code>Bundle A</code>：声明发布了<code>package A</code>，依赖了<code>java.*</code>的包；</li><li><code>Bundle B</code>：声明依赖了<code>package A</code>和<code>package C</code>，同时也依赖了<code>java.*</code>的包；</li><li><code>Bundle C</code>：声明发布了<code>package C</code>，依赖了<code>package A</code>。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OSGiClassloaderArchitecture.PNG" alt="OSGi的类加载器架构" /><figcaption aria-hidden="true">OSGi的类加载器架构</figcaption></figure><p>在 <code>OSGi</code>里，类加载时可能进行的查找规则如下：</p><ul><li>以<code>java.*</code>开头的类，委派给父类加载器加载。</li><li>否则，委派列表名单内的类，委派给父类加载器加载。</li><li>否则，<code>Import</code>列表中的类，委派给<code>Export</code>这个类的<code>Bundle</code>的类加载器加载。</li><li>否则，查找当前<code>Bundle</code>的<code>Classpath</code>，使用自己的类加载器加载。</li><li>否则，查找是否在自己的<code>Fragment Bundle</code>中，如果是则委派给<code>Fragment Bundle</code>的类加载器加载。</li><li>否则，查找<code>Dynamic Import</code>列表的<code>Bundle</code>，委派给对应<code>Bundle</code>的类加载器加载。</li><li>否则，类查找失败。</li></ul><h4 id="字节码生成技术与动态代理的实现">1.3 字节码生成技术与动态代理的实现</h4><h5 id="字节码生成技术">1.3.1 字节码生成技术</h5><p>要深入从Java源码到字节码编译过程，阅读<code>Javac</code>的源码是个很好的途径。在Java世界里面除了<code>Javac</code>和字节码类库外，使用到字节码生成的例子比比皆是：</p><ul><li>Web服务器中的<code>JSP编译器</code>，编译时植入的<code>AOP框架</code>；</li><li>动态代理技术；</li><li>使用反射的时候虚拟机有可能会在运行时生成字节码来提高执行速度。</li></ul><h5 id="动态代理技术">1.3.2 动态代理技术</h5><p>动态代理的优势在于，<u>实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        Object originalObj;</span><br><span class="line"></span><br><span class="line">        <span class="function">Object <span class="title">bind</span><span class="params">(Object originalObj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.originalObj = originalObj;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"welcome"</span>);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(originalObj, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IHello hello = (IHello) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> Hello());</span><br><span class="line">        hello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy::newProxyInstance()</code>方法返回一个实现了<code>IHello</code>的接口，并且代理了<code>new Hello()</code>实例行为的对象，程序进行过验证、优化、缓存、同步、生成字节码、显式类加载等操作，它最后调用<code>sun.misc.ProxyGenerator::generateProxyClass()</code>方法来完成<code>生成字节码</code>的动作，这个方法会在运行时产生一个描述代理类的字节码<strong>byte[]数组</strong>。</p><h4 id="backport工具java的时光机器">1.4 <code>Backport</code>工具：Java的时光机器</h4><p>“Java逆向移植”的工具（<code>Java Backporting Tools</code>）用于把<strong>高版本JDK</strong>中编写的代码放到低版本JDK环境中去部署使用。<code>Retrotranslator</code>和<code>Retrolambda</code>是这类工具中的杰出代表。</p><ul><li><code>Retrotranslator</code>的作用是将<code>JDK 5</code>编译出来的Class文件转变为可以在<code>JDK 1.4</code>或<code>1.3</code>上部署的版本，它能很好地支持<u>自动装箱</u>、<u>泛型</u>、<u>动态注解</u>、<u>枚举</u>、<u>变长参数</u>、<u>遍历循环</u>、<u>静态导入</u>这些语法特性， 甚至还可以支持<code>JDK 5</code>中新增的<u>集合改进</u>、<u>并发包</u>及<u>对泛型、注解等的反射操作</u>。</li><li><code>Retrolambda</code>将<code>JDK 8</code>的<code>Lambda</code>表达式和<code>try-resources</code>语法转变为可以在<code>JDK 5</code>、<code>JDK 6</code>、<code>JDK 7</code>中使用的形式，同时也对<code>接口默认方法</code>提供了<strong>有限度</strong>的支持。</li></ul><p>JDK的每次升级新增的功能大致可以分为以下五类：</p><ol type="1"><li>对Java类库API的代码增强。</li><li>在前端编译器层面做的改进。</li><li>需要在字节码中进行支持的改动。</li><li>需要在JDK整体结构层面进行支持的改进。</li><li>集中在虚拟机内部的改进。</li></ol><p>上述的5类新功能中，逆向移植工具能比较完美地模拟了前两类。</p><h3 id="实战自己动手实现远程执行功能">2. 实战：自己动手实现远程执行功能</h3><p>做程序维护的时候会遇到只要在服务中执行一小段程序代码，就可以定位或排除问题，但就是偏偏找不到可以让服务器执行时代码的途径。通常解决这类问题有以下几种途径：</p><ol type="1"><li>可以使用<code>BTrace</code>这类<code>JVMTI</code>工具去动态修改程序中某一部分的运行代码，类似的<code>JVMTI</code>工具还有阿里巴巴的<code>Arthas</code>等。</li><li>使用<code>JDK 6</code>之后提供了<code>Compiler API</code>，可以动态地编译Java程序，这样虽然达不到动态语言的灵活度，但让服务器执行临时代码的需求是可以得到解决的。</li><li>写一个<code>JSP文件</code>上传到服务器，然后在浏览器中运行它，或者在服务端程序中加入一个<code>BeanShell Script</code>、<code>JavaScript</code>等的执行引擎去执行动态脚本。</li><li>在应用程序中内置动态执行的功能。</li></ol><h4 id="目标">2.1 目标</h4><p>希望最终的产品：</p><ul><li>不依赖某个JDK版本才加入的特性（包括<code>JVMTI</code>），能在目前还被普遍使用的JDK中部署。</li><li>不改变原有服务端程序的部署，不依赖任何第三方类库。</li><li>不侵入原有程序，即无须改动原程序的任何代码。也不会对原有程序的运行带来任何影响。</li><li>考虑到<code>BeanShell Script</code>或<code>JavaScript</code>等脚本与Java对象交互起来不太方便，<code>“临时代码”</code>应该直接支持Java语言。</li><li><code>“临时代码”</code>应当具备足够的自由度，不需要依赖特定的类或实现特定的接口。</li><li><code>“临时代码”</code>的执行结果能返回到客户端，执行结果可以包括程序中输出的信息及抛出的异常等。</li></ul><h4 id="思路">2.2 思路</h4><p>需要解决以下3个问题：</p><ol type="1"><li>如何编译提交到服务器的Java代码？<ul><li>在服务器上编译，在<code>JDK 6</code>以后可以使用<code>Compiler API</code>，在<code>JDK 6</code>以前可以使用<code>tools.jar</code>包中的 <code>com.sun.tools.Javac.Main</code>类来编译Java文件。这种思路的缺点是引入了额外的依赖，而且把程序绑死在<strong>特定</strong>的<code>JDK</code>上了。</li><li>在客户端编译好，把<strong><u>字节码</u></strong>传到服务端。</li></ul></li><li>如何执行编译之后的Java代码？<ul><li>让类加载器加载这个类生成一个Class对象，然后反射调用一下某个方法；</li></ul></li><li>如何收集Java代码的执行结果？<ul><li>把程序往<code>标准输出（System.out）</code>和<code>标准错误输出（System.err）</code>中打印的信息收集起来。但会对原有程序产生影响：<u>会把其他线程向标准输出中打印的信息也收集了</u>。</li><li>直接在执行的类中把对<code>System.out</code>的符号引用替换为我们准备的<code>PrintStream</code>的符号引用。</li></ul></li></ol><h4 id="实现">2.3 实现</h4><p>实现过程中需要用到的4个支持类：</p><h5 id="hotswapclassloader">2.3.1 <code>HotSwapClassLoader</code></h5><p><code>HotSwapClassLoader</code>类于实现<code>“同一个类的代码可以被多次加载”</code>这个需求。<code>HotSwapClassLoader</code>所做的事情仅仅是公开父类（即<code>java.lang.ClassLoader</code>）中的<code>protected</code>方法<code>defineClass()</code>，我们将会使用这个方法<u><strong>把提交执行的Java类的<code>byte[]</code>数组转变为Class对象</strong></u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了多次载入执行类而加入的加载器</span></span><br><span class="line"><span class="comment"> * 把defineClass方法开放出来，只有外部显式调用的时候才会使用到loadByte方法</span></span><br><span class="line"><span class="comment"> * 由虚拟机调用时，仍然按照原有的双亲委派规则使用loadClass方法进行类加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotSwapClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HotSwapClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HotSwapClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadByte</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, classByte, <span class="number">0</span>, classByte.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="classmodifier">2.3.2 <code>ClassModifier</code></h5><p><code>ClassModifier</code>类实现将<code>java.lang.System</code>替换为我们自己定义的<code>HackSystem</code>类的过程，它<strong><u>直接修改符合Class文件格式的byte[]数组中的<code>常量池</code>部分，将常量池中指定内容的<code>CONSTANT_Utf8_info</code>常量替换为新的字符串</u></strong>。</p><p>经过<code>ClassModifier</code>处理后的<code>byte[]数组</code>才会传给<code>HotSwapClassLoader.loadByte()</code>方法进行类加载，<code>byte[]数组</code>在这里替换符号引用之后，与客户端直接在Java代码中引用<code>HackSystem</code>类再编译生成的Class是完全一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 修改Class文件，暂时只提供修改常量池常量的功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassModifier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class文件中常量池的起始偏移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_POOL_COUNT_INDEX = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CONSTANT_Utf8_info常量的tag标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_Utf8_info = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量池中11种常量所占的长度，CONSTANT_Utf8_info型常量除外，因为它不是定长的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] CONSTANT_ITEM_LENGTH = &#123; -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] classByte;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassModifier</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classByte = classByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改常量池中CONSTANT_Utf8_info常量的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldStr 修改前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newStr 修改后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 修改结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] modifyUTF8Constant(String oldStr, String newStr) &#123;</span><br><span class="line">        <span class="keyword">int</span> cpc = getConstantPoolCount();</span><br><span class="line">        <span class="keyword">int</span> offset = CONSTANT_POOL_COUNT_INDEX + u2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cpc; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tag = ByteUtils.bytes2Int(classByte, offset, u1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tag == CONSTANT_Utf8_info) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = ByteUtils.bytes2Int(classByte, offset + u1, u2);</span><br><span class="line">                offset += (u1 + u2);</span><br><span class="line">                String str = ByteUtils.bytes2String(classByte, offset, len);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (str.equalsIgnoreCase(oldStr)) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] strBytes = ByteUtils.string2Bytes(newStr);</span><br><span class="line">                    <span class="keyword">byte</span>[] strLen = ByteUtils.int2Bytes(newStr.length(), u2);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset - u2, u2, strLen);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset, len, strBytes);</span><br><span class="line">                    <span class="keyword">return</span> classByte;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    offset += len;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                offset += CONSTANT_ITEM_LENGTH[tag];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classByte;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取常量池中常量的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 常量池数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getConstantPoolCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ByteUtils.bytes2Int(classByte, CONSTANT_POOL_COUNT_INDEX, u2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="byteutils">2.3.3 <code>ByteUtils</code></h5><p><code>ClassModifier</code>中涉及对<code>byte[]数组</code>操作的部分， 主要是将<code>byte[]</code>与<code>int</code>和<code>String</code>互相转换，以及把对<code>byte[]数据</code>的替换操作封装在<code>ByteUtils</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** Bytes数组处理工具</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bytes2Int</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = start + len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = ((<span class="keyword">int</span>) b[i]) &amp; <span class="number">0xff</span>;</span><br><span class="line">            n &lt;&lt;= (--len) * <span class="number">8</span>;</span><br><span class="line">            sum = n + sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] int2Bytes(<span class="keyword">int</span> value, <span class="keyword">int</span> len) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            b[len - i - <span class="number">1</span>] = (<span class="keyword">byte</span>) ((value &gt;&gt; <span class="number">8</span> * i) &amp; <span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytes2String</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(b, start, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] string2Bytes(String str) &#123;</span><br><span class="line">        <span class="keyword">return</span> str.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] bytesReplace(<span class="keyword">byte</span>[] originalBytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, <span class="keyword">byte</span>[] replaceBytes) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] newBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[originalBytes.length + (replaceBytes.length - len)];</span><br><span class="line">        System.arraycopy(originalBytes, <span class="number">0</span>, newBytes, <span class="number">0</span>, offset);</span><br><span class="line">        System.arraycopy(replaceBytes, <span class="number">0</span>, newBytes, offset, replaceBytes.length);</span><br><span class="line">        System.arraycopy(originalBytes, offset + len, newBytes, offset + replaceBytes.length, originalBytes.length - offset - len);</span><br><span class="line">        <span class="keyword">return</span> newBytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="hacksystem">2.3.4 <code>HackSystem</code></h5><p>用来代替<code>java.lang.System</code>的<code>HackSystem</code>，主要把<code>out</code>和<code>err</code>两个静态变量改成使用<code>ByteArrayOutputStream</code>作为打印目标的同一个<code>PrintStream</code>对象，以及增加了<u><strong>读取</strong></u>、<u><strong>清理</strong></u><code>ByteArrayOutputStream</code>中内容的<code>getBufferString()</code>和 <code>clearBuffer()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为Javaclass劫持java.lang.System提供支持</span></span><br><span class="line"><span class="comment"> * 除了out和err外，其余的都直接转发给System处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HackSystem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> InputStream in = System.in;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out = <span class="keyword">new</span> PrintStream(buffer);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream err = out;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getBufferString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buffer.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSecurityManager</span><span class="params">(<span class="keyword">final</span> SecurityManager s)</span> </span>&#123;</span><br><span class="line">        System.setSecurityManager(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecurityManager <span class="title">getSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.getSecurityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(src, srcPos, dest, destPos, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">identityHashCode</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.identityHashCode(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面所有的方法都与java.lang.System的名称一样</span></span><br><span class="line">    <span class="comment">// 实现都是字节转调System的对应方法</span></span><br><span class="line">    <span class="comment">// 因版面原因，省略了其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="javaclassexecuter">2.3.5 <code>JavaclassExecuter</code></h5><p><code>JavaclassExecuter</code>是提供给外部调用的入口，调用前面几个支持类组装逻辑，完成类加载工作。</p><ul><li>用输入的符合Class文件格式的<code>byte[]数组</code>替换掉<code>java.lang.System</code>的符号引用后，使用<code>HotSwapClassLoader</code>加载生成一个Class对象；</li><li>然后<code>反射</code>调用这个Class对象的<code>main()</code>方法，如果期间出现任何异常，将异常信息打印到<code>HackSystem.out</code>中，</li><li>最后把缓冲区中的信息作为方法的结果来返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Javaclass执行工具</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaclassExecuter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行外部传过来的代表一个Java类的Byte数组&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 将输入类的byte数组中代表java.lang.System的CONSTANT_Utf8_info常量修改为劫持后的HackSystem类</span></span><br><span class="line"><span class="comment">     * 执行方法为该类的static main(String[] args)方法，输出结果为该类向System.out/err输出的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classByte 代表一个Java类的Byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">execute</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        HackSystem.clearBuffer();</span><br><span class="line">        ClassModifier cm = <span class="keyword">new</span> ClassModifier(classByte);</span><br><span class="line">        <span class="keyword">byte</span>[] modiBytes = cm.modifyUTF8Constant(<span class="string">"java/lang/System"</span>, <span class="string">"org/fenixsoft/classloading/execute/HackSystem"</span>);</span><br><span class="line">        HotSwapClassLoader loader = <span class="keyword">new</span> HotSwapClassLoader();</span><br><span class="line">        Class clazz = loader.loadByte(modiBytes);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = clazz.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[]&#123;String[]<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            method.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> String[]&#123; <span class="keyword">null</span> &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace(HackSystem.out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HackSystem.getBufferString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证">2.4 验证</h4><p>写一个Java类，只要向<code>System.out</code>输出信息即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test executor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立一个测试代码，就可以在输出这个类的运行结果(原文是通过<code>JSP</code>来实现的，这里没有搭建服务器，就用这个小例子试试，可能不是那么合适的代替)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecuter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/Users/yunjiewu/IdeaProjects/JavaLearning/out/production/JavaLearning/JVMLearning/JavaclassExecuter/TestClass.class"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line">            is.close();</span><br><span class="line">            System.out.println(JavaclassExecuter.execute(b));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变。
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--8 虚拟机字节码执行引擎</title>
    <link href="https://wuyunjie.top/2021/05/28/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_8_Virtual_machine_bytecode_execution_engine.html"/>
    <id>https://wuyunjie.top/2021/05/28/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_8_Virtual_machine_bytecode_execution_engine.html</id>
    <published>2021-05-28T01:51:15.000Z</published>
    <updated>2021-05-28T01:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>执行引擎是Java虚拟机核心的组成部分之一。 <a id="more"></a></p></blockquote><p>在不同的虚拟机实现中，执行引擎在执行字节码的时候，通常会有<code>解释执行（通过解释器执行）</code>和<code>编译执行（通过即时编译器产生本地代码执行）</code>两种，也可能两者兼备。</p><p>但从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：</p><ul><li>输入的是字节码二进制流；</li><li>处理过程是字节码解析执行的等效过程；</li><li>输出的是执行结果，</li></ul><h3 id="运行时栈帧结构">1. 运行时栈帧结构</h3><p>Java虚拟机<strong><u>以方法作为最基本的执行单元</u></strong>，<code>“栈帧”（Stack Frame）</code>则是用于支持虚拟机进行<strong>方法调用</strong>和<strong>方法执行</strong>背后的数据结构，它也是虚拟机运行时数据区中的<code>虚拟机栈（Virtual Machine Stack）</code>的栈元素。</p><blockquote><p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。一个栈帧需要分配多少内存仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p></blockquote><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/StackFrame.PNG" alt="栈帧结构" /><figcaption aria-hidden="true">栈帧结构</figcaption></figure><h4 id="局部变量表">1.1 局部变量表</h4><p><code>局部变量表（Local Variables Table）</code>是一组变量值的存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>。</p><blockquote><p>局部变量表的容量以<code>变量槽（Variable Slot）</code>为最小单位，一个变量槽应占用的内存空间大小未明确定义，每个变量槽都应该能存放一个<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>reference</code>或<code>returnAddress</code>类型的数据。对于64位的数据类型，Java虚拟机会以<strong>高位对齐</strong>的方式为其分配两个连续的变量槽空间。</p></blockquote><p>Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是<u><strong>从0开始至局部变量表最大的变量槽数量</strong></u>。</p><blockquote><p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成<u><strong>参数值到参数变量列表的传递过程， 即实参到形参的传递</strong></u>。</p><ul><li>如果执行的是实例方法，局部变量表中<strong><u>第0位索引</u></strong>的变量槽默认是<strong><u>用于传递方法所属对象实例的引用</u></strong>，在方法中可以通过关键字<code>“this”</code>来访问到这个隐含的参数。</li><li>其余参数则按照参数表顺序排列，占用<strong><u>从1开始</u></strong>的局部变量槽；</li><li>参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</li></ul></blockquote><p>为了尽可能节省栈帧耗用的内存空间，局部变量表中的变量槽是可以重用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 局部变量表Slot复用对垃圾收集的影响</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>placeholder</code>能否被回收的根本原因就是：局部变量表中的变量槽是否还存有关于<code>placeholder</code>数组对象的引用。</p><ul><li>未加入<code>int a = 0;</code>语句时，虽然已经离开了<code>placeholder</code>的作用域，<code>placeholder</code>原本所占用的变量槽还没有被其他变量所复用，所以作为<code>GC Roots</code>一部分的局部变量表仍然保持着对它的关联。所以<code>placeholder</code>数组对象不会被回收。</li><li>手动将其设置占用了大量内存但实际上已经不会再使用的变量为<code>null</code>值(代替那句<code>int a = 0;</code>)，可以作为一种在极特殊情形下的<code>“奇技”</code>来使用。</li></ul><p>此外，局部变量不像类变量那样存在“准备阶段”，即不会被系统初始化为默认值。</p><h4 id="操作数栈">1.2 操作数栈</h4><p><code>操作数栈（Operand Stack）</code>也常被称为操作栈，它是一个<code>后入先出（Last In First Out，LIFO）</code>栈。</p><blockquote><p><code>Javac编译器</code>的<strong>数据流分析工作</strong>保证了在方法执行的任何时候，操作数栈的深度都不会超过在<code>max_stacks</code>数据项中设定的最大值。</p></blockquote><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OperandStackShareData.PNG" alt="栈帧之间的数据共享" /><figcaption aria-hidden="true">栈帧之间的数据共享</figcaption></figure><p>概念上，两个不同栈帧作为不同方法的虚拟机栈的元素，是<strong><u>完全相互独立</u></strong>的。但在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现<u>一部分重叠</u>。让<strong>下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起</strong>，这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了。</p><h4 id="动态连接">1.3 动态连接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的<code>动态连接（Dynamic Linking）</code>。</p><h4 id="方法返回地址">1.4 方法返回地址</h4><p>当一个方法开始执行后，只有两种方式退出这个方法：</p><ol type="1"><li>第一种方式是<u><strong>执行引擎遇到任意一个方法返回的字节码指令</strong></u>，这时候可能会有返回值传递给上层的方法调用者，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为<code>“正常调用完成”（Normal Method Invocation Completion）</code>。</li><li>另外一种是在<u><strong>方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理</strong></u>。无论是Java虚拟机内部产生的异常，还是代码中使用<code>athrow</code>字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为<code>“异常调用完成（Abrupt Method Invocation Completion）”</code>。一个方法使用异常完成出口的方式退出，是<strong><u>不会给它的上层调用者提供任何返回值的</u></strong>。</li></ol><p>方法退出之后必须返回到最初方法被调用时的位置，退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p><ul><li>方法正常退出时，<u><strong>主调方法的PC计数器的值就可以作为返回地址</strong></u>，栈帧中很可能会保存这个计数器值；</li><li>方法异常退出时，<u><strong>返回地址要通过异常处理器表来确定</strong></u>，栈帧中就一般不会保存这部分信息。</li></ul><h4 id="附加信息">1.5 附加信息</h4><p>比如与调试、性能收集相关的信息。一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为<code>栈帧信息</code>。</p><h3 id="方法调用">2. 方法调用</h3><p><strong>方法调用并<u>不等同于</u>方法中的代码被执行</strong>，方法调用阶段唯一的任务就是<strong>确定被调用方法的版本</strong>。</p><h4 id="解析">2.1 解析</h4><p>所有方法调用的目标方法在Class文件里面都是一个<strong>常量池中的符号引用</strong>，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：</p><ul><li>方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为<code>解析（Resolution）</code>。</li></ul><blockquote><p>在Java语言中符合<code>“编译期可知，运行期不可变”</code>这个要求的方法，主要有静态方法、私有方法、实例构造器、父类方法，再加上被<code>final</code>修饰的方法（尽管它使用<code>invokevirtual</code>指令调用），这5种方法调用会在<strong>类加载</strong>的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为<code>“非虚方法”（Non-Virtual Method）</code>，其他方法就被称为<code>“虚方法”（Virtual Method）</code>。</p></blockquote><p>解析调用一定是个<code>静态的过程</code>，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用。</p><h4 id="分派">2.2 分派</h4><p><code>分派 （Dispatch）</code>调用可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。</p><h5 id="静态分派">2.2.1 静态分派</h5><p>通过如下代码来定义两个关键概念：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure><ul><li><code>静态类型（Static Type）</code>。“Human”称为变量的<code>“静态类型”（Static Type）</code>，或者叫<code>“外观类型”（Apparent Type）</code>，静态类型的变化仅仅<u>在使用时发生</u>，变量本身的静态类型不会被改变，并且最终的静态类型是<u><strong>在编译期可知的</strong></u>；</li><li><code>实际类型（Actual Type）</code>。“Man”则被称为变量的<code>“实际类型”（Actual Type）</code>或者叫<code>“运行时类型”（Runtime Type）</code>，实际类型变化的结果<u>在运行期才可确定</u>，编译器<strong><u>在编译程序的时候并不知道</u></strong>一个对象的实际类型是什么。</li></ul><p>比如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line">Human human = (<span class="keyword">new</span> Random()).nextBoolean() ? <span class="keyword">new</span> Man() : <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">sr.sayHello((Man) human)</span><br><span class="line">sr.sayHello((Woman) human)</span><br></pre></td></tr></table></figure><ul><li>对象<code>human</code>的实际类型是可变的，到底是Man还是Woman，必须等到程序运行到这行的时候才能确定。</li><li>human的静态类型是Human，也可以在使用时（如<code>sayHello()</code>方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的</li></ul><p>在如下的例子中，使用哪个重载版本的<code>sayHello()</code>方法，完全取决于传入参数的数量和数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,guy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,gentleman!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,lady!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机（或者准确地说是编译器）在重载时是<strong><u>通过参数的静态类型而不是实际类型作为判定依据的</u></strong>，所以在编译阶段，<code>Javac</code>编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了<code>sayHello(Human)</code>作为调用目标。</p><blockquote><p>所有依赖<code>静态类型</code>来决定方法执行版本的分派动作，都称为<code>静态分派</code>。</p></blockquote><p>静态分派的最典型应用表现就是<code>方法重载</code>。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。从下面的示例代码可以看出方法重载中，选择重载版本的匹配优先级：</p><ul><li><p>如果注释掉 <code>sayHello(char arg)</code>方法，会输出：<code>hello int</code>。这时发生了一次自动类型转换，<code>'a'</code>转换为<code>int</code>类型。</p></li><li><p>继续注释掉<code>sayHello(int arg)</code>方法，那输出会变为：<code>hello long</code>。这时发生了两次自动类型转换，<code>'a'</code>转型为整数<code>97</code>之后，进一步转型为长整数<code>97L</code>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello int"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello long"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Serializable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动转型可以依<code>据char&gt;int&gt;long&gt;float&gt;double</code>的顺序转型进行匹配。</li><li>自动装箱为封装类型<code>java.lang.Character</code>，但是自动装箱的封装类型<code>java.lang.Character</code>不会转换为其他封装类型，比如<code>Integer</code>。</li><li>封装类型<code>java.lang.Character</code>只能安全地转型为它实现的接口(如<code>java.lang.Serializable</code>)或父类(如<code>Object</code>)。</li><li>可见变长参数的重载优先级是最低的，这里使用的是<code>char</code>类型的变长参数。</li></ul><h5 id="动态分派">2.2.2 动态分派</h5><p>动态分派与<code>重写（Override）</code>有着密切关联，考虑如下方法的动态分派：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法动态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"woman say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里选择调用的方法版本不可能再根据静态类型来决定的，因为静态类型同样都是<code>Human</code>的两个变量<code>man</code>和<code>woman</code>在调用<code>sayHello()</code>方法时产生了不同的行为。导致这个现象的原因很明显，是因为这两个变量的<code>实际类型</code>不同。</p><p>从子节码看，这两条调用指令无论是指令（都是<code>invokevirtual</code>）还是参数都完全一样，但是这两句指令最终执行的目标方法并不相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span><br><span class="line">20: aload_2</span><br><span class="line">21: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span><br></pre></td></tr></table></figure><p><code>invokevirtual</code>指令的运行时解析过程大致分为以下几步：</p><ol type="1"><li>找到操作数栈顶的第一个元素所指向的对象的<code>实际类型</code>，记作<code>C</code>。</li><li>如果在类型<code>C</code>中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回<code>java.lang.IllegalAccessError</code>异常。</li><li>否则，按照继承关系从下往上依次对<code>C</code>的各个父类进行第二步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li></ol><p><code>invokevirtual</code>指令执行的第一步就是在运行期确定<code>接收者（Receiver）</code>的<code>实际类型</code>，所以两次调用中的 <code>invokevirtual</code>指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。</p><blockquote><p>把这种在运行期根据<code>实际类型</code>确定方法执行版本的分派过程称为<code>动态分派</code>。</p></blockquote><h5 id="单分派与多分派">2.2.3 单分派与多分派</h5><p>方法的<code>接收者</code>与方法的<code>参数</code>统称为方法的<code>宗量</code>，根据分派基于多少种宗量，可以将分派划分为<code>单分派</code>和<code>多分派</code>两种。</p><ul><li><code>单分派</code>是根据一个宗量对目标方法进行选择；</li><li><code>多分派</code>则是根据多于一个宗量对目标方法进行选择。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单分派、多分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先是编译阶段中编译器的选择过程，也就是<code>静态分派</code>的过程。选择目标方法的依据有两点：<ul><li>一是静态类型是Father还是Son；</li><li>二是方法参数是QQ还是360。</li></ul></li><li>选择结果的最终产生了两条<code>invokevirtual</code>指令，两条指令的参数分别为常量池中指向<code>Father::hardChoice(360)</code>及<code>Father::hardChoice(QQ)</code>方法的符号引用。</li></ul><blockquote><p>因为是根据两个宗量进行选择，所以Java语言的<code>静态分派</code>属于<code>多分派</code>类型。</p></blockquote><ul><li>然后是运行阶段中虚拟机的选择，也就是动态分派的过程：<ul><li>执行<code>“son.hardChoice(new QQ())”</code>所对应的<code>invokevirtual</code>指令时，由于编译期已经决定目标方法的签名必须为<code>hardChoice(QQ)</code>，这时候参数的<code>静态类型</code>、<code>实际类型</code>都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有该方法的<code>接受者的实际类型</code>。</li></ul></li></ul><blockquote><p>因为只有一个宗量作为选择依据， 所以Java语言的<code>动态分派</code>属于<code>单分派</code>类型。</p></blockquote><p>如今的Java语言是一门<code>静态多分派</code>、<code>动态单分派</code>的语言。</p><h5 id="虚拟机动态分派的实现">2.3.4 虚拟机动态分派的实现</h5><p>动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的<code>方法元数据</code>中搜索合适的目标方法。基于执行性能的考虑，一种基础而且常见的优化手段是使用<code>虚方法表索引</code>来代替元数据查找以提高性能。</p><ul><li>为类型在方法区中建立一个<code>虚方法表（Virtual Method Table</code>，也称为<code>vtable</code>）</li><li>在<code>invokeinterface</code>执行时也会用到接口方法表（<code>Interface Method Table</code>，简称<code>itable</code>）</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/MethodTable.PNG" alt="方法表结构" /><figcaption aria-hidden="true">方法表结构</figcaption></figure><p>虚方法表中存放着各个方法的<code>实际入口地址</code>。</p><ul><li>如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。</li><li>如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</li></ul><p>具有<code>相同签名</code>的方法，在父类、子类的虚方法表中都应当具有一样的<code>索引序号</code>，当类型变换时仅需要变更查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p><p>虚拟机除了使用虚方法表之外，为了进一步提高性能，还会使用<code>类型继承关系分析（Class Hierarchy Analysis，CHA）</code>、<code>守护内联（Guarded Inlining）</code>、<code>内联缓存（Inline Cache）</code>等多种非稳定的激进优化来争取更大的性能空间。</p><h3 id="动态类型语言支持">3. 动态类型语言支持</h3><p><code>invokedynamic</code>指令是为了实现<code>动态类型语言（Dynamically Typed Language）</code>支持而进行的改进。</p><h4 id="动态类型语言">3.1 动态类型语言</h4><p><code>动态类型语言</code>的<u>关键特征</u>是<strong><u>它的类型检查的主体过程是在运行期而不是编译期进行的</u></strong>。在编译期就进行类型检查过程的语言（譬如C++和Java等）就是<code>静态类型语言</code>。</p><p>动态类型语言与<code>Java</code>有一个核心的差异就是<u><strong>变量本身并没有类型，变量的值才具有类型</strong></u>，所以编译器在编译时最多只能确定<u>方法名称</u>、<u>参数</u>、<u>返回值</u>这些信息，而不会去确定方法所在的具体类型（即方法接收者不固定）。</p><blockquote><p><code>“变量无类型而变量值才有类型”</code>是动态类型语言的一个核心特征。</p></blockquote><h4 id="java与动态类型">3.2 Java与动态类型</h4><p><code>JDK 7</code>以前的字节码指令集中，4条方法调用指令（<code>invokevirtual</code>、<code>invokespecial</code>、<code>invokestatic</code>、 <code>invokeinterface</code>）的第一个参数都是<code>被调用方法的符号引用</code>，方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定方法的接收者。</p><h4 id="java.lang.invoke包">3.3 <code>java.lang.invoke</code>包</h4><p><code>JDK 7</code>时新加入的<code>java.lang.invoke</code>包的主要目的是<u><strong>在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制</strong></u>，称为<code>“方法句柄”（Method Handle）</code>。</p><p>拥有方法句柄之后，Java语言也可以拥有类似于<code>函数指针</code>或者<code>委托</code>的方法别名这样的工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JSR 292 MethodHandle基础用法演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> ClassA();</span><br><span class="line">        <span class="comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。</span></span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">"icyfenix"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和具体参数（methodType()第二个及以后的参数）。</span></span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</span></span><br><span class="line">        <span class="comment">// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情。</span></span><br><span class="line">        <span class="keyword">return</span> lookup().findVirtual(reveiver.getClass(), <span class="string">"println"</span>, mt).bindTo(reveiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getPrintlnMH()</code>方法实际上是模拟了<code>invokevirtual</code>指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个由用户设计的Java方法来实现。而这个方法本身的返回值 <code>（MethodHandle对象）</code>，可以视为对最终调用方法的一个<code>“引用”</code>。</p><p><code>MethodHandle</code>与<code>Reflection</code>的区别：</p><ul><li><code>Reflection</code>和<code>MethodHandle</code>机制本质上都是在<strong>模拟方法调用</strong>，但是<code>Reflection</code>是在<strong>模拟Java代码层次</strong>的方法调用，而<code>MethodHandle</code>是在<strong>模拟字节码层次</strong>的方法调用。</li><li><code>Reflection</code>中的<code>java.lang.reflect.Method</code>比<code>MethodHandle</code>中的 <code>java.lang.invoke.MethodHandle</code>对象所包含的信息多。<ul><li>前者是方法在Java端的全面映像，包含了方法的<u>签名</u>、<u>描述符</u>以及<u>方法属性表中各种属性的Java端表示方式</u>，还包含<u>执行权限等的运行期信息</u>。</li><li>后者仅包含执行该方法的相关信息。<code>Reflection</code>是重量级，而<code>MethodHandle</code> 是轻量级。</li></ul></li><li>理论上<code>MethodHandle</code>上也可以采用虚拟机在字节码层次的各种优化方法 （如方法内联），而通过反射去调用方法则几乎不可能直接去实施各类调用点优化措施。</li><li><code>Reflection API</code>的设计目标是只为Java语言服务的，而<code>MethodHandle</code>则设计为可服务于所有Java虚拟机之上的语言。</li></ul><h4 id="invokedynamic指令">3.4 <code>invokedynamic</code>指令</h4><p><code>invokedynamic</code>指令与<code>MethodHandle</code>机制的作用是一样的，都是把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中。两者的思路也是可类比的，只是一个用<strong>上层代码和API</strong>来实现， 另一个用<strong>字节码和Class中其他属性、常量</strong>来完成。</p><p>每一处含有<code>invokedynamic</code>指令的位置都被称作<code>“动态调用点（Dynamically-Computed Call Site）”</code>，这条指令的第一个参数是<code>JDK 7</code>时新加入的<code>CONSTANT_InvokeDynamic_info</code>常量，从中可以得到3项信息：</p><ul><li><code>引导方法（Bootstrap Method）</code>，该方法存放在新增的<code>BootstrapMethods</code>属性中，有固定的参数，并且返回值规定是<code>java.lang.invoke.CallSite</code>对象，这个对象代表了真正要执行的目标方法调用；</li><li><code>方法类型（MethodType）</code>；</li><li><code>名称</code>。</li></ul><h3 id="基于栈的字节码解释执行引擎">4. 基于栈的字节码解释执行引擎</h3><h4 id="解释执行">4.1 解释执行</h4><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过如下各个步骤</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/compileProcess.PNG" alt="编译过程" /><figcaption aria-hidden="true">编译过程</figcaption></figure><h4 id="基于栈的指令集与基于寄存器的指令集">4.2 基于栈的指令集与基于寄存器的指令集</h4><p><code>基于栈的指令集架构（Instruction Set Architecture，ISA）</code>，字节码指令流里面的指令大部分都是<strong><u>零地址指令</u></strong>，它们依赖操作数栈进行工作。<code>Javac</code>编译器输出的字节码指令流基本上是基于栈的指令集架构。</p><ul><li>主要优点是可移植，因为寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。还有一些其他的优点，如代码相对更加紧凑，编译器实现更加简单。</li><li>主要缺点是理论上执行速度相对来说会稍慢一些。完成相同功能所需的指令数量一般会比寄存器架构来得更多，更重要的是栈实现在内存中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。</li></ul><p><code>基于寄存器的指令集</code>，就是现在我们主流PC机中物理硬件直接支持的指令集架构，这些指令依赖寄存器进行工作。最典型的就是<code>x86</code>的<strong><u>二地址指令集</u></strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;执行引擎是Java虚拟机核心的组成部分之一。
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--7 虚拟机类加载机制</title>
    <link href="https://wuyunjie.top/2021/05/27/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_7_Virtual_machine_class_loading_mechanism.html"/>
    <id>https://wuyunjie.top/2021/05/27/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_7_Virtual_machine_class_loading_mechanism.html</id>
    <published>2021-05-27T05:31:54.000Z</published>
    <updated>2021-05-27T05:31:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>在Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。 <a id="more"></a></p></blockquote><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的<code>类加载机制</code>。</p><h3 id="类加载的时机">1. 类加载的时机</h3><p>一个类型<strong><u>从被加载到虚拟机内存中开始，到卸载出内存为止</u></strong>，它的整个生命周期将会经历七个阶段:</p><ul><li>加载（Loading）</li><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）</li><li>初始化 （Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><p>其中验证、准备、解析三个部分统称为连接（Linking）。</p><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ClassLifeCycle.PNG" alt="类的生命周期" /><figcaption aria-hidden="true">类的生命周期</figcaption></figure><blockquote><p>解析阶在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的<code>运行时绑定</code>特性（也称为<code>动态绑定</code>或<code>晚期绑定</code>）。</p></blockquote><p>只有六种情况必须立即对类进行<code>“初始化”</code>（而加载、验证、准备自然需要在此之前开始）：</p><ul><li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段；</li><li>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化；</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；<ul><li>一个<code>接口</code>在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li></ul></li><li>当虚拟机启动时，用户需要指定一个要执行的<code>主类（包含main()方法的那个类）</code>，虚拟机会先初始化这个主类；</li><li>当使用<code>JDK 7</code>新加入的<code>动态语言支持</code>时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析的方法句柄对应的类没有进行过初始化，则需要先触发其初始化；</li><li>当一个接口中定义了<code>JDK 8</code>新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化；</li></ul><h3 id="类加载的过程">2. 类加载的过程</h3><h4 id="加载">2.1 加载</h4><p><code>“加载”（Loading）</code>阶段是整个<code>“类加载”（Class Loading）</code>过程中的一个阶段，在加载阶段，Java虚拟机需要完成以下三件事情：</p><ol type="1"><li>通过一个类的全限定名来获取定义此类的<code>二进制字节流</code>。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的<code>findClass()</code>或<code>loadClass()</code>方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p><h4 id="验证">2.2 验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是<u>确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</u>。从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节 码验证和符号引用验证。</p><h5 id="文件格式验证">2.2.1 文件格式验证</h5><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p><p>该验证阶段的主要目的是<u><strong>保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。</strong></u>这阶段的验证是<strong>基于二进制字节流进行的</strong>，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储。</p><h5 id="元数据验证">2.2.2 元数据验证</h5><p>对字节码描述的信息进行<code>语义分析</code>，以保证其描述的信息符合《Java语言规范》的要求。</p><h5 id="字节码验证">2.2.3 字节码验证</h5><p>通过<code>数据流分析</code>和<code>控制流分析</code>，确定程序语义是合法的、符合逻辑的。</p><p>这阶段对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。</p><h5 id="符号引用验证">2.2.4 符号引用验证</h5><p>符号引用验证可以看作是<strong><u>对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验</u></strong>，即该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p><p>该校验过程发生在虚拟机<u>将符号引用转化为直接引用</u>的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</p><h4 id="准备">2.3 准备</h4><p>准备阶段是正式<u><strong>为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值</strong></u>的阶段。</p><p>两个容易产生混淆的概念：</p><ul><li>此时进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</li><li>这里所说的初始值“通常情况”下是<code>数据类型的零值</code>。<ul><li>比如对于<code>public static int value = 123;</code>，变量value在准备阶段过后的初始值为0，把 <code>value</code>赋值为<code>123</code>的<code>putstatic</code>指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中，所以把<code>value</code>赋值为<code>123</code>的动作要到<strong>类的初始化阶段</strong>才会被执行。</li><li>如果类字段的字段属性表中存在<code>ConstantValue</code>属性，那在准备阶段变量值就会被初始化为<code>ConstantValue</code>属性所指定的初始值(比如<code>public static final int value = 123;</code>)</li></ul></li></ul><h4 id="解析">2.4 解析</h4><p>解析阶段是Java虚拟机<strong>将常量池内的符号引用替换为直接引用</strong>的过程。</p><ul><li><code>符号引用（Symbolic References）</code>：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的<strong>字面量</strong>，只要使用时能无歧义地定位到目标即可。<ul><li>符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。</li></ul></li><li><code>直接引用（Direct References）</code>：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。<ul><li>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</li><li>如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li></ul></li></ul><p>虚拟机实现可以对第一次解析的结果进行缓存(除<code>invokedynamic</code>指令以外)，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。无论是否真正执行了多次解析动作，Java虚拟机都需要保证的是在同一个实体中：</p><ul><li>如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功；</li><li>如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功加载进Java虚拟机内存之中。</li></ul><p>对于<code>invokedynamic</code>指令，上面的规则就不成立了。当碰到某个前面已经由<code>invokedynamic</code>指令触发过解析的符号引用时，并不意味着这个解析结果对于其他<code>invokedynamic</code>指令也同样生效。</p><ul><li><code>invokedynamic</code>指令的目的本来就是用于动态语言支持，它对应的引用称为<code>“动态调用点限定符 （Dynamically-Computed Call Site Specifier）”</code>，这里<code>“动态”</code>的含义是指<u><strong>必须等到程序实际运行到这条指令时，解析动作才能进行</strong></u>。</li></ul><p>解析动作主要针对<u><strong>类或接口</strong></u>、<u><strong>字段</strong></u>、<u><strong>类方法</strong></u>、<u><strong>接口方法</strong></u>、<u><strong>方法类型</strong></u>、<u><strong>方法句柄</strong></u>和<u><strong>调用点限定符</strong></u>这7类符号引用进行。</p><h5 id="类或接口的解析">2.4.1 类或接口的解析</h5><p>假设当前代码所处的类为<code>D</code>，如果要把一个从未解析过的符号引用<code>N</code>解析为一个类或接口<code>C</code>的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p><ol type="1"><li>如果<code>C</code>不是一个数组类型，那虚拟机将会把代表<code>N</code>的全限定名传递给<code>D</code>的类加载器去加载这个类<code>C</code>。</li><li>如果<code>C</code>是一个数组类型，并且数组的元素类型为对象，也就是<code>N</code>的描述符会是类似“<code>[Ljava/lang/Integer</code>”的形式，那将会按照第一点的规则加载数组元素类型。</li><li>如果上面两步没有出现任何异常，那么<code>C</code>在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认<code>D</code>是否具备对<code>C</code>的访问权限。如果发现不具备访问权限， 将抛出<code>java.lang.IllegalAccessError</code>异常。</li></ol><p>如果我们说一个<code>D</code>拥有<code>C</code>的访问权限，那就意味着以下3条规则中至少有其中一条成立：</p><ul><li>被访问类<code>C</code>是<code>public</code>的，并且与访问类<code>D</code>处于同一个模块。</li><li>被访问类<code>C</code>是<code>public</code>的，不与访问类<code>D</code>处于同一个模块，但是<code>被访问类C</code>的模块允许<code>访问类D</code>的模块进行访问。</li><li>被访问类<code>C</code>不是<code>public</code>的，但是它与访问类<code>D</code>处于同一个包中。</li></ul><h5 id="字段解析">2.4.2 字段解析</h5><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内<code>class_index</code>项中索引的<code>CONSTANT_Class_info</code>符号引用进行解析，也就是<strong><u>字段所属的类或接口的符号引用</u></strong>。</p><p>如果解析成功完成，那把这个字段所属的类或接口用<code>C</code>表示，按照如下步骤对C进行后续字段的搜索：</p><ol type="1"><li>如果<code>C</code>本身就包含了<strong>简单名称</strong>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>如果在<code>C</code>中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口， 如果接口中包含了<strong>简单名称</strong>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>如果<code>C</code>不是<code>java.lang.Object</code>的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了<code>简单名称</code>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li><li>否则，查找失败，抛出<code>java.lang.NoSuchFieldError</code>异常。</li></ol><p>如果查找过程成功返回了引用，将会对这个字段进行权限验证。</p><h5 id="方法解析">2.4.3 方法解析</h5><p>方法解析的第一个步骤也是需要先解析出方法表的<code>class_index</code>项中索引的方法所属的类或接口的符号引用，如果解析成功，那么依然用<code>C</code>表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：</p><ol type="1"><li>由于Class文件格式中<strong><u>类的方法和接口的方法符号引用的常量类型定义是分开的</u></strong>，如果在类的方法表中发现<code>class_index</code>中索引的<code>C</code>是个接口的话，那就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li><li>在类<code>C</code>中查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>在类<code>C</code>的父类中递归查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>在类<code>C</code>实现的接口列表及它们的父接口之中递归查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果存在匹配的方法，说明类<code>C</code>是一个抽象类，这时候查找结束，抛出<code>java.lang.AbstractMethodError</code>异常。</li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>。</li></ol><p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证。</p><h5 id="接口方法解析">2.4.4 接口方法解析</h5><p>接口方法也是需要先解析出接口方法表的<code>class_index</code>项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用<code>C</code>表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p><ol type="1"><li>与类的方法解析相反，如果在接口方法表中发现<code>class_index</code>中的索引<code>C</code>是个类而不是接口，那么就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li><li>在接口<code>C</code>中查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li><li>在接口<code>C</code>的父接口中递归查找，直到<code>java.lang.Object</code>类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。<ul><li>由于Java的<u>接口允许多重继承</u>，如果C的不同父接口中存有<u>多个</u><strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，不同发行商实现的<code>Javac</code>编译器有可能会按照<u><strong>更严格的约束拒绝编译这种代码来避免不确定性</strong></u>。</li></ul></li><li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</li></ol><blockquote><ul><li>在<code>JDK 9</code>之前，Java接口中的所有方法都<u>默认是<code>public</code>的</u>，也没有模块化的访问约束，所以不存在访问权限的问题。</li><li>但在<code>JDK 9</code>中增加了<u>接口的静态私有方法</u>，也有了模块化的访问约束，所以接口方法的访问也完全有可能因访问权限控制而出现<code>java.lang.IllegalAccessError</code>异常。</li></ul></blockquote><h4 id="初始化">2.5 初始化</h4><blockquote><p>直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p></blockquote><p>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><blockquote><p><code>&lt;clinit&gt;()</code>并不是程序员在Java代码中直接编写的方法，它是<code>Javac</code>编译器的自动生成物。</p></blockquote><p><code>&lt;clinit&gt;()</code>方法是由编译器<u>自动收集</u>类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块（static{}块）中的语句</strong>合并产生的。</p><ul><li><code>&lt;clinit&gt;()</code>方法不需要显式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。意味着父类中定义的静态语句块要优先于子类的变量赋值操作；</li><li><code>&lt;clinit&gt;()</code>方法不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法</li><li>执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，接口的<strong><u>实现类</u></strong>在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法；</li><li>Java虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法方法在多线程环境中被正确地加锁同步。</li><li>同一个类加载器下，一个类型只会被初始化一次。</li></ul><h3 id="类加载器">3. 类加载器</h3><p>实现<code>“通过一个类的全限定名来获取描述该类的二进制字节流”</code>这个动作的代码被称为<code>“类加载器”（Class Loader）</code>。</p><h4 id="类与类加载器">3.1 类与类加载器</h4><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的<strong><u>唯一性</u></strong>，每一个类加载器都拥有一个独立的类名称空间。</p><blockquote><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，只要加载它们的类加载器不同，那这两个类就<strong>必定不相等</strong>。</p></blockquote><h4 id="双亲委派模型">3.2 双亲委派模型</h4><p>Java虚拟机的角度来看，只存在两种不同的类加载器：</p><ul><li><code>启动类加载器（Bootstrap ClassLoader）</code>，这个类加载器是虚拟机自身的一部分；</li><li>其他所有的类加载器，这些类加载器都由Java语言实现，<strong><u>独立存在于虚拟机外部</u></strong>，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。</li></ul><p>Java开发人员的角度来看，类加载器是<code>三层类加载器</code>、<code>双亲委派</code>的类加载架构：</p><ul><li><code>启动类加载器（Bootstrap Class Loader）</code>：负责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用；</li><li><code>扩展类加载器（Extension Class Loader）</code>：负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库。这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoader</code>中以Java代码的形式实现的。</li><li><code>应用程序类加载器（Application Class Loader）</code>：负责加载用户类路径<code>（ClassPath）</code>上所有的类库，由 <code>sun.misc.Launcher$AppClassLoader</code>来实现。</li></ul><p><u><code>JDK 9</code>之前</u>的Java应用都是由这三种类加载器互相配合来完成加载的，用户可以加入自定义的类加载器来进行拓展，如：</p><ul><li>增加除了磁盘位置之外的Class文件来源</li><li>通过类加载器实现类的隔离、重载等功能。</li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ParentsDelegation.PNG" alt="双亲委派模型" /><figcaption aria-hidden="true">双亲委派模型</figcaption></figure><p><code>“双亲委派模型（Parents Delegation Model）”</code>要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p><blockquote><p>类加载器之间的父子关系一般不是以<code>继承（Inheritance）</code>来实现的，而是通常使用<code>组合（Composition）</code>关系来复用父加载器的代码。</p></blockquote><p>双亲委派模型的工作过程是：</p><ul><li>如果一个类加载器收到了类加载的请求，首先把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中；</li><li>只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</li></ul><h4 id="破坏双亲委派模型">3.3 破坏双亲委派模型</h4><p>直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况：</p><ul><li>第一次“被破坏”其实发生在双亲委派模型出现之前——即<code>JDK 1.2</code>面世以前。</li><li>第二次“被破坏”是由这个模型自身的缺陷导致的，有基础类型要调用回用户的代码。</li><li>第三次“被破坏”是由于用户对程序动态性的追求而导致的。</li></ul><p><code>OSGi</code>实现模块化热部署的关键是<u><strong>它自定义的类加载器机制的实现</strong></u>：</p><ul><li>每一个程序模块（<code>OSGi</code>中称为<code>Bundle</code>）都有一个自己的类加载器，当需要更换一个<code>Bundle</code>时，就把<code>Bundle</code>连同类加载器一起换掉以实现代码的热替换。</li></ul><p>在<code>OSGi</code>环境下，类加载器发展为更加复杂的网状结构，当收到类加载请求时，<code>OSGi</code>将按照下面的顺序进行类搜索：</p><ol type="1"><li>将以<code>java.*</code>开头的类，委派给父类加载器加载。</li><li>否则，将委派列表名单内的类，委派给父类加载器加载。</li><li>否则，将<code>Import</code>列表中的类，委派给<code>Export</code>这个类的<code>Bundle</code>的类加载器加载。</li><li>否则，查找当前<code>Bundle</code>的<code>ClassPath</code>，使用自己的类加载器加载。</li><li>否则，查找类是否在自己的<code>Fragment Bundle</code>中，如果在，则委派给<code>Fragment Bundle</code>的类加载器加载。</li><li>否则，查找<code>Dynamic Import</code>列表的<code>Bundle</code>，委派给对应<code>Bundle</code>的类加载器加载。</li><li>否则，类查找失败。</li></ol><h3 id="java模块化系统">4. Java模块化系统</h3><p><code>JDK 9</code>中引入的<code>Java模块化系统（Java Platform Module System，JPMS）</code>能够实现模块化的关键目标——可配置的封装隔离机制。<code>JDK 9</code>的模块除了简单地充当代码的容器，还包含以下内容：</p><ul><li>依赖其他模块的列表。</li><li>导出的包列表，即其他模块可以使用的列表。</li><li>开放的包列表，即其他模块可反射访问模块的列表。</li><li>使用的服务列表。</li><li>提供服务的实现列表。</li></ul><p><u><strong>可配置的封装隔离机制</strong></u>解决了：</p><ul><li><code>JDK 9</code>之前基于<code>类路径（ClassPath）</code>来查找依赖的<strong>可靠性问题</strong>。</li><li>原来类路径上跨<code>JAR</code>文件的<code>public</code>类型的<strong>可访问性问题</strong>。</li></ul><h4 id="模块的兼容性">4.1 模块的兼容性</h4><p><code>JDK 9</code>提出了与<code>“类路径”（ClassPath）</code>相对应的<code>“模块路径”（ModulePath）</code>的概念，使<u><strong>可配置的封装隔离机制</strong></u>能够兼容传统的类路径查找机制。</p><p>模块化系统将按照以下规则来保证使用传统类路径依赖的Java程序可以不经修改地直接运行在<code>JDK 9</code>及以后的Java版本上：</p><ul><li><strong>JAR文件在类路径的访问规则</strong>：所有类路径下的<code>JAR</code>文件及其他资源文件，都被视为自动打包在一个<code>匿名模块（Unnamed Module）</code>里，这个匿名模块<strong>几乎是没有任何隔离的</strong>，它可以看到和使用<u>类路径上所有的包</u>、<u>JDK系统模块中所有的导出包</u>，以及<u>模块路径上所有模块中导出的包</u>。</li><li><strong>模块在模块路径的访问规则</strong>：模块路径下的<code>具名模块（Named Module）</code>只能访问到它<u>依赖定义中列明依赖的模块和包</u>，匿名模块里所有的内容对具名模块来说都是不可见的，即<strong><u>具名模块看不见传统JAR包的内容</u></strong>。</li><li><strong>JAR文件在模块路径的访问规则</strong>：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个<code>自动模块（Automatic Module）</code>。尽管不包含<code>module-info.class</code>，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到<u>所有模块导出的</u>包，自动模块也<strong>默认导出自己所有的包</strong>。</li></ul><h4 id="模块化下的类加载器">4.2 模块化下的类加载器</h4><p><code>JDK 9</code>为了模块化系统的顺利施行，模块化下的类加载器发生了一些变动，主要包括以下几个方面：</p><ul><li><code>扩展类加载器（Extension Class Loader）</code>被<code>平台类加载器（Platform Class Loader）</code>取代。</li><li><code>平台类加载器</code>和<code>应用程序类加载器</code>都不再派生自<code>java.net.URLClassLoader</code>，现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 <code>jdk.internal.loader.BuiltinClassLoader</code>。<code>BuiltinClassLoader</code>中实现了新的模块化架构下<u>类如何从模块中加载的逻辑</u>，以及<u>模块中资源可访问性的处理</u>。</li><li><code>JDK 9</code>中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。<ul><li>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类<u>是否能够归属到某一个系统模块中</u>，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JDK9ClassLoaderDelegation.PNG" alt="JDK 9后的类加载器委派关系" /><figcaption aria-hidden="true">JDK 9后的类加载器委派关系</figcaption></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。
    
    </summary>
    
      <category term="JVM" scheme="https://wuyunjie.top/categories/JVM/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://wuyunjie.top/tags/JVM/"/>
    
  </entry>
  
</feed>
