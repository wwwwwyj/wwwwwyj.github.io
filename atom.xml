<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuYJ&#39;s Blog</title>
  
  <subtitle>wuyunjie的小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuyunjie.top/"/>
  <updated>2021-07-25T14:51:16.000Z</updated>
  <id>https://wuyunjie.top/</id>
  
  <author>
    <name>wuyunjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[数据结构和算法|求素数的方法]</title>
    <link href="https://wuyunjie.top/2021/07/25/Data_structure_and_algorithm_prime.html"/>
    <id>https://wuyunjie.top/2021/07/25/Data_structure_and_algorithm_prime.html</id>
    <published>2021-07-25T14:51:16.000Z</published>
    <updated>2021-07-25T14:51:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题介绍">1. 问题介绍</h3><p>求素数（质数）问题很普遍，问题很简单就是求小于某个数的素数。目前看还没有特别优化的方法，基本上都是打表，主要是在优化打表过程。这里总结一下目前求解素数的一些方法。</p><a id="more"></a><h3 id="题解">2. 题解</h3><h4 id="leetcode-204.-计数质数">2.1 leetcode-204. 计数质数</h4><blockquote><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p></blockquote><h5 id="枚举">2.1.1 枚举</h5><p>很直观的思路是枚举每个数判断其是不是质数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += isPrime(i) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度过大，为<span class="math inline">\(O(n\sqrt{n})\)</span>。</p><h5 id="埃氏筛">2.1.2 埃氏筛</h5><p>由希腊数学家厄拉多塞（<code>Eratosthenes</code>）提出，称为厄拉多塞筛法，简称埃氏筛。</p><blockquote><p>如果 <code>x</code> 是质数，那么大于 <code>x</code> 的 <code>x</code> 的倍数 <span class="math inline">\(2x,3x,\ldots\)</span> 一定不是质数。</p></blockquote><p>对于一个质数 <code>x</code>，直接从 <span class="math inline">\(x\cdot x\)</span> 开始标记，因为 <span class="math inline">\(2x,3x,\ldots\)</span> 这些数一定在 <span class="math inline">\(x\)</span>之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span>) i * i &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线性筛">2.1.3 线性筛</h5><p>埃氏筛还是存在冗余的标记操作，比如对于 45 这个数，它会同时被 3,5 两个数标记为合数。</p><p>线性筛需要多维护一个 <span class="math inline">\(\textit{primes}\)</span> 数组表示当前得到的质数集合。「标记过程」不再仅当 <span class="math inline">\(x\)</span> 为质数时才进行，而是对每个整数 <span class="math inline">\(x\)</span> 都进行。对于整数 <span class="math inline">\(x\)</span>，不再标记其所有的倍数 <span class="math inline">\(x\cdot x,x\cdot (x+1),\ldots\)</span>，而是只标记质数集合中的数与 <span class="math inline">\(x\)</span> 相乘的数，即 <span class="math inline">\(x\cdot\textit{primes}_0,x\cdot\textit{primes}_1,\ldots\)</span>且，在发现 <span class="math inline">\(x \bmod \textit{primes}_i=0\)</span> 的时候结束当前标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                primes.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.size() &amp;&amp; i * primes.get(j) &lt; n; ++j) &#123;</span><br><span class="line">                isPrime[i * primes.get(j)] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % primes.get(j) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="奇数筛">2.1.4 奇数筛</h5><p>主要用两条规则来优化埃氏筛：</p><ul><li><code>质数</code>一定是<code>奇数</code>，<code>偶数</code>一定不是<code>质数</code>。只用在<code>奇数</code>范围标记<code>合数</code>，未标记是<code>质数</code></li><li><code>奇数</code> 乘以 <code>偶数</code> 一定是 <code>偶数</code>。只用<code>奇数</code> 乘以 <code>奇数</code>，确保在<code>奇数</code>范围内标记</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] isCom = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> b = (<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">    <span class="keyword">int</span> r = n &gt; <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCom[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= b) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; i * j &lt; n; j += <span class="number">2</span>) &#123;</span><br><span class="line">                    isCom[i*j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方法更适合用于统计，不适合用于打表，因为尤其是在偶数域上，没有标记。</p><blockquote><p>不过换个思路，可以直接遍历奇数，找出奇数中的所有质数就可以得到所有质数了。只需要注意使用这个表时特殊处理就可以了。</p></blockquote><h3 id="参考文献">参考文献</h3><ol type="1"><li><a href="https://leetcode-cn.com/problems/count-primes/solution/ji-shu-zhi-shu-by-leetcode-solution/" target="_blank" rel="noopener">计数质数-leetcode</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题介绍&quot;&gt;1. 问题介绍&lt;/h3&gt;
&lt;p&gt;求素数（质数）问题很普遍，问题很简单就是求小于某个数的素数。目前看还没有特别优化的方法，基本上都是打表，主要是在优化打表过程。这里总结一下目前求解素数的一些方法。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="https://wuyunjie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="素数" scheme="https://wuyunjie.top/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|求最长的XXX]</title>
    <link href="https://wuyunjie.top/2021/07/25/Data_structure_and_algorithm_longest_xxx.html"/>
    <id>https://wuyunjie.top/2021/07/25/Data_structure_and_algorithm_longest_xxx.html</id>
    <published>2021-07-25T11:57:33.000Z</published>
    <updated>2021-07-25T11:57:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>经常遇见一类问题，求最长字串，最长递增序列等等，大部分求解的思路都类型，可以用动态规划求解。但遇到一些变种后，问题常常变得很困难，这里对这类问题进行一个归纳。</p><a id="more"></a><h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.  题解"></a>2.  题解</h3><h4 id="2-1-leetcode-1027-最长等差数列"><a href="#2-1-leetcode-1027-最长等差数列" class="headerlink" title="2.1 leetcode-1027. 最长等差数列"></a>2.1 leetcode-1027. 最长等差数列</h4><blockquote><p>给定一个整数数组 <code>A</code>，返回 <code>A</code> 中最长等差子序列的长度。</p><p>回想一下，<code>A</code> 的子序列是列表 <code>A[i_1], A[i_2], ..., A[i_k]</code> 其中 <code>0 &lt;= i_1 &lt; i_2 &lt; ... &lt; i_k &lt;= A.length - 1</code>。并且如果 <code>B[i+1] - B[i]( 0 &lt;= i &lt; B.length - 1)</code> 的值都相同，那么序列 <code>B</code> 是等差的。</p></blockquote><p>可以用<code>dp[i][diff]</code>表示以第<code>i</code>个数为结尾，以<code>diff</code>为差值的最长子序列长度，那么可以写出其状态转移方程：</p><script type="math/tex; mode=display">dp[i][diff] =\begin{cases}    \operatorname{max}(dp[i][diff], dp[j][diff] + 1) &, dp[i-1][diff] > 0 \\     \operatorname{max}(dp[i][diff], 2) &, else \\ \end{cases}\\ 1 \leq j < i</script><p>即当要加入第<code>i</code>个元素时，考虑将其与之前第<code>j</code>个元素构成一个等差数列的子序列，此时有两种情况：</p><ul><li><p>之前以 <code>diff = nums[i] - nums[j]</code>组成的最长数列长度为<code>dp[j][diff]</code>（大于<code>0</code>），加入第<code>i</code>个数后，序列长度加<code>1</code>；</p></li><li><p>之前不存在以 <code>diff = nums[i] - nums[j]</code>组成的数列，则当前两个数组成新序列，此时最大长度为<code>2</code>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLen = nums.length, longest = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[numsLen][<span class="number">20002</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span> ; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> diff = nums[j] - nums[i] + <span class="number">10000</span>;</span><br><span class="line">                dp[i][diff] = Math.max(dp[i][diff], dp[j][diff] == <span class="number">0</span> ? <span class="number">2</span> : dp[j][diff] + <span class="number">1</span>);</span><br><span class="line">                longest = Math.max(longest, dp[i][diff]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-墨奇科技笔试-最长的连续的等差子数组的长度"><a href="#2-2-墨奇科技笔试-最长的连续的等差子数组的长度" class="headerlink" title="2.2 墨奇科技笔试-最长的连续的等差子数组的长度"></a>2.2 墨奇科技笔试-最长的连续的等差子数组的长度</h4><blockquote><p>有一个整数数组，允许替换一个数字，返回替换后数组中最长的连续的等差子数组的长度。例如将8 5 2 0替换为8 5 2 -1，返回4。</p></blockquote><p>应该也可以用动态规划解决，而且是连续的子序列，应该状态不会太多。初步想法是，需要设置的状态有两个，一个是当前是否修改过数组，另一个是需要处理子序列长度为<code>3</code>时修改的方式：</p><ul><li>修改第一个节点使得符合之后的序列；</li><li>修改最后一个节点使得符合之前的序列。</li></ul><p>但这样会使得状态更新变得很复杂。使用了同学介绍的快慢指针方法，先固定一个点，遍历从这个点开始往后走可以到达的最大长度，记录下最值。为了解决上面存在两种修改方式的问题，使用了正反两遍的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSub</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">2</span>, last = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = nums[i] - nums[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (diff == last) <span class="keyword">continue</span>; <span class="comment">// 减枝</span></span><br><span class="line">        <span class="keyword">else</span> last = diff;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] - nums[j-<span class="number">1</span>] == diff) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> oldValue = nums[j];</span><br><span class="line">            <span class="keyword">int</span> oldIndex = j;</span><br><span class="line"></span><br><span class="line">            nums[j] = nums[j-<span class="number">1</span>] + diff;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] - nums[j-<span class="number">1</span>] == diff) j++;</span><br><span class="line">            nums[oldIndex] = oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        longest = Math.max(longest, j - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = nums[i] - nums[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (diff == last) <span class="keyword">continue</span>; <span class="comment">// 减枝</span></span><br><span class="line">        <span class="keyword">else</span> last = diff;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] - nums[j+<span class="number">1</span>] == diff) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> oldValue = nums[j];</span><br><span class="line">            <span class="keyword">int</span> oldIndex = j;</span><br><span class="line"></span><br><span class="line">            nums[j] = nums[j+<span class="number">1</span>] + diff;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] - nums[j+<span class="number">1</span>] == diff) j--;</span><br><span class="line">            nums[oldIndex] = oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        longest = Math.max(longest, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管例子都过了，但提交的时候没过，也没找到问题在哪。</p><h4 id="2-3-leetcode-674-最长连续递增序列"><a href="#2-3-leetcode-674-最长连续递增序列" class="headerlink" title="2.3 leetcode-674. 最长连续递增序列"></a>2.3 leetcode-674. 最长连续递增序列</h4><blockquote><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p></blockquote><p>这个题很简答，用动态规划解决的经典问题，而且由于要求是连续的，降低了问题的难度。用<code>dp[i]</code>表示以第<code>i</code>个元素结尾的最长递增子序列长度，转移方程可以表示为：</p><script type="math/tex; mode=display">dp[i] =\begin{cases}    dp[i-1] + 1 &, nums[i] > nums[i-1] \\     1 &, else \\ \end{cases}</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            pre = nums[i] &gt; nums[i-<span class="number">1</span>] ? pre + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            maxLen = Math.max(pre, maxLen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-leetcode-718-最长重复子数组"><a href="#2-4-leetcode-718-最长重复子数组" class="headerlink" title="2.4 leetcode-718. 最长重复子数组"></a>2.4 leetcode-718. 最长重复子数组</h4><blockquote><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p></blockquote><p>最长字串问题，用<code>dp[i][j]</code>表示以<code>A</code>的第<code>i</code>个字符串结尾和<code>B</code>的第<code>j</code>个字符串结尾的最长子串长度，可以得到转移方程：</p><script type="math/tex; mode=display">dp[i+1][j+1] =\begin{cases}    dp[i][j] + 1 &, nums1[i] == nums2[j] \\     0 &, else \\ \end{cases}</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j++) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = nums1[i] == nums2[j]? dp[i][j] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                longest = Math.max(longest, dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-leetcode-1218-最长定差子序列"><a href="#2-5-leetcode-1218-最长定差子序列" class="headerlink" title="2.5 leetcode-1218. 最长定差子序列"></a>2.5 leetcode-1218. 最长定差子序列</h4><blockquote><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>difference</code>，请你找出并返回 <code>arr</code> 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 <code>difference</code> 。</p><p>子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 <code>arr</code> 派生出来的序列。</p></blockquote><p>一开始想用<code>dp[i]</code>表示以第<code>i</code>个数结尾的最长子序列，但难以找到<code>nums[i]-difference</code>这个数的位置或者是否存在，想到了之前遇到的类似用空间换时间的方法，因为是有序的所以直接存储<code>dp[nums[i]]</code>作为以当前这个数结尾的符合定差的子序列长度，状态转移方程为：</p><script type="math/tex; mode=display">dp[nums[i]] = dp[nums[i]-difference]</script><p>实际上也可以用<code>HashMap</code>来实现这个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">400004</span>];</span><br><span class="line">        <span class="keyword">if</span>(difference!=<span class="number">0</span>) Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = arr[i] + <span class="number">20000</span>;</span><br><span class="line">            dp[cur + difference] = dp[cur] + <span class="number">1</span>;</span><br><span class="line">            longest = Math.max(longest, dp[cur]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = map.getOrDefault(arr[i] - difference, <span class="number">0</span> ) + <span class="number">1</span>;</span><br><span class="line">            map.put(arr[i], curLen);</span><br><span class="line"></span><br><span class="line">            longest = Math.max(longest, curLen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-leetcode-300-最长递增子序列"><a href="#2-6-leetcode-300-最长递增子序列" class="headerlink" title="2.6 leetcode-300. 最长递增子序列"></a>2.6 leetcode-300. 最长递增子序列</h4><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p></blockquote><p>用<code>dp[i]</code>表示以第<code>i</code>个元素结尾得到的最长递增子序列，与连续递增子序列类似，状态转移方程相同。不同的是，需要遍历第<code>i</code>个元素之前的所有数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, longest = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                longest = Math.max(dp[i], longest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-leetcode-1143-最长公共子序列"><a href="#2-7-leetcode-1143-最长公共子序列" class="headerlink" title="2.7 leetcode-1143. 最长公共子序列"></a>2.7 leetcode-1143. 最长公共子序列</h4><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</li></ul><p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p></blockquote><p>最长字串问题，用<code>dp[i][j]</code>表示以<code>A</code>的第<code>i</code>个字符串结尾和<code>B</code>的第<code>j</code>个字符串结尾的最长子串长度，转移方程与连续子串类似。唯一不同是需要遍历所有<code>i</code>和<code>j</code>的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h3&gt;&lt;p&gt;经常遇见一类问题，求最长字串，最长递增序列等等，大部分求解的思路都类型，可以用动态规划求解。但遇到一些变种后，问题常常变得很困难，这里对这类问题进行一个归纳。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="https://wuyunjie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最值问题" scheme="https://wuyunjie.top/tags/%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|贪心算法]</title>
    <link href="https://wuyunjie.top/2021/07/24/null.html"/>
    <id>https://wuyunjie.top/2021/07/24/null.html</id>
    <published>2021-07-23T16:04:49.000Z</published>
    <updated>2021-07-23T16:04:49.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|并查集]</title>
    <link href="https://wuyunjie.top/2021/07/23/Data_structure_and_algorithm_union-find.html"/>
    <id>https://wuyunjie.top/2021/07/23/Data_structure_and_algorithm_union-find.html</id>
    <published>2021-07-23T07:05:20.000Z</published>
    <updated>2021-07-23T07:05:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-并查集介绍"><a href="#1-并查集介绍" class="headerlink" title="1. 并查集介绍"></a>1. 并查集介绍</h3><p>并查集（UnionFindSet）主要用于解决动态连通性问题，判断一个图中两个点是否连同。开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间反复查找一个元素在哪个集合中。</p><a id="more"></a><p>并查集顾名思义就是有<code>“合并集合”</code>和<code>“查找集合中的元素”</code>两种操作的关于数据结构的一种算法，它的名字中<code>“并”</code>、<code>“査”</code>、<code>“集”</code>分别取自<code>Union</code>(合并)、<code>Find</code>(査找)、<code>Set</code>(集合)这3个单词。</p><h4 id="1-1-并查集的数据结构"><a href="#1-1-并查集的数据结构" class="headerlink" title="1.1 并查集的数据结构"></a>1.1 并查集的数据结构</h4><p>并查集在使用中以<strong><u>森林</u></strong>来表示，维护一个数组<code>father[]</code>记录每个结点<code>x</code>的父亲结点<code>father[x]</code>。</p><p>初始状态将每个节点看作一棵只有一个节点的数，此时每个节点的父节点都指向它本身，即<code>father[x] = x</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] findSet = <span class="keyword">null</span>; <span class="comment">// 即father</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    findSet = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后通过不断加入边，更新<code>father[]</code>数组将多棵树合并。如下图是一个森林的<code>father</code>数组：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/algorithm/UnionFind.png" alt="并查集森林"></p><h4 id="1-2-并查集的查找"><a href="#1-2-并查集的查找" class="headerlink" title="1.2 并查集的查找"></a>1.2 并查集的查找</h4><p>查找元素<code>x</code>所在的集合，即找到<code>x</code>的根节点的标号。同一个集合中<u>只存在一个根结点</u>，因此查找操作就是对给定的结点寻找其根结点的过程。查找方法是：通过反复寻找父亲结点，直到找到根结点(即<code>father[x]=x</code>的结点)。比如要查找节点<code>4</code>的根节点，流程如下：</p><ul><li>x=4，father[x] = 2，不是根节点(4 != father[4])，继续查找；</li><li>x=2，father[x] = 1，不是根节点，继续查找；</li><li>x=1，father[x] = 1，满足根节点条件，返回根节点<code>1</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == findSet[cur]) <span class="keyword">return</span> cur;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findSet[cur];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-并查集的合并"><a href="#1-3-并查集的合并" class="headerlink" title="1.3 并查集的合并"></a>1.3 并查集的合并</h4><p>合并是指把两个集合合并成一个集合，通过两个元素<code>x</code>，<code>y</code>，把这两个元素所在的集合合并<code>Union(x, y)</code>。合并过程只需要把其中一个集合的根结点设置为另一个集合根结点的孩子即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    xRoot = Find(x);</span><br><span class="line">    yRoot = Find(y);</span><br><span class="line">    <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">        findSet[xRoot] = yRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-路径压缩"><a href="#1-4-路径压缩" class="headerlink" title="1.4 路径压缩"></a>1.4 路径压缩</h4><p>在并查集查找中，查找元素<code>x</code>所在的集合的运算次数=元素<code>x</code>所在的深度。极端情况下，如果整棵树构造成了一个链，元素过多时深度会过深，时间复杂度过大。这里需要对森林中的树进行优化。</p><p>可以发现最优化的时候，即每棵树中非根节点都刚好指向跟节点，此时每个孩子节点的深度都为<code>2</code>。复杂度从<code>O(n)</code>降为了<code>O(1)</code>。</p><p>该优化过程可以在查找过程中实现，查找到跟节点后，同步更新当前节点的根节点，这个过程即<strong><u>路径压缩</u></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == findSet[cur]) <span class="keyword">return</span> cur;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        findSet[cur] = Find(findSet[cur]);  <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> findSet[cur];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，在合并过程中也可以进行优化，尽量降低树的深度。每次合并中，将深度较小的树作为另一棵树的子树，这时需要一个额外的数组<code>rank</code>来记录当前各树的深度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加权 Quick Union</span></span><br><span class="line"><span class="comment">// 合并x和y所在的集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x); <span class="comment">//找到x所在的集合，即x的根节点</span></span><br><span class="line">    <span class="keyword">int</span> fy = find(y); <span class="comment">//找到y所在集合，即y的根节点</span></span><br><span class="line">    <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rank[fx] &gt; rank[fy]) &#123; <span class="comment">// y 所在的树深度较小，y 合并到 x</span></span><br><span class="line">        father[fy] = fx;</span><br><span class="line">        <span class="keyword">if</span>(rank[fy]+<span class="number">1</span>&gt;rank[fx]) &#123; <span class="comment">//如果挂上fy之后深度增加</span></span><br><span class="line">            rank[fx]=rank[fy]+<span class="number">1</span>; <span class="comment">//这里的秩为深度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;           </span><br><span class="line">        father[fx] = fy;</span><br><span class="line">        <span class="keyword">if</span>(rank[fx]+<span class="number">1</span>&gt;rank[fy]) rank[fy]=rank[fx]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-并查集模板"><a href="#1-5-并查集模板" class="headerlink" title="1.5 并查集模板"></a>1.5 并查集模板</h4><p>一般并查集都比较模板化，实现都差不多，直接并查集模板如下，这里没有用<code>加权 Quick Union</code>，简化模板。太复杂的记不住。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] findSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        findSet = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            findSet[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == findSet[cur]) <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            findSet[cur] = Find(findSet[cur]);</span><br><span class="line">            <span class="keyword">return</span> findSet[cur];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xRoot = Find(x);</span><br><span class="line">        <span class="keyword">int</span> yRoot = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">            findSet[xRoot] = yRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Find(x) == Find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2. 题解"></a>2. 题解</h3><h4 id="2-1-leetcode-1202-交换字符串中的元素"><a href="#2-1-leetcode-1202-交换字符串中的元素" class="headerlink" title="2.1 leetcode-1202. 交换字符串中的元素"></a>2.1 leetcode-1202. 交换字符串中的元素</h4><blockquote><p>给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。</p><p>你可以 任意多次交换 在 pairs 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。</p></blockquote><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]</span><br><span class="line">输出：&quot;bacd&quot;</span><br><span class="line">解释： </span><br><span class="line">交换 s[0] 和 s[3], s = &quot;bcad&quot;</span><br><span class="line">交换 s[1] 和 s[2], s = &quot;bacd&quot;</span><br></pre></td></tr></table></figure><p>由于可以交换任意次数，所以存在情况 <code>pairs = [[0, 1], [1, 2]]</code>，这时候<code>0, 1, 2</code>位置上的元素可以任意交换，所以可以看出他们形成了一个集合。可以将其转化为一个图论的问题，需要找出同属于一个连通分量的所有字符，然后把「连在一起」的索引按照字符的 <code>ASCII</code> 值升序排序，可以使用并查集来寻找这些连通分量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] father;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            father = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                father[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (father[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">            father[x] = Find(father[x]);</span><br><span class="line">            <span class="keyword">return</span> father[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> xRoot = Find(x);</span><br><span class="line">            <span class="keyword">int</span> yRoot = Find(y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">                father[xRoot] = yRoot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">smallestStringWithSwaps</span><span class="params">(String s, List&lt;List&lt;Integer&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span> || pairs.size() == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        UnionFind pairUF = <span class="keyword">new</span> UnionFind(sLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; pair : pairs) &#123;</span><br><span class="line">            pairUF.Union(pair.get(<span class="number">0</span>), pair.get(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于每个并查集中的集合, 用优先队列存储字符, 使得字符有序</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        Map&lt;Integer, PriorityQueue&lt;Character&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> root = pairUF.Find(i);</span><br><span class="line">             map.computeIfAbsent(root, key -&gt; <span class="keyword">new</span> PriorityQueue&lt;&gt;()).offer(charArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于每个位置的字符, 用其对应的优先队列中的最小字符替换</span></span><br><span class="line">        StringBuilder newStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> root = pairUF.Find(i);</span><br><span class="line">            newStr.append( map.get(root).poll() );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newStr.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-leetcode-399-除法求值"><a href="#2-2-leetcode-399-除法求值" class="headerlink" title="2.2 leetcode-399. 除法求值"></a>2.2 leetcode-399. 除法求值</h4><blockquote><p>给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p><p>另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。</p><p>注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p></blockquote><p><strong>变量之间的倍数关系具有传递性</strong>，处理有传递性关系的问题，可以使用「并查集」。分析示例 1：</p><ul><li>$a / b = 2.0$ 说明 $a = 2b$， $a$ 和 $b$ 在同一个集合中；</li></ul><ul><li>$b / c = 3.0$​ 说明 $b = 3c$​ ，$b$ 和 $c$ 在同一个集合中。</li></ul><ul><li><p>求 $\cfrac{a}{c}$，可以把 $a = 2b$，$b = 3c$ 依次代入，得到 $\cfrac{a}{c} = \cfrac{2b} {c} = \cfrac{2 \cdot 3c} {c} = 6.0$；</p></li><li><p>求 $\cfrac{b}{a}$，可以把 $b$ 和 $a$ 都转换成为 $c$ 的倍数，$\cfrac{b}{a} = \cfrac{b} {2b} = \cfrac{3c} {6c} = \cfrac{1}{2} = 0.5$</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = equations.size();</span><br><span class="line"></span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(len*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++ ) &#123;</span><br><span class="line">            List&lt;String&gt; cur = equations.get(i);</span><br><span class="line">            uf.union(cur.get(<span class="number">0</span>), cur.get(<span class="number">1</span>), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> queriesSize = queries.size();</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queriesSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queriesSize; i++) &#123;</span><br><span class="line">            String val1 = queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String val2 = queries.get(i).get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            res[i] = uf.isConnected(val1, val2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; father;</span><br><span class="line">        HashMap&lt;String, Double&gt; weights;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            father = <span class="keyword">new</span> HashMap&lt;&gt;(len);</span><br><span class="line">            weights = <span class="keyword">new</span> HashMap&lt;&gt;(len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">            String curFather = father.computeIfAbsent(x, key -&gt; x);</span><br><span class="line">            weights.computeIfAbsent(x, key -&gt; <span class="number">1.0</span>d);</span><br><span class="line">            <span class="keyword">if</span> (!curFather.equals(x)) &#123;</span><br><span class="line">                String lastFather = curFather;</span><br><span class="line">                curFather = find(curFather);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">double</span> weight = weights.computeIfAbsent(lastFather, key -&gt; <span class="number">1.0</span>d);</span><br><span class="line">                weights.put(x, weight * weights.computeIfAbsent(x, key -&gt; <span class="number">1.0</span>d));</span><br><span class="line">                father.put(x, curFather);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curFather;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(String x, String y, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">            String rootX = find(x);</span><br><span class="line">            String rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (!rootX.equals(rootY)) &#123;</span><br><span class="line">                father.put(rootX, rootY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 关系式的推导</span></span><br><span class="line">                weights.put(rootX, weights.get(y) * value / weights.get(x));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">isConnected</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!father.containsKey(x) || !father.containsKey(y)) <span class="keyword">return</span> -<span class="number">1.0</span>d;</span><br><span class="line"></span><br><span class="line">            String rootX = find(x);</span><br><span class="line">            String rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX.equals(rootY)) &#123;</span><br><span class="line">                <span class="keyword">return</span> weights.get(x) / weights.get(y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1.0</span>d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-面试题-17-07-婴儿名字"><a href="#2-3-面试题-17-07-婴儿名字" class="headerlink" title="2.3 面试题 17.07. 婴儿名字"></a>2.3 <a href="https://leetcode-cn.com/problems/baby-names-lcci/" target="_blank" rel="noopener">面试题 17.07. 婴儿名字</a></h4><blockquote><p>每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John 和 Jon 本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果 John 和 Jon 是相同的，并且 Jon 和 Johnny 相同，则 John 与 Johnny 也相同，即它们有传递和对称性。</p><p>在结果列表中，选择 字典序最小 的名字作为真实名字。</p></blockquote><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;John(15)&quot;,&quot;Jon(12)&quot;,&quot;Chris(13)&quot;,&quot;Kris(4)&quot;,&quot;Christopher(19)&quot;], synonyms = [&quot;(Jon,John)&quot;,&quot;(John,Johnny)&quot;,&quot;(Chris,Kris)&quot;,&quot;(Chris,Christopher)&quot;]</span><br><span class="line">输出：[&quot;John(27)&quot;,&quot;Chris(36)&quot;]</span><br></pre></td></tr></table></figure><p>分析条件中，强调的传递性和关系，又是一个求连通子图的题，可以使用并查集直接求解。主要是数据处理上很麻烦，需要处理很多字符串的切分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 并查集</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind1</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind1</span><span class="params">(String[] names)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">                map.put(name, name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 并</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(String name1, String name2)</span> </span>&#123;</span><br><span class="line">            String parent1 = find(name1);</span><br><span class="line">            <span class="keyword">if</span> (parent1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent1 = name1;</span><br><span class="line">            &#125;</span><br><span class="line">            String parent2 = find(name2);</span><br><span class="line">            <span class="keyword">if</span> (parent2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent2 = name2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!parent1.equals(parent2)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent2.compareTo(parent1) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    map.put(parent2, parent1);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(parent1, parent2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查</span></span><br><span class="line">        <span class="function">String <span class="title">find</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (name.equals(map.get(name))) &#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> find(map.get(name));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] trulyMostPopular(String[] names, String[] synonyms) &#123;</span><br><span class="line">        <span class="comment">// 初始化并查集</span></span><br><span class="line">        String[] nameArray = Arrays.stream(names).map(ele -&gt; ele.substring(<span class="number">0</span>, ele.indexOf(<span class="string">"("</span>))).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        UnionFind1 uf = <span class="keyword">new</span> UnionFind1(nameArray);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String syn : synonyms) &#123;</span><br><span class="line">            String[] array = syn.replace(<span class="string">'('</span>, <span class="string">' '</span>).replace(<span class="string">')'</span>, <span class="string">' '</span>).trim().split(<span class="string">","</span>);</span><br><span class="line">            uf.union(array[<span class="number">0</span>], array[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算数字</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String item : names) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = item.indexOf(<span class="string">"("</span>);</span><br><span class="line">            String name = item.substring(<span class="number">0</span>, index);</span><br><span class="line">            <span class="keyword">int</span> num = Integer.parseInt(item.substring(index + <span class="number">1</span>, item.length() - <span class="number">1</span>));</span><br><span class="line">            name = uf.find(name);</span><br><span class="line">            map.put(name, map.getOrDefault(name, <span class="number">0</span>) + num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.entrySet().stream().map(ele -&gt; String.format(<span class="string">"%s(%d)"</span>, ele.getKey(), ele.getValue())).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-leetcode-1631-最小体力消耗路径"><a href="#2-4-leetcode-1631-最小体力消耗路径" class="headerlink" title="2.4 leetcode-1631. 最小体力消耗路径"></a>2.4 leetcode-1631. 最小体力消耗路径</h4><blockquote><p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <code>0</code> 开始编号）。你每次可以往 <strong>上，下，左，右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p><p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p><p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p></blockquote><p>可以将本题抽象成如下的一个图论模型：</p><ul><li><p>将地图中的每一个格子看成图中的一个节点；</p></li><li><p>将两个相邻（左右相邻或者上下相邻）的两个格子对应的节点之间连接一条无向边，边的权值为这两个格子的高度差的绝对值；</p></li><li><p>需要找到一条从左上角到右下角的最短路径，其中一条路径的长度定义为其经过的所有边权的最大值。</p></li></ul><p>可以将图中的所有边按照权值从小到大进行排序，并依次加入并查集中。当加入一条权值为 <code>x</code> 的边之后，如果左上角和右下角从非连通状态变为连通状态，那么 <code>x</code> 即为答案。可以参考力扣上的博客：<a href="https://leetcode-cn.com/problems/path-with-minimum-effort/solution/duo-tu-xiang-xi-fen-xi-jie-ti-si-lu-fen-7z89x/" target="_blank" rel="noopener">多图详细分析解题思路，分享刷题心得</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] findSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">            findSet = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                findSet[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == findSet[cur]) <span class="keyword">return</span> cur;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                findSet[cur] = Find(findSet[cur]);</span><br><span class="line">                <span class="keyword">return</span> findSet[cur];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> xRoot = Find(x);</span><br><span class="line">            <span class="keyword">int</span> yRoot = Find(y);</span><br><span class="line">            <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">                findSet[xRoot] = yRoot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Find(x) == Find(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span> <span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.begin = begin;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="keyword">int</span>[][] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = heights.length;</span><br><span class="line">        <span class="keyword">int</span> colunms = heights[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(rows*colunms);</span><br><span class="line">        PriorityQueue&lt;Edge&gt; edgeQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Edge&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge e1, Edge e2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> e1.value - e2.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> curValue;</span><br><span class="line">        Edge curE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colunms; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = i*colunms+j;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; rows-<span class="number">1</span>) &#123;</span><br><span class="line">                    curValue = Math.abs(heights[i+<span class="number">1</span>][j] - heights[i][j]); </span><br><span class="line">                    curE = <span class="keyword">new</span> Edge(id, id + colunms, curValue);</span><br><span class="line">                    edgeQ.offer(curE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(j &lt; colunms-<span class="number">1</span>) &#123;</span><br><span class="line">                    curValue = Math.abs(heights[i][j+<span class="number">1</span>] - heights[i][j]); </span><br><span class="line">                    curE = <span class="keyword">new</span> Edge(id, id + <span class="number">1</span>, curValue);</span><br><span class="line">                    edgeQ.offer(curE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> last = rows*colunms-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!edgeQ.isEmpty()) &#123;</span><br><span class="line">            curE = edgeQ.poll();</span><br><span class="line">            uf.Union(curE.begin, curE.end);</span><br><span class="line">            <span class="keyword">if</span> (uf.Connected(<span class="number">0</span>, last)) <span class="keyword">return</span> curE.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>总结起来并查集可以解决的问题存在以下性质：</p><ul><li>可以转化为寻找连通分量；</li><li>元素之间的关系具备传递性；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-并查集介绍&quot;&gt;&lt;a href=&quot;#1-并查集介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 并查集介绍&quot;&gt;&lt;/a&gt;1. 并查集介绍&lt;/h3&gt;&lt;p&gt;并查集（UnionFindSet）主要用于解决动态连通性问题，判断一个图中两个点是否连同。开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间反复查找一个元素在哪个集合中。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="https://wuyunjie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="并查集" scheme="https://wuyunjie.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|动态规划]</title>
    <link href="https://wuyunjie.top/2021/07/22/Data_structure_and_algorithm_dynamic_programming.html"/>
    <id>https://wuyunjie.top/2021/07/22/Data_structure_and_algorithm_dynamic_programming.html</id>
    <published>2021-07-22T08:37:30.000Z</published>
    <updated>2021-07-22T08:37:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-动态规划概述"><a href="#1-动态规划概述" class="headerlink" title="1. 动态规划概述"></a>1. 动态规划概述</h3><h4 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h4><p>动态规划（<code>dynamic programming</code>）可以理解为是对递归算法的一种优化，是R.E.Bellman等人在研究多阶段决策过程(<code>multistep decision process</code>)的优化问题时，提出的最优化原理(<code>principle of optimality</code>)，即把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系逐个求解。</p><blockquote><p><code>dynamic programming</code>的名字是为了<a href="https://www.zhihu.com/question/39948290/answer/83920614" target="_blank" rel="noopener">规避军方的厌恶</a></p></blockquote><a id="more"></a><h4 id="1-2-基本思想"><a href="#1-2-基本思想" class="headerlink" title="1.2 基本思想"></a>1.2 基本思想</h4><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。动态规划过程是：</p><blockquote><p><strong><u>每次决策依赖于当前状态，又随即引起状态的转移</u></strong>。</p></blockquote><p>动态规划将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。能采用动态规划求解的问题的一般要具有3个性质：</p><ul><li><strong>最优化原理</strong>：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</li><li><strong>无后效性</strong>：即某阶段状态一旦确定，就不受这个状态以后决策的影响。</li><li><strong>有重叠子问题</strong>：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。这<strong><u>并非必要条件</u></strong>，但满足这个条件动态规划才能发挥出较大的优势。</li></ul><h4 id="1-3-求解的基本步骤"><a href="#1-3-求解的基本步骤" class="headerlink" title="1.3 求解的基本步骤"></a>1.3 求解的基本步骤</h4><p>动态规划一般要经历以下几个步骤：</p><ul><li><strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。</li><li><strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的不同的状态表示出来。确定<code>状态</code>需要满足<strong>最优化原理</strong>和<strong>无后效性</strong>。</li><li><strong>确定决策并写出状态转移方程</strong>：根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</li><li><strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</li></ul><p>可以看出，动态规划最主要的两个核心部分是：<code>DP 状态</code>和<code>DP 转移方程</code>。整个求解过程可以用一个<strong><u>最优决策表</u></strong>来描述：</p><ul><li><code>最优决策表</code>是一个<strong>二维表</strong>，其中<strong><u>行表示决策的阶段</u></strong>，列表示<strong><u>问题状态</u></strong>，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值；</li><li>填表的过程就是根据递推关系，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</li></ul><h4 id="1-4-动态规划与递归"><a href="#1-4-动态规划与递归" class="headerlink" title="1.4 动态规划与递归"></a>1.4 动态规划与递归</h4><p>动态规划是<strong>自底向上</strong>，递归树是<strong>自顶向下</strong>。</p><ul><li><p><strong>自顶向下</strong>的递归。从规模较大的原问题比如说 $f(n)$，向下逐渐分解规模直到边界条件$f(1)$触底，然后逐层返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> Fibonacci1(n-<span class="number">1</span>) + Fibonacci1(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>自底向上</strong>的动态规划。从问题规模最小的$f(1)$，直到推到得到原问题答案$f(n)$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[N + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-4-变体"><a href="#1-4-变体" class="headerlink" title="1.4 变体"></a>1.4 变体</h4><h5 id="1-4-1-数位dp"><a href="#1-4-1-数位dp" class="headerlink" title="1.4.1 数位dp"></a>1.4.1 <code>数位dp</code></h5><p>可以看这个视频：<a href="https://www.bilibili.com/video/BV1ip4y1v7zw?from=search&amp;seid=13099671920328002016" target="_blank" rel="noopener">数位DP</a>。数位DP解决的问题是：</p><blockquote><p>求出在给定区间$[A,B]$内，符合条件$f(i)$的数$i$的个数。条件$f(i)$一般与数的大小无关，而与数的组成有关由于数是按位dp，<strong>数的大小对复杂度的影响很小</strong>。</p></blockquote><p>暴力解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=A; i&lt;=B; i++)</span><br><span class="line"><span class="keyword">if</span>(f(i)) ans++;</span><br></pre></td></tr></table></figure><p>引入数位的概念，使得新的枚举方式满足dp的性质，然后记忆化搜索。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/dp/numBitBP.PNG" alt="数位搜索"></p><p>从起点向下搜索，到最底层得到方案数，一层一层向上返回答案并累加，最后从搜索起点得到最终答案。主要涉及以下参数：</p><ul><li>数位dp基本的量数字位数<code>pos</code>，记录答案的<code>st</code>；</li><li>最高位限制<code>limit</code>。</li><li>判断<strong>前导0</strong>的标记<code>lead</code>。部分题目中，前导0会影响答案结果，需要进行区分。</li><li>经常要比较当前位和前一位或前几位的关系，一般在<code>dfs()</code>中也要记录前一位或前几位数<code>pre</code>。</li><li>更多参量以区分状态，视题意而定。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">long</span> dp[<span class="number">20</span>][state];<span class="comment">//不同题目状态不同</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="comment">/*其他state变量*/</span>,<span class="keyword">boolean</span> lead<span class="comment">/*前导零*/</span>,<span class="keyword">boolean</span> limit<span class="comment">/*数位上界变量*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归边界，按位枚举最低位是0，pos &lt; 0 说明这个数枚举完了</span></span><br><span class="line">    <span class="comment">// 这里一般返回1，表示枚举的这个数是合法的</span></span><br><span class="line">    <span class="comment">// 也可能返回别的值</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记忆化</span></span><br><span class="line">    <span class="comment">// !limit 代表非边界状态，无需特殊处理</span></span><br><span class="line">    <span class="comment">// dp[pos][state] != -1 代表已经遍历过了</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state] != -<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> dp[pos][state];</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//根据limit判断枚举的上界up</span></span><br><span class="line">    <span class="keyword">int</span> up = limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">long</span> ans=<span class="number">0</span>; <span class="comment">// 开始计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up;i++) &#123; <span class="comment">//枚举，然后把不同情况的个数加到ans就可以了</span></span><br><span class="line">        <span class="keyword">if</span>() ...</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>()...</span><br><span class="line">        ans+=dfs(pos-<span class="number">1</span>,<span class="comment">/*状态转移*/</span>,lead &amp;&amp; i==<span class="number">0</span>,limit &amp;&amp; i==a[pos]) <span class="comment">//最后两个变量传参都是这样写的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算完，记录状态</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead) dp[pos][state]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123; <span class="comment">//把数位都分解出来</span></span><br><span class="line">        a[pos++] = x % <span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// //刚开始最高位都是有限制并且有前导零的</span></span><br><span class="line">    <span class="keyword">return</span> dfs(pos-<span class="number">1</span><span class="comment">/*从最高位开始枚举*/</span>,<span class="comment">/*一系列状态 */</span>,<span class="keyword">true</span>,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-2-0-1背包问题"><a href="#1-4-2-0-1背包问题" class="headerlink" title="1.4.2 0/1背包问题"></a>1.4.2 <code>0/1</code>背包问题</h5><blockquote><p>有一个容量有限的背包，总容量为<code>c</code>，有<code>n</code>个可待选择的物品，<strong><u>每个物品只有一件</u></strong>，它们都有各自的重量和价值，需要从中选择合适的组合来使得背包中的物品总价值最大。</p></blockquote><p>背包问题抽象为寻找组合${x_1,x_2,x_3,…,x_n}$​​​ （其中$x_i$​​​取<code>0</code>或<code>1</code>，表示第$i$个物品取或者不取），$v_i$代表第$i$个物品的价值，$w_i$代表第$i$个物品的重量，总物品数为$n$，背包容量为$c$。问题即求解：</p><script type="math/tex; mode=display">\textbf{目标}：& max\{ x_1v_1 + x_2v_2 + x_3v_3 + ... + x_nv_n \} \\\textbf{约束条件}：& x_1w_1 + x_2w_2 + x_3w_3 + ... + x_nw_n < c</script><p>证明最优化原理：</p><blockquote><p>假设$(x_1，x_2，…，x_n)$是$0/1$背包问题的最优解，则有$(x_2，x_3，…，x_n)$是其子问题的最优解，假设$(y_2，y_3，…，y_n)$是上述问题的子问题最优解，则有$(v_2y_2+v_3y_3+…+v_ny_n)+v_1x_1 &gt; (v_2x_2+v_3x_3+…+v_nx_n)+v_1x_1$。说明$(X_1，Y_2，Y_3，…，Y_n)$才是该$0/1$背包问题的最优解，这与最开始的假设相矛盾，故满足<code>最优性原理</code>。</p></blockquote><p>用$dp[i][j]$表示第$i$件物品放入容量为$j$的背包所得的最大价值，则状态转移方程可以推出如下：</p><script type="math/tex; mode=display">dp[i][j]=max\{dp[i-1][j-v[i]]+c[i],dp[i-1][j]\};、</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) <span class="comment">//枚举物品  &#123;  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= C; j++) &#123; <span class="comment">//枚举背包容量    </span></span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j];  </span><br><span class="line">        <span class="comment">// 能装下物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= v[i]) &#123;</span><br><span class="line">            <span class="comment">// 选择最优装法</span></span><br><span class="line">            f[i][j] = Max(f[i - <span class="number">1</span>][j],f[i - <span class="number">1</span>][j - v[i]] + c[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-动态规划题解"><a href="#2-动态规划题解" class="headerlink" title="2. 动态规划题解"></a>2. 动态规划题解</h3><h4 id="2-1-剑指offer-10-斐波那契数列"><a href="#2-1-剑指offer-10-斐波那契数列" class="headerlink" title="2.1 剑指offer-10 斐波那契数列"></a>2.1 剑指offer-10 斐波那契数列</h4><p>斐波那契数列的标准公式为：</p><script type="math/tex; mode=display">F(1)=1;F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)</script><p>可以看出定义即为转移方程的定义，可以很容易写出其动态规划实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] fibDP = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        fibDP[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        fibDP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            fibDP[i] = (fibDP[i-<span class="number">1</span>] + fibDP[i-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fibDP[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-剑指offer-10-跳台阶"><a href="#2-2-剑指offer-10-跳台阶" class="headerlink" title="2.2 剑指offer-10 跳台阶"></a>2.2 剑指offer-10 跳台阶</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p></blockquote><p>实际上是斐波那契数列的变种，求第$n$个台阶的跳法时，需要之前的两个状态：</p><ul><li>上一步跳<code>1</code>级台阶，求跳到<code>n-1</code>级台阶的方法；</li><li>上一步跳<code>2</code>级台阶，求跳到<code>n-2</code>级台阶的方法；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n== <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] numWays = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        numWays[<span class="number">1</span>] = <span class="number">1</span>; numWays[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            numWays[i] = (numWays[i-<span class="number">1</span>] + numWays[i-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numWays[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-剑指offer-13-机器人的运动范围"><a href="#2-3-剑指offer-13-机器人的运动范围" class="headerlink" title="2.3 剑指offer-13 机器人的运动范围"></a>2.3 剑指offer-13 机器人的运动范围</h4><blockquote><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p></blockquote><p>搜索的过程中搜索方向可以缩减为向右和向下，由可达解分析机器人可 <strong>仅通过向右和向下移动，访问所有可达解</strong> 。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ13/Reachable.PNG" alt="可达解分析"></p><p>所以 <code>(i, j)</code> 的格子只会从 <code>(i - 1, j)</code> 或者 <code>(i, j - 1)</code> 两个格子走过来（不考虑边界条件），那么 <code>vis[i][j]</code> 是否可达的状态则可由如下公式计算得到：</p><script type="math/tex; mode=display">vis[i][j]=vis[i−1][j]\ \ or\ \ vis[i][j−1]</script><p>因此只要遍历所有格子，递推计算出它们是否可达然后用变量 <code>ans</code> 记录可达的格子数量即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] movingCountDP = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        movingCountDP[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( reachable(i, j, k) ) &#123;</span><br><span class="line">                    <span class="comment">// 转移方程</span></span><br><span class="line">                    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) movingCountDP[i][j] = movingCountDP[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) movingCountDP[i][j] = movingCountDP[i][j-<span class="number">1</span>] &gt; <span class="number">0</span> ? <span class="number">1</span> : movingCountDP[i][j];</span><br><span class="line">                    ans += movingCountDP[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reachable</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> || j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += (i % <span class="number">10</span> + j % <span class="number">10</span>);</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法缺点是，许多不可达的节点也需要进行计算，应该可以进行进一步优化。</p><h4 id="2-4-剑指-Offer-14-I-剪绳子"><a href="#2-4-剑指-Offer-14-I-剪绳子" class="headerlink" title="2.4 剑指 Offer 14- I. 剪绳子"></a>2.4 剑指 Offer 14- I. 剪绳子</h4><blockquote><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></blockquote><p>先把绳子剪掉第一段（长度为<code>j</code>），剩下<code>(i - j)</code>长度可以剪也可以不剪。</p><ul><li>如果不剪，这种分割方法长度乘积即为<code>j * (i - j)</code>；</li><li>如果继续剪，这种分割方法长度乘积即为<code>j * dp[i - j]</code>；</li><li>取两者最大值<code>max(j * (i - j), j * dp[i - j])</code>。</li></ul><p>因此<code>dp[i]</code>的转移方程为</p><script type="math/tex; mode=display">dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++ ) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * (i-j), j * dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题实际上有更优化的解法，需要结合数学推理和贪心算法，具体可以参考对这道题的解析：<a href="">待完善</a>。</p><h4 id="2-5-剑指-Offer-19-正则表达式匹配"><a href="#2-5-剑指-Offer-19-正则表达式匹配" class="headerlink" title="2.5 剑指 Offer 19. 正则表达式匹配"></a>2.5 剑指 Offer 19. 正则表达式匹配</h4><blockquote><p>请实现一个函数用来匹配包含<code>&#39;. &#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但与”aa.a”和”ab*a”均不匹配。</p></blockquote><p>用 $f[i][j]$ 表示 $s$ 的前 $i$ 个字符与 $p$​ 中的前 $j$ 个字符是否能够匹配。在进行状态转移时，考虑 $p$ 的第 $j$ 个字符的匹配情况：</p><ul><li><p>如果 $p$​ 的第 $j$​​ 个字符是一个<code>正常字符</code>，那么必须在 $s$ 中匹配一个相同的正常字符：</p><script type="math/tex; mode=display">f[i][j] =     \begin{cases}        f[i-1][j-1], & s[i]=p[j] \\         \text { false, } & s[i] \neq p[j]\end{cases}</script></li><li><p>如果 $p$ 的第 $j$ 个字符是 <code>&#39;*&#39;</code>，那么就表示可以对 $p$ 的第 $j-1$ 个字符匹配任意次数。</p><ul><li><p>如果匹配 $0$​ 次：</p><script type="math/tex; mode=display">f[i][j]=f[i][j−2]</script></li><li><p>匹配 $s$​ 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；不匹配字符，丢掉带星号的组合，不再继续匹配。</p><script type="math/tex; mode=display">f[i][j] = f[i-1][j] or f[i][j-2]，s[i] = p[j-1]</script></li></ul></li><li></li></ul><p>最终的状态转移方程如下：</p><script type="math/tex; mode=display">f[i][j]= \begin{cases}    \text { if }\left(p[j] \neq '*' \right) =         \begin{cases}            f[i-1][j-1], & \text { matches }(s[i], p[j]) \\             \text { false, } & \text { otherwise }        \end{cases} \\     \text { otherwise }=         \begin{cases}            f[i-1][j] \text { or } f[i][j-2], & \text { matches }(s[i], p[j-1]) \\             f[i][j-2], & \text { otherwise }        \end{cases}\end{cases}</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> pLen = p.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第零行表示其中一个为空串时的结果</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sLen+<span class="number">1</span>][pLen+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pLen; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前判断的 第 j 个 p 字符为"*"</span></span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) == <span class="string">'*'</span> ) &#123;</span><br><span class="line">                    <span class="comment">// 匹配 0 次</span></span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    <span class="comment">// 匹配 n 次</span></span><br><span class="line">                    <span class="keyword">if</span> ( matches(s, p, i, j-<span class="number">1</span>) ) &#123;</span><br><span class="line">                        dp[i][j] |= dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 正常字符</span></span><br><span class="line">                    <span class="keyword">if</span> ( matches(s, p, i, j) ) &#123;</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[sLen][pLen];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) == <span class="string">'.'</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-Offer-42-连续子数组的最大和"><a href="#2-6-Offer-42-连续子数组的最大和" class="headerlink" title="2.6 Offer 42. 连续子数组的最大和"></a>2.6 Offer 42. 连续子数组的最大和</h4><blockquote><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p></blockquote><p>我们用 $f(i)$​​​ 代表以第 $i$​​​​ 个数结尾的「连续子数组的最大和」。可以考虑 $nums[i]$​​ 单独成为一段还是加入 $f(i−1)$​​ 对应的那一段，这取决于 $nums[i]$​ 和 $f(i−1)+nums[i]$ 的大小，于是可以写出这样的动态规划转移方程：</p><script type="math/tex; mode=display">f(i)=max\{f(i−1)+nums[i],nums[i]\}</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = Math.max(nums[i], nums[i] + nums[i-<span class="number">1</span>]);</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#2-7-剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="2.7 剑指 Offer 43. 1～n 整数中 1 出现的次数"></a>2.7 剑指 Offer 43. 1～n 整数中 1 出现的次数</h4><blockquote><p>输入一个整数 <code>n</code> ，求1～n这n个整数的十进制表示中1出现的次数。</p></blockquote><p>这道题有直接基于规律统计的方法。但还有一种基于动态规划的方法——<code>数位dp</code>，按数位来遍历。状态转移方程为：</p><script type="math/tex; mode=display">dp[pos][count] = \left\{    \begin{array}{lr}    dp[pos][count] & , pos < up \ \& \ not \ limit \\    \sum_0^{up}{dfs(pos-1, limit=true)} & , else  \\    \end{array}\right.</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] num;</span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>];</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> numLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            num[numLen++] = n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; ++i) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);<span class="comment">//初始化dp数组，用-1表示对应的dfs有没有执行过</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(numLen - <span class="number">1</span> , <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> count, <span class="keyword">boolean</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!limit &amp;&amp; dp[pos][count] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[pos][count];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> up = limit ? num[pos] : <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= up; i++) &#123;</span><br><span class="line">            res += dfs(pos - <span class="number">1</span>, (i == <span class="number">1</span>) ? count+<span class="number">1</span> : count, limit &amp;&amp; i == up);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!limit) dp[pos][count] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8-剑指-Offer-46-把数字翻译成字符串"><a href="#2-8-剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="2.8 剑指 Offer 46. 把数字翻译成字符串"></a>2.8 剑指 Offer 46. 把数字翻译成字符串</h4><blockquote><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p></blockquote><p>用 $f(i)$ 表示以第 $i$​ 位结尾的前缀串翻译的方案数，这时有两种选择：</p><ul><li>单独翻译第 $i$​​ 位，对 $f(i)$ 的贡献为 $f(i - 1)$；</li><li>如果第 $i−1$​ 位存在，并且第 $i - 1$​ 位和第 $i$​ 位形成的数字 $x$​ 满足 $10 \leq x \leq 25$，那么就可以把第 $i−1$ 位和第 $i$ 位连起来一起翻译，对 $f(i)$ 的贡献为 $f(i - 2)$，否则为 0。</li></ul><p>可以列出动态规划转移方程：</p><script type="math/tex; mode=display">f(i)= \left\{    \begin{array}{lr}    f(i-1)+f(i-2), num[i-1] \geq 0 \ \& \ 10 \leq x \leq 25 \\    f(i-1), else  \\    \end{array}\right.</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        </span><br><span class="line">        String numStr = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> numLen = numStr.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[numLen];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        dp[<span class="number">1</span>] = numStr.substring(<span class="number">0</span>, <span class="number">2</span>).compareTo(<span class="string">"25"</span>) &lt;= <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; numLen; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            String pre = numStr.substring(i-<span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ( pre.compareTo(<span class="string">"25"</span>) &lt;= <span class="number">0</span> &amp;&amp; pre.compareTo(<span class="string">"10"</span>) &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">                dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[numLen-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-9-剑指-Offer-47-礼物的最大价值"><a href="#2-9-剑指-Offer-47-礼物的最大价值" class="headerlink" title="2.9 剑指 Offer 47. 礼物的最大价值"></a>2.9 剑指 Offer 47. 礼物的最大价值</h4><blockquote><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p></blockquote><p>可以看作找连续子数组的最大和的升级版，从一维数组变为了二维数组，但思想上是差不多的。只可能每次向右或者向下移动一格，设 <code>f(i,j)</code> 为从棋盘左上角走至单元格 <code>(i,j)</code> 的礼物最大累计价值，易得到以下递推关系：<code>f(i,j)</code> 等于 <code>f(i,j−1)</code> 和 <code>f(i−1,j)</code> 中的较大值加上当前单元格礼物价值 <code>grid(i,j)</code> 。</p><script type="math/tex; mode=display">f(i,j) = \max[f(i,j-1), f(i-1,j)] + grid(i,j)</script><script type="math/tex; mode=display">dp(i, j) = \begin{cases}    \operatorname{grid}(i, j) & , i=0, j=0 \\     \operatorname{grid}(i, j)+d p(i, j-1) & , i=0, j \neq 0 \\     \operatorname{grid}(i, j)+d p(i-1, j) & , i \neq 0, j=0 \\     \operatorname{grid}(i, j)+\max [d p(i-1, j), d p(i, j-1)] & , i \neq 0, j \neq 0\end{cases}</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxGift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) dp[i][j] = dp[i][j - <span class="number">1</span>] +  grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[ grid.length - <span class="number">1</span> ][ grid[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-10-剑指-Offer-49-丑数"><a href="#2-10-剑指-Offer-49-丑数" class="headerlink" title="2.10 剑指 Offer 49. 丑数"></a>2.10 剑指 Offer 49. 丑数</h4><blockquote><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p></blockquote><p>定义数组 $dp$​​，其中 $dp[i]$ 表示第 $i$ 个丑数，第 $n$ 个丑数即为 $dp[n]$。最小的丑数是 $1$，因此 $dp[1]=1$。</p><ul><li>定义三个指针 $p_2,p_3,p_5$，表示下一个丑数是当前指针指向的丑数乘以对应的质因数。初始时，三个指针的值都是 $1$。</li><li>可以定义转移方程：</li></ul><script type="math/tex; mode=display">\textit{dp}[i]=\min(\textit{dp}[p_2] \times 2, \textit{dp}[p_3] \times 3, \textit{dp}[p_5] \times 5)</script><ul><li>比较 $\textit{dp}[i]$ 和 $\textit{dp}[p_2],\textit{dp}[p_3],\textit{dp}[p_5]$，如果相等则将对应的指针加 <code>1</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n ; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur2 = <span class="number">2</span> * dp[p2], cur3 = <span class="number">3</span> * dp[p3], cur5 = <span class="number">5</span> * dp[p5];</span><br><span class="line">            dp[i] = Math.min(cur2, Math.min(cur3, cur5));</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == cur2) p2++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == cur3) p3++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == cur5) p5++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-11-剑指-Offer-60-n个骰子的点数"><a href="#2-11-剑指-Offer-60-n个骰子的点数" class="headerlink" title="2.11 剑指 Offer 60. n个骰子的点数"></a>2.11 剑指 Offer 60. n个骰子的点数</h4><blockquote><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p></blockquote><p>设输入 $n$​个骰子的解（即概率列表）为 $f(n)$​，其中「点数和」 $x$​ 的概率为 $f(n, x)$​。假设已知 $n - 1$​ 个骰子的解 $f(n - 1)$，此时添加一枚骰子，求 $n$ 个骰子的点数和为 $x$ 的概率 $f(n, x)$。</p><ul><li>当添加骰子的点数为 $1$ 时，前 $n - 1$ 个骰子的点数和应为 $x - 1$，方可组成点数和 $x$；</li><li>同理，当此骰子为 $i$ 时，前 $n - 1$ 个骰子应为 $x - i$；</li><li>递推公式如下所示：</li></ul><script type="math/tex; mode=display">f(n, x) = \sum_{i=1}^6 f(n - 1, x - i) \times \frac{1}{6}</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] dicesProbability(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] probs = <span class="keyword">new</span> <span class="keyword">double</span>[ <span class="number">6</span> * n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i) probs[i] = <span class="number">1.0</span> / <span class="number">6.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = i*<span class="number">6</span>; x &gt;= i; x--) &#123;</span><br><span class="line">                <span class="comment">// 因为是从后往前逐个累加，在加到当前点数时，必须把原先存放的n-1个骰子的数据置0</span></span><br><span class="line">                probs[x] = <span class="number">0.0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// n-1个骰子的最小值就是n-1</span></span><br><span class="line">                    <span class="keyword">if</span> (x - j  &gt;= i-<span class="number">1</span>) &#123;</span><br><span class="line">                        probs[x] += probs[x-j] / <span class="number">6.0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>*n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= <span class="number">6</span>*n; i++) &#123;</span><br><span class="line">            res[i - n] = probs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><h4 id="2-12-剑指-Offer-63-股票的最大利润"><a href="#2-12-剑指-Offer-63-股票的最大利润" class="headerlink" title="2.12 剑指 Offer 63. 股票的最大利润"></a>2.12 剑指 Offer 63. 股票的最大利润</h4><blockquote><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p></blockquote><p>感觉应该是个简单题，思路就是找两个数字之间的最大差值。使用动态规划的思想，设 $dp[i]$ 为前 $i$ 天股票的最低价格，$maxProfit$ 是当前已经获取的最大利润，那么有转移方程：</p><script type="math/tex; mode=display">dp[i] = min(prices[i], dp[i-1]) \\maxProfit = max(maxPtofit, prices[i] - dp[i])</script><p>实际上只用两个变量直接遍历数组一遍就可以得到答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            res = Math.max(res, prices[i] - prices[i-<span class="number">1</span>]);</span><br><span class="line">            prices[i] = Math.min(prices[i], prices[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-13-leetcode-62-不同路径"><a href="#2-13-leetcode-62-不同路径" class="headerlink" title="2.13 leetcode-62 不同路径"></a>2.13 leetcode-62 不同路径</h4><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p></blockquote><p>比起剑指Offer那道题来说，约束条件更加明确。由于只能向下或向右移动，到达 <code>(i, j)</code>单元格的方法数只与 <code>(i-1, j )</code>和 <code>(i, j-1)</code>两个单元格的状态有关。可以得到转移方程：</p><script type="math/tex; mode=display">dp[i][j] = dp[i-1][j] + dp[i][j-1]</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = (i - <span class="number">1</span> &gt;= <span class="number">0</span> ? dp[i - <span class="number">1</span>][j] : <span class="number">0</span>) +  (j - <span class="number">1</span> &gt;= <span class="number">0</span> ? dp[i][j - <span class="number">1</span>] : <span class="number">0</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-14-leetcode-871-最低加油次数"><a href="#2-14-leetcode-871-最低加油次数" class="headerlink" title="2.14 leetcode-871. 最低加油次数"></a>2.14 leetcode-871. 最低加油次数</h4><blockquote><p>汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。</p><p>沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1] 升汽油。</p><p>假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。</p><p>当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。</p><p>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。</p><p>注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。</p></blockquote><p>用$dp[i]$表示只加 $i$​​​ 次油可以到达的最远距离。那么最后只需要求解$dp$中可以到达$target$的最小 $i$，求解$dp$的状态转移方程为：</p><script type="math/tex; mode=display">dp[k+1] =\begin{cases}    \operatorname{max}(dp[k+1], dp[k]+stations[i][0]) & , stations[i][0] \leq dp[k] \\     dp[k+1] & , else \\ \end{cases}</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minRefuelStops</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> startFuel, <span class="keyword">int</span>[][] stations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startFuel &gt;= target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[stations.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = startFuel;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stations.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[k] &gt;= stations[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                    dp[k+<span class="number">1</span>] = Math.max(dp[k+<span class="number">1</span>], dp[k] + stations[i][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= stations.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt;= target) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题也可以用优先队列求解，先求当前能到达的最远距离，然后当不够到达下一个地点时，选择之前路过可选的最大油量，加一次油继续前进，直到到达最终$targer$，可以得到最小的加油次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minRefuelStops</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> startFuel, <span class="keyword">int</span>[][] stations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startFuel &gt;= target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minRefuel = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; topFuel = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer one, Integer two)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> two - one;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> curStation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curFuel = startFuel;</span><br><span class="line">        <span class="keyword">int</span> N = stations.length;</span><br><span class="line">        <span class="keyword">while</span> (curStation &lt; N) &#123;</span><br><span class="line">            <span class="comment">// 当前可以前进距离</span></span><br><span class="line">            <span class="keyword">while</span> (curStation &lt; N &amp;&amp; curFuel &gt;= stations[curStation][<span class="number">0</span>]) &#123;</span><br><span class="line">                topFuel.offer(stations[curStation++][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(target &lt;= curFuel ) <span class="keyword">return</span> minRefuel;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (curFuel &lt; target &amp;&amp; ! topFuel.isEmpty()) &#123;</span><br><span class="line">                curFuel += topFuel.poll();</span><br><span class="line">                minRefuel++;</span><br><span class="line">                <span class="keyword">if</span> (target &lt;= curFuel) <span class="keyword">return</span> minRefuel;</span><br><span class="line">                <span class="keyword">if</span> (curStation &lt; N &amp;&amp; curFuel &gt;= stations[curStation][<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curStation &lt; N &amp;&amp; curFuel &lt; stations[curStation][<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p>[1] <a href="https://houbb.github.io/2020/01/23/data-struct-learn-07-base-dp#" target="_blank" rel="noopener">五大基本算法之动态规划算法 DP</a></p><p>[2] <a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html" target="_blank" rel="noopener">五大常用算法之二：动态规划算法</a></p><p>[3] <a href="https://www.zhihu.com/question/39948290/answer/1309260344" target="_blank" rel="noopener">如何理解动态规划？ - 力扣（LeetCode）的回答 - 知乎 </a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-动态规划概述&quot;&gt;&lt;a href=&quot;#1-动态规划概述&quot; class=&quot;headerlink&quot; title=&quot;1. 动态规划概述&quot;&gt;&lt;/a&gt;1. 动态规划概述&lt;/h3&gt;&lt;h4 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 简介&quot;&gt;&lt;/a&gt;1.1 简介&lt;/h4&gt;&lt;p&gt;动态规划（&lt;code&gt;dynamic programming&lt;/code&gt;）可以理解为是对递归算法的一种优化，是R.E.Bellman等人在研究多阶段决策过程(&lt;code&gt;multistep decision process&lt;/code&gt;)的优化问题时，提出的最优化原理(&lt;code&gt;principle of optimality&lt;/code&gt;)，即把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系逐个求解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dynamic programming&lt;/code&gt;的名字是为了&lt;a href=&quot;https://www.zhihu.com/question/39948290/answer/83920614&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;规避军方的厌恶&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="https://wuyunjie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://wuyunjie.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--11 Java并发编程实践</title>
    <link href="https://wuyunjie.top/2021/07/22/JavaLearning_The_art_of_concurrent_programming_in_Java-11-concurrent-programming-practice.html"/>
    <id>https://wuyunjie.top/2021/07/22/JavaLearning_The_art_of_concurrent_programming_in_Java-11-concurrent-programming-practice.html</id>
    <published>2021-07-22T07:12:03.000Z</published>
    <updated>2021-07-22T07:12:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>并发编程产生的问题和风险可能也会随之而来。<br><a id="more"></a></p><h3 id="1-生产者和消费者模式"><a href="#1-生产者和消费者模式" class="headerlink" title="1. 生产者和消费者模式"></a>1. 生产者和消费者模式</h3><p>生产者和消费者模式是<strong><u>通过一个容器来解决生产者和消费者的强耦合问题</u></strong>。生产者和消费者彼此之间不直接通信，而是<strong><u>通过阻塞队列来进行通信</u></strong>。</p><ul><li>生产者生产完数据之后不用等待消费者处理，直接放入阻塞队列；</li><li>消费者不找生产者要数据，而是直接从阻塞队列取数据；</li><li>阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</li></ul><h4 id="1-1-多生产者和多消费者"><a href="#1-1-多生产者和多消费者" class="headerlink" title="1.1 多生产者和多消费者"></a>1.1 多生产者和多消费者</h4><p>消费者消费的数据，有可能需要继续处理，于是消费者处理完数据之后，它又要作为生产者把数据放在新的队列里，交给其他消费者继续处理。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/MultipleProducePay.PNG" alt="多生产者消费者模式"></p><h3 id="2-线上问题定位"><a href="#2-线上问题定位" class="headerlink" title="2. 线上问题定位"></a>2. 线上问题定位</h3><p>主要讲述了利用<code>top</code>来查看每个进程的情况，然后定位问题。其实有个更好用的<code>htop</code>，但需要单独安装，<code>top</code>是linux内置的：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/top.PNG" alt="top指令"></p><ul><li>COMMAND表示启动当前进程的命令</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/top1.PNG" alt="top交互"></p><p>使用top的交互命令数字<code>1</code>查看每个<code>CPU</code>的性能数据。参数的含义如下：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/CPUParam.PNG" alt="CPU参数含义"></p><h3 id="3-性能测试"><a href="#3-性能测试" class="headerlink" title="3. 性能测试"></a>3. 性能测试</h3><ul><li><p>使用<code>netstat</code>命令查询有多少台机器连接到端口上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep 12200 –c</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>通过<code>ps</code>命令查看下线程数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf | grep java -c</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看网络流量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/net/dev</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看系统平均负载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/loadavg</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看系统内存情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看CPU的利用率</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/<span class="built_in">stat</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-异步任务池"><a href="#4-异步任务池" class="headerlink" title="4. 异步任务池"></a>4. 异步任务池</h3><p>任务池的主要处理流程是，每台机器会启动一个任务池，每个任务池里有多个线程池，当某台机器将一个任务交给任务池后，任务池会先将这个任务保存到数据库中，然后某台机器上的任务池会从数据库中获取待执行的任务，再执行这个任务。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/AsynchronousTaskPool.PNG" alt="异步任务池"></p><p>每个任务有几种状态：</p><ul><li>创建（<code>NEW</code>）：提交给任务池之后的状态；</li><li>执行中（<code>EXECUTING</code>）：任务池从数据库中拿到任务执行时的状态；</li><li>重试（<code>RETRY</code>）：当执行任务时出现错误，程序显式地告诉任务池这个任务需要重试，并设置下一次执行时间；</li><li>挂起 （<code>SUSPEND</code>）：当一个任务的执行依赖于其他任务完成时，可以将这个任务挂起，当收到消息后，再开始执行；</li><li>中止（<code>TEMINER</code>）：任务执行失败，让任务池停止执行这个任务，并设置错误消息告诉调用端；</li><li>执行完成（<code>FINISH</code>）：任务执行结束。</li></ul><p><strong>任务池的任务隔离</strong>。异步任务有很多种类型，不同类型的任务优先级不一样，所以对任务进行隔离执行。使用不同的线程池处理不同的任务，或者不同的线程池处理不同优先级的任务。</p><p><strong>任务池的重试策略</strong>。根据不同的任务类型设置不同的重试策略。</p><p><strong>使用任务池的注意事项</strong>。任务必须无状态：任务不能在执行任务的机器中保存数据，上传的文件必须存在其他的集群里，比如<code>OSS</code>或<code>SFTP</code>。</p><p><strong>异步任务的属性</strong>。包括任务名称、下次执行时间、已执行次数、任务类型、任务优先级和执行时的报错信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;并发编程产生的问题和风险可能也会随之而来。&lt;br&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--10 Executor框架</title>
    <link href="https://wuyunjie.top/2021/07/22/JavaLearning_The_art_of_concurrent_programming_in_Java-10-Executor-framework.html"/>
    <id>https://wuyunjie.top/2021/07/22/JavaLearning_The_art_of_concurrent_programming_in_Java-10-Executor-framework.html</id>
    <published>2021-07-22T02:04:28.000Z</published>
    <updated>2021-07-22T02:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java的线程既是<strong>工作单元</strong>，也是<strong>执行机制</strong>。<code>JDK 5</code>开始，把<strong>工作单元</strong>与<strong>执行机制</strong>分离开来，<strong>工作单元</strong>包括<code>Runnable</code>和<code>Callable</code>，而执行机制由<code>Executor</code>框架提供。<br><a id="more"></a></p><h3 id="1-Executor框架简介"><a href="#1-Executor框架简介" class="headerlink" title="1. Executor框架简介"></a>1. <code>Executor</code>框架简介</h3><h4 id="1-1-Executor框架的两级调度模型"><a href="#1-1-Executor框架的两级调度模型" class="headerlink" title="1.1 Executor框架的两级调度模型"></a>1.1 <code>Executor</code>框架的两级调度模型</h4><p>两级调度模型即：</p><ul><li><strong>应用程序通过<code>Executor</code>框架控制<u>上层的调度</u></strong>。<code>Java</code>多线程程序把应用分解为若干个任务，然后使用用户级的调度器（<code>Executor</code>框架）将这些任务映射为固定数量的线程；</li><li><strong>由<code>操作系统内核</code>控制<u>下层的调度</u></strong>。操作系统内核将这些线程映射到硬件处理器上，下层的调度不受应用程序的控制。在<code>HotSpot VM</code>的线程模型中，<code>Java</code>线程（<code>java.lang.Thread</code>）被一对一映射为本地操作系统线程。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/TwoLevelSchedule.PNG" alt="线程池的主要处理流程"></p><h4 id="1-2-Executor框架的结构与成员"><a href="#1-2-Executor框架的结构与成员" class="headerlink" title="1.2 Executor框架的结构与成员"></a>1.2 <code>Executor</code>框架的结构与成员</h4><h5 id="1-2-1-Executor框架的结构"><a href="#1-2-1-Executor框架的结构" class="headerlink" title="1.2.1 Executor框架的结构"></a>1.2.1 <code>Executor</code>框架的结构</h5><p><code>Executor</code>框架主要由3大部分组成：</p><ul><li><strong>任务</strong>。包括被执行任务需要实现的接口：<code>Runnable</code>接口或<code>Callable</code>接口。<ul><li><code>Runnable</code>接口和<code>Callable</code>接口的实现类，都可以被<code>Executor</code>接口的<strong>实现类</strong>执行。</li></ul></li><li><strong>任务的执行</strong>。包括任务执行机制的核心接口<code>Executor</code>，以及继承自<code>Executor</code>的<code>ExecutorService</code>接口。<code>Executor</code>接口是<strong>Executor框架</strong>的基础，它将任务的提交与任务的执行分离开来。<code>Executor</code>框架有两个<strong>关键类</strong>实现了<code>ExecutorService</code>接口：<ul><li><code>ThreadPoolExecutor</code>，线程池的核心实现类，用来<strong><u>执行被提交的任务</u></strong>；</li><li><code>ScheduledThreadPoolExecutor</code>，可以<strong><u>在给定的延迟后运行命令，或者定期执行命令</u></strong>。比<code>Timer</code>更灵活，功能更强大。</li></ul></li><li><strong>异步计算的结果</strong>。包括接口<code>Future</code>和实现<code>Future</code>接口的<code>FutureTask</code>类，代表异步计算的结果。</li></ul><p><code>Executor</code>框架的使用过程一般如下：</p><ul><li><p>主线程首先要创建实现<code>Runnable</code>或者<code>Callable</code>接口的任务对象。工具类<code>Executors</code>可以把一 个<code>Runnable</code>对象封装为一个<code>Callable</code>对象：</p><ul><li><code>Executors.callable(Runnable task)</code>；</li><li><code>Executors.callable(Runnable task, Object resule)</code>。</li></ul></li><li><p>然后可以把<code>Runnable</code>对象<strong><u>直接</u></strong>交给<code>ExecutorService</code>执行；或者也可以把<code>Runnable</code>对象或<code>Callable</code>对象<strong><u>提交</u></strong>给<code>ExecutorService</code>执行：</p><ul><li><code>ExecutorService.execute(Runnable command)</code></li><li><code>ExecutorService.submit(Runnable task)</code></li><li><code>ExecutorService.submit(Callabletask)</code></li></ul></li><li><p>如果执行<code>ExecutorService.submit</code>，<code>ExecutorService</code>将返回一个实现<code>Future</code>接口的对象。</p><ul><li>由于<code>FutureTask</code>实现了<code>Runnable</code>，也可以创建<code>FutureTask</code>，然后直接交给<code>ExecutorService</code>执行</li></ul></li><li><p>最后，主线程可以执行<code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行<code>FutureTask.cancel(boolean mayInterruptIfRunning)</code>来取消此任务的执行。</p></li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/ExractorFramework.PNG" alt="线程池的主要处理流程"></p><h5 id="1-2-2-Executor框架的成员"><a href="#1-2-2-Executor框架的成员" class="headerlink" title="1.2.2 Executor框架的成员"></a>1.2.2 <code>Executor</code>框架的成员</h5><h6 id="1-2-2-1-ThreadPoolExecutor"><a href="#1-2-2-1-ThreadPoolExecutor" class="headerlink" title="1.2.2.1 ThreadPoolExecutor"></a>1.2.2.1 <code>ThreadPoolExecutor</code></h6><p><code>ThreadPoolExecutor</code>通常使用工厂类<code>Executors</code>来创建。<code>Executors</code>可以创建3种类型的<code>ThreadPoolExecutor</code>：</p><ul><li><p><code>SingleThreadExecutor</code>。适用于<strong><u>需要保证顺序地执行各个任务</u></strong>；并且在任意时间点，不会有多个线程是活动的应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors提供的API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>FixedThreadPool</code>。适用于为了满足资源管理的需求，而<strong><u>需要限制当前线程数量</u></strong>的应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors提供的API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>CachedThreadPool</code>。<strong><u>大小无界</u></strong>的线程池，适用于执行很多的<strong><u>短期异步任务</u></strong>的小程序，或者是负载较轻的服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors提供的API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li></ul><h6 id="1-2-2-2-ScheduledThreadPoolExecutor"><a href="#1-2-2-2-ScheduledThreadPoolExecutor" class="headerlink" title="1.2.2.2 ScheduledThreadPoolExecutor"></a>1.2.2.2 <code>ScheduledThreadPoolExecutor</code></h6><p><code>ScheduledThreadPoolExecutor</code>通常使用工厂类<code>Executors</code>来创建。Executors可以创建2种类型的<code>ScheduledThreadPoolExecutor</code>：</p><ul><li><p><code>ScheduledThreadPoolExecutor</code>。包含若干个线程的<code>ScheduledThreadPoolExecutor</code>。适用于<strong><u>需要多个后台线程执行周期任务</u></strong>，同时为了满足资源管理的需求而<strong><u>需要限制后台线程的数量</u></strong>的应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize,ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>SingleThreadScheduledExecutor</code>。只包含一个线程的<code>ScheduledThreadPoolExecutor</code>。适用于需要<strong><u>单个后台线程执行周期任务</u></strong>，同时<strong><u>需要保证顺序地执行各个任务</u></strong>的应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li></ul><h6 id="1-2-2-3-Future接口"><a href="#1-2-2-3-Future接口" class="headerlink" title="1.2.2.3 Future接口"></a>1.2.2.3 <code>Future</code>接口</h6><p><code>Future</code>接口和实现<code>Future</code>接口的<code>FutureTask</code>类用来表示异步计算的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span></span><br><span class="line"><span class="function">Future&lt;&gt; <span class="title">submit</span><span class="params">(Runnable task)</span></span></span><br></pre></td></tr></table></figure><p>把<code>Runnable</code>接口或<code>Callable</code>接口的实现类<strong><u>提交（submit）</u></strong>给<code>ThreadPoolExecutor</code>或<code>ScheduledThreadPoolExecutor</code>时，<code>ThreadPoolExecutor</code>或<code>ScheduledThreadPoolExecutor</code>会返回一个<code>FutureTask</code>对象。</p><h6 id="1-2-2-4-Runnable接口和Callable接口"><a href="#1-2-2-4-Runnable接口和Callable接口" class="headerlink" title="1.2.2.4 Runnable接口和Callable接口"></a>1.2.2.4 <code>Runnable</code>接口和<code>Callable</code>接口</h6><p>它们之间的区别是<code>Runnable</code><strong>不会返回结果</strong>，而<code>Callable</code><strong>可以返回结果</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把一个Runnable包装成一个Callable</span></span><br><span class="line"><span class="comment">// 当任务成功完成后FutureTask.get()方法将返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 把一个Runnable和一个待返回的结果包装成一个Callable</span></span></span><br><span class="line"><span class="function"><span class="comment">// 当任务成功完成后FutureTask.get()方法将返回result对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span></span></span><br></pre></td></tr></table></figure><h3 id="2-ThreadPoolExecutor详解"><a href="#2-ThreadPoolExecutor详解" class="headerlink" title="2. ThreadPoolExecutor详解"></a>2. <code>ThreadPoolExecutor</code>详解</h3><p><code>Executor</code>框架<strong>最核心</strong>的类是<code>ThreadPoolExecutor</code>，它是<strong><u>线程池的实现类</u></strong>，主要由下列4个组件构成。</p><ul><li><code>corePool</code>：核心线程池的大小。</li><li><code>maximumPool</code>：最大线程池的大小。</li><li><code>BlockingQueue</code>：用来暂时保存任务的工作队列。</li><li><code>RejectedExecutionHandler</code>：当<code>ThreadPoolExecutor</code>已经关闭或<code>ThreadPoolExecutor</code>已经饱和时，<code>execute()</code>方法将要调用的Handler。</li></ul><h4 id="2-1-FixedThreadPool详解"><a href="#2-1-FixedThreadPool详解" class="headerlink" title="2.1 FixedThreadPool详解"></a>2.1 <code>FixedThreadPool</code>详解</h4><p><code>FixedThreadPool</code>被称为<strong><u>可重用固定线程数</u></strong>的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>FixedThreadPool</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>都被设置为创建<code>FixedThreadPool</code>时指定的参数<code>nThreads</code>。</li><li>当线程池中的线程数大于<code>corePoolSize</code>时，<code>keepAliveTime</code>为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。这里把<code>keepAliveTime</code>设置为<code>0L</code>，意味着<strong><u>多余的空闲线程会被立即终止</u></strong>。</li></ul><p><code>FixedThreadPool</code>的<code>execute()</code>方法的运行流程如下：</p><ul><li>如果当前运行的线程数少于<code>corePoolSize</code>，则创建新线程来执行任务；</li><li>在线程池完成预热之后（当前运行的线程数等于<code>corePoolSize</code>），将任务加入 <code>LinkedBlockingQueue</code>。</li><li>线程执行完<code>1</code>中的任务后，会在循环中反复从<code>LinkedBlockingQueue</code>获取任务来执行。</li></ul><p><code>FixedThreadPool</code>使用<strong><u>无界队列</u></strong><code>LinkedBlockingQueue</code>作为线程池的工作队列（队列的容量为 <code>Integer.MAX_VALUE</code>）。使用无界队列作为工作队列会对线程池带来如下影响：</p><ol><li>当线程池中的线程数达到<code>corePoolSize</code>后，新任务将在无界队列中等待，因此线程池中的线程数不会超过<code>corePoolSize</code>。</li><li>使用无界队列时<code>maximumPoolSize</code>将是一个无效参数。使用无界队列时<code>keepAliveTime</code>将是一个无效参数。</li><li>由于使用无界队列，运行中的<code>FixedThreadPool</code>（未执行方法<code>shutdown()</code>或<code>shutdownNow()</code>）不会拒绝任务。</li></ol><h4 id="2-2-SingleThreadExecutor详解"><a href="#2-2-SingleThreadExecutor详解" class="headerlink" title="2.2 SingleThreadExecutor详解"></a>2.2 <code>SingleThreadExecutor</code>详解</h4><p><code>SingleThreadExecutor</code>是使用<strong><u>单个</u></strong><code>worker</code>线程的<code>Executor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>SingleThreadExecutor</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>被设置为<code>1</code>。</li><li><code>SingleThreadExecutor</code>使用无界队列<code>LinkedBlockingQueue</code>作为线程池的工作队列（队列的容量为<code>Integer.MAX_VALUE</code>）。</li></ul><h4 id="2-3-CachedThreadPool详解"><a href="#2-3-CachedThreadPool详解" class="headerlink" title="2.3 CachedThreadPool详解"></a>2.3 <code>CachedThreadPool</code>详解</h4><p><code>CachedThreadPool</code>是一个会根据需要创建新线程的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>CachedThreadPool</code>的<code>corePoolSize</code>被设置为<code>0</code>，即<code>corePool</code>为空；</li><li><code>maximumPoolSize</code>被设置为<code>Integer.MAX_VALUE</code>，即<code>maximumPool</code>是无界的。</li><li><p><code>keepAliveTime</code>设置为<code>60L</code>，意味着<code>CachedThreadPool</code>中的空闲线程等待新任务的最长时间为<code>60</code>秒，空闲线程超过<code>60</code>秒后将会被终止。</p></li><li><p><code>CachedThreadPool</code>使用<strong><u>没有容量</u></strong>的<code>SynchronousQueue</code>作为线程池的工作队列，但<code>CachedThreadPool</code>的<code>maximumPool</code>是无界的。</p><ul><li>如果主线程提交任务的速度高于<code>maximumPool</code>中线程处理任务的速度时，<code>CachedThreadPool</code>会不断创建新线程。</li><li>极端情况下，<code>CachedThreadPool</code>会<strong><u>因为创建过多线程而耗尽CPU和内存资源</u></strong>。</li></ul></li></ul><p><code>CachedThreadPool</code>的<code>execute()</code>方法的执行流程为：</p><ol><li>首先执行<code>SynchronousQueue.offer(Runnable task)</code>。如果当前<code>maximumPool</code>中有空闲线程正在执行<code>SynchronousQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>，那么主线程执行<code>offer</code>操作与空闲线程执行的<code>poll</code>操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code>方法执行完成；</li><li>当初始<code>maximumPool</code>为空，或者<code>maximumPool</code>中当前没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>。此时<code>CachedThreadPool</code>会创建一个新线程执行任务，<code>execute()</code>方法执行完成。</li><li>新创建的线程将任务执行完后，会执行 <code>SynchronousQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>。这个<code>poll</code>操作会让空闲线程最多在<code>SynchronousQueue</code>中等待<code>60</code>秒钟。<ul><li>如果<code>60</code>秒钟内主线程提交了一个新任务，那么这个空闲线程将执行主线程提交的新任务；</li><li>否则，这个空闲线程将终止。</li></ul></li></ol><h3 id="3-ScheduledThreadPoolExecutor详解"><a href="#3-ScheduledThreadPoolExecutor详解" class="headerlink" title="3. ScheduledThreadPoolExecutor详解"></a>3. <code>ScheduledThreadPoolExecutor</code>详解</h3><p><code>ScheduledThreadPoolExecutor</code>继承自<code>ThreadPoolExecutor</code>。主要用来在给定的延迟之后运行任务，或者定期执行任务。</p><h4 id="3-1-ScheduledThreadPoolExecutor的运行机制"><a href="#3-1-ScheduledThreadPoolExecutor的运行机制" class="headerlink" title="3.1 ScheduledThreadPoolExecutor的运行机制"></a>3.1 <code>ScheduledThreadPoolExecutor</code>的运行机制</h4><p><code>ScheduledThreadPoolExecutor</code>使用无界队列<code>DelayQueue</code>作为线程池的工作队列。执行主要分为两大部分：</p><ul><li>当调用<code>ScheduledThreadPoolExecutor</code>的<code>scheduleAtFixedRate()</code>方法或者<code>scheduleWithFixedDelay()</code>方法时，会向<code>ScheduledThreadPoolExecutor</code>的<code>DelayQueue</code>添加一个实现了<code>RunnableScheduledFutur</code>接口的<code>ScheduledFutureTask</code>。</li><li>线程池中的线程从<code>DelayQueue</code>中获取<code>ScheduledFutureTask</code>，然后执行任务。</li></ul><p>为了实现<strong><u>周期性</u></strong>的执行任务，<code>ScheduledThreadPoolExecutor</code>做了如下修改：</p><ul><li>使用<code>DelayQueue</code>作为任务队列。</li><li>获取任务的方式不同。</li><li>执行周期任务后，增加了额外的处理。</li></ul><h4 id="3-2-ScheduledThreadPoolExecutor的实现"><a href="#3-2-ScheduledThreadPoolExecutor的实现" class="headerlink" title="3.2 ScheduledThreadPoolExecutor的实现"></a>3.2 <code>ScheduledThreadPoolExecutor</code>的实现</h4><p><code>ScheduledFutureTask</code>主要包含3个成员变量：</p><ul><li><code>long</code>型成员变量<code>time</code>，表示这个任务将要被执行的具体时间。</li><li><code>long</code>型成员变量<code>sequenceNumber</code>，表示这个任务被添加到<code>ScheduledThreadPoolExecutor</code>中的序号。</li><li><code>long</code>型成员变量<code>period</code>，表示任务执行的间隔周期。</li></ul><p><code>DelayQueue</code>封装了一个<code>PriorityQueue</code>，这个<code>PriorityQueue</code>会对队列中的<code>ScheduledFutureTask</code>进行排序。</p><ul><li><code>time</code>小的排在前面。</li><li>如果两个<code>ScheduledFutureTask</code>的<code>time</code>相同，<code>sequenceNumber</code>小的排在前面。</li></ul><p><code>ScheduledThreadPoolExecutor</code>执行某个周期任务的4个步骤：</p><ol><li><p>工作线程从<code>DelayQueue</code>中获取已到期的<code>ScheduledFutureTask</code>（<code>DelayQueue.take()</code>）。到期任务是指<code>ScheduledFutureTask</code>的<strong><u><code>time</code>大于等于当前时间</u></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                available.await(); <span class="comment">// 2.1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> tl = available.awaitNanos(delay); <span class="comment">// 2.2</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    E x = q.poll(); <span class="comment">// 2.3.1</span></span><br><span class="line">                    <span class="keyword">assert</span> x != <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (q.size() != <span class="number">0</span>)</span><br><span class="line">                        available.signalAll(); <span class="comment">// 2.3.2</span></span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取任务分为3大步骤。</p><ul><li>获取<code>Lock</code>。</li><li>获取周期任务。<ul><li>如果<code>PriorityQueue</code>为空，当前线程到<code>Condition</code>中等待；</li><li>如果<code>PriorityQueue</code>的头元素的<code>time</code>时间比当前时间大，到<code>Condition</code>中等待到<code>time</code>时间；</li><li>获取<code>PriorityQueue</code>的头元素，如果<code>PriorityQueue</code>不为空，则唤醒在<code>Condition</code>中等待的所有线程。</li></ul></li><li>释放<code>Lock</code>。</li></ul></li></ol><ol><li>工作线程执行这个<code>ScheduledFutureTask</code>，并修改<code>ScheduledFutureTask</code>的<code>time</code>变量为下次将要被执行的时间。</li></ol><ol><li><p>工作线程把这个修改<code>time</code>之后的<code>ScheduledFutureTask</code>放回<code>DelayQueue</code>中（<code>DelayQueue.add()</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E first = q.peek();</span><br><span class="line">        q.offer(e); <span class="comment">// 2.1</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || e.compareTo(first) &lt; <span class="number">0</span>)</span><br><span class="line">            available.signalAll(); <span class="comment">// 2.2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加任务分为3大步骤：</p><ul><li>获取<code>Lock</code>。</li><li>添加任务。<ul><li>向<code>PriorityQueue</code>添加任务。</li><li>如果添加的任务是<code>PriorityQueue</code>的<strong>头元素</strong>，唤醒在<code>Condition</code>中等待的所有线程。</li></ul></li><li>释放<code>Lock</code>。</li></ul></li></ol><h3 id="4-FutureTask详解"><a href="#4-FutureTask详解" class="headerlink" title="4. FutureTask详解"></a>4. <code>FutureTask</code>详解</h3><h4 id="4-1-FutureTask简介"><a href="#4-1-FutureTask简介" class="headerlink" title="4.1 FutureTask简介"></a>4.1 <code>FutureTask</code>简介</h4><p><code>FutureTask</code>除了实现<code>Future</code>接口外，还实现了<code>Runnable</code>接口。因此，<code>FutureTask</code>可以交给<code>Executor</code>执行，也可以由调用线程直接执行（<code>FutureTask.run()</code>）。<code>FutureTask</code>可以处于下面3种状态：</p><ul><li><strong>未启动</strong>。当创建一 个<code>FutureTask</code>，<code>FutureTask.run()</code>方法还没有被执行之前，<code>FutureTask</code>处于未启动状态。</li><li><strong>已启动</strong>。<code>FutureTask.run()</code>方法被执行的过程中，<code>FutureTask</code>处于已启动状态。</li><li><strong>已完成</strong>。<code>FutureTask.run()</code>方法执行完后正常结束，或被取消（<code>FutureTask.cancel(…)</code>），或执行<code>FutureTask.run()</code>方法时抛出异常而异常结束，<code>FutureTask</code>处于已完成状态。</li></ul><p>不同状态下调用<code>FutureTask</code>方法的响应不同：</p><ul><li>当<code>FutureTask</code>处于<strong>未启动</strong>或<strong>已启动</strong>状态时，执行<code>FutureTask.get()</code>方法将导致调用线程阻塞；</li><li>当<code>FutureTask</code>处于<strong>已完成</strong>状态时，执行<code>FutureTask.get()</code>方法将导致调用线程立即返回结果或抛出异常。</li><li>当<code>FutureTask</code>处于<strong>未启动</strong>状态时，执行<code>FutureTask.cancel()</code>方法将导致此任务<strong><u>永远不会被执行</u></strong>；</li><li>当<code>FutureTask</code>处于<strong>已启动</strong>状态时，执行<code>FutureTask.cancel(true)</code>方法将以<strong><u>中断执行此任务线程</u></strong>的方式来试图停止任务；</li><li>当<code>FutureTask</code>处于<strong>已启动</strong>状态时，执行<code>FutureTask.cancel(false)</code>方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；</li><li>当<code>FutureTask</code>处于<strong>已完成</strong>状态时，执行<code>FutureTask.cancel(…)</code>方法将返回<code>false</code>。</li></ul><h4 id="4-2-FutureTask的使用"><a href="#4-2-FutureTask的使用" class="headerlink" title="4.2 FutureTask的使用"></a>4.2 <code>FutureTask</code>的使用</h4><p>当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行，此时可以使用<code>FutureTask</code>。</p><ul><li>可以把<code>FutureTask</code>交给<code>Executor</code>执行；</li><li>可以通过<code>ExecutorService.submit(…)</code>方法返回一个<code>FutureTask</code>，然后执行<code>FutureTask.get()</code>方法或<code>FutureTask.cancel(…)</code>方法；</li><li>也可以单独使用<code>FutureTask</code>。</li></ul><h4 id="4-3-FutureTask的实现"><a href="#4-3-FutureTask的实现" class="headerlink" title="4.3 FutureTask的实现"></a>4.3 <code>FutureTask</code>的实现</h4><p><code>FutureTask</code>的实现基于<code>AbstractQueuedSynchronizer</code>（<code>AQS</code>）：</p><ul><li><code>FutureTask</code>的<code>get()</code>/<code>get(long timeout, TimeUnit unit)</code>方法调用<code>AQS</code>的<code>acquire</code>操作。</li><li><code>FutureTask</code>的<code>run()</code>方法和<code>cancel(…)</code>方法调用<code>AQS</code>的<code>release</code>操作。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/FutureTask.PNG" alt="FutureTask的设计"></p><p><code>Sync</code>是<code>FutureTask</code>继承自<code>AQS</code>的<strong><u>内部私有类</u></strong>，实现了<code>tryAcquireShared(int)</code>方法和<code>tryReleaseShared(int)</code>方法，<code>Sync</code>通过这两个方法来检查和更新同步状态。</p><blockquote><p>需要注意的是，在<code>jdk 1.8</code>，不再基于<code>AQS</code>实现<code>FutureTask</code>：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Revision notes: This differs from previous versions of this</span></span><br><span class="line"><span class="comment"> * class that relied on AbstractQueuedSynchronizer, mainly to</span></span><br><span class="line"><span class="comment"> * avoid surprising users about retaining interrupt status during</span></span><br><span class="line"><span class="comment"> * cancellation races. Sync control in the current design relies</span></span><br><span class="line"><span class="comment"> * on a "state" field updated via CAS to track completion, along</span></span><br><span class="line"><span class="comment"> * with a simple Treiber stack to hold waiting threads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Style note: As usual, we bypass overhead of using</span></span><br><span class="line"><span class="comment"> * AtomicXFieldUpdaters and instead directly use Unsafe intrinsics.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></blockquote></blockquote><p><code>FutureTask.get()</code>方法执行过程为：</p><ol><li>调用<code>AQS.acquireSharedInterruptibly(int arg)</code>方法，这个方法首先会回调在子类Sync中实现的<code>tryAcquireShared()</code>方法来判断<code>acquire</code>操作是否可以成功。<ul><li><code>acquire</code>操作可以成功的条件为：<code>state</code>为<strong><u>执行完成</u></strong>状态<code>RAN</code>或<strong><u>已取消</u></strong>状态<code>CANCELLED</code>，且<code>runner</code>不为<code>null</code>。</li></ul></li><li>如果成功则<code>get()</code>方法立即返回。如果失败则到线程等待队列中去等待其他线程执行<code>release</code>操作。</li><li>当其他线程执行<code>release</code>操作唤醒当前线程后，当前线程再次执行<code>tryAcquireShared()</code>将返回正值<code>1</code>，当前线程将离开线程等待队列并唤醒它的后继线程。</li><li>最后返回计算的结果或抛出异常。</li></ol><p><code>FutureTask.run()</code>的执行过程如下：</p><ol><li>执行在构造函数中指定的任务（<code>Callable.call()</code>）。</li><li>以原子方式来更新同步状态（调用<code>AQS.compareAndSetState(int expect，int update)</code>，设置<code>state</code>为执行完成状态<code>RAN</code>）。如果这个原子操作成功，就设置代表计算结果的变量<code>result</code>的值为<code>Callable.call()</code>的返回值，然后调用<code>AQS.releaseShared(int arg)</code>。</li><li><code>AQS.releaseShared(int arg)</code>首先会回调在子类<code>Sync</code>中实现的<code>tryReleaseShared(arg)</code>来执行<code>release</code>操作（设置运行任务的线程<code>runner</code>为<code>null</code>，然会返回<code>true</code>）；然后唤醒线程等待队列中的第一个线程。</li><li>调用<code>FutureTask.done()</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Java的线程既是&lt;strong&gt;工作单元&lt;/strong&gt;，也是&lt;strong&gt;执行机制&lt;/strong&gt;。&lt;code&gt;JDK 5&lt;/code&gt;开始，把&lt;strong&gt;工作单元&lt;/strong&gt;与&lt;strong&gt;执行机制&lt;/strong&gt;分离开来，&lt;strong&gt;工作单元&lt;/strong&gt;包括&lt;code&gt;Runnable&lt;/code&gt;和&lt;code&gt;Callable&lt;/code&gt;，而执行机制由&lt;code&gt;Executor&lt;/code&gt;框架提供。&lt;br&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--9 Java中的线程池</title>
    <link href="https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-9-Java-thread-pool.html"/>
    <id>https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-9-Java-thread-pool.html</id>
    <published>2021-07-21T12:19:57.000Z</published>
    <updated>2021-07-21T12:19:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。<br><a id="more"></a></p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。使用线程池可以进行统一分配、调优和监控。</li></ul><h3 id="1-线程池的实现原理"><a href="#1-线程池的实现原理" class="headerlink" title="1. 线程池的实现原理"></a>1. 线程池的实现原理</h3><p>当提交一个新任务到线程池时，线程池的处理流程如下。</p><ul><li>线程池判断<u><strong>核心线程池是否已满</strong></u>。<ul><li>如果不是，则创建一个新的工作线程来执行任务。</li><li>如果是，则进入下个流程。</li></ul></li><li>线程池判断<strong><u>工作队列是否已经满</u></strong>。<ul><li>如果工作队列没有满，则将新提交的任务存储在这个工作队列里。</li><li>如果工作队列满了，则进入下个流程。</li></ul></li><li>线程池判断<strong><u>线程池是否已满</u></strong>。<ul><li>如果没有，则创建一个新的工作线程来执行任务。</li><li>如果已经满了，则交给饱和策略来处理这个任务。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter9/thradPoolFlow.PNG" alt="线程池的主要处理流程"></p><p><code>ThreadPoolExecutor</code>执行<code>execute()</code>方法有四种情况：</p><ol><li>如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（<strong><u>需要获取全局锁</u></strong>）。</li><li>如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li><li>如果无法将任务加入<code>BlockingQueue</code>（队列已满），则创建新的线程来处理任务（<strong><u>需要获取全局锁</u></strong>）。</li><li>如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并调用 <code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ol><p>在<code>ThreadPoolExecutor</code>完成预热之后（当前运行的线程数大于等于<code>corePoolSize</code>），几乎所有的<code>execute()</code>方法调用都是执行步骤<code>2</code>，而步骤<code>2</code>不需要获取全局锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="comment">// 如果线程数小于基本线程数，则创建线程并执行当前任务</span></span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line"><span class="comment">// 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span></span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，</span></span><br><span class="line"><span class="comment">// 则创建一个线程执行任务。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line"><span class="comment">// 抛出RejectedExecutionException异常</span></span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter9/thradPoolExecute.PNG" alt="ThreadPoolExecutor"></p><p>线程池创建线程时，会将线程封装成工作线程<code>Worker</code>，<code>Worker</code>在执行完任务后，还会循环获取工作队列里的任务来执行。线程池中的线程执行任务分两种情况。</p><ol><li>在<code>execute()</code>方法中创建一个线程时，会让这个线程执行当前任务。</li><li>这个线程执行完<code>1</code>的任务后，会反复从<code>BlockingQueue</code>获取任务来执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Worker类的run()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Runnable task = firstTask;</span><br><span class="line">        firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            runTask(task);task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        workerDone(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-线程池的使用"><a href="#2-线程池的使用" class="headerlink" title="2 线程池的使用"></a>2 线程池的使用</h3><h4 id="2-1-线程池的创建"><a href="#2-1-线程池的创建" class="headerlink" title="2.1 线程池的创建"></a>2.1 线程池的创建</h4><p>通过<code>ThreadPoolExecutor</code>来创建一个线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);</span><br></pre></td></tr></table></figure><p>输入几个参数介绍如下：</p><ul><li><code>corePoolSize</code>：线程池的基本大小。<ul><li>需要执行的任务数小于线程池基本大小时，即使其他空闲的基本线程能够执行新任务，线程池会先创建一个线程来执行任务。</li><li>如果调用了线程池的<code>prestartAllCoreThreads()</code>方法，线程池会<strong><u>提前</u></strong>创建并启动所有基本线程。</li></ul></li><li><code>runnableTaskQueue</code>：任务队列。用于保存等待执行的任务的阻塞队列。可以选择的阻塞队列有：<ul><li><code>ArrayBlockingQueue</code>；</li><li><code>LinkedBlockingQueue</code>。静态方法<code>Executors.newFixedThreadPool()</code>使用这个队列。</li><li><code>SynchronousQueue</code>。静态方法<code>Executors.newCachedThreadPool</code>使用这个队列。</li><li><code>PriorityBlockingQueue</code>。</li></ul></li><li><code>maximumPoolSize</code>：线程池允许创建的最大线程数。<ul><li>如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</li></ul></li><li><code>ThreadFactory</code>：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li><li><p><code>RejectedExecutionHandler</code>：饱和策略。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。策略默认情况下是<code>AbortPolicy</code>，表示无法处理新任务时抛出异常。Java线程池框架提供了以下4种策略。</p><ul><li><code>AbortPolicy</code>：直接抛出异常。</li><li><code>CallerRunsPolicy</code>：用调用者所在线程来运行任务。</li><li><code>DiscardOldestPolicy</code>：丢弃队列里最近的一个任务，并执行当前任务。</li><li><code>DiscardPolicy</code>：不处理，直接丢弃掉。</li><li>也可以实现<code>RejectedExecutionHandler</code>接口自定义策略</li></ul></li><li><p><code>keepAliveTime</code>：线程活动保持时间。线程池的工作线程空闲后，保持存活的时间。</p></li><li><code>TimeUnit</code>：线程活动保持时间的单位。可选的单位有<code>天（DAYS）</code>、<code>小时（HOURS）</code>、<code>分钟（MINUTES）</code>、<code>毫秒（MILLISECONDS）</code>、<code>微秒（MICROSECONDS）</code>和<code>纳秒（NANOSECONDS）</code>。</li></ul><h4 id="2-2-向线程池提交任务"><a href="#2-2-向线程池提交任务" class="headerlink" title="2.2 向线程池提交任务"></a>2.2 向线程池提交任务</h4><p>可以使用两个方法向线程池提交任务：</p><ul><li><p><code>execute()</code>方法。用于提交<u><strong>不需要返回值</strong></u>的任务，所以无法判断任务是否被线程池执行成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>submit()</code>方法。用于提交<u><strong>需要返回值</strong></u>的任务，线程池会返回一个<code>future</code>类型的对象，通过该<code>future</code>对象可以判断任务是否执行成功，并可以通过<code>future</code>的<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Object s = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 处理中断异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-关闭线程池"><a href="#2-3-关闭线程池" class="headerlink" title="2.3 关闭线程池"></a>2.3 关闭线程池</h4><p>通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。</p><blockquote><p>原理是<strong><u>遍历线程池中的工作线程</u></strong>，然后逐个调用线程的<code>interrupt</code>方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p></blockquote><ul><li><code>shutdownNow</code>首先将线程池的状态设置成<code>STOP</code>，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表；</li><li><p><code>shutdown</code>只是将线程池的状态设置成<code>SHUTDOWN</code>状态，然后中断所有<strong><u>没有正在执行任务</u></strong>的线程。</p></li><li><p>只要调用了关闭方法，<code>isShutdown</code>方法就会返回<code>true</code>。</p></li><li><p>当所有的任务都已关闭后，才表示线程池关闭成功，这时调用<code>isTerminaed</code>方法会返回<code>true</code>。</p></li></ul><h4 id="2-4-合理地配置线程池"><a href="#2-4-合理地配置线程池" class="headerlink" title="2.4 合理地配置线程池"></a>2.4 合理地配置线程池</h4><ul><li>性质不同的任务可以用不同规模的线程池分开处理。</li><li>优先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理。</li><li>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</li><li><strong><u>建议使用有界队列</u></strong>。有界队列能增加系统的稳定性和预警能力。</li></ul><h4 id="2-5-线程池的监控"><a href="#2-5-线程池的监控" class="headerlink" title="2.5 线程池的监控"></a>2.5 线程池的监控</h4><p>可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。</p><ul><li><code>taskCount</code>：线程池需要执行的任务数量。</li><li><code>completedTaskCount</code>：线程池在运行过程中已完成的任务数量，小于或等于<code>taskCount</code>。</li><li><code>largestPoolSize</code>：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。</li><li><code>getPoolSize</code>：线程池的线程数量。<u>如果线程池不销毁的话，线程池里的线程不会自动销毁</u>，所以这个大小<strong><u>只增不减</u></strong>。</li><li><code>getActiveCount</code>：获取活动的线程数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。&lt;br&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--8 Java中的并发工具类</title>
    <link href="https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-8-Java-concurrent-tools.html"/>
    <id>https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-8-Java-concurrent-tools.html</id>
    <published>2021-07-21T09:14:21.000Z</published>
    <updated>2021-07-21T09:14:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>CountDownLatch</code>、<code>CyclicBarrier</code>和<code>Semaphore</code>工具类提供了一种<strong><u>并发流程控制</u></strong>的手段，<code>Exchanger</code>工具类则提供了在<strong><u>线程间交换数据</u></strong>的一种手段。<br><a id="more"></a></p></blockquote><h3 id="1-等待多线程完成的CountDownLatch"><a href="#1-等待多线程完成的CountDownLatch" class="headerlink" title="1. 等待多线程完成的CountDownLatch"></a>1. 等待多线程完成的<code>CountDownLatch</code></h3><p>要实现主线程等待所有线程完成操作，最简单的做法是使用<code>join()</code>方法。<code>join</code>用于让当前执行线程等待<code>join</code>线程执行结束。原理是不停检查<code>join</code>线程是否存活，如果<code>join</code>线程存活则让当前线程永远等待。<code>join</code>线程中止后，线程的<code>this.notifyAll()</code>方法会被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CountDownLatch</code>允许一个或多个线程等待其他线程完成操作，比<code>join</code>的功能更多。</p><ul><li><code>CountDownLatch</code>的构造函数接收一个<code>int</code>类型的参数作为计数器，表示需要等待<code>N</code>个点完成。</li><li>调用<code>CountDownLatch</code>的<code>countDown</code>方法时，<code>N</code>就会减<code>1</code>；</li><li><code>CountDownLatch</code>的<code>await</code>方法会阻塞当前线程，直到<code>N</code>变成零。</li></ul><blockquote><p>由于<code>countDown</code>方法可以用在<strong><u>任何地方</u></strong>，所以这里说的<code>N</code>个点，可以是<code>N</code>个线程，也可以是<code>1</code>个线程里的<code>N</code>个执行步骤。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        c.await();</span><br><span class="line">        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-同步屏障CyclicBarrier"><a href="#2-同步屏障CyclicBarrier" class="headerlink" title="2. 同步屏障CyclicBarrier"></a>2. 同步屏障<code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code>的字面意思是<strong><u>可循环使用（Cyclic）</u></strong>的<u><strong>屏障（Barrier）</strong></u>。让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><h4 id="2-1-CyclicBarrier简介"><a href="#2-1-CyclicBarrier简介" class="headerlink" title="2.1 CyclicBarrier简介"></a>2.1 <code>CyclicBarrier</code>简介</h4><p><code>CyclicBarrier</code>默认的构造方法是<code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉<code>CyclicBarrier</code>我已经到达了屏障，然后当前线程被阻塞。</p><p><code>CyclicBarrier</code>还提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行<code>barrierAction</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment"> * given number of parties (threads) are waiting upon it, and which</span></span><br><span class="line"><span class="comment"> * will execute the given barrier action when the barrier is tripped,</span></span><br><span class="line"><span class="comment"> * performed by the last thread entering the barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties the number of threads that must invoke &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment"> *        before the barrier is tripped</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> barrierAction the command to execute when the barrier is</span></span><br><span class="line"><span class="comment"> *        tripped, or &#123;<span class="doctag">@code</span> null&#125; if there is no action</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties&#125; is less than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment"> * given number of parties (threads) are waiting upon it, and</span></span><br><span class="line"><span class="comment"> * does not perform a predefined action when the barrier is tripped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties the number of threads that must invoke &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment"> *        before the barrier is tripped</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties&#125; is less than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>CyclicBarrier</code>可以用于<u><strong>多线程计算数据，最后合并计算结果的场景</strong></u>。</p></blockquote><h4 id="2-2-CyclicBarrier和CountDownLatch的区别"><a href="#2-2-CyclicBarrier和CountDownLatch的区别" class="headerlink" title="2.2 CyclicBarrier和CountDownLatch的区别"></a>2.2 <code>CyclicBarrier</code>和<code>CountDownLatch</code>的区别</h4><p><code>CountDownLatch</code>的计数器只能使用一次，<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置。<code>CyclicBarrier</code>还提供其他有用的方法：</p><ul><li><code>getNumberWaiting</code>方法可以获得<code>CyclicBarrier</code>阻塞的线程数量。</li><li><code>isBroken()</code>方法用来了解阻塞的线程是否被中断。</li></ul><h3 id="3-控制并发线程数的Semaphore"><a href="#3-控制并发线程数的Semaphore" class="headerlink" title="3. 控制并发线程数的Semaphore"></a>3. 控制并发线程数的<code>Semaphore</code></h3><p><code>Semaphore（信号量）</code>是用来控制<strong><u>同时访问特定资源的线程数量</u></strong>，它通过协调各个线程，以保证合理的使用公共资源。</p><h4 id="3-1-应用场景"><a href="#3-1-应用场景" class="headerlink" title="3.1 应用场景"></a>3.1 应用场景</h4><p><code>Semaphore</code>可以用于做<strong><u>流量控制</u></strong>，特别是公用资源有限的应用场景，比如数据库连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println(<span class="string">"save data"</span>);</span><br><span class="line">                        s.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-其他方法"><a href="#3-2-其他方法" class="headerlink" title="3.2 其他方法"></a>3.2 其他方法</h4><ul><li><code>intavailablePermits()</code>：返回此信号量中当前可用的许可证数。</li><li><code>intgetQueueLength()</code>：返回正在等待获取许可证的线程数。</li><li><code>booleanhasQueuedThreads()</code>：是否有线程正在等待获取许可证。</li><li><code>void reducePermits(int reduction)</code>：减少<code>reduction</code>个许可证，是个<code>protected</code>方法。</li><li><code>Collection getQueuedThreads()</code>：返回所有等待获取许可证的线程集合，是个<code>protected</code>方法。</li></ul><h3 id="4-线程间交换数据的Exchanger"><a href="#4-线程间交换数据的Exchanger" class="headerlink" title="4. 线程间交换数据的Exchanger"></a>4. 线程间交换数据的<code>Exchanger</code></h3><p><code>Exchanger（交换者）</code>是一个用于<strong><u>线程间协作</u></strong>的工具类。<code>Exchanger</code>用于进行<strong><u>线程间的数据交换</u></strong>。</p><ul><li>它提供一个<code>同步点</code>，在这个同步点，两个线程通过<code>exchange</code>方法交换彼此的数据，如果第一个线程先执行<code>exchange()</code>方法，它会一直等待第二个线程也执行<code>exchange</code>方法；</li><li>当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方；</li><li>可以使用<code>exchange(V x，longtimeout，TimeUnit unit)</code>设置最大等待时长。</li></ul><h4 id="4-1-应用场景"><a href="#4-1-应用场景" class="headerlink" title="4.1 应用场景"></a>4.1 应用场景</h4><ul><li><code>Exchanger</code>可以用于<strong><u>遗传算法</u></strong>，遗传算法里需要选出两个人作为配对对象，这时候会交换两人的数据。</li><li><code>Exchanger</code>也可以用于<strong><u>校对工作</u></strong>。如对两份录入数据进行校对，看看是否录入一致。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String A = <span class="string">"银行流水A"</span>; <span class="comment">// A录入银行流水数据</span></span><br><span class="line">                    String B = exgr.exchange(A);</span><br><span class="line">                    System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span>+ A + <span class="string">"，B录入是："</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String B = <span class="string">"银行流水B"</span>; <span class="comment">// B录入银行流水数据</span></span><br><span class="line">                    String A = exgr.exchange(<span class="string">"B"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span>+ A + <span class="string">"，B录入是："</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;CyclicBarrier&lt;/code&gt;和&lt;code&gt;Semaphore&lt;/code&gt;工具类提供了一种&lt;strong&gt;&lt;u&gt;并发流程控制&lt;/u&gt;&lt;/strong&gt;的手段，&lt;code&gt;Exchanger&lt;/code&gt;工具类则提供了在&lt;strong&gt;&lt;u&gt;线程间交换数据&lt;/u&gt;&lt;/strong&gt;的一种手段。&lt;br&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--7 Java中的13个原子操作类</title>
    <link href="https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-7-Java-atomic-class.html"/>
    <id>https://wuyunjie.top/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-7-Java-atomic-class.html</id>
    <published>2021-07-21T08:06:12.000Z</published>
    <updated>2021-07-21T08:06:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>java.util.concurrent.atomic</code>包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。<code>Atomic</code>包里的类基本都是<u>使用<code>Unsafe</code>实现的包装类</u>。<br><a id="more"></a></p></blockquote><h3 id="1-原子更新基本类型类"><a href="#1-原子更新基本类型类" class="headerlink" title="1. 原子更新基本类型类"></a>1. 原子更新基本类型类</h3><p><code>Atomic</code>包提供了3个类更新基本类型：</p><ul><li><code>AtomicBoolean</code>：原子更新布尔类型。</li><li><code>AtomicInteger</code>：原子更新整型。</li><li><code>AtomicLong</code>：原子更新长整型。</li></ul><p>以上3个类提供的方法几乎一模一样，常用方法有：</p><ul><li><p><code>int addAndGet(int delta)</code>：以原子方式将输入的数值与实例中的值（<code>AtomicInteger</code>里的<code>value</code>）相加，并返回结果。</p></li><li><p><code>boolean compareAndSet(int expect，int update)</code>：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>int getAndIncrement()</code>：以原子方式将当前值加<code>1</code>，返回的是自增前的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk 1.8 实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>void lazySet(int newValue)</code>：最终会设置成<code>newValue</code>，使用<code>lazySet</code>设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</p></li><li><p><code>int getAndSet(int newValue)</code>：以原子方式设置为<code>newValue</code>的值，并返回旧值。</p></li></ul><p><code>Atomic</code>包里的类基本都是使用<code>Unsafe</code>实现的。<code>Unsafe</code>只提供了<code>3</code>种<code>CAS</code>方法，<code>AtomicBoolean</code>先把<code>Boolean</code>转换成<strong>整型</strong>，再使用<code>compareAndSwapInt</code>进行<code>CAS</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果当前数值是expected，则原子的将Java变量更新成x</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果更新成功则返回true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object expected, Object x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> expected, <span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-原子更新数组"><a href="#2-原子更新数组" class="headerlink" title="2. 原子更新数组"></a>2. 原子更新数组</h3><p>Atomic包提供了4个类更新数组里的某个元素：</p><ul><li><code>AtomicIntegerArray</code>：原子更新整型数组里的元素。</li><li><code>AtomicLongArray</code>：原子更新长整型数组里的元素。</li><li><code>AtomicReferenceArray</code>：原子更新引用类型数组里的元素。</li><li><code>AtomicBooleanArray</code> ：原子更新布尔类型数组的元素。</li></ul><p>其常用方法如下：</p><ul><li><p><code>int addAndGet(int i，int delta)</code>：以原子方式将输入值与数组中索引<code>i</code>的元素相加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getAndAdd(i, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index "</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.getAndAddInt(array, checkedByteOffset(i), delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>boolean compareAndSet(int i，int expect，int update)</code>：如果当前值等于预期值，则以原子方式将数组位置<code>i</code>的元素设置成<code>update</code>值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>基于已有数组创建<code>AtomicIntegerArray</code>对象时，构造函数会将当前数组复制一份，所以当<code>AtomicIntegerArray</code>对内部的数组元素进行修改时，不会影响原数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Visibility guaranteed by final field guarantees</span></span><br><span class="line">    <span class="keyword">this</span>.array = array.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-原子更新引用类型"><a href="#3-原子更新引用类型" class="headerlink" title="3. 原子更新引用类型"></a>3. 原子更新引用类型</h3><p>Atomic包提供了3个类原子更新引用类型：</p><ul><li><p><code>AtomicReference</code>：原子更新引用类型。</p></li><li><p><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段。</p></li><li><code>AtomicMarkableReference</code>：原子更新带有标记位的引用类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更新的仅仅只是引用，引用的对象并未改变。</p></blockquote><h3 id="4-原子更新字段类"><a href="#4-原子更新字段类" class="headerlink" title="4. 原子更新字段类"></a>4. 原子更新字段类</h3><p>Atomic包提供了3个类进行原子字段更新。</p><ul><li><code>AtomicIntegerFieldUpdater</code>：原子更新整型的字段的更新器。</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器。</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。可以解决使用<code>CAS</code>进行原子更新时可能出现的<code>ABA</code>问题。</li></ul><p>原子地更新字段类需要两步。</p><ul><li>第一步，必须使用静态方法<code>newUpdater()</code>创建一个更新器，并且需要设置想要更新的类和属性。</li><li>第 二步，更新类的字段（属性）必须使用<code>public volatile</code>修饰符。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建原子更新器，并设置需要更新的对象类和对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.</span><br><span class="line">        newUpdater(User.class, "old");</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置柯南的年龄是10岁</span></span><br><span class="line">        User conan = <span class="keyword">new</span> User(<span class="string">"conan"</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 柯南长了一岁，但是仍然会输出旧的年龄</span></span><br><span class="line">        System.out.println(a.getAndIncrement(conan));</span><br><span class="line">        <span class="comment">// 输出柯南现在的年龄</span></span><br><span class="line">        System.out.println(a.get(conan));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> old;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.old = old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt;包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。&lt;code&gt;Atomic&lt;/code&gt;包里的类基本都是&lt;u&gt;使用&lt;code&gt;Unsafe&lt;/code&gt;实现的包装类&lt;/u&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--6 Java并发容器和框架</title>
    <link href="https://wuyunjie.top/2021/07/20/JavaLearning_The_art_of_concurrent_programming_in_Java-6-Java-concurrent-container-and-framework.html"/>
    <id>https://wuyunjie.top/2021/07/20/JavaLearning_The_art_of_concurrent_programming_in_Java-6-Java-concurrent-container-and-framework.html</id>
    <published>2021-07-20T12:56:06.000Z</published>
    <updated>2021-07-20T12:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>并发编程大师Doug Lea不遗余力地为Java开发者提供了非常多的并发容器和框架</code><br><a id="more"></a></p></blockquote><h3 id="1-ConcurrentHashMap的实现原理"><a href="#1-ConcurrentHashMap的实现原理" class="headerlink" title="1. ConcurrentHashMap的实现原理"></a>1. <code>ConcurrentHashMap</code>的实现原理</h3><p>在并发编程中使用<code>HashMap</code>可能导致程序死循环，而使用线程安全的<code>HashTable</code>效率又非常低下。<code>ConcurrentHashMap</code>是线程安全且高效的<code>HashMap</code>。</p><ul><li><strong>线程不安全的<code>HashMap</code></strong>。在多线程环境下，使用<code>HashMap</code>进行<code>put</code>操作会引起死循环。</li><li><p><strong>效率低下的<code>HashTable</code></strong>。<code>HashTable</code>容器使用<code>synchronized</code>来保证线程安全，但在线程竞争激烈的情况下<code>HashTable</code>的效率非常低下。</p></li><li><p><code>ConcurrentHashMap</code>的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p></li></ul><h4 id="1-1-ConcurrentHashMap的结构"><a href="#1-1-ConcurrentHashMap的结构" class="headerlink" title="1.1 ConcurrentHashMap的结构"></a>1.1 <code>ConcurrentHashMap</code>的结构</h4><p><code>ConcurrentHashMap</code>是由<code>Segment</code>数组结构和<code>HashEntry</code>数组结构组成。</p><ul><li><code>Segment</code>是一种<strong>可重入锁</strong>（<code>ReentrantLock</code>），一个<code>ConcurrentHashMap</code>里包含一个<code>Segment</code>数组；<ul><li><code>Segment</code>的结构和<code>HashMap</code>类似，是一种<strong>数组和链表结构</strong>；</li><li>一个<code>Segment</code>里包含一个<code>HashEntry</code>数组，每个<code>Segment</code>守护着一个<code>HashEntry</code>数组里的元素，当对<code>HashEntry</code>数组的数据进行修改时，必须首先获得与它对应的<code>Segment</code>锁。</li></ul></li><li><code>HashEntry</code>则用于存储键值对数据，每个<code>HashEntry</code>是一个<strong>链表结构</strong>的元素。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentHashMapClass.PNG" alt="ConcurrentHashMap类图"></p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentHashMapStructure.PNG" alt="ConcurrentHashMap结构"></p><h4 id="1-2-ConcurrentHashMap的初始化"><a href="#1-2-ConcurrentHashMap的初始化" class="headerlink" title="1.2 ConcurrentHashMap的初始化"></a>1.2 <code>ConcurrentHashMap</code>的初始化</h4><p><code>ConcurrentHashMap</code>初始化方法是通过<code>initialCapacity</code>、<code>loadFactor</code>和<code>concurrencyLevel</code>等几个参数来初始化<code>segment</code>数组、段偏移量<code>segmentShift</code>、段掩码<code>segmentMask</code>和每个<code>segment</code>里的<code>HashEntry</code>数组来实现的。</p><h5 id="1-2-1-初始化segments数组"><a href="#1-2-1-初始化segments数组" class="headerlink" title="1.2.1 初始化segments数组"></a>1.2.1 初始化<code>segments</code>数组</h5><p><code>segments</code>数组的长度<code>ssize</code>是通过<code>concurrencyLevel</code>计算得出的：</p><ul><li>为了能通过<code>按位与的散列算法</code>来定位<code>segments</code>数组的索引，必须保证<code>segments</code>数组的长度是<code>2</code>的<code>N</code>次方，所以必须计算出一个大于或等于<code>concurrencyLevel</code>的最小的2的N次方值来作为<code>segments</code>数组的长度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure><h5 id="1-2-2-初始化segmentShift和segmentMask"><a href="#1-2-2-初始化segmentShift和segmentMask" class="headerlink" title="1.2.2 初始化segmentShift和segmentMask"></a>1.2.2 初始化<code>segmentShift</code>和<code>segmentMask</code></h5><p>这两个全局变量需要在定位<code>segment</code>时的散列算法里使用：</p><ul><li><code>sshift</code>等于<code>ssize</code>从1向左移位的次数。<code>segmentShift</code>用于<u><strong>定位参与散列运算的位数</strong></u>，<code>segmentShift</code>等于<code>32</code>减<code>sshift</code>，这里之所以用32是因为<code>ConcurrentHashMap</code>里的<code>hash()</code>方法输出的最大数是32位的。</li><li><code>segmentMask</code>是散列运算的掩码，等于<code>ssize</code>减<code>1</code>，掩码的二进制各个位的值都是<code>1</code>。</li></ul><h5 id="1-2-3-初始化每个segment"><a href="#1-2-3-初始化每个segment" class="headerlink" title="1.2.3 初始化每个segment"></a>1.2.3 初始化每个<code>segment</code></h5><p>输入参数<code>initialCapacity</code>是<code>ConcurrentHashMap</code>的<strong>初始化容量</strong>，<code>loadfactor</code>是每个<code>segment</code>的<strong>负载因子</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">++c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line"><span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);</span><br></pre></td></tr></table></figure><ul><li>变量<code>cap</code>是<code>segment</code>里<code>HashEntry</code>数组的长度，它等于<code>initialCapacity</code>除以<code>ssize</code>的倍数<code>c</code>。</li><li><code>segment</code>的容量<code>threshold＝（int）cap*loadFactor</code>。</li></ul><h4 id="1-3-定位Segment"><a href="#1-3-定位Segment" class="headerlink" title="1.3 定位Segment"></a>1.3 定位<code>Segment</code></h4><p>在<strong>插入和获取</strong>元素的时候，必须先通过散列算法定位到<code>Segment</code>。</p><ul><li><code>ConcurrentHashMap</code>会首先使用<code>Wang/Jenkins hash</code>的变种算法对元素的<code>hashCode</code>进行一次再散列。目的是<strong><u>减少散列冲突</u></strong>，使元素能够均匀地分布在不同的<code>Segment</code>上， 从而提高容器的存取效率。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种再散列能让数字的每一位都参加到散列运算当中，从而减少散列冲突。<code>ConcurrentHashMap</code>通过以下散列算法定位<code>segment</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-ConcurrentHashMap的操作"><a href="#1-4-ConcurrentHashMap的操作" class="headerlink" title="1.4 ConcurrentHashMap的操作"></a>1.4 <code>ConcurrentHashMap</code>的操作</h4><h5 id="1-4-1-get操作"><a href="#1-4-1-get操作" class="headerlink" title="1.4.1 get操作"></a>1.4.1 <code>get</code>操作</h5><p><code>Segment</code>的<code>get</code>操作先经过一次再散列，然后使用这个散列值通过散列运算定位到<code>Segment</code>，再通过散列算法定位到元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line"><span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get</code>操作的高效之处在于<u><strong>整个<code>get</code>过程不需要加锁，除非读到的值是空才会加锁重读</strong></u>。</p><ul><li><p><code>get</code>方法里将要使用的共享变量都定义成<code>volatile</code>类型，如用于统计当前<code>Segement</code>大小的<code>count</code>字段和用于存储值的<code>HashEntry</code>的<code>value</code>。这是用volatile替换锁的经典应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">volatile</span> V value;</span><br></pre></td></tr></table></figure></li><li><p>定位<code>Segment</code>使用的是元素的<code>hashcode</code>通过再散列后得到的值的高位，而定位<code>HashEntry</code>直接使用的是再散列后的值。其目的是避免两次散列后的值一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask <span class="comment">// 定位Segment所使用的hash算法</span></span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); <span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="1-4-2-put操作"><a href="#1-4-2-put操作" class="headerlink" title="1.4.2 put操作"></a>1.4.2 <code>put</code>操作</h5><p><code>put</code>方法首先定位到<code>Segment</code>，然后在<code>Segment</code>里进行插入操作。插入操作需要经历两个步骤</p><ul><li>第一步判断是否需要对<code>Segment</code>里的<code>HashEntry</code>数组进行扩容；<ul><li>在<strong><u>插入元素前</u></strong>先判断<code>Segment</code>里的<code>HashEntry</code>数组是否超过<code>容量（threshold）</code>，如果超过阈值，则对数组进行扩容。扩容的时候首先会创建一个容量是<strong><u>原来容量两倍</u></strong>的数组，然后将原数组里的元素进行<u><strong>再散列后插入</strong></u>到新的数组里。</li><li><code>HashMap</code>是在<strong><u>插入元素后</u></strong>判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时<code>HashMap</code>就进行了一次无效的扩容。</li></ul></li><li>第二步定位添加元素的位置，然后将其放在<code>HashEntry</code>数组里。</li></ul><h5 id="1-4-3-size操作"><a href="#1-4-3-size操作" class="headerlink" title="1.4.3 size操作"></a>1.4.3 <code>size</code>操作</h5><p><code>ConcurrentHashMap</code>统计<code>size</code>时，先尝试<code>2</code>次通过<strong>不锁住</strong><code>Segment</code>的方式来统计各个<code>Segment</code>大小，如果统计的过程中，容器的<code>count</code>发生了变化，则再采用<strong>加锁</strong>的方式来统计所有<code>Segment</code>的大小。</p><h3 id="2-ConcurrentLinkedQueue"><a href="#2-ConcurrentLinkedQueue" class="headerlink" title="2. ConcurrentLinkedQueue"></a>2. <code>ConcurrentLinkedQueue</code></h3><p>实现一个线程安全的队列有两种方式：</p><ul><li><strong>使用阻塞算法</strong>。用一个<strong>锁</strong>（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</li><li><strong>使用非阻塞算法</strong>。使用循环<code>CAS</code>的方式来实现。</li></ul><p><code>ConcurrentLinkedQueue</code>是一个基于链接节点的<strong>无界线程安全队列</strong>。它采用了<code>“wait-free”算法</code>（即<code>CAS</code>算法）来实现。</p><h4 id="2-1-ConcurrentLinkedQueue的结构"><a href="#2-1-ConcurrentLinkedQueue的结构" class="headerlink" title="2.1 ConcurrentLinkedQueue的结构"></a>2.1 <code>ConcurrentLinkedQueue</code>的结构</h4><p><code>ConcurrentLinkedQueue</code>由<code>head</code>节点和<code>tail</code>节点组成。</p><ul><li>每个节点（Node）由节点元素（item）和 指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一 张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail = head;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentLinkedQueueClass.PNG" alt="ConcurrentLinkedQueue类图"></p><h4 id="2-2-入队列"><a href="#2-2-入队列" class="headerlink" title="2.2 入队列"></a>2.2 入队列</h4><h5 id="2-2-1-入队列的过程"><a href="#2-2-1-入队列的过程" class="headerlink" title="2.2.1 入队列的过程"></a>2.2.1 入队列的过程</h5><p>入队列就是将入队节点添加到队列的尾部。入队主要做两件事情：</p><ul><li>将<strong>入队节点</strong>设置成当前队列尾节点的下一个节点；</li><li>更新<code>tail</code>节点，如果<code>tail</code>节点的<code>next</code>节点不为空，则将入队节点设置成<code>tail</code>节点，如果<code>tail</code>节点的<code>next</code>节点为空，则将入队节点设置成<code>tail</code>的<code>next</code>节点，<u><strong>所以<code>tail</code>节点不总是尾节点</strong></u>。</li></ul><p>多个线程同时进行入队操作时，使用<code>CAS</code>算法来入队：</p><ul><li>首先定位出尾节点；</li><li>然后使用<code>CAS</code>算法将入队节点设置成尾节点的<code>next</code>节点，如不成功则重试。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 入队前，创建一个入队节点</span></span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    </span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 死循环，入队不成功反复入队。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 创建一个指向tail节点的引用</span></span><br><span class="line">        Node&lt;E&gt; t = tail;</span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class="line">        Node&lt;E&gt; p = t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">            <span class="comment">// 获得p节点的下一个节点。</span></span><br><span class="line">            Node&lt;E&gt; next = succ(p);</span><br><span class="line">            <span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;</span><br><span class="line">                <span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</span></span><br><span class="line"><span class="comment">                  更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt;= HOPS)</span><br><span class="line">                    casTail(t, n); <span class="comment">// 更新tail节点，允许失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = succ(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>入队方法永远返回<code>true</code>，所以不要通过返回值判断入队是否成功。</p></blockquote><h5 id="2-2-2-定位尾节点"><a href="#2-2-2-定位尾节点" class="headerlink" title="2.2.2 定位尾节点"></a>2.2.2 定位尾节点</h5><p><code>tail</code>节点并不总是尾节点，所以每次入队都必须先通过<code>tail</code>节点来找到尾节点。</p><blockquote><p>尾节点可能是<code>tail</code>节点，也可能是<code>tail</code>节点的<code>next</code>节点。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">Node&lt;E&gt; next = p.getNext();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取tail节点的next节点需要注意的是 p 节点等于 p 的 next 节点的情况，</span></span><br><span class="line"><span class="comment">     * 此时p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-设置入队节点为尾节点"><a href="#2-2-3-设置入队节点为尾节点" class="headerlink" title="2.2.3 设置入队节点为尾节点"></a>2.2.3 设置入队节点为尾节点</h5><p><code>p.casNext(null，n)</code>方法用于将入队节点设置为当前队列尾节点的<code>next</code>节点：</p><ul><li>如果<code>p</code>是<code>null</code>， 表示<code>p</code>是当前队列的尾节点；</li><li>如果不为<code>null</code>，表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</li></ul><h5 id="2-2-4-HOPS的设计"><a href="#2-2-4-HOPS的设计" class="headerlink" title="2.2.4 HOPS的设计"></a>2.2.4 <code>HOPS</code>的设计</h5><p>使用<code>hops</code>变量来<strong><u>控制并减少<code>tail</code>节点的更新频率</u></strong>。</p><ul><li>不是每次节点入队后都将<code>tail</code>节点更新成尾节点，而是当<code>tail</code>节点和尾节点的距离大于等于常量<code>HOPS</code>的值（默认等于1）时才更新<code>tail</code>节点。<strong><u><code>tail</code>和尾节点的距离越长，使用<code>CAS</code>更新<code>tail</code>节点的次数就会越少</u></strong>；</li><li>但是距离越长带来的<strong>负面效果</strong>就是<u>每次入队时定位尾节点的时间就越长</u>，因为循环体需要多循环一次来定位出尾节点。但是这样仍然能提高入队的效率，因为<u><strong>通过增加对<code>volatile</code>变量的读操作来减少对<code>volatile</code>变量的写操作</strong></u>，而对volatile变量的写操作开销要远远大于读操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOPS = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="2-3-出队列"><a href="#2-3-出队列" class="headerlink" title="2.3 出队列"></a>2.3 出队列</h4><p><strong>出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用</strong>。与入队列类似，<u>不是每次出队时都更新<code>head</code>节点</u>，通过<code>hops</code>变量来减少使用<code>CAS</code>更新<code>head</code>节点的消耗。</p><ul><li>当<code>head</code>节点里<strong>有元素</strong>时，直接弹出<code>head</code>节点里的元素，而不会更新<code>head</code>节点。</li><li>只有当<code>head</code>节点里<strong>没有元素</strong>时，出队操作才会更新<code>head</code> 节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">// p表示头节点，需要出队的节点</span></span><br><span class="line">    Node&lt;E&gt; p = h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">        <span class="comment">// 获取p节点的元素</span></span><br><span class="line">        E item = p.getItem();</span><br><span class="line">        <span class="comment">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</span></span><br><span class="line">        <span class="comment">// 如果成功则返回p节点的元素。</span></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hops &gt;= HOPS) &#123;</span><br><span class="line">                <span class="comment">// 将p节点下一个节点设置成head节点</span></span><br><span class="line">                Node&lt;E&gt; q = p.getNext();</span><br><span class="line">                updateHead(h, (q != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</span></span><br><span class="line">        <span class="comment">// 一个线程修改了。那么获取p节点的下一个节点</span></span><br><span class="line">        Node&lt;E&gt; next = succ(p);</span><br><span class="line">        <span class="comment">// 如果p的下一个节点也为空，说明这个队列已经空了</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 更新头节点。</span></span><br><span class="line">            updateHead(h, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span></span><br><span class="line">        p = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个线程同时进行出队操作时，使用<code>CAS</code>算法来出队：</p><ul><li>首先获取<strong>头节点的元素</strong>，然后判断<strong>头节点元素</strong>是否为空；</li><li>如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走；</li><li>如果不为空，则使用<code>CAS</code>的方式将头节点的引用设置成<code>null</code>；<ul><li>如果<code>CAS</code>成功，则直接返回头节点的元素；</li><li>如果不成功，表示另外一个线程已经进行了一次出队操作更新了<code>head</code>节点，需要重新获取头节点。</li></ul></li></ul><h3 id="3-Java中的阻塞队列"><a href="#3-Java中的阻塞队列" class="headerlink" title="3. Java中的阻塞队列"></a>3. Java中的阻塞队列</h3><h4 id="3-1-阻塞队列介绍"><a href="#3-1-阻塞队列介绍" class="headerlink" title="3.1 阻塞队列介绍"></a>3.1 阻塞队列介绍</h4><p><code>阻塞队列（BlockingQueue）</code>支持阻塞的插入和移除方法。</p><ul><li><strong>支持阻塞的插入方法</strong>：当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li><li><strong>支持阻塞的移除方法</strong>：在队列为空时，获取元素的线程会等待队列变为非空。</li></ul><p>在阻塞队列不可用时，这两个附加操作提供了4种处理方式：</p><ul><li><strong>抛出异常</strong>：当队列满时，如果再往队列里插入元素，会抛出<code>IllegalStateException(&quot;Queue full&quot;)</code>异常。当队列空时，从队列里获取元素会抛出<code>NoSuchElementException</code>异常。主要方法有：<code>add(e), remove(), element()</code>。</li><li><strong>返回特殊值</strong>：当往队列插入元素时，会返回元素是否插入成功，成功返回<code>true</code>。如果是移除方法，则是从队列里取出一个元素，如果没有则返回<code>null</code>。主要方法有：<code>offer(e), poll(), peek()</code>。</li><li><strong>一直阻塞</strong>：当阻塞队列满时，如果生产者线程往队列里<code>put</code>元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里<code>take</code>元素，队列会阻塞住消费者线程，直到队列不为空。主要方法有：<code>put(e), take()</code>。</li><li><strong>超时退出</strong>：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。主要方法有：<code>offer(e, time, unit), poll(time, unit)</code>。</li></ul><blockquote><p>无界阻塞队列<strong>不可能会出现满</strong>的情况，所以使用<code>put</code>或<code>offer</code>方法永远不会被阻塞，而且使用<code>offer</code>方法时，该方法永远返回<code>true</code>。</p></blockquote><h4 id="3-2-Java里的阻塞队列"><a href="#3-2-Java里的阻塞队列" class="headerlink" title="3.2 Java里的阻塞队列"></a>3.2 Java里的阻塞队列</h4><p><code>JDK 7</code>提供了<code>7</code>个阻塞队列。</p><h5 id="3-2-1-ArrayBlockingQueue"><a href="#3-2-1-ArrayBlockingQueue" class="headerlink" title="3.2.1 ArrayBlockingQueue"></a>3.2.1 <code>ArrayBlockingQueue</code></h5><p>一个由<strong><u>数组结构</u></strong>组成的<strong>有界</strong>阻塞队列，默认情况下不保证线程公平的访问队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-2-LinkedBlockingQueue"><a href="#3-2-2-LinkedBlockingQueue" class="headerlink" title="3.2.2 LinkedBlockingQueue"></a>3.2.2 <code>LinkedBlockingQueue</code></h5><p>一个由<strong><u>链表结构</u></strong>组成的<strong>有界</strong>阻塞队列。此队列的默认和最大长度为<code>Integer.MAX_VALUE</code>。</p><h5 id="3-2-3-PriorityBlockingQueue"><a href="#3-2-3-PriorityBlockingQueue" class="headerlink" title="3.2.3 PriorityBlockingQueue"></a>3.2.3 <code>PriorityBlockingQueue</code></h5><p>一个<strong><u>支持优先级排序</u></strong>的<strong>无界</strong>阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现<code>compareTo()</code>方法来指定元素排序规则，或者初始化<code>PriorityBlockingQueue</code>时，指定构造参数<code>Comparator</code>来对元素进行排序。</p><blockquote><p>不能保证同优先级元素的顺序。</p></blockquote><h5 id="3-2-4-DelayQueue"><a href="#3-2-4-DelayQueue" class="headerlink" title="3.2.4 DelayQueue"></a>3.2.4 <code>DelayQueue</code></h5><p>一个使用<u><strong>优先级队列(<code>PriorityQueue</code>)</strong></u>实现的<strong>无界</strong>阻塞队列，支持<strong><u>延时获取元素</u></strong>。</p><ul><li>队列中的元素必须实现<code>Delayed</code>接口，在创建元素时可以指定多久才能从队列中获取当前元素。</li><li>只有在延迟期满时才能从队列中提取元素。</li></ul><h6 id="3-2-4-1-Delayed接口实现"><a href="#3-2-4-1-Delayed接口实现" class="headerlink" title="3.2.4.1 Delayed接口实现"></a>3.2.4.1 <code>Delayed</code>接口实现</h6><p>参考<code>ScheduledThreadPoolExecutor</code>里<code>ScheduledFutureTask</code>类的实现。</p><ul><li>第一步：在对象创建的时候，初始化基本数据。使用<code>time</code>记录当前对象延迟到什么时候可以使用，使用<code>sequenceNumber</code>来标识元素在队列中的先后顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二步：实现<code>getDelay</code>方法，该方法返回当前元素还需要延时多长时间，单位是纳秒。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三步：实现<code>compareTo</code>方法来指定元素的顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero ONLY if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;&gt; x = (ScheduledFutureTask&lt;&gt;)other;</span><br><span class="line">        <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// othter 不是 ScheduledFutureTask 对象时</span></span><br><span class="line">    <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) - other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">    <span class="keyword">return</span> (d == <span class="number">0</span>) ? <span class="number">0</span> : ( (d &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-2-4-2-实现延时阻塞队列"><a href="#3-2-4-2-实现延时阻塞队列" class="headerlink" title="3.2.4.2 实现延时阻塞队列"></a>3.2.4.2 实现延时阻塞队列</h6><p>当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> q.poll();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">    available.await();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    Thread thisThread = Thread.currentThread();</span><br><span class="line">    leader = thisThread;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        available.awaitNanos(delay);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>leader</code>是一个<u><strong>等待获取队列头部元素的线程</strong></u>。</p><ul><li>如果<code>leader</code>不等于空，表示<u>已经有线程在等待获取队列的头元素</u>。使用<code>await()</code>方法让当前线程等待信号；</li><li>如果<code>leader</code>等于空，则把当前线程设置成<code>leader</code>，并使用<code>awaitNanos()</code>方法让当前线程等待接收信号或等待<code>delay</code>时间。</li></ul><h6 id="3-2-4-3-DelayQueue应用场景"><a href="#3-2-4-3-DelayQueue应用场景" class="headerlink" title="3.2.4.3 DelayQueue应用场景"></a>3.2.4.3 <code>DelayQueue</code>应用场景</h6><ul><li><strong>缓存系统的设计</strong>：用<code>DelayQueue</code>保存缓存元素的<u>有效期</u>，使用一个线程循环查询<code>DelayQueue</code>，一旦能从<code>DelayQueue</code>中获取元素时，表示缓存有效期到了。</li><li><strong>定时任务调度</strong>：使用<code>DelayQueue</code>保存当天将会执行的任务和执行时间，一旦从<code>DelayQueue</code>中获取到任务就开始执行，比如<code>TimerQueue</code>就是使用<code>DelayQueue</code>实现的。</li></ul><h5 id="3-2-5-SynchronousQueue"><a href="#3-2-5-SynchronousQueue" class="headerlink" title="3.2.5 SynchronousQueue"></a>3.2.5 <code>SynchronousQueue</code></h5><p>一个<strong><u>不存储元素</u></strong>的阻塞队列。每一个<code>put</code>操作<strong><u>必须等待</u></strong>一个<code>take</code>操作， 否则不能继续添加元素。默认情况下线程采用非公平性策略访问队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">transferer = fair ? <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列本身并不存储任何元素，非常适合传递性场景。</p><ul><li><code>SynchronousQueue</code>的吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>。</li></ul><h5 id="3-2-6-LinkedTransferQueue"><a href="#3-2-6-LinkedTransferQueue" class="headerlink" title="3.2.6 LinkedTransferQueue"></a>3.2.6 <code>LinkedTransferQueue</code></h5><p>一个由<strong><u>链表结构</u></strong>组成的<strong>无界</strong>阻塞队列。<code>LinkedTransferQueue</code>增加了<code>tryTransfer</code>和<code>transfer</code>方法。</p><ol><li><p><code>transfer</code>方法</p><ul><li>如果当前有消费者正在等待接收元素，<code>transfer</code>方法可以把生产者传入的元素立刻<code>transfer</code>（传输）给消费者。</li><li>如果没有消费者在等待接收元素，<code>transfer</code>方法会将元素存放在队列的<code>tail</code>节点，并等到该元素被消费者消费了才返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试图把存放当前元素的s节点作为tail节点</span></span><br><span class="line">Node pred = tryAppend(s, haveData);</span><br><span class="line"><span class="comment">// 让CPU自旋等待消费者消费元素</span></span><br><span class="line"><span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br></pre></td></tr></table></figure></li><li><p><code>tryTransfer</code>方法</p><p>用来试探生产者传入的元素是否能直接传给消费者。</p><ul><li>如果没有消费者等待接收元素，则返回<code>false</code>；</li><li><code>tryTransfer</code>方法无论消费者是否接收，方法<u><strong>立即返回</strong></u>；<code>transfer</code>方法是<u><strong>必须等到消费者消费了才返回</strong></u>。</li><li>带有时间限制的<code>tryTransfer(E e, long timeout, TimeUnit unit)</code>方法，如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false；如果在超时时间内消费了元素，则返回true。</li></ul></li></ol><h5 id="3-2-7-LinkedBlockingDeque"><a href="#3-2-7-LinkedBlockingDeque" class="headerlink" title="3.2.7 LinkedBlockingDeque"></a>3.2.7 <code>LinkedBlockingDeque</code></h5><p>一个由<strong><u>链表结构</u></strong>组成的<strong><u>双向</u></strong>阻塞队列。在初始化<code>LinkedBlockingDeque</code>时可以设置容量防止其过度膨胀。</p><blockquote><p>双向阻塞队列可以运用在<code>“工作窃取”模式</code>中。</p></blockquote><h4 id="3-3-阻塞队列的实现"><a href="#3-3-阻塞队列的实现" class="headerlink" title="3.3 阻塞队列的实现"></a>3.3 阻塞队列的实现</h4><p>使用<strong><u>通知模式</u></strong>实现阻塞队列。如<code>ArrayBlockingQueue</code>使用了<code>Condition</code>来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        insert(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> extract();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    putIndex = inc(putIndex);</span><br><span class="line">    ++count;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞生产者主要通过 <code>LockSupport.park(this)</code>来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程加入等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步状态，也就是释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 调用setBlocker先保存一下将要阻塞的线程</span></span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    <span class="comment">// 调用unsafe.park阻塞当前线程</span></span><br><span class="line">    unsafe.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unsafe.park是个native方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure><p><code>park</code>方法会阻塞当前线程，只有以下4种情况中的一种发生时，该方法才会返回：</p><ul><li>与<code>park</code>对应的<code>unpark</code>执行或已经执行时。<code>“已经执行”</code>是指<u><code>unpark</code>先执行，然后再执行<code>park</code></u>的情况。</li><li>线程被中断时。</li><li>等待完<code>time</code>参数指定的毫秒数时。</li><li>异常现象发生时，这个异常现象没有任何原因。</li></ul><p><code>Linux</code>下使用的是系统方法<code>pthread_cond_wait</code>实现<code>park</code>方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> os::PlatformEvent::park() &#123;</span><br><span class="line">    <span class="keyword">int</span> v ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        v = _Event ;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg (v<span class="number">-1</span>, &amp;_Event, v) == v) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    guarantee (v &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// Do this the hard way by blocking ...</span></span><br><span class="line">        <span class="keyword">int</span> status = pthread_mutex_lock(_mutex);</span><br><span class="line">        assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_lock"</span>);</span><br><span class="line">        guarantee(_nParked == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">        ++ _nParked;</span><br><span class="line">        <span class="keyword">while</span> (_Event &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// pthread_cond_wait是一个多线程的条件变量函数</span></span><br><span class="line">            status = pthread_cond_wait(_cond, _mutex);</span><br><span class="line"><span class="comment">// for some reason, under 2.7 lwp_cond_wait() may return ETIME ...</span></span><br><span class="line"><span class="comment">// Treat this the same as if the wait was interrupted</span></span><br><span class="line">            <span class="keyword">if</span> (status == ETIME) &#123; status = EINTR; &#125;</span><br><span class="line">            assert_status(status == <span class="number">0</span> || status == EINTR, status, <span class="string">"cond_wait"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        -- _nParked ;</span><br><span class="line"><span class="comment">// In theory we could move the ST of 0 into _Event past the unlock(),</span></span><br><span class="line"><span class="comment">// but then we'd need a MEMBAR after the ST.</span></span><br><span class="line">        _Event = <span class="number">0</span> ;</span><br><span class="line">        status = pthread_mutex_unlock(_mutex);</span><br><span class="line">        assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_unlock"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    guarantee (_Event &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Fork-Join框架"><a href="#4-Fork-Join框架" class="headerlink" title="4. Fork/Join框架"></a>4. Fork/Join框架</h3><h4 id="4-1-Fork-Join框架介绍"><a href="#4-1-Fork-Join框架介绍" class="headerlink" title="4.1 Fork/Join框架介绍"></a>4.1 Fork/Join框架介绍</h4><p><code>Fork/Join框架</code>是<code>Java 7</code>提供的一个<strong><u>用于并行执行任务</u></strong>的框架。它<u>把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果</u>。</p><ul><li><code>Fork</code>就是把一个大任务切分为若干子任务并行的执行；</li><li><code>Join</code>就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li></ul><h4 id="4-2-工作窃取算法"><a href="#4-2-工作窃取算法" class="headerlink" title="4.2 工作窃取算法"></a>4.2 工作窃取算法</h4><p><code>工作窃取（work-stealing）</code>算法是指<u><strong>某个线程从其他队列里窃取任务来执行</strong></u>。</p><ul><li>把大任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。</li><li>但某个线程先完成自己队列里的任务，而其他线程对应的队列里还有任务等待处理，它会去其他线程的队列里窃取一个任务来执行。</li><li>为了减少窃取任务线程和被窃取任务线程之间的竞争，通常使用<strong><u>双端队列</u></strong>，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</li></ul><p><strong>工作窃取算法的优点</strong>：充分利用线程进行并行计算，减少了线程间的竞争。</p><p><strong>工作窃取算法的缺点</strong>：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。且会消耗更多的系统资源。</p><h4 id="4-3-Fork-Join框架的设计"><a href="#4-3-Fork-Join框架的设计" class="headerlink" title="4.3 Fork/Join框架的设计"></a>4.3 Fork/Join框架的设计</h4><p>Fork/Join框架主要有两个步骤：</p><ul><li><strong>步骤1 分割任务</strong>。首先需要一个<code>fork类</code>来把大任务分割成子任务。</li><li><strong>步骤2 执行任务并合并结果</strong>。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。<u>子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据</u>。</li></ul><blockquote><p>很像<code>MapReduce</code>算法，都是任务分解(Map)，然后聚合结果(Reduce)</p></blockquote><p><code>Fork/Join</code>使用两个类来完成以上两件事情：</p><ul><li><code>ForkJoinTask</code>：首先创建一个<code>ForkJoin</code>任务。它提供在任务中执行<code>fork()</code>和<code>join()</code>操作的机制。一般不需要直接继承<code>ForkJoinTask</code>类，<strong>Fork/Join框架</strong>提供了两个子类。<ul><li><code>RecursiveAction</code>：用于<strong><u>没有返回结果</u></strong>的任务。</li><li><code>RecursiveTask</code>：用于<strong><u>有返回结果</u></strong>的任务。</li></ul></li><li><code>ForkJoinPool</code>：<code>ForkJoinTask</code>需要通过<code>ForkJoinPool</code>来执行。</li></ul><h4 id="4-4-使用Fork-Join框架"><a href="#4-4-使用Fork-Join框架" class="headerlink" title="4.4 使用Fork/Join框架"></a>4.4 使用Fork/Join框架</h4><p><code>ForkJoinTask</code>需要实现<code>compute</code>方法，在这个方法里首先需要判断任务是否足够小：</p><ul><li>如果足够小就直接执行任务。</li><li>如果不足够小，就必须分割成两个子任务，每个子任务在调用<code>fork</code>方法时，又会进入<code>compute</code>方法。</li></ul><p>使用<code>join</code>方法会等待子任务执行完并得到其结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>; <span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-Fork-Join框架的异常处理"><a href="#4-5-Fork-Join框架的异常处理" class="headerlink" title="4.5 Fork/Join框架的异常处理"></a>4.5 Fork/Join框架的异常处理</h4><p><code>ForkJoinTask</code>提供了<code>isCompletedAbnormally()</code>方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过<code>ForkJoinTask</code>的<code>getException</code>方法获取异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(task.isCompletedAbnormally()) &#123;</span><br><span class="line">System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-6-Fork-Join框架的实现"><a href="#4-6-Fork-Join框架的实现" class="headerlink" title="4.6 Fork/Join框架的实现"></a>4.6 Fork/Join框架的实现</h4><p><code>ForkJoinPool</code>由<code>ForkJoinTask</code>数组和<code>ForkJoinWorkerThread</code>数组组成：</p><ul><li><code>ForkJoinTask</code>数组负责将存放程序提交给<code>ForkJoinPool</code>的任务；</li><li><code>ForkJoinWorkerThread</code>数组负责执行这些任务。</li></ul><h5 id="4-6-1-ForkJoinTask的fork方法"><a href="#4-6-1-ForkJoinTask的fork方法" class="headerlink" title="4.6.1 ForkJoinTask的fork方法"></a>4.6.1 ForkJoinTask的fork方法</h5><p>调用<code>ForkJoinTask</code>的<code>fork</code>方法时</p><ul><li>首先调用<code>ForkJoinWorkerThread</code>的<code>pushTask</code>方法<strong><u>异步地执行</u></strong>这个任务。</li><li><code>pushTask</code>方法把当前任务存放在<code>ForkJoinTask</code>数组队列里。然后再调用<code>ForkJoinPool</code>的<code>signalWork()</code>方法唤醒或创建一个工作线程来执行任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">((ForkJoinWorkerThread) Thread.currentThread()).pushTask(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pushTask</span><span class="params">(ForkJoinTask&lt;&gt; t)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;&gt;[] q; </span><br><span class="line">    <span class="keyword">int</span> s, m;</span><br><span class="line">    <span class="keyword">if</span> ((q = queue) != <span class="keyword">null</span>) &#123; <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="comment">// 计算t放到队列中的位置，即u</span></span><br><span class="line">        <span class="keyword">long</span> u = (((s = queueTop) &amp; (m = q.length - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="comment">// 加入队列</span></span><br><span class="line">        UNSAFE.putOrderedObject(q, u, t);</span><br><span class="line">        queueTop = s + <span class="number">1</span>; <span class="comment">// or use putOrderedInt</span></span><br><span class="line">        <span class="comment">// 激活或创建工作线程</span></span><br><span class="line">        <span class="keyword">if</span> ((s -= queueBase) &lt;= <span class="number">2</span>)</span><br><span class="line">            pool.signalWork();</span><br><span class="line">        <span class="comment">// 队列已满</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == m)</span><br><span class="line">            growQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-6-2-ForkJoinTask的join方法"><a href="#4-6-2-ForkJoinTask的join方法" class="headerlink" title="4.6.2 ForkJoinTask的join方法"></a>4.6.2 ForkJoinTask的join方法</h5><p><code>Join</code>方法的主要作用是阻塞当前线程并等待获取结果。</p><ul><li>首先通过<code>doJoin()</code>方法得到当前任务的状态。任务状态有4种：<code>已完成（NORMAL）</code>、<code>被取消（CANCELLED）</code>、<code>信号（SIGNAL）</code>和<code>出现异常（EXCEPTIONAL）</code>。<ul><li>如果任务状态是已完成，则直接返回任务状态；</li><li>如果没有执行完，则从任务数组里取出任务并执行；</li><li>如果任务顺利执行完成，则设置任务状态为<code>NORMAL</code>；</li><li>如果出现异常，则记录异常，并将任务状态设置为<code>EXCEPTIONAL</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (doJoin() != NORMAL)</span><br><span class="line">        <span class="keyword">return</span> reportResult();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t; ForkJoinWorkerThread w; <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                completed = exec();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (completed)</span><br><span class="line">                <span class="keyword">return</span> setCompletion(NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w.joinTask(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> externalAwaitDone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">reportResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Throwable ex;</span><br><span class="line">    <span class="comment">// 如果任务状态是被取消，则直接抛出CancellationException</span></span><br><span class="line">    <span class="keyword">if</span> ((s = status) == CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="comment">// 如果任务状态是抛出异常，则直接抛出对应的异常</span></span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.throwException(ex);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;并发编程大师Doug Lea不遗余力地为Java开发者提供了非常多的并发容器和框架&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--5 Java中的锁</title>
    <link href="https://wuyunjie.top/2021/07/19/JavaLearning_The_art_of_concurrent_programming_in_Java-5-Java-lock.html"/>
    <id>https://wuyunjie.top/2021/07/19/JavaLearning_The_art_of_concurrent_programming_in_Java-5-Java-lock.html</id>
    <published>2021-07-19T14:37:39.000Z</published>
    <updated>2021-07-19T14:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。</code><br><a id="more"></a></p></blockquote><h3 id="1-Lock接口"><a href="#1-Lock接口" class="headerlink" title="1. Lock接口"></a>1. Lock接口</h3><p><code>Java SE 5</code>之后，<strong>并发包</strong>中新增了<code>Lock</code>接口（以及相关实现类）用来实现锁功能。</p><ul><li>提供了与<code>synchronized</code>关键字类似的同步功能，在使用时需要<strong>显式地</strong>获取和释放锁。</li><li>拥有<strong>锁获取与释放</strong>的<code>可操作性</code>、<code>可中断的获取锁</code>以及<code>超时获取锁</code>等多种synchronized关键字所不具备的同步特性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 保证在获取到锁之后，最终能够被释放</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/LockFeature.PNG" alt="Lock接口提供的主要特性"></p><p>Lock接口定义了锁获取和释放的基本操作：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/LockAPI.PNG" alt="Lock API"></p><h3 id="2-队列同步器"><a href="#2-队列同步器" class="headerlink" title="2. 队列同步器"></a>2. 队列同步器</h3><p>队列同步器<code>AbstractQueuedSynchronizer</code>，是用来构建锁或者其他同步组件的基础框架。</p><blockquote><p>使用了一个i<strong>nt成员变量</strong>表示<code>同步状态</code>，通过内置的<code>FIFO</code>队列来完成<u>资源获取线程的排队工作</u>。</p></blockquote><p>子类通过继承同步器并实现它的抽象方法来管理同步状态，同步器提供3个方法对同步状态进行更改，保证状态的改变是安全的：</p><ul><li><code>getState()</code>，获取当前同步状态；</li><li><code>setState(int newState)</code>，设置当前同步状态；</li><li><code>compareAndSetState(int expect, int update)</code>，使用CAS设置当前状态，该方法能够保证状态设置的<strong>原子性</strong>。</li></ul><p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义：</p><ul><li>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；</li><li>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</li></ul><h4 id="2-1-队列同步器的接口与示例"><a href="#2-1-队列同步器的接口与示例" class="headerlink" title="2.1 队列同步器的接口与示例"></a>2.1 队列同步器的接口与示例</h4><p>使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法。同步器可重写的方法如下：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/AQSMethod.PNG" alt="同步器可重写的方法"></p><p>同步器提供的模板方法基本上分为3类：</p><ul><li><p>独占式获取与释放同步状态；</p></li><li><p>共享式获取与释放同步状态；</p></li><li>查询同步队列中的等待线程情况。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/AQSMethodTemplate.PNG" alt="同步器提供的模板方法"></p><p><code>独占锁</code>是<u><strong>在同一时刻只能有一个线程获取到锁</strong>，而其他获取锁的线程只能处于同步队列中等待</u>，只有获取锁的线程释放了锁，后继的线程才能够获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类，自定义同步器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否处于占用状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当状态为0的时候获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁，将状态设置为0</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅需要将操作代理到Sync上即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用户使用<code>Mutex</code>时并不会直接和内部同步器的实现打交道，而是调用<code>Mutex</code>提供的方法；</li><li>在Mutex的实现中，只需要在方法实现中调用同步器的模板方法即可，当前线程调用该方法获取同步状态失败后会被加入到同步队列中等待。</li></ul><h4 id="2-2-队列同步器的实现"><a href="#2-2-队列同步器的实现" class="headerlink" title="2.2 队列同步器的实现"></a>2.2 队列同步器的实现</h4><h5 id="2-2-1-同步队列"><a href="#2-2-1-同步队列" class="headerlink" title="2.2.1 同步队列"></a>2.2.1 同步队列</h5><p>同步器依赖内部的同步队列来完成<strong>同步状态的管理</strong>：</p><ul><li>当前线程获取同步状态失败时，同步器会将<strong><u>当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列</u></strong>，同时会阻塞当前线程；</li><li>当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/AQSNode.PNG" alt="同步队列中的节点（Node）"></p><p>同步器拥有<code>首节点（head）</code>和<code>尾节点（tail）</code>，没有成功获取同步状态的线程将会成为节点加入该队列的尾部。</p><ul><li>同步器提供了一个基于<code>CAS</code>的设置尾节点的方法：<code>compareAndSetTail(Node expect, Node update)</code>，需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</li><li>首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是<u><strong>通过获取同步状态成功的线程来完成的</strong></u>，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/SynchronizedQueue.PNG" alt="同步队列"></p><h5 id="2-2-2-独占式同步状态获取与释放"><a href="#2-2-2-独占式同步状态获取与释放" class="headerlink" title="2.2.2 独占式同步状态获取与释放"></a>2.2.2 独占式同步状态获取与释放</h5><p>同步器的<code>acquire(int arg)</code>方法可以获取同步状态，该方法对中断不敏感。主要完成<strong>同步状态获取</strong>、<strong>节点构造</strong>、<strong>加入同步队列</strong>以及<strong>在同步队列中自旋等待</strong>的相关工作。</p><ul><li>首先调用自定义同步器实现的<code>tryAcquire(int arg)</code>方法，该方法保证<strong>线程安全的获取同步状态</strong>；</li><li>如果同步状态获取失败，则构造同步节点（独占式<code>Node.EXCLUSIVE</code>，同一时刻只能有一个线程成功获取同步状态）；</li><li>通过<code>addWaiter(Node node)</code> 方法将该节点加入到同步队列的尾部；</li><li>最后调用<code>acquireQueued(Node node, int arg)</code>方法，使得该节点以<strong>“死循环”</strong>的方式获取同步状态；</li><li>如果获取不到则<u><strong>阻塞节点中的线程</strong></u>，而被阻塞线程的<strong>唤醒</strong><u>主要依靠前驱节点的出队或阻塞线程被中断来实现</u>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 快速尝试在尾部添加</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用 compareAndSetTail 方法来确保节点能够被线程安全添加</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">    pred.next = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同步器通过“死循环”来保证节点的正确添加</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// 通过CAS将节点设置成为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">            tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点进入同步队列之后，就进入了一个自旋的过程</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 只有前驱节点是头节点才能够尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/acquireFlow.PNG" alt="独占式同步状态获取流程"></p><p>同步器的<code>release(int arg)</code>方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// unparkSuccessor(Node node)方法使用LockSupport来唤醒处于等待状态的线程。</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-共享式同步状态获取与释放"><a href="#2-2-3-共享式同步状态获取与释放" class="headerlink" title="2.2.3 共享式同步状态获取与释放"></a>2.2.3 共享式同步状态获取与释放</h5><p><strong>共享式获取</strong>与<strong>独占式获取</strong>最主要的区别：<u><strong>在于同一时刻能否有多个线程同时获取到同步状态</strong></u>。</p><ul><li>共享式访问资源时，<u>其他<strong>共享式</strong>的访问均被允许</u>，而<strong>独占式</strong>访问被阻塞；</li><li>独占式访问资源时，同一时刻其他访问均被阻塞。</li></ul><p>同步器的<code>acquireShared(int arg)</code>方法可以共享式地获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquireShared 方法尝试获取同步状态，</span></span><br><span class="line">    <span class="comment">// tryAcquireShared 方法返回值为int类型，</span></span><br><span class="line">    <span class="comment">// 当返回值大于等于0时，表示能够获取到同步状态</span></span><br><span class="line"><span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果当前节点的前驱为头节点时，尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 获取同步状态成功，从自旋过程中退出</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            setHeadAndPropagate(node, r);</span><br><span class="line">            p.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用<code>releaseShared(int arg)</code>方法可以释放同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryReleaseShared 必须确保同步状态（或者资源数）线程安全释放，</span></span><br><span class="line">    <span class="comment">// 一般是通过循环和CAS来保证的</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-4-独占式超时获取同步状态"><a href="#2-2-4-独占式超时获取同步状态" class="headerlink" title="2.2.4 独占式超时获取同步状态"></a>2.2.4 独占式超时获取同步状态</h5><p>同步器的<code>doAcquireNanos(int arg, long nanosTimeout)</code>方法可以超时获取同步状态，<code>doAcquireNanos</code>方法在<strong><u>支持响应中断</u></strong>的基础上，增加了<u><strong>超时获取</strong></u>的特性。</p><ul><li><strong>支持响应中断</strong>。在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出<code>InterruptedException</code>。</li><li><strong>超时获取</strong>。即在指定的时间段内获取同步状态，如果获取到同步状态则返回<code>true</code>；否则，返回<code>false</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> lastTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 计算时间，当前时间now减去睡眠之前的时间lastTime得到已经睡眠</span></span><br><span class="line">            <span class="comment">// 的时间delta，然后被原有超时时间nanosTimeout减去，得到了</span></span><br><span class="line">            <span class="comment">// 还应该睡眠的时间</span></span><br><span class="line">            nanosTimeout -= now - lastTime;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/doAcquireNanosFlow.PNG" alt="独占式超时获取同步状态流程"></p><h5 id="2-2-5-自定义同步组件——TwinsLock"><a href="#2-2-5-自定义同步组件——TwinsLock" class="headerlink" title="2.2.5 自定义同步组件——TwinsLock"></a>2.2.5 自定义同步组件——<code>TwinsLock</code></h5><p><code>TwinsLock</code>要求在同一时刻，只允许<strong><u>至多两个</u></strong>线程同时访问，超过两个线程的访问将被阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count must large than zero."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current - reduceCount;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> returnCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current + returnCount;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步器作为一个桥梁，连接<strong>线程访问</strong>以及<strong>同步状态控制</strong>等底层技术与不同并发组件的接口语义。</p><h3 id="3-重入锁"><a href="#3-重入锁" class="headerlink" title="3 重入锁"></a>3 重入锁</h3><p>重入锁<code>ReentrantLock</code>，即支持重进入的锁，该锁能够支持<u><strong>一个线程对资源的重复加锁</strong></u>。</p><ul><li>在调用<code>lock()</code>方法时，<strong>已经获取到锁</strong>的线程，能够<strong>再次调用</strong><code>lock()</code>方法获取锁而<u>不被阻塞</u>。</li></ul><p>该锁的还支持获取锁时的公平和非公平性选择。</p><ul><li>在<strong>绝对时间</strong>上，先对锁进行获取的请求一定先被满足，那么这个锁是<code>公平</code>的；</li><li>反之，是<code>不公平</code>的。</li></ul><h4 id="3-1-实现重进入"><a href="#3-1-实现重进入" class="headerlink" title="3.1 实现重进入"></a>3.1 实现重进入</h4><p>重进入是指<u><strong>任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞</strong></u>：</p><ul><li><strong>线程再次获取锁</strong>。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</li><li><strong>锁的最终释放</strong>。线程重复<code>n</code>次获取了锁，随后在第<code>n</code>次释放该锁后，其他线程能够获取到该锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 再次获取同步状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 将同步状态值进行增加并返回true，表示获取同步状态成功</span></span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在释放同步状态时减少同步状态值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-公平与非公平获取锁"><a href="#3-2-公平与非公平获取锁" class="headerlink" title="3.2 公平与非公平获取锁"></a>3.2 公平与非公平获取锁</h4><ul><li>对于非公平锁，<code>nonfairTryAcquire</code>方法，只要<code>CAS</code>设置同步状态成功，则表示当前线程获取了锁；</li><li>对于公平锁，<code>tryAcquire</code>方法为判断条件增加了<code>hasQueuedPredecessors()</code>方法，判断同步队列中当前节点是否有前驱节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察公平和非公平锁在获取锁时的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairAndUnfairTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock fairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock unfairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//    @Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(fairLock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    @Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(unfairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动10个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Job w = <span class="keyword">new</span> Job(lock);</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FairAndUnfairTest test = <span class="keyword">new</span> FairAndUnfairTest();</span><br><span class="line">        test.testLock(fairLock);</span><br><span class="line"><span class="comment">//        test.testLock(unfairLock);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Lock lock;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.print(<span class="string">"Lock by ["</span> + Thread.currentThread().getName() + <span class="string">"], Waiting by ["</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Thread t : ((ReentrantLock2) lock).getQueuedThreads()) &#123;</span><br><span class="line">                    System.out.print(t.getName() + <span class="string">", "</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"]"</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock2</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            List&lt;Thread&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="keyword">super</span>.getQueuedThreads());</span><br><span class="line">            Collections.reverse(arrayList);</span><br><span class="line">            <span class="keyword">return</span> arrayList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平性锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁出现了一个线程连续获取锁的情况。</p><blockquote><p>非公平性锁可能使线程<code>“饥饿”</code>，但被设定成默认的实现</p></blockquote><p>非公平性锁虽然可能造成线程“饥饿”，但线程切换极少，减小了线程上下文切换带来的开销，保证了其更大的吞吐量。</p><h3 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4. 读写锁"></a>4. 读写锁</h3><p><code>读写锁</code>维护了<strong>一对锁</strong>，一个<code>读锁</code>和一个<code>写锁</code>，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p><ul><li>读操作时获取读锁；</li><li>写操作时获取写锁。写锁被获取到时，后续（非当前写 操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行。</li></ul><p>Java并发包提供读写锁的实现是<code>ReentrantReadWriteLock</code>。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ReentrantReadWriteLock.PNG" alt="ReentrantReadWriteLock特性"></p><h4 id="4-1-读写锁的接口"><a href="#4-1-读写锁的接口" class="headerlink" title="4.1 读写锁的接口"></a>4.1 读写锁的接口</h4><p><code>ReadWriteLock</code>仅定义了<strong>获取</strong>读锁和写锁的两个方法，即<code>readLock()</code>方法和<code>writeLock()</code>方法；<code>ReentrantReadWriteLock</code>除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ReentrantReadWriteLockMthods.PNG" alt="ReentrantReadWriteLock方法"></p><h4 id="4-2-读写锁的实现"><a href="#4-2-读写锁的实现" class="headerlink" title="4.2 读写锁的实现"></a>4.2 读写锁的实现</h4><h5 id="4-2-1-读写状态的设计"><a href="#4-2-1-读写状态的设计" class="headerlink" title="4.2.1 读写状态的设计"></a>4.2.1 读写状态的设计</h5><p>读写锁同样依赖<strong>自定义同步器</strong>来实现同步功能，而<strong>读写状态</strong>就是其同步器的同步状态。</p><ul><li>读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态。</li></ul><p>读写锁将变量切分成了两个部分，<u><strong>高16位表示读</strong>，<strong>低16位表示写</strong></u>。读写锁通过<code>位运算</code>迅速确定读和写各自的状态。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ReadWriteLockStatus.PNG" alt="读写锁状态的划分"></p><h5 id="4-2-2-写锁的获取与释放"><a href="#4-2-2-写锁的获取与释放" class="headerlink" title="4.2.2 写锁的获取与释放"></a>4.2.2 写锁的获取与释放</h5><p>写锁是一个支持重进入的<strong>排它锁</strong>。</p><ul><li>如果当前线程已经获取了写锁，则增加写状态。</li><li>如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程， 则当前线程进入等待状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">        <span class="comment">// c != 0 且 w == 0，代表存在读锁</span></span><br><span class="line">    <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 写锁超过最大值</span></span><br><span class="line">    <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">    <span class="comment">// 设置写锁(此时该线程已经获取过写锁，所以无需CAS也是线程安全的)</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为加锁，尝试获取写锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁成功</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写锁的释放与<code>ReentrantLock</code>的释放过程基本类似，每次释放均减少写状态，当写状态为<code>0</code>时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁。</p><h5 id="4-2-3-读锁的获取与释放"><a href="#4-2-3-读锁的获取与释放" class="headerlink" title="4.2.3 读锁的获取与释放"></a>4.2.3 读锁的获取与释放</h5><p>读锁是一个支持重进入的<strong>共享锁</strong>。</p><ul><li>能够被<u>多个线程</u>同时获取，在没有其他<u>写线程访问</u>（或者写状态为0）时，读锁总会被成功地获取，只需增加读状态。</li><li>如果当前线程已经获取了<strong>读锁或写锁</strong>，则增加读状态。</li><li>如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</li><li>读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在<code>ThreadLocal</code>中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; c)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-4-锁降级"><a href="#4-2-4-锁降级" class="headerlink" title="4.2.4 锁降级"></a>4.2.4 锁降级</h5><p><code>锁降级</code>指的是<strong><u>写锁降级成为读锁</u></strong>。线程已经持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程，即<code>锁降级</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">        <span class="comment">// 必须先释放读锁</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">// 锁降级从写锁获取到开始</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">                <span class="comment">// 准备数据的流程（略）</span></span><br><span class="line">                update = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            readLock.lock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 锁降级完成，写锁降级为读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">// 使用数据的流程（略）</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁降级中读锁的获取主要是为了保证数据的可见性。</p><ul><li>如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。</li><li>如果当前线程获取读锁，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进 行数据更新。</li></ul><h3 id="5-LockSupport工具"><a href="#5-LockSupport工具" class="headerlink" title="5. LockSupport工具"></a>5. <code>LockSupport</code>工具</h3><p>当需要<strong>阻塞</strong>或<strong>唤醒</strong>一个线程的时候，都会使用<code>LockSupport</code>工具类来完成相应工作。<code>LockSupport</code>定义了一组的<strong><u>公共静态方法</u></strong>，这些方法提供了最基本的线程阻塞和唤醒功能，而<code>LockSupport</code>也成为构建同步组件的基础工具。</p><ul><li>以<code>park</code>开头的方法用来<strong><u>阻塞当前线程</u></strong>；</li><li><code>unpark(Thread thread)</code> 方法来<u><strong>唤醒一个被阻塞的线程</strong></u>。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/LockSupportMethods.PNG" alt="读写锁状态的划分"></p><p><code>Java 6</code>中，<code>LockSupport</code>增加了<code>park(Object blocker)</code>、<code>parkNanos(Object blocker, long nanos)</code>和<code>parkUntil(Object blocker, long deadline)</code>3个方法，用于实现阻塞当前线程的功能，其中参数<code>blocker</code>是用来<u><strong>标识当前线程在等待的对象</strong></u>（以下称为阻塞对象）。</p><h3 id="6-Condition接口"><a href="#6-Condition接口" class="headerlink" title="6. Condition接口"></a>6. <code>Condition</code>接口</h3><p><code>Condition</code>接口也提供了类似<code>Object</code>的<strong>监视器</strong>方法，与<code>Lock</code>配合可以实现等待/通知模式。</p><h4 id="6-1-Condition接口与示例"><a href="#6-1-Condition接口与示例" class="headerlink" title="6.1 Condition接口与示例"></a>6.1 Condition接口与示例</h4><p><code>Condition</code>定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要<strong><u>提前获取</u></strong>到<code>Condition</code>对象关联的锁。<code>Condition</code>对象是由<code>Lock</code>对象（调用Lock对象的<code>newCondition()</code>方法）创建出来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 一般都会将Condition对象作为成员变量</span></span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用await()方法后，当前线程会释放锁并在此等待</span></span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 其他线程调用Condition对象的signal()方法，</span></span><br><span class="line">        <span class="comment">// 通知当前线程后，当前线程才从await()方法返回，</span></span><br><span class="line">        <span class="comment">// 并且在返回前已经获取了锁。</span></span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ConditionMethods.PNG" alt="Condition的方法"></p><p>基于<code>Condition</code>实现的有界队列：</p><ul><li>当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素；</li><li>当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] items;</span><br><span class="line">    <span class="comment">// 添加的下标，删除的下标和数组当前数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addIndex, removeIndex, count;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个元素，如果数组满，则添加线程进入等待状态，直到有"空位"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[addIndex] = t;</span><br><span class="line">            <span class="keyword">if</span> (++addIndex == items.length)</span><br><span class="line">                addIndex = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[removeIndex];</span><br><span class="line">            <span class="keyword">if</span> (++removeIndex == items.length)</span><br><span class="line">                removeIndex = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> (T) x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-Condition的实现"><a href="#6-2-Condition的实现" class="headerlink" title="6.2 Condition的实现"></a>6.2 Condition的实现</h4><p><code>ConditionObject</code>是同步器<code>AbstractQueuedSynchronizer</code>的内部类。每个<code>Condition</code>对象都包含着一个队列（等待队列），该队列是<code>Condition</code>对象实现<strong><u>等待/通知功能</u></strong>的关键。</p><h5 id="6-2-1-等待队列"><a href="#6-2-1-等待队列" class="headerlink" title="6.2.1 等待队列"></a>6.2.1 等待队列</h5><p>等待队列是一个<code>FIFO</code>的队列，在队列中的每个节点都包含了一个<strong><code>线程引用</code></strong>，该线程就是在<code>Condition</code>对象上等待的线程：</p><ul><li>同步队列和等待队列中节点类型都是同步器的静态内部类<code>AbstractQueuedSynchronizer.Node</code>。</li><li><code>Lock</code>（同步器）拥有一个同步队列和多个等待队列</li></ul><p>同理，<code>Condition</code>拥有<code>首节点（firstWaiter）</code>和<code>尾节点（lastWaiter）</code>。</p><ul><li>当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。节点引用更新的过程并<strong><u>没有使用</u></strong><code>CAS</code>保证，原因在于调用<code>await()</code>方法的线程必定是获取了锁的线程。</li></ul><h5 id="6-2-2-等待"><a href="#6-2-2-等待" class="headerlink" title="6.2.2 等待"></a>6.2.2 等待</h5><p>调用<code>Condition</code>的<code>await()</code>方法，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。从await()方法返回时，当前线程<u><strong>一定获取了<code>Condition</code>相关联的锁</strong></u>。</p><ul><li>被唤醒后的线程，将从<code>await()</code>方法中的while循环中退出（<code>isOnSyncQueue(Node node)</code>方法返回true，节点已经在同步队列中）；</li><li>进而调用同步器的<code>acquireQueued()</code>方法加入到获取同步状态的竞争中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程加入等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步状态，也就是释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于<u><strong>同步队列的<code>首节点</code>（获取了锁的节点）移动到Condition的<code>等待队列</code>中</strong></u>。</p><h5 id="6-2-3-通知"><a href="#6-2-3-通知" class="headerlink" title="6.2.3 通知"></a>6.2.3 通知</h5><p>调用Condition的<code>signal()</code>方法，将会唤醒在等待队列中<u><strong>等待时间最长</strong></u>的节点（<code>首节点</code>），在唤醒节点之前，会将节点移到同步队列中。</p><ul><li>调用该方法的前置条件是当前线程必须获取了锁；</li><li>通过调用同步器的<code>enq(Node node)</code>方法，等待队列中的头节点线程安全地移动到同步队列。</li><li>当节点移动到同步队列后，当前线程再使用<code>LockSupport</code>唤醒该节点的线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用该方法的前置条件是当前线程必须获取了锁</span></span><br><span class="line"><span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line"><span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--4  Java并发编程基础</title>
    <link href="https://wuyunjie.top/2021/07/18/JavaLearning_The_art_of_concurrent_programming_in_Java-4-Java-concurrent-programming-basics.html"/>
    <id>https://wuyunjie.top/2021/07/18/JavaLearning_The_art_of_concurrent_programming_in_Java-4-Java-concurrent-programming-basics.html</id>
    <published>2021-07-18T14:31:47.000Z</published>
    <updated>2021-07-18T14:31:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>线程作为操作系统调度的最小单元，多个线程能够同时执行，这将显著提升程序性能，在多核环境中表现得更加明显。</code><br><a id="more"></a></p></blockquote><h3 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1. 线程简介"></a>1. 线程简介</h3><h4 id="1-1-线程定义"><a href="#1-1-线程定义" class="headerlink" title="1.1 线程定义"></a>1.1 线程定义</h4><p>现代操作系统<strong>调度的最小单元</strong>是线程，也叫<code>轻量级进程（Light Weight Process）</code>，在一个进程里可以创建多个线程，这些线程都拥有<u>各自的计数器、堆栈和局部变量</u>等属性，并且能够访问共享的内存变量。</p><blockquote><p>Java程序<u>天生就是多线程程序</u>，因为执行<code>main()</code>方法的是一个名称为main的线程。</p></blockquote><p>一个Java程序的运行是main线程和多个其他线程的同时运行。</p><h4 id="1-2-多线程"><a href="#1-2-多线程" class="headerlink" title="1.2 多线程"></a>1.2 多线程</h4><p>使用多线程的原因主要有以下几点：</p><ol><li><strong>更多的处理器核心</strong>。使用多线程技术将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。</li><li><strong>更快的响应时间</strong>。使用多线程技术，将数据一致性不强的操作派发给其他线程处理，缩短响应时间。</li><li><strong>更好的编程模型</strong>。</li></ol><h4 id="1-3-线程优先级"><a href="#1-3-线程优先级" class="headerlink" title="1.3 线程优先级"></a>1.3 线程优先级</h4><p>线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。在Java线程中，通过一个整型成员变量<code>priority</code>来控制优先级，优先级的范围从<code>1~10</code>，在线程构建的时候可以通过<code>setPriority(int)</code>方法来修改优先级，默认优先级是<code>5</code>。</p><blockquote><p>优先级只是一个建议，实际执行时可能会忽略对线程优先级的设定。</p></blockquote><h4 id="1-4-线程的状态"><a href="#1-4-线程的状态" class="headerlink" title="1.4 线程的状态"></a>1.4 线程的状态</h4><p>Java线程在运行的生命周期中可能处于<code>6</code>种不同的状态，且在给定的一个时刻，线程<u><strong>只能处于其中的一个状态</strong></u>：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter4/threadState.PNG" alt="线程状态"></p><p>可以使用<code>jps</code>查看进程<code>ID</code>，然后用<code>&quot;jstack 进程ID&quot;</code>查看运行时的线程信息。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter4/threadStateChange.PNG" alt="Java线程状态变迁"></p><h4 id="1-5-Daemon线程"><a href="#1-5-Daemon线程" class="headerlink" title="1.5 Daemon线程"></a>1.5 Daemon线程</h4><p><code>Daemon</code>线程是一种<strong>支持型线程</strong>，因为它主要被用作程序中<u>后台调度以及支持性工作</u>。</p><blockquote><p>当一个Java虚拟机中<strong>不存在非Daemon线程</strong>的时候，Java虚拟机将会退出。</p></blockquote><p>通过调用<code>Thread.setDaemon(true)</code>将线程设置为Daemon线程，<u>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置</u>。</p><blockquote><p>在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</p></blockquote><p>实际上经过测试，甚至Daemon线程中<code>run()</code>内的代码都不一定会被执行，。main线程（非 Daemon线程）在启动了线程<code>DaemonRunner</code>之后随着main方法执行完毕而终止，而此时Java虚拟机中已经没有非Daemon线程，虚拟机需要退出。Java虚拟机中的所有Daemon线程都需要立即终止，因此<code>DaemonRunner</code>立即终止，但是<code>DaemonRunner</code>中的finally块并没有执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(), <span class="string">"DaemonRunner"</span>);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"DaemonThread finally run."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"DaemonThread finally run."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"DaemonThread finally run."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-启动和终止线程"><a href="#2-启动和终止线程" class="headerlink" title="2. 启动和终止线程"></a>2. 启动和终止线程</h3><h4 id="2-1-构造线程"><a href="#2-1-构造线程" class="headerlink" title="2.1 构造线程"></a>2.1 构造线程</h4><p>线程对象在构造的时候需要提供线程所需要的属性，如线程所属的<strong>线程组</strong>、<strong>线程优先级</strong>、<strong>是否是Daemon线程</strong>等信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程就是该线程的父线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将daemon、priority属性设置为父线程的对应属性</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将父线程的InheritableThreadLocal复制过来</span></span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">// 分配一个线程ID</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个新构造的线程对象是由其parent线程来进行空间分配的。</p><h4 id="2-2-启动线程"><a href="#2-2-启动线程" class="headerlink" title="2.2 启动线程"></a>2.2 启动线程</h4><p>线程对象在初始化完成之后，调用<code>start()</code>方法启动这个线程：<u><strong>当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用<code>start()</code>方法的线程</strong></u>。</p><h4 id="2-3-中断"><a href="#2-3-中断" class="headerlink" title="2.3 中断"></a>2.3 中断</h4><p><code>中断</code>可以理解为线程的一个<strong>标识位属性</strong>，它表示<u>一个运行中的线程是否被其他线程进行了中断操作</u>。</p><ul><li>其他线程通过调用该线程的<code>interrupt()</code>方法对其进行中断操作；</li><li>线程通过方法<code>isInterrupted()</code>来进行判断自身是否被中断；<ul><li>如果该线程已经处于<strong><u>终结状态</u></strong>，即使该线程被中断过，在调用该线程对象的<code>isInterrupted()</code>时依旧会返回<code>false</code>；</li><li>方法在抛出<code>InterruptedException</code>之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出<code>InterruptedException</code>，此时调用<code>isInterrupted()</code>方法将会返回<code>false</code>。</li></ul></li><li>可以调用静态方法<code>Thread.interrupted()</code>对当前线程的中断标识位进行复位；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeWaiting(), <span class="string">"TimeWaitingThread"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Waiting(), <span class="string">"WaitingThread"</span>).start();</span><br><span class="line">        <span class="comment">// 使用两个Blocked线程，一个获取锁成功，另一个被阻塞</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该线程不断地进行睡眠</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该线程在Waiting.class实例上等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Waiting<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Waiting<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该线程在Blocked.class实例上加锁后，不会释放该锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Blocked<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(<span class="keyword">long</span> seconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-过期-deprecated-的suspend-、resume-和stop"><a href="#2-4-过期-deprecated-的suspend-、resume-和stop" class="headerlink" title="2.4 过期(deprecated)的suspend()、resume()和stop()"></a>2.4 过期(<code>deprecated</code>)的<code>suspend()</code>、<code>resume()</code>和<code>stop()</code></h4><p><code>suspend()</code>、<code>resume()</code>和<code>stop()</code>方法完成线程的<strong>暂停</strong>、<strong>恢复</strong>和<strong>终止</strong>工作。但是这些<code>API</code>是过期的，已经不建议使用，因为这些方法会带来副作用：</p><ul><li>在调用<code>suspend()</code>后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发<strong>死锁问题</strong>；</li><li><code>stop()</code>方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</li></ul><h4 id="2-5-安全地终止线程"><a href="#2-5-安全地终止线程" class="headerlink" title="2.5 安全地终止线程"></a>2.5 安全地终止线程</h4><p>中断操作是一种适合用来取消或停止任务的交互方式。除了中断以外，还可以利用一个boolean变量来控制<u>是否需要停止任务并终止该线程</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shutdown</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread countThread = <span class="keyword">new</span> Thread(one, <span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line"></span><br><span class="line">        Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">        countThread = <span class="keyword">new</span> Thread(two, <span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Count i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种通过<strong>标识位</strong>或者<strong>中断操作</strong>的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止。</p><h3 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3. 线程间通信"></a>3. 线程间通信</h3><h4 id="3-1-volatile和synchronized关键字"><a href="#3-1-volatile和synchronized关键字" class="headerlink" title="3.1 volatile和synchronized关键字"></a>3.1 <code>volatile</code>和<code>synchronized</code>关键字</h4><ul><li>关键字<code>volatile</code>可以用来修饰字段（成员变量），告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</li><li>关键字<code>synchronized</code>可以修饰方法或者以同步块的形式来进行使用，它确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</li></ul><h4 id="3-2-等待-通知机制"><a href="#3-2-等待-通知机制" class="headerlink" title="3.2 等待/通知机制"></a>3.2 等待/通知机制</h4><p>等待/通知的相关方法是<u><strong>任意Java对象都具备的</strong></u>，因为这些方法被定义在所有对象的超类<code>java.lang.Object</code>上。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter4/WaitAndNotify.PNG" alt="等待/通知方法"></p><p>等待/通知机制通过对象O来完成线程之间的交互：</p><ul><li>一个线程A调用了对象O的<code>wait()</code>方法进入等待状态；</li><li>另一个线程B调用了对象O的<code>notify()</code>或者<code>notifyAll()</code>方法，线程A收到通知后从对象O的<code>wait()</code>方法返回，进而执行后续操作。</li><li>对象上的<code>wait()</code>和<code>notify/notifyAll()</code>的关系就如同开关信号，用来完成等待方和通知方之间的交互工作。</li></ul><p>调用<code>wait()</code>、<code>notify()</code>以及<code>notifyAll()</code>时需要注意的细节：</p><ol><li>使用<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>时需要先对调用<strong>对象加锁</strong>。</li><li>调用<code>wait()</code>方法后，线程状态由<code>RUNNING</code>变为<code>WAITING</code>，并将当前线程放置到对象的等待队列。</li><li><code>notify()</code>或<code>notifyAll()</code>方法调用后，<u><strong>等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回</strong></u>。</li><li><code>notify()</code>方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而<code>notifyAll()</code>方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为 BLOCKED。</li><li>从<code>wait()</code>方法返回的<strong>前提</strong>是<u>获得了调用对象的锁</u>。</li></ol><h4 id="3-3-等待-通知的经典范式"><a href="#3-3-等待-通知的经典范式" class="headerlink" title="3.3 等待/通知的经典范式"></a>3.3 等待/通知的经典范式</h4><p><strong>等待/通知的经典范式</strong>分为两部分，分别针对<strong>等待方（消费者）</strong>和<strong>通知方（生产者）</strong>：</p><ul><li><p><strong>等待方</strong>遵循如下原则：</p><ol><li>获取对象的锁；</li><li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件；</li><li>条件满足则执行对应的逻辑；</li></ol></li><li><p><strong>通知方</strong>遵循如下原则：</p><ol><li>获得对象的锁；</li><li>改变条件；</li><li>通知所有等待在对象上的线程。</li></ol></li></ul><h4 id="3-4-管道输入-输出流"><a href="#3-4-管道输入-输出流" class="headerlink" title="3.4 管道输入/输出流"></a>3.4 管道输入/输出流</h4><p>管道输入/输出流主要用于<strong>线程</strong>之间的数据传输，而<u>传输的媒介为内存</u>。主要包括4种具体实现：</p><ul><li>面向字节：<code>PipedOutputStream</code>、<code>PipedInputStream</code></li><li>面向字符：<code>PipedReader</code>、<code>PipedWriter</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        <span class="comment">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</span></span><br><span class="line">        out.connect(in);</span><br><span class="line"></span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">"PrintThread"</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader in;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-Thread-join-的使用"><a href="#3-5-Thread-join-的使用" class="headerlink" title="3.5 Thread.join()的使用"></a>3.5 <code>Thread.join()</code>的使用</h4><p>一个线程A执行<code>thread.join()</code>后，当前线程A等待thread线程终止之后才从<code>thread.join()</code>返回。线程Thread除了提供<code>join()</code>方法之外，还提供了<code>join(long millis)</code>和<code>join(long millis, int nanos)</code>两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁当前线程对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 条件不满足，继续等待</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件符合，方法返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-ThreadLocal的使用"><a href="#3-6-ThreadLocal的使用" class="headerlink" title="3.6 ThreadLocal的使用"></a>3.6 <code>ThreadLocal</code>的使用</h4><p><code>ThreadLocal</code>，即线程变量，是一个<u>以<code>ThreadLocal</code>对象为<strong>键</strong></u>、<u>任意对象为<strong>值</strong></u>的存储结构。一个线程可以根据一个<code>ThreadLocal</code>对象查询到绑定在这个线程上的一个值。</p><ul><li>可以通过<code>set(T)</code>方法来设置一个值；</li><li>在当前线程下再通过<code>get()</code>方法获取到原先设置的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-线程应用实例"><a href="#4-线程应用实例" class="headerlink" title="4. 线程应用实例"></a>4. 线程应用实例</h3><h4 id="4-1-等待超时模式"><a href="#4-1-等待超时模式" class="headerlink" title="4.1 等待超时模式"></a>4.1 等待超时模式</h4><p>在<strong>等待/通知的经典范式</strong>上加入<strong>超时等待</strong>，可以使得该模式更具有灵活性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对当前对象加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line"><span class="keyword">long</span> remaining = mills;</span><br><span class="line">    <span class="comment">// 当超时大于0并且result返回值不满足要求</span></span><br><span class="line">    <span class="keyword">while</span> ((result == <span class="keyword">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    wait(remaining);</span><br><span class="line">        remaining = future - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-数据库连接池示例"><a href="#4-2-数据库连接池示例" class="headerlink" title="4.2 数据库连接池示例"></a>4.2 数据库连接池示例</h4><p>使用等待超时模式来构造一个简单的<code>数据库连接池</code>，从连接池中<strong>获取</strong>、<strong>使用</strong>和<strong>释放连接</strong>，而客户端获取连接的过程被设定为等待超时的模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">                <span class="comment">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span></span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在mills内无法获取到连接，将会返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">            <span class="comment">// 完全超时</span></span><br><span class="line">            <span class="keyword">if</span> (mills &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty()) &#123;</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">                <span class="keyword">long</span> remaining = mills;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                Connection result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (!pool.isEmpty()) &#123;</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在资源一定的情况下（连接池中的10个连接），随着客户端线程的逐步增加，客户端出现超时无法获取连接的比率会不断升高。</p><h4 id="4-3-线程池技术及其示例"><a href="#4-3-线程池技术及其示例" class="headerlink" title="4.3 线程池技术及其示例"></a>4.3 线程池技术及其示例</h4><p>对于服务端的程序，经常面对的是客户端传入的<strong>短小（执行时间短、工作内容较为单一）</strong>任务，需要服务端快速处理并返回结果。如果采用一个任务一个线程的方式，任务过多时会创建大量线程，线程上下文切换会增加系统的负载。</p><p><code>线程池技术</code>预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。</p><ul><li>一方面，消除了频繁创建和消亡线程的系统资源开销；</li><li>另一方面，面对过量任务的提交能够平缓的劣化。</li></ul><p>一个简单的线程池接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 执行一个Job，这个Job需要实现Runnable</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 增加工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 减少工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 得到正在等待执行的任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端可以通过<code>execute(Job)</code>方法将<code>Job</code><strong><u>提交入线程池执行</u></strong>，而客户端自身不用等待<code>Job</code>的执行完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 线程池最大限制数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 线程池默认的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 线程池最小的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这是一个工作列表，将会向里面插入工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;Job&gt;();</span><br><span class="line">    <span class="comment">// 工作者列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Worker&gt;());</span><br><span class="line">    <span class="comment">// 工作者线程的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">    <span class="comment">// 线程编号生成</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong threadNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initializeWokers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;</span><br><span class="line">        initializeWokers(workerNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加一个工作，然后进行通知</span></span><br><span class="line">            <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="comment">// 限制新增的Worker数量不能超过最大值</span></span><br><span class="line">            <span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWokers(num);</span><br><span class="line">            <span class="keyword">this</span>.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="keyword">this</span>.workerNum) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"beyond workNum"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 按照给定的数量停止Worker</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程工作者</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWokers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">"ThreadPool-Worker-"</span> + threadNum.incrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作者，负责消费任务</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否工作</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                    <span class="comment">// 如果工作者列表是空的，那么就wait</span></span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                            <span class="comment">// 感知到外部对WorkerThread的中断操作，返回</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 取出一个Job</span></span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        job.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        <span class="comment">// 忽略Job执行中的Exception</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的本质就是使用了一个线程安全的工作队列连接工作者线程和客户端线程：</p><ul><li>客户端线程将任务放入工作队列后便返回；</li><li>工作者线程则不断地从工作队列上取出工作并执行。</li></ul><h4 id="4-4-基于线程池技术的简单Web服务器"><a href="#4-4-基于线程池技术的简单Web服务器" class="headerlink" title="4.4 基于线程池技术的简单Web服务器"></a>4.4 基于线程池技术的简单Web服务器</h4><p>常用的Java Web服务器，如<code>Tomcat</code>、<code>Jetty</code>，在其处理请求的过程中都使用到了线程池技术。</p><p>构造一个简单的Web服务器，这个Web服务器用来处理<code>HTTP</code>请求，使用<code>main</code>线程不断地接受客户端<code>Socket</code>的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理HttpRequest的线程池</span></span><br><span class="line">    <span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool&lt;HttpRequestHandler&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// SimpleHttpServer的根路径</span></span><br><span class="line">    <span class="keyword">static</span> String basePath;</span><br><span class="line">    <span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="comment">// 服务监听端口</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (port &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span><span class="params">(String basePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (basePath != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> File(basePath).exists() &amp;&amp; <span class="keyword">new</span> File(basePath).isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动SimpleHttpServer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">            InputStream in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 由相对路径计算出绝对路径</span></span><br><span class="line">                String filePath = basePath + header.split(<span class="string">" "</span>)[<span class="number">1</span>];</span><br><span class="line">                out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">"jpg"</span>) || filePath.endsWith(<span class="string">"ico"</span>)) &#123;</span><br><span class="line">                    in = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: image/jpeg"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Length: "</span> + array.length);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(filePath)));</span><br><span class="line">                    out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: text/html; charset=UTF-8"</span>);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                out.println(<span class="string">"HTTP/1.1 500"</span>);</span><br><span class="line">                out.println(<span class="string">""</span>);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(br, in, reader, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭流或者Socket</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeables != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable closeable : closeables) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SimpleHttpServer</code>在建立了与客户端的连接之后，并不会处理客户端的请求，而是将其包装成<code>HttpRequestHandler</code>并交由线程池处理。启动服务的测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHttpServer newSever = <span class="keyword">new</span> SimpleHttpServer();</span><br><span class="line">        newSever.setBasePath(<span class="string">"..\\src\\Concurrency\\Chapter4\\DefaultThreadPool"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newSever.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<code>Apache HTTP server benchmarking tool</code>来测试不同线程数下，<code>SimpleHttpServer</code>的吞吐量表现。</p><blockquote><p><a href="https://www.cnblogs.com/cjsblog/p/9038838.html" target="_blank" rel="noopener">Apache HTTP server benchmarking tool</a>是服务器压力测试工具，可以参考链接查看使用方法。</p></blockquote><p>随着线程池中线程数量的增加，<code>SimpleHttpServer</code>响应时间不断变小。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;线程作为操作系统调度的最小单元，多个线程能够同时执行，这将显著提升程序性能，在多核环境中表现得更加明显。&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--3 Java内存模型</title>
    <link href="https://wuyunjie.top/2021/07/17/JavaLearning_The_art_of_concurrent_programming_in_Java-3-Java-memory-model.html"/>
    <id>https://wuyunjie.top/2021/07/17/JavaLearning_The_art_of_concurrent_programming_in_Java-3-Java-memory-model.html</id>
    <published>2021-07-17T08:14:02.000Z</published>
    <updated>2021-07-17T08:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>Java线程之间的通信对程序员完全透明，内存可见性问题很容易困扰Java程序员</code><br><a id="more"></a></p></blockquote><h3 id="1-Java内存模型的基础"><a href="#1-Java内存模型的基础" class="headerlink" title="1. Java内存模型的基础"></a>1. <code>Java</code>内存模型的基础</h3><h4 id="1-1-并发编程模型的两个关键问题"><a href="#1-1-并发编程模型的两个关键问题" class="headerlink" title="1.1 并发编程模型的两个关键问题"></a>1.1 并发编程模型的两个关键问题</h4><p>在并发编程中，需要处理两个关键问题：</p><ul><li><strong>线程之间如何通信</strong>。线程之间的通信机制有两种：<code>共享内存</code>和<code>消息传递</code>。<ul><li><code>共享内存</code>是线程之间共享程序的公共状态，通过<u>写-读内存中的公共状态</u>进行<strong>隐式</strong>通信。</li><li><code>消息传递</code>是线程之间通过<u>发送消息</u>来<strong>显式</strong>进行通信。</li></ul></li><li><strong>线程之间如何同步</strong>。<ul><li>在<code>共享内存</code>并发模型里，同步是<strong>显式</strong>进行的。必须显式指定某个方法或某段代码需要在线程之间互斥执行。</li><li>在<code>消息传递</code>并发模型里，同步是<strong>隐式</strong>进行的。消息的发送必须在消息的接收之前。</li></ul></li></ul><p>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行。</p><h4 id="1-2-Java内存模型的抽象结构"><a href="#1-2-Java内存模型的抽象结构" class="headerlink" title="1.2 Java内存模型的抽象结构"></a>1.2 Java内存模型的抽象结构</h4><p>Java中所有<code>实例域</code>、<code>静态域</code>和<code>数组元素</code>都存储在<strong>堆内存</strong>中，<strong><u>堆内存在线程之间共享</u></strong>。Java内存模型（为<code>JMM</code>）<u>决定一个线程对共享变量的写入何时对另一个线程可见</u>。<code>JMM</code>定义了线程和主内存之间的抽象关系：</p><blockquote><p>线程之间的共享变量存储在<code>主内存（Main Memory）</code>中，每个线程都有一个私有的<code>本地内存（Local Memory）</code>，本地内存中存储了该线程以读/写共享变量的副本。本地内存是<code>JMM</code>的一个<strong>抽象概念</strong>，并不真实存在。</p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/JMMStructure.PNG" alt="Java内存模型的抽象结构"></p><p>Java线程之间的通信过程必须要经过<code>主内存</code>。<code>JMM</code>通过控制主内存与每个线程的本地内存之间的交互，来提供<strong>内存可见性保证</strong>。</p><h4 id="1-3-从源代码到指令序列的重排序"><a href="#1-3-从源代码到指令序列的重排序" class="headerlink" title="1.3 从源代码到指令序列的重排序"></a>1.3 从源代码到指令序列的重排序</h4><p>为了提高性能，编译器和处理器常常会对指令做<code>重排序</code>。<code>重排序</code>分3种类型：</p><ol><li><code>编译器优化的重排序</code>。<strong>编译器</strong>在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li><code>指令级并行的重排序</code>。现代<strong>处理器</strong>采用了<code>指令级并行技术（Instruction-Level Parallelism，ILP）</code>来<u>将多条指令重叠执行</u>。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li><code>内存系统的重排序</code>。由于<strong>处理器</strong>使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>重排序可能会导致<strong>多线程程序</strong>出现<strong>内存可见性问题</strong>。JMM属于<u>语言级</u>的内存模型，通过<u>禁止<strong>特定类型</strong>的编译器重排序和处理器重排序，提供一致的内存可见性保证</u>。</p><h4 id="1-4-并发编程模型的分类"><a href="#1-4-并发编程模型的分类" class="headerlink" title="1.4 并发编程模型的分类"></a>1.4 并发编程模型的分类</h4><p>现代的处理器使用<strong>写缓冲区</strong>临时保存<u>向内存写入的数据</u>，它可以</p><ul><li>避免由于处理器停顿下来<u>等待向内存写入数据而产生的延迟</u>。</li><li>以<strong>批处理</strong>的方式刷新写缓冲区，合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。</li></ul><p>每个处理器上的写缓冲区，仅仅对它所在的处理器可见，这会它会导致<u>处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致</u>。为了保证<strong>内存可见性</strong>，Java编译器在生成指令序列的适当位置会插入<code>内存屏障</code>指令来<u>禁止特定类型的处理器重排序</u>。<code>JMM</code>把内存屏障指令分为4类：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/MemoryBarriers.PNG" alt="内存屏障类型"></p><p><code>StoreLoad Barriers</code>是一个<code>“全能型”</code>的屏障，同时具有其他3个屏障的效果。但<u>执行该屏障开销会很昂贵</u>，因为当前处理器通常要把写缓冲区中的数据<code>全部刷新到内存中（Buffer Fully Flush）</code>。</p><h4 id="1-5-happens-before"><a href="#1-5-happens-before" class="headerlink" title="1.5 happens-before"></a>1.5 <code>happens-before</code></h4><p><code>happens-before</code>用于表示操作之间的<code>内存可见性</code>。在<code>JMM</code>中，如果<u>一个操作执行的<strong>结果</strong>需要对另一个操作可见</u>，那么这两个操作之间必须要存在<code>happens-before</code>关系。</p><ul><li><code>程序顺序规则</code>：一个线程中的每个操作，<code>happens-before</code>于该线程中的任意后续操作。</li><li><code>监视器锁规则</code>：对一个锁的解锁，<code>happens-before</code>于随后对这个锁的加锁。</li><li><code>volatile变量规则</code>：对一个volatile域的写，<code>happens-before</code>于任意后续对这个volatile域的读。</li><li><code>传递性</code>：如果A <code>happens-before</code> B，且B <code>happens-before</code> C，那么A <code>happens-before</code> C。</li></ul><p>一个<code>happens-before</code>规则对应于一个或多个<strong>编译器和处理器重排序规则</strong>。</p><h3 id="2-重排序"><a href="#2-重排序" class="headerlink" title="2. 重排序"></a>2. 重排序</h3><h4 id="2-1-数据依赖性"><a href="#2-1-数据依赖性" class="headerlink" title="2.1 数据依赖性"></a>2.1 数据依赖性</h4><p>如果两个操作访问<strong>同一个变量</strong>，且这两个操作中<strong>有一个为写操作</strong>，此时这两个操作之间就存在<code>数据依赖性</code>。只要重排序两个操作的执行顺序，程序的执行结果就会被改变。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/DataDependency.PNG" alt="数据依赖类型"></p><p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p><h4 id="2-2-as-if-serial语义"><a href="#2-2-as-if-serial语义" class="headerlink" title="2.2 as-if-serial语义"></a>2.2 <code>as-if-serial</code>语义</h4><p><code>as-if-serial</code>语义的意思是：不管怎么重排序，（单线程）程序的执行结果不能被改变。如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><h4 id="2-3-程序顺序规则"><a href="#2-3-程序顺序规则" class="headerlink" title="2.3 程序顺序规则"></a>2.3 程序顺序规则</h4><p>如果<code>A happens-before B</code>，<code>JMM</code>并不要求A一定要在B之前执行。JMM仅仅要求<u>前一个操作（执行的结果）对后一个操作可见</u>，且<u>前一个操作按顺序排在第二个操作之前</u>。</p><p>若操作A的执行结果<strong>不需要对操作B可见</strong>，而且重排序操作A和操作B后的执行结果，与操作A和操作B按<code>happens-before</code>顺序<strong>执行的结果一致</strong>，<code>JMM</code>会允许这种重排序。</p><h4 id="2-4-重排序对多线程的影响"><a href="#2-4-重排序对多线程的影响" class="headerlink" title="2.4 重排序对多线程的影响"></a>2.4 重排序对多线程的影响</h4><p>重排序可能会改变多线程程序的执行结果。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Public <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f?lag) &#123; <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">int</span> i = a * a; <span class="comment">// 4</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序。如果操作1和操作2做了重排序，程序执行时</p><ul><li>线程A首先写标记变量<code>flag</code>；</li><li>随后线程B读变量<code>flag</code>；</li><li>由于条件判断为真，线程B将读取变量<code>a</code>。此时，变量<code>a</code>还没有被线程A写入，此时多线程程序的语义被重排序破坏。</li></ul><p>同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。操作3和操作4存在<code>控制依赖关系</code>。编译器和处理器会采用<code>猜测（Speculation）执行</code>来克服控制相关性<u>对并行度的影响</u>。</p><ul><li>执行线程B的处理器可以提前读取并计算<code>a*a</code>；</li><li>然后把计算结果临时保存到一个名为<code>重排序缓冲（Reorder Buffer，ROB）</code>的<strong>硬件缓存</strong>中；</li><li>当操作3的条件判断为真时，就把该计算结果写入变量<code>i</code>中。在此时，重排序也破坏了多线程程序的语义。</li></ul><h3 id="3-顺序一致性"><a href="#3-顺序一致性" class="headerlink" title="3. 顺序一致性"></a>3. 顺序一致性</h3><h4 id="3-1-数据竞争与顺序一致性"><a href="#3-1-数据竞争与顺序一致性" class="headerlink" title="3.1 数据竞争与顺序一致性"></a>3.1 数据竞争与顺序一致性</h4><p><code>Java内存模型规范</code>把<code>数据竞争</code>的定义为：</p><blockquote><p><strong>在一个线程中写一个变量，另一个线程读同一个变量，而且写和读没有通过同步来排序。</strong></p></blockquote><p><code>JMM</code>对正确同步的多线程程序的内存一致性保证：</p><blockquote><p>如果程序是正确同步的，程序的执行将具有<code>顺序一致性（Sequentially Consistent）</code>——即<u>程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同</u>。</p></blockquote><h4 id="3-2-顺序一致性内存模型"><a href="#3-2-顺序一致性内存模型" class="headerlink" title="3.2 顺序一致性内存模型"></a>3.2 顺序一致性内存模型</h4><p>顺序一致性内存模型有两大特性：</p><ol><li>一个线程中的所有操作必须<u>按照程序的顺序来执行</u>。</li><li>（不管程序是否同步）所有线程都<u>只能看到一个单一的操作执行顺序</u>。在顺序一致性内存模型中，每个操作都必须<strong>原子执行且立刻对所有线程可见</strong>。</li></ol><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/SequentiallyConsistent.PNG" alt="顺序一致性内存模型"></p><p>顺序一致性内存模型是一个<strong>理论参考模型</strong>，在概念上顺序一致性模型有一个<u><strong>单一的全局内存</strong></u>，这个内存通过一个<u>左右摆动的开关</u>可以连接到任意一个线程，同时每一个线程<strong>必须按照程序的顺序</strong>来执行内存读/写操作。</p><p>未同步程序在<code>JMM</code>中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。</p><ul><li>在当前线程把写过的数据缓存在<code>本地内存</code>中，在没有刷新到<code>主内存</code>之前，这个写操作仅对当前线程可见；</li><li>从其他线程的角度来观察，会认为这个写操作根本没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。</li><li>当前线程和其他线程看到的操作执行顺序将不一致。</li></ul><h4 id="3-3-同步程序的顺序一致性效果"><a href="#3-3-同步程序的顺序一致性效果" class="headerlink" title="3.3 同步程序的顺序一致性效果"></a>3.3 同步程序的顺序一致性效果</h4><ul><li><p>顺序一致性模型中，所有操作完全按程序的顺序串行执行。</p></li><li><p>而在<code>JMM</code>中，<u>临界区内的代码可以重排序</u>（但JMM不允许临界区内的代码<code>“逸出”</code>到临界区之外，那样会破坏监视器的语义）。虽然线程A在临界区内做了重排序，但由于<u>监视器互斥执行</u>的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。</p></li></ul><h4 id="3-4-未同步程序的执行特性"><a href="#3-4-未同步程序的执行特性" class="headerlink" title="3.4 未同步程序的执行特性"></a>3.4 未同步程序的执行特性</h4><p>对于未同步或未正确同步的多线程程序，<code>JMM</code>只提供<u><strong>最小安全性</strong></u>：</p><blockquote><p>线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，Null，False），JMM保证<u><strong>线程读操作读取到的值不会<code>无中生有（Out Of Thin Air）</code>的冒出来</strong></u>。</p></blockquote><p>JMM不保证未同步程序的<strong>执行结果</strong>与该程序在顺序一致性模型中的执行结果一致，整体上是无序的，其执行结果无法预知。两个模型中的执行特性有如下几个差异：</p><ol><li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行。</li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。</li><li>JMM不保证对64位的<code>long</code>型和<code>double</code>型变量的<code>写操作</code>具有<strong>原子性</strong>，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li></ol><h3 id="4-volatile的内存语义"><a href="#4-volatile的内存语义" class="headerlink" title="4. volatile的内存语义"></a>4. <code>volatile</code>的内存语义</h3><h4 id="4-1-volatile的特性"><a href="#4-1-volatile的特性" class="headerlink" title="4.1 volatile的特性"></a>4.1 volatile的特性</h4><p>理解<code>volatile</code>特性的一个好方法是把对<code>volatile</code>变量的单个读/写，看成是使用<strong>同一个锁</strong>对这些<strong>单个读/写操作</strong>做了同步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> vl = <span class="number">0L</span>; <span class="comment">// 使用volatile声明64位的long型变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">vl = l; <span class="comment">// 单个volatile变量的写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">vl++; <span class="comment">// 复合（多个）volatile变量的读/写</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vl; <span class="comment">// 单个volatile变量的读</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个程序在语义上等价。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> vl = <span class="number">0L</span>; <span class="comment">// 64位的long型普通变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123; <span class="comment">// 对单个的普通变量的写用同一个锁同步</span></span><br><span class="line">vl = l;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123; <span class="comment">// 普通方法调用</span></span><br><span class="line">        <span class="keyword">long</span> temp = get(); <span class="comment">// 调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>; <span class="comment">// 普通写操作</span></span><br><span class="line">        set(temp); <span class="comment">// 调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// 对单个的普通变量的读用同一个锁同步</span></span><br><span class="line">        <span class="keyword">return</span> vl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>volatile</code>变量自身具有下列特性：</p><ul><li><strong>可见性</strong>。锁的<code>happens-before</code>规则保证释放锁和获取锁的两个线程之间的<strong>内存可见性</strong>，这意味着对一个<code>volatile</code>变量的读，总是能看到（任意线程）对这个<code>volatile</code>变量<u><strong>最后的写入</strong></u>。</li><li><strong>原子性</strong>。锁的语义决定了临界区代码的执行具有<strong>原子性</strong>，对任意单个volatile变量的读/写具有原子性。</li></ul><h4 id="4-2-volatile写-读建立的happens-before关系"><a href="#4-2-volatile写-读建立的happens-before关系" class="headerlink" title="4.2 volatile写-读建立的happens-before关系"></a>4.2 <code>volatile</code>写-读建立的<code>happens-before</code>关系</h4><p><code>volatile</code>变量的<strong>写-读</strong>可以实现线程之间的通信。<code>volatile</code>的<strong>写-读</strong>与<code>锁</code>的<strong>释放-获取</strong>有相同的内存效果：</p><ul><li><code>volatile写</code>和<code>锁的释放</code>有相同的内存语义；</li><li><code>volatile读</code>与<code>锁的获取</code>有相同的内存语义。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123; <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">int</span> i = a; <span class="comment">// 4</span></span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A执行<code>writer()</code>方法之后，线程B执行<code>reader()</code>方法。根据<code>happens-before</code>规则，这个过程建立的<code>happens-before</code>关系可以分为3类：</p><ol><li>根据<strong>程序次序规则</strong>，<strong>1</strong> <code>happens-before</code> <strong>2</strong>；<strong>3</strong> <code>happens-before</code> <strong>4</strong>。</li><li>根据<code>volatile规则</code>，<strong>2</strong> <code>happens-before</code> <strong>3</strong>。</li><li>根据<code>happens-before</code>的<strong>传递性规则</strong>，<strong>1</strong> <code>happens-before</code> <strong>4</strong>。</li></ol><h4 id="4-3-volatile写-读的内存语义"><a href="#4-3-volatile写-读的内存语义" class="headerlink" title="4.3 volatile写-读的内存语义"></a>4.3 volatile写-读的内存语义</h4><ul><li><code>volatile写</code>的内存语义即：当写一个volatile变量时，JMM会<strong><u>把该线程对应的本地内存中的共享变量值刷新到主内存</u></strong>。</li><li><code>volatile读</code>的内存语义即：当读一个volatile变量时，JMM会<strong><u>把该线程对应的本地内存置为无效</u></strong>。线程接下来将从主内存中读取共享变量。</li></ul><p>把<code>volatile写</code>和<code>volatile读</code>两个步骤综合起来看，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将<strong><u>立即变得对读线程B可见</u></strong>。</p><ul><li>·线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ul><h4 id="4-4-volatile内存语义的实现"><a href="#4-4-volatile内存语义的实现" class="headerlink" title="4.4 volatile内存语义的实现"></a>4.4 volatile内存语义的实现</h4><p>JMM针对<strong>编译器</strong>制定的volatile重排序规则：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/volatileReorderRule.PNG" alt="volatile重排序规则表"></p><ul><li>当<strong>第二个操作是volatile写</strong>时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li><li>当<strong>第一个操作是volatile读</strong>时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li><li>当<strong>第一个操作是volatile写，第二个操作是volatile读</strong>时，不能重排序。</li></ul><p>JMM采取保守策略插入内存屏障：</p><ul><li>在每个volatile写操作的<strong>前面</strong>插入一个<code>StoreStore</code>屏障。</li><li>在每个volatile写操作的<strong>后面</strong>插入一个<code>StoreLoad</code>屏障。</li><li>在每个volatile读操作的<strong>后面</strong>插入一个<code>LoadLoad</code>屏障。</li><li>在每个volatile读操作的<strong>后面</strong>插入一个<code>LoadStore</code>屏障。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/volatileWrite.PNG" alt="volatile写指令序列"></p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/volatileRead.PNG" alt="volatile读指令序列"></p><p>在实际执行时，只要不改变 volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。</p><h3 id="5-锁的内存语义"><a href="#5-锁的内存语义" class="headerlink" title="5. 锁的内存语义"></a>5. 锁的内存语义</h3><h4 id="5-1-锁的释放-获取建立的happens-before关系"><a href="#5-1-锁的释放-获取建立的happens-before关系" class="headerlink" title="5.1 锁的释放-获取建立的happens-before关系"></a>5.1 锁的释放-获取建立的happens-before关系</h4><p>锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123; <span class="comment">// 1</span></span><br><span class="line">        a++; <span class="comment">// 2</span></span><br><span class="line">    &#125; <span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123; <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">int</span> i = a; <span class="comment">// 5</span></span><br><span class="line">        ……</span><br><span class="line">    &#125; <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A执行<code>writer()</code>方法，随后线程B执行<code>reader()</code>方法。根据happens-before规则，这个过程包含的happens-before关系可以分为3类。</p><ol><li>根据<strong>程序次序规则</strong>，<strong>1</strong> <code>happens-before</code> <strong>2</strong>, <strong>2</strong> <code>happens-before</code> <strong>3</strong>; <strong>4</strong> <code>happens-before</code> <strong>5</strong>,<strong>5</strong> <code>happens-before</code> <strong>6</strong>。</li><li>根据<strong>监视器锁规则</strong>，<strong>3</strong> <code>happens-before</code> <strong>4</strong>。 </li><li>根据<strong>happens-before的传递性</strong>，<strong>2</strong> <code>happens-before</code> <strong>5</strong>。</li></ol><h4 id="5-2-锁的释放和获取的内存语义"><a href="#5-2-锁的释放和获取的内存语义" class="headerlink" title="5.2 锁的释放和获取的内存语义"></a>5.2 锁的释放和获取的内存语义</h4><ul><li>当线程<strong>释放锁</strong>时，JMM会<u><strong>把该线程对应的本地内存中的共享变量刷新到主内存中</strong></u>。</li><li>当线程<strong>获取锁</strong>时，JMM会<strong><u>把该线程对应的本地内存置为无效</u></strong>。从而使得被监视器保护的临界区代码<strong><u>必须从主内存中读取共享变量</u></strong>。</li></ul><h4 id="5-3-锁内存语义的实现"><a href="#5-3-锁内存语义的实现" class="headerlink" title="5.3 锁内存语义的实现"></a>5.3 锁内存语义的实现</h4><p>在<code>ReentrantLock</code>中，调用<code>lock()</code>方法获取锁；调用<code>unlock()</code>方法释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        a++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = a;</span><br><span class="line">            ……</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code>的实现依赖于Java同步器框架<code>AbstractQueuedSynchronizer</code>（<code>AQS</code>）。<code>AQS</code>使用一个<strong>整型的volatile变量</strong>（命名为state）来维护同步状态。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/ReentrantLockPKG.PNG" alt="ReentrantLock的类图"></p><p><code>ReentrantLock</code>分为<code>公平锁</code>和<code>非公平锁</code>。</p><h5 id="5-3-1-公平锁"><a href="#5-3-1-公平锁" class="headerlink" title="5.3.1 公平锁"></a>5.3.1 公平锁</h5><p>使用<code>公平锁</code>时，加锁方法<code>lock()</code>调用轨迹为：</p><ol><li><code>ReentrantLock:lock()</code>；</li><li><code>FairSync:lock()</code>；</li><li><code>AbstractQueuedSynchronizer:acquire(int arg)</code>；</li><li><code>ReentrantLock:tryAcquire(int acquires)</code>，真正开始加锁，加锁方法首先<strong>读</strong>volatile变量<code>state</code>；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">// 获取锁的开始，首先读volatile变量state</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个锁，使用CAS操作进行加锁</span></span><br><span class="line">        <span class="keyword">if</span> (isFirst(current) &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 已经获取过锁</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 增加锁数量</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 超出锁的数量，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁解锁方法<code>unlock()</code>调用轨迹为：</p><ol><li><code>ReentrantLock:unlock()</code>；</li><li><code>AbstractQueuedSynchronizer:release(int arg)</code>；</li><li><code>Sync:tryRelease(int releases)</code>，真正开始释放锁，释放锁的最后<strong>写</strong>volatile变量<code>state</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读volatile变量state，尝试释放</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程未获取锁，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// c == 0 该线程所有锁已经释放</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放锁的最后，写volatile变量state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>volatile</code>的happens-before规则：释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。</p><h5 id="5-3-2-非公平锁"><a href="#5-3-2-非公平锁" class="headerlink" title="5.3.2 非公平锁"></a>5.3.2 非公平锁</h5><p>非公平锁加锁方法<code>lock()</code>调用轨迹为：</p><ol><li><code>ReentrantLock:lock()</code>；</li><li><code>NonfairSync:lock()</code>；</li><li><code>AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)</code>，真正开始加锁，以<strong>原子操作</strong>的方式更新state变量。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值</span></span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁的释放和公平锁完全一样。</p><ul><li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li><li>公平锁获取时，首先会去读volatile变量。</li><li>非公平锁获取时，首先会用<code>CAS</code>更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。</li></ul><p>为了同时实现<code>volatile读</code>和<code>volatile写的</code>内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。</p><p><strong>锁释放-获取</strong>的内存语义的实现至少有下面两种方式：</p><ul><li>利用volatile变量的写-读所具有的内存语义。</li><li>利用<code>CAS</code>所附带的volatile读和volatile写的内存语义。</li></ul><h4 id="5-4-concurrent包的实现"><a href="#5-4-concurrent包的实现" class="headerlink" title="5.4 concurrent包的实现"></a>5.4 concurrent包的实现</h4><p>由于Java的<code>CAS</code>同时具有<code>volatile读</code>和<code>volatile写</code>的内存语义，因此Java线程之间的通信有4种方式：</p><ul><li>A线程写volatile变量，随后B线程读这个volatile变量。</li><li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li><li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li></ul><p>Java的<code>CAS</code>会使用现代处理器上提供的高效机器级别的<strong>原子指令</strong>，这些原子指令以原子方式对内存执行<code>读-改-写操作</code>。<code>concurrent</code>包一个通用化的实现模式：</p><ul><li>首先，声明共享变量为volatile。</li><li>然后，使用CAS的原子条件更新来实现线程之间的<strong>同步</strong>。</li><li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的<strong>通信</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/concurrentPackage.PNG" alt="concurrent包的实现示意图"></p><h3 id="6-final域的内存语义"><a href="#6-final域的内存语义" class="headerlink" title="6. final域的内存语义"></a>6. final域的内存语义</h3><h4 id="6-1-final域的重排序规则"><a href="#6-1-final域的重排序规则" class="headerlink" title="6.1 final域的重排序规则"></a>6.1 final域的重排序规则</h4><p>对于<code>final</code>域，编译器和处理器要遵守两个重排序规则。</p><ol><li>在<strong>构造函数</strong>内对一个<code>final</code>域的<strong>写入</strong>，与随后<u>把这个被构造对象的引用赋值给一个引用变量</u>，这两个操作之间不能重排序。</li><li><strong>初次读</strong>一个<u>包含<code>final</code>域的对象的引用</u>，与随后<strong>初次读</strong>这个<u><code>final</code>域</u>，这两个操作之间不能重排序。</li></ol><h4 id="6-2-写final域的重排序规则"><a href="#6-2-写final域的重排序规则" class="headerlink" title="6.2 写final域的重排序规则"></a>6.2 写final域的重排序规则</h4><p>写final域的重排序规则<u>禁止把final域的写重排序到<strong>构造函数</strong>之外</u>。</p><ol><li>JMM禁止编译器把final域的写重排序到构造函数之外。</li><li>编译器会在final域的写之后，构造函数return之前，插入一个<code>StoreStore</code>屏障。这个屏障<u>禁止处理器把final域的写重排序到构造函数之外</u>。</li></ol><p>写final域的重排序规则可以确保：<u>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了</u>，而普通域不具有这个保障。</p><h4 id="6-3-读final域的重排序规则"><a href="#6-3-读final域的重排序规则" class="headerlink" title="6.3 读final域的重排序规则"></a>6.3 读final域的重排序规则</h4><p>读final域的重排序规则是，在一个线程中，<u>初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作</u>。</p><ul><li>编译器会在读final域操作的前面插入一个<code>LoadLoad</code>屏障。</li></ul><p>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在<strong>间接依赖关系</strong>。</p><p>读final域的重排序规则可以确保：<u>在读一个对象的final域之前，一定会先读包含这个final 域的对象的引用</u>。</p><h4 id="6-4-final域为引用类型"><a href="#6-4-final域为引用类型" class="headerlink" title="6.4 final域为引用类型"></a>6.4 final域为引用类型</h4><p>对于<code>引用类型</code>，写final域的重排序规则对编译器和处理器<strong>增加了</strong>如下约束：</p><ul><li>在<strong>构造函数</strong>内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li></ul><p>JMM可以确保读final引用对象时，至少能看到<strong>构造函数</strong>中<u>对final引用对象的成员域的写入</u>。(可以理解为<strong><u>构造函数</u></strong>中对引用对象的操作看作一个整体)。</p><h4 id="6-5-final引用不能从构造函数内“逸出”"><a href="#6-5-final引用不能从构造函数内“逸出”" class="headerlink" title="6.5 final引用不能从构造函数内“逸出”"></a>6.5 final引用不能从构造函数内<code>“逸出”</code></h4><p>要实现<code>“在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了”</code>， 还需要一个前提：</p><ul><li>在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中<code>“逸出”</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>; <span class="comment">// 1写final域</span></span><br><span class="line">        obj = <span class="keyword">this</span>; <span class="comment">// 2 this引用在此"逸出"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> FinalReferenceEscapeExample ();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">int</span> temp = obj.i; <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-6-final语义在处理器中的实现"><a href="#6-6-final语义在处理器中的实现" class="headerlink" title="6.6 final语义在处理器中的实现"></a>6.6 final语义在处理器中的实现</h4><ul><li>写final域的重排序规则会要求编译器在final域的写之后，构造函数return之前插入一个<code>StoreStore</code>障屏。</li><li>读final域的重排序规则要求编译器在读final域的操作前面插入一个<code>LoadLoad</code>屏障。</li></ul><h3 id="7-happens-before"><a href="#7-happens-before" class="headerlink" title="7. happens-before"></a>7. happens-before</h3><h4 id="7-1-JMM的设计"><a href="#7-1-JMM的设计" class="headerlink" title="7.1 JMM的设计"></a>7.1 JMM的设计</h4><p><strong>JSR-133专家组</strong>在设计JMM时的核心目标就是找到一个好的平衡点：</p><ul><li>一方面，要为程序员提供足够强的内存可见性保证；</li><li>另一方面，对编译器和处理器的限制要尽可能地放松。</li></ul><p>JMM对这两种不同性质的重排序，采取了不同的策略：</p><ul><li>对于<strong><u>会改变程序执行结果的重排序</u></strong>，JMM要求编译器和处理器<strong>必须禁止</strong>这种重排序。</li><li>对于<strong><u>不会改变程序执行结果的重排序</u></strong>，JMM对编译器和处理器不做要求（JMM<u>允许</u>这种重排序）。</li></ul><h4 id="7-2-happens-before的定义"><a href="#7-2-happens-before的定义" class="headerlink" title="7.2 happens-before的定义"></a>7.2 happens-before的定义</h4><p><code>《JSR-133:Java Memory Model and Thread Specification》</code>对happens-before关系的定义如下。</p><ol><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ol><p><code>as-if-serial</code>语义和<code>happens-before</code>的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</p><h4 id="7-3-happens-before规则"><a href="#7-3-happens-before规则" class="headerlink" title="7.3 happens-before规则"></a>7.3 happens-before规则</h4><p><code>《JSR-133:Java Memory Model and Thread Specification》</code>定义了如下<code>happens-before</code>规则：</p><ol><li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li><li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li></ol><h3 id="8-双重检查锁定与延迟初始化"><a href="#8-双重检查锁定与延迟初始化" class="headerlink" title="8. 双重检查锁定与延迟初始化"></a>8. 双重检查锁定与延迟初始化</h3><p><strong>双重检查锁定</strong>是常见的<strong>延迟初始化</strong>技术，但它是一个<u>错误</u>的用法。</p><h4 id="8-1-双重检查锁定的由来"><a href="#8-1-双重检查锁定的由来" class="headerlink" title="8.1 双重检查锁定的由来"></a>8.1 双重检查锁定的由来</h4><p>有时候可能需要推迟一些<strong><u>高开销</u></strong>的对象初始化操作，并且只有在使用这些对象时才进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非线程安全的延迟初始化对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeLazyInitialization</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">// 1：A线程执行</span></span><br><span class="line">        instance = <span class="keyword">new</span> Instance(); <span class="comment">// 2：B线程执行</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以对getInstance()方法做同步处理来实现线程安全的延迟初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeLazyInitialization</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronized将导致性能开销</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">// 1：A线程执行</span></span><br><span class="line">        instance = <span class="keyword">new</span> Instance(); <span class="comment">// 2：B线程执行</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>早期的JVM中<code>synchronized</code>（甚至是<u>无竞争</u>的<code>synchronized</code>）存在巨大的性能开销。因此，人们想通过<code>双重检查锁定（Double-Checked Locking）</code>来降低同步的开销：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLocking</span> </span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance; <span class="comment">// 2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 4:第一次检查</span></span><br><span class="line">        <span class="keyword">synchronized</span> (DoubleCheckedLocking<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">// 5:加锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">// 6:第二次检查</span></span><br><span class="line">        instance = <span class="keyword">new</span> Instance(); <span class="comment">// 7:问题的根源出在这里</span></span><br><span class="line">        &#125; <span class="comment">// 8</span></span><br><span class="line">        &#125; <span class="comment">// 9</span></span><br><span class="line">        <span class="keyword">return</span> instance; <span class="comment">// 10</span></span><br><span class="line">    &#125; <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果第一次检查instance不为null，那么就<u>不需要执行下面的加锁和初始化操作</u>。因此，可以大幅降低<code>synchronized</code>带来的性能开销。<code>但这是一个错误的优化！</code>在线程执行到第4行，代码读取到instance不为null时，<u><strong>instance引用的对象有可能还没有完成初始化</strong></u>。</p><p>双重检查锁定的第7行（<code>instance = new Instance();</code>）创建了一个对象。这一行代码可以分解为3行伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">// 1：分配对象的内存空间</span></span><br><span class="line">ctorInstance(memory); <span class="comment">// 2：初始化对象</span></span><br><span class="line">instance = memory; <span class="comment">// 3：设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure><p>上面3行伪代码中的2和3之间，可能会被重排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">// 1：分配对象的内存空间</span></span><br><span class="line">instance = memory; <span class="comment">// 3：设置instance指向刚分配的内存地址</span></span><br><span class="line"><span class="comment">// 注意，此时对象还没有被初始化！</span></span><br><span class="line">ctorInstance(memory); <span class="comment">// 2：初始化对象</span></span><br></pre></td></tr></table></figure><p>如果发生重排序，另一个并发执行的线程B就有可能访问到未被A线程初始化的instance对象：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/DoubleCheckedLock.PNG" alt="双重检查锁定问题的根源"></p><p>本质上还是因为创建了一个对象的过程是非原子性的。</p><h4 id="8-2-基于volatile的解决方案"><a href="#8-2-基于volatile的解决方案" class="headerlink" title="8.2 基于volatile的解决方案"></a>8.2 基于volatile的解决方案</h4><p>基于<code>volatile</code>可以禁止2和3重排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeDoubleCheckedLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SafeDoubleCheckedLocking<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">    instance = <span class="keyword">new</span> Instance(); <span class="comment">// instance为volatile，现在没问题了</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-基于类初始化的解决方案"><a href="#8-3-基于类初始化的解决方案" class="headerlink" title="8.3 基于类初始化的解决方案"></a>8.3 基于类初始化的解决方案</h4><p>允许2和3重排序，但不允许其他线程“看到”这个重排序。</p><p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会去获取一个锁。基于这个特性，可以实现另一种线程安全的延迟初始化方案：<code>Initialization On Demand Holder idiom</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> InstanceHolder.instance ; <span class="comment">// 这里将导致InstanceHolder类被初始化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化一个类，包括执行这个类的<strong>静态初始化</strong>和初始化在这个类中声明的<strong>静态字段</strong>。根据Java语言规范，在<code>首次发生</code>下列任意一种情况时，一个类或接口类型<code>T</code>将被立即初始化。</p><ol><li><code>T</code>是一个类，而且一个<code>T</code>类型的实例被创建。</li><li><code>T</code>是一个类，且<code>T</code>中声明的一个静态方法被调用。</li><li><code>T</code>中声明的一个静态字段被赋值。</li><li><code>T</code>中声明的一个静态字段被使用，而且<u><strong>这个字段不是一个常量字段</strong></u>。</li><li><code>T</code>是一个顶级类（Top Level Class），而且一个<strong>断言语句</strong>嵌套在<code>T</code>内部被执行。</li></ol><p>Java语言规范规定，对于每一个类或接口都有一个唯一的初始化锁与之对应。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了。Java初始化一个类或接口的处理过程如下：</p><ul><li>第1阶段：通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化。这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。</li><li>第2阶段：线程A执行类的初始化，同时线程B在初始化锁对应的condition上等待。</li><li>第3阶段：线程A设置state=initialized，然后唤醒在condition中等待的所有线程。</li><li>第4阶段：线程B结束类的初始化处理。</li><li>第5阶段：线程C执行类的初始化的处理。在第3阶段之后，类已经完成了初始化。因此线程C在第5阶段的类初始化处理过程相对简单一些（线程C的类初始化处理只需要经历一次锁获取-锁释放）。</li></ul><p>字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。在大多数时候，正常的初始化要优于延迟初始化。</p><h3 id="9-Java内存模型综述"><a href="#9-Java内存模型综述" class="headerlink" title="9. Java内存模型综述"></a>9. Java内存模型综述</h3><h4 id="9-1-处理器的内存模型"><a href="#9-1-处理器的内存模型" class="headerlink" title="9.1 处理器的内存模型"></a>9.1 处理器的内存模型</h4><p>根据<u><strong>对不同类型的读/写操作组合的执行顺序的放松</strong></u>，可以把常见处理器的内存模型划分为如下几种类型。</p><ul><li>放松程序中<code>写-读操作</code>的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）。</li><li>在上面的基础上，继续放松程序中<code>写-写操作</code>的顺序，由此产生了Partial Store Order内存模型（简称为PSO）。</li><li>在前面两条的基础上，继续放松程序中<code>读-写</code>和<code>读-读</code>操作的顺序，由此产生了Relaxed Memory Order内存模型（简称为RMO）和PowerPC内存模型。</li></ul><h4 id="9-2-JMM的内存可见性保证"><a href="#9-2-JMM的内存可见性保证" class="headerlink" title="9.2 JMM的内存可见性保证"></a>9.2 JMM的内存可见性保证</h4><p>按程序类型，Java程序的内存可见性保证可以分为下列3类。</p><ul><li><strong>单线程程序</strong>。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li><li><strong>正确同步的多线程程序</strong>。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。</li><li><strong>未同步/未正确同步的多线程程序</strong>。JMM为它们提供了<u>最小安全性保障</u>：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java线程之间的通信对程序员完全透明，内存可见性问题很容易困扰Java程序员&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--2 Java并发机制的底层实现原理</title>
    <link href="https://wuyunjie.top/2021/07/13/JavaLearning_The_art_of_concurrent_programming_in_Java-2-The-underlying-implementation-principle.html"/>
    <id>https://wuyunjie.top/2021/07/13/JavaLearning_The_art_of_concurrent_programming_in_Java-2-The-underlying-implementation-principle.html</id>
    <published>2021-07-13T02:01:19.000Z</published>
    <updated>2021-07-13T02:01:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>Java中所使用的并发机制依赖于JVM的实现和CPU的指令</code><br><a id="more"></a></p></blockquote><h3 id="1-volatile的应用"><a href="#1-volatile的应用" class="headerlink" title="1. volatile的应用"></a>1. <code>volatile</code>的应用</h3><p><code>volatile</code>是<strong>轻量级</strong>的<code>synchronized</code>，它在多处理器开发中保证了共享变量的<code>“可见性”</code>。</p><blockquote><p><code>可见性</code>是<u>当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值</u>。</p></blockquote><h4 id="1-1-volatile的定义与实现原理"><a href="#1-1-volatile的定义与实现原理" class="headerlink" title="1.1 volatile的定义与实现原理"></a>1.1 <code>volatile</code>的定义与实现原理</h4><p>Java编程语言允许线程访问共享变量，为了确保共享变量能被<code>准确</code>和<code>一致</code>地更新，线程应该确保通过<code>排他锁</code>单独获得这个变量。如果一个字段被声明成<code>volatile</code>，Java线程内存模型确保<u>所有线程看到这个变量的值是一致的</u>。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/CPUTerm.png" alt="CPU的术语定义"></p><p>有<code>volatile</code>变量修饰的共享变量进行写操作时会有一行<code>Lock</code>前缀的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x01a3de1d: movb $0×0,0×1104800(%esi);</span><br><span class="line">0x01a3de24: lock addl $0×0,(%esp);</span><br></pre></td></tr></table></figure><p><code>Lock</code>指令在多核处理器下会:</p><ul><li>将当前处理器缓存行的数据<strong>写回到系统内存</strong>。</li><li>写回内存的操作会使在其他CPU里缓存了该内存地址的数据<strong>无效</strong>。在多处理器下，理由<code>缓存一致性协议</code>保证各个处理器的缓存是一致的，每个处理器通过<strong>嗅探</strong>在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成<code>无效状态</code>，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</li></ul><p><code>volatile</code>的两条实现原则：</p><ul><li><code>Lock</code>前缀指令会引起处理器缓存回写到内存。</li><li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</li></ul><h4 id="1-2-volatile的使用优化"><a href="#1-2-volatile的使用优化" class="headerlink" title="1.2 volatile的使用优化"></a>1.2 <code>volatile</code>的使用优化</h4><p>队列集合类<code>LinkedTransferQueue</code>在使用<code>volatile</code>变量时，用一种追加字节的方式来优化队列出队和入队的性能。<code>LinkedTransferQueue</code>的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 队列中的头部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"><span class="comment">/** 队列中的尾部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedAtomicReference</span> &lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 使用很多4个字节的引用追加到64个字节</span></span><br><span class="line">Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;</span><br><span class="line"></span><br><span class="line">    PaddedAtomicReference(T r) &#123;</span><br><span class="line"><span class="keyword">super</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span> &lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>类<code>LinkedTransferQueue</code>使用一个内部类<code>PaddedAtomicReference</code>来定义队列的<strong>头节点（head）</strong>和<strong>尾节点（tail）</strong>，这个内部类相对于父类 <code>AtomicReference</code>只将共享变量追加到<code>64</code>字节。</p><p>主要原因是一些处理器的<code>L1</code>、<code>L2</code>或<code>L3</code>缓存的高速缓存行是64个字节宽，不支持部分填充缓存行。如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都<strong><u>读到同一个高速缓存行中</u></strong>，当一 个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，严重影响到队列的入队和出队效率。</p><p>通过追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。但在两种场景下不应该使用这种方式：</p><ul><li>缓存行非64字节宽的处理器。</li><li>共享变量不会被频繁地写。</li></ul><blockquote><p><code>Java 7</code>会淘汰或重新排列无用字段，需要使用其他追加字节的方式</p></blockquote><h3 id="2-synchronized的实现原理与应用"><a href="#2-synchronized的实现原理与应用" class="headerlink" title="2.  synchronized的实现原理与应用"></a>2.  <code>synchronized</code>的实现原理与应用</h3><p><code>synchronized</code>被称呼为<strong>重量级锁</strong>。随着<code>Java SE 1.6</code>对<code>synchronized</code>的优化，它变得轻量级了。下利用<code>synchronized</code>实现同步的基础：<strong>Java中的每一个对象都可以作为锁</strong>。</p><ul><li>对于<strong>普通同步方法</strong>，锁是当前实例对象。</li><li>对于<strong>静态同步方法</strong>，锁是当前类的<code>Class</code>对象。</li><li>对于<strong>同步方法块</strong>，锁是<code>Synchonized</code>括号里配置的对象。</li></ul><p>当一个线程试图<u>访问同步代码块</u>时，它首先<strong>必须得到锁，退出或抛出异常时必须释放锁</strong>。<code>JVM</code>基于进入和退出<code>Monitor对象</code>来实现<strong>方法同步</strong>和<strong>代码块同步</strong>：</p><ul><li><code>代码块同步</code>是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的；<ul><li><code>monitorenter</code>指令是在编译后插入到同步代码块的开始位置；</li><li><code>monitorexit</code>是插入到方法结束处和异常处；</li><li><code>JVM</code>要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对；</li><li>任何对象都有一个<code>monitor</code>与之关联，当且仅当一个<code>monitor</code>被持有后，它将处于<strong>锁定状态</strong>。线程执行到<code>monitorenter</code>指令时，将会尝试获取对象所对应的<code>monitor</code>的所有权，即尝试获得对象的锁。</li></ul></li><li><code>方法同步</code>是使用另外一种方式实现的，细节在<strong>JVM规范</strong>里并没有详细说明。方法的同步同样可以使用这两个指令来实现。</li></ul><h4 id="2-1-Java对象头"><a href="#2-1-Java对象头" class="headerlink" title="2.1 Java对象头"></a>2.1 Java对象头</h4><p><code>synchronized</code>用的锁是存在<strong>Java对象</strong>头里的。Java对象头里的<code>Mark Word</code>里默认存储对象的<code>HashCode</code>、分代年龄和锁标记位。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/objectHeadLength.PNG" alt="Java对象头的长度"></p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/objectHeadStructure.PNG" alt="Java对象头的存储结构"></p><p>在运行期间，<code>Mark Word</code>里存储的数据会随着锁标志位的变化而变化。</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/objectHeadMarkWord.PNG" alt="Mark Word的状态变化"></p><p><code>64位虚拟机</code>下，<code>Mark Word</code>是<code>64bit</code>大小的，其存储结构如下：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/objectHeadMarkWord64.PNG" alt="Mark Word的状态变化(64bits)"></p><h4 id="2-2-锁的升级与对比"><a href="#2-2-锁的升级与对比" class="headerlink" title="2.2 锁的升级与对比"></a>2.2 锁的升级与对比</h4><p>在<code>Java SE 1.6</code>中，锁一共有<code>4</code>种状态，级别从低到高依次是：<code>无锁状态</code>、<code>偏向锁状态</code>、<code>轻量级锁状态</code>和<code>重量级锁状态</code>，这几个状态会随着竞争情况逐渐升级。</p><blockquote><ul><li><p><strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。</p></li><li><p>引入了<code>“偏向锁”</code>和<code>“轻量级锁”</code>，是为了<u>减少获得锁和释放锁带来的性能消耗</u>。</p></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/BiasedLock.PNG" alt="偏向锁"></p><h5 id="2-2-1-偏向锁"><a href="#2-2-1-偏向锁" class="headerlink" title="2.2.1 偏向锁"></a>2.2.1 偏向锁</h5><p>大多数情况下，锁不仅不存在多线程竞争，而且<u><strong>总是由同一线程多次获得</strong></u>，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储<strong>锁偏向的线程ID</strong>，以后该线程在进入和退出同步块时不需要进行<code>CAS</code>操作来加锁和解锁，只需简单地测试一下对象头的<code>Mark Word</code>里<u><strong>是否存储着指向当前线程的偏向锁</strong></u>。</p><ul><li>如果测试成功，表示线程已经获得了锁。</li><li>如果测试失败，则需要再测试一下<code>Mark Word</code>中偏向锁的标识是否设置成<code>1</code>（表示当前是偏向锁）。如果没有设置，则使用<code>CAS</code>竞争锁；如果设置了，则尝试使用<code>CAS</code>将对象头的偏向锁指向当前线程。</li></ul><p>偏向锁使用了一种<u>等到竞争出现才释放锁的机制</u>，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待<strong>全局安全点</strong>（在这个时间点上没有正在执行的字节码）。</p><ul><li>首先暂停拥有偏向锁的线程；</li><li>然后检查持有偏向锁的线程是否活着：<ul><li>如果线程不处于活动状态，则将对象头设置成无锁状态；</li><li>如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的<code>Mark Word</code>要么重新偏向于其他 线程，要么恢复到无锁或者标记对象不适合作为偏向锁。</li></ul></li><li>最后唤醒暂停的线程。</li></ul><h5 id="2-2-2-轻量级锁"><a href="#2-2-2-轻量级锁" class="headerlink" title="2.2.2 轻量级锁"></a>2.2.2 轻量级锁</h5><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/LightweightLock.PNG" alt="轻量级锁"></p><h6 id="2-2-2-1-轻量级锁加锁"><a href="#2-2-2-1-轻量级锁加锁" class="headerlink" title="2.2.2.1 轻量级锁加锁"></a>2.2.2.1 轻量级锁加锁</h6><p>线程在执行同步块之前，<code>JVM</code>会先在当前线程的<strong>栈桢</strong>中创建<u>用于存储锁记录</u>的空间，并将对象头中的<code>Mark Word</code>复制到锁记录中，官方称为<code>Displaced Mark Word</code>。然后线程尝试使用<code>CAS</code>将对象头中的<code>Mark Word</code>替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋</strong>来获取锁。</p><h6 id="2-2-2-2-轻量级锁解锁"><a href="#2-2-2-2-轻量级锁解锁" class="headerlink" title="2.2.2.2 轻量级锁解锁"></a>2.2.2.2 轻量级锁解锁</h6><p>轻量级解锁时，会使用原子的<code>CAS</code>操作将<code>Displaced Mark Word</code>替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会<strong>膨胀</strong>成重量级锁。因为<code>自旋</code>会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。</p><h4 id="2-2-3-锁的优缺点对比"><a href="#2-2-3-锁的优缺点对比" class="headerlink" title="2.2.3 锁的优缺点对比"></a>2.2.3 锁的优缺点对比</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/LockAdAndDisad.PNG" alt="锁的优缺点的对比"></p><h3 id="3-原子操作的实现原理"><a href="#3-原子操作的实现原理" class="headerlink" title="3. 原子操作的实现原理"></a>3. 原子操作的实现原理</h3><p>原子操作（atomic operation）指“不可被中断的一个或一系列操作”。</p><h4 id="3-1-术语定义"><a href="#3-1-术语定义" class="headerlink" title="3.1 术语定义"></a>3.1 术语定义</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/CPUTerm2.PNG" alt="术语定义"></p><h4 id="3-2-实现原子操作"><a href="#3-2-实现原子操作" class="headerlink" title="3.2 实现原子操作"></a>3.2 实现原子操作</h4><p><code>32位IA-32处理器</code>使用<strong><u>基于对缓存加锁</u></strong>或<strong><u>总线加锁</u></strong>的方式来实现多处理器之间的原子操作。</p><ul><li>首先处理器会自动保证<strong>基本的内存操作</strong>的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，即当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。</li><li>但是处理器不能自动保证<strong>复杂的内存操作</strong>的原子性，比如<u>跨总线宽度</u>、<u>跨多个缓存行</u>和<u>跨页表</u>的访问。</li></ul><p>处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来<u>保证复杂内存操作的原子性</u>。</p><h5 id="3-2-1-总线锁保证原子性"><a href="#3-2-1-总线锁保证原子性" class="headerlink" title="3.2.1 总线锁保证原子性"></a>3.2.1 总线锁保证原子性</h5><p>总线锁就是使用处理器提供的一个<code>LOCK＃</code>信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以<strong>独占共享内存</strong>。</p><h5 id="3-2-2-缓存锁保证原子性"><a href="#3-2-2-缓存锁保证原子性" class="headerlink" title="3.2.2 缓存锁保证原子性"></a>3.2.2 缓存锁保证原子性</h5><p>同一时刻只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，锁定期间其他处理器<u><strong>不能操作其他内存地址的数据</strong></u>，所以总线锁定的开销比较大，目前处理器在某些场合下<u>使用缓存锁定代替总线锁定来进行优化</u>。</p><p><code>“缓存锁定”</code>是指内存区域如果被缓存在处理器的缓存行中，并且在<code>Lock</code>操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言<code>LOCK＃</code>信号，而是<strong><u>修改内部的内存地址</u></strong>，并允许它的缓存一致性机制来保证操作的原子 性，因为<u>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</u>，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p><p><strong>有两种情况下处理器不会使用缓存锁定</strong>：</p><ul><li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，处理器会调用总线锁定。</li><li>有些处理器不支持缓存锁定。</li></ul><h4 id="3-3-Java实现原子操作"><a href="#3-3-Java实现原子操作" class="headerlink" title="3.3 Java实现原子操作"></a>3.3 Java实现原子操作</h4><p>在<code>Java</code>中可以通过<strong>锁</strong>和<strong>循环CAS</strong>的方式来实现原子操作：</p><h5 id="3-3-1-使用循环CAS实现原子操作"><a href="#3-3-1-使用循环CAS实现原子操作" class="headerlink" title="3.3.1 使用循环CAS实现原子操作"></a>3.3.1 使用<code>循环CAS</code>实现原子操作</h5><p>JVM中的<code>CAS操作</code>利用了处理器提供的<code>CMPXCHG</code>指令实现的，自旋CAS实现的基本思路是<u><strong>循环进行CAS操作直到成功为止</strong></u>。从<code>Java 1.5</code>开始，<code>JDK</code>的并发包里提供了一些类来支持原子操作，如<code>AtomicBoolean</code>、<code>AtomicInteger</code>和<code>AtomicLong</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger atomicI = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/** * 使用CAS实现线程安全计数器 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">int</span> i = atomicI.get();</span><br><span class="line"><span class="keyword">boolean</span> suc = atomicI.compareAndSet(i, ++i);</span><br><span class="line"><span class="keyword">if</span> (suc) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-CAS实现原子操作的三大问题"><a href="#3-3-2-CAS实现原子操作的三大问题" class="headerlink" title="3.3.2 CAS实现原子操作的三大问题"></a>3.3.2 CAS实现原子操作的三大问题</h5><ol><li><strong>ABA问题</strong>。因为<code>CAS</code>需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是<code>A</code>，变成了<code>B</code>，又变成了<code>A</code>，那么使用<code>CAS</code>进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是<strong><u>使用版本号</u></strong>。<code>JDK</code>的<code>Atomic</code>包里提供了一个类<code>AtomicStampedReference</code>来解决<code>ABA</code>问题。这个类的<code>compareAndSet</code>方法：<ul><li>首先检查当前引用是否等于预期引用；</li><li>然后检查当前标志是否等于预期标志；</li><li>如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li></ul></li><li><strong>循环时间长开销大</strong>。自旋<code>CAS</code>如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持<code>pause指令</code>，那么效率会有一定的提升。pause指令有两个作用：<ul><li><strong>延迟流水线执行指令（de-pipeline）</strong>，使CPU不会消耗过多的执行资源；</li><li>避免在退出循环的时候因<code>内存顺序冲突（Memory Order Violation）</code>而引起<code>CPU流水线被清空（CPU Pipeline Flush）</code>，从而提高CPU的执行效率。</li></ul></li><li><strong>只能保证一个共享变量的原子操作</strong>。对多个共享变量操作时，循环<code>CAS</code>就无法保证操作的原子性，这个时候就可以用<strong>锁</strong>。JDK也提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行<code>CAS操作</code>。</li></ol><h5 id="3-3-3-使用锁机制实现原子操作"><a href="#3-3-3-使用锁机制实现原子操作" class="headerlink" title="3.3.3 使用锁机制实现原子操作"></a>3.3.3 使用锁机制实现原子操作</h5><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。除了<code>偏向锁</code>，JVM实现锁的方式都用了<code>循环 CAS</code>，即当一个线程想进入同步块的时候<strong>使用循环CAS的方式来<u>获取锁</u></strong>，当它退出同步块的时候<strong>使用循环CAS<u>释放锁</u></strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java中所使用的并发机制依赖于JVM的实现和CPU的指令&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Java学习|Java并发编程的艺术]--1 并发编程的挑战</title>
    <link href="https://wuyunjie.top/2021/07/12/JavaLearning_The_art_of_concurrent_programming_in_Java-1-Challenges-of-concurrent-programming.html"/>
    <id>https://wuyunjie.top/2021/07/12/JavaLearning_The_art_of_concurrent_programming_in_Java-1-Challenges-of-concurrent-programming.html</id>
    <published>2021-07-12T13:15:56.000Z</published>
    <updated>2021-07-12T13:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><code>并发编程的目的是为了让程序运行得更快。在进行并发编程时，如果希望通过多线程执行任务让程序运行得更快，会面临非常多的挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题</code><br><a id="more"></a></p></blockquote><h3 id="1-上下文切换"><a href="#1-上下文切换" class="headerlink" title="1. 上下文切换"></a>1. 上下文切换</h3><p>CPU通过<u>给每个线程分配CPU时间片来实现多线程</u>。<strong>时间片</strong>是<code>CPU</code>分配给各个线程的时间，一般是几十毫秒（ms）。<code>CPU</code>通过时间片分配算法来循环执行任务，在切换任务前会保存上一个任务的状态，以便下次切换回来时可以再加载这个任务的状态。所以<u>任务从保存到再加载的过程</u>就是一次<strong>上下文切换（CS，<code>Content Switch</code>）</strong>。</p><h4 id="1-1-多线程的效率"><a href="#1-1-多线程的效率" class="headerlink" title="1.1 多线程的效率"></a>1.1 多线程的效率</h4><p>并发执行并不一定比串行执行快，比如下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Concurrency.Chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> count = <span class="number">1000000l</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        concurrency();</span><br><span class="line">        serial();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concurrency</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    a += <span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">"concurrency :"</span> + time+<span class="string">"ms,b="</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            a += <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">"serial:"</span> + time+<span class="string">"ms,b="</span>+b+<span class="string">",a="</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当并发执行累加操作<strong>不超过百万次</strong>时，速度会比串行执行累加操作要慢。因为<code>线程有创建和上下文切换的开销</code>。</p><h4 id="1-2-上下文切换次数和时长"><a href="#1-2-上下文切换次数和时长" class="headerlink" title="1.2 上下文切换次数和时长"></a>1.2 上下文切换次数和时长</h4><p>可以度量上下文切换带来的消耗的工具：</p><ul><li><code>Lmbench3</code>：可以测量上下文切换的<strong>时长</strong>。</li><li><code>vmstat</code>：可以测量上下文切换的<strong>次数</strong>。</li></ul><h4 id="1-3-减少上下文切换"><a href="#1-3-减少上下文切换" class="headerlink" title="1.3 减少上下文切换"></a>1.3 减少上下文切换</h4><p>减少上下文切换的方法有<code>无锁并发编程</code>、<code>CAS算法</code>、使用<code>最少线程</code>和使用<code>协程</code>。</p><ul><li><code>无锁并发编程</code>。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一 些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li><li><code>CAS算法</code>。Java的<code>Atomic</code>包使用<code>CAS算法</code>来更新数据，而不需要加锁。</li><li>使用<code>最少线程</code>。避免创建不需要的线程，创建过多线程会造成大量线程都处于等待状态。</li><li><code>协程</code>。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul><h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2. 死锁"></a>2. 死锁</h3><p>一旦产生死锁，就会造成系统功能不可用。如下代码会引发死锁，使线程<code>t1</code>和线程<code>t2</code>互相等待对方释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Concurrency.Chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String A = <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String B = <span class="string">"B"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DeadLockDemo().deadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免死锁的几个常见方法。</p><ul><li>避免一个线程同时获取多个锁。</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li><li>尝试使用定时锁，使用<code>lock.tryLock(timeout)</code>来替代使用内部锁机制。</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li></ul><h3 id="3-资源限制的挑战"><a href="#3-资源限制的挑战" class="headerlink" title="3. 资源限制的挑战"></a>3. 资源限制的挑战</h3><h4 id="3-1-资源限制"><a href="#3-1-资源限制" class="headerlink" title="3.1 资源限制"></a>3.1 资源限制</h4><p>资源限制是指在进行并发编程时，<u>程序的执行速度受限于计算机硬件资源或软件资源</u>。</p><ul><li>硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。</li><li>软件资源限制有数据库的连接数和socket连接数等。</li></ul><h4 id="3-2-资源限制引发的问题"><a href="#3-2-资源限制引发的问题" class="headerlink" title="3.2 资源限制引发的问题"></a>3.2 资源限制引发的问题</h4><p>如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为<code>增加了上下文切换和资源调度的时间</code>。</p><h4 id="3-3-何解决资源限制的问题"><a href="#3-3-何解决资源限制的问题" class="headerlink" title="3.3 何解决资源限制的问题"></a>3.3 何解决资源限制的问题</h4><ul><li>对于硬件资源限制，可以考虑<strong>使用集群</strong>并行执行程序。</li><li>对于软件资源限制，可以考虑<strong>使用资源池</strong>将资源复用。</li></ul><h4 id="3-4-资源限制情况下并发编程"><a href="#3-4-资源限制情况下并发编程" class="headerlink" title="3.4 资源限制情况下并发编程"></a>3.4 资源限制情况下并发编程</h4><p>根据不同的资源限制调整程序的并发度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;并发编程的目的是为了让程序运行得更快。在进行并发编程时，如果希望通过多线程执行任务让程序运行得更快，会
面临非常多的挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="Java并发编程" scheme="https://wuyunjie.top/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|二叉树的构建和相关操作]</title>
    <link href="https://wuyunjie.top/2021/06/30/Data_structure_and_algorithm_binary_tree.html"/>
    <id>https://wuyunjie.top/2021/06/30/Data_structure_and_algorithm_binary_tree.html</id>
    <published>2021-06-30T12:17:55.000Z</published>
    <updated>2021-06-30T12:17:55.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://wuyunjie.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|各种排序算法原理及实现]</title>
    <link href="https://wuyunjie.top/2021/06/30/Data_structure_and_algorithm_sorting_algorithm.html"/>
    <id>https://wuyunjie.top/2021/06/30/Data_structure_and_algorithm_sorting_algorithm.html</id>
    <published>2021-06-30T12:11:46.000Z</published>
    <updated>2021-06-30T12:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-排序问题的形式定义"><a href="#1-排序问题的形式定义" class="headerlink" title="1. 排序问题的形式定义"></a>1. 排序问题的形式定义</h3><p>可以将<strong>排序问题</strong>形式化定义为如下：</p><blockquote><p><strong>输入</strong>: $n$ 个数的一个序列 $\left\langle a<em>{1}, a</em>{2}, \cdots, a<em>{n}\right\rangle$。<br><strong>输出</strong>: 输入序列的一个排列 $\left\langle a</em>{1}^{\prime}, a<em>{2}^{\prime}, \cdots, a</em>{n}^{\prime}\right\rangle$, 满足 $a<em>{1}^{\prime} \leqslant a</em>{2}^{\prime} \leqslant \cdots \leqslant a_{n}^{\prime}$ 。</p></blockquote><p>希望排序的数也称为<strong>关键词</strong>。</p><a id="more"></a><h3 id="2-排序算法"><a href="#2-排序算法" class="headerlink" title="2. 排序算法"></a>2. 排序算法</h3><h4 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h4><h5 id="2-1-1-插入排序算法介绍"><a href="#2-1-1-插入排序算法介绍" class="headerlink" title="2.1.1 插入排序算法介绍"></a>2.1.1 插入排序算法介绍</h5><p>对于少量元素的排序，插入排序是一种有效的算法。插入排序的伪代码如下，输入是数组$A[1.. n]$：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line">for j = 2 to A.length</span><br><span class="line">key = A[j]</span><br><span class="line">// Insert A[j] into the sorted sequence A[1 .. j-1].</span><br><span class="line">i = j - 1</span><br><span class="line">while i &gt; 0 and A[i] &gt; key</span><br><span class="line">A[ i + i ] = A[i]</span><br><span class="line">i = i - 1</span><br><span class="line">A[ i + 1 ] = key</span><br></pre></td></tr></table></figure><h5 id="2-1-2-循环不变式与插入排序的正确性"><a href="#2-1-2-循环不变式与插入排序的正确性" class="headerlink" title="2.1.2 循环不变式与插入排序的正确性"></a>2.1.2 循环不变式与插入排序的正确性</h5><p>下图式对数组$A=<5, 2, 4, 6, 1, 3>$的插入排序：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/sort/insertSortExample.PNG" alt="插入排序示例"></p><p>在<code>for</code>循环每次迭代开始时，子数组$A[1.. j-1]$由原来在$A[1.. j-1]$中的元素组成，但已按顺序排列，即<strong><code>循环不变式</code></strong>。<strong><code>循环不变式</code></strong>用于帮助理解算法地正确性。关于循环不变式需要证明三条性质：</p><ul><li><strong>初始化</strong>：循环的第一次迭代之前，它为真。</li><li><strong>保持</strong>：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。</li><li><strong>终止</strong>：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。</li></ul><h5 id="2-1-3-插入排序算法的分析"><a href="#2-1-3-插入排序算法的分析" class="headerlink" title="2.1.3 插入排序算法的分析"></a>2.1.3 插入排序算法的分析</h5><p>这里是基于<strong>算法导论</strong>中算法分析给出的计算方法，做一个示例：</p><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/sort/insertSortTimeAnalysis.PNG" alt="插入排序运行时间分析"></p><p>算法运行时间是职校每条语句的执行时间之和：</p><script type="math/tex; mode=display">T(n)=c_{1} n+c_{2}(n-1)+c_{4}(n-1)+c_{5} \sum_{j=2}^{n} t_{j}+c_{6} \sum_{j=2}^{n}\left(t_{j}-1\right)+c_{7} \sum_{j=2}^{n}\left(t_{j}-1\right)+c_{8}(n-1)</script><p>当输入数组已经排好序时，出现最佳情况，使得$t_j=1$，则最佳情况下的运行时间为：</p><script type="math/tex; mode=display">\begin{aligned}T(n) &=c_{1} n+c_{2}(n-1)+c_{4}(n-1)+c_{5}(n-1)+c_{8}(n-1) \\&=\left(c_{1}+c_{2}+c_{4}+c_{5}+c_{8}\right) n-\left(c_{2}+c_{4}+c_{5}+c_{8}\right)\end{aligned}</script><p>可以将其表示为$an+b$，因此它是$n$的<strong>线性函数</strong>。若输出数组是反向排序，即按递减排好序，此时出现最坏情况，有$t_j=j$，由于有：</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{j=2}^{n} j=\frac{n(n+1)}{2}-1 \\&\sum_{j=2}^{n}(j-1)=\frac{n(n-1)}{2}\end{aligned}</script><p>最坏情况下，插入排序运行时间为：</p><script type="math/tex; mode=display">\begin{aligned}T(n)=& c_{1} n+c_{2}(n-1)+c_{4}(n-1)+c_{5}\left(\frac{n(n+1)}{2}-1\right) \\&+c_{6}\left(\frac{n(n-1)}{2}\right)+c_{7}\left(\frac{n(n-1)}{2}\right)+c_{8}(n-1) \\=&\left(\frac{c_{5}}{2}+\frac{c_{6}}{2}+\frac{c_{7}}{2}\right) n^{2}+\left(c_{1}+c_{2}+c_{4}+\frac{c_{5}}{2}-\frac{c_{6}}{2}-\frac{c_{7}}{2}+c_{8}\right) n \\&-\left(c_{2}+c_{4}+c_{5}+c_{8}\right)\end{aligned}</script><p>可以将其表示为$an^2+bn+c$，因此它是$n$的<strong>二次函数</strong>。一般只求<strong>最坏情况运行时间</strong>，记插入排序具有最坏情况运行时间$O(n^2)$。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-排序问题的形式定义&quot;&gt;&lt;a href=&quot;#1-排序问题的形式定义&quot; class=&quot;headerlink&quot; title=&quot;1. 排序问题的形式定义&quot;&gt;&lt;/a&gt;1. 排序问题的形式定义&lt;/h3&gt;&lt;p&gt;可以将&lt;strong&gt;排序问题&lt;/strong&gt;形式化定义为如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;: $n$ 个数的一个序列 $\left\langle a&lt;em&gt;{1}, a&lt;/em&gt;{2}, \cdots, a&lt;em&gt;{n}\right\rangle$。&lt;br&gt;&lt;strong&gt;输出&lt;/strong&gt;: 输入序列的一个排列 $\left\langle a&lt;/em&gt;{1}^{\prime}, a&lt;em&gt;{2}^{\prime}, \cdots, a&lt;/em&gt;{n}^{\prime}\right\rangle$, 满足 $a&lt;em&gt;{1}^{\prime} \leqslant a&lt;/em&gt;{2}^{\prime} \leqslant \cdots \leqslant a_{n}^{\prime}$ 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;希望排序的数也称为&lt;strong&gt;关键词&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="https://wuyunjie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序算法" scheme="https://wuyunjie.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构和算法|算法分析]</title>
    <link href="https://wuyunjie.top/2021/06/30/Data_structure_and_algorithm_algorithm_analysis.html"/>
    <id>https://wuyunjie.top/2021/06/30/Data_structure_and_algorithm_algorithm_analysis.html</id>
    <published>2021-06-30T12:09:23.000Z</published>
    <updated>2021-06-30T12:42:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-算法介绍"><a href="#1-算法介绍" class="headerlink" title="1. 算法介绍"></a>1. 算法介绍</h3><h4 id="1-1-算法"><a href="#1-1-算法" class="headerlink" title="1.1. 算法"></a>1.1. 算法</h4><blockquote><p>非形式地说，<strong>算法</strong>（algorithm）就说任何<code>良定义</code>地计算过程，该过程取某个值或值的集合作为<strong>输入</strong>，并产生某个值或值的集合作为<strong>输出</strong>。即算法就是<u>把输入转化为输出的计算步骤的一个序列</u>。</p></blockquote><a id="more"></a><p>若对每个输入实例算法都以正确的输出<strong>停机</strong>，则称该算法是<strong>正确的</strong>，并称正确的算法<strong>解决了</strong>给定的计算问题。不正确的算法对某些输入实例可能根本<strong>不停机</strong>，也可能以不正确的回答停机。</p><h4 id="1-2-数据结构"><a href="#1-2-数据结构" class="headerlink" title="1.2. 数据结构"></a>1.2. 数据结构</h4><blockquote><p><strong>数据结构</strong>（data structure）是一种存储和组织数据的方式，旨在便于访问和修改。</p></blockquote><h3 id="2-分析算法"><a href="#2-分析算法" class="headerlink" title="2. 分析算法"></a>2. 分析算法</h3><p>分析算法的结果意味着预测算法需要的资源，通常度量的是<strong>计算时间</strong>。一般来说，算法需要的时间与<strong>输入规模</strong>同步增长，所以通常把一个程序的运行时间描述为<u>其输入规模的函数</u>。</p><h4 id="2-1-最坏情况与平均情况分析"><a href="#2-1-最坏情况与平均情况分析" class="headerlink" title="2.1. 最坏情况与平均情况分析"></a>2.1. 最坏情况与平均情况分析</h4><p>一般只求<strong>最坏情况运行时间</strong>，主要有三个理由：</p><ul><li>一个算法的最坏情况运行时间给出了任何输入运行时间的一个<strong>上界</strong>。</li><li>对某些算法，最坏情况经常出现。</li><li>“平均情况”往往与最坏情况大致一样差。</li></ul><h4 id="2-2-增长量级"><a href="#2-2-增长量级" class="headerlink" title="2.2. 增长量级"></a>2.2. 增长量级</h4><p>可以将运行时间就行更简化的抽象，即运行时间的<strong>增长率</strong>或<strong>增长量级</strong>。</p><ul><li><p>只考虑运行时间公式中最重要的项(比如，$an^2+bn+c$中的$an^2$)，因为$n$很大时，低阶项相对来说不太重要。</p></li><li><p>同时也忽略最重要项的常系数，因为在确定计算效率时常量因子不如增长率重要。</p></li></ul><p>比如记插入排序具有最坏情况运行时间$\Theta(n^2)$。<u>如果一个算法的最坏情况运行时间具有比另一个算法更低的增长量级，那么通常认为前者比后者更有效</u>。</p><h3 id="3-函数的增长"><a href="#3-函数的增长" class="headerlink" title="3. 函数的增长"></a>3. 函数的增长</h3><h4 id="3-1-渐近记号"><a href="#3-1-渐近记号" class="headerlink" title="3.1. 渐近记号"></a>3.1. 渐近记号</h4><p>主要使用渐近记号来描述算法的运行时间，渐近记号实际上应用于函数。</p><h5 id="3-1-1-Theta-记号"><a href="#3-1-1-Theta-记号" class="headerlink" title="3.1.1 $\Theta$记号"></a>3.1.1 $\Theta$记号</h5><p>比如插入排序的最坏情况运行时间为$T(n)=\Theta(n^2)$，对这个记号定义。对一个给定的函数$g(n)$，用 $\Theta(g(n))$来表示以下函数的集合: </p><script type="math/tex; mode=display">\begin{aligned}\Theta(g(n))=\left\{f(n) \text { :存在正常量 } c_{1}, c_{2} \text { 和 } n_{0}, \text { 使得对所有 } n \geqslant n_{0}, \text { 有 } 0 \leqslant c_{1} g(n) \leqslant f(n) \leqslant c_{2} g(n)\right\}\end{aligned}</script><p>所以 $\Theta(g(n))$是一个集合，可以记$f(n) \in \Theta(g(n))$以指出$f(n)$是$\Theta(g(n))$的成员。称$g(n)$是$f(n)$的一个<strong>渐近紧确界</strong>。</p><h5 id="3-1-2-O-记号"><a href="#3-1-2-O-记号" class="headerlink" title="3.1.2 $O$记号"></a>3.1.2 $O$记号</h5><p>当只有一个<strong>渐近上界</strong>时，使用$O$记号。对于给定的函数$g(n)$，用$O(g(n))$来表示以下函数的集合：</p><script type="math/tex; mode=display">\begin{aligned}O(g(n))=\left\{f(n): \text { 存在正常量 } c \text { 和 } n_{0}, \text { 使得对所有 } n \geqslant n_{0}, \text { 有 } 0 \leqslant f(n) \leqslant c g(n)\right\}\end{aligned}</script><h5 id="3-1-3-Omega-记号"><a href="#3-1-3-Omega-记号" class="headerlink" title="3.1.3 $\Omega$记号"></a>3.1.3 $\Omega$记号</h5><p>当只有一个<strong>渐近下界</strong>时，使用$\Omega$记号。对于给定的函数$g(n)$，用$\Omega(g(n))$来表示以下函数的集合：</p><script type="math/tex; mode=display">\begin{aligned}\Omega(g(n))=\left\{f(n): \text { 存在正常量 } c \text { 和 } n_{0}, \text { 使得对所有 } n \geqslant n_{0}, \text { 有 } 0 \leqslant c g(n) \leqslant f(n)\right\}\end{aligned}</script><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/algorithm/algorithmTime.PNG" alt="记号图例"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-算法介绍&quot;&gt;&lt;a href=&quot;#1-算法介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 算法介绍&quot;&gt;&lt;/a&gt;1. 算法介绍&lt;/h3&gt;&lt;h4 id=&quot;1-1-算法&quot;&gt;&lt;a href=&quot;#1-1-算法&quot; class=&quot;headerlink&quot; title=&quot;1.1. 算法&quot;&gt;&lt;/a&gt;1.1. 算法&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;非形式地说，&lt;strong&gt;算法&lt;/strong&gt;（algorithm）就说任何&lt;code&gt;良定义&lt;/code&gt;地计算过程，该过程取某个值或值的集合作为&lt;strong&gt;输入&lt;/strong&gt;，并产生某个值或值的集合作为&lt;strong&gt;输出&lt;/strong&gt;。即算法就是&lt;u&gt;把输入转化为输出的计算步骤的一个序列&lt;/u&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试复习" scheme="https://wuyunjie.top/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="数据结构和算法" scheme="https://wuyunjie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="https://wuyunjie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[Java|String,StringBuffer与StringBuilder的区别与用法]</title>
    <link href="https://wuyunjie.top/2021/06/25/JavaLearning_String_StringBuffer_and_StringBuilder.html"/>
    <id>https://wuyunjie.top/2021/06/25/JavaLearning_String_StringBuffer_and_StringBuilder.html</id>
    <published>2021-06-25T02:05:01.000Z</published>
    <updated>2021-06-25T02:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>字符串在<code>Java</code>中被广泛应用，学习一下<code>String</code>、<code>StringBuilder</code>和<code>StringBuffer</code>这几个类之间的异同和适用场景。<br><a id="more"></a></p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/javaString.png" alt="`String`、`StringBuilder`和`StringBuffer`继承树"></p><h3 id="1-String-类"><a href="#1-String-类" class="headerlink" title="1. String 类"></a>1. <code>String</code> 类</h3><p>在 Java 中字符串属于<strong><code>对象</code></strong>，Java 提供了 <code>String</code> 类来创建和操作字符串。</p><h4 id="1-1-实例化"><a href="#1-1-实例化" class="headerlink" title="1.1 实例化"></a>1.1 实例化</h4><p>主要有两种方法：直接赋值和构造法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>; <span class="comment">//直接赋值</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>); <span class="comment">//构造法</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>字符串常量是String的匿名对象</strong>。Java 本身没有提供<code>字符串常量</code>的概念，所有使用<code>&quot;&quot;</code>定义的内容本质上来讲都是<code>String</code>的<code>匿名对象</code>。</p></blockquote><p>String 创建的字符串存储在<strong><code>公共池</code></strong>中，而 <code>new</code> 创建的字符串对象在<strong><code>堆</code></strong>上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Runoob"</span>;              <span class="comment">// String 直接创建</span></span><br><span class="line">String s2 = <span class="string">"Runoob"</span>;              <span class="comment">// String 直接创建</span></span><br><span class="line">String s3 = s1;                    <span class="comment">// 相同引用</span></span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"Runoob"</span>);   <span class="comment">// String 对象创建</span></span><br><span class="line">String s5 = <span class="keyword">new</span> String(<span class="string">"Runoob"</span>);   <span class="comment">// String 对象创建</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/javaStringPublicPool.png" alt="公共池和堆"></p><p>String 类是<code>final</code>类，<strong>不可以继承</strong>。对String类型最好的重用方式是<strong>组合</strong>而不是继承。其构造函数源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// copyOf(source[],length); 从源数组的0位置拷贝length个；</span></span><br><span class="line"><span class="comment">// copyOf是用System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength))实现的。</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断offset，count,offset+count是否越界之后</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用StringBuffer/StringBuilder类型初始化String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>String s = new String(&quot;xyz&quot;);</code> 创建两个对象，一个静态存储区<code>“xyz”</code>，一个用<code>new</code>创建在堆上的对象。但这种说法是片面的。可以参考<a href="https://www.iteye.com/blog/rednaxelafx-774673" target="_blank" rel="noopener">请别再拿“String s = new String(“xyz”);创建了多少个String实例”来面试了吧</a></p></blockquote><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/javaNew.jpg" alt="`String`的new反编译"></p><p><code>new</code>只调用了一次，也就是说<strong><u>只创建了一个对象</u></strong>。这段代码在运行期间确实只创建了一个对象，即在堆上创建了<code>&quot;abc&quot;</code>对象。但在类加载的过程中，确实在运行时常量池中创建了一个<code>&quot;abc&quot;</code>对象，而在代码执行过程中确实只创建了一个<code>String</code>对象。因此更准确的说法是 <code>String str = new String(&quot;abc&quot;)</code> 涉及到2个<code>String</code>对象。</p><blockquote><p>一个是字符串字面量<code>&quot;abc&quot;</code>所对应的、驻留（<code>intern</code>）在一个<strong><u>全局共享的字符串常量池</u></strong>中的实例，另一个是通过<code>new String(String)</code>创建并初始化的、内容与<code>&quot;abc&quot;</code>相同的实例</p></blockquote><h4 id="1-2-不可变性"><a href="#1-2-不可变性" class="headerlink" title="1.2 不可变性"></a>1.2 不可变性</h4><blockquote><p>String 类是<strong>不可改变</strong>的，所以你一旦创建了 String 对象，<u>那它的值就无法改变了</u>。</p></blockquote><p><code>String</code>类中使用<code>“final”</code>修饰的字符数组保存字符串，所以<code>string</code>对象是不可变的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><blockquote><p>“对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex - beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == count)) ? <span class="keyword">this</span> :</span><br><span class="line">        <span class="keyword">new</span> String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[count + otherLen];</span><br><span class="line">    getChars(<span class="number">0</span>, count, buf, <span class="number">0</span>);</span><br><span class="line">    str.getChars(<span class="number">0</span>, otherLen, buf, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(<span class="number">0</span>, count + otherLen, buf);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = count;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line">        <span class="keyword">int</span> off = offset;   <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val[off + i] == oldChar) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; i ; j++) &#123;</span><br><span class="line">            buf[j] = val[off+j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = val[off + i];</span><br><span class="line">            buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(<span class="number">0</span>, len, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub</code>、<code>concat</code>、<code>replace</code>操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。</p><h4 id="1-3-多线程安全"><a href="#1-3-多线程安全" class="headerlink" title="1.3 多线程安全"></a>1.3 多线程安全</h4><p><code>String</code>中的对象是不可变的，可以理解为常量，<strong>显然线程安全</strong>。</p><h4 id="1-4-intern方法"><a href="#1-4-intern方法" class="headerlink" title="1.4 intern方法"></a>1.4 <code>intern</code>方法</h4><p>在<code>String</code>类中，<code>intern</code>方法是一个本地方法，在<code>JAVA SE6</code>之前，<code>intern</code>方法会<strong><u>在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用，如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用。</u></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"hello"</span>;</span><br><span class="line">        String b =  <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">        String c =  <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">        String d = b.intern();</span><br><span class="line">         </span><br><span class="line">        System.out.println(a==b);</span><br><span class="line">        System.out.println(b==c);</span><br><span class="line">        System.out.println(b==d);</span><br><span class="line">        System.out.println(a==d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h4 id="1-5-String类中常用方法"><a href="#1-5-String类中常用方法" class="headerlink" title="1.5 String类中常用方法"></a>1.5 String类中常用方法</h4><ul><li><p><code>char charAt(int index)</code></p><p>返回指定索引处的 char 值。</p></li><li><p><code>int compareTo(String anotherString)</code><br>按字典顺序比较两个字符串。实际上返回的是字符ASCII码的差值，但通常只关心正负还是0</p></li><li><p><code>boolean contains(CharSequence s)</code><br>当且仅当此字符串包含指定的 char 值序列时，返回 true。</p></li><li><p><code>boolean startsWith(String prefix)</code><br>测试此字符串是否以指定的前缀开始。还可以指定开始检测位置下标</p></li><li><code>boolean endsWith(String suffix)</code><br>测试此字符串是否以指定的后缀结束。</li><li><p><code>boolean equals(Object anObject)</code><br>将此字符串与指定的对象比较。已覆写，比较内容是否相等</p></li><li><p><code>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code><br>将字符从此字符串复制到目标字符数组。</p></li><li><p><code>int hashCode()</code><br>返回此字符串的哈希码。</p></li><li><p><code>int indexOf(int ch)</code><br>返回指定字符在此字符串中第一次出现处的索引。 没有则返回-1</p></li><li><code>int indexOf(int ch, int fromIndex)</code><br>返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</li><li><code>int indexOf(String str)</code><br>返回指定子字符串在此字符串中第一次出现处的索引。</li><li><code>int indexOf(String str, int fromIndex)</code><br>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</li><li><code>int lastIndexOf(int ch)</code><br>返回指定字符在此字符串中最后一次出现处的索引。</li><li><code>int lastIndexOf(int ch, int fromIndex)</code><br>返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</li><li><code>int lastIndexOf(String str)</code><br>返回指定子字符串在此字符串中最右边出现处的索引。</li><li><code>int lastIndexOf(String str, int fromIndex)</code><br>返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</li><li><p><code>int length()</code><br>返回此字符串的长度。</p></li><li><p><code>boolean matches(String regex)</code><br>告知此字符串是否匹配给定的正则表达式。</p></li><li><code>String replace(char oldChar, char newChar)</code><br>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</li><li><code>String replace(CharSequence target, CharSequence replacement)</code><br>使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</li><li><p><code>String replaceAll(String regex, String replacement)</code><br>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</p></li><li><p><code>String[] split(String regex)</code><br>根据给定正则表达式的匹配拆分此字符串。</p></li><li><p><code>String[] split(String regex, int limit)</code><br>根据匹配给定的正则表达式来拆分此字符串。</p></li><li><p><code>String substring(int beginIndex)</code><br>返回一个新的字符串，它是此字符串的一个子字符串。</p></li><li><p><code>String substring(int beginIndex, int endIndex)</code><br>返回一个新字符串，它是此字符串的一个子字符串。</p></li><li><p><code>char[] toCharArray()</code><br>将此字符串转换为一个新的字符数组。</p></li><li><p><code>String toLowerCase()</code><br>使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</p></li><li><p><code>String toLowerCase(Locale locale)</code><br>使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</p></li><li><p><code>String toUpperCase()</code><br>使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</p></li><li><p><code>String toUpperCase(Locale locale)</code><br>使用给定 Locale 的规则将此 String 中的所有字符都转换为大写</p></li><li><p><code>String toString()</code><br>返回此对象本身。</p></li><li><p><code>isEmpty()</code> </p><p>判断字符串是否为空。</p></li></ul><h3 id="2-StringBuffer-类"><a href="#2-StringBuffer-类" class="headerlink" title="2. StringBuffer 类"></a>2. <code>StringBuffer</code> 类</h3><p>如果需要对字符串对象进行修改，需要使用 <code>StringBuffer</code> 和 <code>StringBuilder</code> 类。和 <code>String</code> 类不同的是，<code>StringBuffer</code> 和 <code>StringBuilder</code> 类是可变的，即对象能够被多次的修改，并且不产生新的未使用对象。</p><blockquote><p>在使用 <code>StringBuffer</code> 类时，每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。</p></blockquote><h4 id="2-2-可变性"><a href="#2-2-可变性" class="headerlink" title="2.2 可变性"></a>2.2 可变性</h4><p><code>StringBuilder</code>与<code>StringBuffer</code>都继承自<code>AbstractStringBuilder</code>类，在<code>AbstractStringBuilder</code>中也是使用字符数组保存字符串，但无<code>“final”</code>修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure><h4 id="2-3-缓冲区"><a href="#2-3-缓冲区" class="headerlink" title="2.3 缓冲区"></a>2.3 缓冲区</h4><p>每个<code>StringBuffer</code>对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer();<span class="comment">//分配长16字节的字符缓冲区</span></span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer(<span class="number">512</span>); <span class="comment">//分配长512字节的字符缓冲区</span></span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer(<span class="string">"this is a test"</span>); <span class="comment">//在缓冲区中存放了字符串，并在后面预留了16字节的空缓冲区。</span></span><br></pre></td></tr></table></figure><h4 id="2-4-多线程安全"><a href="#2-4-多线程安全" class="headerlink" title="2.4 多线程安全"></a>2.4 多线程安全</h4><p><code>StringBuffer</code>对方法加了<code>同步锁</code>或者对调用的方法加了<code>同步锁</code>，所以是<strong>线程安全的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.reverse();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);  <span class="comment">//存在 public synchronized int indexOf(String str, int fromIndex) 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-主要方法"><a href="#2-5-主要方法" class="headerlink" title="2.5 主要方法"></a>2.5 主要方法</h4><ul><li><p><code>public StringBuffer append(String s)</code></p><p>将指定的字符串追加到此字符序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) str = <span class="string">"null"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);<span class="comment">//查看使用空间满足，不满足扩展空间</span></span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);<span class="comment">//getChars就是利用native的array copy,性能高效</span></span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>public StringBuffer reverse()</code></p><p>将此字符序列用其反转形式取代。</p></li><li><p><code>public delete(int start, int end)</code></p><p>移除此序列的子字符串中的字符。</p></li><li><p><code>public insert(int offset, int i)</code></p><p>将 int 参数的字符串表示形式插入此序列中。</p></li><li><p><code>insert(int offset, String str)</code></p><p>将 str 参数的字符串插入此序列中。</p></li><li><p><code>replace(int start, int end, String str)</code></p><p>使用给定 String 中的字符替换此序列的子字符串中的字符。</p></li><li><p><code>void setCharAt(int index, char ch)</code></p><p>将给定索引处的字符设置为 <code>ch</code>。</p></li><li><p><code>void setLength(int newLength)</code></p><p>设置字符序列的长度。</p></li><li><p><code>String toString()</code></p><p>返回此序列中数据的字符串表示形式。</p></li></ul><h3 id="3-StringBuilder-类"><a href="#3-StringBuilder-类" class="headerlink" title="3. StringBuilder 类"></a>3. <code>StringBuilder</code> 类</h3><p><code>StringBuilder</code> 类在 <strong><code>Java 5</code></strong> 中被提出，它和 <code>StringBuffer</code>类功能基本相似，主要区别在于 <code>StringBuilder</code> 的方法不是线程安全的（不能同步访问）。</p><h4 id="3-2-可变性"><a href="#3-2-可变性" class="headerlink" title="3.2 可变性"></a>3.2 可变性</h4><p><code>StringBuilder</code>与<code>StringBuffer</code>相同，是可变的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure><h4 id="3-3-多线程安全"><a href="#3-3-多线程安全" class="headerlink" title="3.3 多线程安全"></a>3.3 多线程安全</h4><p><code>StringBuilder</code>没有对方法进行加同步锁，所以是<strong>非线程安全的</strong>。</p><blockquote><p>如果程序不是多线程的，那么使用<code>StringBuilder</code>效率高于<code>StringBuffer</code>。</p></blockquote><h3 id="4-主要区别与适用场景"><a href="#4-主要区别与适用场景" class="headerlink" title="4. 主要区别与适用场景"></a>4. 主要区别与适用场景</h3><p>主要区别是：</p><ul><li><code>String</code>：是<strong>不可改变</strong>的量，也就是创建后就不能在修改了。</li><li><code>StringBuffer</code>：是一个<strong>可变</strong>字符串序列。</li><li><code>StringBuilder</code>：与 <code>StringBuffer</code> 类基本相同，都是可变字符换字符串序列，不同点是 <code>StringBuffer</code> 是<strong>线程安全</strong>的，<code>StringBuilder</code> 是<strong>非线程安全</strong>的。</li></ul><p>适用场景：</p><ul><li><code>String</code> 类：在字符串不经常变化的场景中可以使用 <code>String</code> 类，例如常量的声明、少量的变量运算。</li><li><code>StringBuffer</code> 类：在频繁进行字符串运算（如拼接、替换、删除等），并且运行在<strong>多线程环境</strong>中，则可以考虑使用 <code>StringBuffer</code>，例如 <code>HTTP</code> 参数解析和封装。</li><li><code>StringBuilder</code> 类：在频繁进行字符串运算（如拼接、替换、和删除等），并且运行在<strong>单线程</strong>的环境中，则可以考虑使用 <code>StringBuilder</code>，如 <code>JSON</code> 封装等。</li></ul><p>性能：</p><p><code>String</code> 类的操作是<strong><u>产生新的 <code>String</code> 对象</u></strong>，而 <code>StringBuilder</code> 和 <code>StringBuffer</code> 是一个<strong>字符数组的扩容</strong>，所以 <code>String</code> 类的操作要远慢于 <code>StringBuffer</code> 和 <code>StringBuilder</code>。</p><ul><li>对 <code>String</code> 类型进行改变的时候其实都等同于<code>生成了一个新的 String 对象</code>，<code>然后将指针指向新的 String 对象</code>。所以经常改变内容的字符串会因<code>频繁生成对象对系统性能产生影响，内存不够时JVM 的 GC 就会开始工作</code>。</li><li><code>StringBuffer</code>每次结果都会对 <code>StringBuffer</code> 对象本身进行操作。</li><li>某些特别情况下， <code>String</code> 对象的字符串拼接其实是被 <code>JVM</code> 解释成了 <code>StringBuffer</code> 对象的拼接，所以这些时候 <code>String</code> 对象的速度并不会比 <code>StringBuffer</code> 对象慢。</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://www.runoob.com/java/java-string.html" target="_blank" rel="noopener">Java String 类</a></li><li><a href="https://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="noopener">Java StringBuffer 和 StringBuilder 类</a></li><li><a href="https://www.jb51.net/article/33398.htm" target="_blank" rel="noopener">全面解释java中StringBuilder、StringBuffer、String类之间的关系</a></li><li><a href="https://segmentfault.com/a/1190000002683782" target="_blank" rel="noopener">浅谈 Java 字符串（String, StringBuffer, StringBuilder）</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3778589.html" target="_blank" rel="noopener">探秘Java中的String、StringBuilder以及StringBuffer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;字符串在&lt;code&gt;Java&lt;/code&gt;中被广泛应用，学习一下&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;StringBuilder&lt;/code&gt;和&lt;code&gt;StringBuffer&lt;/code&gt;这几个类之间的异同和适用场景。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://wuyunjie.top/categories/Java/"/>
    
    
      <category term="Learning" scheme="https://wuyunjie.top/tags/Learning/"/>
    
      <category term="Java" scheme="https://wuyunjie.top/tags/Java/"/>
    
      <category term="String" scheme="https://wuyunjie.top/tags/String/"/>
    
  </entry>
  
</feed>
