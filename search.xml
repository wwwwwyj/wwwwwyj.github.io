<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo学习记录-博文加密</title>
    <url>/2019/11/16/hexo-learning-record--post-encryption.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="密码是 password" />
    <label for="hbePass">密码是 password</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="77fa5be6fed2d407a88ebb433f7f586eeace7d6f5171c17aef3a81aeba17e56d">818ffb39eb08dc7f13d5091f8a8f23c74cbcacf9d9efc5a1642c7ce851f7a2cca16e40aae9f8b3a7cfd18a133ef0859b982999ae55cdd79958a18d381cf93b0184c5fc7597fbe1ff53861ac035aa40e7ed09f930b69762c7ba529ba705428eeb0bd56fa727216c8a4b6a8079a205f214439b1eee967f2d56bd584ace969d7aa65b7b007e79691869b0453d312e4a86536df140e382ff630abbb475d551ea2f2a194d35e83b3bf6591ef4fa058c39db1a1c3b718427aaa867ce1fa0326ab0201510b208adc6a3814e96279ee824d2cbd216726a06df5605bb0441b398f24ac4aa708655a5fe415df8c9735c0f931c86b4dc42c336c272012d8ca716288bbb825d48ac68f7248bd46a81ffe415f6158b1831a18aa8eeb4f308f8e7656fc7aa0d73cb9251c1d87dfb85d6a0ac450bdc8de0f70610b6810c3704ea941f6610ea39087fcb063ed9088af7091a83de257e31ef7b1ab65129923e6211845527900985314e4b51d5d4a6e9f34d3b7d1ac31705c42110d7991409d8cc44b490a6b9ae824444e34ec6905c08ceaa748f73c609839aa7fccfaacd90400bef600a1823233518648b82eaf24cdbb91e38649d60dfd3a209f5274d1ac2acd778647b2a4f0fa8ee4fa88dd70cfe106ce3d14c986face0c19a7bec1996243721a1200a615b81785b61a51301ee8673199636a50cca2813b60250b33ac38f807c494e40e51ab5a51a01bb213842d0779b49b1b3b59b99c63894f7e8bff5ec1ada82b9e3d8c538ff2396d46ba8d7d305a06694fef4019310b0e81598b6fd2f31e256fca15d667b8c6fc96f7b62216b4480db7160f5ffcc65b5f52d1d260c43241083cc9bb022547201ed9583994257ec0816613bb5828475d0bf2a37fbb828ca554dc56d2d2a9ecbfed122be2009cafb5974fa8edb13a4759ef27b91f2c5ebb99ded649edf00e9259bd5eda19acfeb2e321857bd9eda5bbddb6a800d7d1967468568c90fd49f1a85233cf787011dcd2d74486d61184ff13dac072a83f2df4026f71769ba5dc5df1f1dd8474ec212006d1c3a8c0880cdc810fab2df97e4fe09108b583cbcc11fb5cc8e314271329292d167abdfcf07a888e9cd30896bfe2f2a226cb5182e7fca300adc775cc8f8441486b8f93bad378f18f1d938e36bdcbc003b8535c02bb68f14b701bb103b228b4ccabd893fb880bc8c61e33a18cdf185b52bb3a17a2a9b8a0a1dfeb4923a9e7aa152943ee2d3bccb1506bc9221ac3953e24699415bf2cbab350ad82fb8ad9c113b309ac6d965d286c18c29d867771ca72e507ca2583f825cf9981df7fa7e458b93cb26dd22f607e68ac326e08077a2a59b74b3e8451d58a0d5d0e30f65dbc59846a654b33deda3d115dcc21f8df26554942b424e4ee7b8dc276938b1e6f2b5b0b82cb23fbd20abbf7a12a00c69b97c392b146a4b127d0802118b3aab543fc76f54b01351063090071657758cc4ac103b8169038757c3db5c933fce25a8578781024d4242b964ea3c0722e46ab1c867bebf10bd129f2a4e86b05130b7f911b1f9b9d1c3dd26da0b46f3e5cd11172c5daca6b1ae5b322afb73014e10fa9d823ba9aff1ebbee6b4059fc4f5a99ffad5db5afe23067cd3e7a223e3eec5f81eda2643dc3854916c660e5764a5fca419ce4574f57e51c4f3874fa3b2b278098c4d412989d5534d1ee24741193bfbf10563a73ee14e174c22ae9c015104b87b36abf48a06281cff66e4c9df44066bf68f54fa4c225fa2d6aa7a233f8322c3ac0c07316cfc20b7211e15f2c0aad834248ed7e98d07e4262cc7b595583fc8dabf11e78d857bde0ba38268e004ad079544126201c858664ba21aeb663c1cab40b12cfd63d8d09f3ec376b7268a5d491294e7503834f1b4afce6167b81c54df34705a756b44ce5a7d1074684e13840719adcef8adddd44e12093fd5661794fcf31e949f0b169d3180d146bffe3ec4e1e026e757dbc697b2cad5be56df0fe357c61d2fa625394e800e9a9f24671cb6cdbc344692c8ded8c79c0a4cafcf688a746fb257323b04a2956f297aa014968e8a5bb66c9abebc1193a2a840820d97fbbb653975a1d56b4943bb5046b89de996b367c17d8fc6658be8517c5008348cd5f0b9fce0bc1d58736a892402e8c5b58eebb145ddd90fc13b74bd7f3ef8fba7e5861acb3357fbdf3bb651ff077c5a47a6771f4cb1a821a3785b47cb39cbc33febd6a0a69f439f99c6119fd18246c857ec43b2d682e3a83dc6599e2323f6ae07a1687be365ebd7aad0188f7586b177ca7047ef72428026a3c7db2dbd7f07fb3c00850ceb288fa025bf68e967a67848df52a122b392ff03e998b27961fa9641f2f3f822ad39da17e93806ac7cfdcb0cec1aa1e8f31d07f2422b478944f396190299e3508c60956105a38cb82c21754d05d6948eaac78ba5c3aaa68594d8c81d3c9c1b6c84f0c94a01deefe058cd5a258b2a861e9846e20cea369b9173a4aba0403721a2a5fa05a49825455cc521d2e61ff423b44e17d589a328f98c769ad7292d59972f9b7c830c1ba69810ad74142b7a06ed05b5a5c998bca97196f99f334ce97e378167d20915974090d4a6e6f45e29b69dd7e81cac42c1294f38ce1dfaccbe51f3eaf661301d97c3fded67af615a60020a29d84c9d145f489b776bb7350ebf8238f06b9cd03288ecc58a2a7a43a83d19f89ba7fb910ca474f8b169a67d72a6c87fb9437a71d78c13daca49269d26b09ba4783e23ecce661bdae2d3b10c2c6ea0aa22e7dd36ded1cf0e7dddd8e13924c460f93e6e2cf78a128f9c381465b7ecede906d1c746ee5bd60229b16875cd82d8383f605c89e4ce3dd9f5067ac93d207c6353a475b842fb35bedc5b91b32835c5b456673a22c2239be58f70b8a725a5bec1c461216fb364bbbfdce8126ac11eab28c5f316d582f4aa4d501393855534b620c3e58631848f952a08abf93e95f488577cd63a3a348bd3f2d3fb51a93e4d9e4d6a595d51345e3821ce59093da6f2db7f7baff7c34dbd526766bff313a399f61c7106bd76b8d99be596f9fdbb221f60f58f6d5971e8236d0146889f124e94ca80988f6b16cb18306633dc65dbbc391f17ba7a5cd4ed2f3bcd3f461340c550a9a353737c30ad9dcc5c22e22c7557553b4454860f69eedc9f40793168f023d7342d02b140c0d0f4fab5b3f83f51430c1c1e8337235b0c14f79724eeaf8ad4c76e88587ce7ac2de9d3484840ee7f661f8221ae3ecc9a77f223af3658090cb8588cc0ee56ba414598540151c1af453070730c2c28af76192448ca146e8b39dd749e7cd23db6b5a5afc288318deeb3c3f44adffe5a884e64800624d9bdf3c754c1abbe391917b77c6283f08091f3ead401d5ca2c5a1b59c8cf0b10acea04c0e6036dfd89c2760c668c63e4810b3a03cc019d4ec179f9c0cb505d65bcb8efa51ee1b745f2d8bb372b0939fdb6718d533a0dac264f6a94c238e92ff78c6e872411a6675fee303a99e05b0ba45f68185e323a29bdcf35552b3156fa100b322da4b0710c975b06fb308e386697148ab663e6e8873f434c7e6b6a9490fef86e1b79b34465fb66f9d1b1bb2e92eeb2c128ce128be3c55eec88cf6af82c87de9ddf2f5130333bbd34dbf5023fff91c18c20a30725b8d0c61ac4414df2d040b7bbcd9e0a30b0b483e75c42b5fd1e37adebacfb5df53607b8943c244f81ebf7c5d9cdbeefadd00a8b4e244af1503c8677911af955ae8c4ac40081e704295660c3c4c68b27fe06effa8aa6ae7af4ac62abbfb5ce8ad83fb36bf2f12d202719954503ed4756180670257802761d84fc45c68b99c68b6913d65e11500e2ef6efbdcf3fcc3d57bdf591f343545179b78ae7f06136cff9e0f20a85129faba51432d0789a9892f34aa7c477f45b2c44ba321b4151fcd93347f43c6807948737a6927617eed2d70b4889c9cbdfc37bca158870b2d47e3a5771cc6fca5d49e69a4b3730b5c5017ba72516f679f67e64a456ee75549a7ecb811ec9dae9890a5aa82e7927651dfe00acaedb7516655ceb479e3945124962738b3e9c0438821c5dce6d563a590ad01765418cf1fc06e0845686271c81af59c6afdccc4e149f53e0833df48a7b96b43ec0ed79fbe04e91a962cd95fe5fa2acc2ea7f13aafd58b74f48aa643a7848972bd683ab6951897aa4afc66b7e82d6fa4d223f553fdb1ad7d3cc7a3cab891e5db8dad378d3bcf97d95638b95dd6902cd098e0b0590e7400785cfa1a6f645c63ee4505fd31c137a6c3d19d797eae891e34b2a5da705c7a263466aaa0e34ca3f0f957a94a913735e2f38e28f3320562af92846883ce3d696c5be428362b2c8adf4dfe1d13efc48ba95daa47e62c79f24ee5968c5e91bb41bb42d546512c5d2e3d5af06b19977d6f19dde8b363725ea9f92b4f444e9505af140decffb731b79280d9169861cb1ef6cf236739e61269a4f062a305676b4c98c41e42805201e3e943003c2fb0354bdfde5e2404fcf0b4884f189ee181e8efae01eaba64fef48f266e7349b027ec47415e7943541bb750141d8c42e620ee4c91c2e7d7e25041442cd6f9757ed3a213c621780ecafbb9e2b12cc472f0c83aa767e1858029a9513c74e56ed8edc36abbcaed822413096c009c60e7245c91b6da8819dc3ed647b63cbc1bfac32c690c9ed279b17319a2ec2c3771278a5f72745d212d2af8d38d6942ef43df4110d666d564ec6909578e2a0a2f960fd9340a9ad260a730f16e7813a1536bef5a236e5b77ee361552d84a4e235f98ae70393500d11d539226fc45a3ea31eaae1444f7064f4bad63e463d1e8e868acb8f9162fae7d20087690f816b9176495e357e818be5d9b11af86b1685a1dd8582d9817d3bd781bb6d4c0e12ebb01dc693c519d112387cd6bad227d6201dbaee61e76a40cb311af394ca5404f59f17154f062be7fc4ff7080191799b8e71fb658a0695c5f72857155e4af4c2ce62439c5179cfee3a5d2168f3bba6d0a04804969ed387f3671de0738ab3216319c794de805aec9be49294033c016f9dae18253a066e29a3b1b8037910e3b9b7cb4b3ef3ab7b787ec4a0a8abf65ca54ffe2564a5d1242f58432d3a3a107c35618dc62fb54333c509b5f654a9064336c804b672bdd200e2f7a419ab3564de92f62f80b4f2510ce589180107c6de56da1ae7d8caea96f6c62b95ea5ff1c1a329486e6661a5354b6dd15b9705e3fab91a849858cc71c0a019d5950b5d9f691deaac1f294b0b99f1561256cb3c79e3c204399c1b5879cf77401b5bd0a96c3ad378e06957ff637e8d7e1ba868fb907c237cc18262ce605200de80dfd28074b75abd055ec30e8485d6c0bfc0ba006f4e79b880784931cb91ec0f0d608b1cd330efeb46437ae502a4623315d48dd40cfdc5d01bc6cf443812d41282907050090eeac5f5b0e4aa40235cf23cdafee2b2fb5a7de0fd84c93aa7477125896cff030323370b1a3fa627260717ef11136dc78ee65cdeea851327c927b584094bfafa2d98907898734aedc7a4fffd38953778ca8b4658ec784fae7a96f75c2b086b137dd9080bd68470efcc47148a7b52f55a7100cc850e827d816fdcc72a6c02c3e09f85ae4ae0026dfbca9825f6decd2658c4da5b6fef7b69161e8374f553934369758e95e13b9f682a8906429abc46ed8344c5a399241d6ece5c9eef8341920828fa508e740cacd71a7232aa96f92d7f510c83b0ad9208ee84d7a2442005e64006d937fd409536498f02c1e95a5222df5b67e25eded37d90bd22e57e08459069d0d111df1cc1985e53ad0d6623dc52ca32f7f61ffb908e039225d8ac439ccf9563de42d6b5c7a941e0eedeb1554ae387f70ea0b40ed8cd41fc9c10d931c3b68892c49617e9a1bd193be2460951db6ab116ae3d34ef5b54c5d31fa8756cec268e38c8d04c0ed663f2a560120af45c96a1c03040a35642ec9d08d140bccc21a345377b8f193c2a6ae10ca5226de1c3ef2f308990131879e62aedaa4a375468c76ceba4594f60c5d0e8cc92a050d1a72327a0fb1fd15d2a64731c5aff0ccad7b5830f43f4abe2cd19f9403e54c6beeb0aac5bb984ac4bb2c7c2fb87145117f82d42c148373a1d195d4d9334fd43c60fd29f9610c9e46a3823023a562a44d54cce4b5b36aa828c7135a5fe68f3fdea6dad5e5ea306c337f5c3afe13a27a7fd6bd4004a2a424b7c33b5c5e08f4994b6f4b2a4711158b36153228172800acd8671c9cd6e99fca40ce6f1d4dc47f181ef88acf927af14900bacecf84188411bd83286904df6630562dd675a5ca129f0f1251c4f818d898bf233dabcc0da9c79e7eb417da7aac4d70289fb3e84a2c92a52fe55a053815ded1eae12b9e6a8872a0a859e116efe2c46af2adeae72c8a8a6c88e0ee48e1bdecd7e697dac91aff9c2f6cfffb0b0a92607bdb468fd044e2f2763a7001b3a40d0c7dd6529198332cc4b0b4543a0f97642dcc6ab68e958f66bc9cdefbc0387a9f96b98e8488cb2041dfbacd9ba7efeaba0eaed72e9ed5ef303d16e6306b63b4a1ff4207a19f117f31c3c3149ef4052be5c22bd032a24c3e23d8868f125c047d1c190f1211c08d2f9c1aa639607f0246775715f2d4d8efa24444a933d47a4b3cfaee7fee8d048e5b29622096162906c7d053c57a9bde0ad01ff507defc01f67cd90e71ef0f97545978a02e0b7aced57f08f65b7a39ed00ff4a87bcf2acfc68e19c61eb1f56fbd3e8b1be73763572e18b5a2def95b7678d793dc7b7102c1c3a386c9269d60f74e0a3ffe3d438edc1ff1ada4a2781fd7d7c8d85dc557679db9782f2ac3afa7a37a974fc75795cd80d155c9b8a451ccda45e5eafce61ea89f554242dffa2e70b59beaf46fb829085c8f610eae37582079ed19deb0704086c58f676372794fb1514d858c4dfc967a843d6b80930f19629f879d82ffb309cd75df83f3c9a7b078f135794dce2036a31c1af831a0ec75ae3243150e0fc639ac0bd95765a40f242e8c3f282683f42a73d73a151c1c4b138bec46b6eaa9d8994cea592a3c8122f5cd554b7e34c92f393b01c5d8aa752e2a9ed591076f7d774ffa64f926e0c82b5c75fd479d8d03bca940a07cbba02f6b89b3ce7458ba9bf6e9fd51d4d64a73b9833832d8fe4651e989e20fa97e475aa8b946ca3049bb192dc2adcd3792e35763199a0e23e6ae267d2c7ffbeabde73d087ce50636e10ac4ab402e52b0f1e3ab3ba80fb8e6d269195c85a60b92ad60d2eda8df41d620ddad674ba87dea22d1c482ff3677c4674ac6f831ed6b5003ebe8b9174ed309337f0071a98d0ee7198bc971f572e9ba737440341c0978a5d257816bd25f3c621c393e5b4c46171baf8fb8fc39434917422e0a1ca390f4df739e7085c8bd242c9a77ab6b9bd971f703a9caf405cf0de890d9c04315eb198fc4fc7d3d2fa4fc9cc36a61cdb5391b6bb4b7fbb0655f60d464db99baf864503a32dea5d503fb06cc62ed2e60ec0ed678418bf6649511873047e65e24cd8d303fb520df914e468a6ab71d2667c3bb6c3f99f4ec084591c210c97b7170c1082e4f4cf1f8e7c07ae31dce6f2bf5cce08f682e4cae50156b84b8e2978549a77394f0ffd9360085db514e31ab387637598e10f216e4ce7c678cda6980d48f6212e5fc6e25b996a6fe4e4144cf154a4c2ee3bd122cfc088d2356015c58c4b4666d2c5def6a90ab31e9c39e4dee4fcd907859311f1b2ac537591d568e9659ba1b445b2db387b799b106e5ec1713b82f72918773258844715cdcae15b1fdf4909d25c44fcca1a5976853986e20df1c89516fbb94e0c32cb7fc2d73fb47e590066506609ba6512250d4c4b1447ad364f00423bc34b26360c2213c177f133b36fa3c111dd3d85de6a70e0407f96931aba09dcc60f42753f49cde1acbd54b283397481003f9e144fa98b016f9bbee30a600b869723044746a62b96ffd48d774743d901ee184b4db0a49a2979d80a36e82da19fb4374f7fe6f3c689fba1fb1cd01d03b806db1f93a65011dbceb9eed6f1545f693c8c8c467f52dbb8c8e9630fa866d3397f93662c3008d9d0a3cff0e954dda24b300fdcdcd3d7a34be1449f6357829d867a643d49f3bca016723dabcd4a3369416f39ad71a319d90cfd39c8e358dce26433c03a1af6089c0e0b5f7b310d88269b928bb5c48905bcd8c72069542ee2fd03130c22f4041d6d7c16c146f0b2e5f6e79a85835e960af81d64acd1288de6a19a77fdaeef8a5dd21fb0cb06e229e52690d51e78d3cf9a0061ab13a13dee84810d6674d182d3da33bce908abe7ec7e7a35ff7ee6f538b1bcef75f892b19876cfe29fbdedb4300cf839366d61be096cac0bb3c352fd6ff4ea5b1750ed7e4e1dd9bcdd25882f9924a34af41e0e2b42009a67e898997dbafc3bdf69df3e3b4b86a32a7c7deac62797db0cf2a7cb7262ddd22147caea7071a3b2d20e3682ce0dcbef4cf7a625ba3e93667e1914ff75fd45ecaab1a23f44c2e2a9c028b1ef2a08ba3cf3bc5e2f69255463a3f1229e73c624cc6bab8626ab847ae081ed66e23100c9aa9172e17ee093b9e184d70c8e7913ed8ed706b0361a632f9249df3d4fffbcce3029f4b40e2219970b610a3eb4234fb9657df67d6484278a10503819da81db69a30d721edcacf3468cb7c2535d805ad44decff3c4ef606e57df2026df623c4890f390b5af4a761aa7057f61fd0acf95be342454c37eb92a846d92c858f3869cc105de438a110bf0176b0f4ac503d0b730cb863ea2f84179405906fd48479ceee4c284f71a9758b85ee790a9868b7e97cb16860566038d76f221548bbbc89736d0a475729993d0b1f829ae6aca1a5ea36d74eb3a4defebbee90fd00de67dc592980f243929715bbcbb6590998fd8368b554a49bd4a8d39674df23185a9729a5a37ec228ef42fded6ffa4fb8056dffefae4da149069af78b1207c2bf544542de7b2af610e0e74856539b010fa0bf6629d0a86134f67519745ffc5fbedabb970a91ac340af495efece5a85daedf42c9e9359ba1bfd01568837df6d927444f67aebbb8493340ccd055fe0a85535cd5b9a9f37d1526198bf524e4108af7221aa9d080ecdba2cf3d7caab31a30a8c7c06e875b3f4e6442101759c91283ab9f6e8e16fc9fadd21fa87d72e9f76675667807f51c4a2d9a9762094dc2b8f0ff80488e8d00e223b4dc0f50ec67da09f6c8cfe4f5d67acd9bea191f9af3b30623ad4b237e20626c39e11be4fd3156c5c9a8485d1aab4df194ac4494b6fb247cb2df431fb58e111f7816871a42c9890e372653839841dcf403a04368b2502b5a1c96d3b4abf631b297272422caa5dc105995c06b041ee432eb72d6519b299b3287acad660d1be6dc1a7b2ac204869fe19d139c54d39473ee215f51c302b583dd30b156c16a9f932f7991d1cd70a9f2d627b91e1972d4a0cef007fbe7ecdb6334f7017e50ab5ceb4d086753b60e08e53ac411b7b770f3b8b3526beb4bb2d5a80e314d9a774108cb45bd18b78c3ae86f6ced8bf44a781535dca748894fd46605a9fd055ab630ff65bc28a0c761f77e9c70679f85c269d3961e7f7f74edd37f9d592c4d34a6a4545b377907343dc18c4d4c2737b5c173f098c542e673178b7fc5e9a1b6123611e4c28d90a67467cc187c51f48c8e11c550bf9d505221249a4698f0abb9ad6dedc524d38ae6f51de51be21429ccbd3e93b0888b970bd93db54952dd2c7f8951f62330b4fd30513aa73f0954573f21bebbbbd98f94146c03195ad4884467c608a163d921868237ca60e1d67d5500178fd38f758720bc7ea96dbe0ddc18018355aedfc45e3a0c7158f8bccffa7e5f1e6aaeebf0b78b4fdd4723430bad48b928371318f5e837756248f40a2eebdd433a2f7cb9258f1ef91aab64ac464cdf68d658f9d65553d2cf9bacdc5127f454ccdafe71455d577e5001d717f125853842c583b7b3cc4c97c8c268756f2483d827bdd9ce80456a7c711e7e1234cdd792d99ff0b1717fe2f431ce76fe7689e33f1b46eee888e3e77adfa0b32c6763f579ce7ee190027495fb634a3f659fc9ab495e60322d8b00ba74a801f10a32667638f3d3c690bbeb97b9b1e4e6fb675c1cce259e693f612eba8b454be98e536ab9082689334a7bbda70ef966370939506a511e6833f585dea7efde3b26337b6509c3ec052478a5a19a82468436d95fca87e0ab58bb3cc53de1dbd7cc4bf41e04f986c9dcb43fc27a81728b08f7528770cf1a97d437f475a805962af9f96aba853b7e67995ec13132bc51496b5a215522c48716698fca73dde113175e993b22a14f92eab48a51b888a7a1c3f190359b7b1a72530507ddc448f2a3f193e53953ca9fedc4d1b4aa77dd75559e031c955b18e8f912450534bea95d886ee59cae699ce127c0417148659d1d747acc8df50e56196b19fc15c414df5cae3fad3f55a7cb5928dcdf589c033fae03138860ef213bfbbf378508404645a2bc4a59e854c56fdc21bc9b322a2f99655364b7b203e57599a6f6d7ba39558d2744d881409c8370e551ce7ebf0c4dd1435480e7595f29504e302b5280837a27d8797806211a2a16a63f824eae73b44a76aebad86eb3dee995a58fc48821fd8524bfd62c89e4dd39e59d960df75ce9ae3f7e62c48c35ed68eaaa9687eb1043daf8b001feae2d7dd4e6aa82e150d912b664dd8887f6f4422db3d0e3f9dc63ba5040383201cdc2d406785de46fc15df8d7cf4c8d9933b5409c9ff9b01ed8f086032c6a6865fd9293a4c30c0c8584e7048a716ba36fc96dea7bb6f1cc0a8197102213b19800e771a7f8558a2ee8fae21d82201a32826295752d070850122d618abc29847ebc19382ae0bef762dd2d8e18429d67109db52780a3ec75ed4dab3c7f9d2c9bb3c522ef6dd01d6562fba21427549a977e0fc3fa7ed4ba2f9fef8f14227807567e91c5b6a026fafc18969ee23faa51a1a0dfa8a8e62e8a1a8727ee519a07f838903db0dfe45ca58bd48bbd35fdc7460664f5470e96d5d3744ceb27602b63972f4be9f199d16d33ce3ad8c0f60c074886b84bdb5a9efb6b1e4065a5104e435a6d8c55f0af40fdbf1e68a5a32f2dde62c60edc42eaf390704195cecf6c880ea86ef035555d87005e5a297cc9e50a66f3b0e2fbff339228a82a2d1754582b8ccdcc7ff74a8a8b3e35d9bef5c528f69e45300893ad2c467cc36bef9f8ec48aaa96ff914b868be799da3ffcf50c8e8f43001456d89d88ac7d1b15e891314483344c0684909f13dc131622d769c3a4487291a38548de241c0bc0cecc3e472caf1ff7f57d0863549c724a1ac8a64c4ee44d641876ba045593c25024630afa146b20de66013bdae5848c50f0212c99b1119a4c589d43b41809b3d3847a9cee5cc152c467ffd518feb5946d54beee5963e0e16166b3fde939cfda71c0a935aa2b18094b0acfc5e2b5727a2cd0df7312c152846a77ce76331e0a87b1c343e0181677e75ca364f6b1e9e889ecfc3b4f7df6e59fdf568cac441e8c317b9a541c7fd61eb9b2fede20676ace6d0635403cd38adcadb6b15ebe7a74af8e4408e5a38c755f9c66ae58e4a95cd11f55b00cb62f8be43d83cf8c8a6313e603863d560817147926161f681ecc2e19d10bf31f63dacf3fea7b8ac6504b2c522c9335ac372e4ce457841951c065158f3404532359b3ad7e0f8fc49567bdf4bd3ba2c65d0af60e468a94ff2bae006f78a323df707a58749c2047a3c069d42b3137796cd05183815a7dc34e0ec391a7ce73ae60320e1ce65c4c20a330e173b075237150e53283ec95261fbc60f3ec7a30992fd344898f4b9f60acfb72ed60a98dffc26a4d53d3f1f63623cd06f28a6c18364a2d2571fcdf5b5f6f04d8d63dde2f77fd2db6e6d73bc43d88970d9dad59920f258adbc539bac44c6dd59d62dc368339b2671e3595529deb7fcc39b154bcd8a40f6f698733227d9433958f2855df5dcf96c6d68b728d806fb216f95632e748692dea981f53edd70352e4fc60532239d68fdea2190474a5a6f33f7777c2ca7d6422fe37cd9de57b5dc5675b8805e05187e6e5d740b9b7bb6e553813bc7d18f8cb7788bdd16e0cd32d820b76de33d19182fd9ccdb67e4962ea23f8a317d10a421f236f6c4cc491dd0bbd5e8a9d60448f2ba912ba79141c4be3a2a30685362e728af8f8522188f92c41a4dddb8c322d4cb446585a9630279d1606d697ac278e11c484b98a46662362e926c0501a4c58ee6902c39715fc0f34c080d85768d0a449240627cfd1df2d4f4eeca042e396833f977d6344fbaca0a65ac9d7fc76c5a6283e2591d15ba3c25034dec9c0d8c7b0c95d7467ba434de1dfa70fdc3292f6b1eba1d563876b999285c5c743e1f4c4f5f0813e51f8a04133f08f7a450b7b211650ca1f13e1e02148e78a8df3396f1bb938f7d786fd31de7b12ac729fbfa6f052fbc023f522a35a62ee8e340ef1ccb59aa537cbf1212262c45f8e1570c65052d687d51c5460f128e3318a8916d93a1f12086e50c70766aac9f088b81ab134641a1406b9cba907f247ac3e517d6ad3e98d0253cfeac89ef45b47a65348468389bcaa0105afd000900499291d9c00da35b1117c9405087e9f46f0094b362cdfa0a8b54a03a566b48de2ca431bf5a1ba130ada530ce03d030a838c4a04c11848feb3324163171bf6415ce73a1a2d0970cb615431825eaa042a09fd6d63e8ce1f22c6f0aa4fd0f8d7d1ad774b1daa9653234e417bca2af79e3cd7d2656fa486ebbd9d69283b540412e9be25aa266a0c1aff19acd323081cf3c90465a0837217922fc8736d45628807dc8e28159f71dbb729a6f15e3ed7a67a77716dbdcdcdbe3dc3a7fa2f1a9063bea281da8c44129516e5e419e20a35df819c7c8039e3883228ec1e1a9116990923f8cc6c4ed576fcb84b82373c26882bc623136c70588c342947a6463d6216d69ef7492a9d81f34ac23e7855f8fea23d513f3464be1c7643d5388fc043a5804fec9205e8a3d5a28fb51a4cbf3fb83568b446dc41372d66c4dd7d8ca1ed6dfab3afefb415eaa3924b365fed171324f59ceed75927ed97d16b2b4afb6577ac6262fcaaa7d4d94380977d04dccbc510411ce9aa461b85d9648ce0e927eed10569b07228d5e9dda60aae7af50f6a753a83824442651e0b7c7203b467396b6e3c1e069371ca432cd621e204e0d0d6de477d9b45eb1781ee063d6a1880d306905c6fa8a4037813deb16572638248f8fb028a1068db25608c6b1e34d667873371e152b27a45002df135fd1540064c55c50629d926e58700db9b0744ee039e7f7c8a990499054fe84872115ad490cec7e0c85dc9e5428c6089ef69e076ab9db10fe5deef408772af024d4b8ccf38748cc439b2f30108ff00a2bc4654ba3227f3637dd256d0b3d0f6c37e379c7ebce44d739cdc1e9540951791b70f09498fddad17f6baf81770f386f2d6db823feb6b7da602f18577c16a965ac54ee3476b4121c115e2d09386ac9cc9823d979654a3c7c568505c073847da0c253aa7a6536888b741ad1ca9fd9712392ff3ee98f410aecb48d9aafc4b746c6c8862eb2d813a6f2e681e50afb503aed1e8453ef70be5ef32f9daedd7520e5204bbc7933c1a2f8f316e8489f1ce6ea55ae01ff1c2e66aadc1361ae416bb738968768fe144e1ea128486db4303b76a4c0d2412ccc0e8d0a948f37f14560768dcbcb41807144f4b5f01df6e8594975df1d52c05a5a5fbc1a2fb3faabdd5aa3011eaded043a44328cff5868360ac0220006506014296923379b0c39dc018dedd881e3b6f828b2d49bd636b6669b3dec202d64700aa4fe4cfed5c3ff9734750fe97fd276ab4de3a0713f124a0daf7a8c0bd180396bb39243a30eec911843410d3aebcdf710d149ef28632f523ae39ac2066492a4d25d517ba90531668183ae5748c389de08bae99975c67d7743c105a6d040292cda973a466ca6f728baa5a4ef883688824ba5603c50e039da0776d316945f72c59ca49370275ccff4af70154d22c92583624801f7ecbbf22e3a1ac180be7521f3fcddfaef073ad9fcbfb467d0cd1d344ab9b47659895f0c236e127c17a174c5883d6243083ac080eeea0a0c15f6bda4ed76f38e1636a645c8b9a2dad32f591bc6b4580181c9234734283041bad38e2ead004520590190bea8e35b58224a467f813aed65db4692c5d6abcf7c557168e1b4a65d1091842b3dc21311a05dabdbff07a58311c91f6034a3f5adeda6d6584811c9356341e5ec6dde0e0b4ea98e6922a943b0f06264dfe7a4c8a7cfbb7a68af2dd31ba578c8d970e4f34ef328249f79a2b932eda4eee304490fee5faf6801aa88adb0e9f3ee8cfa05cc2cadb88617e3993bef37932454259254e5f5fa81e683dec6fff8da413dcc2e3c8db1de3e57b33296ba8c2d7797aa7e25ccf0e47ef874e859157a3f093c7c6c476174fa6bc9945bee343f34e76cb1d1af06917ab29890518c8b2e67f89ff7c7f436e44e36db6e0b58b0d1095c4c215a6ba3a735e1ea93699c696121499756faf1db453e25251f60fd3c89b991693fda42a053e7a2f2762505bc0f05631f19f744758b4fc0803fcaab259f5507a76aac5f9e2c067d2e7ddb2af2748a255e21f352bdb6a01b69f54267cc0b4100cbadbba80424b0091f9eab3d323a97d07ae65f1b6158bb4d17cc40c286435479bfd0abf3123d152a0f442b09adcefe59d592aeb0743cb32dfc73d42984525f524c52907c95b8349128f30eb2683c2e32d97b9363821c98287aae605e080ce40cb8cc21cb1df86f24d88f958f29dbf0daa88c31dc60be68cefccdae9d10e5106d733502219d29c0c38ec64fabb50f2afbaf183d5d06715e6f280a64d0429a3f5a8f2c28c65eff140d9099f4ea74cb0fbda57e35f6eed54646d3a3a1bb775b1736158d90ea552f6c164771c293f24a61eedc0f1f37c80875ee716149de26745ac94bdfeed561e6ef698b19570e46422f8ef691b230bcb9afa6a90ce79446376ee655766d1ce47ac607bffde36ef1e72542f1f26369e9fd4d5daf3c7b0f4110512d6cb48a42fe1e857d40c09f6457baf9aec6c9866759b125c750742cafefba404c3000477670359217d5b38da5ae430e34ba7479a3c021b6d15bf887d6c87862e33aac40384e906bf3bd90fe5eec52bc4a8404b611ca229e803a5131a141bc5117ff16d80f5a7f625fcbe4d0a74a7124bdc893d6194aba1ac0057c14585a88e4f907d339a58614d042f385b276c24f31faa7fa49c26fc5a687144f6adb07721e32079c7077eff94664a8d6629c0264e250e3fff276869f3c86e6bf4a726b38f8b4412fc9e370fe215c78e1ac064bfcd50c7439a1e3e014d42cbab83bf22fdc63205187838217e806d51b8ed623fd62870ec6648320600160f6e5b7e722422e140e6478a71909195b5efd497f38e1f17a6dab6f0ec914ac2de16281bee4f14e0a8cfc15bae816d8ce9ba54aae274fd8950125ca5f9d3d8f58ed775922aaf608272659f4a88584a3c3507f850dc04120abf0c59f62a3c33e843ebce28b26b6e928aa8c06a819a8c80b3a4e39f576dc751cd27d7ea03ea17dd86b62200c550e4b0bc9bffaa1380b7bd3751eb8f88b0373a582a429b107ff1e00395ac4fad944f7018b952ca3494150651294ab28eb0a717d7502ac2f1bbc2f04db98c3f5422647d64f60304b0a88ddca35281d40bf52eb6a71c8a85beacc445d1023b30b4301fd13b14646c526b90f0e901305d4697482124785a8657d557e2c339c768b38aa0de42d879d2e7dd7316bd283bf5a2e9e57213395aa52d0408b83f83f461e5be220ebb7ebb301131e5e04865b380b0f20522def1adc1ca616482c77054db3a72aab8a4cdf5ec1812fefab122fdf8e356e91693a146e7c8fda004192cb5cb83c2a0ee0e11a3d77d25cef80f8d0cfcd55b9a94c18f95a65b7a80b9d0f1010a84310</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>学习记录</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--11 异常处理</title>
    <url>/2021/05/14/JavaLearning_Head_First_Java_11_exception_handling.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>倒霉的事情就算会发生。找不到文件、服务器出现故障。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h3><p>需要对可能发生的异常情况进行处理，<strong>未雨绸缪</strong>！Java的<code>异常处理机制(exception-handling)</code>将处理错误状况的代码放在一个容易阅读的位置。如果知道调用某个方法可能会有异常情况，可以预先准备问题处理程序甚至从错误中恢复。</p>
<blockquote>
<p>异常是一种<code>Exception</code>类型的对象。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/exceptionClass.PNG" alt="异常类"></p>
<ul>
<li><p><strong>抛出异常(throws)</strong>。使用<code>throws</code>语句来抛出异常。</p>
<p>在编写可能会抛出异常的方法时，必须先声明有异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeRisk</span><span class="params">()</span> <span class="keyword">throws</span> BadException </span>&#123; <span class="comment">// 声明会抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> (abandonAllHope) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BadException(); <span class="comment">// 创建异常对象并抛出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意声明时是<code>throws</code>，抛出时是<code>throw</code>。</p>
</blockquote>
</li>
<li><p><strong>捕捉异常(catch)</strong>。使用<code>try/catch</code>块来捕捉处理异常。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 有风险的动作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>非<code>RuntimeExceptions</code>子类的异常由编译器检查，称作<code>检查异常(checked exceptions)</code>；<code>RuntimeExceptions</code>类称为<code>非检查异常</code>，编译器不会检查。编译器会确保：</p>
<ol>
<li>如果有抛出异常，一定使用了<code>throws</code>来声明</li>
<li>如果调用会抛出异常的方法，一定知道异常可能性。即会处理异常。</li>
</ol>
<h4 id="1-1-try-catch块"><a href="#1-1-try-catch块" class="headerlink" title="1.1 try/catch块"></a>1.1 try/catch块</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/tryCatchFlow.PNG" alt="try/catch块流程"></p>
<p><code>finally</code>块用来存放不管有没有异常都需要执行的程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     turnOvenOn();</span><br><span class="line">     x.bake(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (BakingException ex) &#123; </span><br><span class="line">     ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     turnOvenOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果try或catch块有<code>return</code>指令，<strong><code>finally</code>块还是会执行</strong>！流程会跳到<code>finally</code>块然后再回到return指令。</p>
</blockquote>
<h4 id="1-2-throws"><a href="#1-2-throws" class="headerlink" title="1.2 throws"></a>1.2 throws</h4><p>方法可以抛出多个异常，声明时必须要含有全部可能的检查异常。调用方法时，编译器会坚持是否处理了所有可能的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laundry</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> PantsException, LingerieException </span>&#123;</span><br><span class="line">         <span class="comment">// code that could throw either exception</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Laundry laundry = <span class="keyword">new</span> Laundry();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             laundry.doLaundry();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(PantsException pex) &#123;</span><br><span class="line">             <span class="comment">// recovery code</span></span><br><span class="line">         &#125; <span class="keyword">catch</span>(LingerieException lex) &#123;</span><br><span class="line">             <span class="comment">// recovery code</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常也是多态的，所以异常也可以用多态的方式引用。抛出异常时可以声明多个异常的共同父类，捕捉异常时也同理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     laundry.doLaundry();</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClothingException cex) &#123;</span><br><span class="line">     <span class="comment">// recovery code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的确可以用<code>Exception</code>来捕捉所有异常，但也会在处理异常时无法精确定位捕捉到了何种异常。使用<code>catch</code>来处理异常时，在继承数中高层次的异常不能放到低层次的异常之前。</p>
<h4 id="1-3-duck异常"><a href="#1-3-duck异常" class="headerlink" title="1.3 duck异常"></a>1.3 duck异常</h4><blockquote>
<p>如果不想处理异常，可以把它duck掉来避开。</p>
</blockquote>
<p>也就是不用try/catch处理异常，而是再度throw该异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Washer</span> </span>&#123;</span><br><span class="line">     Laundry laundry = <span class="keyword">new</span> Laundry();</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException </span>&#123; </span><br><span class="line">         laundry.doLaundry();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> ClothingException </span>&#123;</span><br><span class="line">         Washer a = <span class="keyword">new</span> Washer();</span><br><span class="line">         a.foo();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/duckException.PNG" alt="duck异常"></p>
<h4 id="1-4-异常处理规则"><a href="#1-4-异常处理规则" class="headerlink" title="1.4 异常处理规则"></a>1.4 异常处理规则</h4><ol>
<li><code>catch</code>与<code>finally</code>不能没有<code>try</code>；</li>
<li><code>try</code>与<code>catch</code>之间不能有程序；</li>
<li><code>try</code>一定要有<code>catch</code>或<code>finally</code>；</li>
<li>只带有<code>finally</code>的方法必须duck异常(即声明)。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/exceptionRules.PNG" alt="异常处理规则"></p>
<h3 id="2-创建MIDI音乐播放器"><a href="#2-创建MIDI音乐播放器" class="headerlink" title="2. 创建MIDI音乐播放器"></a>2. 创建<code>MIDI</code>音乐播放器</h3><p><code>MIDI</code>音乐播放器，类似一款乐队软件。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/MIDI.PNG" alt="`MIDI`音乐播放器"></p>
<h4 id="2-1-JavaSound-API"><a href="#2-1-JavaSound-API" class="headerlink" title="2.1 JavaSound API"></a>2.1 <code>JavaSound</code> API</h4><p><code>JavaSound</code> API是<code>Java 1.3</code>后加入的一组类和接口，分为两部分：<code>MIDI(Musical Instrument Digital Interface)</code>和<code>取样(sampled)</code>。<code>MIDI</code>是不同电子发声装置沟通的标准协议，可以想象成<code>乐谱</code>，可以输入到“高级多功能电子魔音琴”中。</p>
<blockquote>
<p><code>MIDI</code>本身不带有声音，它带有的是有MIDI播放功能装置的指令</p>
</blockquote>
<h4 id="2-2-Sequencer"><a href="#2-2-Sequencer" class="headerlink" title="2.2 Sequencer"></a>2.2 Sequencer</h4><p>先获取<code>Sequencer</code>对象，它会将所有MIDI数据送到正确的装置上，由装置来产生音乐。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sequencer sequencer = MidiSystem.getSequencer();</span><br></pre></td></tr></table></figure>
<p>直接调用无法通过编译，编译器显式需要处理异常。API中说明<code>getSequencer()</code>可能会抛出<code>MidiUnavailableException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MusicTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Sequencer sequencer = MidiSystem.getSequencer();</span><br><span class="line">            System.out.println(<span class="string">"We get a sequencer"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MidiUnavailableException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Bummer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MusicTest1 mt = <span class="keyword">new</span> MusicTest1();</span><br><span class="line">        mt.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以下是<code>JavaSound</code>的工作原理：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JavaSoundWorkFlow.PNG" alt="`JavaSound`的工作原理"></p>
<ul>
<li>运行该播放器需要5个步骤：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/fiveStepOfMIDI.PNG" alt="`JavaSound`的工作原理"></p>
<blockquote>
<p>第5步是开始播放：<code>player.start();</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniMiniMusicApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiniMiniMusicApp mini = <span class="keyword">new</span> MiniMiniMusicApp();</span><br><span class="line">        mini.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个Sequencer并打开</span></span><br><span class="line">            Sequencer player = MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            Sequence seq = <span class="keyword">new</span> Sequence(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取一道音轨</span></span><br><span class="line">            Track track = seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage a = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOn = <span class="keyword">new</span> MidiEvent(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            ShortMessage b = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOff = <span class="keyword">new</span> MidiEvent(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Sequence放到Sequencer上(相对于把CD放到CD机上)</span></span><br><span class="line">            player.setSequence(seq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始播放</span></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-制作MidiEvent"><a href="#2-3-制作MidiEvent" class="headerlink" title="2.3 制作MidiEvent"></a>2.3 制作<code>MidiEvent</code></h4><p><code>MidiEvent</code>是组合乐曲的指令，一连串<code>MidiEvent</code>如同乐谱。必须在<code>MidiEvent</code>中指定何时开始播放某个音符(<code>NOTE ON event</code>)以及何时停止(<code>NOTE OFF event</code>)。</p>
<p><code>Midi</code>指令实际上放在<code>Message</code>对象中，<code>MidiEvent</code>由<code>Message</code>和发音时机组成。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/MidiEvent.PNG" alt="MidiEvent"></p>
<p><code>Message</code>中信息的格式：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/AnatomyMessage.PNG" alt="信息的格式"></p>
<p>使用命令行参数版本的播放器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniMusicCmdLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiniMusicCmdLine mini = <span class="keyword">new</span> MiniMusicCmdLine();</span><br><span class="line"><span class="comment">//        if (args.length &lt; 2) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Don’t forget the instrument and note args");</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            int instrument = Integer.parseInt(args[0]);</span></span><br><span class="line"><span class="comment">//            int note = Integer.parseInt(args[1]);</span></span><br><span class="line"><span class="comment">//            mini.play(instrument, note);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Input the instrument and note"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                String instrumentS = <span class="keyword">null</span>;</span><br><span class="line">                instrumentS = is.readLine();</span><br><span class="line">                String noteS = <span class="keyword">null</span>;</span><br><span class="line">                noteS = is.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> instrument = Integer.parseInt(instrumentS);</span><br><span class="line">                <span class="keyword">int</span> note = Integer.parseInt(noteS);</span><br><span class="line">                mini.play(instrument, note);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(<span class="keyword">int</span> instrument, <span class="keyword">int</span> note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个Sequencer并打开</span></span><br><span class="line">            Sequencer player = MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            Sequence seq = <span class="keyword">new</span> Sequence(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line">            <span class="comment">// 获取一道音轨</span></span><br><span class="line">            Track track = seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage first = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            first.setMessage(<span class="number">192</span>, <span class="number">1</span>, instrument, <span class="number">0</span>);</span><br><span class="line">            MidiEvent changeInstrument = <span class="keyword">new</span> MidiEvent(first, <span class="number">1</span>);</span><br><span class="line">            track.add(changeInstrument);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage a = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOn = <span class="keyword">new</span> MidiEvent(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            ShortMessage b = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOff = <span class="keyword">new</span> MidiEvent(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Sequence放到Sequencer上(相对于把CD放到CD机上)</span></span><br><span class="line">            player.setSequence(seq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始播放</span></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--10 数字和静态</title>
    <url>/2021/05/14/JavaLearning_Head_First_Java_10_numbers_and_statics.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>盘算一下。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-静态（static）"><a href="#1-静态（static）" class="headerlink" title="1. 静态（static）"></a>1. 静态（static）</h3><h4 id="1-1-静态方法"><a href="#1-1-静态方法" class="headerlink" title="1.1 静态方法"></a>1.1 静态方法</h4><p>在<code>Java</code>中没有<code>全局(global)</code>方法。但有些类中的方法不需要实例变量，为这样的类在堆上建立实例时很浪费的。</p>
<blockquote>
<p><code>Math</code>方法是最接近全局的方法。</p>
</blockquote>
<p><code>Math</code>类中所有方法都不需要实例变量，这些方法都是<code>静态(static)</code>的。而且无需也无法创建<code>Math</code>实例，只会用到它的类本身：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = Math.round(<span class="number">42.2</span>);</span><br><span class="line"><span class="keyword">int</span> y = Math.min(<span class="number">56</span>,<span class="number">12</span>);</span><br><span class="line"><span class="keyword">int</span> z = Math.abs(-<span class="number">343</span>);</span><br></pre></td></tr></table></figure>
<p><code>Java</code>中使用<code>static</code>这一关键词来标记出不需要实例的方法。一个静态方法代表<u><strong>一种不依靠实例变量(对象)的行为</strong></u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">     <span class="comment">//returns the lesser of a and b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以类名调用静态方法，以引用变量名调用非静态方法。</p>
</blockquote>
<p>带有静态方法的类通常会被设置为不可初始化。除了把类定义为抽象类之外，也可以<strong>把构造函数标记为私有</strong>防止类被初始化。但带有静态方法的类也可以被初始化(比如带有<code>main()</code>函数的类，<code>main()</code>函数是一个静态方法)</p>
<blockquote>
<p>静态方法不能调用非静态的变量。静态方法无法引用到该类的任何实例变量，静态方法也不能调用非静态的方法。</p>
</blockquote>
<p>可以用实例变量来调用静态方法，但编译器会解析出原来的类，并不会知道是哪个对象引用调用的该静态方法。</p>
<h4 id="1-2-静态变量"><a href="#1-2-静态变量" class="headerlink" title="1.2 静态变量"></a>1.2 静态变量</h4><p>静态变量的值对所有实例来说都相同，而且该变量被所有实例共享。比如要计算当前<code>Duck</code>实例的数量，或许可以在构造函数中递增计算器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> duckCount = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         duckCount++;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但由于<code>duckCount</code>是实例变量，每个<code>Duck</code>对象都会将其初始化为0。而将其设置为静态变量可以实现所需要的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> duckCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         duckCount++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">         size = s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态变量只在类第一次载入时初始化。同一个类所有实例共享一份静态变量。</p>
</blockquote>
<p><code>Java</code>虚拟机会加载某个类主要因为第一次被尝试创建该类的实例，或使用该类的静态方法或变量时。静态项目的初始化又两项保证：</p>
<blockquote>
<ul>
<li>静态变量会在该类的任何对象创建前就完成初始化。</li>
<li>静态变量会在该类的任何静态方法执行前就初始化。</li>
</ul>
</blockquote>
<p>被标记为<code>final</code>的变量代表该变量初始化后就不会改动，是一个常数。而静态的<code>final</code>变量在类加载后就会一致维持原值。</p>
<blockquote>
<p><code>静态初始化程序(static initializer)</code>是一段在加载类时会执行的程序代码，会在其他程序可以使用该类前执行，所有适合放置<code>静态final变量</code>在该部分。</p>
<p>根据<code>命名惯例(naming convention)</code>，常数变量的名称应该都是大写字母！</p>
</blockquote>
<p><code>静态final变量</code>可以通过两种方法初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 在声明时初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FOO_X = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在静态初始化程序中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> BAR_SIGN;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">static</span> &#123; <span class="comment">// 这部分代码在类加载时就执行，早于任何方法或静态变量被使用之前</span></span><br><span class="line">         BAR_SIGN = (<span class="keyword">double</span>) Math.random();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若未使用上述方法为<code>静态final变量</code>初始化，编译器会报错。</p>
<blockquote>
<p><code>final</code>还可以修饰其他变量，方法甚至类</p>
<ul>
<li><code>final</code>变量代表不能改变它的值；</li>
<li><code>final</code>方法代表不能覆盖该方法；</li>
<li><code>final</code>类代表不能继承该类；</li>
</ul>
</blockquote>
<h3 id="2-数字"><a href="#2-数字" class="headerlink" title="2. 数字"></a>2. 数字</h3><h4 id="2-1-Math方法"><a href="#2-1-Math方法" class="headerlink" title="2.1 Math方法"></a>2.1 <code>Math</code>方法</h4><p>下面是对<code>Math</code>方法的一些结束：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/mathMethods.PNG" alt="`Math`方法"></p>
<h4 id="2-2-primitive主数据类型包装"><a href="#2-2-primitive主数据类型包装" class="headerlink" title="2.2 primitive主数据类型包装"></a>2.2 <code>primitive</code>主数据类型包装</h4><p>把<code>primitive</code>主数据类型当作对象来处理，需要一个包装该数据类型的类。每个<code>primitive</code>主数据类型都有一个包装类，存放在<code>java.lang</code>这个包中。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/wrapperClasses.PNG" alt="包装类"></p>
<p>包装类将<code>primitive</code>主数据类型名称第一个字母大写，以符合命名惯例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包装值</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">288</span>;</span><br><span class="line">Integer iWrap = <span class="keyword">new</span> Integer(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解开包装</span></span><br><span class="line"><span class="keyword">int</span> unWrapped = iWrap.intValue();</span><br></pre></td></tr></table></figure>
<h4 id="2-3-autoboxing"><a href="#2-3-autoboxing" class="headerlink" title="2.3 autoboxing"></a>2.3 <code>autoboxing</code></h4><p><code>java 5.0</code>以后加入了<code>autoboxing</code>，自动将<code>primitive</code>主数据类型转换成包装过的对象。</p>
<blockquote>
<p>但依旧无法直接声明<code>ArrayList&lt;int&gt;</code>，因为<code>generic</code>类型的规则是只能指定类或接口类型，因此<code>ArrayList&lt;int&gt;</code>无法通过编译。但可以把该包装对象的<code>primitive</code>主数据类型直接放入<code>ArrayList</code>中。</p>
</blockquote>
<p><code>autoboxing</code>除了在包装或解包<code>primitive</code>主数据类型给<code>collection</code>之外，还可以用到其他地方：</p>
<ul>
<li><p>方法的参数</p>
<p>参数是包装类型，可以传入相应的<code>primitive</code>主数据类型。反之亦然。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">takeNumber</span><span class="params">(Integer i)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值</p>
<p>如果方法声明为返回某些<code>primitive</code>主数据类型，也可以返回兼容的包装类型。</p>
</li>
<li><p><code>boolean</code>表达式</p>
<p>可以使用<code>Boolean</code>包装类型</p>
</li>
<li><p>数值运算</p>
<p>可以直接对包装类型进行数值运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">42</span>); </span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">5</span>); </span><br><span class="line">Integer k = j + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值</p>
<p>将包装类型赋值给<code>primitive</code>主数据类型或相反。</p>
</li>
</ul>
<p>包装内也有实用的静态方法，比如字符串和主数据类型的转化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = Integer.parseInt(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">double</span> d = Double.parseDouble(“<span class="number">420.24</span>”);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意没有<code>Boolean.parseBoolean()</code>方法，但<code>Boolean</code>构造函数可以用<code>String</code>类型创建对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">42.5</span>;</span><br><span class="line">String doubleString = <span class="string">""</span> + d; <span class="comment">// "+"运算符是Java中唯一重载过的运算符，作为字符串拼接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">42.5</span>;</span><br><span class="line">String doubleString = Double.toString(d);</span><br></pre></td></tr></table></figure>
<h4 id="2-4-数字格式"><a href="#2-4-数字格式" class="headerlink" title="2.4 数字格式"></a>2.4 数字格式</h4><p>Java中数字与日期的<code>格式化</code>功能没有结合在输入/输出功能上。该功能在<code>java 5.0</code>以后由<code>java.lang</code>中的<code>Formatter</code>类来提供，该类的功能加入到了部分输入/输出类和<code>String</code>中。可以直接调用<strong>静态</strong>的<code>String.format()</code>来实现格式设定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = String.format(<span class="string">"%, d"</span>, <span class="number">1000000000</span>); <span class="comment">// 将数字以带逗号的形式格式化</span></span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>
<p>格式化主要由两个主要部分组成：</p>
<ol>
<li><strong>格式指令</strong>。概述要输出的特殊格式。</li>
<li><strong>要格式化的值</strong>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/formatString.PNG" alt="格式化"></p>
<p>格式化说明中，跟在<code>百分号(%)</code>后面包括类型指示(如<code>d</code>或<code>f</code>)的每个东西都是格式化指令，类型指示后的字符被视作直接输出的字符串。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/formatSpecifier.PNG" alt="格式化说明"></p>
<blockquote>
<p>类型是唯一的必填项</p>
<p><code>format()</code>使用<code>可变参数列表(variable argument lists, varargs)</code>来对应有不同数目排列组合的参数。</p>
</blockquote>
<h4 id="2-5-日期格式"><a href="#2-5-日期格式" class="headerlink" title="2.5 日期格式"></a>2.5 日期格式</h4><p><code>Date</code>类型是Java上表示时间用的，数值与日期时间格式化的主要差别在于日期格式的类型是用<code>&quot;t&quot;</code>开头的两个字符表示：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dateFormat.PNG" alt="日期格式"></p>
<p><code>java.util.Date</code>适合用于查看当前日期时间，但许多功能已经停用。更多功能推荐使用API <code>java.util.Calendar</code>。<code>Calendar</code>是一个抽象类，当需要<code>Calendar</code>类型时，需要从<code>JVM</code>获取一个子类实例。需要用到静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br></pre></td></tr></table></figure>
<p>通过调用<code>getInstance()</code>会返回一个具体子类的实例。一般默认返回<code>java.util.GregorianCalendar</code>的实例。<code>Calendar</code>类的几个关键特性：</p>
<ul>
<li>字段会保持状态。比如可以读取或设置<code>year</code>或<code>month</code>字段；</li>
<li>日期和时间可以运算。</li>
<li>日期与时间可以用<code>milliseconds</code>表示。即可以将日期转化为微秒，也可以将微秒转换为日期。(相对于<code>1970年1月1日</code>的微秒数)。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/CalendarExample.PNG" alt="Calendar示例"></p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习--基础</title>
    <url>/2019/11/23/Git-learning-foundation.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Git</code> 是一个”版本控制”工具, 可以用来管理我们的代码。简单来说, 就是可以像玩游戏一样, 给一定时间的代码存档, 以后就可以通过”读档”回退到以前的状态。<br><a id="more"></a><br>Git 是<strong>分布式版本控制系统</strong>, 每个项目协作者电脑里都有完整的版本库, 完成修改后, 只需把各自的修改推送给其他人就可以让别人看见自己的修改, 也有充当“中央服务器”的电脑方便“交换”大家的修改。</p>
<p>这里版本库又名仓库，即<em>repository</em>，可以简单理解成一个目录，这个目录里面的所有文件都可以被<code>Git</code>管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以”还原”。</p>
<h3 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h3><p>安装 Git 之后, 使用之前需要先进行一些配置, 主要进行如下配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Zhang San&quot;            # your name</span><br><span class="line">$ git config --global user.email &quot;zhangsan@foo.com&quot;    # your email</span><br><span class="line">$ git config --global core.editor vim                  # your favourite editor</span><br><span class="line">$ git config --global color.ui true                    # your git color</span><br></pre></td></tr></table></figure><br>前两个命令设置基本的用户信息, <code>core.editor</code>可以设置自己喜欢的文本编辑器, <code>color.ui</code> 能为输出到你终端的内容着色，以便你可以凭直观进行快速、简单地分析</p>
<h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>现在可以开始用<code>Git</code>来管理代码了。首先需要将项目的目录初始化为Git可以管理的仓库, 切换到实验/项目的目录中, 然后输入:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init    # 初始化仓库</span><br></pre></td></tr></table></figure><br>我们通过 git clone 命令下载项目, 里面已经包含一些 git 记录, 因此不需要额外进行初始化。</p>
<h4 id="查看版本信息"><a href="#查看版本信息" class="headerlink" title="查看版本信息"></a>查看版本信息</h4><p>主要使用以下两条命令查看版本信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log        # 查看目前为止所有的存档.</span><br><span class="line">$ git status     # 查看与当前存档相比, 哪些文件发生了变化</span><br></pre></td></tr></table></figure></p>
<h4 id="存档"><a href="#存档" class="headerlink" title="存档"></a>存档</h4><p>首先你需要使用 git status 查看是否有新的文件或已修改的文件未被跟踪, 可以使用以下命令将修改的文件加入跟踪列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add file.c    # 将文件 file.c 加入跟踪列表</span><br></pre></td></tr></table></figure><br>如果需要一次添加所有未被跟踪的文件, 也可以使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add .     # 把工作时的所有变化提交到暂存区, 包括文件内容修改(modified)以及新文件(new), 但不包括被删除的文件</span><br><span class="line">$ git add -u    # 仅监控已经被add的文件(即tracked file), 他会将被修改的文件提交到暂存区。(git add --update的缩写)</span><br><span class="line">$ git add -A    # 是上面两个功能的合集(git add --all的缩写), 提交所有变化</span><br></pre></td></tr></table></figure><br>可以通过编辑 <code>.gitignore</code> 文件, 在里面给出需要被 git 忽略的文件和文件类型从而筛选文件。新文件加入跟踪列表, 确认无误后就可以存档了:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit    # 提交工程当前的状态</span><br></pre></td></tr></table></figure><br>执行这条命令后, 需要添加本次存档的注释, 可以根据这些注释来区别和寻找不同的存档。</p>
<h4 id="读档"><a href="#读档" class="headerlink" title="读档"></a>读档</h4><p>首先使用 git log 来查看已有的存档, 并通过存档的 <code>hash code</code> 来回到过去。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard &lt;code&gt;</span><br></pre></td></tr></table></figure><br><code>hard</code>模式会把你工作目录中所有未提交的内容清空, 所以需要慎用。</p>
<h4 id="分支功能"><a href="#分支功能" class="headerlink" title="分支功能"></a>分支功能</h4><p>这就是 <code>Git</code> 的分支功能可以让我们创建不同的世界线, 即在一个时刻, 我们可以做出不同的选择, 使得多个”平行宇宙”并行存在:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch    # 查看所有分支</span><br></pre></td></tr></table></figure><br>使用 <code>git init</code> 初始化之后会自动建立主分支 <code>master</code>。可以用以下命令创建一个新的分支:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b &lt;分支名&gt;    # 创建并切换分支</span><br></pre></td></tr></table></figure><br>我们可以将新分支上的修改合并到主分支上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge &lt;分支名&gt;    # 合并指定分支到当前分支</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<ul>
<li><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/git.html" target="_blank" rel="noopener">git快速入门</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></li>
<li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Git Book(官方文档)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--12 图形用户接口</title>
    <url>/2021/05/17/JavaLearning_Head_First_Java_12_getting_gui.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>面对现实，你得做出图形用户接口。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-window"><a href="#1-window" class="headerlink" title="1. window"></a>1. window</h3><p><code>JFrame</code>是代表屏幕上window的对象，可以把<code>button</code>，<code>checkbox</code>，<code>text</code>字段等接口放在window上。标准的<code>menu</code>也可以加到上面。</p>
<p>一旦创建了<code>JFrame</code>后，就可以把组件(<code>widget</code>)加到上面。最常用的组件包括：<code>JButton, JRadioButton, JCheckBox, JLabel, JList, JScrollPane, JSlider, JTextArea, JTextField, and JTable</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleGui1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 frame</span></span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 widget</span></span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">"click me"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// window关闭时结束程序</span></span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把widget加到frame上</span></span><br><span class="line">        frame.getContentPane().add(button);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定frame大小</span></span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        <span class="comment">// 显式</span></span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-用户接口事件"><a href="#2-用户接口事件" class="headerlink" title="2. 用户接口事件"></a>2. 用户接口事件</h3><p>让按钮在按下时执行工作需要两项：</p>
<ul>
<li>被按下时要执行的方法(按钮任务)</li>
<li>检测按钮被按下的方法(按钮感应装置)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/buttonEvent.PNG" alt="按钮事件"></p>
<p>取得与处理用户操作事件的过程称为<code>event-handling</code>。如果想知道按钮的事件，就会监听事件的接口，<code>监听接口</code>是<u>介于监听与事件源间的桥梁</u>。</p>
<p>事件来源将用户操作转换成事件的对象，事件几乎都是以对象来表示。程序大多数情况是事件的接收方而不是创建方。事件对象通过不同的事件方法来表示不同类型的事件。</p>
<p>比如取得按钮的<code>ActionEvent</code>：</p>
<ul>
<li>实现ActionListener接口</li>
<li>向按钮注册</li>
<li>定义事件处理的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口ActionListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleGui1B</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">    JButton button;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleGui1B gui = <span class="keyword">new</span> SimpleGui1B();</span><br><span class="line">        gui.go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line">        button = <span class="keyword">new</span> JButton(<span class="string">"click me"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        button.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        frame.getContentPane().add(button);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.setSize(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现ActionListener接口的方法，处理事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以ActionEvent对象作为参数调用</span></span><br><span class="line">        button.setText(<span class="string">"I’ve been clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-绘图组件"><a href="#3-绘图组件" class="headerlink" title="3. 绘图组件"></a>3. 绘图组件</h3><p>创建具有绘图功能的<code>widget</code>放到<code>frame</code>上，创建<code>JPanel</code>的子类覆盖掉<code>paintComponet()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDrawPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        g.setColor(Color.orange);</span><br><span class="line">        g.fillRect(<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显式<code>JPEG</code>照片：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">     Image image = <span class="keyword">new</span> ImageIcon(<span class="string">"catzilla.jpg"</span>).getImage();</span><br><span class="line">     g.drawImage(image,<span class="number">3</span>,<span class="number">4</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随机色彩圆：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    g.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">this</span>.getWidth(), <span class="keyword">this</span>.getHeight());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> red = (<span class="keyword">int</span>) (Math.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">int</span> green = (<span class="keyword">int</span>) (Math.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">int</span> blue = (<span class="keyword">int</span>) (Math.random() * <span class="number">256</span>);</span><br><span class="line">    Color randomColor = <span class="keyword">new</span> Color(red, green, blue);</span><br><span class="line">    g.setColor(randomColor);</span><br><span class="line">    g.fillOval(<span class="number">70</span>,<span class="number">70</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-内部类（Inner-class）"><a href="#4-内部类（Inner-class）" class="headerlink" title="4. 内部类（Inner class）"></a>4. 内部类（Inner class）</h3><p>一个类可以嵌套在另一个类的内部。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/innerClass.PNG" alt="简单内部类"></p>
<blockquote>
<p>内部类可以使用外部的所有方法与变量，就算私有内容也一样。即内部类可以把外部的方法或变量当作自己的。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/Inner_class_using_outer_class.PNG" alt="内部类使用外部类的变量"></p>
<blockquote>
<p>内部类的实例一定会绑定在外部类的实例上。从外部类程序代码中初始化的内部类，此内部对象会绑定在该外部对象上。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/innerOuterBound.PNG" alt="创建内部类实例"></p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>AdPart复现--问题集锦</title>
    <url>/2019/11/23/AdPart-Repeat-Problem-Collect.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在复现分布式RDF引擎<code>AdPart</code>, 复现过程中遇到了一些小问题, 就在这里记录一下吧。<br><a id="more"></a></p>
<h3 id="Problem-and-Solve"><a href="#Problem-and-Solve" class="headerlink" title="Problem and Solve"></a>Problem and Solve</h3><h4 id="g-编译问题"><a href="#g-编译问题" class="headerlink" title="g++ 编译问题"></a>g++ 编译问题</h4><p>因为对 <code>g++</code> 编译项目不太熟悉, 这也是第一次自己写一个完整的项目并用 <code>g++</code> 来编译, 难免许多基础都不会。遇到了下面这个报错:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">undefined reference to &apos;Foo::Foo(std::string)&apos;</span><br></pre></td></tr></table></figure><br>这个问题卡了我很久, 什么修改 <code>g++</code> 版本, 不使用<code>c++11</code>都试过，还一度怀疑是不是我代码写的有问题。后来发现是一个很简单的原因，没有在编译的时候将<code>Foo.cpp</code>(用这个来代指我的问题)添加进去, 也就是我编译的时候差不多是这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o testFoo</span><br></pre></td></tr></table></figure><br>但是实际上需要是这样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ main.cpp Foo.cpp -o testFoo</span><br></pre></td></tr></table></figure><br>修改完之后成功编译, 还是对 <code>g++</code> 不熟, 得抽时间学学 <code>g++</code> 怎么编译 <code>c++</code> 代码了。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<ul>
<li><a href="https://stackoverflow.com/questions/3656050/c-undefined-reference-to-foofoostdstring" target="_blank" rel="noopener">c++ “ undefined reference to ‘Foo::Foo(std::string)’ ”</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>AdPart复现</category>
      </categories>
      <tags>
        <tag>AdPart</tag>
        <tag>代码复现</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo学习记录--功能升级</title>
    <url>/2019/11/14/hexo-learning-record--Feature-Upgrade.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>增加一些新功能, 丰富一下博客内容和界面, 就是一些花里胡哨的东西。<br><a id="more"></a></p>
<h3 id="LeanCloud添加文章阅读量"><a href="#LeanCloud添加文章阅读量" class="headerlink" title="LeanCloud添加文章阅读量"></a>LeanCloud添加文章阅读量</h3><p>操作很简单，在 <code>LeanCloud</code>注册账号后，创建一个应用即可，主要参考官网教程和一些网上的博客：</p>
<blockquote>
<ul>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">开始使用</a></li>
<li><a href="https://blog.csdn.net/weixin_39345384/article/details/80787998" target="_blank" rel="noopener">NexT主题下，用Leancloud统计文章阅读量</a></li>
</ul>
</blockquote>
<p>这里需要注意的主要是需要安装 <strong>Web安全</strong> 模块，否者无法正常使用<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-leancloud-counter-security --save</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>主要参考这个博客解决问题 <a href="https://blog.csdn.net/w573719227/article/details/100704952" target="_blank" rel="noopener">HEXO博客使用LeanCloud报错“Counter not initialized! See more at console err msg.”</a></li>
</ul>
</blockquote>
<p>这里还有一个问题, 就是链接里带中文名, 所以导致链接在<code>leancloud</code>中以特殊字符形式存在, 在统计访问次数时出错。需要将其转换为英文的链接地址, 这里使用<a href="https://hexo.io/zh-cn/docs/permalinks.html" target="_blank" rel="noopener">Hexo-永久链接(Permalinks)</a>的方法，自定义链接地址，最终阅读量正常实现。</p>
<h3 id="永久链接（Permalinks）"><a href="#永久链接（Permalinks）" class="headerlink" title="永久链接（Permalinks）"></a>永久链接（Permalinks）</h3><p>可以在博客根目录的配置文件（<code>_config.yml</code>）中这样修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:entitle.html</span></span><br></pre></td></tr></table></figure>
<p>其中<code>entitle</code>是自定义的一个属性，同时在<code>.\scaffolds\post.md</code>中修改：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">entitle: </span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这样在编写文章时，可以在<code>entitle</code>输入指定字符，作为文章链接地址</p>
<blockquote>
<ul>
<li>参考文章<a href="https://blog.csdn.net/Likianta/article/details/79343427" target="_blank" rel="noopener">如何让你的Hexo博客网址使用全英文路径</a></li>
</ul>
</blockquote>
<h3 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a>不蒜子统计</h3><p>更新到新版本后，启用不蒜子统计很简单，只需要在主题配置文件中启用即可：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">false</span> <span class="comment"># 与leancloud重复，故注释掉</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure>
<p>应该也可以用leancloud实现类似功能，但懒得折腾了，就直接<code>不蒜子统计</code>一块用吧。</p>
<h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><p>启用字数统计需要安装一个插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>之后设置配置文件即可：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>
<h3 id="加载进度条"><a href="#加载进度条" class="headerlink" title="加载进度条"></a>加载进度条</h3><p>同样需要安装一下依赖库，不过他的安装方法与之前不同，不是用<code>npm</code>命令来安装，而是直接添加到主题的<code>lib</code>中：</p>
<ol>
<li><p>进入博客文件夹的<code>/themes/next</code>文件夹下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog_folder/themes/next-update # 注意转换为对应主题路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>载安装<code>Progress module</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-pace source/lib/pace</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>/themes/next/_config.yml</code>中设置使生效</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">bounce</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="GitHub图床"><a href="#GitHub图床" class="headerlink" title="GitHub图床"></a>GitHub图床</h3><p>在写博客时，我们常常需要在博客中插入图片什么的。这时一般需要一个图床，免费的图床有很多，但是上传文件后只能得到一个链接，不知道什么时候会丢失链接或者干脆图床网站不维护了。我们可以利用<code>GitHub</code>建立一个图床仓库，方便管理。顺便也可以练习一下<code>Git</code>的使用。如下图就是建立的一个图床仓库：<br><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/GitHubImageRepository.PNG" alt="GitHub图床"></p>
<blockquote>
<p>这里需要注意的一点是，GitHub图片的地址需要是源文件地址，比如上图的地址：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/GitHubImageRepository.PNG</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>之前一直用的<code>GitHub</code>下文件的url(<code>https://github.com</code>开头)，一直不显示，还以为是图片格式不兼容，笑哭。</p>
<h3 id="表格显示问题"><a href="#表格显示问题" class="headerlink" title="表格显示问题"></a>表格显示问题</h3><p><code>table</code>表格显示异常，直接不显示表格。一开始以为是渲染器，语法什么的问题，后来发现原来解决方法很简单，表格和正文之间需要空行。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">测试</th>
<th style="text-align:left">表格</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">正常</td>
<td style="text-align:left">显示</td>
</tr>
</tbody>
</table>
</div>
<h3 id="加入豆瓣书单"><a href="#加入豆瓣书单" class="headerlink" title="加入豆瓣书单"></a>加入豆瓣书单</h3><p>直接安装豆瓣依赖模块 <code>$ npm install hexo-douban --save</code>, 简单易操作。配置上需要在 <code>hexo</code> 配置文件中加入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">douban:</span><br><span class="line">  user: mythsman</span><br><span class="line">  builtin: false</span><br><span class="line">  book:</span><br><span class="line">    title: &apos;This is my book title&apos;</span><br><span class="line">    quote: &apos;This is my book quote&apos;</span><br><span class="line">  movie:</span><br><span class="line">    title: &apos;This is my movie title&apos;</span><br><span class="line">    quote: &apos;This is my movie quote&apos;</span><br><span class="line">  game:</span><br><span class="line">    title: &apos;This is my game title&apos;</span><br><span class="line">    quote: &apos;This is my game quote&apos;</span><br><span class="line">  timeout: 10000</span><br></pre></td></tr></table></figure></p>
<p>然后部署到主题文件中, <code>next</code> 主题下设置为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives</span><br><span class="line">  books: /books     # 这是链接到books页面</span><br><span class="line">  movies: /movies   #  这是链接到movies页面</span><br><span class="line">  games: /games   # 这是链接到games页面</span><br></pre></td></tr></table></figure></p>
<p>之后在启动过程中加入命令 <code>hexo douban -bgm</code> 自动抓取相关信息生成页面。 其中开启 <code>hexo-douban</code> 的命令中，<code>-bgm</code> 代表的是 <code>book、game、movie</code> 三个参数。</p>
<h3 id="加入搜索功能"><a href="#加入搜索功能" class="headerlink" title="加入搜索功能"></a>加入搜索功能</h3><ol>
<li><p>安装本地搜索插件 <code>hexo-generator-search</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
<p>安装之后，会在站点目录的 <code>public</code> 文件夹下创建一个 <code>search.xml</code> 文件</p>
</li>
<li><p>在站点配置文件 <code>_config.yml</code> 中添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Search </span><br><span class="line">search:</span><br><span class="line">  path: ./public/search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p><code>field</code>：搜索范围，默认是 <code>post</code>，还可以选择 <code>page</code>、<code>all</code>，设置成 <code>all</code> 表示搜索所有页面<br><code>limit</code>：限制搜索的条目数</p>
</li>
<li><p>主题配置文件<br>在主题配置文件 <code>_config.yml</code> 中找到如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  trigger: auto</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>
<p>确保 <code>enable</code> 设成 <code>true</code>。</p>
</li>
</ol>
<h3 id="加入评论系统-基于Valine"><a href="#加入评论系统-基于Valine" class="headerlink" title="加入评论系统(基于Valine)"></a>加入评论系统(基于Valine)</h3><ol>
<li><p>获取 <code>APP ID</code> 和 <code>APP Key</code><br> 先登录或注册 <code>LeanCloud</code>, 进入控制台后创建应用。选择<code>设置</code>&gt;<code>应用Key</code>，就可以获取<code>APP ID</code>和<code>APP Key</code>了。</p>
</li>
<li><p>在<code>next</code>主题中配置<code>valine</code><br>在主题配置文件 <code>_config.yml</code> 中找到<code>comments</code>栏目并开启<code>valine</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comments:</span><br><span class="line">  active: valine</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>然后在该配置文件中找到<code>valine</code>设置栏，开启<code>valine</code>并填入<code>appid</code>和<code>appkey</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid: # your app id</span><br><span class="line">  appkey: # your app key</span><br><span class="line">  notify: true # 评论回复邮件提醒, See: https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # 验证码服务</span><br><span class="line">  placeholder: 留言区 # 评论框占位提示符</span><br><span class="line">  avatar: mm # 头像配置</span><br><span class="line">  guest_info: nick,mail,link # 回复要填写的信息</span><br><span class="line">  pageSize: 10 # 评论列表分页，每页条数</span><br><span class="line">  visitor: false # 文章访问量统计 </span><br><span class="line">  comment_count: true # if false, comment count will only be displayed in post page, not in home page</span><br></pre></td></tr></table></figure></p>
<ol>
<li>由于<code>valine 1.4</code>版本后，不再支持自带的<code>邮件提醒</code>，所以这里使用第三方<code>Valine-Admin</code>，基于<code>Leancloud</code>的云引擎与云函数。功能更完善，主要部署方法可以查阅<code>github</code>:<a href="https://github.com/DesertsP/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a>。<blockquote>
<p>PS: 这里<code>Leancloud</code><strong>一定要用国际版</strong>，可以少去很多麻烦。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>学习记录</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--16 集合与泛型</title>
    <url>/2021/05/19/JavaLearning_Head_First_Java_16_collections_and_generics.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>排序在Java中只是雕虫小技。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-集合"><a href="#1-集合" class="headerlink" title="1. 集合"></a>1. 集合</h3><p><code>ArrayList</code>是最常用的集合，此外还有一些较为重要的集合：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/collector.PNG" alt="一些集合类"></p>
<p>可以使用<code>TreeSet</code>或<code>Collections.sort()</code>方法对集合元素排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(songList);</span><br></pre></td></tr></table></figure>
<p>若将<code>ArrayList</code>声明为自定义类(如<code>Song</code>)的数组，使用<code>Collections.sort()</code>将无法通过编译。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/sortMethod.PNG" alt="sort方法定义"></p>
<blockquote>
<p><code>sort()</code>方法取只能接受<code>Comparable</code>对象的<code>list</code>。</p>
</blockquote>
<h4 id="1-1-Collections接口"><a href="#1-1-Collections接口" class="headerlink" title="1.1 Collections接口"></a>1.1 Collections接口</h4><p><code>Collections</code>主要有<code>3</code>个接口：<code>List</code>，<code>Set</code>和<code>Map</code>。</p>
<ul>
<li><code>List</code>是一种知道索引位置的集合，可以存在重复元素。</li>
<li><code>Set</code>知道某物是否存在于集合中，它不允许重复。</li>
<li><code>Map</code>使用成对的键值(<code>key</code>)和数据值(<code>value</code>)，<code>key</code>可以引用相同的对象，但<code>key</code>自身不能重复。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/collectorTree.PNG" alt="Collection API"></p>
<h4 id="1-2-对象等价"><a href="#1-2-对象等价" class="headerlink" title="1.2 对象等价"></a>1.2 对象等价</h4><ul>
<li><code>引用相等性</code>。堆上同一对象的两个引用，引用对堆上同一个对象的两个引用时相等的。如果这两个引用调用<code>hashCode</code>，会得到相同的结果。使用<code>==</code>来比较变量上的子节组合，判断引用是否相等。</li>
<li><code>对象相等性</code>。堆上的两个不同对象在意义上是相同的，要把两个不同的对象视为相等，需要覆盖<code>hashCode</code>方法与<code>equals</code>方法。</li>
</ul>
<blockquote>
<p>要让<code>set</code>把对象视为重复的，必须满足<code>equals</code>和<code>hashCode</code>返回两对象相等。</p>
</blockquote>
<p><code>equals</code>和<code>hashCode</code>的相关规定：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/hashCodeEquals.PNG" alt="`equals`和`hashCode`"></p>
<h4 id="1-3-TreeSet"><a href="#1-3-TreeSet" class="headerlink" title="1.3 TreeSet"></a>1.3 TreeSet</h4><p>使用<code>TreeSet</code>必须使得以下一项为真：</p>
<ul>
<li><p>集合中的元素必须是有实现<code>Comparable</code>的类型；</p>
</li>
<li><p>使用重载、取用<code>Comparator</code>参数的构造函数创建<code>TreeSet</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BookCompare bCompare = <span class="keyword">new</span> BookCompare();</span><br><span class="line">TreeSet&lt;Book&gt; tree = <span class="keyword">new</span> TreeSet&lt;Book&gt;(bCompare);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-4-Map"><a href="#1-4-Map" class="headerlink" title="1.4 Map"></a>1.4 Map</h4><p><code>Map</code>的元素实际上是两个对象：关键词(key)和值(value)。值可以重复，但key不能重复。通过<code>Map</code>可以用名称来取值等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; scores = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">scores.put(“Kathy”, <span class="number">42</span>);</span><br><span class="line">scores.put(“Bert”, <span class="number">343</span>);</span><br><span class="line">scores.put(“Skyler”, <span class="number">420</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2. 泛型"></a>2. 泛型</h3><p><code>&lt;&gt;</code>符号代表<code>泛型(generic)</code>正在起作用，它是从<code>Java 5.0</code>开始加入的特质。泛型的主要目的是能够获取有<u>更好的类型安全性的集合</u>。</p>
<blockquote>
<p>在泛型出现前，没有办法什么<code>ArrayList</code>的类型，所以只能用<code>Object</code>来操作。各种对象以引用的形式加入到<code>ArrayList</code>中，出来时会是<code>Object</code>类型的引用。</p>
</blockquote>
<p>使用泛型后，能定义<code>ArrayList</code>类型，在取出时还是该类型的引用。此外也不能在该<code>ArrayList</code>中加入非该类的对象。关于泛型几件重要的事：</p>
<ol>
<li><p>创建被泛型化类的实例。比如创建<code>ArrayList</code>时必须指定它所容许的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ArrayList&lt;Song&gt;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明与指定泛型类型的变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Song&gt; songList = <span class="keyword">new</span> ArrayList&lt;Song&gt;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明(与调用)取用泛型类型的方法。</p>
</li>
</ol>
<h4 id="2-1-泛型的类"><a href="#2-1-泛型的类" class="headerlink" title="2.1 泛型的类"></a>2.1 泛型的类</h4><p>查看泛型化类型，有两个关键的部分：</p>
<ol>
<li>类的声明。</li>
<li>新增元素的方法的声明。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; ... </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>E</code>部分会用所声明和创建的真正类型来取代，<code>E</code>代指<code>Element</code>。在新增元素的方法中，也用<code>E</code>指示可以加入<code>ArrayList</code>的元素类型。</li>
<li>这里<code>E</code>并不是关键词，硬性规定的。也可以用其他合法字符串来当作类型参数。习惯用法是以单一字母表示。</li>
</ul>
</blockquote>
<h4 id="2-2-泛型的方法"><a href="#2-2-泛型的方法" class="headerlink" title="2.2 泛型的方法"></a>2.2 泛型的方法</h4><p>泛型的类代表类的声明用到类型参数。泛型的方法代表方法的声明特征用到类型参数。</p>
<ol>
<li><p>使用定义在类声明的类型参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; ... </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>声明类的类型参数后，就可以直接把该类或接口类型用在任何地方。</p>
</li>
<li><p>使用未定义在类声明的类型参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure>
<p>如果类本身未使用类型参数，可以通过在返回类型之前指定给该方法。<code>&lt;T extends Animal&gt;</code>意味着<code>T</code>可以是任意一种<code>Animal</code>。</p>
</li>
</ol>
<p>这里需要注意的是，以下两种方法的声明合法，但意义不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;Animal&gt; list)</span></span></span><br></pre></td></tr></table></figure>
<p><code>&lt;T extends Animal&gt;</code>是方法声明的一部分，表示任何被声明未<code>Animal</code>或<code>Animal</code>的子类型的<code>ArrayList</code>是合法的。可以使用<strong>任意一种</strong><code>Animal</code>的<code>ArrayList</code>。</p>
<p>但下面的方法中<code>ArrayList&lt;Animal&gt; list</code>代表只有<code>ArrayList&lt;Animal&gt;</code>是合法的，也就是它<strong>只能使用</strong><code>Animal</code>的<code>ArrayList</code>。</p>
<h4 id="2-3-sort-方法中的泛型"><a href="#2-3-sort-方法中的泛型" class="headerlink" title="2.3 sort()方法中的泛型"></a>2.3 <code>sort()</code>方法中的泛型</h4><p>回到<code>sort()</code>方法的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure>
<p>实际上<code>Comparable</code>是一个接口，但以泛型的观点，<code>extends</code>代表<code>extends</code>或<code>implement</code>。所以必须实现<code>Comparable</code>才能把类的<code>ArrayList</code>传给<code>sort</code>。只有一个方法需要实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>compareTo</code>方法会判别在排序位置上某个对象是高于、低于或等于另一个对象。<code>sort()</code>有重载方法，可以取用称为<code>Comparator</code>的参数。<code>Comparator</code>是独立的类，因此可以实现不同的比较方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用规则如下：</p>
<ul>
<li>调用单一参数的<code>sort(List o)</code>方法代表由<code>List</code>元素上的<code>compareTo</code>方法来决定顺序，需要实现<code>Comparable</code>接口。</li>
<li>调用<code>sort(List o, Comparator c)</code>方法代表不会调用<code>list</code>元素的<code>compareTo</code>方法，而会使用<code>Comparator</code>的<code>compare</code>方法，这种情况下list元素不需要实现<code>Comparable</code>接口。</li>
</ul>
<h4 id="2-4-多态与泛型"><a href="#2-4-多态与泛型" class="headerlink" title="2.4 多态与泛型"></a>2.4 多态与泛型</h4><p>在普通的多态中，定义如下函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(Animal a: animals) &#123;</span><br><span class="line">         a.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法只能取用<code>ArrayList&lt;Animal&gt;</code>参数，而不能传入<code>ArrayList&lt;Dog&gt;</code>或<code>ArrayList&lt;Cat&gt;</code>，以为如果程序执行如下代码时，会出现类型错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">	animals.add(<span class="keyword">new</span> Cat());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数换成数组时尽管能通过编译，但在执行时也会出错。</p>
<blockquote>
<p>数组的类型在运行期间检查，集合的类型检查只发生在编译期间。</p>
</blockquote>
<p>可以使用泛型的<code>万用字符(wildcard)</code>来解决这个问题。创建出可以接受<code>Animal</code>子类型参数的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;? extends Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(Animal a: animals) &#123;</span><br><span class="line">     	a.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用带有<code>&lt;?&gt;</code>的声明时，编译器会组织任何可能破坏引用参数所指集合的行为。</p>
<ul>
<li>可以调用<code>list</code>中任何元素的方法，但不能加入元素。即可以操作集合元素，但不能新增集合元素，以保证安全性。</li>
</ul>
<p>两种不同的语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;? extends Animal&gt; list)</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--2 类与对象</title>
    <url>/2021/04/27/JavaLearning_Head_First_Java_2_class_and_objects.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>有人告诉我那里遍地都是对象！<br><a id="more"></a></p>
</blockquote>
<h3 id="1-椅子大战——阿花的”对象”"><a href="#1-椅子大战——阿花的”对象”" class="headerlink" title="1. 椅子大战——阿花的”对象”"></a>1. 椅子大战——阿花的”对象”</h3><p>面向对象信徒阿花利用面向对象的思想赢得了椅子大战(但最后赢家是阿娇——老板娘的侄女，作者调皮了)。</p>
<h4 id="类与继承-inheritance"><a href="#类与继承-inheritance" class="headerlink" title="类与继承(inheritance)"></a>类与继承(inheritance)</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_inheritance.PNG" alt="继承(inheritance)"></p>
<h4 id="覆盖-override"><a href="#覆盖-override" class="headerlink" title="覆盖(override)"></a>覆盖(override)</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_override.PNG" alt="覆盖(override)"></p>
<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h3><blockquote>
<p> <code>对象</code>是依靠类的模型塑造出来的，对象也可以叫做<code>实例</code>。可以把对象分为两部分看：</p>
<ul>
<li>对象是已知的事物<ul>
<li><code>实例变量</code>(instance variable)。对象本身已知的事物，代表对象的状态(数据)，且该类型的每一个对象都会独立地拥有一份该类型的值。</li>
</ul>
</li>
<li>对象会执行的当作<ul>
<li><code>方法</code>(methods)。对象可以执行的动作，读取或操作实例变量。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_override.PNG" alt="Java对象"></p>
<h4 id="类与对象的区别"><a href="#类与对象的区别" class="headerlink" title="类与对象的区别"></a>类与对象的区别</h4><blockquote>
<p>”<em>类不是对象，却是用来创建对象的模型</em>‘“。类是对象的<strong>蓝图</strong>，告诉虚拟机如何创建某种类型的对象。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_object_relation.PNG" alt="类与对象"></p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>创建对象后，使用<code>圆点(.)</code>符号所代表的操作数来<em>存取该对象的变量和方法</em>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_create_object.PNG" alt="创建对象"></p>
<h4 id="逃出main"><a href="#逃出main" class="headerlink" title="逃出main()"></a>逃出main()</h4><blockquote>
<p><code>main()</code>的两种用途</p>
<ul>
<li>测试真正的类</li>
<li>启动JAVA应用程序</li>
</ul>
</blockquote>
<p>Java程序普遍只会让对象与对象交互，即相互调研方法。猜数字游戏示例：</p>
<blockquote>
<p><strong>摘要：</strong></p>
<p>涉及到<code>game</code>和<code>player</code>两个对象，<code>game</code>会产生介于0~9之间的随机数，3个<code>player</code>对象会猜测该数字。</p>
<p><strong>类：</strong></p>
<ul>
<li>GuessGame.class</li>
<li>Player.class</li>
<li>GameLauncher.class</li>
</ul>
<p><strong>程序逻辑：</strong></p>
<ol>
<li><code>GameLauncher</code>类带有<code>main()</code>方法，是应用程序<strong>入口点</strong>；</li>
<li><code>main()</code>中会创建<code>GuessGame</code>对象，并调用它的<code>startGame()</code>方法；</li>
<li><code>startGame()</code>方法是游戏的起点。它会创建3个player，然后挑出要猜测的随机数字。它会要求player猜测并检查结果，列出过程。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.schoolLearning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        number = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"I'm guessing "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    Player p1;</span><br><span class="line">    Player p2;</span><br><span class="line">    Player p3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        p1 = <span class="keyword">new</span> Player();</span><br><span class="line">        p2 = <span class="keyword">new</span> Player();</span><br><span class="line">        p3 = <span class="keyword">new</span> Player();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> guessp1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> guessp2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> guessp3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> p1isRight = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> p2isRight = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> p3isRight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetNumber = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"I'm thinking of a number between 0 and 9..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Number to guess is "</span> + targetNumber);</span><br><span class="line"></span><br><span class="line">            p1.guess();</span><br><span class="line">            p2.guess();</span><br><span class="line">            p3.guess();</span><br><span class="line"></span><br><span class="line">            guessp1 = p1.number;</span><br><span class="line">            System.out.println(<span class="string">"Player one guessed "</span> + guessp1);</span><br><span class="line">            guessp2 = p2.number;</span><br><span class="line">            System.out.println(<span class="string">"Player two guessed "</span> + guessp2);</span><br><span class="line">            guessp3 = p3.number;</span><br><span class="line">            System.out.println(<span class="string">"Player three guessed "</span> + guessp3);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (guessp1 == targetNumber) &#123;</span><br><span class="line">                p1isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp2 == targetNumber) &#123;</span><br><span class="line">                p2isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp3 == targetNumber) &#123;</span><br><span class="line">                p3isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p1isRight || p2isRight || p3isRight) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"We have a winner!"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Player one got it right? "</span> + p1isRight);</span><br><span class="line">                System.out.println(<span class="string">"Player two got it right? "</span> + p2isRight);</span><br><span class="line">                System.out.println(<span class="string">"Player three got it right? "</span> + p3isRight);</span><br><span class="line">                System.out.println(<span class="string">"Game is over."</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Players will have to try again."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameLauncher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GuessGame game = <span class="keyword">new</span> GuessGame();</span><br><span class="line">        game.startGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol>
<li><p>在创建类时，<code>.java</code>文件内只能有一个<code>public</code>声明的类，且类名需要与文件名一致，一般设定为包含<code>main()</code>函数的类。更规范的写法是为不同的类分别创建<code>.java</code>文件，维护各自的代码，通过文件之间的调用(<code>import</code>)实现交互。</p>
</li>
<li><p>Java垃圾回收。</p>
<p>创建对象时，不管对象如何创建的，它都会被存放于称为<code>堆</code>的内存区域，在Java中是<code>可回收垃圾的堆(Garbage-Collectible Heap)</code>。Java会根据对象的大小来分配内存空间，当Java虚拟机察觉到对象不再会被使用到时，该对象会被标记为可回收的。如果内存不足，垃圾收集器就会启动来清理垃圾、回收空间。</p>
</li>
<li><p>包装多个类成为单一应用程序形式。</p>
<p>可以把所有文件包装进依据<code>pkzip</code>格式来存档的<code>Java Archive-.jar文件</code>。在该<code>jar</code>文件中可以引入一个简单文字格式的文字文件，被称为<code>manifest</code>，里面有定义出<code>jar</code>中的哪一个文件带有启动应用程序的<code>main()</code>方法。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--3 认识变量</title>
    <url>/2021/05/11/JavaLearning_Head_First_Java_3_recognize_variables.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>变量有两种：<code>primitive</code>主数据类型和引用。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-声明变量"><a href="#1-声明变量" class="headerlink" title="1. 声明变量"></a>1. 声明变量</h3><p><code>Java</code>中必须声明所有变量的类型。主要分为两种变量</p>
<blockquote>
<ul>
<li><code>primitive</code>主数据类型保存基本类型的值，包括<strong>整数、布尔和浮点数等</strong>；</li>
<li><code>对象引用</code>保存对象的引用</li>
</ul>
</blockquote>
<p>变量必须有<strong>类型</strong>和<strong>名称</strong>。（<strong><code>variables must have a type and a name</code></strong>）</p>
<h4 id="primitive主数据类型"><a href="#primitive主数据类型" class="headerlink" title="primitive主数据类型"></a><code>primitive</code>主数据类型</h4><p><code>primitive</code>主数据类型有不同大小和名称：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/variable_type_size.PNG" alt="`primitive`主数据类型有不同大小"></p>
<p>这里展示了<code>primitive</code>主数据类型的名称以及对应的位数：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/primitive_variable_type_size.PNG" alt="`primitive`主数据类型名称以及对应的位数"></p>
<blockquote>
<p>这里注意在声明浮点数时，除非加上<code>f</code>，否则所有带小数点的值都会被<code>Java</code>当作<code>double</code>处理。(比如<code>float f = 32.5f</code>)</p>
</blockquote>
<p><code>Java</code>编译器不允许将较大的类型值赋给较小类型，比如<code>int</code>类型值无法赋予<code>byte</code>类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">byte</span> b = x;</span><br></pre></td></tr></table></figure>
<p>即使<code>byte</code>可以装下<code>24</code>，这条语句也不能通过编译。</p>
<h4 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h4><p>没有对象变量存在，只有<code>引用（reference）</code>到对象的变量。</p>
<blockquote>
<p>对象引用变量保存的是<strong>存取对象的方法</strong>；</p>
</blockquote>
<p>它不是对象的容器，而是类似于指向对象的指针或者说地址。</p>
<blockquote>
<p>但只有<code>Java</code>虚拟机知道如何使用引用来获取对象，我们并不知道引用变量中实际装载的是什么。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/variable_object_reference.PNG" alt="对象引用"></p>
<p>对象的声明、创建与赋值有三个步骤：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/create_object.PNG" alt="对象的声明、创建与赋值"></p>
<blockquote>
<p><strong>数组也是对象</strong></p>
</blockquote>
<p>无论声明来承载<code>primitive</code>主数据类型还是对象引用，数组永远是对象。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/array_is_object.PNG" alt="数组也是对象"></p>
<h3 id="2-变量命名规范"><a href="#2-变量命名规范" class="headerlink" title="2. 变量命名规范"></a>2. 变量命名规范</h3><p>可以根据一下规则来为类、方法或变量命名：</p>
<blockquote>
<ul>
<li>名称必须以字母、下划线(<code>_</code>)或<code>$</code>符号开头，不能用数字开头；</li>
<li>除了第一个字符外，后面就可以用数字；</li>
<li>只要符合上述两条规则，就可以进行任意命名了。但要注意避开Java<code>保留字</code>。</li>
</ul>
</blockquote>
<p>这里的规则是最为基础的规则了，实际上为了命名规范，还有更多更复杂的要求。Java<code>保留字</code>一览表：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/reserved_word.PNG" alt="Java`保留字`一览表"></p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--4 对象的行为</title>
    <url>/2021/05/12/JavaLearning_Head_First_Java_4_behavior_of_objects.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>状态影响行为，行为影响变量。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-对象参数"><a href="#1-对象参数" class="headerlink" title="1. 对象参数"></a>1. 对象参数</h3><h4 id="1-1-对象的状态与行为"><a href="#1-1-对象的状态与行为" class="headerlink" title="1.1. 对象的状态与行为"></a>1.1. 对象的状态与行为</h4><p>类是对象的蓝图。在编写类时，是在描述Java虚拟机应该如何制作该类型的对象。</p>
<blockquote>
<p>类所描述的是对象<code>知道什么与执行什么</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/instance_and_method.PNG" alt="实例变量与方法"></p>
<p>同一个类型的对象能有不同的方法行为。每个实例有相同的方法，但方法可以根据实例变量的值变现不同行为。</p>
<h4 id="1-2-方法的参数"><a href="#1-2-方法的参数" class="headerlink" title="1.2. 方法的参数"></a>1.2. 方法的参数</h4><p>可以传值给方法。可以使用<code>实参(argument)</code>或<code>形参(parameter)</code>来调用传给方法的参数</p>
<blockquote>
<p>方法会运用形参，调用一方会传入实参</p>
<ul>
<li>实参是传给方法的值；</li>
<li>实参传入方法后就成为了形参；</li>
<li>参数跟局部变量一样。它也有类型和名称，可以在方法内运用</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/argument_and_parameter.PNG" alt="实参与形参"></p>
<h4 id="1-3-返回值"><a href="#1-3-返回值" class="headerlink" title="1.3. 返回值"></a>1.3. 返回值</h4><p>方法可以有返回值，每个方法都需要声明返回的类型。</p>
<blockquote>
<p><code>void</code>表示没有返回任何东西。</p>
</blockquote>
<p>比如可以声明一个返回<code>int</code>类型值的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">giveSecret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果声明了方法有返回值，必须返回声明类型的值！</p>
<h4 id="1-4-多个参数"><a href="#1-4-多个参数" class="headerlink" title="1.4. 多个参数"></a>1.4. 多个参数</h4><p>方法可以有多个参数，声明和传入时都要以逗号分开。</p>
<blockquote>
<p>一定要以正确数量，类型和顺序来传递参数</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/multipe_argument.PNG" alt="多个参数"></p>
<h4 id="1-5-参数传递"><a href="#1-5-参数传递" class="headerlink" title="1.5. 参数传递"></a>1.5. 参数传递</h4><p>Java通过值传递，或者通过拷贝传递参数。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/argument_pass.PNG" alt="参数传递"></p>
<blockquote>
<p><strong>方法无法改变调用方所传入的参数。</strong></p>
</blockquote>
<h4 id="1-6-要点"><a href="#1-6-要点" class="headerlink" title="1.6. 要点"></a>1.6. 要点</h4><blockquote>
<ul>
<li>如果传入的参数是对象，那么<strong>实际上传入的是远程控制的拷贝</strong>。</li>
<li>方法只能声明单一返回值。如果需要返回多个返回值，可以使用数组。如需要返回混合不同类型值，可以使用<code>ArrayList</code></li>
</ul>
</blockquote>
<h3 id="2-封装-Encapsulation"><a href="#2-封装-Encapsulation" class="headerlink" title="2. 封装(Encapsulation)"></a>2. 封装(Encapsulation)</h3><p>不封装可能会导致数据泄露。比如直接通过圆点运算符(<code>.</code>)来存取实例变量，可能会出现异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">theCat.height = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>需要创建<code>Setter</code>方法，使得在设置变量前可以进行检查。将程序实现从不良数据改成可以保护数据，且还能保持数据可修改，可以使用两个<code>存取修饰符(access modifier)</code>：公有修饰符<code>public</code>和私有修饰符<code>private</code>。封装的基本原则是：</p>
<blockquote>
<p>将实例变量标记为私有，提供公有的<code>getter</code>与<code>setter</code>方法来控制存取动作。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/advantage_of_setter.PNG" alt="封装的好处"></p>
<h3 id="3-初始化实例变量"><a href="#3-初始化实例变量" class="headerlink" title="3. 初始化实例变量"></a>3. 初始化实例变量</h3><p>声明变量是需要名称和类型，也可以同时初始化变量(为变量赋值)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">256</span>;</span><br></pre></td></tr></table></figure>
<p>如果未明确初始化实例变量，会为实例变量设置默认值。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/init_variable.PNG" alt="实例变量默认值"></p>
<blockquote>
<p>这么看，<code>String</code>变量内存储的也是一个对象引用。</p>
</blockquote>
<h3 id="4-实例变量与局部变量"><a href="#4-实例变量与局部变量" class="headerlink" title="4. 实例变量与局部变量"></a>4. 实例变量与局部变量</h3><p>实例变量与局部变量的区别：</p>
<blockquote>
<ul>
<li>实例变量声明在类内而不是方法中；而局部变量声明在方法中</li>
<li>局部变量使用前必须初始化，即<strong>局部变量没有默认值！</strong>如果在初始化前被调用，编译器会报错。</li>
</ul>
</blockquote>
<p>方法参数基本上与局部变量是相同的。</p>
<h3 id="5-变量的比较"><a href="#5-变量的比较" class="headerlink" title="5. 变量的比较"></a>5. 变量的比较</h3><h4 id="5-1"><a href="#5-1" class="headerlink" title="5.1 =="></a>5.1 <code>==</code></h4><blockquote>
<p><code>==</code>用于比较两个变量的字节组合是否相等。</p>
</blockquote>
<p>可以使用<code>==</code>来比较两个<code>primitive</code>主数据类型是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123; <span class="comment">// true &#125;</span></span><br></pre></td></tr></table></figure>
<p>也可以用<code>==</code>来判断两个引用是否指向同一对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo a = <span class="keyword">new</span> Foo();</span><br><span class="line">Foo b = <span class="keyword">new</span> Foo();</span><br><span class="line">Foo c = a;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123; <span class="comment">// false &#125;</span></span><br><span class="line"><span class="keyword">if</span> (a == c) &#123; <span class="comment">// true &#125;</span></span><br><span class="line"><span class="keyword">if</span> (b == c) &#123; <span class="comment">// false &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2-equals"><a href="#5-2-equals" class="headerlink" title="5.2 equals()"></a>5.2 <code>equals()</code></h4><p>使用<code>equals()</code>方法来判断两个对象是否在含义上相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1,s2,s3 = <span class="string">"abc"</span>, s4 =<span class="string">"abc"</span> ;</span><br><span class="line">s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">s1==s2   是 <span class="keyword">false</span>      <span class="comment">//两个变量的内存地址不一样，也就是说它们指向的对象不一样，</span></span><br><span class="line"></span><br><span class="line">s1.equals(s2) 是 <span class="keyword">true</span>    <span class="comment">//两个变量的所包含的内容是abc，故相等。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--14 序列化和文件的输入/输出</title>
    <url>/2021/05/18/JavaLearning_Head_First_Java_14_serialization_and_file_IO.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>对象可以被序列化也可以展开。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-存储对象"><a href="#1-存储对象" class="headerlink" title="1. 存储对象"></a>1. 存储对象</h3><p>存储对象状态的数据格式（主要讨论两种）：</p>
<ul>
<li>序列化(serialization)。将被序列化的对象写到文件中，然后让程序去文件中读取序列化的对象并把他们展开变回状态。</li>
<li>纯文本文件。用可解析的特殊字符写到文件中，比如用<code>tab</code>字符来分隔数据。</li>
</ul>
<p>将对象序列化（存储）的方法步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1. 创建出 FileOutputStream</span></span><br><span class="line">FileOutputStream fileStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"MyGame.ser"</span>); <span class="comment">// 文件不存在会自动创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建出 ObjectOutputStream</span></span><br><span class="line">ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(fileStream); <span class="comment">// 可以向文件写入对象，但无法直接连接文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 写入对象</span></span><br><span class="line">os.writeObject(characterOne); <span class="comment">// 将变量所引用的对象序列化并写入文件</span></span><br><span class="line">os.writeObject(characterTwo);</span><br><span class="line">os.writeObject(characterThree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 关闭 ObjectOutputStream</span></span><br><span class="line">os.close(); <span class="comment">// 关闭所关联的输出串流</span></span><br></pre></td></tr></table></figure>
<p>Java输入/输出<code>API</code>带有连接类型的<code>串流(chain streams)</code>，代表来源与目的地之间的连接，连接串流将串流与其他串流连接起来。</p>
<p>串流要两两连接，一个表示连接，另一个是要被调用方法。<code>FileOutputStream</code>把子节写入文件，<code>ObjectOutputStream</code>把对象转换成可以写入串流的数据。当调用<code>ObjectOutputStream</code>的<code>writeObject</code>方法时，对象会被打成串流送到<code>FileOutputStream</code>来写入文件。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/chainStreams.PNG" alt="序列化"></p>
<blockquote>
<p>当对象被序列化时，被该对象引用的实例变量也会被序列化，且所有被引用的对象也会被序列化。</p>
</blockquote>
<p>如果要让类能够被序列化，需要实现<code>Serializable</code>。<code>Serializable</code>接口又被称为<code>marker</code>或<code>tag</code>类的标记用接口，此接口没有任何方法需要实现，唯一目的是<u><strong>声明所有实现它的类是可以被序列化的</strong></u>。所以此类型的对象可以通过序列化机制来存储。</p>
<blockquote>
<ul>
<li>某类是可序列化的，则它的子类也自动地可以序列化</li>
<li>序列化是全有或全无地，即整个对象版图必须全部正确序列化，不然全部失败。</li>
</ul>
</blockquote>
<p>如果某实例变量不能或不应该被序列化，需要标记其为<code>transient</code>(瞬时)。序列化程序会跳过标记的变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chat</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">transient</span> String currentID;</span><br><span class="line"> </span><br><span class="line">     String userName;</span><br><span class="line">     <span class="comment">// more code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-还原对象"><a href="#2-还原对象" class="headerlink" title="2. 还原对象"></a>2. 还原对象</h3><p><code>解序列化(Deserialization)</code>像是序列化的反向操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建FileInputStream</span></span><br><span class="line">FileInputStream fileStream = <span class="keyword">new</span> FileInputStream(<span class="string">"MyGame.ser"</span>); <span class="comment">// 文件不存在会抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建ObjectInputStream</span></span><br><span class="line"><span class="comment">// ObjectInputStream可以读取对象，但不能直接连接文件，需要一个连接流(connection stream)</span></span><br><span class="line">ObjectInputStream os = <span class="keyword">new</span> ObjectInputStream(fileStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 读取对象</span></span><br><span class="line"><span class="comment">// 每次readObject都会读出下一个对象，读取顺序与写入顺序相同，次数超过会抛出异常</span></span><br><span class="line">Object one = os.readObject();</span><br><span class="line">Object two = os.readObject();</span><br><span class="line">Object three = os.readObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 转换对象类型</span></span><br><span class="line"><span class="comment">// 返回值是Object类型，因此必须要转换类型</span></span><br><span class="line">GameCharacter elf = (GameCharacter) one;</span><br><span class="line">GameCharacter troll = (GameCharacter) two;</span><br><span class="line">GameCharacter magician = (GameCharacter) three;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 关闭ObjectInputStream</span></span><br><span class="line"><span class="comment">// FileInputStream会随之自动关闭</span></span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure>
<p>对象被解序列化时，Java虚拟机会通过尝试在堆上创建新对象，让它维持与被序列化时有相同的状态来恢复对象的原状。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/Deserialization.PNG" alt="解序列化"></p>
<ol>
<li>对象从<code>stream</code>中读出来；</li>
<li>Java虚拟机通过存储的消息判断出对象的class类型；</li>
<li>Java虚拟机尝试寻找和加载对象的类。如果Java虚拟机找不到或无法加载该类，则Java虚拟机会抛出异常</li>
<li>新的对象会被配置在堆上，但构造函数不会执行。</li>
<li>如果对象在继承树上有不可序列化的祖先类，则该不可序列化类以及它之上的类的构造函数会执行。</li>
<li>对象的实例变量会被还原成序列化时的状态值。<code>transient</code>变量会被赋值默认值。</li>
</ol>
<h3 id="3-将字符串写入文本文件"><a href="#3-将字符串写入文本文件" class="headerlink" title="3. 将字符串写入文本文件"></a>3. 将字符串写入文本文件</h3><p>写入文本数据与写入对象类似，可以使用<code>FileWriter</code>代替<code>FileOutputStream</code>，它不会被连接到<code>ObjectOutputStream</code>上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteAFile</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="string">"Foo.txt"</span>);</span><br><span class="line">             writer.write(<span class="string">"hello foo!"</span>);</span><br><span class="line">             writer.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">             ex.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.io.File</code>类代表磁盘上的文件，但并不是文件中的内容。<code>File</code>没有读写文件的方法，它提供一种比字符串文件名来表示文件更安全的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建出代表磁盘文件的File对象</span></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"MyCode.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立新的目录</span></span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"Chapter7"</span>); </span><br><span class="line">dir.mkdir();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 列出目录下的内容</span></span><br><span class="line"><span class="keyword">if</span> (dir.isDirectory()) &#123;</span><br><span class="line">	String[] dirContents = dir.list();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dirContents.length; i++) &#123;</span><br><span class="line">		System.out.println(dirContents[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 取得文件或目录的绝对路径</span></span><br><span class="line">System.out.println(dir.getAbsolutePath());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 删除文件或目录</span></span><br><span class="line"><span class="keyword">boolean</span> isDeleted = f.delete();</span><br></pre></td></tr></table></figure>
<p><strong>缓冲区</strong></p>
<p>缓冲区可以带来更高的效率。通过<code>BufferedWriter</code>和<code>FileWriter</code>的链接，<code>BufferedWriter</code>可以暂存一些数据，到满的时候在实际写入磁盘，可以减少对磁盘的操作次数。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/buffers.PNG" alt="缓冲区"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(aFile));</span><br></pre></td></tr></table></figure>
<p>若想要强制缓冲区立即写入，可以调用以下方法要求立即写入缓冲区内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">writer.flush();</span><br></pre></td></tr></table></figure>
<h3 id="4-读取文本文件"><a href="#4-读取文本文件" class="headerlink" title="4. 读取文本文件"></a>4. 读取文本文件</h3><p>用<code>File</code>对象来表示文件，以<code>FileReader</code>来执行实际的读取，并用<code>BufferedReader</code>来让读取更有效。读取以<code>while</code>循环来逐行进行，知道<code>readLine()</code>的结果为<code>null</code>为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadAFile</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             File myFile = <span class="keyword">new</span> File(<span class="string">"MyText.txt"</span>);</span><br><span class="line">             <span class="comment">// FileReader是字符连接到文本文件的串流</span></span><br><span class="line">             FileReader fileReader = <span class="keyword">new</span> FileReader(myFile);</span><br><span class="line">             <span class="comment">// FileReader链接到BufferedReader以获取更高效率</span></span><br><span class="line">             BufferedReader reader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">             </span><br><span class="line">             <span class="comment">// 用String变量来承接所读取的结果</span></span><br><span class="line">             String line = <span class="keyword">null</span>;</span><br><span class="line">             </span><br><span class="line">             <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 读一行就列出一行</span></span><br><span class="line">                 System.out.println(line);</span><br><span class="line">             &#125;</span><br><span class="line">             reader.close(); </span><br><span class="line">         &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">             ex.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解析字符串</strong></p>
<p>用<code>String</code>的<code>split()</code>方法来解析字符串，<code>split()</code>可以将字符串拆开成<code>String</code>的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从文件读出来的格式</span></span><br><span class="line">String toTest = <span class="string">"What is blue + yellow?/green"</span>;</span><br><span class="line"><span class="comment">// split用参数所指定的字符来把这个String拆开成两个部分</span></span><br><span class="line">String[] result = toTest.split(<span class="string">"/"</span>);</span><br><span class="line"><span class="keyword">for</span> (String token:result) &#123;</span><br><span class="line">     System.out.println(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.nio</code>类可以直接控制<code>buffer</code>。另一个能力是<code>non-blocking</code>的输入/输出，能让输入/输出程序代码在没有东西可读取或写入时不必等待。</p>
<p><strong>序列化的识别</strong></p>
<p>版本控制很重要，如果在序列化后修改了类的定义，会伤害兼容性：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/changesForDeserialization.PNG" alt="修改对序列化的影响"></p>
<p>每当对象被序列化时，该对象会被盖上一个类版本识别ID，叫做<code>serialVersionUID</code>，根据类的结构消息计算所得。当对象被接序列化时，如果对象被序列化之后有了不同的<code>serialVersionUID</code>，还原操作会失败！</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/serialVersionUID.PNG" alt="serialVersionUID"></p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--15 网络与线程</title>
    <url>/2021/05/18/JavaLearning_Head_First_Java_15_networking_and_threads.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>连接到外面的世界。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-客户端-Client-与服务器-Server"><a href="#1-客户端-Client-与服务器-Server" class="headerlink" title="1. 客户端(Client)与服务器(Server)"></a>1. 客户端(Client)与服务器(Server)</h3><p>客户端必须要认识服务器，服务器必须要认识所有的客户端。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientAndServer.PNG" alt="客户端与服务器"></p>
<p>工作方式如下：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientAndServerWorks.PNG" alt="客户端与服务器工作方式"></p>
<p>连接、传送与接受：</p>
<p>客户端要连接服务器需要做三件事：</p>
<ol>
<li>建立客户端与服务器之间的初始连接</li>
<li>传送信息到服务器</li>
<li>接受来自服务器的信息</li>
</ol>
<p>Java API的网络功能包(<code>java.net</code>)对底层工作细节进行了封装。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientConnectServer.PNG" alt="客户端"></p>
<h4 id="1-1-Socket连接"><a href="#1-1-Socket连接" class="headerlink" title="1.1 Socket连接"></a>1.1 Socket连接</h4><p>连接到其他机器需要<code>Socket连接</code>，<code>Socket</code>是代表两台机器间网络连接的对象(<code>java.net.Socket</code>)。创建Socket连接需要两项关于<strong>服务器</strong>的信息：<code>IP地址</code>和<code>端口号</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"196.164.1.103"</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
<p>Socket连接的建立代表两台机器间有对方的信息(包括<code>IP地址</code>和<code>端口号</code>)</p>
<p><code>TCP</code>端口是一个<code>16</code>位宽、用来识别服务器上特定程序的数字。一个地址可以有<code>65536</code>个不同的端口号可用。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/wellKnownTCPPort.PNG" alt="常用的TCP端口号"></p>
<blockquote>
<p><code>0~1023</code>的<code>TCP</code>端口号预留给已知特定服务使用，可以从<code>1024~65535</code>中选择端口号用于自定义程序</p>
</blockquote>
<p>不同程序不能共享一个端口，使用(也叫绑定)某个已被占用的端口，会受到<code>BindException</code>异常。</p>
<h4 id="1-2-读取Socket数据"><a href="#1-2-读取Socket数据" class="headerlink" title="1.2 读取Socket数据"></a>1.2 读取Socket数据</h4><p>可以用串流来通过Socket连接沟通，即使用<code>BufferedReader</code>从<code>Socket</code>上读取数据，而不管串流来自文件还是Socket。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 建立对服务器的Socket连接</span></span><br><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立连接到Socket上低层输入串流的InputStreamReader</span></span><br><span class="line">InputStreamReader stream = <span class="keyword">new</span> InputStreamReader(chatSocket.getInputStream());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 建立BufferedReader来读取</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(stream);</span><br><span class="line">String message = reader.readLine();</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/readFromSocket.PNG" alt="读取Socket数据"></p>
<h4 id="1-3-向Socket写入数据"><a href="#1-3-向Socket写入数据" class="headerlink" title="1.3 向Socket写入数据"></a>1.3 向Socket写入数据</h4><p>利用<code>PrintWriter</code>向Socket写入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 对服务器建立Socket连接</span></span><br><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立连接到Socket的PrintWriter</span></span><br><span class="line">PrintWriter writer = <span class="keyword">new</span> PrintWriter(chatSocket.getOutputStream());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 写入数据</span></span><br><span class="line">writer.println(<span class="string">"message to send"</span>);</span><br><span class="line">writer.print(<span class="string">"another message"</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/PrintWriterToSocket.PNG" alt="向Socket写入数据"></p>
<h4 id="1-4-客户端"><a href="#1-4-客户端" class="headerlink" title="1.4 客户端"></a>1.4 客户端</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/client.PNG" alt="客户端"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyAdviceClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket s = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">4242</span>);</span><br><span class="line">            InputStreamReader streamReader = <span class="keyword">new</span> InputStreamReader(s.getInputStream());</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(streamReader);</span><br><span class="line">            String advice = reader.readLine();</span><br><span class="line">            System.out.println(<span class="string">"Today you should: "</span> + advice);</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DailyAdviceClient client = <span class="keyword">new</span> DailyAdviceClient();</span><br><span class="line">        client.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-服务器"><a href="#1-5-服务器" class="headerlink" title="1.5 服务器"></a>1.5 服务器</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/server.PNG" alt="客户端"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyAdviceServer</span> </span>&#123;</span><br><span class="line">    String[] adviceList = &#123;<span class="string">"Take smaller bites"</span>, <span class="string">"Go for the tight jeans. No they do NOT make you look fat."</span>, <span class="string">"One word: inappropriate"</span>, <span class="string">"Just for today, be honest. Tell your boss what you *really* think"</span>, <span class="string">"You might want to rethink that haircut."</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSock = <span class="keyword">new</span> ServerSocket(<span class="number">4242</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket sock = serverSock.accept();</span><br><span class="line"></span><br><span class="line">                PrintWriter writer = <span class="keyword">new</span> PrintWriter(sock.getOutputStream());</span><br><span class="line">                String advice = getAdvice();</span><br><span class="line">                writer.println(advice);</span><br><span class="line">                writer.close();</span><br><span class="line">                System.out.println(advice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// close go</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> random = (<span class="keyword">int</span>) (Math.random() * adviceList.length);</span><br><span class="line">        <span class="keyword">return</span> adviceList[random];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DailyAdviceServer server = <span class="keyword">new</span> DailyAdviceServer();</span><br><span class="line">        server.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>每个线程有独立的<code>执行空间(stack)</code>。Java内置有<code>多线程(Multithreading)</code>功能，但只有一种<code>Thread</code>类。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/javaThread.PNG" alt="Thread类"></p>
<h4 id="2-1-新建线程"><a href="#2-1-新建线程" class="headerlink" title="2.1 新建线程"></a>2.1 新建线程</h4><p>每个Java应用程序会启动一个主线程，将<code>main()</code>函数放在执行空间最开始处。Java虚拟机负责主线程的启动。自定义建立的线程，需要在程序中启动。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JVMThread.PNG" alt="主线程与自建线程"></p>
<p>启动新线程主要有以下几个步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 建立Runnable对象(线程的任务)，此类是对线程要执行的任务的定义</span></span><br><span class="line">Runnable threadJob = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立Thread对象(执行工人)并赋值Runnable对象</span></span><br><span class="line"><span class="comment">// 告诉Thread对象把Runnable的run()方法放到执行空间执行</span></span><br><span class="line">Thread myThread = <span class="keyword">new</span> Thread(threadJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 启动线程Thread</span></span><br><span class="line"><span class="comment">// 真正到执行空间执行run()方法</span></span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Thread</code>是个工人，<code>Runnable</code>是这个工人的工作。</p>
</blockquote>
<p><code>Runnable</code>是一个<strong>接口</strong>，只有<code>run()</code>这一个方法。<code>Runnable</code>带有会放在执行空间的第一项方法：<code>run()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// code that will be run by the new thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-线程的状态"><a href="#2-2-线程的状态" class="headerlink" title="2.2 线程的状态"></a>2.2 线程的状态</h4><p>新建线程的3个状态：</p>
<ol>
<li><p>等待启动(新建线程)。Thread实例已经创建，但还未启动。即未处于执行中的线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可执行线程。启动线程时，变成可执行状态，已经布置好了执行空间，轮到它就可以执行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行中线程。线程占用资源开始执行，该过程只能依靠JVM的线程调度机制来决定。</p>
</li>
</ol>
<blockquote>
<p>一旦线程进入可执行状态，会不断在可执行与执行中两种状态切换。也可有另一种状态：暂时不可执行(<code>阻塞状态</code>)</p>
</blockquote>
<ul>
<li>典型的可执行/执行中循环。即JVM线程调度器会把不断切换线程，给予不同线程执行机会。</li>
<li>暂时被阻挡。<code>调度器(scheduler)</code>会在特殊情况下把线程阻塞，比如线程执行到等待<code>Socket</code>输入流的程序段，但又无数据可读，调度器会把线程移出可执行状态。或者<code>Sleep()</code>函数、调用某个被<code>锁住(locked)</code>的对象等等。</li>
</ul>
<h4 id="2-3-线程调度器"><a href="#2-3-线程调度器" class="headerlink" title="2.3 线程调度器"></a>2.3 线程调度器</h4><p><code>线程调度器(Thread Scheduler)</code>会<u>决定哪个线程从等待状态中被挑出来运行，以及何时把哪个线程送回等待被执行的状态</u>。</p>
<blockquote>
<p>调度是无法被控制的</p>
</blockquote>
<p>可以通过<code>sleep</code>强制要求线程睡眠，暂时不被唤醒。但调度器是不可预测的，线程之间可能有多个不同的执行顺序，每次执行可能得到不同的结果。</p>
<blockquote>
<p>Thread对象不能重复使用，一旦线程的run()方法完成后，线程就不能再重新启动。</p>
</blockquote>
<h4 id="2-4-sleep"><a href="#2-4-sleep" class="headerlink" title="2.4 sleep()"></a>2.4 <code>sleep()</code></h4><p>确保线程有机会执行，可以让它们周期性地进入<code>睡眠</code>状态。当线程醒来时，会进入可执行状态等待被调度器调度执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<p><code>sleep</code>方法可能会抛出<code>InterruptedException</code>异常，所以对它的调用需要放在<code>try/catch</code>块中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">     ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-建立与启动多个线程"><a href="#2-5-建立与启动多个线程" class="headerlink" title="2.5 建立与启动多个线程"></a>2.5 建立与启动多个线程</h4><p>可以为线程命名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunThreads</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunThreads runner = <span class="keyword">new</span> RunThreads();</span><br><span class="line">        Thread alpha = <span class="keyword">new</span> Thread(runner);</span><br><span class="line">        Thread beta = <span class="keyword">new</span> Thread(runner);</span><br><span class="line">        alpha.setName(<span class="string">"Alpha thread"</span>);</span><br><span class="line">        beta.setName(<span class="string">"Beta thread"</span>);</span><br><span class="line">        alpha.start();</span><br><span class="line">        beta.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(threadName + <span class="string">" is running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-线程的并发性问题"><a href="#2-6-线程的并发性问题" class="headerlink" title="2.6 线程的并发性问题"></a>2.6 线程的并发性问题</h4><p>线程的<code>并发性(Concurrency)</code>问题会引发<code>竞争状态(race condition)</code>。竞争状态可能会引起数据的损毁。需要对线程间的共享数据增加一道锁，以保证数据的安全。</p>
<p>要使得具有安全问题的方法<code>原子化</code>，比如对账户操作的方法<code>makeWithdrawal()</code>。确定线程一旦进入这个方法后，就必须能够在其他线程进入之前把任务执行完毕。</p>
<blockquote>
<p>使用<code>synchronized</code>关键词来修饰方法使它每次只能被单一线程存取。</p>
<ul>
<li><code>synchronized</code>关键词代表线程需要钥匙来存取被<code>同步化(synchronized)</code>过的线程。</li>
<li>要保护数据，就把作用在数据上的方法同步化</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">makeWithdrawal</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (account.getBalance() &gt;= amount) &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ is about to withdraw”);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             System.out.println(Thread.currentThread().getName() + “ is going to sleep”);</span><br><span class="line">             Thread.sleep(<span class="number">500</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;ex.printStackTrace(); &#125;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ woke up.”);</span><br><span class="line">         account.withdraw(amount);</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ completes the withdrawl”);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(“Sorry, not enough <span class="keyword">for</span> “ + Thread.currentThread().getName());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>锁不是配在方法上的，而是配在对象上的。这意味着对象有两个同步化的方法，就表示两个线程无法进入同一个方法，也表示两个线程无法进入不同的方法。</p>
</blockquote>
<p>同步化除了可以保证数据的安全，但同时也存在一些影响或潜在问题：</p>
<ul>
<li>同步化方法会带来额外的开销(查询钥匙等)</li>
<li>同步化方法会强制线程排队，影响并行性</li>
<li>同步化方法可能会导致死锁</li>
</ul>
<p>原则上只做最少量的同步化，可以用<code>synchronized</code>来修饰一行或数行指令而不必同步化整个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     doStuff();</span><br><span class="line">     <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">         criticalStuff();</span><br><span class="line">         moreCriticalStuff();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于静态方法，每个被载入的类也有锁。</p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--7 继承与多态</title>
    <url>/2021/05/12/JavaLearning_Head_First_Java_7_inheritance_and_polymorphism.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>规划程序时要考虑未来。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h3><h4 id="1-1-继承"><a href="#1-1-继承" class="headerlink" title="1.1 继承"></a>1.1 继承</h4><p>设计<strong>继承</strong>时，会把共同程序代码放在某个类中，告诉其他类此类事他们的父类。当某个类继承另一个类的时候，也就是子类继承自父类。继承的关系意味着子类继承了父类的方法和实例变量。</p>
<p>如下一个例子</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceExample.PNG" alt="继承"></p>
<p><code>PantherMan</code>会自动继承<code>SuperHero</code>的实例变量和方法，且<code>PantherMan</code>也可以加入自己的方法和实例变量，或者覆盖掉继承的方法。而<code>FriedEggMan</code>不需要独特的行为，所以没有覆盖任何方法。</p>
<blockquote>
<p>实例变量无法覆盖是因为不需要，它们没有定义特殊的行为。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceExample.PNG" alt="继承范例"></p>
<p>在这个继承范例中，<code>Family Doctor</code>增加了实例变量和方法，<code>Surgeon</code>覆盖了继承的方法并增加了一个新方法。</p>
<blockquote>
<ul>
<li><p>需要注意继承使用的关键词<code>extends</code></p>
</li>
<li><p>如果在子类中还打算引用父类的方法，可以使用<code>super</code>关键字：</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.roam();</span><br><span class="line">     <span class="comment">// my own roam stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-继承层次设计"><a href="#1-2-继承层次设计" class="headerlink" title="1.2 继承层次设计"></a>1.2 继承层次设计</h4><p>比如以设计动物仿真程序为例，主要有以下步骤：</p>
<ol>
<li>找出具有共同属性和行为的对象</li>
<li>设计代表共同状态与行为的类</li>
<li>决定子类是否需要让某项行为(即方法的实现)有特定不同的运作方式</li>
<li>通过寻找使用共同行为的子类来找出更多抽象化的机会</li>
<li>完成类的继承层次</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/animalInheritanceTree.PNG" alt="动物类继承层次"></p>
<blockquote>
<p>当调用对象引用的方法时，会调用到与该对象类型最接近的方法。即<code>最低阶</code>会胜出。Java虚拟机会从树的叶节点开始往上寻找方法。</p>
</blockquote>
<p>所有子类与其任一个上层父类之间应该都是<code>IS-A</code>的关系。</p>
<h4 id="1-3-存取权限"><a href="#1-3-存取权限" class="headerlink" title="1.3 存取权限"></a>1.3 存取权限</h4><p>父类可以通过存取权限决定子类是否能够继承某些特定的成员。主要有以下4种存取权限，左边最受限制，越往右限制程度越小：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/accessLevels.PNG" alt="存取权限"></p>
<p><code>存取权限(Access levels)</code>控制谁可以接触什么：</p>
<blockquote>
<ul>
<li><code>public</code>类型的成员会被继承</li>
<li><code>private</code>类型的成员不会被继承</li>
</ul>
</blockquote>
<h4 id="1-4-继承的意义"><a href="#1-4-继承的意义" class="headerlink" title="1.4 继承的意义"></a>1.4 继承的意义</h4><p>通过继承，子类不需要重新编译就能运行到新版本的父类。此外通过继承可以：</p>
<ol>
<li><p>避免重复的程序代码</p>
<p>即可以在父类这一单一位置定义共同程序代码。</p>
</li>
<li><p>定义出共同的协议</p>
<p>继承可以确保每个父类下的所有类都会有父类所持有的全部(可继承的)方法。也就是说，通过继承来定义相关类之间的共同协议。</p>
</li>
</ol>
<h4 id="1-5-“私有类”"><a href="#1-5-“私有类”" class="headerlink" title="1.5 “私有类”"></a>1.5 “私有类”</h4><p>实际上没有”私有类”的概念，但有三种方法可以防止这个类被继承：</p>
<ol>
<li><p>存取控制。不能标记类为私有，但可以不标记为公有。非公有类只能被同一个包的类继承。</p>
</li>
<li><p>使用<code>final</code>修饰符。表示它是继承树的末端，不能被继承。</p>
<blockquote>
<p><code>final</code>表示符主要为保证安全，确保方法都是当前版本。</p>
<p>如果想防止特定方法被覆盖，可以在该方法前表示<code>final</code>修饰符。</p>
</blockquote>
</li>
<li><p>让类只拥有<code>private</code>的构造函数。</p>
</li>
</ol>
<h3 id="2-多态"><a href="#2-多态" class="headerlink" title="2. 多态"></a>2. 多态</h3><p>一般声明引用和创建对象时，重点在于要求引用类型与对象类型必须相符。而在多态下，引用与对象可以是不同类型：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphismExample.PNG" alt="多态"></p>
<p>运用多态时，引用类型可以时实际对象类型的父类。所以可以实现<code>多态数组(polymorphic arrays)</code>这一类东西：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphicArray.PNG" alt="多态数组"></p>
<p>参数和返回类型也可以用多态。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphicArgument.PNG" alt="参数多态"></p>
<h3 id="3-覆盖的规则"><a href="#3-覆盖的规则" class="headerlink" title="3. 覆盖的规则"></a>3. 覆盖的规则</h3><p>当要覆盖父类的方法时，必须遵守以下规则：</p>
<ol>
<li>参数必须一样，且返回类型必须兼容</li>
<li><strong>不能降低</strong>方法的存取权限</li>
</ol>
<h3 id="4-方法的重载-overload"><a href="#4-方法的重载-overload" class="headerlink" title="4. 方法的重载(overload)"></a>4. 方法的重载(overload)</h3><p>重载的意义是两个方法的名称相同，但参数不同。所以<strong>重载与多态毫无关系</strong>。</p>
<blockquote>
<p>重载的方法只是刚好有相同名字的不同方法，它与继承或多态无关</p>
</blockquote>
<p>重载的方法有更多的扩展性：</p>
<ol>
<li>返回类型可以不同</li>
<li>不能只改变返回类型。重载的条件是<strong>要使用不同的参数</strong>。</li>
<li>可以任意设定存取权限</li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--6 认识Java的API</title>
    <url>/2021/05/12/JavaLearning_Head_First_Java_6_Using_the_Java_Library.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>Java内置有数百个类。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-解决上一章程序的bug"><a href="#1-解决上一章程序的bug" class="headerlink" title="1. 解决上一章程序的bug"></a>1. 解决上一章程序的bug</h3><p>上一章的简单版游戏中，一旦猜中了一格，可以持续攻击同一格结束游戏。需要一种机制判别之前是否已经猜中过。</p>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>使用第二个数组，一旦玩家猜中某格，就把对应的格设置为true，之后每次猜中都检查是否已经猜中过。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionOneForDotComBug.PNG" alt="方案一"></p>
<p>但这种方法过于耗时，每次猜中某一格，都必须检查或改变第二个数组的状态，且需要额外的空间。</p>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>只动用原来数组，将任何被命中的格子改为<code>-1</code>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionTwoForDotComBug.PNG" alt="方案二"></p>
<p>但依旧不是很有效率，已经命中过的格子还是需要再次被搜索。</p>
<h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p>在命中某个格子后，就把它删掉，格子会越来越少。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionThreeForDotComBug.PNG" alt="方案三"></p>
<p>但数组大小无法改变，必须创建新数组并进行拷贝。如果有<em>可变数组</em>就可以解决这个问题。</p>
<h3 id="2-ArrayList类"><a href="#2-ArrayList类" class="headerlink" title="2. ArrayList类"></a>2. <code>ArrayList</code>类</h3><p><code>ArrayList</code>类是Java库函数中的一个类，是一个”边长的数组”。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/someMethodsArrayList.PNG" alt="`ArrayList`类部分方法"></p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/someMethodsArrayList2.PNG" alt="`ArrayList`的操作"></p>
<p><code>ArrayList</code>与一般数组的区别：</p>
<blockquote>
<ul>
<li>一般数组在创建时必须确定大小，但<code>ArrayList</code>只需要创建出该类型对象就可以。</li>
<li>存放对象时，一般数组需要指定位置；<code>ArrayList</code>可以使用方法<code>add()</code>。</li>
<li>一般数组使用<code>[]</code>来存取对象；<code>ArrayList</code>使用<code>get</code>方法。</li>
<li>在<code>Java 5.0</code>中<code>ArrayList</code>是<strong>参数化的(parameterized)</strong>，即<code>ArrayList&lt;Type&gt;</code>。<code>&lt;Type&gt;</code>是类型参数，代表<code>Type</code>类型的集合。</li>
</ul>
</blockquote>
<h3 id="3-完整版”Sink-a-Dot-Com”"><a href="#3-完整版”Sink-a-Dot-Com”" class="headerlink" title="3. 完整版”Sink a Dot Com”"></a>3. 完整版”Sink a Dot Com”</h3><p>需要对原来的三个类进行修改：</p>
<blockquote>
<ul>
<li><code>DotCom</code>类。原来的<code>SimpleDotCom</code>类。<ul>
<li>需要增加名称变量来保存<code>DotCom</code>的名字。</li>
</ul>
</li>
<li><code>DotComBust</code>类。原来的<code>SimpleDotComGame</code>类。<ul>
<li>需要创建多个<code>DotCom</code>对象。</li>
<li>将<code>DotCom</code>对象放到方阵上。</li>
<li>每次猜测要检查多个<code>DotCom</code>，所有都击沉后才能结束游戏。</li>
<li>脱离<code>main()</code>函数。</li>
</ul>
</li>
<li><code>GameHelper</code>类。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/fullDotComGame.PNG" alt="完整版&quot;Sink a Dot Com&quot;类间关系"></p>
<h4 id="3-1-DotComBust类"><a href="#3-1-DotComBust类" class="headerlink" title="3.1 DotComBust类"></a>3.1 <code>DotComBust</code>类</h4><h5 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h5><p><code>DotComBust</code>类有3个任务：启动游戏，运行游戏以及结束游戏。可以对运行游戏任务分解，较小的方法更容易测试修改。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dotComBustPrepCode.PNG" alt="DotComBust伪码"></p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dotComBustPrepCodeContinued.PNG" alt="DotComBust伪码（续）"></p>
<h5 id="真实码"><a href="#真实码" class="headerlink" title="真实码"></a>真实码</h5><p><code>DotComBust</code>类Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotComBust</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GameHelper helper = <span class="keyword">new</span> GameHelper();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;DotCom&gt; dotComList = <span class="keyword">new</span> ArrayList&lt;DotCom&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfGuesses = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建dotCom实例，并加入到dotComList中</span></span><br><span class="line">        DotCom one = <span class="keyword">new</span> DotCom();</span><br><span class="line">        one.setName(<span class="string">"Pets.com"</span>);</span><br><span class="line">        dotComList.add(one);</span><br><span class="line"></span><br><span class="line">        DotCom two = <span class="keyword">new</span> DotCom();</span><br><span class="line">        two.setName(<span class="string">"eToys.com"</span>);</span><br><span class="line">        dotComList.add(two);</span><br><span class="line"></span><br><span class="line">        DotCom three = <span class="keyword">new</span> DotCom();</span><br><span class="line">        three.setName(<span class="string">"Go2.com"</span>);</span><br><span class="line">        dotComList.add(three);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出提示信息</span></span><br><span class="line">        System.out.println(<span class="string">"Your goal is to sink three dot coms."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Pets.com, eToys.com, Go2.com"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Try to sink them all in the fewest number of guesses"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化每个dotCom在棋盘中的位置</span></span><br><span class="line">        <span class="keyword">for</span> (DotCom dotComToSet: dotComList) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; newLocation = helper.placeDotCom(<span class="number">3</span>);</span><br><span class="line">            dotComToSet.setLocationCells(newLocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startPlaying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!dotComList.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取用户的猜测值</span></span><br><span class="line">            String userGuess = helper.getUserInput(<span class="string">"Enter a guess"</span>);</span><br><span class="line">            <span class="comment">// 检查玩家猜测值</span></span><br><span class="line">            checkUserGuess(userGuess);</span><br><span class="line">        &#125;</span><br><span class="line">        finishGame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkUserGuess</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        numOfGuesses++;</span><br><span class="line">        String result = <span class="string">"miss"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (DotCom dotComToSet: dotComList) &#123;</span><br><span class="line">            result = dotComToSet.checkYourself(userGuess);</span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"hit"</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"kill"</span>)) &#123;</span><br><span class="line">                dotComList.remove(dotComToSet);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"All Dot Coms are dead! Your stock is now worthless."</span>);</span><br><span class="line">        <span class="keyword">if</span> (numOfGuesses &lt;= <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"It only took you "</span> + numOfGuesses + <span class="string">" guesses."</span>);</span><br><span class="line">            System.out.println(<span class="string">" You got out before your options sank."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Took you long enough. "</span> + numOfGuesses + <span class="string">" guesses."</span>);</span><br><span class="line">            System.out.println(<span class="string">"Fish are dancing with your options."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotComBust game = <span class="keyword">new</span> DotComBust();</span><br><span class="line">        game.setUpGame();</span><br><span class="line">        game.startPlaying();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-DotCom类"><a href="#3-2-DotCom类" class="headerlink" title="3.2 DotCom类"></a>3.2 <code>DotCom</code>类</h4><p><code>DotCom</code>类Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotCom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; locationCells;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocationCells</span> <span class="params">(ArrayList&lt;String&gt; locations)</span> </span>&#123;</span><br><span class="line">        locationCells = locations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkYourself</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">"miss"</span>; <span class="comment">// 创建保存返回结果的变量, 以miss作为默认值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (locationCells.contains(userGuess)) &#123;</span><br><span class="line">            locationCells.remove(userGuess);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(locationCells.isEmpty()) &#123;</span><br><span class="line">                result = <span class="string">"kill"</span>;</span><br><span class="line">                System.out.println(<span class="string">"Ouch! You sunk "</span> + name + <span class="string">" :("</span>); <span class="comment">// 显式结果</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="string">"hit"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(result); // 显式结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-GameHelper类"><a href="#3-3-GameHelper类" class="headerlink" title="3.3 GameHelper类"></a>3.3 <code>GameHelper</code>类</h4><p><code>GameHelper</code>类除了获取玩家输入外，还增加了设置<code>DotCom</code>的位置这一功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String alphabet = <span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gridLength = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gridSize = <span class="number">49</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] grid = <span class="keyword">new</span> <span class="keyword">int</span>[gridSize];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> comCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInput</span><span class="params">(String prompt)</span> </span>&#123;</span><br><span class="line">        String inputLine = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(prompt + <span class="string">"  "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">            );</span><br><span class="line">            inputLine = is.readLine();</span><br><span class="line">            <span class="keyword">if</span> (inputLine.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inputLine.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">placeDotCom</span><span class="params">(<span class="keyword">int</span> comSize)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; alphaCells = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        String temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 现有字符串</span></span><br><span class="line">        <span class="keyword">int</span> [] coords = <span class="keyword">new</span> <span class="keyword">int</span> [comSize];</span><br><span class="line">        <span class="comment">// 目前测试的字符串</span></span><br><span class="line">        <span class="keyword">int</span> attempts = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到适合的位置吗？</span></span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 目前起点</span></span><br><span class="line">        <span class="keyword">int</span> location = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在处理到第n个dot com</span></span><br><span class="line">        comCount++;</span><br><span class="line">        <span class="comment">// incr是增量, 水平方向增量(+1), 垂直增量(+7, gridLength)</span></span><br><span class="line">        <span class="keyword">int</span> incr = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果是单数号dot com, 垂直增量</span></span><br><span class="line">        <span class="keyword">if</span> ((comCount % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            incr = gridLength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主要搜索循环</span></span><br><span class="line">        <span class="keyword">while</span> (!success &amp; attempts++ &lt; <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 随机起点</span></span><br><span class="line">            location = (<span class="keyword">int</span>) (Math.random() * gridSize);</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 假设是适合的位置</span></span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查找未使用的点</span></span><br><span class="line">            <span class="keyword">while</span> (success &amp;&amp; x &lt; comSize) &#123;</span><br><span class="line">                <span class="comment">// 若未使用</span></span><br><span class="line">                <span class="keyword">if</span> (grid[location] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 存储位置，尝试下一个点</span></span><br><span class="line">                    coords[x++] = location;</span><br><span class="line">                    location += incr;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 超出边缘, 失败, 不是适合的</span></span><br><span class="line">                    <span class="keyword">if</span> (location &gt;= gridSize) &#123;</span><br><span class="line">                        success = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 水平方向超出边缘, 失败</span></span><br><span class="line">                    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; (location % gridLength) == <span class="number">0</span>) &#123;</span><br><span class="line">                        success = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 该位置已经使用过</span></span><br><span class="line">                    success = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将位置转换为字符串</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(x &lt; comSize) &#123;</span><br><span class="line">            <span class="comment">// 标示格子已用</span></span><br><span class="line">            grid[coords[x]] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 行值</span></span><br><span class="line">            row = (<span class="keyword">int</span>) (coords[x] / gridLength);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 列值</span></span><br><span class="line">            column = coords[x] % gridLength;</span><br><span class="line">            temp = String.valueOf(alphabet.charAt(column));</span><br><span class="line"></span><br><span class="line">            alphaCells.add(temp.concat(Integer.toString(row)));</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  alphaCells;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-布尔表达式"><a href="#4-布尔表达式" class="headerlink" title="4. 布尔表达式"></a>4. 布尔表达式</h3><ol>
<li><p>“与”和“或”运算符(<code>&amp;&amp;</code>, <code>||</code>)</p>
</li>
<li><p>“不等于”运算符(<code>!=</code>和<code>!</code>)</p>
</li>
<li><p>短运算符(<code>&amp;&amp;</code>, <code>||</code>)</p>
<blockquote>
<p>比如<code>&amp;&amp;</code>表达式中，左右两边都为<code>true</code>这个表达式才为<code>true</code>。因此<code>Java</code>虚拟机发现左方表达式为<code>false</code>时不需要也不会计算右边表达式。<code>||</code>类似。基于这样的性质可以避免调用内容为<code>null</code>的引用变量：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (refVar != <span class="keyword">null</span> &amp;&amp; refVar.isValidType() ) &#123;</span><br><span class="line"> <span class="comment">// do ‘got a valid type’ stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>长运算符(<code>&amp;</code>, <code>|</code>)</p>
<p><code>&amp;</code>和 <code>|</code>运算符通常用于位运算，Java虚拟机会计算运算符两边的算式。</p>
</li>
</ol>
<h3 id="5-使用库函数-Java-API"><a href="#5-使用库函数-Java-API" class="headerlink" title="5. 使用库函数(Java API)"></a>5. 使用库函数(<code>Java API</code>)</h3><h4 id="5-1-库函数的使用"><a href="#5-1-库函数的使用" class="headerlink" title="5.1 库函数的使用"></a>5.1 库函数的使用</h4><p>在<code>Java API</code>中，类是包装在<code>包</code>中的。要使用<code>API</code>中的类，必须直到它在哪个包中。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/apiPakage.PNG" alt="在`Java API`中，类被包装在`包`中"></p>
<p>必须指明程序代码中所使用到的类的完整名称。(<strong>除了<code>java.lang</code>之外</strong>)</p>
<blockquote>
<p>比如<code>ArrayList</code>的完整名称应该是：<code>java.util.ArrayList</code></p>
</blockquote>
<p>主要有两种方法可以指定使用的是哪一个<code>ArrayList</code>：</p>
<ol>
<li><p><code>Import</code></p>
<p>在程序源文件最前面放上<code>import</code>述句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;... &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>Type</code></p>
<p>直接在程序代码中打出全名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line">java.util.ArrayList&lt;Dog&gt; list = <span class="keyword">new</span> java.util.ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用参数</span></span><br><span class="line">java.util.ArrayList&lt;Dog&gt; list = <span class="keyword">new</span> java.util.ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型</span></span><br><span class="line"><span class="keyword">public</span> java.util.<span class="function">ArrayList&lt;Dog&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><code>java.lang</code>是个预先被引用的包，因为<code>java.lang</code>是经常会被用到的基础包，所有可以不必指定名称。比如<code>java.lang.String</code>与<code>java.lang.System</code>都不需要<code>import</code>或写全名。</p>
</blockquote>
<h4 id="5-2-关于javax开头的包中x的含义"><a href="#5-2-关于javax开头的包中x的含义" class="headerlink" title="5.2 关于javax开头的包中x的含义"></a>5.2 关于<code>javax</code>开头的包中<code>x</code>的含义</h4><p><code>javax</code>作为开头的包是指标准版的扩展函数库。后来纳入到标准库中后，为了保持程序的兼容性，故而沿用了<code>javax</code>这一命名。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/javaxHistory.PNG" alt="`javax`中`x`的由来"></p>
<h4 id="5-3-如何查阅API"><a href="#5-3-如何查阅API" class="headerlink" title="5.3 如何查阅API"></a>5.3 如何查阅<code>API</code></h4><p>使用函数库必须知道：</p>
<ol>
<li>库中有哪些类</li>
<li>这些类是做什么的</li>
</ol>
<p>主要方法是：</p>
<ol>
<li>查阅参考书</li>
<li>查阅HTML API文档</li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--1 基础概念</title>
    <url>/2021/01/09/JavaLearning_Head_First_Java_1_basic_concepts.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>重新开始学习Java，同时为找工作开始做准备，加油。从《Head First Java》开始吧！<br><a id="more"></a></p>
</blockquote>
<h3 id="1-Java的工作方式"><a href="#1-Java的工作方式" class="headerlink" title="1. Java的工作方式"></a>1. Java的工作方式</h3><p>基于Java写出应用程序并在任意设备上运行主要分为4步：</p>
<blockquote>
<ol>
<li>源代码。编写源码文件</li>
<li>编译器。用编译器运行源代码，检查错误</li>
<li>输出。编译器对源码编译输出字节文件，编译后的<code>字节文件与平台无关</code></li>
<li>Java虚拟机。Java虚拟机可以读取及执行字节文件</li>
</ol>
</blockquote>
<h3 id="2-Java的程序结构"><a href="#2-Java的程序结构" class="headerlink" title="2. Java的程序结构"></a>2. Java的程序结构</h3><p>类存在于源文件里，方法存在于类中，语句存在于方法中。<br><img src="https://github.com/wwwwwyj/image_repository/blob/master/img/blog/JavaLearning/HeadFirstJava/JavaProgramStructure.PNG?raw=true" alt="Java程序结构"></p>
<h4 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h4><p>源文件(<code>.java</code>)带有类定义，类用于表示程序的一个组件。</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>类带有一个或多个方法。<br><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JavaClassStructure.PNG" alt="Java类的结构"></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>在方法中包含需要执行的指令，方法由一组语句组成，可以当作一个函数或过程。</p>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a><code>Tips</code></h4><h5 id="Java中integer与boolean不兼容"><a href="#Java中integer与boolean不兼容" class="headerlink" title="Java中integer与boolean不兼容"></a>Java中integer与boolean不兼容</h5><p>Java中integer与boolean不兼容，所以int类型不能用作条件，如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Java中执行会报错，需要将其修改为boolean类型变量来实现相同功能：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isHot = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (isHot) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--1 走近Java</title>
    <url>/2021/04/23/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_1_Approaching_Java.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><code>世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。</code><br><a id="more"></a></p>
</blockquote>
<h4 id="1-Java技术体系"><a href="#1-Java技术体系" class="headerlink" title="1. Java技术体系"></a>1. Java技术体系</h4><p><code>JCP(Java Community Process)</code>所定义的Java技术体系包括了以下几个组成部分：</p>
<ul>
<li>Java程序设计语言</li>
<li>各种硬件平台上的Java虚拟机实现</li>
<li>Class文件格式</li>
<li>Java类库API</li>
<li>来自商业机构和开源社区的第三方Java类库</li>
</ul>
<p><code>JDK(Java Development Kit)</code>是用于支持Java程序开发的最小环境，主要分为三部分：</p>
<ul>
<li>Java程序设计语言</li>
<li>Java虚拟机</li>
<li>Java类库</li>
</ul>
<p><code>JRE(Java Runtime Environment)</code>是支持Java程序运行的标准环境，主要包括：</p>
<ul>
<li>Java SE API子集</li>
<li>Java虚拟机</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Java_technology_system.PNG" alt="Java技术体系"></p>
<p>按照技术关注的重点业务来划分，可以分为以下四条主要的产品线：</p>
<ul>
<li><strong>Java Card</strong>：支持Java小程序（Applets）运行在<strong><code>小内存设备（如智能卡）</code></strong>上的平台。</li>
<li><strong>Java ME（Micro Edition）</strong>：支持Java程序运行在<strong><code>移动终端（手机、PDA）</code></strong>上的平台，对Java API 有所精简，并加入了移动终端的针对性支持，这条产品线在JDK 6以前被称为<code>J2ME</code>。</li>
<li><strong>Java SE（Standard Edition）</strong>：支持面向<strong><code>桌面级应用（如Windows下的应用程序）</code></strong>的Java平台，提 供了完整的Java核心API，这条产品线在JDK 6以前被称为<code>J2SE</code>。</li>
<li><strong>Java EE（Enterprise Edition）</strong>：支持<strong><code>使用多层架构的企业应用（如ERP、MIS、CRM应用）</code></strong>的 Java平台，除了提供Java SE API外，还对其做了大量有针对性的扩充，并提供了相关的部署支持， 这条产品线在JDK 6以前被称为<code>J2EE</code>；在JDK 10以后被Oracle放弃，捐献给Eclipse基金会管理，此后被 称为<code>Jakarta EE</code>。(PS:扩展一般以<code>javax.*</code>作为包名，而以<code>java.*</code>为包名的包都是Java SE API的核心包。一部分曾经是扩展包的API后来进入了核心包中，因此核心包中也包含了不少<code>javax.*</code>开头的包名)</li>
</ul>
<h4 id="2-Java虚拟机家族"><a href="#2-Java虚拟机家族" class="headerlink" title="2. Java虚拟机家族"></a>2. Java虚拟机家族</h4><h5 id="2-1-虚拟机始祖：Sun-Classic-Exact-VM"><a href="#2-1-虚拟机始祖：Sun-Classic-Exact-VM" class="headerlink" title="2.1 虚拟机始祖：Sun Classic/Exact VM"></a>2.1 虚拟机始祖：Sun Classic/Exact VM</h5><p><code>Classic VM</code>只能使用<strong>纯解释器方式</strong>来执行Java代码，如果要使用<strong>即时编译器</strong>就必须进行外挂，但是假如外挂了即时编译器的话，即时编译器就会完全接管虚拟机的执行系统，解释器便不能再工作了。由于解释器和编译器不能配合工作，这就意味着<code>如果要使用编译执行，编译器就不得不对每一个方法、每一行代码都进行编译，而无论它们执行的频率是否具有编译的价值</code>。</p>
<p><code>Exact VM</code>因它使用<code>准确式内存管理</code>（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management）而得名。准确式内存管理是指<code>虚拟机可以知道内存中某个位置的数据具体是什么类型</code>。已经具备现代高性能虚拟机雏形，如热点探测、两级即时编译器、编译器与解释器混合工作模式等。</p>
<h5 id="2-2-武林盟主：HotSpot-VM"><a href="#2-2-武林盟主：HotSpot-VM" class="headerlink" title="2.2 武林盟主：HotSpot VM"></a>2.2 武林盟主：HotSpot VM</h5><p><code>HotSpot VM</code>是Sun/OracleJDK和OpenJDK中的默认Java虚拟机，也是目前<em>使用范围最广</em>的Java虚拟机。</p>
<blockquote>
<p>它是由一家名为<code>“Longview Technologies”</code>的小公司设计；甚至这个虚拟机最初<em>并非是为Java语言而研发的</em>，它来源于<code>Strongtalk虚拟机</code>，而这款虚拟机中相当多的技术又是来源于一款为<em>支持Self语言</em>实现“达到C语言50%以上的执行效率”的目标而设计的Self虚拟机， 最终甚至可以追溯到20世纪80年代中期开发的<code>Berkeley Smalltalk</code>上。</p>
</blockquote>
<p>它名称中的HotSpot指的就是它的<code>热点代码探测技术</code>。</p>
<blockquote>
<p>HotSpot虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器<strong>以方法为单位进行编译</strong>。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发<code>标准即时编译和栈上替换编译（On-Stack Replacement，OSR）行为</code>。</p>
</blockquote>
<h5 id="2-3-小家碧玉：Mobile-Embedded-VM"><a href="#2-3-小家碧玉：Mobile-Embedded-VM" class="headerlink" title="2.3 小家碧玉：Mobile/Embedded VM"></a>2.3 小家碧玉：Mobile/Embedded VM</h5><p>面对移动和嵌入式市场，在Java ME这条产品线上的虚拟机名为CDC-HI（C Virtual Machine， CVM）和CLDC-HI（Monty VM）。</p>
<blockquote>
<p>CDC/CLDC全称是<code>Connected（Limited）Device Configuration</code>，HI则是<code>HotSpot Implementation</code>的缩写，但它们并不是由HotSpot直接裁剪而来，只是借鉴过其中一些技术，并没有血缘关系，充其量能叫有所渊源。</p>
</blockquote>
<h5 id="2-4-天下第二：BEA-JRockit-IBM-J9-VM"><a href="#2-4-天下第二：BEA-JRockit-IBM-J9-VM" class="headerlink" title="2.4 天下第二：BEA JRockit/IBM J9 VM"></a>2.4 天下第二：BEA JRockit/IBM J9 VM</h5><p>BEA System公司的<code>JRockit</code>与 IBM公司的<code>IBM J9</code>曾经与HotSpot并称<strong>“三大商业Java虚拟机”</strong>。</p>
<p>JRockit虚拟机曾经号称是“世界上速度最快的Java虚拟机”，BEA将其发展为一款<strong>专门为服务器硬件和服务端应用场景高度优化的虚拟机</strong>，由于专注于服务端应用，它可以不太关注于程序启动速度，因此JRockit内部<em>不包含解释器实现</em>，全部代码都靠<code>即时编译器编译后执行</code>。JRockit的<strong>垃圾收集器</strong>和<strong>Java Mission Control故障处理套件</strong>等部分的实现，在当时众多的Java虚拟机中也处于领先水平。</p>
<p>IBM J9虚拟机机最初是由IBM Ottawa实验室的一个<code>SmallTalk虚拟机</code>项目扩展而来。IBM J9虚拟机的市场定位与HotSpot比较接近，它是一款在<em>设计上全面考虑服务端、桌面应用，再到嵌入式的多用途虚拟机</em>。</p>
<blockquote>
<p>IBM J9虚拟机的<code>职责分离与模块化</code>做得比HotSpot更优秀，由J9 虚拟机中抽象封装出来的核心组件库（包括垃圾收集器、即时编译器、诊断监控子系统等）就单独构成了IBM OMR项目</p>
</blockquote>
<h5 id="2-5-软硬合璧：BEA-Liquid-VM-Azul-VM"><a href="#2-5-软硬合璧：BEA-Liquid-VM-Azul-VM" class="headerlink" title="2.5 软硬合璧：BEA Liquid VM/Azul VM"></a>2.5 软硬合璧：BEA Liquid VM/Azul VM</h5><p>一类<strong>与特定硬件平台绑定、软硬件配合工作的专有虚拟机</strong>，往往能够实现更高的执行性能，或提供某些特殊的功能特性。</p>
<blockquote>
<p>Liquid VM也被称为JRockit VE(Virtual Edition，VE)，BEA公司开发的可以直接运行在自家 Hypervisor系统上的JRockit虚拟机的虚拟化版本。Liquid VM不需要操作系统的支持，或者说<strong>它自己本身实现了一个专用操作系统的必要功能</strong>。</p>
<p>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的<strong>专有硬件Vega系统</strong>上的Java虚拟机。</p>
<p>Zing虚拟机(Azul Systems公司研发)是一个从HotSpot某旧版代码分支基础上独立出来重新开发的高性能Java虚拟机。在要求低延迟、快速预热等场景中，Zing VM都要比HotSpot表现得更好。Zing的PGC、 C4收集器可以轻易支持TB级别的Java堆内存，而且保证暂停时间仍然可以维持在不超过10毫秒的范围里。</p>
</blockquote>
<h5 id="2-6-挑战者：Apache-Harmony-Google-Android-Dalvik-VM"><a href="#2-6-挑战者：Apache-Harmony-Google-Android-Dalvik-VM" class="headerlink" title="2.6 挑战者：Apache Harmony/Google Android Dalvik VM"></a>2.6 挑战者：Apache Harmony/Google Android Dalvik VM</h5><p>Harmony虚拟机（准确地说是Harmony里的DRLVM）和Dalvik虚拟机<code>只能称作“虚拟 机”，而不能称作“Java虚拟机”</code>。</p>
<h5 id="2-7-没有成功，但并非失败：Microsoft-JVM及其他"><a href="#2-7-没有成功，但并非失败：Microsoft-JVM及其他" class="headerlink" title="2.7 没有成功，但并非失败：Microsoft JVM及其他"></a>2.7 没有成功，但并非失败：Microsoft JVM及其他</h5><p>微软为了在Internet Explorer 3浏览器中支持Java Applets应用而开发了自己的Java虚拟机，</p>
<h5 id="2-8-百家争鸣"><a href="#2-8-百家争鸣" class="headerlink" title="2.8 百家争鸣"></a>2.8 百家争鸣</h5><p>一些Java虚拟机是单纯为了用于生产，甚至在设计之初就仅仅是用于研究、验证某种技术和观点，又或者是作为一些规范的标准实现：</p>
<blockquote>
<ul>
<li>KVM。KVM中的K是“Kilobyte”的意思，它强调简单、轻量、高度可移植，但是运行速度比较慢。主要用于手机平台。</li>
<li>Java Card VM。JCVM必须精简到能放入智能卡、SIM卡、银行信用卡、借记卡内。</li>
<li>Squawk VM。运行于Sun SPOT（Sun Small Programmable Object Tech-nology，一种手持的Wi-Fi设备），也曾经运用于Java Card。</li>
<li>JavaInJava。试图以Java语言来实现Java语言本身的运行环境，既所谓的“元循环”（Meta-Circular，是指使用语言自身来实现其运行环境）虚拟机。</li>
<li>Maxine VM。也是一个几乎全部以Java代码实现（只有用于启动 Java虚拟机的加载器使用C语言编写）的元循环Java虚拟机。</li>
<li>Jikes RVM。是IBM开发的专门用来研究Java虚拟机实现技术的项目，也是一个元循环虚拟机。</li>
<li>IKVM.NET。基于微软.NET框架实现的Java虚拟机，并借助Mono获得一定的跨平台能力。</li>
</ul>
</blockquote>
<h4 id="3-实战：自己编译JDK"><a href="#3-实战：自己编译JDK" class="headerlink" title="3. 实战：自己编译JDK"></a>3. 实战：自己编译JDK</h4><h5 id="3-1-OpenJDK和OracleJDK"><a href="#3-1-OpenJDK和OracleJDK" class="headerlink" title="3.1 OpenJDK和OracleJDK"></a>3.1 OpenJDK和OracleJDK</h5><p>OpenJDK和 OracleJDK在程序上是非常接近的，两者共用了绝大部分相同的代码。在JDK 11以前，OracleJDK中还会存在一些OpenJDK没有的、闭源的功能，即OracleJDK 的“商业特性”。许多功能在JDK 11时全部开源到了OpenJDK中。到了这个阶段，已经可以认为OpenJDK与OracleJDK代码实质上已达到完全一致的程度。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OpenJDK_and_OracleJDK.PNG" alt="OpenJDK和 OracleJDK的关系"></p>
<p>OpenJDK内部不同版本之间的关系，按照开发习惯，新的功能或Bug修复通常是在最新分支上进行的，当功能或修复在最新分支上稳定之后会同步到其他老版本的维护分支上。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Relationship_between_OpenJDK_versions.PNG" alt="OpenJDK版本之间的关系"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--8 接口与抽象类</title>
    <url>/2021/05/13/JavaLearning_Head_First_Java_8_interfaces_and_abstract_classes.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>继承只是个开始。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1. 抽象类"></a>1. 抽象类</h3><h4 id="1-1-抽象类"><a href="#1-1-抽象类" class="headerlink" title="1.1 抽象类"></a>1.1 抽象类</h4><p>有些类不应该被初始化。比如如果尝试创建一个<code>Animal</code>对象，很难定义该对象或者说该对象并没有意义(没有一种叫做<code>Animal</code>的动物)。而又需要<code>Animal</code>类来继承和产生多态，需要<strong>限制只有它的子类才能被初始化</strong>。</p>
<p>通过标记类为<code>抽象类</code>，可以告诉编译器这个类不能创建任何类型实例。记让这个类不能被<code>&quot;nwe&quot;</code>出来。设计抽象类只需要在类前加入关键词<code>abstract</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Canie</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roam</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是可以用这种抽象类作为引用类型给多态使用。不是<code>抽象(abstract)</code>的类就被称为<code>具体(concrete)</code>类</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/abstractConcrete.PNG" alt="抽象与具体"></p>
<h4 id="1-2-抽象方法"><a href="#1-2-抽象方法" class="headerlink" title="1.2 抽象方法"></a>1.2 抽象方法</h4><p>方法也可以被标及为<code>abstract</code>。抽象类代表此类必须要被<code>extend</code>，抽象方法代表此方法必须要被覆盖。</p>
<blockquote>
<p><strong>抽象的方法没有实体</strong></p>
</blockquote>
<p>比如一个抽象的方法可以写作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果声明了一个抽象方法，那么这个类也必须被标记为抽象类。</p>
<blockquote>
<p>即<strong>非抽象类不能拥有抽象方法</strong></p>
</blockquote>
<p>抽象方法的意义是<u>就算无法实现出方法的内容，但还是可以定义出一组子类共同的协议</u>。由于抽象方法没有内容，只是为了标记出多态而存在，所以<strong>继承树下的第一个具体类必须要实现出所有的抽象方法</strong>。</p>
<p>一个抽象类继承另一个抽象类，不需要实现其抽象方法。但抽象类可以同时带有抽象和非抽象方法，所以如果有需要，也可以对抽象方法进行实现。</p>
<h4 id="1-3-多态范例"><a href="#1-3-多态范例" class="headerlink" title="1.3 多态范例"></a>1.3 多态范例</h4><p>如果要一个可以保持Dog对象的list，可以写一个专用的list类。但如果Cat也要用同样的方法，如果重新编写一个类似的类过于麻烦。可以利用多态的特点，编写一个<code>AnimalList</code>类来处理<code>Animal</code>的所有子类。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/animalList.PNG" alt="Animal List"></p>
<p>进一步，可以设计处理<code>Animal</code>之上的类，得到更通用、更抽象的类。</p>
<blockquote>
<p>Java中所有类都是从<code>Object</code>这个类继承出来的。<code>Object</code>是所有类的源头，即所有类的父类。</p>
</blockquote>
<p>没有直接继承过其他类的类会隐含地继承<code>Object</code>类。这样一个终极类(<code>ultra-super-megaclass</code>)需要带有一些每个对象都需要的行为。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/ultra-super-megaclass-Object.PNG" alt="终极类`Object`"></p>
<p><code>Object</code>不是一个正式的<code>Java</code>抽象类，也就是说可以创建<code>Object</code>对象。</p>
<blockquote>
<p><code>Object</code>对象的意义主要在于，有时需要一个<u>通用的、轻量化的</u>对象。比如在线程同步中。</p>
</blockquote>
<p><code>Object</code>类的主要目的是：</p>
<ul>
<li>作为多态让方法可以应付多种类型的机制；</li>
<li>提供Java在执行期间对任何对象都需要实现的程序代码。</li>
</ul>
<p>而如果使用<code>Object</code>类型的多态引用会带来一些问题：</p>
<ul>
<li>以<code>Object</code>类型作为引用时，<code>Java</code>会把它当作<code>Object</code>类型的实例，这代表只能调用由<code>Object</code>声明的方法。</li>
<li>任何重<code>ArrayList&lt;Object&gt;</code>取出的东西都会被当作<code>Object</code>类型的引用，也就导致无法复制给原来的类型。</li>
</ul>
<blockquote>
<p>编译器是<u>根据引用类型来判断有那些method可以调用，而不是<code>Object</code>的确实类型</u>。</p>
</blockquote>
<p>对象会带有从父类继承的所有东西。所以无论这个对象实际类型，它也是一个<code>Object</code>实例。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/snowboardObject.PNG" alt="内部`Object`"></p>
<p>但也有办法可以让<code>Object</code>引用恢复成原来的类，那就是使用<code>类型转化</code>。如果确定对象类型，可以直接转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dog d = (Dog) o;</span><br></pre></td></tr></table></figure>
<p>如果无法确定类型，可以使用<code>instanceof</code>来检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">	Dog d = (Dog) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h3><h4 id="2-1-接口"><a href="#2-1-接口" class="headerlink" title="2.1 接口"></a>2.1 接口</h4><p>如果想要修改<code>合约</code>，比如为Dog类加入Pet的方法，而又不影响其他非Pet类的使用，就需要<code>接口</code>。先看看没有<code>接口</code>会遇到的问题，可以用如下方式加入<code>Pet</code>方法进行修改：</p>
<ol>
<li>把<code>Pet</code>方法加入到<code>Animal</code>类中。<ul>
<li><code>优点</code>：所有子类马上继承<code>Pet</code>方法，无需改变子类程序代码。</li>
<li><code>缺点</code>：<code>非Pet</code>类也会继承到<code>Pet</code>方法</li>
</ul>
</li>
<li>把<code>Pet</code>方法加入到<code>Animal</code>类中，但把其设定为抽象的。<ul>
<li><code>优点</code>：<code>非Pet</code>类覆盖方法时，作出合理动作。</li>
<li><code>缺点</code>：所有子类都需要实现<code>Pet</code>方法，耗时。</li>
</ul>
</li>
<li>把方法添加到需要的子类中。<ul>
<li><code>优点</code>：<code>非Pet</code>类无需实现，更灵活。</li>
<li><code>缺点</code>：失去合约保证，且多态无法其作用。</li>
</ul>
</li>
</ol>
<p>真正需要的是：<code>Pet</code>方法只需要在宠物上实现；所有宠物类都有相同的方法定义；可以运用到多态。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/twoSuperClassesAtTop.PNG" alt="继承多个上次父类"></p>
<p>图中的<code>多重继承</code>会有被称为<code>”致命方块”（Deadly Diamond of Death）</code>的问题，而且Java也并不支持这种方式。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/DeadlyDiamondofDeath.PNG" alt="”致命方块”（Deadly Diamond of Death）"></p>
<p>·同名的实例变量和函数会导致冲突，带来更复杂的问题。</p>
<p>Java里使用<code>接口(interface)</code>来解决这一问题，接口把全部方法设为抽象的，所有子类都需要实现其方法。接口定义如下，使用<code>interface</code>代替<code>class</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pet</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>接口实现如下，使用关键字<code>implements</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Canine</span> <span class="keyword">implements</span> <span class="title">Pet</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实现某接口的类<code>必须实现它所有的方法</code>，因为这些方法都是<code>public</code>与<code>abstract</code>的。</p>
</blockquote>
<p>接口主要为<code>多态</code>服务，以接口取代具体的子类或抽象父类作为参数或返回值，<code>可以传入任何有实现该接口的东西</code>。此外，使用接口可以继承超过一个以上的来源。</p>
<blockquote>
<p>不同继承树的类也可以实现相同的接口</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceTreeInterface.PNG" alt="继承树中的接口"></p>
<p>用接口作为多态类型时，对象可以来自任何地方。唯一的条件是<strong>该对象必须是来自有实现此接口的类</strong>。类可以实现多个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Pet</span>, <span class="title">Saveable</span>, <span class="title">Paintable</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>可以把接口理解为<strong>类可以扮演的角色</strong>。</p>
<h4 id="2-2-Super的使用"><a href="#2-2-Super的使用" class="headerlink" title="2.2 Super的使用"></a>2.2 <code>Super</code>的使用</h4><p>如果子类不打算完全覆盖某个父类方法，又需要加入额外动作，可以使用<code>super</code>关键词来调用父类方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">runReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	<span class="comment">// set-up report </span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">printReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">// generic printing</span></span><br><span class="line"> 	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuzzwordsReport</span> <span class="keyword">extends</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">runReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.runReport();  <span class="comment">//调用父类方法</span></span><br><span class="line">		buzzwordCompliance();</span><br><span class="line">		printReport();</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">buzzwordCompliance</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/superClass.PNG" alt="superClass"></p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--17 包、jar存档文件和部署</title>
    <url>/2021/05/19/JavaLearning_Head_First_Java_17_package_jars_and_deployment.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>该放手了。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-部署应用程序"><a href="#1-部署应用程序" class="headerlink" title="1. 部署应用程序"></a>1. 部署应用程序</h3><p>可以有多种部署选择：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/DeploymentOptions.PNG" alt="部署选择"></p>
<p>首先需要将源代码与<code>class</code>文件分离，关键在于结合<code>-d</code>这个编译选项和目录组织的结构。</p>
<blockquote>
<p>将源代码(<code>.java</code>)存储在<code>source</code>目录下，将编译输出的类文件(<code>.class</code>)放入<code>classes</code>目录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/<span class="built_in">source</span></span><br><span class="line">javac -d ../classes MyApp.java</span><br></pre></td></tr></table></figure>
<h4 id="1-1-把程序打包为JAR"><a href="#1-1-把程序打包为JAR" class="headerlink" title="1.1 把程序打包为JAR"></a>1.1 把程序打包为JAR</h4><p><code>JAR</code>即<code>Java ARchive</code>，这种文件是<code>pkzip</code>格式的文件，能把一组类文件包装起来。创建可执行的<code>JAR</code>分为以下步骤：</p>
<ol>
<li><p>确定所有的类文件都在<code>classes</code>目录下；</p>
</li>
<li><p>创建<code>manifest.txt</code>文件描述哪个类带有<code>main()</code>方法，该文件带有下面一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Main-Class: MyApp</span><br></pre></td></tr></table></figure>
<p>此行后面要有换行，该文件放入<code>classes</code>目录</p>
</li>
<li><p>执行<code>jar</code>工具来创建带有<strong>所有类</strong>以及<code>manifest</code>的<code>JAR</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/classes </span><br><span class="line">jar -cvmf manifest.txt app1.jar *.class</span><br><span class="line">OR</span><br><span class="line">jar -cvmf manifest.txt app1.jar MyApp.class</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/makingJAR.PNG" alt="创建JAR"></p>
<p><code>JVM</code>能从<code>JAR</code>中载入类，并调用该类的<code>main()</code>方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar app1.jar</span><br></pre></td></tr></table></figure>
<p>可以用包防止类名称的冲突。<code>Sun</code>建议加上所取得的域名(<code>domain</code>)名称来保证包名称不会重复。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/domainPackageNames.PNG" alt="使用域名的包名称"></p>
<p>需要把类放在与包层次结构相对应的目录结构下：</p>
<ol>
<li><p>选择包名称。</p>
</li>
<li><p>在类中加入包指令。这必须是程序源码的第一个语句，在<code>import</code>之上。每个源文件中只能有一个包指令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.headfirstjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageExercise</span> </span>&#123;</span><br><span class="line">     <span class="comment">// life-altering code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设定相对应的目录结构。按照包层次结构来放置类文件</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/packageHierarchy.PNG" alt="包层次结构"></p>
<ol>
<li><p>编译和执行<code>JAR</code></p>
<ul>
<li><p>加上<code>-d</code>选项来编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">%编译器把输出放到class目录下正确的位置</span><br><span class="line">javac -d ../classes com/headfirstjava/PackageExercise.java</span><br><span class="line"></span><br><span class="line">%编译com.headfirstjava包下所有.java文件</span><br><span class="line">javac -d ../classes com/headfirstjava/*.java</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>执行程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/classes</span><br><span class="line">java com.headfirstjava.PackageExercise</span><br></pre></td></tr></table></figure>
<p>一旦类被包进包中后，就不能使用“简写”名称来调用它，必须在命令栏指定要执行<code>main()</code>的类完整名称。</p>
</li>
</ul>
<p>还可以条列和解压<code>JAR</code>包：</p>
<ul>
<li><p>将<code>JAR</code>内容列出，<code>-tf</code>代表<code>Table File</code>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jar -tf packEx.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压<code>JAR</code>内容，<code>-xf</code>代表<code>eXtract File</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd Skyler</span><br><span class="line">jar -xf packEx.jar</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-2-Java-Web-Start"><a href="#1-2-Java-Web-Start" class="headerlink" title="1.2 Java Web Start"></a>1.2 Java Web Start</h4><p><code>Java Web Start(JWS)</code>可以让用户从浏览器上执行首次启动，一旦程序下载后就可以独立于浏览器执行。</p>
<ul>
<li><code>JWS</code>下载程序时会调用程序的<code>main()</code>，然后用户可以通过<code>JWS helper app</code>启动应用程序而无需回到网页</li>
<li><code>JWS</code>能偶检测服务器上应用程序局部更新，自动下载和整合更新过的程序</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JWS.PNG" alt="Java Web Start工作方式"></p>
<p><code>.jnlp</code>(<code>Java  Network Launch Protocol</code>)文件用于创建JWS应用程序，<code>JWS</code>会读取文件来寻找<code>JAR</code>并启动应用程序，<code>.jnlp</code>是个简单的<code>XML</code>文件。</p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--13 线程安全与锁优化</title>
    <url>/2021/06/07/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_13_Thread_safety_and_lock_optimization.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>首先需要保证并发的正确性，然后在此基础上来实现高效。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1. 线程安全"></a>1. 线程安全</h3><blockquote>
<p><code>“线程安全”</code>是<code>“当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。”</code></p>
</blockquote>
<h4 id="1-1-Java语言中的线程安全"><a href="#1-1-Java语言中的线程安全" class="headerlink" title="1.1 Java语言中的线程安全"></a>1.1 Java语言中的线程安全</h4><p>将Java语言中各种操作共享的数据分为以下五类：<code>不可变</code>、<code>绝对线程安全</code>、<code>相对线程安全</code>、<code>线程兼容</code>和<code>线程对立</code>。</p>
<h5 id="1-1-1-不可变"><a href="#1-1-1-不可变" class="headerlink" title="1.1.1 不可变"></a>1.1.1 不可变</h5><p><code>不可变（Immutable）</code>的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。</p>
<ul>
<li>如果多线程共享的数据是一个<code>基本数据类型</code>，那么只要在定义时使用<code>final</code>关键字修饰它就可以保证它是不可变的。</li>
<li>如果共享数据是一个<code>对象</code>，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。<ul>
<li>Java类库<code>API</code>中<code>不可变</code>的类型，除了<code>String</code>外，常用的还有<code>枚举类型</code>及<code>java.lang.Number</code>的部分子类。</li>
</ul>
</li>
</ul>
<h5 id="1-1-2-绝对线程安全"><a href="#1-1-2-绝对线程安全" class="headerlink" title="1.1.2 绝对线程安全"></a>1.1.2 绝对线程安全</h5><p><code>绝对的线程安全</code>能够完全满足给出的线程安全的定义，但一个类要达到<code>“不管运行时环境如何，调用者都不需要任何额外的同步措施”</code>可能需要付出非常高昂的， 甚至不切实际的代价。</p>
<p>在<code>Java API</code>中标注自己是线程安全的类，大多数都<strong>不是绝对的线程安全</strong>。</p>
<h5 id="1-1-3-相对线程安全"><a href="#1-1-3-相对线程安全" class="headerlink" title="1.1.3 相对线程安全"></a>1.1.3 相对线程安全</h5><p><code>相对线程安全</code>就是通常意义上所讲的线程安全，它需要<u><strong>保证对这个对象单次的操作是线程安全的，在调用的时候不需要进行额外的保障措施</strong></u>，但是对于一些<strong>特定顺序的连续调用</strong>，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>
<h5 id="1-1-4-线程兼容"><a href="#1-1-4-线程兼容" class="headerlink" title="1.1.4 线程兼容"></a>1.1.4 线程兼容</h5><p><code>线程兼容</code>是指<u>对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用</u>。平常说一个类不是线程安全的，通常就是指这种情况。</p>
<h5 id="1-1-5-线程对立"><a href="#1-1-5-线程对立" class="headerlink" title="1.1.5 线程对立"></a>1.1.5 线程对立</h5><p><code>线程对立</code>是指<u>不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码</u>。</p>
<h4 id="1-2-线程安全的实现方法"><a href="#1-2-线程安全的实现方法" class="headerlink" title="1.2 线程安全的实现方法"></a>1.2 线程安全的实现方法</h4><h5 id="1-2-1-互斥同步"><a href="#1-2-1-互斥同步" class="headerlink" title="1.2.1 互斥同步"></a>1.2.1 互斥同步</h5><p><code>互斥同步（Mutual Exclusion &amp; Synchronization）</code>是一种最常见也是最主要的并发正确性保障手段。</p>
<ul>
<li><code>同步</code>是指<u>在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用</u>。</li>
<li><code>互斥</code>是实现同步的一种手段，<code>临界区（Critical Section）</code>、<code>互斥量（Mutex）</code>和<code>信号量（Semaphore）</code>都是常见的互斥实现方式。</li>
</ul>
<p>在<code>Java</code>里面，最基本的互斥同步手段就是<code>synchronized</code>关键字。</p>
<blockquote>
<p><code>synchronized</code>关键字经过<code>Javac</code>编译之后，会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令。这两个字节码指令都需要一个<code>reference</code>类型的参数来指明要锁定和解锁的对象。</p>
<ul>
<li>在执行<code>monitorenter</code>指令时，首先要去尝试获取对象的<code>锁</code>。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把<code>锁的计数器</code>的值增加一</li>
<li>在执行<code>monitorexit</code>指令时会将<code>锁计数器</code>的值减一。一旦计数器的值为零，锁随即就被释放了。</li>
<li>如果获取对象锁失败，那当前线程就应当被<code>阻塞等待</code>，直到请求锁定的对象被持有它的线程释放为止。</li>
</ul>
</blockquote>
<p>两个关于<code>synchronized</code>的直接推论：</p>
<ul>
<li>被<code>synchronized</code>修饰的同步块对<strong>同一条线程</strong>来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li>
<li>被<code>synchronized</code>修饰的同步块在<u>持有锁的线程执行完毕并释放锁之前</u>，会<strong>无条件地阻塞后面其他线程的进入</strong>。这意味着<u>无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁</u>；也<u>无法强制正在等待锁的线程中断等待或超时退出</u>。</li>
</ul>
<p>持有锁是一个<code>重量级（Heavy-Weight）</code>的操作，尤其是对于代码特别简单的同步块，状态转换消耗的时间甚至会比用户代码本身执行的时间还要长。<code>JDK 5</code>起提供了<code>java.util.concurrent.locks.Lock</code>接口，作为另一种全新的互斥同步手段。基于<code>Lock</code>接口，用户能够以<code>非块结构（Non-Block Structured）</code>来实现互斥同步，在<strong>类库层面去实现同步</strong>。</p>
<p><code>重入锁（ReentrantLock）</code>是<code>Lock</code>接口最常见的一种实现，它与<code>synchronized</code>一样是可重入的。主要增加了以下三项高级功能：</p>
<ul>
<li><code>等待可中断</code>：是指<u>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</u>。</li>
<li><code>公平锁</code>：是指<u>多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</u>；而<code>非公平锁</code>则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。<ul>
<li><code>synchronized</code>中的锁是非公平的；</li>
<li><code>ReentrantLock</code>在<strong>默认情况</strong>下也是非公平的，但可以通过构造函数要求使用公平锁。但一旦使用了公平锁，将会导致<code>ReentrantLock</code>的性能急剧下降，会明显影响吞吐量。 </li>
</ul>
</li>
<li><code>锁绑定多个条件</code>：是指<u><strong>一个<code>ReentrantLock</code>对象可以同时绑定多个<code>Condition</code>对象</strong></u>。</li>
</ul>
<h5 id="1-2-2-非阻塞同步"><a href="#1-2-2-非阻塞同步" class="headerlink" title="1.2.2 非阻塞同步"></a>1.2.2 非阻塞同步</h5><p>互斥同步面临的主要问题是进行线程<strong>阻塞</strong>和<strong>唤醒</strong>所带来的性能开销，因此这种同步也被称为<code>阻塞同步（Blocking Synchronization）</code>，互斥同步属于一种<strong>悲观的并发策略</strong>。</p>
<p>另外有一种基于<code>冲突检测</code>的<strong>乐观并发策略</strong>，通俗地说就是<u><strong>不管风险，先进行操作</strong></u>：</p>
<ul>
<li>如果<strong>没有</strong>其他线程争用共享数据，那操作就直接成功；</li>
<li>如果<strong>有</strong>其他线程争用共享数据，产生了冲突，再进行其他的补偿措施，比如不断地重试，直到出现没有竞争的共享数据为止。</li>
</ul>
<p>这种乐观并发策略的实现<strong><u>不再需要把线程阻塞挂起</u></strong>，因此这种同步操作被称为<code>非阻塞同步（Non-Blocking Synchronization）</code>，使用这种措施的代码也常被称为<code>无锁（Lock-Free）编程</code>。</p>
<p>乐观并发策略需要<code>“硬件指令集的发展”</code>，因为要求<code>操作</code>和<code>冲突检测</code>这两个步骤具备<strong>原子性</strong>。硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，这类指令常用的有：</p>
<ul>
<li><code>测试并设置（Test-and-Set）</code>；</li>
<li><code>获取并增加（Fetch-and-Increment）</code>；</li>
<li><code>交换（Swap）</code>；</li>
<li><code>比较并交换（Compare-and-Swap）</code>；</li>
<li><code>加载链接/条件储存（Load-Linked/Store-Conditional）</code>。</li>
</ul>
<h5 id="1-2-3-无同步方案"><a href="#1-2-3-无同步方案" class="headerlink" title="1.2.3 无同步方案"></a>1.2.3 无同步方案</h5><p>同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的：</p>
<ul>
<li><code>可重入代码（Reentrant Code）</code>：这种代码又称<code>纯代码（Pure Code）</code>，是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。<ul>
<li><code>可重入代码</code>有一些共同的特征，例如<u>不依赖全局变量、存储在堆上的数据和公用的系统资源</u>， 用到的状态量都由参数中传入，不调用非可重入的方法等。</li>
<li>如果一个方法的返回结果是<strong>可以预测的</strong>，那它就满足可重入性的要求。</li>
</ul>
</li>
<li><code>线程本地存储（Thread Local Storage）</code>：如果一段代码中所需要的数据必须与其他代码共享，如果能保证这些共享数据的代码在同一个线程中执行，就可以把共享数据的可见范围限制在同一个线程之内，无须同步也能保证线程之间不出现数据争用的问题。</li>
</ul>
<h3 id="2-锁优化"><a href="#2-锁优化" class="headerlink" title="2. 锁优化"></a>2. 锁优化</h3><h4 id="2-1-自旋锁与自适应自旋（Adaptive-Spinning）"><a href="#2-1-自旋锁与自适应自旋（Adaptive-Spinning）" class="headerlink" title="2.1 自旋锁与自适应自旋（Adaptive Spinning）"></a>2.1 自旋锁与自适应自旋（Adaptive Spinning）</h4><p>如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，就可以让后面请求锁的那个线程<code>“稍等一会”</code>，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，只须让线程执行一个<code>忙循环（自旋）</code>，这项技术就是所谓的<code>自旋锁</code>。</p>
<blockquote>
<ul>
<li>自旋等待本身虽然避免了<code>线程切换</code>的开销，但它需要<strong>占用处理器时间</strong>，所以如果锁被占用的时间很短，自旋等待的效果就会非常好；</li>
<li>反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。</li>
</ul>
</blockquote>
<p>自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。引入了<code>自适应的自旋</code>，自旋的时间不再是固定，而是由<u><strong>前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</strong></u>的。</p>
<h4 id="2-2-锁消除（Lock-Elimination）"><a href="#2-2-锁消除（Lock-Elimination）" class="headerlink" title="2.2 锁消除（Lock Elimination）"></a>2.2 锁消除（Lock Elimination）</h4><p>锁消除是指虚<u>拟机即时编译器在运行时，对一些代码要求同步，但是对<strong>被检测到不可能存在共享数据竞争的锁</strong>进行消除</u>。</p>
<blockquote>
<p>锁消除的主要判定依据来源于<code>逃逸分析</code>的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以认为它们是<code>线程私有</code>的。</p>
</blockquote>
<h4 id="2-3-锁粗化（Lock-Coarsening）"><a href="#2-3-锁粗化（Lock-Coarsening）" class="headerlink" title="2.3 锁粗化（Lock Coarsening）"></a>2.3 锁粗化（Lock Coarsening）</h4><p>如果一系列的<code>连续操作</code>都对<strong>同一个对象</strong>反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围<strong><code>扩展（粗化）</code>到整个操作序列的外部</strong>。</p>
<h4 id="2-4-轻量级锁（Lightweight-Locking）"><a href="#2-4-轻量级锁（Lightweight-Locking）" class="headerlink" title="2.4 轻量级锁（Lightweight Locking）"></a>2.4 轻量级锁（Lightweight Locking）</h4><p><code>HotSpot</code>虚拟机的<code>对象头（Object Header）</code>分为两部分：</p>
<ul>
<li>第一部分用于<strong><u>存储对象自身的运行时数据</u></strong>，如<code>哈希码（HashCode）</code>、<code>GC分代年龄（Generational GC Age）</code> 等，官方称为<code>“Mark Word”</code>。这部分是实现轻量级锁和偏向锁的关键。</li>
<li>另一部分用于<u><strong>存储指向方法区对象类型数据的指针</strong></u>，如果是数组对象，还会有一个额外的部分用于存储数组长度。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/HotSpotMarkWord.PNG" alt="HotSpot虚拟机对象头Mark Word"></p>
<p>轻量级锁的工作过程：</p>
<ul>
<li>在代码即将进入同步块的时候，如果此同步对象<strong>没有被锁定</strong>（锁标志位为<code>“01”</code>状态），虚拟机首先将在当前线程的栈帧中建立一个名为<code>锁记录（Lock Record）</code>的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝（即<code>Displaced Mark Word</code>）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/BeforeCAS.PNG" alt="轻量级锁CAS操作之前堆栈与对象的状态"></p>
<ul>
<li>然后，虚拟机将使用<code>CAS</code>操作尝试把对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。<ul>
<li>如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象<code>Mark Word</code>的<code>锁标志位</code>将转变为<code>“00”</code>，表示此对象处于轻量级锁定状态。</li>
<li>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，<ul>
<li>如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行；</li>
<li>否则，就说明这个锁对象已经被其他线程抢占了。</li>
</ul>
</li>
<li>如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要<strong>膨胀为重量级锁</strong>，锁标志的状态值变为<code>“10”</code>，此时<code>Mark Word</code>中存储的就是指向<code>重量级锁（互斥量）</code>的指针，后面等待锁的线程也必须进入阻塞状态。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/AfterCAS.PNG" alt="轻量级锁CAS操作之后堆栈与对象的状态"></p>
<p>轻量级锁的解锁过程也同样是通过<code>CAS</code>操作来进行的：</p>
<ul>
<li>如果对象的<code>Mark Word</code>仍然指向线程的锁记录，那就用<code>CAS</code>操作把对象当前的<code>Mark Word</code>和线程中复制的<code>Displaced Mark Word</code>替换回来。</li>
<li>假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</li>
</ul>
<h4 id="2-5-偏向锁（Biased-Locking）"><a href="#2-5-偏向锁（Biased-Locking）" class="headerlink" title="2.5 偏向锁（Biased Locking）"></a>2.5 偏向锁（Biased Locking）</h4><p>偏向锁的目的是<u><strong>消除数据在无竞争情况下的同步原语</strong></u>， 进一步提高程序的运行性能。</p>
<blockquote>
<p>偏向锁是在无竞争的情况下把整个同步都消除掉，连<code>CAS</code>操作都不去做了。</p>
</blockquote>
<ul>
<li>假设当前虚拟机启用了偏向锁，那么当锁对象<strong>第一次</strong>被线程获取的时候，虚拟机将会把对象头中的<code>标志位</code>设置为<code>“01”</code>、把<code>偏向模式</code>设置为<code>“1”</code>，表示进入<strong>偏向模式</strong>。同时使用<code>CAS</code>操作把获取到这个锁的线程的<code>ID</code>记录在对象的<code>Mark Word</code>之中。如果<code>CAS</code>操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。</li>
<li>一旦出现另外一个线程去尝试获取这个锁的情况，<strong>偏向模式</strong>就<u>马上宣告结束</u>。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为<code>“0”</code>），撤销后标志位恢复到未锁定（标志位为<code>“01”</code>）或轻量级锁定（标志位为<code>“00”</code>）的状态，后续的同步操作就按照轻量级锁那样去执行。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/BiasedLocking.PNG" alt="偏向锁、轻量级锁的状态转化及对象Mark Word的关系"></p>
<ul>
<li>当一个对象已经计算过<code>一致性哈希码</code>后，它就再也无法进入偏向锁状态了；</li>
<li>当一个对象当前正处于<code>偏向锁</code>状态，又收到需要计算其<code>一致性哈希码</code>请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的<code>ObjectMonitor</code>类里有字段可以记录非加锁状态（标志位为<code>“01”</code>）下的<code>Mark Word</code>，其中自然可以存储原来的哈希码。</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--十大遗珠之憾</title>
    <url>/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>什么！有完没完啊？这本书到底还要看多久？<br><a id="more"></a></p>
</blockquote>
<h3 id="1-枚举-又称为枚举类型或Enum"><a href="#1-枚举-又称为枚举类型或Enum" class="headerlink" title="1. 枚举(又称为枚举类型或Enum)"></a>1. 枚举(又称为枚举类型或<code>Enum</code>)</h3><p>枚举类型定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Members &#123; JERRY, BOBBY, PHIL &#125;;</span><br><span class="line"><span class="keyword">public</span> Members selectedBandMember;</span><br><span class="line"></span><br><span class="line"><span class="comment">// later in the code</span></span><br><span class="line"><span class="keyword">if</span> (selectedBandMember == Members.JERRY) &#123;</span><br><span class="line">	<span class="comment">// do JERRY related stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在<code>enum</code>中加入构造函数、方法、变量和特定常量的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HfjEnum</span> </span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> Names &#123;</span><br><span class="line">        <span class="comment">// 传给下方定义构造函数的参数</span></span><br><span class="line">		JERRY(“lead guitar”) &#123; <span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">							<span class="keyword">return</span> “plaintively”; &#125;&#125;,</span><br><span class="line">		BOBBY(“rhythm guitar”) &#123; <span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">							<span class="keyword">return</span> “hoarsely”; &#125;&#125;,</span><br><span class="line">		PHIL(“bass”);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String instrument;</span><br><span class="line"> 		</span><br><span class="line">        <span class="comment">// enum的构造函数，会对每个被声明的enum值执行一次</span></span><br><span class="line">        Names(String instrument) &#123;</span><br><span class="line">            <span class="keyword">this</span>.instrument = instrument;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getInstrument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.instrument;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> “occasionally”;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Names n : Names.values()) &#123;</span><br><span class="line">            System.out.print(n);</span><br><span class="line">            System.out.print(“, instrument: “+ n.getInstrument());</span><br><span class="line">            System.out.println(“, sings: “ + n.sings());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-多维数组"><a href="#2-多维数组" class="headerlink" title="2. 多维数组"></a>2. 多维数组</h3><p>Java中，二维数组实际上是一个<strong><code>数组的数组</code></strong>。</p>
<h3 id="3-String-and-StringBuffer-StringBuilder-Methods"><a href="#3-String-and-StringBuffer-StringBuilder-Methods" class="headerlink" title="3. String and StringBuffer/StringBuilder Methods"></a>3. <code>String</code> and <code>StringBuffer/StringBuilder</code> Methods</h3><p><code>Java 5.0</code>起，应该用<code>StringBuilder</code>取代<code>StringBuffer</code>。<code>StringBuffer/StringBuilder</code> 来操作字符串更有效率。</p>
<h3 id="4-存取权限和存取修饰符"><a href="#4-存取权限和存取修饰符" class="headerlink" title="4. 存取权限和存取修饰符"></a>4. 存取权限和存取修饰符</h3><p><code>Java</code>有4种存取权限等级与3种存取修饰符。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/AccessLevelsModifiers.PNG" alt="存取权限和存取修饰符"></p>
<h3 id="5-Anonymous和Static-Nested-Classes"><a href="#5-Anonymous和Static-Nested-Classes" class="headerlink" title="5. Anonymous和Static Nested Classes"></a>5. <code>Anonymous</code>和<code>Static Nested Classes</code></h3><p><code>静态嵌套类</code>可以不需要外部类的实例就调用，但还是被看作外部类的一个成员，能够存取任何外部类的静态成员(包括私有)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooOuter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarInner</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sayIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(“method of a <span class="keyword">static</span> inner <span class="class"><span class="keyword">class</span>”)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FooOuter.BarInner foo = <span class="keyword">new</span> FooOuter.BarInner();</span><br><span class="line">        foo.sayIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>匿名的内部类</code>，是在需要传入一个实例的地方创建一个类，并把整个类作为参数传进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnon</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line">		JButton button = <span class="keyword">new</span> JButton(“click”);</span><br><span class="line">		frame.getContentPane().add(button);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// button.addActionListener(quitListener);</span></span><br><span class="line">		button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent ev)</span> </span>&#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-连接的调用"><a href="#6-连接的调用" class="headerlink" title="6. 连接的调用"></a>6. 连接的调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"spring"</span>);</span><br><span class="line">sb = sb.delete(<span class="number">3</span>,<span class="number">6</span>).insert(<span class="number">2</span>,<span class="string">"umme"</span>).deleteCharAt(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>第二行程序从左到右执行。如下调用方法可以调用方法又不需要维护一个引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo().go();</span><br></pre></td></tr></table></figure>
<h3 id="7-块区域"><a href="#7-块区域" class="headerlink" title="7. 块区域"></a>7. 块区域</h3><p>区段程序代码通常在方法中，以<code>{}</code>字符来区分。在某个块区域中声明的变量，一旦离开块区域，就超出范围，无法再被使用。</p>
<h3 id="8-断言"><a href="#8-断言" class="headerlink" title="8. 断言"></a>8. 断言</h3><p>断言的使用类似<code>println()</code>，执行时未特别设定，被加入到程序中的<code>assert</code>命令会被Java虚拟机忽略。只有打开断言，才会输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> (height &gt; <span class="number">0</span>); </span><br><span class="line"><span class="comment">// if true, program continues normally</span></span><br><span class="line"><span class="comment">// if false, throw an AssertionError</span></span><br></pre></td></tr></table></figure>
<p>也可以加入信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> (height &gt; <span class="number">0</span>) : <span class="string">"height = "</span> + height + <span class="string">" weight = "</span> + weight;</span><br></pre></td></tr></table></figure>
<h3 id="9-不变性"><a href="#9-不变性" class="headerlink" title="9. 不变性"></a>9. 不变性</h3><p><code>String</code>的不变性，主要为了安全性和节省空间。比如下面的程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = “<span class="number">0</span>”;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">     s = s + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上创建了<code>10</code>个<code>String</code>对象(“0”, “01”, …, “0123456789”)。创建新<code>String</code>时，<code>JVM</code>会把它放在<code>&quot;String Pool&quot;</code>的特殊存储区域，如果已经出现同值的<code>String</code>，JVM不会重复建立<code>String</code>，会引用已经存在的内容。因为<code>String</code>是不变的，引用变量无法改变其他参数变量引用到的同一个<code>String</code>值。</p>
<p><code>包装类</code>也具有不变性。</p>
<h3 id="10-位操作"><a href="#10-位操作" class="headerlink" title="10. 位操作"></a>10. 位操作</h3><ul>
<li>按位非运算：<code>~</code></li>
<li>按位与运算：<code>&amp;</code></li>
<li>按位或运算：<code>|</code></li>
<li>按位异或运算：<code>^</code></li>
<li>右移运算：<code>&gt;&gt;</code></li>
<li>无符号右移：<code>&gt;&gt;&gt;</code>。第一位补<code>0</code>，正负号可能改变。</li>
<li>左移运算符：<code>&lt;&lt;</code></li>
</ul>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--12  Java内存模型与线程</title>
    <url>/2021/06/06/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_12_Java_memory_model_and_threads.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>并发处理是人类压榨计算机运算能力的最有力武器。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-硬件的效率与一致性"><a href="#1-硬件的效率与一致性" class="headerlink" title="1. 硬件的效率与一致性"></a>1. 硬件的效率与一致性</h3><p>绝大多数的运算任务都不可能只靠处理器<code>“计算”</code>就能完成。处理器至少要与内存交互，如<u>读取运算数据</u>、 <u>存储运算结果</u>等，这个I/O操作很难消除（无法仅靠寄存器来完成所有运算任务）。</p>
<p>由于计算机的存储设备与处理器的运算速度有着几个<strong>数量级的差距</strong>，所以现代计算机系统都不得不加入<em>一层</em>或<em>多层</em>读写速度尽可能接近处理器运算速度的<code>高速缓存（Cache）</code>来作为内存与处理器之间的缓冲：</p>
<blockquote>
<p>将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p>
</blockquote>
<p>基于高速缓存的存储交互引入了一个新的问题：<code>缓存一致性（Cache Coherence）</code>。</p>
<blockquote>
<p>在多路处理器系统中，每 个处理器都有自己的高速缓存，而它们又共享同一<code>主内存（Main Memory）</code>，这种系统称为<code>共享内存多核系统（Shared Memory Multiprocessors System）</code>。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的<u><strong>缓存数据不一致</strong></u>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/SharedMemoryMultiprocessorsSystem.PNG" alt="处理器、高速缓存、主内存间的交互关系"></p>
<p>为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有<code>MSI</code>、<code>MESI（Illinois Protocol）</code>、<code>MOSI</code>、 <code>Synapse</code>、<code>Firefly</code>及<code>Dragon Protocol</code>等。</p>
<h3 id="2-Java内存模型"><a href="#2-Java内存模型" class="headerlink" title="2. Java内存模型"></a>2. Java内存模型</h3><p><code>“Java内存模型”</code>（<code>Java Memory Model，JMM</code>）用于<u><strong>屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果</strong></u>。</p>
<h4 id="2-1-主内存与工作内存"><a href="#2-1-主内存与工作内存" class="headerlink" title="2.1 主内存与工作内存"></a>2.1 主内存与工作内存</h4><p>Java内存模型的主要目的是定义程序中各种<code>变量（Variables）</code>的访问规则，即关注在虚拟机中把变量值<u><strong>存储到内存</strong></u>和<u><strong>从内存中取出</strong></u>变量值这样的底层细节。</p>
<blockquote>
<p>此处的变量<strong>包括</strong><u>实例字段</u>、<u>静态字段</u>和<u>构成数组对象的元素</u>，但是<strong>不包括</strong><u>局部变量</u>与<u>方法参数</u>，因为后者是<u><strong>线程私有</strong></u>的，不会被共享，不会存在竞争问题。</p>
</blockquote>
<p>Java内存模型规定了所有的变量都存储在<code>主内存（Main Memory）</code>中，每条线程还有自己的<code>工作内存（Working Memory）</code>，线程的工作内存中保存了被该线程<u><strong>使用的变量的主内存副本</strong></u>，线程对变量的所有操作（读取、赋值等）都<u><strong>必须在工作内存中进行，而不能直接读写主内存中的数据</strong></u>。不同的线程之间也无法直接访问对方工作内存中的变量，<u><strong>线程间变量值的传递均需要通过主内存来完成</strong></u>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaMemoryModel.PNG" alt="线程、主内存、工作内存三者的交互关系"></p>
<h4 id="2-2-内存间交互操作"><a href="#2-2-内存间交互操作" class="headerlink" title="2.2 内存间交互操作"></a>2.2 内存间交互操作</h4><p>关于主内存与工作内存之间具体的交互协议，即一个变量<u>如何从主内存拷贝到工作内存</u>、<u>如何从工作内存同步回主内存</u>这一类的实现细节，Java内存模型中定义了以下8种操作来完成，每一种操作都是原子的、不可再分的：</p>
<ul>
<li><code>lock（锁定）</code>：作用于<strong>主内存</strong>的变量，它<strong>把一个变量标识为一条线程独占的状态</strong>。</li>
<li><code>unlock（解锁）</code>：作用于<strong>主内存</strong>的变量，它<strong>把一个处于锁定状态的变量释放出来</strong>，释放后的变量才可以被其他线程锁定。</li>
<li><code>read（读取）</code>：作用于<strong>主内存</strong>的变量，它<strong>把一个变量的值从主内存传输到线程的工作内存中</strong>，以便随后的<code>load</code>动作使用。</li>
<li><code>load（载入）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把<code>read</code>操作从主内存中得到的变量值放入工作内存的变量副本中</strong>。</li>
<li><code>use（使用）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把工作内存中一个变量的值传递给执行引擎</strong>，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li><code>assign（赋值）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把一个从执行引擎接收的值赋给工作内存的变量</strong>， 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><code>store（存储）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把工作内存中一个变量的值传送到主内存中</strong>，以便随后的<code>write</code>操作使用。</li>
<li><code>write（写入）</code>：作用于<strong>主内存</strong>的变量，它<strong>把<code>store</code>操作从工作内存中得到的变量的值放入主内存的变量中</strong>。</li>
</ul>
<p>Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p>
<ul>
<li>不允许<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它最近的<code>assign</code>操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何<code>assign</code>操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在<strong>主内存</strong>中<code>“诞生”</code>，不允许在工作内存中直接使用一个未被初始化（<code>load</code>或 <code>assign</code>）的变量，换句话说就是对一个变量实施<code>use</code>、<code>store</code>操作之前，必须先执行<code>assign</code>和<code>load</code>操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行<code>lock</code>操作，但<code>lock</code>操作可以被同一条线程重复执行多次，多次执行<code>lock</code>后，只有执行<strong>相同次数</strong>的<code>unlock</code>操作，变量才会被解锁。</li>
<li>如果对一个变量执行<code>lock</code>操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行<code>load</code>或<code>assign</code>操作以初始化变量的值。</li>
<li>如果一个变量事先没有被<code>lock</code>操作锁定，那就不允许对它执行<code>unlock</code>操作，也不允许去<code>unlock</code>一个被<strong>其他线程</strong>锁定的变量。</li>
<li>对一个变量执行<code>unlock</code>操作之前，必须先把此变量同步回主内存中（执行<code>store</code>、<code>write</code>操作）。</li>
</ul>
<p>Java内存模型的操作在最新的<code>JSR-133</code>文档中简化为<code>read</code>、<code>write</code>、<code>lock</code>和<code>unlock</code>四种，但这只是语言描述上的等价化简，Java内存模型的基础设计并未改变。</p>
<h4 id="2-3-对于volatile型变量的特殊规则"><a href="#2-3-对于volatile型变量的特殊规则" class="headerlink" title="2.3 对于volatile型变量的特殊规则"></a>2.3 对于volatile型变量的特殊规则</h4><p>关键字<code>volatile</code>可以说是Java虚拟机提供的<strong>最轻量级</strong>的<code>同步机制</code>，Java内存模型为<code>volatile</code>专门定义了一些特殊的访问规则，当一个变量被定义成<code>volatile</code>之后，它将具备两项特性：</p>
<h5 id="2-3-1-保证此变量对所有线程的可见性"><a href="#2-3-1-保证此变量对所有线程的可见性" class="headerlink" title="2.3.1 保证此变量对所有线程的可见性"></a>2.3.1 保证此变量对所有线程的<code>可见性</code></h5><p>这里的<code>“可见性”</code>是指<u>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</u>。而普通变量的值在线程间传递时均需要通过主内存来完成。</p>
<blockquote>
<p><code>volatile</code>变量依然有工作内存的拷贝，但是由于它<strong><u>特殊的操作顺序性规定</u></strong>，所以看起来如同直接在主内存中读写访问一般。</p>
</blockquote>
<p><code>volatile</code>变量在各个线程的工作内存中是不存在一致性问题的，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile变量自增运算测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码并不会获得期望的结果，而且每次运行程序输出的结果都不一样。用<code>Javap</code>反编译这段代码后发现<code>increase()</code>方法在<code>Class</code>文件中是由4条字节码指令构成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void increase();</span><br><span class="line">Code:</span><br><span class="line">	Stack=2, Locals=0, Args_size=0</span><br><span class="line">	0: getstatic #13; //Field race:I</span><br><span class="line">	3: iconst_1</span><br><span class="line">	4: iadd</span><br><span class="line">	5: putstatic #13; //Field race:I</span><br><span class="line">	8: return</span><br><span class="line">LineNumberTable:</span><br><span class="line">	line 14: 0</span><br><span class="line">	line 15: 8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>并发失败的原因：当<code>getstatic</code>指令把<code>race</code>的值取到<strong>操作栈顶</strong>时，<code>volatile</code>关键字保证了<code>race</code>的值在此时是正确的，但是在执行<code>iconst_1</code>、<code>iadd</code>指令时，其他线程可能已经把<code>race</code>的值改变了，而操作栈顶的值就变成了<strong>过期的数据</strong>，所以<code>putstatic</code>指令执行后就可能把<strong>较小的race值</strong>同步回主内存之中。</p>
</blockquote>
<p>由于<code>volatile</code>变量只能保证可见性，在<strong><u>不符合</u></strong>以下两条规则的运算场景中，仍然要通过加锁来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<h5 id="2-3-2-禁止指令重排序优化"><a href="#2-3-2-禁止指令重排序优化" class="headerlink" title="2.3.2 禁止指令重排序优化"></a>2.3.2 禁止指令重排序优化</h5><p>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而<u>不能保证变量赋值操作的顺序与程序代码中的执行顺序一致</u>，即<code>“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="comment">// 此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">// 模拟读取配置信息，当读取完成后</span></span><br><span class="line"><span class="comment">// 将initialized设置为true,通知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span> (!initialized) &#123;</span><br><span class="line">sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure>
<p>如果定义<code>initialized</code>变量时没有使用<code>volatile</code>修饰，就可能会由于<code>指令重排序的优化</code>，导致位于线程<code>A</code>中最后一条 代码<code>“initialized=true”</code>被提前执行（实际上<code>重排序优化</code>是<strong>机器级</strong>的优化操作），这样在线程<code>B</code>中使用配置信息的代码就可能出现错误。</p>
<p>下面是标准的<code>双锁检测（Double Check Lock，DCL）</code>单例的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有<code>volatile</code>修饰的变量，赋值后多执行了一个<code>“lock addl$0x0，(%esp)”</code>操作，这个操作的作用相当于一个<code>内存屏障</code>（<code>Memory Barrier</code>或<code>Memory Fence</code>，指重排序时不能把后面的指令重排序到内存屏障之前的位置）。</p>
<p><code>“addl$0x0，(%esp)”</code>（把ESP寄存器的值加0）是一个<strong>空操作</strong>。</p>
<blockquote>
<p>之所以用这个空操作而不是空操作专用指令<code>nop</code>，是因为<code>IA32</code>手册规定<code>lock</code>前缀不允许配合<code>nop</code>指令使用。</p>
</blockquote>
<p>它的作用是将本处理器的缓存写入了内存，该写入动作也会引起别的处理器或者别的内核<code>无效化（Invalidate）</code>其缓存。所以通过这样一个空操作，可让前面<code>volatile</code>变量的修改对其他处理器立即可见。</p>
<p>在volatile与锁中选择的<strong>唯一判断依据</strong>仅仅是<u><code>volatile</code>的语义能否满足使用场景的需求</u>。假定<code>T</code>表示一个线程，<code>V</code>和<code>W</code>分别表示两个<code>volatile</code>型变量，那么在进行<code>read</code>、<code>load</code>、<code>use</code>、<code>assign</code>、<code>store</code>和<code>write</code>操作时需要满足如下规则：</p>
<ul>
<li>在<strong>工作内存</strong>中，每次使用<code>V</code>前都必须先从<strong>主内存</strong><u>刷新最新的</u>值，用于保证能看见其他线程对变量V所做的修改。<ul>
<li>只有当线程<code>T</code>对变量<code>V</code>执行的前一个动作是<code>load</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>use</code>动作；</li>
<li>只有当线程<code>T</code>对变量<code>V</code>执行的后一个动作是<code>use</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>load</code>动作。</li>
<li>线程<code>T</code>对变量<code>V</code>的<code>use</code>动作可以认为是和线程<code>T</code>对变量<code>V</code>的<code>load</code>、<code>read</code>动作相关联的，必须连续且一起出现。</li>
</ul>
</li>
<li>在<strong>工作内存</strong>中，每次修改<code>V</code>后都必须<strong>立刻</strong>同步回<strong>主内存</strong>中，用于保证其他线程可以看到自己对变量V所做的修改。<ul>
<li>只有当线程<code>T</code>对变量<code>V</code>执行的前一个动作是<code>assign</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>store</code>动作；</li>
<li>只有当线程<code>T</code>对变量|V执行的后一个动作是<code>store</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>assign</code>动作。</li>
<li>线程<code>T</code>对变量<code>V</code>的<code>assign</code>动作可以认为是和线程<code>T</code>对变量<code>V</code>的<code>store</code>、<code>write</code>动作相关联的，必须连续且一起出现。</li>
</ul>
</li>
<li><code>volatile</code>修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。<ul>
<li>假定动作<code>A</code>是线程<code>T</code>对变量<code>V</code>实施的<code>use</code>或<code>assign</code>动作，假定动作<code>F</code>是和动作<code>A</code>相关联的<code>load</code>或<code>store</code>动 作，假定动作<code>P</code>是和动作<code>F</code>相应的对变量<code>V</code>的<code>read</code>或<code>write</code>动作；</li>
<li>假定动作<code>B</code>是线程<code>T</code>对变量<code>W</code>实施的<code>use</code>或<code>assign</code>动作，假定动作<code>G</code>是和动作<code>B</code>相关联的<code>load</code>或<code>store</code>动作，假定动作<code>Q</code>是和动作<code>G</code>相应的对变量<code>W</code>的<code>read</code>或<code>write</code>动作。</li>
<li><strong>如果<code>A</code>先于<code>B</code>，那么<code>P</code>先于<code>Q</code></strong>。</li>
</ul>
</li>
</ul>
<h4 id="2-4-针对long和double型变量的特殊规则"><a href="#2-4-针对long和double型变量的特殊规则" class="headerlink" title="2.4 针对long和double型变量的特殊规则"></a>2.4 针对long和double型变量的特殊规则</h4><p>Java内存模型要求上述八种操作都具有<code>原子性</code>， 但是对于<code>64</code>位的数据类型（<code>long</code>和<code>double</code>），在模型中特别定义了一条宽松的规定：</p>
<blockquote>
<p>允许虚拟机将<strong>没有</strong>被<code>volatile</code>修饰的<code>64</code>位数据的读写操作划分为两次<code>32</code>位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的<code>load</code>、<code>store</code>、<code>read</code>和<code>write</code>这四个操作的原子性，这就是所谓的<code>“long和double的非原子性协定”（Non-Atomic Treatment of double and long Variables）</code>。</p>
</blockquote>
<p>读取到<code>“半个变量”</code>的情况是非常罕见的，除非该数据有明确可知的线程竞争，否则在编写代码时一般不需要因为这个原因刻意把用到的<code>long</code>和<code>double</code>变量专门声明为<code>volatile</code>。</p>
<h4 id="2-5-原子性、可见性与有序性"><a href="#2-5-原子性、可见性与有序性" class="headerlink" title="2.5 原子性、可见性与有序性"></a>2.5 原子性、可见性与有序性</h4><p>Java内存模型是围绕着在并发过程中如何处理<code>原子性</code>、<code>可见性</code>和<code>有序性</code>这三个特征来建立的。</p>
<h5 id="2-5-1-原子性（Atomicity）"><a href="#2-5-1-原子性（Atomicity）" class="headerlink" title="2.5.1 原子性（Atomicity）"></a>2.5.1 <code>原子性（Atomicity）</code></h5><p>由Java内存模型来<strong>直接保证</strong>的原子性变量操作包括<code>read</code>、<code>load</code>、<code>assign</code>、<code>use</code>、<code>store</code>和<code>write</code>，基本数据类型的<strong>访问</strong>、<strong>读写</strong>都是具备原子性的。</p>
<p>Java内存模型提供了<code>lock</code>和<code>unlock</code>操作来满足更大范围的原子性保证，尽管虚拟机未把<code>lock</code>和<code>unlock</code>操作直接开放给用户使用，但是却提供了更高层次的字节码指令<code>monitorenter</code>和<code>monitorexit</code>来隐式地使用这两个操作。这两个字节码指令反映到Java 代码中就是同步块——<code>synchronized</code>关键字，因此在<code>synchronized</code>块之间的操作也具备原子性。</p>
<h5 id="2-5-2-可见性（Visibility）"><a href="#2-5-2-可见性（Visibility）" class="headerlink" title="2.5.2 可见性（Visibility）"></a>2.5.2 <code>可见性（Visibility）</code></h5><p>可见性就是指<u>当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改</u>。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。</p>
<blockquote>
<p>volatile的特殊规则保证了新值能<strong>立即同步到主内存</strong>，以及每次使用前<strong>立即从主内存刷新</strong>。</p>
</blockquote>
<p>除了<code>volatile</code>之外，<code>synchronized</code>和<code>final</code>两个关键字也能实现可见性。</p>
<ul>
<li><code>synchronized</code>同步块的可见性是由<code>“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”</code>这条规则获得的。</li>
<li><code>final</code>关键字的可见性是指：被<code>final</code>修饰的字段在构造器中一旦被初始化完成，并且构造器没有把<code>“this”</code>的引用传递出去，那么在其他线程中就能看见<code>final</code>字段的值。</li>
</ul>
<h5 id="2-5-3-有序性（Ordering）"><a href="#2-5-3-有序性（Ordering）" class="headerlink" title="2.5.3 有序性（Ordering）"></a>2.5.3 <code>有序性（Ordering）</code></h5><p>Java程序中天然的有序性即：</p>
<ul>
<li>如果在本线程内观察，所有的操作都是有序的，指<code>“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）</code>；</li>
<li>如果在一个线程中观察另一个线程， 所有的操作都是无序的，是指<code>“指令重排序”</code>现象和<code>“工作内存与主内存同步延迟”</code>现象。</li>
</ul>
<p>Java语言提供了<code>volatile</code>和<code>synchronized</code>两个关键字来保证线程之间操作的有序性。</p>
<h4 id="2-6-先行发生原则"><a href="#2-6-先行发生原则" class="headerlink" title="2.6 先行发生原则"></a>2.6 先行发生原则</h4><p>Java语言的<code>“先行发生”（Happens-Before）原则</code>，是判断<u>数据是否存在竞争</u>，<u>线程是否安全</u>的手段。</p>
<blockquote>
<p><code>先行发生</code>是Java内存模型中定义的两项操作之间的<code>偏序关系</code>，比如说<code>操作A</code>先行发生于<code>操作B</code>，其实就是说在发生<code>操作B</code>之前，<code>操作A</code>产生的影响能被<code>操作B</code>观察到，<code>“影响”</code>包括<u>修改了内存中共享变量的值</u>、<u>发送了消息</u>、<u>调用了方法</u>等。</p>
</blockquote>
<p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系<u>无须任何同步器协助就已经存在</u>，可以在编码中直接使用。</p>
<ul>
<li><code>程序次序规则（Program Order Rule）</code>：在一个线程内，按照<strong><u>控制流顺序</u></strong>，书写在前面的操作先行发生于书写在后面的操作。</li>
<li><code>管程锁定规则（Monitor Lock Rule）</code>：一个<code>unlock</code>操作先行发生于后面对<strong>同一个锁</strong>的<code>lock</code>操作。</li>
<li><code>volatile变量规则（Volatile Variable Rule）</code>：对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量 的读操作。</li>
<li><code>线程启动规则（Thread Start Rule）</code>：<code>Thread</code>对象的<code>start()</code>方法先行发生于此线程的每一个动作。</li>
<li><code>线程终止规则（Thread Termination Rule）</code>：线程中的所有操作都先行发生于对此线程的终止检测，可以通过<code>Thread::join()</code>方法是否结束、<code>Thread::isAlive()</code>的返回值等手段检测线程是否已经终止执行。</li>
<li><code>线程中断规则（Thread Interruption Rule）</code>：对线程<code>interrupt()</code>方法的调用先行发生于<u>被中断线程的代码检测到中断事件</u>的发生，可以通过<code>Thread::interrupted()</code>方法检测到是否有中断发生。</li>
<li><code>对象终结规则（Finalizer Rule）</code>：一个对象的初始化完成（构造函数执行结束）先行发生于它的<code>finalize()</code>方法的开始。</li>
<li><code>传递性（Transitivity）</code>：如果<code>操作A</code>先行发生于<code>操作B</code>，<code>操作B</code>先行发生于<code>操作C</code>，那就可以得出<u><code>操作A</code>先行发生于<code>操作C</code></u>的结论。</li>
</ul>
<p><code>时间先后顺序</code>与<code>先行发生原则</code>之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须<u><strong>以先行发生原则为准</strong></u>。</p>
<h3 id="3-Java与线程"><a href="#3-Java与线程" class="headerlink" title="3. Java与线程"></a>3. Java与线程</h3><p>线程是比进程<strong>更轻量级</strong>的<u>调度执行单位</u>，线程可以把一个进程的<code>资源分配</code>和<code>执行调度</code>分开，各个线程既可以<strong>共享进程资源</strong>（内存地址、文件I/O等），又可以<strong>独立调度</strong>。目前线程是Java里面进行处理器资源调度的<strong>最基本单位</strong>。</p>
<h4 id="3-1-线程的实现"><a href="#3-1-线程的实现" class="headerlink" title="3.1 线程的实现"></a>3.1 线程的实现</h4><p>实现线程主要有三种方式：使用<code>内核线程实现（1：1实现）</code>，使用<code>用户线程实现（1：N实现）</code>，使用用户线程加轻量级进程<code>混合实现（N：M实现）</code>。</p>
<h5 id="3-1-1-内核线程实现"><a href="#3-1-1-内核线程实现" class="headerlink" title="3.1.1 内核线程实现"></a>3.1.1 内核线程实现</h5><p><code>内核线程（Kernel-Level Thread，KLT）</code>就是<strong><u>直接由操作系统<code>内核（Kernel）</code>支持的线程</u></strong>。</p>
<blockquote>
<p>这种线程由内核来完成<code>线程切换</code>，内核通过操纵<code>调度器（Scheduler）</code>对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为<code>多线程内核（Multi-Threads Kernel）</code>。</p>
</blockquote>
<p>程序一般<strong>不会直接使用内核线程</strong>，而是使用内核线程的一种高级接口——<code>轻量级进程（Light Weight Process，LWP）</code>，由于每个轻量级进程都由一个内核线程支持，因此<strong>只有先支持内核线程，才能有轻量级进程</strong>。这种轻量级进程与内核线程之间<code>1：1</code>的关系称为一对一的线程模型。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/KernelLevelThread.PNG" alt="内核线程实现"></p>
<ul>
<li>优点：每个轻量级进程都成为一个<code>独立的调度单元</code>，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作。</li>
<li>局限性：<ul>
<li>由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的<strong>代价相对较高</strong>，需要在<code>用户态（User Mode）</code>和<code>内核态（Kernel Mode）</code>中来回切换。</li>
<li>每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要<strong>消耗一定的内核资源</strong>，因此一个系统支持轻量级进程的<strong>数量是有限</strong>的。</li>
</ul>
</li>
</ul>
<h5 id="3-1-2-用户线程实现"><a href="#3-1-2-用户线程实现" class="headerlink" title="3.1.2 用户线程实现"></a>3.1.2 用户线程实现</h5><p><strong>广义上</strong>，一个线程只要不是内核线程，都可以认为是<code>用户线程（User Thread，UT）</code>的一种。</p>
<p><strong>狭义上</strong>，用户线程指的是<strong>完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的</strong>。</p>
<blockquote>
<p>用户线程的建立、同步、销毁和调度完全在<code>用户态</code>中完成，<strong><u>不需要内核的帮助</u></strong>。</p>
</blockquote>
<p>这种进程与用户线程之间<code>1：N</code>的关系称为一对多的线程模型。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/UserThread.PNG" alt="用户线程实现"></p>
<ul>
<li>用优势在于不需要系统内核支援，如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量。</li>
<li>劣势也在于没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理。使用用户线程实现的程序通常都比较复杂，除了有明确的需求外，一般的应用程序都不倾向使用用户线程。但近年来许多以高并发为卖点的编程语言普遍支持了用户线程，譬如<code>Golang</code>、<code>Erlang</code>等。</li>
</ul>
<h5 id="3-1-3-混合实现"><a href="#3-1-3-混合实现" class="headerlink" title="3.1.3 混合实现"></a>3.1.3 混合实现</h5><p>线程除了<code>依赖内核线程实现</code>和<code>完全由用户程序自己实现</code>之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为<code>N：M</code>实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/HybridThread.PNG" alt="混合实现"></p>
<ul>
<li><strong><code>用户线程</code></strong><u>完全建立在用户空间中</u>，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。</li>
<li><strong><code>轻量级进程</code></strong>则作为<strong><code>用户线程</code></strong>和<strong><code>内核线程</code></strong>之间的桥梁， 这样可以<u>使用内核提供的线程调度功能及处理器映射</u>，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。</li>
</ul>
<h4 id="3-2-Java线程调度"><a href="#3-2-Java线程调度" class="headerlink" title="3.2 Java线程调度"></a>3.2 Java线程调度</h4><p>线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种：</p>
<ul>
<li><code>协同式（Cooperative Threads-Scheduling）线程调度</code>，线程的执行时间<u>由线程本身来控制</u>，线程把自己的工作执行完之后主动通知系统切换到另外一个线程上去。<ul>
<li>好处是实现简单，切换操作对线程自己是可知的，一般没有<code>线程同步</code>的问题。</li>
<li>坏处是<u><strong>线程执行时间不可控制</strong></u>，甚至如果线程一直不告知系统进行线程切换，那么程序就会一直阻塞。</li>
</ul>
</li>
<li><code>抢占式（Preemptive Threads-Scheduling）线程调度</code>，每个线程将<u>由系统来分配执行时间</u>，线程的切换不由线程本身来决定。<ul>
<li>好处是线程的<strong>执行时间是系统可控的</strong>，不会有一个线程导致整个进程甚至整个系统阻塞的问题。</li>
</ul>
</li>
</ul>
<p>Java使用的线程调度方式就是抢占式调度。虽然Java线程调度是系统自动完成的，但可以设置<code>线程优先级</code>给操作系统提供调度建议。Java设置了<code>10</code>个级别的线程优先级（<code>Thread.MIN_PRIORITY</code>至<code>Thread.MAX_PRIORITY</code>）。在两个线程同时处于<code>Ready</code>状态时，<strong>优先级越高的线程越容易被系统选择执行</strong>。</p>
<p><code>Windows</code>中就只有<code>七</code>种优先级，比Java线程优先级少，所以会出现几个线程优先级对应到同一个操作系统优先级的情况。</p>
<blockquote>
<p><code>Windows</code>平台的虚拟机中使用了除<code>THREAD_PRIORITY_IDLE</code>之外的其余<code>6</code>种线程优先级，因此在<code>Windows</code>下设置线程优先级为<code>1</code>和<code>2</code>、<code>3</code> 和<code>4</code>、<code>6</code>和<code>7</code>、<code>8</code>和<code>9</code>的效果是<strong>完全相同</strong>的。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/THREAD_PRIORITY.PNG" alt="Java线程优先级与Windows线程优先级之间的对应关系"></p>
<p>线程优先级并不是一项稳定的调节手段，优先级可能会被系统自行改变，所以不能在程序中通过优先级来完全准确判断一组状态都为<code>Ready</code>的线程将会先执行哪一个。</p>
<h4 id="3-3-状态转换"><a href="#3-3-状态转换" class="headerlink" title="3.3 状态转换"></a>3.3 状态转换</h4><p>Java定义了<code>6</code>种线程状态，任意一个时间点中，一个线程<strong>只能有且只有其中的一种状态</strong>，可以通过特定的方法在不同状态之间转换：</p>
<ul>
<li><code>新建（New）</code>：创建后尚未启动的线程处于这种状态。</li>
<li><code>运行（Runnable）</code>：包括操作系统线程状态中的<code>Running</code>和<code>Ready</code>，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。</li>
<li><code>无限期等待（Waiting）</code>：处于这种状态的线程不会被分配处理器执行时间，它们要等待<strong>被其他线程显式唤醒</strong>。以下方法会让线程陷入无限期的等待状态：<ul>
<li>没有设置<code>Timeout</code>参数的<code>Object::wait()</code>方法；</li>
<li>没有设置<code>Timeout</code>参数的<code>Thread::join()</code>方法；</li>
<li><code>LockSupport::park()</code>方法。</li>
</ul>
</li>
<li><code>限期等待（Timed Waiting）</code>：处于这种状态的线程也不会被分配处理器执行时间，不过<strong>无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒</strong>。以下方法会让线程进入限期等待状态：<ul>
<li><code>Thread::sleep()</code>方法；</li>
<li>设置了<code>Timeout</code>参数的<code>Object::wait()</code>方法；</li>
<li>设置了<code>Timeout</code>参数的<code>Thread::join()</code>方法； </li>
<li><code>LockSupport::parkNanos()</code>方法；</li>
<li><code>LockSupport::parkUntil()</code>方法。</li>
</ul>
</li>
<li><code>阻塞（Blocked）</code>：线程被阻塞，<code>“阻塞状态”</code>与<code>“等待状态”</code>的区别是：<ul>
<li><code>“阻塞状态”</code>在等待着获取到一个<code>排它锁</code>，这个事件将在另外一个线程放弃这个锁的时候发生；</li>
<li><code>“等待状态”</code>则是在等待一段时间，或者唤醒动作的发生。</li>
<li>在程序等待进入同步区域的时候，线程将进入这种状态。</li>
</ul>
</li>
<li><code>结束（Terminated）</code>：已终止线程的线程状态，线程已经结束执行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ThreadState.PNG" alt="线程状态转换关系"></p>
<h3 id="4-Java与协程"><a href="#4-Java与协程" class="headerlink" title="4. Java与协程"></a>4. Java与协程</h3><h4 id="4-1-内核线程的局限"><a href="#4-1-内核线程的局限" class="headerlink" title="4.1 内核线程的局限"></a>4.1 内核线程的局限</h4><ul>
<li><code>1：1</code>的内核线程模型是如今Java虚拟机线程实现的<strong>主流选择</strong>，但是天然的缺陷是<strong>切换、调度成本高昂</strong>，系统能<strong>容纳的线程数量也很有限</strong>。现在在每个请求本身的执行时间变得很短、数量变得很多的前提下， 用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费。</li>
<li>传统的<code>Java Web</code>服务器的线程池的容量通常在几十个到两百之间，当以百万计的请求往线程池里面灌时，系统即使能处理得过来，但其中的切换损耗也是相当可观的。</li>
</ul>
<h4 id="4-2-协程的复苏"><a href="#4-2-协程的复苏" class="headerlink" title="4.2 协程的复苏"></a>4.2 协程的复苏</h4><p>内核线程的调度成本主要来自于<strong>用户态与核心态之间的状态转换</strong>，而这两种状态转换的开销主要来自于<strong><code>响应中断</code>、<code>保护</code>和<code>恢复执行现场</code></strong>的成本。</p>
<blockquote>
<p>线程A -&gt; 系统中断 -&gt; 线程B</p>
</blockquote>
<p>当中断发生，从<code>线程A</code>切换到<code>线程B</code>去执行之前，操作系统首先要把<code>线程A</code>的上下文数据妥善保管好，然后把寄存器、内存分页等恢复到<code>线程B</code>挂起时候的状态，这样<code>线程B</code>被重新激活后才能仿佛从来没有被挂起过。这种<code>保护和恢复现场</code>的工 作，免不了涉及一系列数据在各种寄存器、缓存中的来回拷贝，当然不可能是一种轻量级的操作。</p>
<p>最初多数的用户线程是被设计成<code>协同式调度 （Cooperative Scheduling）</code>的，它也被叫做<code>“协程”（Coroutine）</code>。又由于这时候的协程会<u>完整地做调用栈的保护、恢复工作</u>，所以也被称为<code>“有栈协程”（Stackfull Coroutine）</code>。后来又出现比<code>有栈协程</code>恢复调用栈要轻量得多<code>“无栈协程”（Stackless Coroutine）</code>。</p>
<blockquote>
<p>一个协程的栈通常在<code>几百个字节</code>到<code>几KB</code>之间，所以Java虚拟机里线程池容量达到两百就已经不算小了，而很多支持协程的应用中，同时并存的协程数量可<code>以十万</code>计。</p>
</blockquote>
<h4 id="4-3-纤程（Fiber）"><a href="#4-3-纤程（Fiber）" class="headerlink" title="4.3 纤程（Fiber）"></a>4.3 纤程（Fiber）</h4><p>对于有栈协程，有一种特例实现名为<code>纤程（Fiber）</code>。在新并发模型下，一段使用纤程并发的代码会被分为两部分：</p>
<ul>
<li><code>执行过程（Continuation）</code>，主要用于维护执行现场，保护、恢复上下文状态；</li>
<li><code>调度器（Scheduler）</code>，负责编排所有要执行的代码的顺序。</li>
</ul>
<p>将调度程序与执行过程分离的好处是，用户可以选择自行控制其中的一个或者多个，而且Java中现有的调度器也可以被直接重用。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--4 虚拟机性能监控、故障处理工具</title>
    <url>/2021/05/20/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_4_Performance_monitoring_fault_handling.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code><br><a id="more"></a></p>
</blockquote>
<h3 id="1-基础故障处理工具"><a href="#1-基础故障处理工具" class="headerlink" title="1. 基础故障处理工具"></a>1. 基础故障处理工具</h3><p>除了编译和运行Java程序外，打包、部署、签名、调试、监控、运维等各种场景都可能会用到<code>JDK</code>的<code>bin</code>目录下的小工具。根据软件可用性和授权的不同，可以把它们划分成三类：</p>
<ul>
<li><strong>商业授权工具</strong>：主要是<code>JMC（Java Mission Control）</code>及它要使用到的<code>JFR（Java Flight Recorder）</code>；</li>
<li><strong>正式支持工具</strong>：这一类工具属于被长期支持的工具，不同平台、不同版本的<code>JDK</code>之间，这类工具可能会略有差异；</li>
<li><strong>实验性工具</strong>：这一类工具在它们的使用说明中被声明为“<code>没有技术支持，并且是实验性质的</code>”（<code>Unsupported and Experimental</code>）产品。</li>
</ul>
<h4 id="1-1-jps：虚拟机进程状况工具"><a href="#1-1-jps：虚拟机进程状况工具" class="headerlink" title="1.1 jps：虚拟机进程状况工具"></a>1.1 <code>jps</code>：虚拟机进程状况工具</h4><p><code>jps（JVM Process Status Tool）</code>功能和<code>UNIX</code>的<code>ps</code>命令类似：</p>
<blockquote>
<p>可以列出<code>正在运行</code>的虚拟机进程，并显示虚拟机<u><strong>执行主类（Main Class，main()函数所在的类）</strong></u>名称以及这些进程的<code>本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）</code>。</p>
</blockquote>
<p><code>jps</code>命令格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/jps.PNG" alt="jps参数"></p>
<h4 id="1-2-jstat：虚拟机统计信息监视工具"><a href="#1-2-jstat：虚拟机统计信息监视工具" class="headerlink" title="1.2 jstat：虚拟机统计信息监视工具"></a>1.2 <code>jstat</code>：虚拟机统计信息监视工具</h4><p><code>jstat（JVM Statistics Monitoring Tool）</code>是用于监视虚拟机各种运行状态信息的命令行工具。</p>
<blockquote>
<p>可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据</p>
</blockquote>
<h4 id="1-3-jinfo：Java配置信息工具"><a href="#1-3-jinfo：Java配置信息工具" class="headerlink" title="1.3 jinfo：Java配置信息工具"></a>1.3 <code>jinfo</code>：Java配置信息工具</h4><p><code>jinfo（Configuration Info for Java）</code>的作用是实时查看和调整虚拟机各项参数。</p>
<blockquote>
<p>使用<code>jps</code>命令的<code>-v</code>参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用<code>jinfo</code>的<code>-flag</code>选项进行查询了</p>
</blockquote>
<h4 id="1-4-jmap：Java内存映像工具"><a href="#1-4-jmap：Java内存映像工具" class="headerlink" title="1.4 jmap：Java内存映像工具"></a>1.4 <code>jmap</code>：Java内存映像工具</h4><p><code>jmap（Memory Map for Java）</code>命令用于生成<strong>堆转储快照</strong>（一般称为<code>heapdump</code>或<code>dump</code>文件）。</p>
<blockquote>
<p>还可以查询<u><code>finalize</code>执行队列</u>、<u>Java堆</u>和<u>方法区的详细信息</u>，如空间使用率、当前用的是哪种收集器等。</p>
</blockquote>
<h4 id="1-5-jhat：虚拟机堆转储快照分析工具"><a href="#1-5-jhat：虚拟机堆转储快照分析工具" class="headerlink" title="1.5 jhat：虚拟机堆转储快照分析工具"></a>1.5 <code>jhat</code>：虚拟机堆转储快照分析工具</h4><p><code>jhat（JVM Heap Analysis Tool）</code>命令与<code>jmap</code>搭配使用，来分析<code>jmap</code>生成的堆转储快照。</p>
<h4 id="1-6-jstack：Java堆栈跟踪工具"><a href="#1-6-jstack：Java堆栈跟踪工具" class="headerlink" title="1.6 jstack：Java堆栈跟踪工具"></a>1.6 <code>jstack</code>：Java堆栈跟踪工具</h4><p><code>jstack（Stack Trace for Java）</code>命令用于生成虚拟机当前时刻的线程快照（一般称为<code>threaddump</code>或者<code>javacore</code>文件）。</p>
<blockquote>
<p>线程快照就是当前虚拟机内每一条线程正在执行的<strong>方法堆栈</strong>的集合，生成线程快照的目的通常是<u>定位线程出现长时间停顿的原因</u>，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。</p>
</blockquote>
<h4 id="1-7-基础工具总结"><a href="#1-7-基础工具总结" class="headerlink" title="1.7 基础工具总结"></a>1.7 基础工具总结</h4><ul>
<li><strong>基础工具</strong>：用于支持基本的程序创建和运行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/basicJavaTools.PNG" alt="基础工具"></p>
<ul>
<li><strong>安全</strong>：用于程序签名、设置安全测试等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/securityJavaTools.PNG" alt="安全工具"></p>
<p>还有许多工具，就不一一列举了，需要的时候在查找学习就行。</p>
<h3 id="2-可视化故障处理工具"><a href="#2-可视化故障处理工具" class="headerlink" title="2. 可视化故障处理工具"></a>2. 可视化故障处理工具</h3><p>这类工具主要包括<code>JConsole</code>、 <code>JHSDB</code>、<code>VisualVM</code>和<code>JMC</code>四个。</p>
<h4 id="2-1-JHSDB：基于服务性代理的调试工具"><a href="#2-1-JHSDB：基于服务性代理的调试工具" class="headerlink" title="2.1  JHSDB：基于服务性代理的调试工具"></a>2.1  <code>JHSDB</code>：基于服务性代理的调试工具</h4><p><code>JHSDB</code>是一款基于<code>服务性代理（Serviceability Agent，SA）</code>实现的进程外调试工具。服务性代理是<code>HotSpot</code>虚拟机中一组用于映射<code>Java</code>虚拟机运行信息的、主要基于<code>Java</code>语言（含少量<code>JNI</code>代码）实现的<code>API</code>集合。</p>
<p>通过服务性代理的<code>API</code>，可以在一个独立的Java虚拟机的进程里分析其他<code>HotSpot</code>虚拟机的内部数据，或者从<code>HotSpot</code>虚拟机进程内存中<code>dump</code>出来的转储快照里还原出它的运行状态细节。</p>
<h4 id="2-2-JConsole：Java监视与管理控制台"><a href="#2-2-JConsole：Java监视与管理控制台" class="headerlink" title="2.2 JConsole：Java监视与管理控制台"></a>2.2 <code>JConsole</code>：Java监视与管理控制台</h4><p><code>JConsole（Java Monitoring and Management Console）</code>是一款基于<code>JMX（Java Manage-ment Extensions）</code>的可视化监视、管理工具。它的主要功能是通过<code>JMX</code>的<code>MBean（Managed Bean）</code>对系统进行信息收集和参数动态调整。</p>
<h4 id="2-3-VisualVM：多合-故障处理工具"><a href="#2-3-VisualVM：多合-故障处理工具" class="headerlink" title="2.3 VisualVM：多合-故障处理工具"></a>2.3 <code>VisualVM</code>：多合-故障处理工具</h4><p><code>VisualVM（All-in-One Java Troubleshooting Tool）</code>是功能最强大的运行监视和故障处理程序之一，除了常规的运行监视、故障处理外，还将提供其他方面的能力，譬如<code>性能分析（Profiling）</code>。</p>
<p><code>VisualVM</code>还有一个很大的<strong>优点</strong>：<u><strong>不需要被监视的程序基于特殊<code>Agent</code>去运行</strong></u>，因此它的通用性很强，对应用程序实际性能的影响也较小，使得它可以直接应用在生产环境中。</p>
<h4 id="2-4-Java-Mission-Control：可持续在线的监控工具"><a href="#2-4-Java-Mission-Control：可持续在线的监控工具" class="headerlink" title="2.4 Java Mission Control：可持续在线的监控工具"></a>2.4 <code>Java Mission Control</code>：可持续在线的监控工具</h4><p><code>JMC</code>最初是<code>BEA</code>公司的产品，选择了由<code>IBM</code>捐赠的<code>Eclipse RCP</code>作为基础框架，更常见的是作为Eclipse的插件来使用。</p>
<p><code>JMC</code>与虚拟机之间同样采取<code>JMX</code>协议进行通信，<code>JMC</code>一方面作为<code>JMX</code>控制台，显示来自虚拟机<code>MBean</code>提供的数据；另一方面作为<code>JFR</code>的分析工具，展示来自<code>JFR</code>的数据。</p>
<h3 id="3-HotSpot虚拟机插件及工具"><a href="#3-HotSpot虚拟机插件及工具" class="headerlink" title="3. HotSpot虚拟机插件及工具"></a>3. <code>HotSpot</code>虚拟机插件及工具</h3><p><code>HotSpot</code>的插件及工具存放在HotSpot源码<code>hotspot/src/share/tools</code>目录下，包括：</p>
<ul>
<li><code>Ideal Graph Visualizer</code>：用于可视化展示<code>C2</code>即时编译器是如何将字节码转化为理想图，然后转化为机器码的。</li>
<li><code>Client Compiler Visualizer</code>：用于查看<code>C1</code>即时编译器生成高级中间表示（<code>HIR</code>），转换成低级中间表示（<code>LIR</code>）和做物理寄存器分配的过程。</li>
<li><code>MakeDeps</code>：帮助处理<code>HotSpot</code>的编译依赖的工具。</li>
<li><code>Project Creator</code>：帮忙生成<code>Visual Studio</code>的<code>.project</code>文件的工具。</li>
<li><code>LogCompilation</code>：将<code>-XX：+LogCompilation</code>输出的日志整理成更容易阅读的格式的工具。</li>
<li><code>HSDIS</code>：即时编译器的反汇编插件。</li>
</ul>
<p><strong><code>HSDIS</code>：<code>JIT</code>生成代码反汇编</strong></p>
<p><code>HSDIS</code>是一个被官方推荐的<code>HotSpot</code>虚拟机即时编译代码的反汇编插件。<code>HSDIS</code>插件的作用是让<code>HotSpot</code>的<code>-XX：+PrintAssembly</code>指令调用它来把即时编译器动态生成的本地代码还原为<u>汇编代码</u>输出，同时还会自动产生大量非常有价值的注释，这样我们就可以通过输出的汇编代码来从最本质的角度分析问题。</p>
<p><code>JITWatch</code>是<code>HSDIS</code>经常搭配使用的可视化的编译日志分析工具，在<code>JITWatch</code>中加载日志后，就可以看到执行期间使用过的各种对象类型和对应调用过的方法。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--10 前端编译与优化</title>
    <url>/2021/06/02/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_10_Front-end_compilation_and_optimization.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>从计算机程序出现的第一天起，对效率的追逐就是程序员天生的坚定信仰，这个过程犹如一场没有终点、永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛车。<br><a id="more"></a></p>
</blockquote>
<p><code>Java</code>有<code>3</code>类编译过程：</p>
<ul>
<li><strong>前端编译器</strong>：<strong>“编译器的前端”</strong>，把<code>*.java</code>文件转变成<code>*.class</code>文件，比如<code>JDK</code>的<code>Javac</code>、<code>Eclipse JDT</code>中的增量式编译器（<code>ECJ</code>）。</li>
<li><strong>即时编译器</strong>：常称<code>JIT编译器</code>（<code>Just In Time Compiler</code>），运行期把字节码转变成本地机器码，比如<code>HotSpot</code>虚拟机的<code>C1</code>、<code>C2</code>编译器，<code>Graal</code>编译器。</li>
<li><strong>提前编译器</strong>：常称<code>AOT编译器</code>（<code>Ahead Of Time Compiler</code>），直接把程序编译成与目标机器指令集相关的二进制代码。<code>JDK</code>的<code>Jaotc</code>、<code>GNU Compiler for the Java（GCJ）</code>、<code>Excelsior JET</code>。</li>
</ul>
<p>Java中即时编译器在运行期的优化过程，支撑了<strong>程序执行效率的不断提升</strong>；而前端编译器在编译期的优化过程，则是支撑着<strong>程序员的编码效率和语言使用者的幸福感的提高</strong>。</p>
<h3 id="1-Javac编译器"><a href="#1-Javac编译器" class="headerlink" title="1. Javac编译器"></a>1. <code>Javac</code>编译器</h3><p><code>Javac</code>编译器不像<code>HotSpot</code>虚拟机那样使用<code>C++</code>语言（包含少量<code>C</code>语言）实现，它本身就是一个由<code>Java</code>语言编写的程序。</p>
<h4 id="1-1-Javac的源码与调试"><a href="#1-1-Javac的源码与调试" class="headerlink" title="1.1 Javac的源码与调试"></a>1.1 <code>Javac</code>的源码与调试</h4><p><code>javac</code>的发展历史：</p>
<ul>
<li><code>JDK 6</code>以前，<code>Javac</code>并不属于标准<code>Java SE API</code>，它实现代码单独存放在<code>tools.jar</code>中。</li>
<li><code>JDK 6</code>发布时通过了<code>JSR 199</code>编译器<code>API</code>的提案，使得<code>Javac</code>编译器的实现代码晋升成为标准Java类库之一，它的源码就改为放在<code>JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac</code>中</li>
<li><code>JDK 9</code>时，整个<code>JDK</code>所有的<code>Java</code>类库都采用模块化进行重构划分，<code>Javac</code>编译器就被挪到了<code>jdk.compiler</code>模块（路径为：<code>JDK_SRC_HOME/src/jdk.compiler/share/classes/com/sun/tools/javac</code>）里面</li>
</ul>
<p>从<code>Javac</code>代码的总体结构来看，编译过程大致可以分为<code>1</code>个准备过程和<code>3</code>个处理过程：</p>
<ol>
<li><strong>准备过程</strong>：初始化插入式注解处理器。</li>
<li><strong>解析与填充符号表过程</strong>，包括：<ul>
<li><strong>词法、语法分析</strong>。将源代码的字符流转变为标记集合，构造出抽象语法树。</li>
<li><strong>填充符号表</strong>。产生符号地址和符号信息。</li>
</ul>
</li>
<li><strong>插入式注解处理器的注解处理过程</strong>：插入式注解处理器的执行阶段。</li>
<li><strong>分析与字节码生成过程</strong>，包括：<ul>
<li><strong>标注检查</strong>。对语法的静态信息进行检查。</li>
<li><strong>数据流及控制流分析</strong>。对程序动态运行过程进行检查。</li>
<li><strong>解语法糖</strong>。将简化代码编写的语法糖还原为原有的形式。</li>
<li><strong>字节码生成</strong>。将前面各个步骤所生成的信息转化成字节码。</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/javacComplierProcess.PNG" alt="Javac的编译过程"></p>
<p>Javac编译动作的入口是<code>com.sun.tools.javac.main.JavaCompiler</code>类:</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/javacComplierCode.PNG" alt="Javac编译过程的主体代码"></p>
<h4 id="1-2-解析与填充符号表"><a href="#1-2-解析与填充符号表" class="headerlink" title="1.2 解析与填充符号表"></a>1.2 解析与填充符号表</h4><p>解析过程包括了<code>词法分析</code>和<code>语法分析</code>两个步骤：</p>
<h5 id="1-2-1-词法、语法分析"><a href="#1-2-1-词法、语法分析" class="headerlink" title="1.2.1 词法、语法分析"></a>1.2.1 词法、语法分析</h5><ul>
<li><strong>词法分析</strong>是将源代码的字符流转变为<code>标记（Token）</code>集合的过程，单个字符是<u>程序编写</u>时的最小元素，但标记才是<u>编译</u>时的最小元素。<ul>
<li>词法分析过程由<code>com.sun.tools.javac.parser.Scanner</code>类来实现。</li>
</ul>
</li>
<li><strong>语法分析</strong>是根据标记序列构造抽象语法树的过程，<code>抽象语法树（Abstract Syntax Tree，AST）</code>是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个<code>语法结构（Syntax Construct）</code>，例如<u>包、类型、修饰符、运算符、接口、返回值</u>甚至连<u>代码注释</u>等都可以是一种特定的语法结构。<ul>
<li>语法分析过程由<code>com.sun.tools.javac.parser.Parser</code>类实现的</li>
<li>抽象语法树是以<code>com.sun.tools.javac.tree.JCTree</code> 类表示的。</li>
</ul>
</li>
</ul>
<p>经过词法和语法分析生成语法树以后，编译器就不会再对源码字符流进行操作了，<u><strong>后续的操作都建立在抽象语法树之上</strong></u>。</p>
<h5 id="1-2-2-填充符号表"><a href="#1-2-2-填充符号表" class="headerlink" title="1.2.2 填充符号表"></a>1.2.2 填充符号表</h5><p><code>符号表（Symbol Table）</code>是由一组<u><strong>符号地址</strong></u>和<u><strong>符号信息</strong></u>构成的数据结构。符号表中所登记的信息在编译的不同阶段都要被用到。</p>
<ul>
<li>在语义分析的过程中，符号表所登记的内容将用于语义检查和产生中间代码</li>
<li>在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。</li>
<li>填充符号表的过程由<code>com.sun.tools.javac.comp.Enter</code>类实现。</li>
</ul>
<h4 id="1-3-注解处理器"><a href="#1-3-注解处理器" class="headerlink" title="1.3 注解处理器"></a>1.3 注解处理器</h4><p><code>注解（Annotations）</code>在设计上原本是与普通的Java代码一样，都只会在程序运行期间发挥作用的。但在<code>JDK 6</code>中设计了一组被称为<code>“插入式注解处理器”</code>的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。</p>
<ul>
<li><code>插入式注解处理器</code>可以看作是一组编译器的<strong>插件</strong>，它允许<strong>读取</strong>、<strong>修改</strong>、<strong>添加</strong>抽象语法树中的<strong>任意元素</strong>。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个<code>轮次（Round）</code>。</li>
</ul>
<h4 id="1-4-语义分析与字节码生成"><a href="#1-4-语义分析与字节码生成" class="headerlink" title="1.4 语义分析与字节码生成"></a>1.4 语义分析与字节码生成</h4><p>抽象语法树能够表示一个<code>结构正确</code>的源程序，但无法保证源程序的<code>语义是符合逻辑</code>的。语义分析的主要任务则是<u><strong>对结构上正确的源程序进行上下文相关性质的检查</strong></u>，譬如进行<u>类型检查</u>、<u>控制流检查</u>、<u>数据流检查</u>，等等。</p>
<h5 id="1-4-1-标注检查"><a href="#1-4-1-标注检查" class="headerlink" title="1.4.1 标注检查"></a>1.4.1 标注检查</h5><p>语义分析过程可分为<strong>标注检查</strong>和<strong>数据及控制流分析</strong>两个步骤。</p>
<p>标注检查步骤要检查的内容包括诸如<u>变量使用前是否已被声明</u>、<u>变量与赋值之间的数据类型是否能够匹配</u>，等等。还会顺便进行一个称为<code>常量折叠（Constant Folding）</code>的代码优化。</p>
<h5 id="1-4-2-数据及控制流分析"><a href="#1-4-2-数据及控制流分析" class="headerlink" title="1.4.2 数据及控制流分析"></a>1.4.2 数据及控制流分析</h5><p><code>数据流分析</code>和<code>控制流分析</code>是对程序上下文逻辑更进一步的验证，它可以检查出诸如<u>程序局部变量在使用前是否有赋值</u>、<u>方法的每条路径是否都有返回值</u>、<u>是否所有的受查异常都被正确处理</u>等问题。</p>
<h5 id="1-4-3-解语法糖"><a href="#1-4-3-解语法糖" class="headerlink" title="1.4.3 解语法糖"></a>1.4.3 解语法糖</h5><p><code>语法糖（Syntactic Sugar）</code>，也称<code>糖衣语法</code>，指的是在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响， 但是却能更方便程序员使用该语言。通常来说使用语法糖能够<em>减少代码量、增加程序的可读性</em>。</p>
<p>Java中最常见的语法糖包括了<strong><u>泛型</u></strong>、<u><strong>变长参数</strong></u>、<strong><u>自动装箱拆箱</u></strong>，等等，它们在编译阶段被还原回原始的基础语法结构，这个过程就称为<code>解语法糖</code>。</p>
<h5 id="1-4-4-字节码生成"><a href="#1-4-4-字节码生成" class="headerlink" title="1.4.4 字节码生成"></a>1.4.4 字节码生成</h5><p>字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了<u>少量的代码添加和转换工作</u>。</p>
<ul>
<li>实例构造器<code>&lt;init&gt;()</code>方法和类构造器<code>&lt;clinit&gt;()</code>方法就是在这个阶段被添加到语法树之中的。</li>
</ul>
<p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交到<code>com.sun.tools.javac.jvm.ClassWriter</code>类手上，由这个类的<code>writeClass()</code>方法输出字节码，生成最终的Class 文件。</p>
<h3 id="2-Java语法糖的味道"><a href="#2-Java语法糖的味道" class="headerlink" title="2. Java语法糖的味道"></a>2. Java语法糖的味道</h3><p>语法糖虽然不会提供实质性的功能改进，但是它们或能提高效率，或能提升语法的严谨性，或能减少编码出错的机会。</p>
<h4 id="2-1-泛型"><a href="#2-1-泛型" class="headerlink" title="2.1 泛型"></a>2.1 泛型</h4><p><code>泛型</code>的本质是<code>参数化类型（Parameterized Type）</code>或者<code>参数化多态（Parametric Polymorphism）</code>的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。</p>
<h5 id="2-1-1-Java与C-的泛型"><a href="#2-1-1-Java与C-的泛型" class="headerlink" title="2.1.1 Java与C#的泛型"></a>2.1.1 Java与C#的泛型</h5><p><code>Java</code>选择的泛型实现方式叫作<code>“类型擦除式泛型”（Type Erasure Generics）</code>，而<code>C#</code>选择的泛型实现方式是<code>“具现化式泛型”（Reified Generics）</code>。</p>
<ul>
<li><code>C#</code>里面泛型无论在程序源码里面、编译后的中间语言表示（<code>Intermediate Language</code>）里面，抑或是运行期的<code>CLR</code>里面都是切实存在的，有着自己独立的虚方法表和类型数据。</li>
<li><code>Java</code>语言中的泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的<code>裸类型（Raw Type）</code>，并且在相应的地方插入了强制转型代码。<ul>
<li>对于运行期的Java语言来说，<code>ArrayList&lt;int&gt;</code>与<code>ArrayList&lt;String&gt;</code>其实是同一个类型。</li>
</ul>
</li>
</ul>
<p>Java的类型<code>擦除式泛型</code>无论在使用效果上还是运行效率上，几乎是全面落后于<code>C#</code>的<code>具现化式泛型</code>，而它的<u><strong>唯一优势</strong></u>是：</p>
<blockquote>
<p><code>擦除式泛型</code>的实现几乎只需要在<code>Javac</code>编译器上做出改进即可，不需要改动字节码、不需要改动Java虚拟机，也保证了以前没有使用泛型的库可以直接运行在Java 5.0之上。</p>
</blockquote>
<h5 id="2-1-2-类型擦除"><a href="#2-1-2-类型擦除" class="headerlink" title="2.1.2 类型擦除"></a>2.1.2 类型擦除</h5><p>为了保证以前编译出来的<code>Class</code>文件可以在<code>Java 5.0</code>引入泛型之后继续运行，大体上有两条路可以选择：</p>
<ol>
<li>需要泛型化的类型（主要是容器类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型。</li>
<li>直接把已有的类型泛型化，即让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。</li>
</ol>
<p>Java选择了<u><strong>直接把已有的类型泛型化</strong></u>，譬如<code>ArrayList</code>原地泛型化后变成了<code>ArrayList&lt;T&gt;</code>。要保证以前直接用<code>ArrayList</code>的代码在泛型新版本里必须还能继续用这同一个容器，这就必须让所有泛型化的实例类型全部自动成为<code>ArrayList</code>的子类型才能可以，否则类型转换就是不安全的。由此就引出了<code>“裸类型”（Raw Type）</code>的概念。</p>
<blockquote>
<p><code>裸类型</code>应被视为所有该类型泛型化实例的<code>共同父类型（Super Type）</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ilist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; slist = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList list; <span class="comment">// 裸类型</span></span><br><span class="line">list = ilist;</span><br><span class="line">list = slist;</span><br></pre></td></tr></table></figure>
<p>如何实现裸类型又有两种选择：</p>
<ol>
<li>在运行期由<code>Java</code>虚拟机来自动地、真实地构造出<code>ArrayList&lt;Integer&gt;</code>这样的类型，并且自动实现从<code>ArrayList&lt;Integer&gt;</code>派生自<code>ArrayList</code>的继承关系来满足裸类型的定义；</li>
<li>简单粗暴地直接在编译时把<code>ArrayList&lt;Integer&gt;</code>还原回<code>ArrayList</code>，只在<u>元素访问</u>、<u>修改</u>时自动插入一些<u>强制类型转换和检查指令</u>。</li>
</ol>
<p>显然Java选择了后一种实现方式。可以看一个<code>Java</code>泛型擦除的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型擦除前的例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">    map.put(<span class="string">"how are you?"</span>, <span class="string">"吃了没？"</span>);</span><br><span class="line">    System.out.println(map.get(<span class="string">"hello"</span>));</span><br><span class="line">    System.out.println(map.get(<span class="string">"how are you?"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型擦除后的例子</span></span><br><span class="line"><span class="comment"> * 上一段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译的结果</span></span><br><span class="line"><span class="comment"> * 泛型类型都变回了裸类型，只在元素访问时插入了从Object到String的强制转型代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">    map.put(<span class="string">"how are you?"</span>, <span class="string">"吃了没？"</span>);</span><br><span class="line">    System.out.println((String) map.get(<span class="string">"hello"</span>));</span><br><span class="line">    System.out.println((String) map.get(<span class="string">"how are you?"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型擦除带来的缺陷：</p>
<ol>
<li><p>使用擦除法实现泛型直接导致了对<code>原始类型（Primitive Types）</code>数据的支持又成了新的麻烦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原始类型的泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ArrayList&lt;<span class="keyword">int</span>&gt; ilist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">ArrayList&lt;<span class="keyword">long</span>&gt; llist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line">ArrayList list;</span><br><span class="line">list = ilist;</span><br><span class="line">list = llist;</span><br></pre></td></tr></table></figure>
<p>由于Java不支持<code>int</code>、<code>long</code>与<code>Object</code>之间的强制转型，所以泛型擦除后在需要插入强制转型代码的地方就无法进行了。Java给出的解决方案简单粗暴：</p>
<blockquote>
<p>不支持原生类型的泛型，使用<code>ArrayList&lt;Integer&gt;</code>、<code>ArrayList&lt;Long&gt;</code>，遇到原生类型时自动装箱、拆箱。</p>
</blockquote>
</li>
<li><p>运行期无法取到泛型类型信息，会让一些代码变得相当啰嗦</p>
<p><code>Java</code>不支持如下泛型的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeErasureGenerics</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (item <span class="keyword">instanceof</span> E) &#123; <span class="comment">// 不合法，无法对泛型进行实例判断</span></span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		E newItem = <span class="keyword">new</span> E(); <span class="comment">// 不合法，无法使用泛型创建对象</span></span><br><span class="line">		E[] itemArray = <span class="keyword">new</span> E[<span class="number">10</span>]; <span class="comment">// 不合法，无法使用泛型创建数组</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些限制都是由于<u><strong>运行期Java虚拟机无法取得泛型类型</strong></u>而导致的，要实现类似操作，需要写一个泛型版本的从<code>List</code>到数组的转换方法，由于不能从<code>List</code>中取得参数化类型<code>T</code>，所以不得不从一个额外参数中再传入一个数组的组件类型进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] convert(List&lt;T&gt; list, Class&lt;T&gt; componentType) &#123;</span><br><span class="line">	T[] array = (T[])Array.newInstance(componentType, list.size());</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>丧失了一些面向对象思想应有的优雅，带来了一些模棱两可的模糊状况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"invoke method(List&lt;String&gt; list)"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"invoke method(List&lt;Integer&gt; list)"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为参数<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>编译之后都被擦除了，变成了同一种的裸类型<code>List</code>，类型擦除导致这两个方法的特征签名变得一模一样，无法重载。</p>
</li>
</ol>
<h5 id="2-1-3-值类型与未来的泛型"><a href="#2-1-3-值类型与未来的泛型" class="headerlink" title="2.1.3 值类型与未来的泛型"></a>2.1.3 值类型与未来的泛型</h5><p>Oracle建立了一个名为<code>Valhalla</code>的语言改进项目，希望改进Java语言留下的各种缺陷。</p>
<p>在<code>Valhalla</code>项目中规划了几种不同的新泛型实现方案，被称为<code>Model 1</code>到<code>Model 3</code>，泛型类型有可能被：</p>
<ul>
<li><strong>具现化</strong></li>
<li>继续维持<strong>类型擦除以</strong>保持兼容<ul>
<li>泛型的参数化类型也可以选择不被完全地擦除掉，而是相对完整地记录在Class文件中，能够在运行期被使用</li>
<li>也可以指定编译器默认要擦除哪些类型。</li>
</ul>
</li>
</ul>
<p>相对于使用不同方式实现泛型，目前比较明确的是未来的Java应该会提供<code>“值类型”（Value Type）</code>的语言层面的支持。</p>
<blockquote>
<ul>
<li><p><code>值类型</code>可以与<code>引用类型</code>一样，具有<u>构造函数</u>、<u>方法</u>或是<u>属性字段</u>，等等</p>
</li>
<li><p><code>值类型</code>与<code>引用类型</code>的区别在于<u><strong>它在赋值的时候通常是整体复制，而不是像引用类型那样传递引用的</strong></u>。</p>
</li>
<li>值类型的实例很容易实现分配在方法的调用栈上的，值类型可以随着当前方法的退出而自动释放，不会给垃圾收集子系统带来任何压力。</li>
</ul>
</blockquote>
<p>Java的值类型方案被称为<code>“内联类型”</code>，计划通过一个新的关键字<code>inline</code>来定义，字节码层面也有专门与原生类型对应的以<code>Q</code>开头的新的操作码（譬如<code>iload</code>对应<code>qload</code>）来支撑。</p>
<h4 id="2-2-自动装箱、拆箱与遍历循环"><a href="#2-2-自动装箱、拆箱与遍历循环" class="headerlink" title="2.2 自动装箱、拆箱与遍历循环"></a>2.2 自动装箱、拆箱与遍历循环</h4><p><code>自动装箱</code>、<code>自动拆箱</code>与<code>遍历循环</code>（<code>for-each循环</code>）是Java语言里面被使用最多的语法糖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动装箱、拆箱与遍历循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">		sum += i;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动装箱、拆箱与遍历循环编译之后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	List list = Arrays.asList( <span class="keyword">new</span> Integer[] &#123;</span><br><span class="line">		Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">		Integer.valueOf(<span class="number">2</span>),</span><br><span class="line">		Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">		Integer.valueOf(<span class="number">4</span>) &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)localIterator.next()).intValue();</span><br><span class="line">        sum += i;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>自动装箱</code>、<code>拆箱</code>在编译之后被转化成了对应的包装和还原方法，如<code>Integer.valueOf()</code>与<code>Integer.intValue()</code>方法</li>
<li><code>遍历循环</code>则是把代码还原成了迭代器的实现</li>
<li><code>变长参数</code>在调用的时候变成了一个数组类型的参数</li>
</ul>
<p>自动装箱的陷阱</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    Integer b = <span class="number">2</span>;</span><br><span class="line">    Integer c = <span class="number">3</span>;</span><br><span class="line">    Integer d = <span class="number">3</span>;</span><br><span class="line">    Integer e = <span class="number">321</span>;</span><br><span class="line">    Integer f = <span class="number">321</span>;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">    System.out.println(e == f);</span><br><span class="line">    System.out.println(c == (a + b));</span><br><span class="line">    System.out.println(c.equals(a + b));</span><br><span class="line">    System.out.println(g == (a + b));</span><br><span class="line">    System.out.println(g.equals(a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/TrapOfAutoBoxing.PNG" alt="自动装箱的陷阱"></p>
<ul>
<li><p>对于前两个结果，基于<code>==</code>比较，但返回结果不一样，查看Integer内部源码发现，有一个静态内部类的缓存池<code>IntegerCache</code>，缓存范在为<code>-128~127</code>的数，超过这个范围的<code>Integer</code>值都是<code>new</code>出来的新对象。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/IntegerValueOf.PNG" alt="ValueOf"></p>
<ul>
<li>直接使用<code>==</code>比较符，比较的是引用的堆地址，所以<code>c</code>与<code>d</code>都是同一个堆地址，返回<code>true</code>；<code>e</code>和<code>f</code>是创建的两个不同的对象，返回<code>false</code>。从变量表也可以看出来：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/TrapOfAutoBoxingVariable.PNG" alt="变量表"></p>
<ul>
<li><code>Integer</code>缓存了<code>-128~127</code>之间的数，这是在类加载期间就完成的。以后需要的时候直接指向它就可以了，省去了构造对象的开支，提高了效率。</li>
</ul>
</li>
<li><p>包装类的<code>“==”</code>运算在不遇到算术运算的情况下不会自动拆箱，以及它们<code>equals()</code>方法不处理数据转型的关系</p>
</li>
</ul>
<h4 id="2-4-条件编译"><a href="#2-4-条件编译" class="headerlink" title="2.4 条件编译"></a>2.4 条件编译</h4><p>Java语言可以进行条件编译，方法就是使用条件为常量的<code>if</code>语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    	System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   		System.out.println(<span class="string">"block 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反编译结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只能使用条件为常量的<code>if</code>语句才能达到上述效果。根据布尔常量值的真假，编译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段（<code>com.sun.tools.javac.comp.Lower</code>类中）完成。</p>
<blockquote>
<p>条件编译的实现方式使用了<code>if</code>语句，所以它必须遵循最基本的Java语法，只能写在方法体内部，因此它只能实现语句<code>基本块（Block）</code>级别的条件编译，而没有办法实现根据条件调整整个Java类的结构。</p>
</blockquote>
<h3 id="3-实战：插入式注解处理器"><a href="#3-实战：插入式注解处理器" class="headerlink" title="3. 实战：插入式注解处理器"></a>3. 实战：插入式注解处理器</h3><h4 id="3-1-实战目标"><a href="#3-1-实战目标" class="headerlink" title="3.1 实战目标"></a>3.1 实战目标</h4><p>使用<code>注解处理器API</code>来编写一款拥有自己编码风格的校验工具：<code>NameCheckProcessor</code>。<code>NameCheckProcessor</code>的目标定为对Java程序命名进行检查，Java程序命名推荐（而不是强制）应当符合下列格式的书写规范：</p>
<ul>
<li><strong>类（或接口）</strong>：符合<u>驼式命名法</u>，<u>首字母大写</u>。</li>
<li><strong>方法</strong>：符合<u>驼式命名法</u>，<u>首字母小写</u>。</li>
<li><strong>字段</strong>：<ul>
<li><strong>类或实例变量</strong>。符合驼式命名法，首字母小写。</li>
<li><strong>常量</strong>。要求<strong>全部由大写字母或下划线</strong>构成，并且<u>第一个字符不能是下划线</u>。</li>
</ul>
</li>
</ul>
<h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><p>实现<code>注解处理器</code>的代码需要继承抽象类<code>javax.annotation.processing.AbstractProcessor</code>。</p>
<ul>
<li>这个抽象类中只有一个子类必须实现的抽象方法：<code>“process()”</code>，它是Javac编译器在执行注解处理器代码时要调用的过程。<ul>
<li>从这个方法的第一个参数<code>“annotations”</code>中获取到此<code>注解处理器</code>所要处理的<code>注解集合</code>。</li>
<li>从第二个参数<code>“roundEnv”</code>中访问到当前这个<code>轮次（Round）</code>中的抽象语法树节点，每个语法树节点在这里都表示为一个<code>Element</code>。</li>
</ul>
</li>
<li>实例变量<code>“processingEnv”</code>是<code>AbstractProcessor</code>中的一个<code>protected</code>变量，在注解处理器初始化的时候（<code>init()</code>方法执行的时候）创建，继承了<code>AbstractProcessor</code>的注解处理器代码可以直接访问它。它代表了注解处理器框架提供的一个<code>上下文环境</code>，要<u>创建新的代码</u>、<u>向编译器输出信息</u>、<u>获取其他工具类</u>等都需要用到这个实例变量。</li>
<li>还有两个经常配合着使用的注解，分别是：<ul>
<li><code>@SupportedAnnotationTypes</code>，代表了这个注解处理器对哪些注解感兴趣，可以使用星号<code>“*”</code>作为通配符代表对所有的注解都感兴趣</li>
<li><code>@SupportedSourceVersion</code>，指出这个注解处理器可以处理哪些版本的Java代码。</li>
</ul>
</li>
</ul>
<p>如果不需要改变或添加抽象语法树中的内容，<code>process()</code> 方法可以返回<code>false</code>，通知编译器这个轮次中的代码未发生变化，无须构造新的<code>JavaCompiler</code>实例。</p>
<p>注解处理器<code>NameCheckProcessor</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用"*"表示支持所有Annotations</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"*"</span>)</span><br><span class="line"><span class="comment">// 只支持JDK 6的Java代码</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NameChecker nameChecker;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化名称检查插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        nameChecker = <span class="keyword">new</span> NameChecker(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对输入的语法树的各个节点进行名称检查</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!roundEnv.processingOver()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Element element : roundEnv.getRootElements())</span><br><span class="line">                nameChecker.checkNames(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名检查器<code>NameChecker</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.processing.Messager;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.ProcessingEnvironment;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.ElementScanner6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.lang.model.element.ElementKind.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.lang.model.element.Modifier.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.tools.Diagnostic.Kind.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序名称规范的编译器插件：&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 如果程序命名不合规范，将会输出一个编译器的WARNING信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messager messager;</span><br><span class="line"></span><br><span class="line">    NameCheckScanner nameCheckScanner = <span class="keyword">new</span> NameCheckScanner();</span><br><span class="line"></span><br><span class="line">    NameChecker(ProcessingEnvironment processsingEnv) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messager = processsingEnv.getMessager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对Java程序命名进行检查，根据《Java语言规范》第三版第6.8节的要求，Java程序命名应当符合下列格式：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;类或接口：符合驼式命名法，首字母大写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;方法：符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;字段：</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;类、实例变量: 符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;常量: 要求全部大写。</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkNames</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        nameCheckScanner.scan(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称检查器实现类，继承了JDK 6中新提供的ElementScanner6&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 将会以Visitor模式访问抽象语法树中的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckScanner</span> <span class="keyword">extends</span> <span class="title">ElementScanner6</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此方法用于检查Java类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitType</span><span class="params">(TypeElement e, Void p)</span> </span>&#123;</span><br><span class="line">            scan(e.getTypeParameters(), p);</span><br><span class="line">            checkCamelCase(e, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">super</span>.visitType(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查方法命名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitExecutable</span><span class="params">(ExecutableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == METHOD) &#123;</span><br><span class="line">                Name name = e.getSimpleName();</span><br><span class="line">                <span class="keyword">if</span> (name.contentEquals(e.getEnclosingElement().getSimpleName()))</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"一个普通方法 “"</span> + name + <span class="string">"”不应当与类名重复，避免与构造函数产生混淆"</span>, e);</span><br><span class="line">                checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.visitExecutable(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查变量命名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitVariable</span><span class="params">(VariableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果这个Variable是枚举或常量，则按大写命名检查，否则按照驼式命名法规则检查</span></span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == ENUM_CONSTANT || e.getConstantValue() != <span class="keyword">null</span> || heuristicallyConstant(e))</span><br><span class="line">                checkAllCaps(e);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断一个变量是否是常量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">heuristicallyConstant</span><span class="params">(VariableElement e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getEnclosingElement().getKind() == INTERFACE)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e.getKind() == FIELD &amp;&amp; e.getModifiers().containsAll(EnumSet.of(PUBLIC, STATIC, FINAL)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查传入的Element是否符合驼式命名法，如果不符合，则输出警告信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCamelCase</span><span class="params">(Element e, <span class="keyword">boolean</span> initialCaps)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line">            <span class="keyword">boolean</span> previousUpper = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (Character.isUpperCase(firstCodePoint)) &#123;</span><br><span class="line">                previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当以小写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isLowerCase(firstCodePoint)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当以大写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (conventional) &#123;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (Character.isUpperCase(cp)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUpper) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        previousUpper = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!conventional)</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当符合驼式命名法（Camel Case Names）"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 大写命名检查，要求第一个字母必须是大写的英文字母，其余部分可以是下划线或大写字母</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkAllCaps</span><span class="params">(Element e)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isUpperCase(firstCodePoint))</span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (cp == (<span class="keyword">int</span>) <span class="string">'_'</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUnderscore) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        previousUnderscore = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!conventional)</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"常量“"</span> + name + <span class="string">"”应当全部以大写字母或下划线命名，并且以字母开头"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含了多处不规范命名的代码样例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BADLY_NAMED_CODE</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> colors &#123;</span><br><span class="line">        red, blue, green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _FORTY_TWO = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> NOT_A_CONSTANT = _FORTY_TWO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">BADLY_NAMED_CODE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NOTcamelCASEmethodNAME</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>Javac</code>命令的<code>“-processor”</code>参数来执行编译时需要附带的注解处理器，还可以使用<code>-XprintRounds</code>和<code>-XprintProcessorInfo</code>参数来查看注解处理器运作的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac -processor JVMLearning.Complier.NameCheckProcessor JVMLearning\Complier\BADLY_NAMED_CODE.java</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--3 垃圾收集器与内存分配策略</title>
    <url>/2021/05/17/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_3_Garbage_collector_and_memory_allocation_strategy.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code><br><a id="more"></a></p>
</blockquote>
<h3 id="1-对象”已死”？"><a href="#1-对象”已死”？" class="headerlink" title="1. 对象”已死”？"></a>1. 对象”已死”？</h3><p>垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（<code>“死去”即不可能再被任何途径使用的对象</code>）。</p>
<h4 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1 引用计数算法"></a>1.1 引用计数算法</h4><p>在对象中添加一个<code>引用计数器（Reference Counting）</code>，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；<strong>任何时刻计数器为零的对象就是不可能再被使用的</strong>。</p>
<blockquote>
<ul>
<li>占用了一些额外的内存空间来进行计数</li>
<li>原理简单，判定效率也很高</li>
</ul>
</blockquote>
<p>主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作。</p>
<blockquote>
<p>譬如单纯的引用计数就很难解决对象之间<code>相互循环引用</code>的问题。</p>
<ul>
<li>对象<code>objA</code>和<code>objB</code>都有字段<code>instance</code>；</li>
<li>赋值令 <code>objA.instance=objB</code>及<code>objB.instance=objA</code>，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问；</li>
<li>但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。</li>
</ul>
</blockquote>
<p>打印内存回收日志的参数设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails      //打印GC详细信息</span><br><span class="line">-Xms100M    //堆大小100M</span><br><span class="line">-Xmx200M   //堆最大占用内存</span><br><span class="line">-Xmn10M     //新生代 大小 </span><br><span class="line">-XX:SurvivorRatio=8   //Eden:Survivor1:Survivor2 = 8:1:1</span><br><span class="line">-XX:MaxPermSize30M   //永久代内存大小</span><br><span class="line">-XX:MetaspaceSize=30M  //元空间 初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</span><br><span class="line">-XX:MaxMetaspaceSize=300M //最大空间，默认是没有限制的。</span><br></pre></td></tr></table></figure>
<h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h4><p><code>可达性分析（Reachability Analysis）算法</code>的基本思路是：</p>
<blockquote>
<ul>
<li>通过 一系列称为<code>“GC Roots”</code>的根对象作为<strong>起始节点集</strong>，从这些节点开始，根据引用关系向下搜索；</li>
<li>搜索过程所走过的路径称为<code>“引用链”（Reference Chain）</code>，如果某个对象到<code>GC Roots</code>间没有任何引用链相连， 或者用图论的话来说就是从<code>GC Roots</code>到这个对象不可达时，则证明此对象是不可能再被使用的。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Reachability_Analysis.PNG" alt="可达性分析算法"></p>
<p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是使用了可达性分析算法。固定可作为<code>GC Roots</code>的对象包括以下几种：</p>
<ul>
<li>在<code>虚拟机栈（栈帧中的本地变量表）中引用的对象</code>，譬如各个线程被调用的方法堆栈中使用到的<u>参数、局部变量、临时变量</u>等。</li>
<li>在<strong>方法区</strong>中<code>类静态属性引用的对象</code>，譬如Java类的引用类型静态变量。</li>
<li>在<strong>方法区</strong>中<code>常量引用的对象</code>，譬如字符串常量池（String Table）里的引用。</li>
<li>在<code>本地方法栈中JNI</code>（即通常所说的Native方法）引用的对象。</li>
<li><code>Java虚拟机内部的引用</code>，如基本数据类型对应的Class对象，一些常驻的<strong>异常对象</strong>（比如<code>NullPointExcepiton</code>、<code>OutOfMemoryError</code>）等，还有系统类加载器。</li>
<li>所有被<code>同步锁（synchronized关键字）持有的对象</code>。</li>
<li>反映Java虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI中注册的回调</code>、<code>本地代码缓存</code>等。</li>
</ul>
<p>除了这些<strong>固定</strong>的<code>GC Roots</code>集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象<strong>“临时性”</strong>地加入，共同构成完整<code>GC Roots</code>集合。</p>
<h4 id="1-3-引用的分类"><a href="#1-3-引用的分类" class="headerlink" title="1.3 引用的分类"></a>1.3 引用的分类</h4><p>在<code>JDK 1.2</code>版之后，Java对引用的概念进行了扩充，将引用分为<code>强引用（Strongly Re-ference）</code>、<code>软引用（Soft Reference）</code>、<code>弱引用（Weak Reference）</code>和<code>虚引用（Phantom Reference）</code>4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li><p>强引用是指在程序代码之中普遍存在的引用赋值，即类似<code>“Object obj=new Object()”</code>这种引用关系。</p>
<blockquote>
<p>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。`</p>
</blockquote>
</li>
<li><p>软引用是用来描述一些<strong>还有用，但非必须的对象</strong>。</p>
<blockquote>
<ul>
<li>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</li>
<li>在<code>JDK 1.2</code>版之后提供了<code>SoftReference</code>类来实现软引用。</li>
</ul>
</blockquote>
</li>
<li><p>弱引用也是用来描述那些<strong>非必须对象</strong>，但是它的强度比软引用更弱一些。</p>
<blockquote>
<p>被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
<p>在<code>JDK 1.2</code>版之后提供了<code>WeakReference</code>类来实现弱引用。</p>
</blockquote>
</li>
<li><p>虚引用也称为<code>“幽灵引用”</code>或者<code>“幻影引用”</code>，它是最弱的一种引用关系。</p>
<blockquote>
<p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的<u>只是为了能在这个对象被收集器回收时收到一个系统通知</u>。</p>
<p>在<code>JDK 1.2</code>版之后提供 了<code>PhantomReference</code>类来实现虚引用。</p>
</blockquote>
</li>
</ul>
<h4 id="1-4-对象的死亡宣告"><a href="#1-4-对象的死亡宣告" class="headerlink" title="1.4 对象的死亡宣告"></a>1.4 对象的死亡宣告</h4><p>在可达性分析算法中判定为不可达的对象，至少要经历两次标记过程：</p>
<ol>
<li><p>如果对象在进行可达性分析后发现没有与<code>GC Roots</code>相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是<u>此对象是否有必要执行<code>finalize()</code>方法</u>。</p>
<ul>
<li><p>假如对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为<strong>“没有必要执行”</strong>。</p>
</li>
<li><p>如果这个对象被判定为确<strong>有必要执行<code>finalize()</code>方法</strong>，那么该对象将会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条由虚拟机<strong>自动建立的、低调度优先级</strong>的<code>Finalizer</code>线程去执行它们的<code>finalize()</code> 方法。</p>
<ul>
<li><code>“执行”</code>是<u>指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束</u>。</li>
</ul>
</li>
</ul>
</li>
<li><p>稍后收集器将对<code>F-Queue</code>中的对象进行<u>第二次小规模的标记</u>，如果对象要在<code>finalize()</code>中重新与引用链上的任何一个对象建立关联，那在第二次标记时它将被移出“即将回收”的集合。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此代码演示了两点：</span></span><br><span class="line"><span class="comment">* 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment">* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes, i am still alive :)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/FinalizeEscapeGC.PNG" alt="FinalizeEscapeGC运行结果"></p>
<p>代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败了。这是因为<strong>任何一个对象的finalize()方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p>
<blockquote>
<p><code>finalize()</code>是不推荐使用的语法</p>
</blockquote>
<h4 id="1-5-回收方法区"><a href="#1-5-回收方法区" class="headerlink" title="1.5 回收方法区"></a>1.5 回收方法区</h4><p>方法区的垃圾收集主要回收两部分内容：<code>废弃的常量</code>和<code>不再使用的类型</code>。</p>
<ul>
<li>回收废弃常量与回收 Java堆中的对象非常类似。</li>
<li>判定一个类型是否属于<code>“不再被使用的类”</code>需要同时满足下面三个条件：<ul>
<li><strong>该类所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li><strong>加载该类的类加载器已经被回收</strong>，这个条件则通常是很难达成。</li>
<li><strong>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ul>
<h3 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h3><p>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为<code>“引用计数式垃圾收集”（Reference Counting GC）</code>和<code>“追踪式垃圾收集”（Tracing GC）</code>两大类，这两类也常被称作<code>“直接垃圾收集”</code>和<code>“间接垃圾收集”</code>。</p>
<h4 id="2-1-分代收集理论"><a href="#2-1-分代收集理论" class="headerlink" title="2.1 分代收集理论"></a>2.1 分代收集理论</h4><p><code>“分代收集”（Generational Collection）</code>建立在两个分代假说之上：</p>
<ol>
<li><code>弱分代假说（Weak Generational Hypothesis）</code>：绝大多数对象都是朝生夕灭的。</li>
<li><code>强分代假说（Strong Generational Hypothesis）</code>：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
<p>设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（<strong>年龄即对象熬过垃圾收集过程的次数</strong>）分配到不同的区域之中存储。</p>
<blockquote>
<ul>
<li>如果一个区域中大多数对象都是朝生夕灭，那么把它们集中放在一起，每次回收时只关注如何保留少量存活，就能以较低代价回收到大量的空间；</li>
<li>如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域；</li>
<li>同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</li>
</ul>
</blockquote>
<p>设计者一般至少会把Java堆划分为<code>新生代（Young Generation）</code>和<code>老年代（Old Generation）</code>两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p>
<p>假如要现在进行一次只局限于新生代区域内的收集<code>（Minor GC）</code>，但新生代中的对象是完全有可能被老年代所引用的。需要对分代收集理论添加第三条经验法则：</p>
<ol>
<li><code>跨代引用假说（Intergenerational Reference Hypothesis）</code>：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
<p>依据这条假说，只需在新生代上建立一个全局的数据结构（该结构被称为<code>“记忆集”</code>，<code>Remembered Set</code>），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生<code>Minor GC</code>时，只有包含了跨代引用的小块内存里的对象才会被加入到<code>GC Roots</code>进行扫描。</p>
<blockquote>
<ul>
<li><code>部分收集（Partial GC）</code>：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul>
<li><code>新生代收集（Minor GC/Young GC）</code>：指目标只是新生代的垃圾收集。</li>
<li><code>老年代收集（Major GC/Old GC）</code>：指目标只是老年代的垃圾收集。</li>
<li><code>混合收集（Mixed GC）</code>：指目标是收集整个新生代以及部分老年代的垃圾收集。</li>
</ul>
</li>
<li><code>整堆收集（Full GC）</code>：收集整个Java堆和方法区的垃圾收集。</li>
</ul>
</blockquote>
<h4 id="2-2-标记-清除-Mark-Sweep-算法"><a href="#2-2-标记-清除-Mark-Sweep-算法" class="headerlink" title="2.2 标记-清除(Mark-Sweep)算法"></a>2.2 标记-清除(Mark-Sweep)算法</h4><p>算法分为<code>“标记”</code>和<code>“清除”</code>两个阶段：</p>
<ul>
<li>首先标记出所有需要回收的对象；</li>
<li>在标记完成后，统一回收掉所有被标记的对象；</li>
</ul>
<p>也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p>
<blockquote>
<p>主要缺点:</p>
<ol>
<li><strong>执行效率不稳定</strong>，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li>
<li><strong>内存空间的碎片化问题</strong>，标记、清除之后会产生大量不连续的内存碎片。</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Sweep.PNG" alt="“标记-清除”算法"></p>
<h4 id="2-3-标记-复制-Mark-Copying-算法"><a href="#2-3-标记-复制-Mark-Copying-算法" class="headerlink" title="2.3 标记-复制(Mark-Copying)算法"></a>2.3 标记-复制(Mark-Copying)算法</h4><p>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，标记-复制(Mark-Copying)算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。<u>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</u>。</p>
<blockquote>
<p>缺点：</p>
<ul>
<li>如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销；</li>
<li>这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一 点。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Copying.PNG" alt="“标记-复制”算法"></p>
<p><code>Appel式回收</code>(<code>Andrew Appel</code>提出的一种更优化的<code>半区复制分代策略</code>)的具体做法是：</p>
<ul>
<li>把新生代分为一块较大的<code>Eden空间</code>和两块较小的<code>Survivor空间</code>，每次分配内存只使用<code>Eden</code>和其中一块<code>Survivor</code>。</li>
<li>发生垃圾搜集时，将<code>Eden</code>和<code>Survivor</code>中仍然存活的对象一次性复制到另外一块<code>Survivor</code>空间上，然后直接清理掉<code>Eden</code>和已用过的那块<code>Survivor</code>空间。</li>
</ul>
<p><code>HotSpot虚拟机</code>默认<code>Eden</code>和<code>Survivor</code>的大小比例是<code>8∶1</code>，也即每次新生代中可用内存空间为整个新生代容量的<strong>90%</strong>（<code>Eden</code>的<strong>80%</strong>加上一个<code>Survivor</code>的<strong>10%</strong>）。</p>
<blockquote>
<p><code>Appel式回收</code>还有一个充当罕见情况的<code>“逃生门”</code>的安全设计，当<code>Survivor</code>空间不足以容纳一次<code>Minor GC</code>之后存活的对象时，就需要依赖<strong>其他内存区域（实际上大多就是老年代）</strong>进行<code>分配担保（Handle Promotion）</code>。</p>
</blockquote>
<h4 id="2-4-标记-整理-Mark-Compact-算法"><a href="#2-4-标记-整理-Mark-Compact-算法" class="headerlink" title="2.4 标记-整理(Mark-Compact)算法"></a>2.4 标记-整理(Mark-Compact)算法</h4><p><code>“标记-整理”（Mark-Compact）算法</code>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Compact.PNG" alt="“标记-整理”算法"></p>
<p>是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。</p>
<h3 id="3-HotSpot的算法细节实现"><a href="#3-HotSpot的算法细节实现" class="headerlink" title="3. HotSpot的算法细节实现"></a>3. HotSpot的算法细节实现</h3><h4 id="3-1-根节点枚举"><a href="#3-1-根节点枚举" class="headerlink" title="3.1 根节点枚举"></a>3.1 根节点枚举</h4><p>所有收集器在根节点枚举这一步骤时都是<strong>必须暂停用户线程</strong>的，因此毫无疑问根节点枚举与整理内存碎片一样会面临相似的<code>“Stop The World”</code>的困扰。</p>
<p><code>HotSpot</code>使用一组称为<code>OopMap</code>的数据结构直接得到哪些地方存放着对象引用。（<code>普通对象指针（Ordinary Object Pointer，OOP）</code>）</p>
<blockquote>
<ul>
<li>一旦类加载动作完成的时候，就会把对象内什么偏移量上是什么类型的数据计算出来；</li>
<li>在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。</li>
</ul>
</blockquote>
<p>这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等<code>GC Roots</code>开始查找。</p>
<h4 id="3-2-安全点"><a href="#3-2-安全点" class="headerlink" title="3.2 安全点"></a>3.2 安全点</h4><p><code>HotSpot</code>没有为每条指令都生成<code>OopMap</code>，只是在<strong>“特定的位置”</strong>记录了这些信息，这些位置被称为<code>安全点（Safepoint）</code>。有了安全点的设定，强制要求必须执行到达安全点后才能够暂停下来开始垃圾收集。</p>
<blockquote>
<p>安全点位置的选取基本上是以“<code>是否具有让程序长时间执行的特征</code>”，<code>“长时间执行”</code>的最明显特征就是<strong>指令序列的复用</strong>，例如<u>方法调用、循环跳转、异常跳转</u>等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p>
</blockquote>
<p>如何在垃圾收集发生时让所有线程（这里其实<code>不包括执行JNI调用的线程</code>）都跑到最近的安全点，然后停顿下来。</p>
<blockquote>
<p><code>抢先式中断（Preemptive Suspension）</code>在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。</p>
<p><code>主动式中断（Voluntary Suspension）</code>当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一 个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。</p>
</blockquote>
<p><code>HotSpot</code>使用<code>内存保护陷阱</code>的方式，把轮询操作精简至只有一条汇编指令的程度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x01b6d62d: test %eax,0x160100</span><br></pre></td></tr></table></figure>
<p>当需要暂停用户线程时，虚拟机把<code>0x160100</code>的内存页设置为不可读，那线程执行到<code>test</code>指令时就会产生一个<code>自陷异常信号</code>，然后在预先注册的异常处理器中挂起线程实现等待。</p>
<h4 id="3-3-安全区域"><a href="#3-3-安全区域" class="headerlink" title="3.3 安全区域"></a>3.3 安全区域</h4><p><code>安全区域</code>是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。</p>
<blockquote>
<ul>
<li>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。</li>
<li>当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段）:<ul>
<li>如果完成了，那线程就当作没事发生过，继续执行；</li>
<li>否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3-4-记忆集与卡表"><a href="#3-4-记忆集与卡表" class="headerlink" title="3.4 记忆集与卡表"></a>3.4 记忆集与卡表</h4><p><code>记忆集（Remembered Set）</code>是一种用于记录<u>从非收集区域指向收集区域的指针集合</u>的抽象数据结构。实现记忆集的一些可供选择（当然也可以选择这个范围以外的）的记录精度：</p>
<ul>
<li><strong>字长精度</strong>：每个记录精确到一个机器字长，该字包含跨代指针。</li>
<li><strong>对象精度</strong>：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li><strong>卡精度</strong>：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>“卡精度”所指的是用一种称为<code>“卡表”（Card Table）</code>的方式去实现记忆集，字节数组<code>CARD_TABLE</code>的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作<code>“卡页”（Card Page）</code>。</p>
<blockquote>
<p>只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为<code>1</code>，称为这个元素变脏（Dirty），没有则标识为<code>0</code>。</p>
</blockquote>
<h4 id="3-5-写屏障"><a href="#3-5-写屏障" class="headerlink" title="3.5  写屏障"></a>3.5  写屏障</h4><p>卡表元素何时变脏?</p>
<blockquote>
<p>有其他分代区域中对象引用了本区域对象时</p>
</blockquote>
<p>如何变脏?</p>
<blockquote>
<p>在<code>HotSpot</code>虚拟机里是通过<code>写屏障（Write Barrier）</code>技术维护卡表状态的。写屏障可以看作在虚拟机层面对<code>“引用类型字段赋值”</code>这个动作的<code>AOP切面</code></p>
<ul>
<li>在引用对象赋值时会产生一个<code>环形（Around）</code>通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。<ul>
<li>在赋值前的部分的写屏障叫作<code>写前屏障（Pre-Write Barrier）</code>；</li>
<li>在赋值后的则叫作<code>写后屏障（Post-Write Barrier）</code>。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>“伪共享”（False Sharing）问题</strong></p>
<blockquote>
<p>现代中央处理器的缓存系统中是以<code>缓存行（Cache Line）</code>为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低。</p>
<p>为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏</p>
</blockquote>
<h4 id="3-6-并发的可达性分析"><a href="#3-6-并发的可达性分析" class="headerlink" title="3.6 并发的可达性分析"></a>3.6 并发的可达性分析</h4><p>可达性分析的停顿时间与Java堆容量直接成正比例关系，把遍历对象图过程中遇到的对象，按照<strong>“是否访问过”</strong>这个条件标记成以下三种颜色，演示并发出现<strong>“对象消失”</strong>问题：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Object_disappeared.PNG" alt="并发出现“对象消失”问题"></p>
<ul>
<li><strong>白色</strong>：表示对象尚未被垃圾收集器访问过。</li>
<li><strong>黑色</strong>：表示对象已经被垃圾收集器访问过，且这个对象的<u>所有引用都已经扫描过</u>。</li>
<li><strong>灰色</strong>：表示对象已经被垃圾收集器访问过，但这个对象上<u>至少存在一个引用还没有被扫描过</u>。</li>
</ul>
<p>当且仅当以下两个条件同时满足时，会产生“对象消失”的问题：</p>
<blockquote>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
</blockquote>
<p>产生了两种解决方案：</p>
<blockquote>
<ul>
<li><p><code>增量更新（Incremental Update）</code>破坏的是第一个条件。当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</p>
</li>
<li><p><code>原始快照（Snapshot At The Beginning，SATB）</code>破坏的是第二个条件。当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p>
</li>
</ul>
</blockquote>
<h3 id="4-经典垃圾收集器"><a href="#4-经典垃圾收集器" class="headerlink" title="4. 经典垃圾收集器"></a>4. 经典垃圾收集器</h3><p>七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Garbage_collector.PNG" alt="HotSpot虚拟机的垃圾收集器"></p>
<h4 id="4-1-新生代收集器"><a href="#4-1-新生代收集器" class="headerlink" title="4.1 新生代收集器"></a>4.1 新生代收集器</h4><h5 id="4-1-1-Serial收集器"><a href="#4-1-1-Serial收集器" class="headerlink" title="4.1.1 Serial收集器"></a>4.1.1 Serial收集器</h5><p><code>Serial收集器</code>是一个单线程工作的收集器，但它的“单线程”的意义是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/serial_collector.PNG" alt="Serial/Serial Old收集器运行示意图"></p>
<blockquote>
<p>它是所有收集器里<code>额外内存消耗（Memory Footprint）</code>最小的，简单而高效</p>
</blockquote>
<h5 id="4-1-2-ParNew收集器"><a href="#4-1-2-ParNew收集器" class="headerlink" title="4.1.2 ParNew收集器"></a>4.1.2 ParNew收集器</h5><p><code>ParNew收集器</code>实质上是<code>Serial收集器</code>的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为都与Serial收集器完全一致。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ParNew_collector.PNG" alt="ParNew/Serial Old收集器运行示意图l Old收集器运行示意图"></p>
<p>在谈论垃圾收集器的上下文语境中，<code>并行和并发</code>可以理解为：</p>
<ul>
<li><code>并行（Parallel）</code>：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态</li>
<li><code>并发（Concurrent）</code>：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。</li>
</ul>
<h5 id="4-1-3-Parallel-Scavenge收集器"><a href="#4-1-3-Parallel-Scavenge收集器" class="headerlink" title="4.1.3 Parallel Scavenge收集器"></a>4.1.3 Parallel Scavenge收集器</h5><p><code>Parallel Scavenge收集器</code>也是一款<code>新生代收集器</code>，它同样是基于<u>标记-复制算法</u>实现的收集器，也是能够并行收集的多线程收集器。Parallel Scavenge收集器的目标则是达到一个可控制的<code>吞吐量（Throughput）</code>，吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值：</p>
<script type="math/tex; mode=display">
吞吐量 = \frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}</script><p>高吞吐量可以最高效率地利用处理器资源，尽快完成程序的运算任务，<em>主要适合在后台运算而不需要太多交互的分析任务</em>。</p>
<blockquote>
<p><code>自适应的调节策略（GC Ergonomics）</code>让虚拟机根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
</blockquote>
<h4 id="4-2-老年代收集器"><a href="#4-2-老年代收集器" class="headerlink" title="4.2 老年代收集器"></a>4.2 老年代收集器</h4><h5 id="4-2-1-Serial-Old收集器"><a href="#4-2-1-Serial-Old收集器" class="headerlink" title="4.2.1 Serial Old收集器"></a>4.2.1 Serial Old收集器</h5><p><code>Serial Old</code>是Serial收集器的老年代版本，它同样是一个单线程收集器，使用<u>标记-整理算法</u>。</p>
<h5 id="4-2-2-Parallel-Old收集器"><a href="#4-2-2-Parallel-Old收集器" class="headerlink" title="4.2.2 Parallel Old收集器"></a>4.2.2 Parallel Old收集器</h5><p><code>Parallel Old</code>是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于<u>标记-整理算法</u>实现。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Parallel_Old_collector.PNG" alt="ParNew/Serial Old收集器运行示意图"></p>
<blockquote>
<p>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p>
</blockquote>
<h5 id="4-2-3-CMS收集器"><a href="#4-2-3-CMS收集器" class="headerlink" title="4.2.3 CMS收集器"></a>4.2.3 CMS收集器</h5><p><code>CMS（Concurrent Mark Sweep）收集器</code>是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于<u>标记-清除算法</u>实现的，它的运作过程分为四个步骤：</p>
<ol>
<li><code>初始标记（CMS initial mark）</code>。只是标记一下<code>GC Roots</code>能<strong>直接</strong>关联到的对象，速度很快；</li>
<li><code>并发标记（CMS concurrent mark）</code>。从<code>GC Roots</code>的<u>直接关联对象</u>开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</li>
<li><code>重新标记（CMS remark）</code>。修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；</li>
<li><code>并发清除（CMS concurrent sweep）</code>。清理删除掉标记阶段判断的已经死亡的对象。</li>
</ol>
<p>初始标记、重新标记这两个步骤仍然需要<code>“Stop The World”</code>。在整个过程中<em>耗时最长</em>的<code>并发标记</code>和<code>并发清除</code>阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说<code>CMS收集器</code>的内存回收过程是与用户线程一起<strong>并发执行</strong>的。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Concurrent_Mark_Sweep.PNG" alt="Concurrent Mark Sweep收集器运行示意图"></p>
<blockquote>
<p>优点：并发收集、低停顿。也称之为<code>“并发低停顿收集器”（Concurrent Low Pause Collector）</code>。</p>
<p>缺点：</p>
<ul>
<li>CMS收集器对<code>处理器资源</code>非常敏感。</li>
<li>由于CMS收集器无法处理<code>“浮动垃圾”（Floating Garbage）</code>，有可能出现<code>“Con-current Mode Failure”</code>失败进而导致另一次完全<code>“Stop The World”</code>的<code>Full GC</code>的产生。<ul>
<li><code>“浮动垃圾”</code>：在CMS的<code>并发标记</code>和<code>并发清理</code>阶段，用户线程运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。</li>
<li><code>“并发失败”（Concurrent Mode Failure）</code>：CMS运行期间预留的内存无法满足程序分配新对象的需要。虚拟机将不得不启动<code>后备预案</code>：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集。</li>
</ul>
</li>
<li>CMS是一款基于“标记-清除”算法实现的收集器，收集结束时会有大量<code>空间碎片</code>产生。</li>
</ul>
</blockquote>
<h4 id="4-3-Garbage-First收集器"><a href="#4-3-Garbage-First收集器" class="headerlink" title="4.3 Garbage First收集器"></a>4.3 Garbage First收集器</h4><p><code>Garbage First（简称G1）收集器</code>开创了收集器<code>面向局部收集</code>的设计思路和<code>基于Region的内存布局</code>形式，也被Oracle官方称为<code>“全功能的垃圾收集器”（Fully-Featured Garbage Collector）</code>。</p>
<blockquote>
<p><code>“停顿时间模型”（Pause Prediction Model）</code>是能够支持指定在一个长度为<strong>M毫秒</strong>的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。</p>
</blockquote>
<p><code>G1</code>面向堆内存任何部分来组成<code>回收集（Collection Set，一般简称CSet）</code>进行回收，衡量标准是<u>哪块内存中存放的垃圾数量最多，回收收益最大</u>。这就是G1收集器的<code>Mixed GC模式</code>。</p>
<h5 id="4-3-1-基于Region的堆内存布局"><a href="#4-3-1-基于Region的堆内存布局" class="headerlink" title="4.3.1 基于Region的堆内存布局"></a>4.3.1 基于Region的堆内存布局</h5><p>G1不再坚持固定大小以及固定数量的分代区域划分，而是<u>把连续的Java堆划分为多个大小相等的<code>独立区域（Region）</code></u>，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理。</p>
<blockquote>
<p>Region中一类特殊的<code>Humongous区域</code>，专门用来存储大对象。只要大小超过了一个 Region容量一半的对象即可判定为大对象。</p>
</blockquote>
<h5 id="4-3-2-面向局部收集"><a href="#4-3-2-面向局部收集" class="headerlink" title="4.3.2 面向局部收集"></a>4.3.2 面向局部收集</h5><p>G1中新生代和老年代不再是固定的了，它们都是一系列区域（<strong>不需要连续</strong>）的<code>动态集合</code>。将Region作为单次回收的最小单元，可以有计划地避免<u>在整个Java堆中进行全区域的垃圾收集</u>。G1收集器跟踪各个Region里面的垃圾堆积的“价值”大小：</p>
<blockquote>
<p>价值即回收所获得的空间大小以及回收所需时间的经验值</p>
</blockquote>
<p>在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region。(“Garbage First”名字的由来)</p>
<h5 id="4-3-3-关键的细节问题"><a href="#4-3-3-关键的细节问题" class="headerlink" title="4.3.3 关键的细节问题"></a>4.3.3 关键的细节问题</h5><ul>
<li><u>将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？</u>使用记忆集避免全堆作为GC Roots扫描。G1的记忆集在存储结构的<u>本质上是一 种哈希表</u>，<code>Key</code>是别的Region的起始地址，<code>Value</code>是一个集合，里面存储的元素是卡表的索引号。</li>
<li><u>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</u>G1 收集器是通过<code>原始快照（SATB）算法</code>保证用户线程改变对象引用关系时，不能打破原本的对象图结构。此外，G1为每一个Region设计了两个名为<code>TAMS（Top at Mark Start）</code>的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li>
<li><u>怎样建立起可靠的停顿预测模型？</u>G1收集器的停顿预测模型是以<code>衰减均值（Decaying Average）</code>为理论基础来实现的。在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。衰减平均值更准确地代表“最近的”平均状态。</li>
</ul>
<h5 id="4-3-4-关键的细节问题"><a href="#4-3-4-关键的细节问题" class="headerlink" title="4.3.4 关键的细节问题"></a>4.3.4 关键的细节问题</h5><p>G1收集器的运作过程大致可划分为以下四个步骤：</p>
<ul>
<li><code>初始标记（Initial Marking）</code>。仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象，并且修改<code>TAMS</code>指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。</li>
<li><code>并发标记（Concurrent Marking）</code>。从<code>GC Root</code>开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。当对象图扫描完成以后，还要重新处理<code>原始快照SATB</code>记录下的在并发时有引用变动的对象。</li>
<li><code>最终标记（Final Marking）</code>。对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的<code>SATB记录</code>。</li>
<li><code>筛选回收（Live Data Counting and Evacuation）</code>。负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。<ul>
<li>这里的操作涉及存活对象的移动，是<strong>必须暂停用户线程</strong>，由多条收集器线程并行完成的。</li>
</ul>
</li>
</ul>
<p>G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/G1_collector.PNG" alt="G1收集器运行示意图"></p>
<blockquote>
<p>从G1开始，最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的<code>内存分配速率 （Allocation Rate）</code>，应用在分配，同时收集器在收集，只要收集的速度能跟得上对象分配的速度，那一切就能运作得很完美。</p>
</blockquote>
<p>优点：</p>
<ul>
<li>可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集</li>
<li>G1<strong>从整体来看是基于“标记-整理”算法</strong>实现的收集器，但<strong>从局部（两个Region之间）上看又是基于“标记-复制”</strong>算法实现，G1运作期间不会产生内存空间碎片。</li>
</ul>
<p>缺点：</p>
<ul>
<li>G1为了垃圾收集产生的内存占用（Footprint）比CMS要高。G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间；</li>
<li>G1程序运行时的额外执行负载（Overload）比CMS要高。G1除了使用写后屏障来进行卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。</li>
</ul>
<h3 id="5-低延迟垃圾收集器"><a href="#5-低延迟垃圾收集器" class="headerlink" title="5. 低延迟垃圾收集器"></a>5. 低延迟垃圾收集器</h3><p>衡量垃圾收集器的三项最重要的指标是：<code>内存占用（Footprint）</code>、<code>吞吐量（Throughput）</code>和<code>延迟 （Latency）</code>。两款目前仍处于实验状态的收集器<code>Shenandoah</code>和<code>ZGC</code>，被官方命名为<code>“低延迟垃圾收集器”（Low-Latency Garbage Collector或者Low-Pause-Time Garbage Collector）</code>。</p>
<h4 id="5-1-Shenandoah收集器"><a href="#5-1-Shenandoah收集器" class="headerlink" title="5.1 Shenandoah收集器"></a>5.1 Shenandoah收集器</h4><p><code>Shenandoah</code>是一款只有<code>OpenJDK</code>才会包含，而<code>OracleJDK</code>里反而不存在的收集器。Shenandoah反而更像是G1的下一代继承者，在管理堆内存方面，它与G1至少有三个明显的不同之处：</p>
<ul>
<li>支持并发的整理算法；</li>
<li>Shenandoah是默认不使用分代收集的；</li>
<li>Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为<code>“连接矩阵”（Connection Matrix）</code>的全局数据结构来记录<em>跨Region的引用关系</em>，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。</li>
</ul>
<p>Shenandoah收集器的工作过程大致可以划分为以下九个阶段：</p>
<ul>
<li><code>初始标记（Initial Marking）</code>。标记与<code>GC Roots</code>直接关联的对象，这个阶段仍是<code>“Stop The World”</code>的。</li>
<li><code>并发标记（Concurrent Marking）</code>。遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的。</li>
<li><code>最终标记（Final Marking）</code>。处理剩余的<code>SATB扫描</code>，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组<code>回收集（Collection Set）</code>。<em>会有一小段短暂的停顿</em>。</li>
<li><code>并发清理（Concurrent Cleanup）</code>。清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为<code>Immediate Garbage Region</code>）。</li>
<li><code>并发回收（Concurrent Evacuation）</code>。Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中，Shenandoah通过读屏障和被称为“<code>Brooks Pointers</code>”的转发指针来解决并发回收阶段遇到的困难。</li>
<li><code>初始引用更新（Initial Update Reference）</code>。把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务。<em>会产生一个非常短暂的停顿</em>。</li>
<li><code>并发引用更新（Concurrent Update Reference）</code>。按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值。<em>与用户线程一起并发的</em>。</li>
<li><code>最终引用更新（Final Update Reference）</code>。修正存在于<code>GC Roots</code>中的引用，这个阶段是Shenandoah的最后一次停顿。</li>
<li><code>并发清理（Concurrent Cleanup）</code>。经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成<code>Immediate Garbage Regions</code>了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</li>
</ul>
<p>三个最重要的并发阶段<strong>（并发标记、并发回收、并发引用更新）</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Shenandoah.PNG" alt="Shenandoah收集器的工作过程"></p>
<p>黄色的区域代表的是<em>被选入回收集的Region</em>，绿色部分就代表<em>还存活的对象</em>，蓝色就是<em>用户线程可以用来分配对象的内存Region</em>。</p>
<p><code>Brooks Pointer</code>。<code>Brooks</code>提出了使用<code>转发指针</code>（<code>Forwarding Pointer</code>，也常被称为<code>Indirection Pointer</code>）来实现对象移动与用户程序并发的一种解决方案。<code>Brooks</code>在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Brooks_Pointers.PNG" alt="Brooks Pointers示意图"></p>
<p>转发指针加入后带来的收益是当对象拥有了一份新的副本时，只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Brooks_Pointers2.PNG" alt="Brooks Pointers原理"></p>
<p><strong>Brooks转发指针的多线程竞争问题</strong>：</p>
<ul>
<li>收集器线程与用户线程发生的只是并发读取，那无论读到旧对象还是新对象上的字段，返回的结果都应该是一样的；</li>
<li>如果发生的是并发写入，就一定必须保证<code>写操作</code>只能发生在新复制的对象上。</li>
</ul>
<p>Shenandoah收集器是通过<code>比较并交换（Compare And Swap，CAS）操作</code>来保证并发时对象的访问正确性的。</p>
<h4 id="5-2-ZGC收集器"><a href="#5-2-ZGC收集器" class="headerlink" title="5.2 ZGC收集器"></a>5.2 ZGC收集器</h4><p><code>ZGC（Z Garbage Collector）</code>是一款在 <code>JDK 11</code>中新加入的具有实验性质的低延迟垃圾收集器。ZGC和Shenandoah的目标是高度相似的，都希望<u>在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</u>。</p>
<h5 id="5-2-1-ZGC的内存布局"><a href="#5-2-1-ZGC的内存布局" class="headerlink" title="5.2.1 ZGC的内存布局"></a>5.2.1 ZGC的内存布局</h5><p>ZGC也采用基于Region的堆内存布局（在一些官方资料中将它称为<code>Page</code>或者<code>ZPage</code>），ZGC的Region具有<strong>动态性</strong>——<u>动态创建和销毁，以及动态的区域容量大小</u>。ZGC的 Region可以有大、中、小三类容量：</p>
<ul>
<li><code>小型Region（Small Region）</code>：容量固定为<code>2MB</code>，用于放置<u>小于</u><code>256KB</code>的小对象。</li>
<li><code>中型Region（Medium Region）</code>：容量固定为<code>32MB</code>，用于放置<u>大于等于</u><code>256KB</code>但<u>小于</u><code>4MB</code>的对象。</li>
<li><code>大型Region（Large Region）</code>：容量不固定，可以动态变化，但必须为<code>2MB</code>的<strong>整数倍</strong>，用于放置<code>4MB</code>或以上的大对象。每个大型Region中只会存放一个大对象，大型Region在ZGC的实现中<strong>不会被重分配</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ZGC_memory.PNG" alt="ZGC的堆内存布局"></p>
<h5 id="5-2-2-ZGC的并发整理算法"><a href="#5-2-2-ZGC的并发整理算法" class="headerlink" title="5.2.2 ZGC的并发整理算法"></a>5.2.2 ZGC的并发整理算法</h5><p>ZGC收集器采用的<code>染色指针技术</code>（<code>Colored Pointer</code>，其他类似的技术中可能将它称为<code>Tag Pointer</code>或者<code>Version Pointer</code>）。染色指针直接把标记信息记在引用对象的指针上。</p>
<p>在64位系统中，理论可以访问的内存高达<code>16EB</code>（<code>2的64次幂</code>）字节。基于需求 、性能和成本的考虑，在<code>AMD64</code>架构中只支持到<code>52</code>位（<code>4PB</code>）的<u>地址总线</u>和<code>48</code>位（<code>256TB</code>）的<u>虚拟地址空间</u>。</p>
<blockquote>
<p>操作系统也还会施加自己的约束，64位的<code>Linux</code>则分别支持<code>47</code>位（<code>128TB</code>）的进程虚拟地址空间和<code>46</code>位（<code>64TB</code>）的物理地址空间，64位的<code>Windows</code>系统甚至只支持<code>44</code>位（<code>16TB</code>）的物理地址空间。</p>
</blockquote>
<p>Linux下64位指针的高18位不能用来寻址，ZGC的染色指针技术利用这剩下的46位指针宽度，将其<code>高4位</code>提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的<strong>三色标记状态</strong>、<strong>是否进入了重分配集</strong>（即被移动过）、<strong>是否只能通过finalize()方法才能被访问到</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Colored_Pointer.PNG" alt="染色指针"></p>
<blockquote>
<p>这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致ZGC能够管理的内存不可以超过<code>4TB</code></p>
</blockquote>
<p>染色指针的三大优势：</p>
<ul>
<li>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</li>
<li>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。</li>
<li>染色指针可以作为一种<code>可扩展</code>的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li>
</ul>
<h5 id="5-2-3-虚拟内存映射技术"><a href="#5-2-3-虚拟内存映射技术" class="headerlink" title="5.2.3 虚拟内存映射技术"></a>5.2.3 虚拟内存映射技术</h5><p>处理器会使用<code>分页管理机制</code>把线性地址空间和物理地址空间分别划分为大小相同的块，这样的内存块被称为<code>“页”（Page）</code>。通过在线性虚拟空间的页与物理地址空间的页之间建立的<code>映射表</code>，分页管理机制会进行线性地址到物理地址空间的映射，完成线性地址到物理地址的转换。</p>
<p><code>Linux/x86-64</code>平台上的ZGC使用了<code>多重映射（Multi-Mapping）</code>将<u>多个不同的虚拟内存地址映射到同一个物理内存地址上</u>，这是一种<strong>多对一映射</strong>，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。把染色指针中的标志位看作是<code>地址的分段符</code>，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Multi_Mapping.PNG" alt="多重映射下的寻址"></p>
<h5 id="5-2-4-ZGC的运作过程"><a href="#5-2-4-ZGC的运作过程" class="headerlink" title="5.2.4 ZGC的运作过程"></a>5.2.4 ZGC的运作过程</h5><p>ZGC的运作过程大致可划分为以下四个大的阶段。全部四个阶段<strong><u>都是可以并发执行</u></strong>的，仅是两个阶段中间会存在短暂的停顿小阶段，如初始化<code>GC Root</code>直接关联对象的<code>Mark Start</code>。</p>
<ul>
<li><code>并发标记（Concurrent Mark）</code>：并发标记是<strong>遍历对象图做可达性分析的阶段</strong>，前后也要经过初始标记、最终标记的短暂停顿。ZGC 的标记是在指针上进行的，标记阶段会更新染色指针中的<code>Marked0</code>、<code>Marked1</code>标志位。</li>
<li><code>并发预备重分配（Concurrent Prepare for Relocate）</code>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成<code>重分配集（Relocation Set）</code>。ZGC每次回收都会<strong>扫描所有的Region</strong>，用范围更大的扫描成本换取<u>省去G1中记忆集的维护成本</u>。</li>
<li><code>并发重分配（Concurrent Relocate）</code>：把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<code>转发表（Forward Table）</code>，<u>记录从旧对象到新对象的转向关系</u>。<ul>
<li>指针的<code>“自愈”（Self-Healing）</code>能力：ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被<code>预置的内存屏障</code>所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象。这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次。</li>
</ul>
</li>
<li><code>并发重映射（Concurrent Remap）</code>：重映射所做的就是<u>修正整个堆中指向重分配集中旧对象的所有引用</u>，但是ZGC重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。ZGC把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成。</li>
</ul>
<h5 id="5-2-5-“NUMA-Aware”的内存分配"><a href="#5-2-5-“NUMA-Aware”的内存分配" class="headerlink" title="5.2.5 “NUMA-Aware”的内存分配"></a>5.2.5 “NUMA-Aware”的内存分配</h5><p>ZGC支持<code>“NUMA-Aware”的内存分配</code>。<code>NUMA</code>（<code>Non-Uniform Memory Access</code>，<strong>非统一内存访问架构</strong>）是一种为多处理器或者多核处理器的计算机所设计的内存架构。在<code>NUMA</code>架构下，ZGC收集器会优先尝试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问。</p>
<h3 id="6-选择合适的垃圾收集器"><a href="#6-选择合适的垃圾收集器" class="headerlink" title="6. 选择合适的垃圾收集器"></a>6. 选择合适的垃圾收集器</h3><h4 id="6-1-Epsilon收集器"><a href="#6-1-Epsilon收集器" class="headerlink" title="6.1 Epsilon收集器"></a>6.1 Epsilon收集器</h4><p><code>Epsilon</code>这是一款以<u>不能够进行垃圾收集</u>为“卖点”的垃圾收集器。</p>
<blockquote>
<p>Epsilon收集器由<code>RedHat</code>公司在<code>JEP 318</code>中提出，在此提案里<code>Epsilon</code>被形容成一个<code>无操作的收集器（A No-Op Garbage Collector）</code>。</p>
</blockquote>
<p>一个垃圾收集器除了垃圾收集这个本职工作之外，它还要负责<u>堆的管理与布局</u>、<u>对象的分配</u>、<u>与解释器的协作</u>、<u>与编译器的协作</u>、<u>与监控子系统协作</u>等职责。Epsilon是垃圾收集器的统一接口，用于需要剥离垃圾收集器影响的性能测试和压力测试。</p>
<p>在实际生产环境中，不能进行垃圾收集的Epsilon也用于应对<code>短时间、小规模</code>的服务形式，只要Java虚拟机<u>能正确分配内存，在堆耗尽之前就会退出</u>，那显然运行负载极小、没有任何回收行为的Epsilon便是很恰当的选择。</p>
<h4 id="6-2-收集器的权衡"><a href="#6-2-收集器的权衡" class="headerlink" title="6.2 收集器的权衡"></a>6.2 收集器的权衡</h4><p>选择一款适合自己应用的收集器主要受以下三 个因素影响：</p>
<ul>
<li><code>应用程序的主要关注点是什么？</code><ul>
<li>如果是数据分析、科学计算类的任务，目标是能尽快算出结果， 那吞吐量就是主要关注点；</li>
<li>如果是<code>SLA（（Service Level Agreements））</code>应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点；</li>
<li>而如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的。</li>
</ul>
</li>
<li><code>运行应用的基础设施如何？</code><ul>
<li>譬如硬件规格，要涉及的系统架构；</li>
<li>处理器的数量多少，分配内存的大小；</li>
<li>选择的操作系统。</li>
</ul>
</li>
<li>使用JDK的发行商是什么？版本号是多少？是ZingJDK/Zulu、OracleJDK、Open-JDK、OpenJ9抑或是其他公司的发行版？该JDK对应了《Java虚拟机规范》的哪个版本？</li>
</ul>
<p>实战中切不可纸上谈兵，<strong>根据系统实际情况去测试才是选择收集器的最终依据</strong>。</p>
<h4 id="6-3-虚拟机及垃圾收集器日志"><a href="#6-3-虚拟机及垃圾收集器日志" class="headerlink" title="6.3 虚拟机及垃圾收集器日志"></a>6.3 虚拟机及垃圾收集器日志</h4><p><code>JDK 9</code>后，<code>HotSpot</code>所有功能的日志都收归到了<code>“-Xlog”</code>参数上，这个参数的能力也相应被极大拓展：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xlog[:[selector][:[output][:[decorators][:output-options]]]]</span><br></pre></td></tr></table></figure>
<p>最关键的参数是<code>选择器（Selector）</code>，它由<code>标签（Tag）</code>和<code>日志级别（Level）</code>共同组成。</p>
<p>日志级别从低到高，共有<code>Trace，Debug，Info，Warning，Error，Off</code>六种级别，默认级别为<code>Info</code>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Log_parameter.PNG" alt="JDK 9前后日志参数变化"></p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Log_parameter2.PNG" alt="JDK 9前后日志参数变化(续)"></p>
<h4 id="6-4-垃圾收集器参数总结"><a href="#6-4-垃圾收集器参数总结" class="headerlink" title="6.4 垃圾收集器参数总结"></a>6.4 垃圾收集器参数总结</h4><p>具体可以查看书籍，主要还是用到的时候查一下就行。</p>
<h3 id="7-内存分配与回收策略"><a href="#7-内存分配与回收策略" class="headerlink" title="7. 内存分配与回收策略"></a>7. 内存分配与回收策略</h3><p>Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：<u><strong>自动给对象分配内存</strong></u>以及<u><strong>自动回收分配给对象的内存</strong></u>。对象的内存分配，从概念上讲，应该都是在堆上分配（而实际上也有可能经过<code>即时编译</code>后被拆散为标量类型并间接地在栈上分配）。</p>
<h4 id="7-1-对象优先在Eden分配"><a href="#7-1-对象优先在Eden分配" class="headerlink" title="7.1 对象优先在Eden分配"></a>7.1 对象优先在Eden分配</h4><p>对象在新生代<code>Eden区</code>中分配。当<code>Eden区</code>没有足够空间进行分配时，虚拟机将发起 一次<code>Minor GC</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">	allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">	allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">	allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">	allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">// 出现一次Minor GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>testAllocation()</code>中分配<code>allocation4</code>对象的语句时会发生一次<code>Minor GC</code>，产生这次垃圾收集的原因是为<code>allocation4</code>分配内存时，发现 <code>Eden</code>已经被占用了<code>6MB</code>，剩余空间已不足以分配<code>allocation4</code>所需的<code>4MB</code>内存，因此发生<code>Minor GC</code>。</p>
<p>垃圾收集期间虚拟机又发现已有的三个<code>2MB</code>大小的对象全部无法放入<code>Survivor</code>空间（<strong>Survivor空间只有 1MB大小</strong>），所以只好通过分配担保机制提前转移到老年代去。</p>
<p>收集结束后，<code>4MB</code>的<code>allocation4</code>对象顺利分配在<code>Eden</code>中。因此程序执行完的结果是<code>Eden</code>占用 <code>4MB</code>（被<code>allocation4</code>占用），<code>Survivor</code>空闲，老年代被占用<code>6MB</code>（被<code>allocation1、2、3</code>占用）。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testAllocation.PNG" alt="testAllocation运行结果"></p>
<h4 id="7-2-大对象直接进入老年代"><a href="#7-2-大对象直接进入老年代" class="headerlink" title="7.2 大对象直接进入老年代"></a>7.2 大对象直接进入老年代</h4><p>最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。</p>
<blockquote>
<p>在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">* -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] allocation;</span><br><span class="line">	allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">//直接分配在老年代中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Eden空间几乎没有被使用，而老年代的<code>10MB</code>空间被使用了40%，也就是<code>4MB</code>的allocation对象<strong>直接就分配在老年代中</strong></p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testPretenureSizeThreshold.PNG" alt="testPretenureSizeThreshold运行结果"></p>
<h4 id="7-3-长期存活的对象将进入老年代"><a href="#7-3-长期存活的对象将进入老年代" class="headerlink" title="7.3 长期存活的对象将进入老年代"></a>7.3 长期存活的对象将进入老年代</h4><p>虚拟机给每个对象定义了一个<code>对象年龄（Age）计数器</code>，存储在对象头中。</p>
<p>对象通常在<code>Eden区</code>里诞生，如果经过第一次 <code>Minor GC</code>后仍然存活，并且能被<code>Survivor</code>容纳的话，该对象会被移动到<code>Survivor</code>空间中，并且将其对象年龄设为<code>1岁</code>。对象在<code>Survivor</code>区中每熬过一次<code>Minor GC</code>，年龄就增加<code>1岁</code>，当它的年龄增加到一定程度（默认为15），就会<strong>被晋升到老年代中</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment">* -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">	allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>]; <span class="comment">// 什么时候进入老年代决定于XX:MaxTenuringThreshold设置</span></span><br><span class="line">	allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">	allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">	allocation3 = <span class="keyword">null</span>;</span><br><span class="line">	allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当<code>-XX：MaxTenuringThreshold=1</code>时，<code>allocation1</code>对象在第二次<code>GC</code>发生时进入老年代， 新生代已使用的内存在垃圾收集以后非常干净地变成<code>0KB</code>。</li>
<li>当<code>-XX：MaxTenuringThreshold=15</code>时， 第二次<code>GC</code>发生后，<code>allocation1</code>对象则还留在新生代<code>Survivor</code>空间，这时候新生代仍然有<code>404KB</code>被占用。</li>
</ul>
<h4 id="7-4-动态对象年龄判定"><a href="#7-4-动态对象年龄判定" class="headerlink" title="7.4 动态对象年龄判定"></a>7.4 动态对象年龄判定</h4><p>如果在<code>Survivor</code>空间中相同年龄所有对象大小的总和大于<code>Survivor</code>空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p>
<h4 id="7-5-空间分配担保"><a href="#7-5-空间分配担保" class="headerlink" title="7.5 空间分配担保"></a>7.5 空间分配担保</h4><p>在发生<code>Minor GC</code>之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间：</p>
<ul>
<li>如果这个条件成立，那这一次<code>Minor GC</code>可以确保是安全的；</li>
<li>如果不成立，会查看是否允许担保失败（Handle Promotion Failure）：<ul>
<li>如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次<code>Minor GC</code>，尽管这次<code>Minor GC</code>是有风险的；</li>
<li>如果小于，或设置不允许冒险，那这时就要改为进行一次<code>Full GC</code>。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--11 后端编译与优化</title>
    <url>/2021/06/03/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_11_Back-end_compilation_and_optimization.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>后端编译器的编译速度及编译结果质量高低，是衡量Java虚拟机性能最重要的一个指标。<br><a id="more"></a></p>
</blockquote>
<p>如果把字节码看作是程序语言的一种<code>中间表示形式（Intermediate Representation，IR）</code>， 那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的<code>后端</code>。</p>
<h3 id="1-即时编译器"><a href="#1-即时编译器" class="headerlink" title="1. 即时编译器"></a>1. 即时编译器</h3><p>目前主流的两款商用Java虚拟机（<code>HotSpot</code>、<code>OpenJ9</code>）里，Java程序最初都是通过<code>解释器（Interpreter）</code>进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为<code>“热点代码”（Hot Spot Code）</code>，为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为<strong><code>即时编译器</code></strong>。</p>
<h4 id="1-1-解释器与编译器"><a href="#1-1-解释器与编译器" class="headerlink" title="1.1 解释器与编译器"></a>1.1 解释器与编译器</h4><p>目前主流的商用Java虚拟机都采用<strong><u>解释器与编译器并存</u></strong>的运行架构，解释器与编译器两者各有优势：</p>
<ul>
<li>当程序需要<strong>迅速启动和执行</strong>的时候，解释器可以首先发挥作用，<u>省去编译的时间，立即运行</u>。</li>
<li>当程序启动后，随着时间的推移，编译器逐渐发挥作用，<u>把越来越多的代码编译成本地代码</u>，这样可以<strong>减少解释器的中间损耗，获得更高的执行效率</strong>。</li>
<li>当程序运行环境中<strong>内存资源限制较大</strong>，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。</li>
<li>解释器还可以作为编译器激进优化时后备的<code>“逃生门”</code>，让编译器根据概率选择一些不能保证所有情况都正确，但<u>大多数时候都能提升运行速度的优化手段</u>，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现<code>“罕见陷阱”（Uncommon Trap）</code>时可以通过<code>逆优化（Deoptimization）</code>退回到解释状态继续执行。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/InteractionBetweenInterpreterAndCompiler.PNG" alt="解释器与编译器的交互"></p>
<p><code>HotSpot</code>虚拟机中内置了两个（或三个）<code>即时编译器</code>：</p>
<ul>
<li>其中两个编译器存在已久，分别被称为<code>“客户端编译器”（Client Compiler）</code>和<code>“服务端编译器”（Server Compiler）</code>，或者简称为<code>C1编译器</code>和<code>C2编译器</code>（部分资料和JDK源码中<code>C2</code>也叫<code>Opto</code>编译器）</li>
<li>第三个是在<code>JDK 10</code>时才出现的、长期目标是代替<code>C2</code>的<code>Graal</code>编译器。目前还处于实验状态。</li>
</ul>
<p><code>分层编译（Tiered Compilation）</code>的工作模式出现以前，<code>HotSpot</code>虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作。</p>
<ul>
<li>解释器与编译器搭配使用的方式在虚拟机中被称为<code>“混合模式”（Mixed Mode）</code></li>
<li>用户可以使用参数<code>“-Xint”</code>强制虚拟机运行于<code>“解释模式”（Interpreted Mode）</code>，这时候编译器<strong>完全不介入</strong>工作，全部代码都使用解释方式执行。</li>
<li>也可以使用参数<code>“-Xcomp”</code>强制虚拟机运行于<code>“编译模式”（Compiled Mode）</code>，这时候将<strong>优先</strong>采用编译方式执行程序，但是<u>解释器仍然要在编译无法进行的情况下介入执行过程</u>。</li>
</ul>
<p>为了在<u>程序启动响应速度与运行效率</u>之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了<code>分层编译</code>的功能，分层编译根据编译器<u><strong>编译、优化的规模与耗时</strong></u>，划分出不同的编译层次：</p>
<ul>
<li>第0层。程序<strong>纯解释执行</strong>，并且解释器不开启<code>性能监控功能（Profiling）</code>。</li>
<li>第1层。使用<code>客户端编译器</code>将字节码编译为本地代码来运行，进行简单可靠的<u>稳定优化</u>，<u>不开启</u>性能监控功能。</li>
<li>第2层。使用<code>客户端编译器</code>执行，仅开启<u>方法及回边次数统计</u>等<strong>有限</strong>的性能监控功能。</li>
<li>第3层。使用<code>客户端编译器</code>执行，开启<strong>全部</strong>性能监控，还会收集如<u>分支跳转、虚方法调用版本</u>等全部的统计信息。</li>
<li>第4层。使用<code>服务端编译器</code>将字节码编译为本地代码，服务端编译器会启用更多<u>编译耗时更长的优化</u>，还会根据性能监控信息进行一些不可靠的<u>激进优化</u>。</li>
</ul>
<p>实施分层编译后，解释器、客户端编译器和服务端编译器就会<strong>同时工作</strong>，热点代码都可能会被多次编译：</p>
<ul>
<li>用客户端编译器获取更高的编译速度</li>
<li>用服务端编译器来获取更好的编译质量</li>
<li>在解释执行的时候也无须额外承担收集性能监控信息的任务</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/TieredCompilation.PNG" alt="分层编译的交互关系"></p>
<h4 id="1-2-编译对象与触发条件"><a href="#1-2-编译对象与触发条件" class="headerlink" title="1.2 编译对象与触发条件"></a>1.2 编译对象与触发条件</h4><h5 id="1-2-1-热点代码"><a href="#1-2-1-热点代码" class="headerlink" title="1.2.1 热点代码"></a>1.2.1 热点代码</h5><p>在运行过程中会被即时编译器编译的目标是<code>“热点代码”</code>，这里所指的热点代码主要有两类：</p>
<ul>
<li>被多次调用的<strong>方法</strong>。</li>
<li>被多次执行的<strong>循环体</strong>。</li>
</ul>
<p>对于这两种情况，编译的目标对象都是<strong><u>整个方法体</u></strong>，而不会是单独的循环体。由循环体所触发的热点只是方法的一部分，但编译器依然必须以整个方法作为编译对象，只是执行入口会稍有不同，编译时会传入执行入口点<code>字节码序号（Byte Code Index，BCI）</code>。</p>
<blockquote>
<p><code>“栈上替换”（On Stack Replacement，OSR）</code>，即方法的栈帧还在栈上，方法就被替换了。</p>
</blockquote>
<h5 id="1-2-2-热点探测判定方式"><a href="#1-2-2-热点探测判定方式" class="headerlink" title="1.2.2 热点探测判定方式"></a>1.2.2 热点探测判定方式</h5><p>要知道某段代码是不是<code>热点代码</code>，是不是需要触发<code>即时编译</code>，这个行为称为<code>“热点探测”（Hot Spot Code Detection）</code>，目前主流的热点探测判定方式有两种：</p>
<ul>
<li><code>基于采样的热点探测（Sample Based Hot Spot Code Detection）</code>。采用这种方法的虚拟机会<u>周期性地检查各个线程的<strong>调用栈顶</strong>，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是<code>“热点方法”</code></u>。<ul>
<li><strong>好处</strong>是实现简单高效，可以很容易地获取方法调用关系（将调用堆栈展开即可）</li>
<li><strong>缺点</strong>是很难精确地确认一个方法的热度，容易因为<strong>受到线程阻塞或别的外界因素的影响而扰乱热点探测</strong>。 </li>
</ul>
</li>
<li><code>基于计数器的热点探测（Counter Based Hot Spot Code Detection）</code>。采用这种方法的虚拟机会<u>为每个方法（甚至是代码块）建立<strong>计数器</strong>，统计方法的执行次数，如果执行次数超过一定的<code>阈值</code>就认为它是<code>“热点方法”</code>。</u><ul>
<li><strong>缺点</strong>是需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。</li>
<li><strong>优点</strong>是统计结果相对来说更加精确严谨。</li>
</ul>
</li>
</ul>
<h5 id="1-2-3-基于计数器的热点探测"><a href="#1-2-3-基于计数器的热点探测" class="headerlink" title="1.2.3 基于计数器的热点探测"></a>1.2.3 基于计数器的热点探测</h5><p><code>HotSpot虚拟机</code>中使用的是基于计数器的热点探测，<code>HotSpot</code>为每个方法准备了两类计数器：</p>
<ul>
<li><p><code>方法调用计数器（Invocation Counter）</code>。这个计数器就是<u>用于统计方法被调用的次数</u>。</p>
<ul>
<li><p>它的<code>默认阈值</code>在<strong>客户端模式</strong>下是<code>1500</code>次，在<strong>服务端模式</strong>下是<code>10000</code>次，这个阈值可以通过虚拟机参数<code>-XX：CompileThreshold</code>来人为设定。</p>
</li>
<li><p>当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的版本</p>
<ul>
<li>如果存在，则优先使用编译后的本地代码来执行。</li>
<li>如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后判断<u><strong>方法调用计数器与回边计数器值之和</strong></u>是否超过方法调用计数器的阈值。</li>
<li>一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。当编译工作完成后，这个方法的调用入口地址就会被系统自动改写成新值</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/InvocationCounter.PNG" alt="方法调用计数器触发即时编译"></p>
</li>
<li><p>方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<u>一段时间之内方法被调用的次数</u>。</p>
<ul>
<li>超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为<code>方法调用计数器热度的衰减（Counter Decay）</code>，而这段时间就称为此方法统计的<code>半衰周期（Counter Half Life Time）</code>。</li>
<li>热度衰减的动作是<u>在虚拟机进行垃圾收集时顺便进行的</u>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>回边计数器（Back Edge Counter）</code>，<code>“回边”</code>的意思就是指在循环边界往回跳转。这个计数器就是用于<u>统计一个方法中循环体代码执行的次数</u>。</p>
<ul>
<li><p>在字节码中遇到控制流向后跳转的指令就称为<code>“回边（Back Edge）</code>”，建立回边计数器统计的目的是为了<u>触发栈上的替换编译</u>。</p>
</li>
<li><p>当前的<code>HotSpot</code>虚拟机必须设置参数<code>-XX:OnStackReplacePercentage</code>来<strong>间接调整</strong>回边计数器的阈值，其计算公式有如下两种：</p>
<ul>
<li>虚拟机运行在<strong>客户端模式</strong>下，回边计数器阈值计算公式为：<script type="math/tex; mode=display">
\frac{方法调用计数器阈值 \times OSR比率}{100}</script></li>
</ul>
<p><code>OSR比率（-XX：OnStackReplacePercentage）</code>默认值为<code>933</code></p>
<ul>
<li>虚拟机运行在<strong>服务端模式</strong>下，回边计数器阈值的计算公式为：</li>
</ul>
<script type="math/tex; mode=display">
\frac{方法调用计数器阈值 \times (OSR比率-解释器监控比率)}{100}</script><p>其中<code>-XX：OnStackReplacePercentage</code>默认值为<code>140</code>，<code>- XX：InterpreterProfilePercentage</code>默认值为<code>33</code>。</p>
</li>
<li><p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本</p>
<ul>
<li>如果有，将会优先执行已编译的代码</li>
<li>否则就把回边计数器的值加一，然后判断<u><strong>方法调用计数器与回边计数器值之和</strong></u>是否超过回边计数器的阈值。</li>
<li>若超过阈值，将会提交一个<strong>栈上替换</strong>编译请求， 并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/BackEdgeCounter.PNG" alt="回边计数器触发即时编译"></p>
</li>
<li><p>回边计数器<u>没有计数热度衰减的过程</u>，因此这个计数器统计的就是该方法循环执行的<code>绝对次数</code>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="1-3-编译过程"><a href="#1-3-编译过程" class="headerlink" title="1.3 编译过程"></a>1.3 编译过程</h4><p>虚拟机在编译器还未完成编译之前将按照解释方式继续执行代码，而编译动作则在<strong>后台的编译线程</strong>中进行。</p>
<h5 id="1-3-1-客户端编译器"><a href="#1-3-1-客户端编译器" class="headerlink" title="1.3.1 客户端编译器"></a>1.3.1 客户端编译器</h5><p>对于<strong>客户端编译器</strong>来说，主要的关注点在于<u>局部性的优化</u>，而放弃了许多耗时较长的全局优化手段：</p>
<ul>
<li>第一个阶段，一个<code>平台独立的前端</code>将字节码构造成一种<code>高级中间代码表示（High-Level Intermediate Representation，HIR</code>），即<u><strong>与目标机器指令集无关</strong></u>的中间表示。<ul>
<li><code>HIR</code>使用<code>静态单分配（Static Single Assignment，SSA）</code>的形式来代表代码值。</li>
<li>在字节码被构造成<code>HIR</code>之前，编译器已经会在字节码上完成一部分基础优化，如<u>方法内联</u>、<u>常量传播</u>等优。</li>
</ul>
</li>
<li>第二个阶段，一个<code>平台相关的后端</code>从<code>HIR</code>中产生<code>低级中间代码表示（Low-Level Intermediate Representation，LIR</code>，即<u><strong>与目标机器指令集相关</strong></u>的中间表示。<ul>
<li>而在此之前会在<code>HIR</code>上完成一些优化，如<u>空值检查消除</u>、<u>范围检查消除</u>等。</li>
</ul>
</li>
<li>最后的阶段，在<code>平台相关的后端</code>使用<code>线性扫描算法（Linear Scan Register Allocation）</code>在<code>LIR</code>上分配寄存器，并在<code>LIR</code>上做<code>窥孔（Peephole）</code>优化，然后产生机器代码。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ClientCompiler.PNG" alt="Client Compiler架构"></p>
<h5 id="1-3-2-服务端编译器"><a href="#1-3-2-服务端编译器" class="headerlink" title="1.3.2 服务端编译器"></a>1.3.2 服务端编译器</h5><p>服务端编译器是一个能容忍很高优化复杂度的高级编译器，会执行大部分经典的优化动作，如：</p>
<ul>
<li>无用代码消除（Dead Code Elimination）</li>
<li>循环展开（Loop Unrolling）</li>
<li>循环表达式外提（Loop Expression Hoisting）</li>
<li>消除公共子表达式（Common Subexpression Elimination）</li>
<li>常量传播（Constant Propagation）</li>
<li>基本块重排序（Basic Block Reordering）</li>
<li>等</li>
</ul>
<p>还会实施一些<strong>与Java语言特性密切相关的优化技术</strong>，如：</p>
<ul>
<li>范围检查消除（Range Check Elimination）</li>
<li>空值检查消除（Null Check Elimination）</li>
<li>等</li>
</ul>
<p>还可能根据解释器或客户端编译器提供的性能监控信息，进行一些<strong>不稳定的预测性激进优化</strong>，如：</p>
<ul>
<li>守护内联（Guarded Inlining）</li>
<li>分支频率预测 （Branch Frequency Prediction）</li>
<li>等</li>
</ul>
<p>服务端编译采用的<strong>寄存器分配器</strong>是一个<code>全局图着色分配器</code>，它可以充分利用某些处理器架构（如<code>RISC</code>）上的大寄存器集合。</p>
<h4 id="1-4-实战：查看及分析即时编译结果"><a href="#1-4-实战：查看及分析即时编译结果" class="headerlink" title="1.4 实战：查看及分析即时编译结果"></a>1.4 实战：查看及分析即时编译结果</h4><p>从外部观察Java虚拟机的即时编译行为。</p>
<ul>
<li>可以使用参数<code>-XX:+PrintCompilation</code>要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来。如下图所示（其中带有<code>“%”</code>的输出说明是由回边计数器触发的栈上替换编译）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testJIT1.PNG" alt="被即时编译的代码(部分)"></p>
<ul>
<li><p>加上参数<code>-XX:+PrintInlining</code>要求虚拟机输出方法内联信息</p>
</li>
<li><p>可以使用<code>-XX:+PrintAssembly</code>参数要求虚拟机打印编译方法的汇编代码。如果没有<code>HSDIS</code>插件支持，也可以使用<code>-XX：+PrintOptoAssembly</code>（用于服务端模式的虚拟机） 或<code>-XX：+PrintLIR</code>（用于客户端模式的虚拟机）来输出比较接近最终结果的中间代码表示</p>
</li>
<li>可以使用参数<code>-XX：+PrintCFGToFile</code>（用于客户端编译器）或<code>-XX：PrintIdealGraphFile</code>（用于服务端编译器）要求Java虚拟机将编译过程中各个阶段的数据输出到文件中。可以使用<code>Java HotSpot Client Compiler Visualizer</code>（用于分析客户端编译器）或<code>Ideal Graph Visualizer</code>（用于分析服务端编译器）打开这些数据文件进行分析。</li>
</ul>
<h3 id="2-提前编译器"><a href="#2-提前编译器" class="headerlink" title="2. 提前编译器"></a>2. 提前编译器</h3><h4 id="2-1-提前编译的优劣得失"><a href="#2-1-提前编译的优劣得失" class="headerlink" title="2.1 提前编译的优劣得失"></a>2.1 提前编译的优劣得失</h4><p><code>提前编译</code>的研究有着两条明显的分支：</p>
<ul>
<li>一条分支是做与传统<code>C、C++</code>编译器类似的，<u>在程序运行之前把程序代码编译成机器码的静态翻译</u>工作。<ul>
<li>这是传统的提前编译应用形式，在Java中存在的价值是为了解决<u><strong>即时编译要占用程序运行时间和运算资源</strong></u>。</li>
</ul>
</li>
<li>另一条分支是<u>把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码时直接把它加载进来使用</u>。<ul>
<li>这种提前编译被称为<code>动态提前编译（Dynamic AOT）</code>或者<code>即时编译缓存（JIT Caching）</code>。</li>
<li>本质是给即时编译器做<strong>缓存加速</strong>，去改善Java程序的启动时间，以及需要一段时间预热后才能到达最高性能的问题。</li>
</ul>
</li>
</ul>
<p>即时编译器相对于提前编译器的天然优势：</p>
<ul>
<li><code>性能分析制导优化（Profile-Guided Optimization，PGO）</code>。</li>
<li><code>激进预测性优化（Aggressive Speculative Optimization）</code>，这也已经成为很多即时编译优化措施的基础。</li>
<li><code>链接时优化（Link-Time Optimization，LTO）</code>，Java语言天生就是动态链接的，一个个Class文件在运行期被加载到虚拟机内存当中，然后在即时编译器里产生优化后的本地代码。</li>
</ul>
<h4 id="2-2-实战：Jaotc的提前编译"><a href="#2-2-实战：Jaotc的提前编译" class="headerlink" title="2.2 实战：Jaotc的提前编译"></a>2.2 实战：<code>Jaotc</code>的提前编译</h4><p><code>JDK 9</code>引入了用于支持对Class文件和模块进行提前编译的工具<code>Jaotc</code>，以减少程序的启动时间和到达全速性能的预热时间，但这项功能必须针对特定物理机器和目标虚拟机的运行参数来使用。</p>
<p><code>Jaotc</code>做的提前编译属于<code>“第二条分支”</code>，即做即时编译的缓存；而<code>Substrate VM</code>则是选择的<code>“第一条分支”</code>，做的是传统的静态提前编译。</p>
<h3 id="3-编译器优化技术"><a href="#3-编译器优化技术" class="headerlink" title="3. 编译器优化技术"></a>3. 编译器优化技术</h3><p>编译器的目标虽然是做由程序代码翻译为本地机器码的工作，但<strong>输出代码优化质量的高低</strong>才是决定编译器优秀与否的关键。</p>
<h4 id="3-1-优化技术概览"><a href="#3-1-优化技术概览" class="headerlink" title="3.1 优化技术概览"></a>3.1 优化技术概览</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/PerformanceTacticIndex1.PNG" alt="即时编译器优化技术一览"></p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/PerformanceTacticIndex2.PNG" alt="即时编译器优化技术一览（续）"></p>
<p>即时编译器对这些代码优化变换是建立在<strong>代码的中间表示或者是机器码</strong>之上的，而不是直接在Java源码上去做的。使用Java语言的语法来表示优化技术所发挥的作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优化前的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	y = b.get();</span><br><span class="line">	<span class="comment">// ...do stuff...</span></span><br><span class="line">	z = b.get();</span><br><span class="line">	sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个要进行的优化是<code>方法内联</code>，它的主要目的有两个：</p>
<ul>
<li>一是去除方法调用的成本（如查找方法版本、建立栈帧等）；</li>
<li>二是为其他优化建立良好的基础。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内联后的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    z = b.value;</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步进行<code>冗余访问消除（Redundant Loads Elimination）</code>，也可以把这项优化看作一种<code>公共子表达式消除（Common Subexpression Elimination）</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冗余访问消除的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    z = y;</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步进行<code>复写传播（Copy Propagation）</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复写传播的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    y = y;</span><br><span class="line">    sum = y + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四步进行<code>无用代码消除（Dead Code Elimination）</code>，无用代码可能是<u>永远不会被执行的代码</u>，也可能是<u>完全没有意义的代码</u>，因此它又被称为<code>“Dead Code”</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行无用代码消除的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    sum = y + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四种具有代表性的优化技术：</p>
<ul>
<li>最重要的优化技术之一：方法内联。</li>
<li>最前沿的优化技术之一：逃逸分析。</li>
<li>语言无关的经典优化技术之一：公共子表达式消除。</li>
<li>语言相关的经典优化技术之一：数组边界检查消除。</li>
</ul>
<h4 id="3-2-方法内联"><a href="#3-2-方法内联" class="headerlink" title="3.2 方法内联"></a>3.2 方法内联</h4><p>内联被业内戏称为<code>优化之母</code>，因为除了消除方法调用的成本之外，它更重要的意义是<u><strong>为其他优化手段建立良好的基础</strong></u>。</p>
<blockquote>
<p>方法内联的优化行为可以理解为<u><strong>把目标方法的代码原封不动地“复制”到发起调用的方法之中，避免发生真实的方法调用</strong></u>。但Java的虚方法调用都必须在运行时进行方法接收者的多态选择，它们都有可能存在多于一个版本的方法接收者，编译器静态地去做内联的时候很难确定应该使用哪个方法版本。</p>
</blockquote>
<p>为了解决虚方法的内联问题，Java虚拟机引入了<code>类型继承关系分析（Class Hierarchy Analysis，CHA）</code>技术。</p>
<blockquote>
<p>是<code>整个应用程序范围内</code>的类型分析技术，用于确定在目前已加载的类中，<u>某个接口是否有多于一种的实现</u>、<u>某个类是否存在子类</u>、<u>某个子类是否覆盖了父类的某个虚方法</u>等信息。</p>
</blockquote>
<ul>
<li>如果是非虚方法，直接进行内联；</li>
<li>如果是虚方法，则会向<code>CHA</code>查询此方法在当前程序状态下是否真的有多个目标版本可供选择<ul>
<li>如果查询到只有一个版本，那就可以假设<em>“应用程序的全貌就是现在运行的这个样子”</em>来进行内联，这种内联被称为<code>守护内联（Guarded Inlining）</code>。由于Java程序是动态连接的，可能会加载到新类型从而改变<code>CHA</code>结论，因此这种内联属于<code>激进预测性优化</code>，必须预留<code>“逃生门”</code>，即当假设条件不成立时的<code>“退路”（Slow Path）</code>。<ul>
<li>若在程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。</li>
<li>若加载了导致继承关系发生变化的新类，那么必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。</li>
</ul>
</li>
<li>如果向<code>CHA</code>查询出来的结果是该方法有多个版本的目标方法可供选择，即时编译器还将使用<code>内联缓存（Inline Cache）</code>的方式来缩减方法调用的开销。<code>内联缓存</code>是一个建立在<u><strong>目标方法正常入口之前</strong></u>的缓存，工作原理大致为：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。<ul>
<li>如果以后进来的每次调用的方法接收者版本都是一样的，那么这时它就是一种<code>单态内联缓存（Monomorphic Inline Cache）</code>。通过该缓存来调用，比用不内联的非虚方法调用，仅多了一次类型判断的开销。</li>
<li>如果出现方法接收者不一致，说明程序用到了方法的多态特性，这时候会退化成<code>超多态内联缓存（Megamorphic Inline Cache）</code>，其开销相当于真正查找虚方法表来进行方法分派。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-3-逃逸分析"><a href="#3-3-逃逸分析" class="headerlink" title="3.3 逃逸分析"></a>3.3 逃逸分析</h4><p><code>逃逸分析（Escape Analysis）</code>与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。</p>
<blockquote>
<p>基本原理是：分析对象<code>动态作用域</code>，当一个对象在方法里面被定义后：</p>
<ul>
<li>可能被<strong>外部方法</strong>所引用，例如作为调用参数传递到其他方法中，这种称为<code>方法逃逸</code>；</li>
<li>可能被<strong>外部线程</strong>访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为<code>线程逃逸</code>；</li>
<li>从不逃逸、方法逃逸到线程逃逸，称为对象<strong>由低到高</strong>的不同<code>逃逸程度</code>。</li>
</ul>
</blockquote>
<p>根据<code>逃逸程度</code>可以为这个对象实例采取不同程度的优化：</p>
<ul>
<li><code>栈上分配（Stack Allocations）</code>：如果确定一个对象<strong>不会逃逸出线程</strong>之外，可以让这个对象<u>在栈上分配内存</u>，对象所占用的内存空间就可以随栈帧出栈而自动销毁，垃圾收集子系统的压力将会下降很多。<u>栈上分配可以支持方法逃逸，但不能支持线程逃逸</u>。</li>
<li><code>标量替换（Scalar Replacement）</code>：Java虚拟机中的原始数据类型都不能再进一步分解分解成更小的数据来表示，这些数据可以被称为<code>标量</code>。如果一个数据可以继续分解，那它就被称为<code>聚合量（Aggregate）</code>。<ul>
<li><u>把一个Java对象拆散，根据程序访问的情况，<strong>将其用到的成员变量恢复为原始类型来访问</strong></u>，这个过程就称为<code>标量替换</code>。</li>
<li>假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。对象拆分后可以让对象的成员变量在栈上 分配和读写，标量替换可以视作<code>栈上分配的一种特例</code>，实现更简单。</li>
<li><u><strong>它不允许对象逃逸出方法范围内</strong></u>。</li>
</ul>
</li>
<li><code>同步消除（Synchronization Elimination）</code>：如果逃逸分析能够确定一个变量<strong>不会逃逸出线程</strong>，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，<u>对这个变量实施的同步措施也就可以安全地消除掉</u>。</li>
</ul>
<p>逃逸分析的<u>计算成本非常高</u>，甚至不能保证逃逸分析带来的性能收益会高于它的消耗，但它是即时编译器优化技术的一个重要前进方向。</p>
<h4 id="3-4-公共子表达式消除"><a href="#3-4-公共子表达式消除" class="headerlink" title="3.4 公共子表达式消除"></a>3.4 公共子表达式消除</h4><p>公共子表达式消除是：如果一个表达式<code>E</code>之前已经被计算过了，并且从先前的计算到现在<code>E</code>中所有变量的值都没有发生变化，那么<code>E</code>的这次出现就称为<code>公共子表达式</code>。对于这种表达式，只需要直接用前面计算过的表达式结果代替<code>E</code>。</p>
<ul>
<li>如果这种优化仅限于<strong>程序基本块</strong>内，便可称为<code>局部公共子表达式消除（Local Common Subexpression Elimination）</code>；</li>
<li>如果这种优化的范围涵盖了<strong>多个基本块</strong>，那就称为<code>全局公共子表达式消除（Global Common Subexpression Elimination）</code>。</li>
</ul>
<h4 id="3-5-数组边界检查消除"><a href="#3-5-数组边界检查消除" class="headerlink" title="3.5 数组边界检查消除"></a>3.5 数组边界检查消除</h4><p><code>数组边界检查消除（Array Bounds Checking Elimination）</code>是语言相关的。Java语言是一门<code>动态安全</code>的语言，访问数组元素<code>foo[i]</code>时系统将会自动进行<u>上下界的范围检查</u>，即i必须满足<code>“i&gt;=0&amp;&amp;i&lt;foo.length”</code>的访问条件，所以每次数组元素的读写都带有一次隐含的条件判定操作。</p>
<ul>
<li>可以进行<code>数组边界检查优化</code>，尽可能把运行期检查提前到编译期完成。比如通过数据流分析就可以判定循环变量的取值范围是否在上下界区间内，如果在，可以把上下界检查消除掉。</li>
<li>还可以进行隐式异常处理。需要根据运行期收集到的性能监控信息选择最合适的方案</li>
</ul>
<h3 id="4-实战：深入理解Graal编译器"><a href="#4-实战：深入理解Graal编译器" class="headerlink" title="4. 实战：深入理解Graal编译器"></a>4. 实战：深入理解<code>Graal</code>编译器</h3><h4 id="4-1-Java虚拟机编译器接口"><a href="#4-1-Java虚拟机编译器接口" class="headerlink" title="4.1 Java虚拟机编译器接口"></a>4.1 Java虚拟机编译器接口</h4><p><code>Java虚拟机编译器接口（Java-Level JVM Compiler Interface，JVMCI）</code>使得<code>Graal</code>可以从<code>HotSpot</code>的代码中分离出来。<code>JVMCI</code>主要提供如下三种功能：</p>
<ul>
<li>响应<code>HotSpot</code>的编译请求，并将该请求分发给Java实现的即时编译器。</li>
<li>允许编译器访问<code>HotSpot</code>中<u>与即时编译相关的数据结构</u>，包括类、字段、方法及其性能监控数据等，并提供了一组这些数据结构在Java语言层面的抽象表示。</li>
<li>提供<code>HotSpot</code>代码缓存（<code>Code Cache</code>）的Java端抽象表示，允许编译器部署编译完成的二进制机器码。</li>
</ul>
<p><code>JVMCI</code>编译器接口输入要编译的方法的字节码，即<code>“用一个字节数组表示的代码”</code>。输出与方法对应的二进制机器码，二进制机器码也应该是<code>“用一个字节数组表示的代码”</code>。这样的话，<code>JVMCI</code>接口就应该类似于下面形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JVMCICompiler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] compileMethod(<span class="keyword">byte</span>[] bytecode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上<code>JVMCI</code>接口只比上面这个稍微复杂一点，其输入除了字节码外，<code>HotSpot</code>还会向编译器提供各种该方法的相关信息，譬如<u>局部变量表中变量槽的个数</u>、<u>操作数栈的最大深度</u>，还有<u>分层编译在底层收集到的统计信息</u>等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JVMCICompiler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">compileMethod</span><span class="params">(CompilationRequest request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompilationRequest</span> </span>&#123;</span><br><span class="line">	<span class="function">JavaMethod <span class="title">getMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JavaMethod</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] getCode();</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getMaxLocals</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getMaxStackSize</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">ProfilingInfo <span class="title">getProfilingInfo</span><span class="params">()</span></span>;</span><br><span class="line">	... <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-代码中间表示"><a href="#4-2-代码中间表示" class="headerlink" title="4.2 代码中间表示"></a>4.2 代码中间表示</h4><p><code>Graal编译器</code>在采用了与<code>HotSpot</code>服务端编译器一致（略有差异但已经非常接近）的中间表示形式，也即是被称为<code>Sea-of-Nodes</code>的中间表示，或者与其等价的被称为<code>理想图</code>（<code>Ideal Graph</code>，在代码中称为<code>Structured Graph</code>）的<code>程序依赖图（Program Dependence Graph，PDG）</code>形式。</p>
<blockquote>
<p>从编译器内部来看理想图上翻译和优化输入代码的整体过程即：<code>字节码→理想图→优化→机器码</code></p>
</blockquote>
<p>理想图是一种<code>有向图</code>，用节点来表示<strong>程序中的元素</strong>，譬如变量、操作符、方法、字段等，而用边来表示<strong>数据</strong>或者<strong>控制流</strong>。如表达式：<code>x+y</code>，在理想图中可以表示为<code>x</code>、<code>y</code>两个节点的数据流流入加法操作符。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/IdealGraph1.PNG" alt="构造理想图"></p>
<p>把表达式<code>x+y</code>变为<code>getX()+getY()</code>，理想图除了需要表达数据流向之外，还必须要考虑方法调用的顺序。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/IdealGraph2.PNG" alt="构造理想图"></p>
<blockquote>
<p>理想图本质上就是这种将<code>数据流图</code>和<code>控制流图</code>以某种方式合并到一起，用一种边来表示数据流向，另一种边来表示控制流向的图形表示。</p>
</blockquote>
<h4 id="4-3-代码优化与生成"><a href="#4-3-代码优化与生成" class="headerlink" title="4.3 代码优化与生成"></a>4.3 代码优化与生成</h4><p><code>Graal编译器</code>中创建理想图的方法是<code>createGraph()</code>，<code>createGraph()</code>方法内调用了<code>StructuredGraph::Builder()</code>构造器来创建理想图。</p>
<h5 id="4-3-1-理想图本身的数据结构"><a href="#4-3-1-理想图本身的数据结构" class="headerlink" title="4.3.1 理想图本身的数据结构"></a>4.3.1 理想图本身的数据结构</h5><p>它是一组<strong>不为空</strong>的节点的集合，它的节点都是用<code>ValueNode</code>的不同类型的<strong>子类节点</strong>来表示的。如加法操作就由<code>AddNode</code>节点来表示，到加法操作是<code>二元算术操作节点（BinaryArithmeticNode&lt;OP&gt;）</code>的一种，而二元算术操作节点又是<code>二元操作符（BinaryNode）</code>的一种。</p>
<h5 id="4-3-2-从字节码转换到理想图"><a href="#4-3-2-从字节码转换到理想图" class="headerlink" title="4.3.2 从字节码转换到理想图"></a>4.3.2 从字节码转换到理想图</h5><p>该过程被封装在<code>BytecodeParser</code>类中，可以按照字节码解释器的思路去理解该解析器。<code>BytecodeParser::genArithmeticOp()</code>方法如下：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/genArithmeticOp.PNG" alt="genArithmeticOp方法"></p>
<p>其中，<code>genIntegerAdd()</code>方法中就只有一行代码，即调用<code>AddNode</code>节点的<code>create()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ValueNode <span class="title">genIntegerAdd</span><span class="params">(ValueNode x, ValueNode y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> AddNode.create(x, y, NodeView.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValueNode <span class="title">create</span><span class="params">(ValueNode x, ValueNode y, NodeView view)</span> </span>&#123;</span><br><span class="line">	BinaryOp&lt;Add&gt; op = ArithmeticOpTable.forStamp(x.stamp(view)).getAdd();</span><br><span class="line">	Stamp stamp = op.foldStamp(x.stamp(view), y.stamp(view));</span><br><span class="line">	ConstantNode tryConstantFold = tryConstantFold(op, x, y, stamp, view);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (tryConstantFold != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> tryConstantFold;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x.isConstant() &amp;&amp; !y.isConstant()) &#123;</span><br><span class="line">		<span class="keyword">return</span> canonical(<span class="keyword">null</span>, op, y, x, view);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> canonical(<span class="keyword">null</span>, op, x, y, view);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个理想图的节点都有两个共同的主要操作：</p>
<ul>
<li><strong>规范化</strong>（<code>Canonicalisation</code>），即代码优化。在理想图的基础上优化代码所要采取的措施，实现在<code>canonical()</code>方法中。</li>
<li><strong>生成机器码</strong>（<code>Generation</code>），即代码翻译。实现在<code>generate()</code>方法中。<code>Graal</code>并不是直接由理想图转换到机器码，而是会先生成<code>低级中间表示</code>（<code>LIR</code>，与具体机器指令集相关的中间表示），然后再由<code>HotSpot</code>统一后端来产生机器码。</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--18 远程部署的RMI</title>
    <url>/2021/05/20/JavaLearning_Head_First_Java_18_remote%20deployment_with_RMI.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>分布式计算，距离不是问题。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-远程过程调用的设计"><a href="#1-远程过程调用的设计" class="headerlink" title="1. 远程过程调用的设计"></a>1. 远程过程调用的设计</h3><p>远程过程调用(<code>Remote Method Invocation, RMI</code>)要建出4种东西：<code>服务器</code>、<code>客户端</code>、<code>服务器辅助设施</code>和<code>客户端辅助设施</code>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/remoteMethod.PNG" alt="远程过程调用的设计"></p>
<h4 id="1-1-辅助设施的任务"><a href="#1-1-辅助设施的任务" class="headerlink" title="1.1 辅助设施的任务"></a>1.1 <code>辅助设施</code>的任务</h4><p>辅助设施是个在实际上执行通信的对象，会让客户端对象看起来在调用远程的方法。辅助设施会去连接服务器，将调用的信息传送过去，然后等待服务器的响应。</p>
<p>服务器的辅助设施会接受客户端辅助设施打包的信息，调用真正的服务，然后取得返回值送回客户端辅助设施。</p>
<h4 id="1-2-创建远程服务"><a href="#1-2-创建远程服务" class="headerlink" title="1.2 创建远程服务"></a>1.2 创建远程服务</h4><p>创建远程服务有5个步骤：</p>
<ol>
<li><p>创建<code>Remote</code>接口。远程接口定义了客户端可以远程调用的方法，是一个作为服务的多态化类。stub和服务都会实现此接口。</p>
<ul>
<li><p>继承<code>java.rmi.Remote</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRemote</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明所有方法都会抛出<code>RemoteException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRemote</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定参数和返回值都是<code>primitive主数据类型</code>或<code>Serializable</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>实现<code>Remote</code>。真正执行的类，实现定义在该接口上的方法。</p>
<ul>
<li><p>实现<code>Remote</code>接口；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRemoteImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">MyRemote</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> “Server says, ‘Hey’”;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// more code in class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>继承<code>UnicastRemoteObject</code>。对象必须要有远程相关功能，最简单的方式就是继承<code>UnicastRemoteObject</code>类来处理。</p>
</li>
<li><p>编写声明<code>RemoteException</code>的无参数构造函数；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyRemoteImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>向<code>RMI registry</code> 注册服务。将服务初始化并加入<code>RMI registry</code> ，<code>RMI</code>系统会把<code>stub</code>加到<code>registry</code>中。使用<code>java.rmi.Naming</code>的<code>rebind</code>方法来注册服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    MyRemote service = <span class="keyword">new</span> MyRemoteImpl();</span><br><span class="line">    <span class="comment">// 帮助服务命名，并向RMI registry注册</span></span><br><span class="line">    Naming.rebind(“Remote Hello”, service);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>用<code>rmic</code>产生<code>stub</code>与<code>skeleton</code>。由<code>JDK</code>附带的<code>rmic</code>工具自动处理。</p>
<ul>
<li><p>对实现出的类执行<code>rmic</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rmic MyRemoteImpl</span><br></pre></td></tr></table></figure>
<p><code>Java software development kit(JDK)</code>中的<code>rmic</code>工具会以服务的实现产生连个新类：<code>stub</code>和<code>skeleton</code>。</p>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>启动<code>RMI registry</code> (<code>rmiregistry</code>)。用户从此处获取代理。</p>
<ul>
<li><p>在命令行启动<code>rmiregistry</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rmiregistry</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>启动远程服务。实现服务的类会启动服务的实例并向<code>RMI registry</code> 注册，要有注册才能对用户提供服务。</p>
<ul>
<li><p>启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java MyRemoteImpl</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="1-3-客户端获取stub"><a href="#1-3-客户端获取stub" class="headerlink" title="1.3 客户端获取stub"></a>1.3 客户端获取<code>stub</code></h4><p>客户端需要获取<code>stub</code>对象，这需要<code>RMI registry</code>，客户端从上面查询得到有相符名称的服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyRemote service = (MyRemote) Naming.lookup(<span class="string">"rmi://127.0.0.1/Remote Hello"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>客户端查询<code>RMI registry</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Naming.lookup(<span class="string">"rmi://127.0.0.1/Remote Hello"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>RMI registry</code>返回<code>stub</code>对象，<code>RMI</code>会自动将<code>stub</code>解序列化。</p>
</li>
<li><p>客户端可以调用<code>stub</code>上的方法</p>
</li>
</ul>
<h3 id="2-Servlets"><a href="#2-Servlets" class="headerlink" title="2. Servlets"></a>2. Servlets</h3><p><code>Servlets</code>是放在<code>Http Web</code>服务上面运行的Java程序，用户通过浏览器与网页交互时，如果请求需要Java的<code>Servlets</code>时，服务器会执行或调用已经执行的<code>Servlets</code>程序代码。</p>
<blockquote>
<p><code>Servlets</code>只运行在服务器上。</p>
</blockquote>
<ul>
<li>用户在网页上填写表格并提交，<code>HTTP</code>服务器受到请求，判断需要<code>Servlets</code>就传送该请求</li>
<li><code>Servlets</code>开始执行，把数据存入数据库，然后返回内容给浏览器。</li>
</ul>
<p>创建并执行<code>Servlets</code>的步骤：</p>
<ol>
<li><p>找出可以存放<code>Servlets</code>的地方</p>
</li>
<li><p>取得<code>Servlets.jar</code>并添加到<code>classpath</code>上。<code>Servlets</code>不是标准库的一部分，需要单独下载。</p>
</li>
<li><p>通过继承<code>HttpServlet</code>来编写<code>Servlet</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletA</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写<code>HTML</code>来调用<code>Servlet</code></p>
</li>
<li><p>给服务器设定HTML网页和<code>Servlet</code></p>
</li>
</ol>
<h3 id="3-Enterprise-JavaBeans"><a href="#3-Enterprise-JavaBeans" class="headerlink" title="3. Enterprise JavaBeans"></a>3. Enterprise JavaBeans</h3><p><code>Enterprise JavaBeans(EJB)</code>服务器作用与<code>RMI</code>调用和服务层之间，支持交易管理、安全性、并发性、数据库和网络功能等。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/EJB.PNG" alt="EJB架构的一部分"></p>
<h3 id="4-Jini"><a href="#4-Jini" class="headerlink" title="4. Jini"></a>4. Jini</h3><p><code>Jini</code>也是使用<code>RMI</code>，但有几个关键功能：</p>
<ol>
<li>自适应探索(<code>Adaptive discovery</code>)</li>
<li>自恢复网络(<code>Self-healing networks</code>)</li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--5 调优案例分析与实战</title>
    <url>/2021/05/26/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_5_Tuning_case_study_and_practice.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code><br><a id="more"></a></p>
</blockquote>
<h3 id="1-案例分析"><a href="#1-案例分析" class="headerlink" title="1. 案例分析"></a>1. 案例分析</h3><p>如何在不改变已有软硬件版本和规格的前提下，调整部署和配置策略去解决或者缓解问题。</p>
<h4 id="1-1-大内存硬件上的程序部署策略"><a href="#1-1-大内存硬件上的程序部署策略" class="headerlink" title="1.1 大内存硬件上的程序部署策略"></a>1.1 大内存硬件上的程序部署策略</h4><p>案例描述：</p>
<blockquote>
<p>升级网址服务器硬件后，<code>HotSpot</code>虚拟机是以服务端模式运行，默认使用的是吞吐量优先收集器，回收<code>12GB</code>的<code>Java</code>堆，一次<code>Full GC</code>的停顿时间就高达14秒。过大的堆内存进行回收时带来的长时间的停顿，将Java堆分配的内存重新缩小到<code>1.5GB</code>或者<code>2GB</code>，这样的确可以避免长时间停顿，但是在硬件上的投资就显得非常浪费。</p>
</blockquote>
<p>解决方式：</p>
<p>目前单体应用在较大内存的硬件上主要部署方式为：</p>
<blockquote>
<ol>
<li>通过一个<u>单独的Java虚拟机</u>实例来管理大量的Java堆内存。<ul>
<li>这种部署方式必须把应用的<code>Full GC</code>频率控制得足够低，至少要低到不会在用户使用过程中发生。这样可以通过在深夜执行<code>定时任务的方式触发Full GC</code>甚至是<code>自动重启应用服务器</code>来保持内存可用空间在一个稳定的水平。</li>
</ul>
</li>
<li>同时使用若干个Java虚拟机，建立<u>逻辑集群</u>来利用硬件资源。<ul>
<li>做法是在一台物理机器上启动多个应用服务器进程，为每个服务器进程分配不同端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。</li>
</ul>
</li>
</ol>
</blockquote>
<p>最后的部署方案是调整为建立<code>5</code>个<code>32</code>位<code>JDK</code>的逻辑集群，每个进程按<code>2GB</code>内存计算（其中堆固定为<code>1.5GB</code>），占用了 <code>10GB</code>内存。另外建立一个<code>Apache</code>服务作为前端均衡代理作为访问门户。</p>
<h4 id="1-2-集群间同步导致的内存溢出"><a href="#1-2-集群间同步导致的内存溢出" class="headerlink" title="1.2 集群间同步导致的内存溢出"></a>1.2 集群间同步导致的内存溢出</h4><p>案例描述：</p>
<blockquote>
<p>构成一个亲合式集群，使用<code>JBossCache</code>构建了一个全局缓存来解决数据库中<u>读写频繁、竞争激烈</u>对性能影响较大的问题，全局缓存启用后，服务正常使用了一段较长的时间，最近不定期出现多次的内存溢出问题。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<ul>
<li><p><code>JBossCache</code>是基于自家的<code>JGroups</code>进行集群间的数据通信，<code>JGroups</code>使用协议栈的方式来实现收发数据包的各种所需特性自由组合，数据包接收和发送时要经过每层协议栈的<code>up()</code>和<code>down()</code>方法，其中的<code>NAKACK</code>栈用于<u>保障各个包的有效顺序以及重发</u>。</p>
</li>
<li><p>也有<code>MIS</code>系统实现方式上的缺陷。网络情况不能满足传输要求时，重发数据在内存中不断堆积，很快就产生了内存溢出。</p>
</li>
</ul>
</blockquote>
<h4 id="1-3-堆外内存导致的溢出错误"><a href="#1-3-堆外内存导致的溢出错误" class="headerlink" title="1.3 堆外内存导致的溢出错误"></a>1.3 堆外内存导致的溢出错误</h4><p>案例描述：</p>
<blockquote>
<p>基于<code>B/S</code>的电子考试系统服务端不定时抛出内存溢出异常。尝试过把堆内存调到最大，<code>32</code>位系统最多到 <code>1.6GB</code>基本无法再加大了，而且开大了基本没效果，抛出内存溢出异常好像还更加频繁。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<p><code>Direct Memory</code>耗用的内存并不算入这<code>1.6GB</code>的堆之内，因此它最大也只能在剩余的<code>0.4GB</code>空间中再分出一部分而已。在此应用中导致溢出的关键是</p>
<ul>
<li><u>垃圾收集进行时，虚拟机虽然会对直接内存进行回收，但是直接内存只能等待老年代满后<code>Full GC</code>出现后，“顺便”帮它清理掉内存的废弃对象</u>。</li>
<li>否则需要等到抛出内存溢出异常时捕获到异常，再在Catch块里面通过<code>System.gc()</code>来触发垃圾收集。</li>
</ul>
</blockquote>
<p>下面这些区域还会占用较多的内存，内存总和受到操作系统进程最大内存的限制：</p>
<ul>
<li>直接内存：可通<code>过-XX：MaxDirectMemorySize</code>调整大小；</li>
<li>线程堆栈：可通过<code>-Xss</code>调整大小，内存不足时抛出<code>StackOverflowError</code>或者<code>OutOfMemoryError</code>；</li>
<li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，如果无法分配，可能会抛出<code>IOException：Too many open files</code>异常。</li>
<li>JNI代码：如果代码中使用了JNI调用本地库，占用的是Java虚拟机的本地方法栈和本地内存的。</li>
</ul>
<h4 id="1-4-外部命令导致系统缓慢"><a href="#1-4-外部命令导致系统缓慢" class="headerlink" title="1.4 外部命令导致系统缓慢"></a>1.4 外部命令导致系统缓慢</h4><p>案例描述：</p>
<blockquote>
<p>一个数字校园应用系统，发现请求响应时间比较慢，通过操作系统的<code>mpstat</code>工具发现处理器使用率很高，但是<u>系统中占用绝大多数处理器资源的程序并不是该应用本身</u>。通过<code>dtrace</code>脚本发现最消耗处理器资源的竟然是<code>“fork”</code>系统调用，<code>“fork”</code>系统调用是Linux用来产生新进程的，在Java虚拟机中，用户编写的Java代码通常最多只会创建新的线程，不应当有进程的产生。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<p>每个用户请求的处理都需要执行一个外部<code>Shell</code>脚本来获得系统的一些信息。执行这个Shell脚本是通过Java的<code>Runtime.getRuntime().exec()</code>方法来调用的。即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也会非常可观。</p>
<p>去掉这个Shell脚本执行的语句，改为使用Java的<code>API</code>去获取这些信息后，系统很快恢复了正常。</p>
</blockquote>
<h4 id="1-5-服务器虚拟机进程崩溃"><a href="#1-5-服务器虚拟机进程崩溃" class="headerlink" title="1.5 服务器虚拟机进程崩溃"></a>1.5 服务器虚拟机进程崩溃</h4><p>案例描述：</p>
<blockquote>
<p>一个基于B/S的MIS系统，正常运行一段时间后，最近发现在运行期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下了一个<code>hs_err_pid###.log</code>文件后，虚拟机进程就消失了。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<p>由于MIS系统的用户多，待办事项变化很快，为了不被<code>OA系统</code>速度拖累，使用了<strong>异步的方式</strong>调用 Web服务，但由于两边服务速度的完全不对等，时间越长就累积了越多Web服务没有调用完成，导致在等待的线程和Socket连接越来越多，最终超过虚拟机的承受能力后导致虚拟机进程崩溃。</p>
<p>修复<code>OA门户</code>无法使用的集成接口，并将异步调用改为<u>生产者/消费者模式</u>的消息队列实现后，系统恢复正常。</p>
</blockquote>
<h4 id="1-6-不恰当数据结构导致内存占用过大"><a href="#1-6-不恰当数据结构导致内存占用过大" class="headerlink" title="1.6 不恰当数据结构导致内存占用过大"></a>1.6 不恰当数据结构导致内存占用过大</h4><p>案例描述：</p>
<blockquote>
<p>一个后台<code>RPC</code>服务器，业务上需要每 10分钟加载一个约<code>80MB</code>的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个<code>HashMap&lt;Long，Long&gt;Entry</code>，在这段时间里面<code>Minor GC</code>就会造成超过<code>500毫秒</code>的停顿，对于这种长度的停顿时间就接受不了了。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<ul>
<li>如果不修改程序，仅从GC调优的角度去解决这个问题，可以考虑直接将Survivor空间去掉，让新生代中存活的对象在第一次<code>Minor GC</code>后立即进入老年代，等到<code>Major GC</code>的时候再去清理它们。</li>
<li>这里产生问题的根本原因是用<code>HashMap&lt;Long, Long&gt;</code>结构来存储数据文件空间效率太低了，只有<code>Key</code>和<code>Value</code>所存放的两个长整型数据是有效数据，空间效率为有效数据除以全部内存空间，即16字节/88字节=18%。</li>
</ul>
</blockquote>
<h4 id="1-7-由Windows虚拟内存导致的长时间停顿"><a href="#1-7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="1.7 由Windows虚拟内存导致的长时间停顿"></a>1.7 由Windows虚拟内存导致的长时间停顿</h4><p>案例描述：</p>
<blockquote>
<p>一个带<code>心跳检测功能</code>的GUI桌面程序，每15秒会发送一次心跳检测信号，如果对方30秒以内都没有信号返回，那就认为和对方程序的连接已经断开。程序上线后发现心跳检测有误报的可能，原因是程序会偶尔出现间隔约一分钟的时间完全无日志输出，处于停顿状态。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<ul>
<li>程序在最小化时它的工作内存被自动交换到磁盘的页面文件之中了，这样发生垃圾收集时就有可能因为恢复页面文件的操作导致不正常的垃圾收集停顿。在Java的GUI程序中要避免这种现象，可以加入参数“<code>-Dsun.awt.keepWorkingSetOnMinimize=true</code>”来解决。</li>
</ul>
</blockquote>
<h4 id="1-8-由安全点导致长时间停顿"><a href="#1-8-由安全点导致长时间停顿" class="headerlink" title="1.8 由安全点导致长时间停顿"></a>1.8 由安全点导致长时间停顿</h4><p>案例描述：</p>
<blockquote>
<p>一个比较大的承担公共计算任务的离线HBase集群，因为集群读写压力较大，而离线分析任务对延迟又不会特别敏感，所以将<code>-XX:MaxGCPauseMillis</code>参数设置到了<em>500毫秒</em>。不过运行一段时间后发现垃圾收集的停顿经常达到<em>3秒</em>以 上，而且实际垃圾收集器进行回收的动作就只占其中的几百毫秒。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<ul>
<li>日志显示当前虚拟机的操作（VM Operation，VMOP）是等待所有用户线程进入到安全点，但是有两个线程特别慢，导致发生了很长时间的<code>自旋等待</code>。</li>
<li>使用int类型或范围更小 的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为<code>可数循环（Counted Loop）</code>，相对应地，使用long或者范围更大的数据类型作为索引值的循环就被称为<code>不可数循环（Uncounted Loop）</code>，将会被放置安全点。把循环索引的数据类型从int改为long即可。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--6 类文件结构</title>
    <url>/2021/05/26/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_6_Class_file_structure.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><code>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</code><br><a id="more"></a></p>
</blockquote>
<h3 id="1-无关性的基石"><a href="#1-无关性的基石" class="headerlink" title="1. 无关性的基石"></a>1. 无关性的基石</h3><p>各种不同平台的Java虚拟机，以及所有平台都统一支持的<u>程序存储格式</u>——<code>字节码（Byte Code）</code>是构成平台无关性的基石。Java虚拟机<strong>不与包括Java语言在内的任何程序语言绑定，它只与<code>“Class文件”</code>这种特定的二进制文件格式所关联</strong>，<code>Class文件</code>中包含了<code>Java虚拟机指令集</code>、<code>符号表</code>以及<code>若干其他辅助信息</code>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JVMLanguageIndependence.PNG" alt="Java虚拟机的语言无关性"></p>
<p>Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，这决定了<u>字节码指令所能提供的语言描述能力比Java语言本身更加强大</u>。</p>
<h3 id="2-Class类文件的结构"><a href="#2-Class类文件的结构" class="headerlink" title="2. Class类文件的结构"></a>2. Class类文件的结构</h3><p><code>Class文件</code>是一组以<code>8</code>个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，<strong>中间没有添加任何分隔符</strong>，这使得<u>整个Class文件中存储的内容几乎全部是程序运行的必要数据</u>，没有空隙存在。遇到需要占用8个字节以上空间的数据项时，则会<strong><code>按照高位在前的方式分割</code></strong>成若干个8个字节进行存储。</p>
<blockquote>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息。反过来说，<strong>类或接口并不一定都得定义在文件里</strong>（譬如类或接口也可以动态生成，直接送入类加载器中）。</p>
</blockquote>
<p>Class文件格式采用一种类似于C语言结构体的<code>伪结构</code>来存储数据，这种伪结构中只有两种数据类型：<code>“无符号数”</code>和<code>“表”</code>。</p>
<ul>
<li><code>无符号数</code>属于<u><strong>基本的数据类型</strong></u>，以<code>u1</code>、<code>u2</code>、<code>u4</code>、<code>u8</code>来分别代表1个字节、2个字节、4个字节和8个 字节的无符号数，可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li><code>表</code>是<u><strong>由多个无符号数或者其他表作为数据项构成的复合数据类型</strong></u>，所有表的命名都习惯性地以<code>“_info”</code>结尾。表用于描述有层次关系的复合结构的数据，<strong><code>整个Class文件本质上也可以视作是一张表</code></strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ClassFileStructure.PNG" alt="Class文件格式"></p>
<h4 id="2-1-魔数与Class文件的版本"><a href="#2-1-魔数与Class文件的版本" class="headerlink" title="2.1 魔数与Class文件的版本"></a>2.1 魔数与Class文件的版本</h4><p>每个Class文件的头4个字节被称为<code>魔数（Magic Number）</code>，它的<strong>唯一作用</strong>是<u><strong>确定这个文件是否为一个能被虚拟机接受的Class文件</strong></u>。</p>
<blockquote>
<p>Class文件的魔数取得很有“浪漫气息”，值为<code>0xCAFEBABE</code>(咖啡宝贝?)</p>
</blockquote>
<p>第5和第6个字节是<code>次版本号（Minor Version）</code>，第7和第8个字节是<code>主版本号（Major Version）</code>。</p>
<blockquote>
<p>Java的版本号是从45开始的。在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p>
</blockquote>
<h4 id="2-2-常量池"><a href="#2-2-常量池" class="headerlink" title="2.2 常量池"></a>2.2 常量池</h4><p>常量池可以比喻为<code>Class</code>文件里的资源仓库，通常也是占用<code>Class</code>文件空间最大的数据项目之一，它还是在Class文件中第一个出现的<code>表类型数据项目</code>。</p>
<p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项<code>u2</code>类型的数据，代表<code>常量池容量计数值（constant_pool_count）</code>。</p>
<blockquote>
<p>Class文件结构中只有常量池的容量计数是<strong>从1开始</strong>。将第0项常量空出来目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达<strong>“不引用任何一个常量池项目”</strong>的含义，可以把索引值设置为0来表示。</p>
</blockquote>
<p>常量池中主要存放两大类常量：<code>字面量（Literal）</code>和<code>符号引用（Symbolic References）</code>。</p>
<ul>
<li>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等；</li>
<li>符号引用则属于编译原理方面的概念，主要包括下面几类常量：<ul>
<li>被模块导出或者开放的包（Package）；</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
</li>
</ul>
<p>常量池中每一项常量都是一个表。这类表都有一个共同的特点，表结构起始的第一位是个<code>u1</code>类型的标志位（<code>tag</code>），代表着当前常量属于哪种常量类型。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ItemTypeOfConstantPool.PNG" alt="常量池的项目类型"></p>
<blockquote>
<p>可以使用用于分析Class文件字节码的工具：<code>javap</code>，输出的<code>TestClass.class</code>文件字节码内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javap -verbose TestClass</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-3-访问标志"><a href="#2-3-访问标志" class="headerlink" title="2.3 访问标志"></a>2.3 访问标志</h4><p><code>访问标志（access_flags）</code>，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；等等。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/accessFlags.PNG" alt="访问标志"></p>
<p>举例：TestClass是一个普通Java类，它的<code>ACC_PUBLIC</code>、<code>ACC_SUPER</code>标志应当为真，其他为假，因此它的<code>access_flags</code>的值应为：<code>0x0001|0x0020=0x0021</code>。</p>
<h4 id="2-4-类索引、父类索引与接口索引集合"><a href="#2-4-类索引、父类索引与接口索引集合" class="headerlink" title="2.4 类索引、父类索引与接口索引集合"></a>2.4 类索引、父类索引与接口索引集合</h4><p><code>类索引（this_class）</code>和<code>父类索引（super_class）</code>都是一个<code>u2</code>类型的数据，而<code>接口索引集合（interfaces）</code>是一组<code>u2</code>类型的数据的集合，Class文件中由这三项数据来确定该<strong><u>类型的继承关系</u></strong>。</p>
<blockquote>
<ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名。父类索引只有一个(不允许多重继承)</li>
<li>接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按<code>implements</code>关键字后的接口顺序从左到右排列在接口索引集合中。</li>
</ul>
</blockquote>
<p>类索引和父类索引用两个<code>u2</code>类型的索引值表示，它们各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过<code>CONSTANT_Class_info</code>类型的常量中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型的常量中的<code>全限定名字符串</code>。</p>
<p>对于接口索引集合，入口的第一项<code>u2</code>类型的数据为<code>接口计数器（interfaces_count）</code>，表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0。</p>
<h4 id="2-5-字段表集合"><a href="#2-5-字段表集合" class="headerlink" title="2.5 字段表集合"></a>2.5 字段表集合</h4><p><code>字段表（field_info）</code>用于描述接口或者类中声明的变量。<code>“字段”（Field）</code>包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/fieldInfo.PNG" alt="字段表结构"></p>
<p><code>name_index</code>和<code>descriptor_index</code>都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p>
<ul>
<li><code>全限定名</code>和<code>简单名称</code>。比如<code>“org/fenixsoft/clazz/TestClass”</code>是类的<code>全限定名</code>；<code>简单名称</code>则就是指没有类型和参数修饰的方法或者字段名称，类中的<code>inc()</code>方法和<code>m</code>字段的简单名称分别就是“<code>inc</code>”和“<code>m</code>”。</li>
<li><code>描述符</code>的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。<ul>
<li>对于数组类型，每一维度将使用一个前置的<code>“[”</code>字符来描述。比如<code>“int[]”</code>将被记录成<code>“[I”</code>。</li>
<li>描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号<code>“()”</code>之内。<code>void inc()</code>的描述符为<code>“()V”</code>。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/descriptor.PNG" alt="描述符"></p>
<blockquote>
<p>字段表集合中不会列出从父类或者父接口中继承而来的字段</p>
</blockquote>
<h4 id="2-6-方法表集合"><a href="#2-6-方法表集合" class="headerlink" title="2.6 方法表集合"></a>2.6 方法表集合</h4><p>对方法的描述与对字段的描述采用了几乎完全一致的方式，依次包括<code>访问标志（access_flags）</code>、<code>名称索引（name_index）</code>、<code>描述符索引（descriptor_index）</code>、<code>属性表集合（attributes）</code>几项。</p>
<blockquote>
<p>父类方法在子类中没有被<code>重写（Override）</code>，方法表集合中就不会出现来自父类的方法信息。</p>
</blockquote>
<h4 id="2-7-属性表集合"><a href="#2-7-属性表集合" class="headerlink" title="2.7 属性表集合"></a>2.7 属性表集合</h4><p>Class文件、字段表、方法表都可以携带自己的<code>属性表集合（attribute_info）</code>。对于每一个属性，它的名称都要从常量池中引用一个<code>CONSTANT_Utf8_info</code>类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个<code>u4</code>的长度属性去说明属性值所占用的位数即可。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/attributeInfo.PNG" alt="属性表结构"></p>
<h5 id="2-7-1-Code属性"><a href="#2-7-1-Code属性" class="headerlink" title="2.7.1 Code属性"></a>2.7.1 Code属性</h5><p>Java程序方法体里面的代码经过<code>Javac</code>编译器处理之后，最终变为字节码指令存储在<code>Code属性</code>内。Code属性出现在方法表的属性集合之中。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/CodeAttributeInfo.PNG" alt="Code属性表的结构"></p>
<ul>
<li><code>attribute_name_index</code>是一项指向<code>CONSTANT_Utf8_info</code>型常量的索引，此常量值<strong>固定为<code>“Code”</code></strong>；</li>
<li><code>attribute_length</code>指示了属性值的长度；</li>
<li><code>max_stack</code>代表了<code>操作数栈（Operand Stack）</code>深度的最大值；</li>
<li><code>max_locals</code>代表了局部变量表所需的存储空间。<code>Javac</code>编译器会根据变量的作用域来分配变量槽给各个变量使用，根据<u><strong>同时生存的最大局部变量数量和类型</strong></u>计算出<code>max_locals</code>的大小。</li>
<li><code>code_length</code>和code用来存储Java源程序编译后生成的字节码指令。<code>code_length</code>代表字节码长度，虽然它是一个<code>u4</code>类型的长度值，理论上最大值可以达到<code>2的32次幂</code>。有可能<strong><u>因为方法生成字节码超长的原因而导致编译失败</u></strong>。</li>
<li>Code属性用于描述代码。<ul>
<li>Java语言里面的潜规则：在任何实例方法里面，都可以通过“<code>this”</code>关键字访问到此方法所属的对象。是通过在<code>Javac</code>编译器编译的时候把对<code>this</code>关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数。所以在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量。</li>
</ul>
</li>
<li>显式异常处理表对于Code属性来说并不是必须存在的。如果存在异常表，它包含<u>四个字段</u>，这些字段的含义为：如果当字节码从第<code>start_pc</code>行到第<code>end_pc</code>行之间（不含第<code>end_pc</code>行）出现了类型为<code>catch_type</code>或者其子类的异常（<code>catch_type</code>为指向一个<code>CONSTANT_Class_info</code>型常量的索引），则转到第<code>handler_pc</code>行继续处理。当 <code>catch_type</code>的值为0时，代表任意异常情况都需要转到<code>handler_pc</code>处进行处理。</li>
</ul>
<h5 id="2-7-2-Exceptions属性"><a href="#2-7-2-Exceptions属性" class="headerlink" title="2.7.2 Exceptions属性"></a>2.7.2 Exceptions属性</h5><p><code>Exceptions属性</code>是在方法表中与Code属性平级的一项属性，作用是列举出方法中可能抛出的<code>受查异常（Checked Excepitons）</code>。</p>
<h5 id="2-7-3-LineNumberTable属性"><a href="#2-7-3-LineNumberTable属性" class="headerlink" title="2.7.3 LineNumberTable属性"></a>2.7.3 LineNumberTable属性</h5><p><code>LineNumberTable</code>属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。</p>
<h5 id="2-7-4-LocalVariableTable及LocalVariableTypeTable属性"><a href="#2-7-4-LocalVariableTable及LocalVariableTypeTable属性" class="headerlink" title="2.7.4 LocalVariableTable及LocalVariableTypeTable属性"></a>2.7.4 LocalVariableTable及LocalVariableTypeTable属性</h5><ul>
<li><code>LocalVariableTable</code>属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。</li>
<li><code>LocalVariableTypeTable</code>把<code>LocalVariableTabl</code>字段描述符的<code>descriptor_index</code>替换成了字段的<code>特征签名（Signature）</code>。泛型引入之后，由于描述符中泛型的参数化类型<code>被擦除掉</code>，描述符就不能准确描述泛型类型了。因此出现了<code>LocalVariableTypeTable</code>属性，<strong><u>使用字段的特征签名来完成泛型的描述</u></strong>。</li>
</ul>
<h5 id="2-7-5-SourceFile及SourceDebugExtension属性"><a href="#2-7-5-SourceFile及SourceDebugExtension属性" class="headerlink" title="2.7.5 SourceFile及SourceDebugExtension属性"></a>2.7.5 SourceFile及SourceDebugExtension属性</h5><p><code>SourceFile</code>属性用于记录生成这个Class文件的源码文件名称。</p>
<p><code>SourceDebugExtension</code>属性用于存储额外的代码调试信息。</p>
<h5 id="2-7-6-ConstantValue属性"><a href="#2-7-6-ConstantValue属性" class="headerlink" title="2.7.6 ConstantValue属性"></a>2.7.6 ConstantValue属性</h5><p><code>ConstantValue</code>属性的作用是通知虚拟机自动为静态变量赋值。只有被<code>static</code>关键字修饰的变量（类变量）才可以使用这项属性。</p>
<h5 id="2-7-7-InnerClasses属性"><a href="#2-7-7-InnerClasses属性" class="headerlink" title="2.7.7 InnerClasses属性"></a>2.7.7 InnerClasses属性</h5><p><code>InnerClasses</code>属性用于记录内部类与宿主类之间的关联。</p>
<h5 id="2-7-8-Deprecated及Synthetic属性"><a href="#2-7-8-Deprecated及Synthetic属性" class="headerlink" title="2.7.8 Deprecated及Synthetic属性"></a>2.7.8 Deprecated及Synthetic属性</h5><ul>
<li><code>Deprecated</code>属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用<code>“@deprecated”</code>注解进行设置；</li>
<li><code>Synthetic</code>属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的。</li>
</ul>
<blockquote>
<p><code>Deprecated</code>和<code>Synthetic</code>两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</p>
</blockquote>
<h5 id="2-7-9-StackMapTable属性"><a href="#2-7-9-StackMapTable属性" class="headerlink" title="2.7.9 StackMapTable属性"></a>2.7.9 StackMapTable属性</h5><p><code>StackMapTable</code>属性会在虚拟机类加载的字节码验证阶段被<code>新类型检查验证器（Type Checker）</code>使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p>
<h5 id="5-7-10-Signature属性"><a href="#5-7-10-Signature属性" class="headerlink" title="5.7.10 Signature属性"></a>5.7.10 Signature属性</h5><p><code>Signature</code>属性记录泛型类型，是因为Java语言的泛型采用的是<code>擦除法</code>实现的伪泛型，字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。</p>
<blockquote>
<ul>
<li>使用擦除法的好处是实现简单（主要修改<code>Javac</code>编译器，虚拟机内部只做了很少的改动）、非常容易实现<code>Backport</code>，运行期也能够节省一些类型所占的内存空间。</li>
<li>坏处是运行期就无法像有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待</li>
</ul>
</blockquote>
<h5 id="2-7-11-BootstrapMethods属性"><a href="#2-7-11-BootstrapMethods属性" class="headerlink" title="2.7.11 BootstrapMethods属性"></a>2.7.11 BootstrapMethods属性</h5><p><code>BootstrapMethods</code>属性用于保存<code>invokedynamic</code>指令引用的引导方法限定符。</p>
<h5 id="2-7-12-MethodParameters属性"><a href="#2-7-12-MethodParameters属性" class="headerlink" title="2.7.12 MethodParameters属性"></a>2.7.12 MethodParameters属性</h5><p><code>MethodParameters</code>的作用是记录方法的各个形参名称和信息。</p>
<h5 id="2-7-13-模块化相关属性"><a href="#2-7-13-模块化相关属性" class="headerlink" title="2.7.13 模块化相关属性"></a>2.7.13 模块化相关属性</h5><p><code>模块描述文件（module-info.java）</code>最终是要编译成一个独立的Class文件来存储的，所以Class文件格式也扩展了<code>Module</code>、<code>ModulePackages</code>和<code>ModuleMainClass</code>三个属性用于支持Java模块化相关功能。</p>
<ul>
<li><code>Module</code>属性除了表示该模块的名称、版本、标志信息以外，还存储了这个模块requires、exports、opens、uses和provides定义的全部内容；</li>
<li><code>ModulePackages</code>用于描述该模块中所有的包</li>
<li><code>ModuleMainClass</code>用于确定该模块的<code>主类（Main Class）</code></li>
</ul>
<h5 id="2-7-14-运行时注解相关属性"><a href="#2-7-14-运行时注解相关属性" class="headerlink" title="2.7.14 运行时注解相关属性"></a>2.7.14 运行时注解相关属性</h5><p>为了存储源码中注解信息，Class文件同步增加了</p>
<ul>
<li><code>RuntimeVisibleAnnotations</code>；</li>
<li><code>RuntimeInvisibleAnnotations</code>；</li>
<li><code>RuntimeVisibleParameterAnnotations</code>；</li>
<li><code>RuntimeInvisibleParameterAnnotations</code></li>
</ul>
<p>后来又新增类型注解 （JSR 308）：</p>
<ul>
<li><code>RuntimeVisibleTypeAnnotations</code></li>
<li><code>RuntimeInvisibleTypeAnnotations</code></li>
</ul>
<p><code>RuntimeVisibleAnnotations</code>记录了类、字段或方法的声明上记录运行时可见注解，当我们使用<code>反射API</code>来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。</p>
<h3 id="3-字节码指令简介"><a href="#3-字节码指令简介" class="headerlink" title="3. 字节码指令简介"></a>3. 字节码指令简介</h3><p>Java虚拟机的指令由<u><strong>一个字节长度的</strong>、<strong>代表着某种特定操作含义</strong></u>的数字（称为<code>操作码，Opcode</code>）以及跟随其后的零至多个代表<strong>此操作所需的参数</strong>（称为<code>操作数，Operand</code>）构成。</p>
<p>如果不考虑异常处理的话，那Java虚拟机的解释器可以使用下面这段伪代码作为最基本的执行模型来理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    自动计算PC寄存器的值加<span class="number">1</span>;</span><br><span class="line">    根据PC寄存器指示的位置，从字节码流中取出操作码;</span><br><span class="line">    <span class="keyword">if</span> (字节码存在操作数) 从字节码流中取出操作数;</span><br><span class="line">    执行操作码所定义的操作;</span><br><span class="line">&#125; <span class="keyword">while</span> (字节码流长度 &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="3-1-字节码与数据类型"><a href="#3-1-字节码与数据类型" class="headerlink" title="3.1 字节码与数据类型"></a>3.1 字节码与数据类型</h4><p>Java虚拟机的指令集中，<strong>大多数指令都包含其操作所对应的数据类型信息</strong>。</p>
<blockquote>
<p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：<code>i</code>代表对<code>int</code>类型的数据操作，<code>l</code>代表<code>long</code>，<code>s</code>代表<code>short</code>，<code>b</code>代表<code>byte</code>，<code>c</code>代表<code>char</code>，<code>f</code>代表<code>float</code>，<code>d</code>代表<code>double</code>，<code>a</code>代表<code>reference</code>。</p>
</blockquote>
<p>Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，即指令集将会被故意设计成非完全独立的。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</p>
<h4 id="3-2-加载和存储指令"><a href="#3-2-加载和存储指令" class="headerlink" title="3.2 加载和存储指令"></a>3.2 加载和存储指令</h4><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输：</p>
<ul>
<li>将一个局部变量加载到操作栈：<code>load</code>、<code>iload_&lt;n&gt;</code>、<code>lload</code>、<code>lload_&lt;n&gt;</code>、<code>fload</code>、<code>fload_&lt;n&gt;</code>、<code>dload</code>、<code>dload_&lt;n&gt;</code>、<code>aload</code>、<code>aload_&lt;n&gt;</code>；</li>
<li>将一个数值从操作数栈存储到局部变量表：<code>istore</code>、<code>istore_&lt;n&gt;</code>、<code>lstore</code>、<code>lstore_&lt;n&gt;</code>、<code>fstore</code>、<code>fstore_&lt;n&gt;</code>、<code>dstore</code>、<code>dstore_&lt;n&gt;</code>、<code>astore</code>、<code>astore_&lt;n&gt;</code>；</li>
<li>将一个常量加载到操作数栈：<code>bipush</code>、<code>sipush</code>、<code>ldc</code>、<code>ldc_w</code>、<code>ldc2_w</code>、<code>aconst_null</code>、<code>iconst_m1</code>、<code>iconst_&lt;i&gt;</code>、<code>lconst_&lt;l&gt;</code>、<code>fconst_&lt;f&gt;</code>、<code>dconst_&lt;d&gt;</code></li>
<li>扩充局部变量表的访问索引的指令：<code>wide</code></li>
</ul>
<p>是以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>）指令助记符实际上代表了一组指令，某个带有一个操作数的通用指令（例如<code>iload</code>）的特殊形式。省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中。</p>
<h4 id="3-3-运算指令"><a href="#3-3-运算指令" class="headerlink" title="3.3 运算指令"></a>3.3 运算指令</h4><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶：</p>
<ul>
<li>对整型数据进行运算的指令</li>
<li>对浮点型数据进行运算的指令</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ArithmeticInstructions.PNG" alt="算术指令"></p>
<h4 id="3-4-类型转换指令"><a href="#3-4-类型转换指令" class="headerlink" title="3.4 类型转换指令"></a>3.4 类型转换指令</h4><p>类型转换指令可以<strong><u>将两种不同的数值类型相互转换</u></strong>，这些转换操作一般用于：</p>
<ul>
<li>实现用户代码中的显式类型转换操作；</li>
<li>处理字节码指令集中数据类型相关指令无法与数据类型 一一对应的问题。</li>
</ul>
<p>Java虚拟机<strong><u>直接支持（即转换时无须显式的转换指令）</u></strong>以下数值类型的<code>宽化类型转换（Widening Numeric Conversion）</code>：</p>
<ul>
<li>int类型到long、float或者double类型</li>
<li>long类型到float、double类型</li>
<li>float类型到double类型</li>
</ul>
<p>处理<code>窄化类型转换（Narrowing Numeric Conversion）</code>时，就必须显式地使用转换指令来完成，这些转换指令包括<code>i2b</code>、<code>i2c</code>、<code>i2s</code>、<code>l2i</code>、<code>f2i</code>、<code>f2l</code>、<code>d2i</code>、<code>d2l</code>和<code>d2f</code>。</p>
<h4 id="3-5-对象创建与访问指令"><a href="#3-5-对象创建与访问指令" class="headerlink" title="3.5 对象创建与访问指令"></a>3.5 对象创建与访问指令</h4><p>对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ObjectInstructions.PNG" alt="对象创建与访问指令"></p>
<h4 id="3-6-操作数栈管理指令"><a href="#3-6-操作数栈管理指令" class="headerlink" title="3.6 操作数栈管理指令"></a>3.6 操作数栈管理指令</h4><p>Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p>
<ul>
<li>将操作数栈的栈顶一个或两个元素出栈：<code>pop</code>、<code>pop2</code></li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：<code>dup</code>、<code>dup2</code>、<code>dup_x1</code>、<code>dup2_x1</code>、<code>dup_x2</code>、<code>dup2_x2</code></li>
<li>将栈最顶端的两个数值互换：<code>swap</code></li>
</ul>
<h4 id="4-7-控制转移指令"><a href="#4-7-控制转移指令" class="headerlink" title="4.7 控制转移指令"></a>4.7 控制转移指令</h4><p>控制转移指令可以让Java虚拟机<strong><u>有条件</u></strong>或<strong><u>无条件</u></strong>地从指定位置指令（而不是控制转移指令）的下 一条指令继续执行程序。控制转移指令包括：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ControlTransferInstruction.PNG" alt="控制转移指令"></p>
<h4 id="4-8-方法调用和返回指令"><a href="#4-8-方法调用和返回指令" class="headerlink" title="4.8 方法调用和返回指令"></a>4.8 方法调用和返回指令</h4><p>方法调用（分派、执行过程）的指令：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/MethodCallAndReturnInstructions.PNG" alt="方法调用和返回指令"></p>
<h4 id="4-9-异常处理指令"><a href="#4-9-异常处理指令" class="headerlink" title="4.9 异常处理指令"></a>4.9 异常处理指令</h4><p>而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用<code>jsr</code>和 <code>ret</code>指令来实现，现在已经不用了），而是<strong><u>采用异常表来完成</u></strong>。</p>
<h4 id="4-10-同步指令"><a href="#4-10-同步指令" class="headerlink" title="4.10 同步指令"></a>4.10 同步指令</h4><p>支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用<code>管程</code>（<code>Monitor</code>，更常见的是直接将它称为<code>“锁”</code>）来实现的。</p>
<ul>
<li>方法级的同步是<strong>隐式的</strong>，<u>无须通过字节码指令来控制</u>，它实现在方法调用和返回操作之中。调用指令将会检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成时释放管程。</li>
<li>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持synchronized关键字的语义</li>
</ul>
<h3 id="5-公有设计，私有实现"><a href="#5-公有设计，私有实现" class="headerlink" title="5. 公有设计，私有实现"></a>5. 公有设计，私有实现</h3><p>任何一款Java虚拟机实现都必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。在此前提下，虚拟机实现者可以使用让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--7 虚拟机类加载机制</title>
    <url>/2021/05/27/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_7_Virtual_machine_class_loading_mechanism.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>在Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。<br><a id="more"></a></p>
</blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的<code>类加载机制</code>。</p>
<h3 id="1-类加载的时机"><a href="#1-类加载的时机" class="headerlink" title="1. 类加载的时机"></a>1. 类加载的时机</h3><p>一个类型<strong><u>从被加载到虚拟机内存中开始，到卸载出内存为止</u></strong>，它的整个生命周期将会经历七个阶段:</p>
<ul>
<li>加载（Loading）</li>
<li>验证（Verification）</li>
<li>准备（Preparation）</li>
<li>解析（Resolution）</li>
<li>初始化 （Initialization）</li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<p>其中验证、准备、解析三个部分统称为连接（Linking）。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ClassLifeCycle.PNG" alt="类的生命周期"></p>
<blockquote>
<p>解析阶在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的<code>运行时绑定</code>特性（也称为<code>动态绑定</code>或<code>晚期绑定</code>）。</p>
</blockquote>
<p>只有六种情况必须立即对类进行<code>“初始化”</code>（而加载、验证、准备自然需要在此之前开始）：</p>
<ul>
<li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段；</li>
<li>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化；</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；<ul>
<li>一个<code>接口</code>在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li>
</ul>
</li>
<li>当虚拟机启动时，用户需要指定一个要执行的<code>主类（包含main()方法的那个类）</code>，虚拟机会先初始化这个主类；</li>
<li>当使用<code>JDK 7</code>新加入的<code>动态语言支持</code>时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析的方法句柄对应的类没有进行过初始化，则需要先触发其初始化；</li>
<li>当一个接口中定义了<code>JDK 8</code>新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化；</li>
</ul>
<h3 id="2-类加载的过程"><a href="#2-类加载的过程" class="headerlink" title="2. 类加载的过程"></a>2. 类加载的过程</h3><h4 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h4><p><code>“加载”（Loading）</code>阶段是整个<code>“类加载”（Class Loading）</code>过程中的一个阶段，在加载阶段，Java虚拟机需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的<code>二进制字节流</code>。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的<code>findClass()</code>或<code>loadClass()</code>方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p>
<h4 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是<u>确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</u>。从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节 码验证和符号引用验证。</p>
<h5 id="2-2-1-文件格式验证"><a href="#2-2-1-文件格式验证" class="headerlink" title="2.2.1 文件格式验证"></a>2.2.1 文件格式验证</h5><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p>
<p>该验证阶段的主要目的是<u><strong>保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。</strong></u>这阶段的验证是<strong>基于二进制字节流进行的</strong>，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储。</p>
<h5 id="2-2-2-元数据验证"><a href="#2-2-2-元数据验证" class="headerlink" title="2.2.2 元数据验证"></a>2.2.2 元数据验证</h5><p>对字节码描述的信息进行<code>语义分析</code>，以保证其描述的信息符合《Java语言规范》的要求。</p>
<h5 id="2-2-3-字节码验证"><a href="#2-2-3-字节码验证" class="headerlink" title="2.2.3 字节码验证"></a>2.2.3 字节码验证</h5><p>通过<code>数据流分析</code>和<code>控制流分析</code>，确定程序语义是合法的、符合逻辑的。</p>
<p>这阶段对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。</p>
<h5 id="2-2-4-符号引用验证"><a href="#2-2-4-符号引用验证" class="headerlink" title="2.2.4 符号引用验证"></a>2.2.4 符号引用验证</h5><p>符号引用验证可以看作是<strong><u>对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验</u></strong>，即该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p>
<p>该校验过程发生在虚拟机<u>将符号引用转化为直接引用</u>的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</p>
<h4 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3 准备"></a>2.3 准备</h4><p>准备阶段是正式<u><strong>为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值</strong></u>的阶段。</p>
<p>两个容易产生混淆的概念：</p>
<ul>
<li>此时进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</li>
<li>这里所说的初始值“通常情况”下是<code>数据类型的零值</code>。<ul>
<li>比如对于<code>public static int value = 123;</code>，变量value在准备阶段过后的初始值为0，把 <code>value</code>赋值为<code>123</code>的<code>putstatic</code>指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中，所以把<code>value</code>赋值为<code>123</code>的动作要到<strong>类的初始化阶段</strong>才会被执行。</li>
<li>如果类字段的字段属性表中存在<code>ConstantValue</code>属性，那在准备阶段变量值就会被初始化为<code>ConstantValue</code>属性所指定的初始值(比如<code>public static final int value = 123;</code>)</li>
</ul>
</li>
</ul>
<h4 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 解析</h4><p>解析阶段是Java虚拟机<strong>将常量池内的符号引用替换为直接引用</strong>的过程。</p>
<ul>
<li><code>符号引用（Symbolic References）</code>：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的<strong>字面量</strong>，只要使用时能无歧义地定位到目标即可。<ul>
<li>符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。</li>
</ul>
</li>
<li><code>直接引用（Direct References）</code>：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。<ul>
<li>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</li>
<li>如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li>
</ul>
</li>
</ul>
<p>虚拟机实现可以对第一次解析的结果进行缓存(除<code>invokedynamic</code>指令以外)，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。无论是否真正执行了多次解析动作，Java虚拟机都需要保证的是在同一个实体中：</p>
<ul>
<li>如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功；</li>
<li>如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功加载进Java虚拟机内存之中。 </li>
</ul>
<p>对于<code>invokedynamic</code>指令，上面的规则就不成立了。当碰到某个前面已经由<code>invokedynamic</code>指令触发过解析的符号引用时，并不意味着这个解析结果对于其他<code>invokedynamic</code>指令也同样生效。</p>
<ul>
<li><code>invokedynamic</code>指令的目的本来就是用于动态语言支持，它对应的引用称为<code>“动态调用点限定符 （Dynamically-Computed Call Site Specifier）”</code>，这里<code>“动态”</code>的含义是指<u><strong>必须等到程序实际运行到这条指令时，解析动作才能进行</strong></u>。</li>
</ul>
<p>解析动作主要针对<u><strong>类或接口</strong></u>、<u><strong>字段</strong></u>、<u><strong>类方法</strong></u>、<u><strong>接口方法</strong></u>、<u><strong>方法类型</strong></u>、<u><strong>方法句柄</strong></u>和<u><strong>调用点限定符</strong></u>这7类符号引用进行。</p>
<h5 id="2-4-1-类或接口的解析"><a href="#2-4-1-类或接口的解析" class="headerlink" title="2.4.1 类或接口的解析"></a>2.4.1 类或接口的解析</h5><p>假设当前代码所处的类为<code>D</code>，如果要把一个从未解析过的符号引用<code>N</code>解析为一个类或接口<code>C</code>的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p>
<ol>
<li>如果<code>C</code>不是一个数组类型，那虚拟机将会把代表<code>N</code>的全限定名传递给<code>D</code>的类加载器去加载这个类<code>C</code>。</li>
<li>如果<code>C</code>是一个数组类型，并且数组的元素类型为对象，也就是<code>N</code>的描述符会是类似“<code>[Ljava/lang/Integer</code>”的形式，那将会按照第一点的规则加载数组元素类型。</li>
<li>如果上面两步没有出现任何异常，那么<code>C</code>在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认<code>D</code>是否具备对<code>C</code>的访问权限。如果发现不具备访问权限， 将抛出<code>java.lang.IllegalAccessError</code>异常。</li>
</ol>
<p>如果我们说一个<code>D</code>拥有<code>C</code>的访问权限，那就意味着以下3条规则中至少有其中一条成立：</p>
<ul>
<li>被访问类<code>C</code>是<code>public</code>的，并且与访问类<code>D</code>处于同一个模块。</li>
<li>被访问类<code>C</code>是<code>public</code>的，不与访问类<code>D</code>处于同一个模块，但是<code>被访问类C</code>的模块允许<code>访问类D</code>的模块进行访问。 </li>
<li>被访问类<code>C</code>不是<code>public</code>的，但是它与访问类<code>D</code>处于同一个包中。</li>
</ul>
<h5 id="2-4-2-字段解析"><a href="#2-4-2-字段解析" class="headerlink" title="2.4.2 字段解析"></a>2.4.2 字段解析</h5><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内<code>class_index</code>项中索引的<code>CONSTANT_Class_info</code>符号引用进行解析，也就是<strong><u>字段所属的类或接口的符号引用</u></strong>。</p>
<p>如果解析成功完成，那把这个字段所属的类或接口用<code>C</code>表示，按照如下步骤对C进行后续字段的搜索：</p>
<ol>
<li>如果<code>C</code>本身就包含了<strong>简单名称</strong>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>如果在<code>C</code>中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口， 如果接口中包含了<strong>简单名称</strong>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>如果<code>C</code>不是<code>java.lang.Object</code>的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了<code>简单名称</code>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出<code>java.lang.NoSuchFieldError</code>异常。</li>
</ol>
<p>如果查找过程成功返回了引用，将会对这个字段进行权限验证。</p>
<h5 id="2-4-3-方法解析"><a href="#2-4-3-方法解析" class="headerlink" title="2.4.3 方法解析"></a>2.4.3 方法解析</h5><p>方法解析的第一个步骤也是需要先解析出方法表的<code>class_index</code>项中索引的方法所属的类或接口的符号引用，如果解析成功，那么依然用<code>C</code>表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：</p>
<ol>
<li>由于Class文件格式中<strong><u>类的方法和接口的方法符号引用的常量类型定义是分开的</u></strong>，如果在类的方法表中发现<code>class_index</code>中索引的<code>C</code>是个接口的话，那就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li>
<li>在类<code>C</code>中查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>在类<code>C</code>的父类中递归查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>在类<code>C</code>实现的接口列表及它们的父接口之中递归查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果存在匹配的方法，说明类<code>C</code>是一个抽象类，这时候查找结束，抛出<code>java.lang.AbstractMethodError</code>异常。</li>
<li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>。 </li>
</ol>
<p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证。</p>
<h5 id="2-4-4-接口方法解析"><a href="#2-4-4-接口方法解析" class="headerlink" title="2.4.4 接口方法解析"></a>2.4.4 接口方法解析</h5><p>接口方法也是需要先解析出接口方法表的<code>class_index</code>项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用<code>C</code>表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p>
<ol>
<li>与类的方法解析相反，如果在接口方法表中发现<code>class_index</code>中的索引<code>C</code>是个类而不是接口，那么就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li>
<li>在接口<code>C</code>中查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>在接口<code>C</code>的父接口中递归查找，直到<code>java.lang.Object</code>类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。<ul>
<li>由于Java的<u>接口允许多重继承</u>，如果C的不同父接口中存有<u>多个</u><strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，不同发行商实现的<code>Javac</code>编译器有可能会按照<u><strong>更严格的约束拒绝编译这种代码来避免不确定性</strong></u>。</li>
</ul>
</li>
<li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</li>
</ol>
<blockquote>
<ul>
<li>在<code>JDK 9</code>之前，Java接口中的所有方法都<u>默认是<code>public</code>的</u>，也没有模块化的访问约束，所以不存在访问权限的问题。</li>
<li>但在<code>JDK 9</code>中增加了<u>接口的静态私有方法</u>，也有了模块化的访问约束，所以接口方法的访问也完全有可能因访问权限控制而出现<code>java.lang.IllegalAccessError</code>异常。</li>
</ul>
</blockquote>
<h4 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h4><blockquote>
<p>直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p>
</blockquote>
<p>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<blockquote>
<p><code>&lt;clinit&gt;()</code>并不是程序员在Java代码中直接编写的方法，它是<code>Javac</code>编译器的自动生成物。</p>
</blockquote>
<p><code>&lt;clinit&gt;()</code>方法是由编译器<u>自动收集</u>类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块（static{}块）中的语句</strong>合并产生的。</p>
<ul>
<li><code>&lt;clinit&gt;()</code>方法不需要显式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。意味着父类中定义的静态语句块要优先于子类的变量赋值操作；</li>
<li><code>&lt;clinit&gt;()</code>方法不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法</li>
<li>执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，接口的<strong><u>实现类</u></strong>在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法；</li>
<li>Java虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法方法在多线程环境中被正确地加锁同步。</li>
<li>同一个类加载器下，一个类型只会被初始化一次。</li>
</ul>
<h3 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3. 类加载器"></a>3. 类加载器</h3><p>实现<code>“通过一个类的全限定名来获取描述该类的二进制字节流”</code>这个动作的代码被称为<code>“类加载器”（Class Loader）</code>。</p>
<h4 id="3-1-类与类加载器"><a href="#3-1-类与类加载器" class="headerlink" title="3.1 类与类加载器"></a>3.1 类与类加载器</h4><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的<strong><u>唯一性</u></strong>，每一个类加载器都拥有一个独立的类名称空间。</p>
<blockquote>
<p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，只要加载它们的类加载器不同，那这两个类就<strong>必定不相等</strong>。</p>
</blockquote>
<h4 id="3-2-双亲委派模型"><a href="#3-2-双亲委派模型" class="headerlink" title="3.2 双亲委派模型"></a>3.2 双亲委派模型</h4><p>Java虚拟机的角度来看，只存在两种不同的类加载器：</p>
<ul>
<li><code>启动类加载器（Bootstrap ClassLoader）</code>，这个类加载器是虚拟机自身的一部分；</li>
<li>其他所有的类加载器，这些类加载器都由Java语言实现，<strong><u>独立存在于虚拟机外部</u></strong>，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。</li>
</ul>
<p>Java开发人员的角度来看，类加载器是<code>三层类加载器</code>、<code>双亲委派</code>的类加载架构：</p>
<ul>
<li><code>启动类加载器（Bootstrap Class Loader）</code>：负责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用；</li>
<li><code>扩展类加载器（Extension Class Loader）</code>：负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库。这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoader</code>中以Java代码的形式实现的。</li>
<li><code>应用程序类加载器（Application Class Loader）</code>：负责加载用户类路径<code>（ClassPath）</code>上所有的类库，由 <code>sun.misc.Launcher$AppClassLoader</code>来实现。</li>
</ul>
<p><u><code>JDK 9</code>之前</u>的Java应用都是由这三种类加载器互相配合来完成加载的，用户可以加入自定义的类加载器来进行拓展，如：</p>
<ul>
<li>增加除了磁盘位置之外的Class文件来源</li>
<li>通过类加载器实现类的隔离、重载等功能。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ParentsDelegation.PNG" alt="双亲委派模型"></p>
<p><code>“双亲委派模型（Parents Delegation Model）”</code>要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
<blockquote>
<p>类加载器之间的父子关系一般不是以<code>继承（Inheritance）</code>来实现的，而是通常使用<code>组合（Composition）</code>关系来复用父加载器的代码。</p>
</blockquote>
<p>双亲委派模型的工作过程是：</p>
<ul>
<li>如果一个类加载器收到了类加载的请求，首先把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中；</li>
<li>只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</li>
</ul>
<h4 id="3-3-破坏双亲委派模型"><a href="#3-3-破坏双亲委派模型" class="headerlink" title="3.3 破坏双亲委派模型"></a>3.3 破坏双亲委派模型</h4><p>直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况：</p>
<ul>
<li>第一次“被破坏”其实发生在双亲委派模型出现之前——即<code>JDK 1.2</code>面世以前。</li>
<li>第二次“被破坏”是由这个模型自身的缺陷导致的，有基础类型要调用回用户的代码。</li>
<li>第三次“被破坏”是由于用户对程序动态性的追求而导致的。</li>
</ul>
<p><code>OSGi</code>实现模块化热部署的关键是<u><strong>它自定义的类加载器机制的实现</strong></u>：</p>
<ul>
<li>每一个程序模块（<code>OSGi</code>中称为<code>Bundle</code>）都有一个自己的类加载器，当需要更换一个<code>Bundle</code>时，就把<code>Bundle</code>连同类加载器一起换掉以实现代码的热替换。</li>
</ul>
<p>在<code>OSGi</code>环境下，类加载器发展为更加复杂的网状结构，当收到类加载请求时，<code>OSGi</code>将按照下面的顺序进行类搜索：</p>
<ol>
<li>将以<code>java.*</code>开头的类，委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类，委派给父类加载器加载。</li>
<li>否则，将<code>Import</code>列表中的类，委派给<code>Export</code>这个类的<code>Bundle</code>的类加载器加载。</li>
<li>否则，查找当前<code>Bundle</code>的<code>ClassPath</code>，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的<code>Fragment Bundle</code>中，如果在，则委派给<code>Fragment Bundle</code>的类加载器加载。</li>
<li>否则，查找<code>Dynamic Import</code>列表的<code>Bundle</code>，委派给对应<code>Bundle</code>的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
<h3 id="4-Java模块化系统"><a href="#4-Java模块化系统" class="headerlink" title="4. Java模块化系统"></a>4. Java模块化系统</h3><p><code>JDK 9</code>中引入的<code>Java模块化系统（Java Platform Module System，JPMS）</code>能够实现模块化的关键目标——可配置的封装隔离机制。<code>JDK 9</code>的模块除了简单地充当代码的容器，还包含以下内容：</p>
<ul>
<li>依赖其他模块的列表。</li>
<li>导出的包列表，即其他模块可以使用的列表。</li>
<li>开放的包列表，即其他模块可反射访问模块的列表。</li>
<li>使用的服务列表。</li>
<li>提供服务的实现列表。</li>
</ul>
<p><u><strong>可配置的封装隔离机制</strong></u>解决了：</p>
<ul>
<li><code>JDK 9</code>之前基于<code>类路径（ClassPath）</code>来查找依赖的<strong>可靠性问题</strong>。</li>
<li>原来类路径上跨<code>JAR</code>文件的<code>public</code>类型的<strong>可访问性问题</strong>。</li>
</ul>
<h4 id="4-1-模块的兼容性"><a href="#4-1-模块的兼容性" class="headerlink" title="4.1 模块的兼容性"></a>4.1 模块的兼容性</h4><p><code>JDK 9</code>提出了与<code>“类路径”（ClassPath）</code>相对应的<code>“模块路径”（ModulePath）</code>的概念，使<u><strong>可配置的封装隔离机制</strong></u>能够兼容传统的类路径查找机制。</p>
<p>模块化系统将按照以下规则来保证使用传统类路径依赖的Java程序可以不经修改地直接运行在<code>JDK 9</code>及以后的Java版本上：</p>
<ul>
<li><strong>JAR文件在类路径的访问规则</strong>：所有类路径下的<code>JAR</code>文件及其他资源文件，都被视为自动打包在一个<code>匿名模块（Unnamed Module）</code>里，这个匿名模块<strong>几乎是没有任何隔离的</strong>，它可以看到和使用<u>类路径上所有的包</u>、<u>JDK系统模块中所有的导出包</u>，以及<u>模块路径上所有模块中导出的包</u>。</li>
<li><strong>模块在模块路径的访问规则</strong>：模块路径下的<code>具名模块（Named Module）</code>只能访问到它<u>依赖定义中列明依赖的模块和包</u>，匿名模块里所有的内容对具名模块来说都是不可见的，即<strong><u>具名模块看不见传统JAR包的内容</u></strong>。</li>
<li><strong>JAR文件在模块路径的访问规则</strong>：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个<code>自动模块（Automatic Module）</code>。尽管不包含<code>module-info.class</code>，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到<u>所有模块导出的</u>包，自动模块也<strong>默认导出自己所有的包</strong>。</li>
</ul>
<h4 id="4-2-模块化下的类加载器"><a href="#4-2-模块化下的类加载器" class="headerlink" title="4.2 模块化下的类加载器"></a>4.2 模块化下的类加载器</h4><p><code>JDK 9</code>为了模块化系统的顺利施行，模块化下的类加载器发生了一些变动，主要包括以下几个方面：</p>
<ul>
<li><code>扩展类加载器（Extension Class Loader）</code>被<code>平台类加载器（Platform Class Loader）</code>取代。</li>
<li><code>平台类加载器</code>和<code>应用程序类加载器</code>都不再派生自<code>java.net.URLClassLoader</code>，现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 <code>jdk.internal.loader.BuiltinClassLoader</code>。<code>BuiltinClassLoader</code>中实现了新的模块化架构下<u>类如何从模块中加载的逻辑</u>，以及<u>模块中资源可访问性的处理</u>。</li>
<li><code>JDK 9</code>中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。<ul>
<li>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类<u>是否能够归属到某一个系统模块中</u>，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JDK9ClassLoaderDelegation.PNG" alt="JDK 9后的类加载器委派关系"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--10. Regular Expression Matching</title>
    <url>/2019/04/07/LeetCode--10-Regular-Expression-Matching.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an input string (s) and a pattern (p), implement regular expression matching with support for <strong>‘.’</strong> and <strong>‘*’</strong>.<br><a id="more"></a></p>
<ul>
<li>‘.’ Matches any single character.</li>
<li>‘*’ Matches zero or more of the preceding element.</li>
</ul>
<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<ul>
<li>s could be empty and contains only lowercase letters a-z.</li>
<li>p could be empty and contains only lowercase letters a-z, and characters like . or *.</li>
</ul>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input:<br>s = “aa”<br>p = “a*“<br>Output: true<br>Explanation: ‘*‘ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input:<br>s = “ab”<br>p = “.*“<br>Output: true<br>Explanation: “.*“ means “zero or more (*) of any character (.)”.</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input:<br>s = “aab”<br>p = “c*a*b”<br>Output: true<br>Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”.</p>
</blockquote>
<p><strong>Example 5:</strong></p>
<blockquote>
<p>Input:<br>s = “mississippi”<br>p = “mis*is*p*.”<br>Output: false</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题主要是看了题目的题解后才解出来的，这里就主要对这道题总结一下。一种直观的方法是<br>使用递归求解，我们发现在进行匹配时有如下考虑：</p>
<blockquote>
<ol>
<li>如果没有”*“，那么我们可以简单的从左到右逐个字符比较，判断是否匹配；</li>
<li>如果有”*“，我们需要检查各种可能的情况，观察是否存在一种匹配的扩展方式。</li>
</ol>
</blockquote>
<p>所以可以看出递归是一种简单直观的实现方式。如果存在”*“，那么它必定出现在一个字符后面。我们要么忽略这段表达式(即假设它重复0次)，要么从字符串S中后移一位(即假设它重复至少1次)。在匹配完所有情况后，若有匹配成功的情况，那么就匹配成功了。</p>
<p>这种方法尽管简单，但是效率不高。一种优化的解法是，我们将中间结果保存起来，不使用递归。这样可以省略大量的计算。这种方法也就是DP算法，定义DP[i][j]如下：若S[0:i]与P[0:j]匹配，那么DP[i][j]值为真；否者，值为假。</p>
<blockquote>
<ol>
<li>dp[i][j] = dp[i - 1][j - 1], if p[j - 1] != ‘*’ &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’);</li>
<li>dp[i][j] = dp[i][j - 2], if p[j - 1] == ‘*’ 且表达式重复0次;</li>
<li>dp[i][j] = dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == ‘.’), if p[j - 1] == ‘*’ 且表达式重复至少1次.</li>
</ol>
</blockquote>
<p><strong>参考文献：</strong><a href="https://leetcode.com/problems/regular-expression-matching/discuss/5684/9-lines-16ms-c-dp-solutions-with-explanations" target="_blank" rel="noopener" title="C++ O(n)-space DP">C++ O(n)-space DP</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.empty()) <span class="keyword">return</span> s.empty();</span><br><span class="line">        <span class="keyword">bool</span> first_match = (!s.empty() &amp;&amp; (p[<span class="number">0</span>] == s[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p.length() &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p.substr(<span class="number">2</span>)) || (first_match &amp;&amp; isMatch(s.substr(<span class="number">1</span>),p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; isMatch(s.substr(<span class="number">1</span>),p.substr(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="DP算法"><a href="#DP算法" class="headerlink" title="DP算法"></a>DP算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length(),plen=p.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(slen+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(plen+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= slen; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">'*'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-2</span>] || (i &amp;&amp; dp[i<span class="number">-1</span>][j] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">'.'</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = i &amp;&amp; dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">'.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法三-Bottom-Up-Variation"><a href="#解法三-Bottom-Up-Variation" class="headerlink" title="解法三 (Bottom-Up Variation)"></a>解法三 (Bottom-Up Variation)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.length()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(p.length()+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        dp[s.length()][p.length()] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length();i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = p.length()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> first_match = (i&lt; s.length() &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'.'</span>));</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span> &lt; p.length() &amp;&amp; p[j+<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">2</span>] || first_match &amp;&amp; dp[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = first_match &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--2 Java内存区域与内存溢出异常</title>
    <url>/2021/05/12/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_2_Java_memory_area.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code><br><a id="more"></a></p>
</blockquote>
<p>在<code>Java</code>虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的<code>delete/free</code>代码，不容易出现内存泄漏和内存溢出问题。</p>
<p>但也因此，如果不了解虚拟机是怎样使用内存的，一旦出现内存泄漏和溢出方面的问题，那排查错误、修正问题将会成为一项异常艰难的工作。</p>
<h3 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1 运行时数据区域"></a>1 运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为<strong>若干个不同的数据区域</strong>。这些区域有各自的用途，以及创建和销毁的时间，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/runtimeDataArea.PNG" alt="Java虚拟机运行时数据区"></p>
<h4 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h4><p><code>程序计数器（Program Counter Register）</code>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。字节码解释器工作时就是通过改变这个计数器的值来<strong>选取下一条需要执行的字节码指令</strong>。</p>
<blockquote>
<p>程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
</blockquote>
<p>Java虚拟机的多线程是通过<strong>线程轮流切换、分配处理器执行时间</strong>的方式来实现的，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</p>
<blockquote>
<p>这类内存区域为“线程<code>私有</code>”的内存</p>
</blockquote>
<p>如果线程正在执行的是一个<code>Java方法</code>，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<code>本地（Native）方法</code>，这个计数器值则应为空（Undefined）。</p>
<blockquote>
<p>此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何<code>OutOfMemoryError情况</code>的区域。</p>
</blockquote>
<h4 id="1-2-Java虚拟机栈"><a href="#1-2-Java虚拟机栈" class="headerlink" title="1.2 Java虚拟机栈"></a>1.2 Java虚拟机栈</h4><p><code>Java虚拟机栈（Java Virtual Machine Stack）</code>描述的是<strong>Java<code>方法</code>执行的线程内存模型</strong>：每个<code>方法</code>被执行的时候，Java虚拟机都会同步创建一个<code>栈帧（Stack Frame）</code>用于存储<em>局部变量表、操作数栈、动态连接、方法出口</em>等信息。</p>
<blockquote>
<p><code>Java虚拟机栈（Java Virtual Machine Stack）</code>也是线程<code>私有</code>的，它的生命周期与线程相同。</p>
</blockquote>
<p>有人把Java内存区域笼统地划分为<code>堆内存（Heap）</code>和<code>栈内存（Stack）</code>。<strong>“栈”通常就是指虚拟机栈</strong>，或者更多的情况下只是指虚拟机栈中<em>局部变量表部分</em>。</p>
<blockquote>
<p>局部变量表中的存储空间以<code>局部变量槽（Slot）</code>来表示，其中64位长度的<code>long</code>和<code>double</code>类型的数据会<em>占用两个变量槽</em>，其余的数据类型只占用一个。</p>
<p><strong>局部变量表所需的内存空间在编译期间完成分配</strong>，一个方法需要在栈帧中分配多大的局部变量空间是<strong>完全确定</strong>的，在方法运行期间不会改变局部变量表的大小(<em>“大小”是指变量槽的数量</em>)</p>
</blockquote>
<p>这个内存区域规定了两类异常状况：</p>
<blockquote>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError异常</code></li>
<li>如果Java虚拟机栈容量可以<em>动态扩展</em>，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError异常</code></li>
</ul>
</blockquote>
<h4 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h4><p><code>本地方法栈（Native Method Stacks）</code>与虚拟机栈所发挥的作用是非常相似的，其<strong>区别</strong>只是：</p>
<blockquote>
<p>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务；</p>
<p>本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
</blockquote>
<p>有的Java虚拟机（譬如<code>Hot-Spot虚拟机</code>）直接把<strong>本地方法栈和虚拟机栈合二为一</strong>。</p>
<blockquote>
<p>本地方法栈规定了<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p>
</blockquote>
<h4 id="1-4-Java堆"><a href="#1-4-Java堆" class="headerlink" title="1.4 Java堆"></a>1.4 Java堆</h4><p><code>Java堆（Java Heap）</code>唯一目的就是<strong>存放对象实例</strong>，Java世界里<em>“几乎”</em>所有的对象实例都在这里分配内存。Java堆是被所有线程<code>共享</code>的一块内存区域，在虚拟机启动时创建，也是虚拟机所管理的内存中<em>最大</em>的一块。</p>
<blockquote>
<p>在《Java虚拟机规范》中对Java堆的描述是：<code>“所有的对象实例以及数组都应当在堆上分配”</code></p>
</blockquote>
<p>Java堆是<strong>垃圾收集器管理的内存区域</strong>，因此它也被称作<code>“GC堆”（Garbage Collected Heap）</code>。如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个<strong>线程私有</strong>的<code>分配缓冲区 （Thread Local Allocation Buffer，TLAB）</code>。</p>
<p>Java堆可以处于<code>物理上不连续</code>的内存空间中，但在逻辑上它应该被视为连续的。</p>
<blockquote>
<p>如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出<code>OutOfMemoryError异常</code>。</p>
</blockquote>
<h4 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h4><p><code>方法区（Method Area）</code>用于存储<strong>已被虚拟机加载</strong>的<em>类型信息、常量、静态变量、即时编译器编译后的代码缓存</em>等数据。与Java堆一样，是各个线程<code>共享</code>的内存区域。</p>
<blockquote>
<p>《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作<code>“非堆”（Non-Heap）</code></p>
</blockquote>
<p>很多人都更愿意把方法区称为<code>“永久代”（Permanent Generation）</code>，或将两者混为一谈。<strong>本质上这两者并不是等价的</strong>，因为仅仅是<strong>使用永久代来实现方法区</strong>而已。</p>
<blockquote>
<ul>
<li>永久代来实现方法区导致了Java应用更容易遇到<code>内存溢出</code>的问题（永久代有<code>-XX：MaxPermSize</code>的上限，即使不设置也有默认大小)；</li>
<li>在JDK 6的时候HotSpot开发团队就有<strong>放弃永久代</strong>，逐步改为<strong>采用本地内存（Native Memory）</strong>来实现方法区的计划了；</li>
<li>JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出；</li>
<li>而到了JDK 8，终于<strong>完全废弃了永久代的概念</strong>，改用与JRockit、J9一样在本地内存中实现的<code>元空间（Meta-space）</code>来代替。</li>
</ul>
</blockquote>
<p>除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择<strong>不实现垃圾收集</strong>。</p>
<blockquote>
<p>这区域的内存回收目标主要是针<strong>对常量池的回收</strong>和<strong>对类型的卸载</strong></p>
<p>如果方法区无法满足新的内存分配需求时，将抛出 <code>OutOfMemoryError异常</code>。</p>
</blockquote>
<h4 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h4><p><code>运行时常量池（Runtime Constant Pool）</code>是<strong>方法区的一部分</strong>。<code>Class文件</code>中有一项信息是<code>常量池表（Constant Pool Table）</code>，用于存放编译期生成的各种<strong>字面量</strong>与<strong>符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<blockquote>
<p>Class文件中还包括类的<em>版本、字段、方法、接口等描述信息</em></p>
</blockquote>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，运行期间也可以将新的常量放入池中。</p>
<blockquote>
<p>当常量池无法再申请到内存时会抛出<code>OutOfMemoryError异常</code>。</p>
</blockquote>
<h4 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7 直接内存"></a>1.7 直接内存</h4><p><code>直接内存（Direct Memory）</code>并不是虚拟机运行时数据区的一部分。</p>
<blockquote>
<p>在<code>JDK 1.4</code>中新加入了<code>NIO（New Input/Output）类</code>，引入了一种基于<code>通道（Channel）</code>与<code>缓冲区 （Buffer）</code>的I/O方式，它可以使用<strong><code>Native函数库</code>直接分配堆外内存</strong>，然后通过一个存储在Java堆里面的<code>DirectByteBuffer</code>对象作为<strong>这块内存的引用</strong>进行操作。</p>
<p>避免了在<code>Java堆</code>和<code>Native堆</code>中来回复制数据。</p>
</blockquote>
<p>本机直接内存的分配不会受到Java堆大小的限制，但是肯定还是会受到本机总内存大小以及处理器寻址空间的限制：</p>
<blockquote>
<p>动态扩展时可能会出现 <code>OutOfMemoryError异常</code>。</p>
</blockquote>
<h3 id="2-HotSpot虚拟机对象探秘"><a href="#2-HotSpot虚拟机对象探秘" class="headerlink" title="2. HotSpot虚拟机对象探秘"></a>2. <code>HotSpot</code>虚拟机对象探秘</h3><h4 id="2-1-对象的创建"><a href="#2-1-对象的创建" class="headerlink" title="2.1 对象的创建"></a>2.1 对象的创建</h4><p>在虚拟机中<code>(普通)对象</code>的创建过程如下：</p>
<blockquote>
<ol>
<li>当Java虚拟机遇到一条<code>字节码new指令</code>时，首先将去检查这个指令的参数是否能在<code>常量池</code>中定位到一个类的<code>符号引用</code>，并且检查这个符号引用代表的类是否已被<strong>加载、解析和初始化</strong>过。如果没有，必须先执行相应的<strong>类加载过程</strong>。</li>
<li>在类加载检查通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。<em>对象所需内存的大小在类加载完成后便可完全确定</em>，为对象分配空间的任务实际上便等同于把一块<u>确定大小</u>的内存块从<code>Java堆</code>中划分出来。<ul>
<li><code>“指针碰撞”（Bump The Pointer）</code>。如果Java堆中内存是<strong>绝对规整</strong>的，所有被<u>使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器</u>。那所分配内存就仅仅是把指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</li>
<li><code>“空闲列表”（Free List）</code>。如果Java堆中的内存是<strong>不规整</strong>的，已被使用的内存和空闲的内存相互交错在一起，<u>虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</u>。</li>
<li>Java堆是否规整<u>由所采用的垃圾收集器是否带有<code>空间压缩整理（Compact）</code>的能力决定</u>。</li>
<li>为了保证对象创建过程<code>线程安全</code>，有两种方法：<ul>
<li>对分配内存空间的动作进行<code>同步处理</code>——实际上虚拟机是采用<code>CAS配上失败重试</code>的方式保证<strong>更新操作的原子性</strong>；</li>
<li><u>把内存分配的动作按照线程划分在不同的空间之中进行</u>，即每个线程在Java堆中<strong>预先分配一小块内存</strong>，称为<code>本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）</code>。线程要分配内存，就在该线程的本地缓冲区中分配，<u>只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定</u>。</li>
</ul>
</li>
</ul>
</li>
<li>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都<strong><code>初始化为零值</code></strong>，如果使用了<code>TLAB</code>，这一项工作也可以提前至<code>TLAB</code>分配时进行。</li>
<li>Java虚拟机对对象进行<strong>必要的设置</strong>，例如<u>对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的<code>GC</code>分代年龄等</u>信息。这些信息存放在对象的<code>对象头（Object Header）</code>之中。</li>
</ol>
</blockquote>
<p>从<code>虚拟机的视角</code>来看，一个新的对象已经产生了。但是从<code>Java程序的视角</code>看来，对象创建才<u>刚刚开始</u>:</p>
<blockquote>
<p><strong>构造函数</strong>，即<code>Class文件</code>中的<code>&lt;init&gt;()</code>方法还没有执行，<u>所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好</u>。</p>
</blockquote>
<h4 id="2-2-对象的内存布局"><a href="#2-2-对象的内存布局" class="headerlink" title="2.2 对象的内存布局"></a>2.2 对象的内存布局</h4><p>在<code>HotSpot虚拟机</code>里，对象在堆内存中的存储布局可以划分为三个部分：<code>对象头（Header）</code>、<code>实例数据（Instance Data）</code>和<code>对齐填充（Padding）</code>。</p>
<h5 id="2-2-1-对象头"><a href="#2-2-1-对象头" class="headerlink" title="2.2.1 对象头"></a>2.2.1 对象头</h5><p>对象头部分包括两类信息：</p>
<ol>
<li>第一类是用于存储<strong>对象自身的<code>运行时数据</code></strong>，如<u>哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</u>等。官方称它为<code>“Mark Word”</code>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/markWord.PNG" alt="HotSpot虚拟机对象头`Mark Word`"></p>
<blockquote>
<p><code>Mark Word</code>被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p>
</blockquote>
<ol>
<li>另外一部分是<strong><code>类型指针</code></strong>，即<u>对象指向它的类型元数据的指针</u>，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</li>
</ol>
<blockquote>
<p>此外，如果对象是一个<code>Java数组</code>，那在对象头中还必须有一块用于<u>记录数组长度</u>的数据。</p>
</blockquote>
<h5 id="2-2-2-实例数据"><a href="#2-2-2-实例数据" class="headerlink" title="2.2.2 实例数据"></a>2.2.2 实例数据</h5><p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面<u>所定义的各种类型的字段内容</u>。</p>
<blockquote>
<p>存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</p>
<ul>
<li>HotSpot虚拟机默认的分配顺序为<code>longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs）</code>，相同宽度的字段总是被分配到一起存放</li>
<li>在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前</li>
</ul>
</blockquote>
<h5 id="2-2-3-对齐填充"><a href="#2-2-3-对齐填充" class="headerlink" title="2.2.3 对齐填充"></a>2.2.3 对齐填充</h5><p>对齐填充<em>不是必然存在</em>的，它仅仅起着<code>占位符</code>的作用。主要由于HotSpot虚拟机的自动内存管理系统要求<u>对象起始地址必须是8字节的整数倍</u>。</p>
<h4 id="2-3-对象的访问定位"><a href="#2-3-对象的访问定位" class="headerlink" title="2.3 对象的访问定位"></a>2.3 对象的访问定位</h4><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。主流的访问方式主要有<code>使用句柄</code>和<code>直接指针</code>两种：</p>
<ol>
<li><code>使用句柄</code>。Java堆中将可能会划分出一块内存来作为<code>句柄池</code>，<code>reference</code>中存储的就是对象的<code>句柄地址</code>，而句柄中包含了<u>对象实例数据与类型数据</u>各自具体的<strong>地址信息</strong>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/handleAccess.PNG" alt="通过句柄访问对象"></p>
<blockquote>
<p>最大好处就是reference中存储的是稳定句柄地址，在对象被移动时<strong>只会改变句柄中的实例数据指针</strong>，而 <code>reference</code>本身不需要被修改。可以理解为只需要移动对象实例数据。</p>
</blockquote>
<ol>
<li><code>直接指针</code>。Java堆中对象的内存布局需要考虑<u>如何放置访问类型数据的相关信息</u>，<code>reference</code>中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/pointerAccess.PNG" alt="通过直接指针访问对象"></p>
<blockquote>
<p>最大的好处就是速度更快，它节省了一次指针定位的时间开销。</p>
</blockquote>
<h3 id="3-OutOfMemoryError异常处理"><a href="#3-OutOfMemoryError异常处理" class="headerlink" title="3. OutOfMemoryError异常处理"></a>3. <code>OutOfMemoryError</code>异常处理</h3><h4 id="3-1-Java堆溢出"><a href="#3-1-Java堆溢出" class="headerlink" title="3.1 Java堆溢出"></a>3.1 Java堆溢出</h4><p>为了捕捉堆溢出，书中实现了如下异常测试程序：</p>
<blockquote>
<p>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证<strong><code>GC Roots</code>到对象之间有可达路径</strong>来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>堆的<code>最小值-Xms</code>参数与<code>最大值-Xmx</code>参数设置为一样即可避免堆自动扩展</li>
<li>参数<code>-XX：+HeapDumpOnOutOf-MemoryError</code>可以让虚拟机在出现内存溢出异常的时候<strong>Dump出当前的内存堆转储快照</strong>以便进行事后分析</li>
</ul>
</blockquote>
<p>运行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/heapOOM.PNG" alt="HeapOOM测试结果"></p>
<p>要解决这个内存区域的异常，常规的处理方法是首先通过内存映像分析工具对Dump出来的堆转储快照进行分析。</p>
<blockquote>
<p>这里使用的是<code>IDEA</code>的插件<code>jprofiler</code>，安装方法参考文章：<a href="https://blog.csdn.net/wytocsdn/article/details/79258247" target="_blank" rel="noopener">Intellij IDEA集成JProfiler性能分析神器</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/heapOOMJprofiler.PNG" alt="HeapOOM Jprofiler结果"></p>
<p>第一步首先应确认内存中<code>导致OOM的对象是</code>否是必要的，也就是要先分清楚到底是出现了<code>内存泄漏（Memory Leak）</code>还是<code>内存溢出（Memory Overflow）</code>。</p>
<ul>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到<code>GC Roots</code>的<code>引用链</code></li>
<li>如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数设置，与机器的内存对比，看看是否还有向上调整的空间。</li>
</ul>
<h4 id="3-2-虚拟机栈和本地方法栈溢出"><a href="#3-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="3.2 虚拟机栈和本地方法栈溢出"></a>3.2 虚拟机栈和本地方法栈溢出</h4><p>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，<code>-Xoss参数</code>（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，<strong>栈容量只能由-<code>Xss参数</code>来设定</strong>。</p>
<p>先将实验范围限制在单线程中操作，尝试下面行为是否能让HotSpot虚拟机产生<code>OutOfMemoryError</code>异常：</p>
<ol>
<li>使用<code>-Xss参数</code>减少栈内存容量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xss128k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaVMStackSOF.PNG" alt="JavaVMStackSOF结果"></p>
<blockquote>
<p>栈容量最小值主要取决于操作系统内存分页大小</p>
</blockquote>
<ol>
<li>定义大量的本地变量，增大此方法帧中本地变量表的长度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> unused1, unused2, unused3, unused4, unused5,</span><br><span class="line">                unused6, unused7, unused8, unused9, unused10,</span><br><span class="line">                unused11, unused12, unused13, unused14, unused15,</span><br><span class="line">                unused16, unused17, unused18, unused19, unused20,</span><br><span class="line">                unused21, unused22, unused23, unused24, unused25,</span><br><span class="line">                unused26, unused27, unused28, unused29, unused30,</span><br><span class="line">                unused31, unused32, unused33, unused34, unused35,</span><br><span class="line">                unused36, unused37, unused38, unused39, unused40,</span><br><span class="line">                unused41, unused42, unused43, unused44, unused45,</span><br><span class="line">                unused46, unused47, unused48, unused49, unused50,</span><br><span class="line">                unused51, unused52, unused53, unused54, unused55,</span><br><span class="line">                unused56, unused57, unused58, unused59, unused60,</span><br><span class="line">                unused61, unused62, unused63, unused64, unused65,</span><br><span class="line">                unused66, unused67, unused68, unused69, unused70,</span><br><span class="line">                unused71, unused72, unused73, unused74, unused75,</span><br><span class="line">                unused76, unused77, unused78, unused79, unused80,</span><br><span class="line">                unused81, unused82, unused83, unused84, unused85,</span><br><span class="line">                unused86, unused87, unused88, unused89, unused90,</span><br><span class="line">                unused91, unused92, unused93, unused94, unused95,</span><br><span class="line">                unused96, unused97, unused98, unused99, unused100;</span><br><span class="line">        stackLength ++;</span><br><span class="line">        test();</span><br><span class="line">        unused1 = unused2 = unused3 = unused4 = unused5 =</span><br><span class="line">        unused6 = unused7 = unused8 = unused9 = unused10 =</span><br><span class="line">        unused11 = unused12 = unused13 = unused14 = unused15 =</span><br><span class="line">        unused16 = unused17 = unused18 = unused19 = unused20 =</span><br><span class="line">        unused21 = unused22 = unused23 = unused24 = unused25 =</span><br><span class="line">        unused26 = unused27 = unused28 = unused29 = unused30 =</span><br><span class="line">        unused31 = unused32 = unused33 = unused34 = unused35 =</span><br><span class="line">        unused36 = unused37 = unused38 = unused39 = unused40 =</span><br><span class="line">        unused41 = unused42 = unused43 = unused44 = unused45 =</span><br><span class="line">        unused46 = unused47 = unused48 = unused49 = unused50 =</span><br><span class="line">        unused51 = unused52 = unused53 = unused54 = unused55 =</span><br><span class="line">        unused56 = unused57 = unused58 = unused59 = unused60 =</span><br><span class="line">        unused61 = unused62 = unused63 = unused64 = unused65 =</span><br><span class="line">        unused66 = unused67 = unused68 = unused69 = unused70 =</span><br><span class="line">        unused71 = unused72 = unused73 = unused74 = unused75 =</span><br><span class="line">        unused76 = unused77 = unused78 = unused79 = unused80 =</span><br><span class="line">        unused81 = unused82 = unused83 = unused84 = unused85 =</span><br><span class="line">        unused86 = unused87 = unused88 = unused89 = unused90 =</span><br><span class="line">        unused91 = unused92 = unused93 = unused94 = unused95 =</span><br><span class="line">        unused96 = unused97 = unused98 = unused99 = unused100 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaVMStackSOF.PNG" alt="JavaVMStackSOF2结果"></p>
<blockquote>
<p>出现<code>StackOverflowError</code>异常时，会有明确错误堆栈可供分析，相对而言比较容易定位到问题所在。</p>
</blockquote>
<h4 id="3-3-方法区和运行时常量池溢出"><a href="#3-3-方法区和运行时常量池溢出" class="headerlink" title="3.3 方法区和运行时常量池溢出"></a>3.3 方法区和运行时常量池溢出</h4><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p><code>String::intern()</code>是一个本地方法，它的作用是：</p>
<ul>
<li>如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；</li>
<li>否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</li>
</ul>
<p>对于<code>JDK 6</code>来运行如下代码，会出现运行时常量池的内存溢出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-XX:PermSize=6M -XX:MaxPermSize=6M</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Set保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在short范围内足以让6MB的PermSize产生OOM了</span></span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里没有安装<code>JDK 6</code>就没测试了，按书中所述，会出现如下异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">	at java.lang.String.intern(Native Method)</span><br><span class="line">	at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java: <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p><code>“PermGen space”</code>说明运行时常量池的确是属于方法区的一部分。使用<code>JDK 7</code>或更高版本的<code>JDK</code>并不会得到相同的结果，因为自<code>JDK 7</code>起，原本<u>存放在永久代的字符串常量池被移至Java堆之中</u>，所以在<code>JDK 7</code>及以上版 本，限制方法区的容量对该测试用例来说是毫无意义的。</p>
<h5 id="字符串常量池的实现方式的影响"><a href="#字符串常量池的实现方式的影响" class="headerlink" title="字符串常量池的实现方式的影响"></a>字符串常量池的实现方式的影响</h5><p>对于字符串常量池的实现引出了对<code>String.intern()</code>这个方法的影响，见如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1);</span><br><span class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>在<code>JDK 6</code>中运行，会得到<strong>两个<code>false</code></strong>。在<code>JDK 6</code>中，<code>intern()</code>方法会<strong>把首次遇到的字符串实例复制到永久代的字符串常量池中存储</strong>，返回的也是<u>永久代里面这个字符串实例</u>的引用，而由<code>StringBuilder</code>创建的字符串对象实例<strong>在Java堆</strong>上，所以必然不可能是同一个引用，结果将返回false。</p>
</li>
<li><p>在<code>JDK 7</code>中运行，会得到一个<code>true</code>和一个<code>false</code>。<code>JDK 7</code>的<code>intern()</code>方法<strong>不需要再拷贝字符串的实例到永久代</strong>，<u>字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可</u>，因此intern()返回的引用和由<code>StringBuilder</code>创建的那个字符串实例就是同一个。</p>
<ul>
<li>对<code>str2</code>比较返回<code>false</code>，这是因为<code>“java”</code>这个字符串在执行<code>StringBuilder.toString()</code>之前就已经出现过了，字符串常量池中已经有它的引用。<code>“java”</code>在加载<code>sun.misc.Version</code>这个类的时候进入常量池</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>方法区的主要职责是用于存放类型的相关信息，如<u>类名、访问修饰符、常量池、字段描述、方法描述</u>等。对于这部分区域的测试，基本的思路是<strong>运行时产生大量的类去填满方法区，直到溢出为止</strong>。作者借助了<code>CGLib</code>直接操作字节码运行时生成了大量的动态类。</p>
<blockquote>
<p>类似这样的代码确实可能会<strong>出现在实际应用</strong>中：当前的很多主流框架，如<code>Spring</code>、<code>Hibernate</code>对类进行增强时，都会使用到<code>CGLib</code>这类字节码技术。</p>
</blockquote>
<p>一个类如果要被垃圾收集器回收，要达成的条件是<strong>比较苛刻</strong>的。在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。</p>
<p><code>JDK 8</code>以后，<code>元空间</code>作为<code>永久代</code>替代者登场。<code>HotSpot</code>还是提供了一 些参数作为元空间的防御措施：</p>
<blockquote>
<ul>
<li><code>-XX：MaxMetaspaceSize</code>：设置元空间最大值；</li>
<li><code>-XX：MetaspaceSize</code>：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整</li>
<li><code>-XX：MinMetaspaceFreeRatio</code>：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。</li>
</ul>
</blockquote>
<h4 id="3-4-本机直接内存溢出"><a href="#3-4-本机直接内存溢出" class="headerlink" title="3.4 本机直接内存溢出"></a>3.4 本机直接内存溢出</h4><p><code>直接内存（Direct Memory）</code>的容量大小可通过<code>-XX：MaxDirectMemorySize</code>参数来指定，如果不去指定，则默认与<code>Java堆最大值</code>（由<code>-Xmx</code>指定）一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通 过反射获取<code>Unsafe</code>实例进行内存分配，虽然使用<code>DirectByteBuffer</code>分配内存也会抛出<code>内存溢出异常</code>，但它抛出异常时并没有真正向操作系统申请分配内存，而是<u>通过计算得知内存无法分配就会在代码里手动抛出溢出异常</u>，真正申请分配内存的方法是<code>Unsafe::allocateMemory()</code>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/DirectMemoryOOM.PNG" alt="DirectMemoryOOM结果"></p>
<p>如果发现内存溢出之后产生的<code>Dump文件</code>很小，而程序中又直接或间接使用了<code>DirectMemory</code>（<strong>典型的间接使用就是<code>NIO</code></strong>），可以考虑重点检查一下直接内存方面的原因。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--1. Two Sum</title>
    <url>/2019/03/28/LeetCode--1-Two-Sum.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.<br><a id="more"></a><br>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the same element twice.</p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>给定一个数组，和一个目标数target，要求数组中，和为target的两个数的下标。<br>想到的方法是暴力求法，即直接逐个遍历数组，找出满足要求的两个数。尽管这种方法能成功AC,但显然效率不高，这种方法比较耗时。需要寻找更加优化的算法。<br>查阅资料和题解思路得知，更加优化的方法是使用哈希表，这是一种通过以空间换取速度的方式，我们可以将查找时间从 O(n)降低到 O(1)。主要有以下两种：</p>
<blockquote>
<p>1.两遍哈希表<br>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。</p>
<p>2.一遍哈希表<br>更优化的方法是，我们可以一次完成计算。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
</blockquote>
<p>这里将这两种方法都实现了一遍。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li><p>解法1 暴力求法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indices;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            indices.push_back(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==target-nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    indices.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> indices;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            indices.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2 两遍哈希表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  indices;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.count(complement) &amp;&amp; hash[complement] != i)</span><br><span class="line">            &#123;</span><br><span class="line">                indices.push_back(i);</span><br><span class="line">                indices.push_back(hash[complement]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一遍哈希表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  indices;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.count(complement))</span><br><span class="line">            &#123;</span><br><span class="line">                indices.push_back(i);</span><br><span class="line">                indices.push_back(hash[complement]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>更新：map与unordered_map区别<br>原文：<a href="https://blog.csdn.net/BillCYJ/article/details/78985895" target="_blank" rel="noopener">https://blog.csdn.net/BillCYJ/article/details/78985895</a><br><strong>1.内部实现机理不同</strong><br><strong>map</strong>： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。</p>
<p><strong>unordered_map</strong>: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p>
<p><strong>2.优缺点以及适用处</strong><br><strong>map：</strong><br>优点：</p>
<ol>
<li>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</li>
<li>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</li>
</ol>
<p>缺点：<br>空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间</p>
<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>
<p><strong>unordered_map：</strong><br>优点： 因为内部实现了哈希表，因此其查找速度非常的快</p>
<p>缺点： 哈希表的建立比较耗费时间</p>
<p>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<p><strong>总结：</strong></p>
<ol>
<li>内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。</li>
<li>但是unordered_map执行效率要比map高很多</li>
<li>对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--9 构造器与垃圾收集器</title>
    <url>/2021/05/13/JavaLearning_Head_First_Java_9_constructors_and_garbage_collection.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>对象有生死。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-栈与堆"><a href="#1-栈与堆" class="headerlink" title="1. 栈与堆"></a>1. 栈与堆</h3><p><code>Java</code>中主要在意两种内存区域：对象的生存空间<code>堆(heap)</code>与方法调用及变量的生存空间<code>栈(stack)</code>。<code>Java</code>虚拟机启动时，会从底层操作系统取得一块内存，用于执行Java程序。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/stackHeap.PNG" alt="栈与堆"></p>
<p>几乎所有对象都存活于可垃圾回收的堆上，而变量根据它的类型判断存在于那一个内存区域。实例变量存在于堆中，而局部变量(也叫区域变量)存在于栈上，所以也叫栈变量。</p>
<blockquote>
<ul>
<li><code>实例变量</code>被声明在类中方法之外，代表每个独理对象的“字段”，存在于所属对象中。</li>
<li><code>局部变量</code>和<code>方法</code>被声明在方法中，是<code>暂时</code>的，生命周期只限于方法被放置于栈上这段时间(即方法调用到执行完毕)</li>
</ul>
</blockquote>
<h4 id="1-1-局部变量"><a href="#1-1-局部变量" class="headerlink" title="1.1 局部变量"></a>1.1 局部变量</h4><p>调用一个方法时，该方法会放在调用栈的栈顶。实际上放到栈顶的时<code>栈帧(stack frame)</code>，带有方法的状态，程序计数器及所有的局部变量值。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/twoMthodsStack.PNG" alt="放了两个方法的栈"></p>
<p>比如<code>foo()</code>调用了<code>bar()</code>，则<code>bar()</code>方法会放置在<code>foo()</code>上面。</p>
<h4 id="1-2-对象局部变量"><a href="#1-2-对象局部变量" class="headerlink" title="1.2 对象局部变量"></a>1.2 对象局部变量</h4><p>非<code>primitive</code>的变量只是保存对象的引用，对象放于堆上，而局部变量本身放于栈上。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/objectLocalVariable.PNG" alt="对象局部变量"></p>
<h4 id="1-3-实例变量"><a href="#1-3-实例变量" class="headerlink" title="1.3 实例变量"></a>1.3 实例变量</h4><p>实例变量存在于对象所属的堆空间上。</p>
<ul>
<li>如果实例变量全是<code>primitive</code>主数据类型，<code>Java</code>会根据其类型的大小为该实例变量留下空间</li>
<li>如果实例变量是一个对象，会留下对象引用所用到的空间，而不是对象本身。</li>
</ul>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><h4 id="2-1-创建对象"><a href="#2-1-创建对象" class="headerlink" title="2.1 创建对象"></a>2.1 创建对象</h4><p>声明对象和赋值的3个步骤：<code>声明引用变量</code>、<code>创建对象</code>、<code>连接对象和引用</code>。第二步<code>创建对象</code>看起来好像在调用类名的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duck myDuck = <span class="keyword">new</span> Duck();</span><br></pre></td></tr></table></figure>
<p>实际上调用的是<code>Duck</code>的构造函数。</p>
<blockquote>
<p>构造函数并不是方法，它带有<code>new</code>的时候会执行的程序代码，在初始化对象时执行。调用构造函数唯一的方法是通过<code>new</code>新建一个类对象。</p>
</blockquote>
<p>未写构造函数时，编译器会有一个默认构造函数。下面是一个默认构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>构造函数没有返回类型，名字必须与类名相同。</p>
</li>
<li><p>可以有与类同名的方法而不会变成构造函数。</p>
</li>
<li>构造函数不会被继承。</li>
</ul>
</blockquote>
<p>构造函数的一个关键特征是，在对象与引用连接前就执行，可以对对象进行预处理。大部分人使用构造函数来初始化对象的状态，也就是给对象的实例变量赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> size;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">(<span class="keyword">int</span> duckSize)</span> </span>&#123; <span class="comment">// 构造函数加上参数</span></span><br><span class="line">     	System.out.println(“Quack”);</span><br><span class="line">    	size = duckSize;</span><br><span class="line">     	System.out.println(“size is “ + size);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseADuck</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Duck d = <span class="keyword">new</span> Duck(<span class="number">42</span>); <span class="comment">// 传值初始化类对象</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最好要有不需要参数的构造函数，来对应参数无法确定的默认情况。</p>
</blockquote>
<p>只有在完全没定义构造函数时，编译器才会帮忙编写默认构造函数。如果已经写了一个有参数的构造函数，编译器并不会增加无参数的构造函数，需要<code>手动编写</code>。</p>
<blockquote>
<p>构造函数可以是<code>公有</code>、<code>私有</code>或<code>不指定</code>的。</p>
</blockquote>
<h4 id="2-2-父类及继承与构造函数的关系"><a href="#2-2-父类及继承与构造函数的关系" class="headerlink" title="2.2 父类及继承与构造函数的关系"></a>2.2 父类及继承与构造函数的关系</h4><p>在创建新对象时，所有继承下来的构造函数都会执行。即每个父类的构造函数都会在子类对象创建时期执行。</p>
<blockquote>
<p>抽象类也有构造函数，只是无法对其执行<code>new</code>操作，他的构造函数会在子类创建实例时执行。</p>
</blockquote>
<p>如果<code>Hippo</code>对象继承<code>Animal</code>，<code>Animal</code>继承了<code>Object</code>，那么创建对象的过程被称为一个<code>&quot;构造函数链(Constructor Chaining)&quot;</code>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/ConstructorChaining.PNG" alt="Hippo类构造函数调用"></p>
<blockquote>
<p>调用父类构造函数唯一的方法时调用<code>super()</code>。</p>
</blockquote>
<p>如果没有显式调用<code>super()</code>，编译器会自动加上<code>super()</code>的调用。且编译器自动加入的一定是<strong>没有参数的构造函数</strong>。</p>
<blockquote>
<p><code>super()</code>的调用必须是构造函数的第一个语句</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boop</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>();</span><br><span class="line">     size = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过要求父类的构造函数必须有名字，可以使得子类可以继承父类的<code>get</code>方法来访问私有的实例变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String theName)</span> </span>&#123;</span><br><span class="line">        name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hippo</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hippo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeHippo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hippo h = <span class="keyword">new</span> Hippo(<span class="string">"Buffy"</span>);</span><br><span class="line">        System.out.println(h.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类没有无参构造函数时，子类必须显式调用父类的构造函数，不然编译无法通过。</p>
<p>也可以在同一个类中调用另外的构造函数。比如多个构造函数有相同的工作部分，可以把这部分代码放在一个构造函数中，然后由其他构造函数调用。</p>
<blockquote>
<p>使用<code>this()</code>来从某个构造函数调用同一个类的另外一个构造函数。</p>
<p><code>this()</code>只能在构造函数中，且也必须时第一行语句。所以<code>super()</code>和<code>this()</code>不能在一个构造函数中同时调用。</p>
</blockquote>
<h4 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3 垃圾收集器"></a>3 垃圾收集器</h4><h4 id="3-1-对象的生命周期"><a href="#3-1-对象的生命周期" class="headerlink" title="3.1 对象的生命周期"></a>3.1 对象的生命周期</h4><p>对象的生命周期取决于引用到它的”引用”，引用变量的声明周期又看它是局部变量还是实例变量。</p>
<blockquote>
<ul>
<li>局部变量只会存活在声明该变量的方法中</li>
<li>实例变量的寿命与对象相同。</li>
</ul>
</blockquote>
<p><strong>“life”与”scope”的差别</strong></p>
<ul>
<li><strong>life</strong>。只要变量的堆栈块还存在于堆栈上，局部变量就算存活。</li>
<li><strong>scope</strong>。局部变量的范围只限于声明它的方法之内。当此方法调用其他方法时，该变量依旧存活，但不在目前执行范围内。</li>
</ul>
<p>如果对象的唯一引用解散，那么对象就会从堆中被抛弃，变成可回收的。</p>
<blockquote>
<p>若没有引用指向该对象，对象无法被获取，<code>垃圾收集器(GC)</code>会自动回收内存空间。</p>
</blockquote>
<p>有三种方法可以释放对象的引用：</p>
<ol>
<li><p>引用永久性的离开它的范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Life z = <span class="keyword">new</span> Life();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用被赋值到其他对象上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Life z = <span class="keyword">new</span> Life();</span><br><span class="line">z = <span class="keyword">new</span> Life();</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接将引用设定为<code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Life z = <span class="keyword">new</span> Life();</span><br><span class="line">z = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--12. Integer to Roman</title>
    <url>/2019/04/03/LeetCode--12-Integer-to-Roman.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<ul>
<li>I can be placed before V (5) and X (10) to make 4 and 9. </li>
<li>X can be placed before L (50) and C (100) to make 40 and 90. </li>
<li>C can be placed before D (500) and M (1000) to make 400 and 900.</li>
</ul>
<p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: 3<br>Output: “III”</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: 4<br>Output: “IV”</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: 9<br>Output: “IX”</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input: 58<br>Output: “LVIII”<br>Explanation: L = 50, V = 5, III = 3.</p>
</blockquote>
<p><strong>Example 5:</strong></p>
<blockquote>
<p>Input: 1994<br>Output: “MCMXCIV”<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目描述很长，但意思很简单，就是将普通的阿拉伯数字转换为罗马数字。罗马数字有自己的表示规则，所以需要进行一定处理。其实处理方法很简单：</p>
<blockquote>
<p>每次找到数字中包含的最大罗马数字，然后减去这个数，并把该罗马数加入表示数的字符串中。不断重复这个过程，直到数字为0停止，输出结果。</p>
</blockquote>
<p>最开始实现时，写了一长串的if-else语句，尽管能够成功解决。但是代码不够简洁，需要想办法使代码美观规范。可以将这些罗马数字和其对应的阿拉伯数字从大到小存放到数组或者map中，之后直接从大到小遍历这个数组即可，可以省去大部分if-else语句，且结构更加清晰。</p>
<p>评论区有另一种解法，直接把0~10,10~100,100~1000,1000~3999范围类，罗马数的可能表示直接列出来放到一个数字中，然后直接按位查表，O(1)的时间复杂度。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= val[i]) &#123;</span><br><span class="line">                num -= val[i];</span><br><span class="line">                res += str[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> THOUS[];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> HUNDS[];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> TENS[];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> ONES[];</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        result += THOUS[(<span class="keyword">int</span>)(num/<span class="number">1000</span>)%<span class="number">10</span>];</span><br><span class="line">        result += HUNDS[(<span class="keyword">int</span>)(num/<span class="number">100</span>)%<span class="number">10</span>];</span><br><span class="line">        result += TENS[(<span class="keyword">int</span>)(num/<span class="number">10</span>)%<span class="number">10</span>];</span><br><span class="line">        result += ONES[num%<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::THOUS[]	= &#123;<span class="string">""</span>,<span class="string">"M"</span>,<span class="string">"MM"</span>,<span class="string">"MMM"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::HUNDS[]	= &#123;<span class="string">""</span>,<span class="string">"C"</span>,<span class="string">"CC"</span>,<span class="string">"CCC"</span>,<span class="string">"CD"</span>,<span class="string">"D"</span>,<span class="string">"DC"</span>,<span class="string">"DCC"</span>,<span class="string">"DCCC"</span>,<span class="string">"CM"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::TENS[]	= &#123;<span class="string">""</span>,<span class="string">"X"</span>,<span class="string">"XX"</span>,<span class="string">"XXX"</span>,<span class="string">"XL"</span>,<span class="string">"L"</span>,<span class="string">"LX"</span>,<span class="string">"LXX"</span>,<span class="string">"LXXX"</span>,<span class="string">"XC"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::ONES[]	= &#123;<span class="string">""</span>,<span class="string">"I"</span>,<span class="string">"II"</span>,<span class="string">"III"</span>,<span class="string">"IV"</span>,<span class="string">"V"</span>,<span class="string">"VI"</span>,<span class="string">"VII"</span>,<span class="string">"VIII"</span>,<span class="string">"IX"</span>&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--13. Roman to Integer</title>
    <url>/2019/04/07/LeetCode--13-Roman-to-Integer.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br><a id="more"></a></p>
</blockquote>
<p>剩余部分略，描述与它前一道题<a href="http://wuyunjie.top/2019/04/03/LeetCode-12-Integer-to-Roman/" title="12. Integer to Roman">12. Integer to Roman</a>大致相同</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: “III”<br>Output: 3</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: “IV”<br>Output: 4</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: “IX”<br>Output: 9</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input: “LVIII”<br>Output: 58<br>Explanation: L = 50, V= 5, III = 3.</p>
</blockquote>
<p><strong>Example 5:</strong></p>
<blockquote>
<p>Input: “MCMXCIV”<br>Output: 1994<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题与它前一道题恰好相反，是从罗马数变成阿拉伯数字。细心观察可以发现，罗马数字一般都是大的数字在前面，如果存在某个较小的数字在某个较大的数字前——比如”IV”，那么他们表示的是一个数字4，即 V - I 。</p>
<p>利用这种特性，一开始思考，是否可以设置一个优先级，来判断某个数字应该比另一个优先出现。转念一想，他们的大小就已经代表优先级了，那么处理起来就很简单了：</p>
<blockquote>
<ol>
<li>若一个数比它下一个数优先级高，加入该数的值；</li>
<li>若一个数比它下一个数优先级低，减去该数的值。</li>
</ol>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; roToInt = &#123;</span><br><span class="line">            &#123;<span class="string">'I'</span>,<span class="number">1</span>&#125;, &#123;<span class="string">'V'</span>,<span class="number">5</span>&#125;, &#123;<span class="string">'X'</span>,<span class="number">10</span>&#125;, </span><br><span class="line">            &#123;<span class="string">'L'</span>,<span class="number">50</span>&#125;,&#123;<span class="string">'C'</span>,<span class="number">100</span>&#125;,&#123;<span class="string">'D'</span>,<span class="number">500</span>&#125;,&#123;<span class="string">'M'</span>,<span class="number">1000</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// int roToInt[256] = &#123;0&#125;;</span></span><br><span class="line">        <span class="comment">// roToInt['I']=1;roToInt['V']=5;roToInt['X']=10;</span></span><br><span class="line">        <span class="comment">// roToInt['L']=50;roToInt['C']=100;roToInt['D']=500;roToInt['M']=1000;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(roToInt[s[i]]&lt;roToInt[s[i+<span class="number">1</span>]])</span><br><span class="line">            &#123;</span><br><span class="line">                result-=roToInt[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result+=roToInt[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--8 虚拟机字节码执行引擎</title>
    <url>/2021/05/28/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_8_Virtual_machine_bytecode_execution_engine.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>执行引擎是Java虚拟机核心的组成部分之一。<br><a id="more"></a></p>
</blockquote>
<p>在不同的虚拟机实现中，执行引擎在执行字节码的时候，通常会有<code>解释执行（通过解释器执行）</code>和<code>编译执行（通过即时编译器产生本地代码执行）</code>两种，也可能两者兼备。</p>
<p>但从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：</p>
<ul>
<li>输入的是字节码二进制流；</li>
<li>处理过程是字节码解析执行的等效过程；</li>
<li>输出的是执行结果，</li>
</ul>
<h3 id="1-运行时栈帧结构"><a href="#1-运行时栈帧结构" class="headerlink" title="1. 运行时栈帧结构"></a>1. 运行时栈帧结构</h3><p>Java虚拟机<strong><u>以方法作为最基本的执行单元</u></strong>，<code>“栈帧”（Stack Frame）</code>则是用于支持虚拟机进行<strong>方法调用</strong>和<strong>方法执行</strong>背后的数据结构，它也是虚拟机运行时数据区中的<code>虚拟机栈（Virtual Machine Stack）</code>的栈元素。</p>
<blockquote>
<p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。一个栈帧需要分配多少内存仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/StackFrame.PNG" alt="栈帧结构"></p>
<h4 id="1-1-局部变量表"><a href="#1-1-局部变量表" class="headerlink" title="1.1 局部变量表"></a>1.1 局部变量表</h4><p><code>局部变量表（Local Variables Table）</code>是一组变量值的存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>。</p>
<blockquote>
<p>局部变量表的容量以<code>变量槽（Variable Slot）</code>为最小单位，一个变量槽应占用的内存空间大小未明确定义，每个变量槽都应该能存放一个<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>reference</code>或<code>returnAddress</code>类型的数据。对于64位的数据类型，Java虚拟机会以<strong>高位对齐</strong>的方式为其分配两个连续的变量槽空间。</p>
</blockquote>
<p>Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是<u><strong>从0开始至局部变量表最大的变量槽数量</strong></u>。</p>
<blockquote>
<p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成<u><strong>参数值到参数变量列表的传递过程， 即实参到形参的传递</strong></u>。</p>
<ul>
<li>如果执行的是实例方法，局部变量表中<strong><u>第0位索引</u></strong>的变量槽默认是<strong><u>用于传递方法所属对象实例的引用</u></strong>，在方法中可以通过关键字<code>“this”</code>来访问到这个隐含的参数。</li>
<li>其余参数则按照参数表顺序排列，占用<strong><u>从1开始</u></strong>的局部变量槽；</li>
<li>参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</li>
</ul>
</blockquote>
<p>为了尽可能节省栈帧耗用的内存空间，局部变量表中的变量槽是可以重用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 局部变量表Slot复用对垃圾收集的影响</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>placeholder</code>能否被回收的根本原因就是：局部变量表中的变量槽是否还存有关于<code>placeholder</code>数组对象的引用。</p>
<ul>
<li>未加入<code>int a = 0;</code>语句时，虽然已经离开了<code>placeholder</code>的作用域，<code>placeholder</code>原本所占用的变量槽还没有被其他变量所复用，所以作为<code>GC Roots</code>一部分的局部变量表仍然保持着对它的关联。所以<code>placeholder</code>数组对象不会被回收。</li>
<li>手动将其设置占用了大量内存但实际上已经不会再使用的变量为<code>null</code>值(代替那句<code>int a = 0;</code>)，可以作为一种在极特殊情形下的<code>“奇技”</code>来使用。</li>
</ul>
<p>此外，局部变量不像类变量那样存在“准备阶段”，即不会被系统初始化为默认值。</p>
<h4 id="1-2-操作数栈"><a href="#1-2-操作数栈" class="headerlink" title="1.2 操作数栈"></a>1.2 操作数栈</h4><p><code>操作数栈（Operand Stack）</code>也常被称为操作栈，它是一个<code>后入先出（Last In First Out，LIFO）</code>栈。</p>
<blockquote>
<p><code>Javac编译器</code>的<strong>数据流分析工作</strong>保证了在方法执行的任何时候，操作数栈的深度都不会超过在<code>max_stacks</code>数据项中设定的最大值。</p>
</blockquote>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OperandStackShareData.PNG" alt="栈帧之间的数据共享"></p>
<p>概念上，两个不同栈帧作为不同方法的虚拟机栈的元素，是<strong><u>完全相互独立</u></strong>的。但在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现<u>一部分重叠</u>。让<strong>下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起</strong>，这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了。</p>
<h4 id="1-3-动态连接"><a href="#1-3-动态连接" class="headerlink" title="1.3 动态连接"></a>1.3 动态连接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的<code>动态连接（Dynamic Linking）</code>。</p>
<h4 id="1-4-方法返回地址"><a href="#1-4-方法返回地址" class="headerlink" title="1.4 方法返回地址"></a>1.4 方法返回地址</h4><p>当一个方法开始执行后，只有两种方式退出这个方法：</p>
<ol>
<li>第一种方式是<u><strong>执行引擎遇到任意一个方法返回的字节码指令</strong></u>，这时候可能会有返回值传递给上层的方法调用者，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为<code>“正常调用完成”（Normal Method Invocation Completion）</code>。</li>
<li>另外一种是在<u><strong>方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理</strong></u>。无论是Java虚拟机内部产生的异常，还是代码中使用<code>athrow</code>字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为<code>“异常调用完成（Abrupt Method Invocation Completion）”</code>。一个方法使用异常完成出口的方式退出，是<strong><u>不会给它的上层调用者提供任何返回值的</u></strong>。</li>
</ol>
<p>方法退出之后必须返回到最初方法被调用时的位置，退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>
<ul>
<li>方法正常退出时，<u><strong>主调方法的PC计数器的值就可以作为返回地址</strong></u>，栈帧中很可能会保存这个计数器值；</li>
<li>方法异常退出时，<u><strong>返回地址要通过异常处理器表来确定</strong></u>，栈帧中就一般不会保存这部分信息。</li>
</ul>
<h4 id="1-5-附加信息"><a href="#1-5-附加信息" class="headerlink" title="1.5 附加信息"></a>1.5 附加信息</h4><p>比如与调试、性能收集相关的信息。一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为<code>栈帧信息</code>。</p>
<h3 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h3><p><strong>方法调用并<u>不等同于</u>方法中的代码被执行</strong>，方法调用阶段唯一的任务就是<strong>确定被调用方法的版本</strong>。</p>
<h4 id="2-1-解析"><a href="#2-1-解析" class="headerlink" title="2.1 解析"></a>2.1 解析</h4><p>所有方法调用的目标方法在Class文件里面都是一个<strong>常量池中的符号引用</strong>，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：</p>
<ul>
<li>方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为<code>解析（Resolution）</code>。</li>
</ul>
<blockquote>
<p>在Java语言中符合<code>“编译期可知，运行期不可变”</code>这个要求的方法，主要有静态方法、私有方法、实例构造器、父类方法，再加上被<code>final</code>修饰的方法（尽管它使用<code>invokevirtual</code>指令调用），这5种方法调用会在<strong>类加载</strong>的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为<code>“非虚方法”（Non-Virtual Method）</code>，其他方法就被称为<code>“虚方法”（Virtual Method）</code>。</p>
</blockquote>
<p>解析调用一定是个<code>静态的过程</code>，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用。</p>
<h4 id="2-2-分派"><a href="#2-2-分派" class="headerlink" title="2.2 分派"></a>2.2 分派</h4><p><code>分派 （Dispatch）</code>调用可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。</p>
<h5 id="2-2-1-静态分派"><a href="#2-2-1-静态分派" class="headerlink" title="2.2.1 静态分派"></a>2.2.1 静态分派</h5><p>通过如下代码来定义两个关键概念：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>静态类型（Static Type）</code>。“Human”称为变量的<code>“静态类型”（Static Type）</code>，或者叫<code>“外观类型”（Apparent Type）</code>，静态类型的变化仅仅<u>在使用时发生</u>，变量本身的静态类型不会被改变，并且最终的静态类型是<u><strong>在编译期可知的</strong></u>；</li>
<li><code>实际类型（Actual Type）</code>。“Man”则被称为变量的<code>“实际类型”（Actual Type）</code>或者叫<code>“运行时类型”（Runtime Type）</code>，实际类型变化的结果<u>在运行期才可确定</u>，编译器<strong><u>在编译程序的时候并不知道</u></strong>一个对象的实际类型是什么。</li>
</ul>
<p>比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line">Human human = (<span class="keyword">new</span> Random()).nextBoolean() ? <span class="keyword">new</span> Man() : <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">sr.sayHello((Man) human)</span><br><span class="line">sr.sayHello((Woman) human)</span><br></pre></td></tr></table></figure>
<ul>
<li>对象<code>human</code>的实际类型是可变的，到底是Man还是Woman，必须等到程序运行到这行的时候才能确定。</li>
<li>human的静态类型是Human，也可以在使用时（如<code>sayHello()</code>方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的</li>
</ul>
<p>在如下的例子中，使用哪个重载版本的<code>sayHello()</code>方法，完全取决于传入参数的数量和数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,guy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,gentleman!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,lady!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚拟机（或者准确地说是编译器）在重载时是<strong><u>通过参数的静态类型而不是实际类型作为判定依据的</u></strong>，所以在编译阶段，<code>Javac</code>编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了<code>sayHello(Human)</code>作为调用目标。</p>
<blockquote>
<p>所有依赖<code>静态类型</code>来决定方法执行版本的分派动作，都称为<code>静态分派</code>。</p>
</blockquote>
<p>静态分派的最典型应用表现就是<code>方法重载</code>。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。从下面的示例代码可以看出方法重载中，选择重载版本的匹配优先级：</p>
<ul>
<li><p>如果注释掉 <code>sayHello(char arg)</code>方法，会输出：<code>hello int</code>。这时发生了一次自动类型转换，<code>&#39;a&#39;</code>转换为<code>int</code>类型。</p>
</li>
<li><p>继续注释掉<code>sayHello(int arg)</code>方法，那输出会变为：<code>hello long</code>。这时发生了两次自动类型转换，<code>&#39;a&#39;</code>转型为整数<code>97</code>之后，进一步转型为长整数<code>97L</code>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello int"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello long"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Serializable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自动转型可以依<code>据char&gt;int&gt;long&gt;float&gt;double</code>的顺序转型进行匹配。</li>
<li>自动装箱为封装类型<code>java.lang.Character</code>，但是自动装箱的封装类型<code>java.lang.Character</code>不会转换为其他封装类型，比如<code>Integer</code>。</li>
<li>封装类型<code>java.lang.Character</code>只能安全地转型为它实现的接口(如<code>java.lang.Serializable</code>)或父类(如<code>Object</code>)。</li>
<li>可见变长参数的重载优先级是最低的，这里使用的是<code>char</code>类型的变长参数。</li>
</ul>
<h5 id="2-2-2-动态分派"><a href="#2-2-2-动态分派" class="headerlink" title="2.2.2 动态分派"></a>2.2.2 动态分派</h5><p>动态分派与<code>重写（Override）</code>有着密切关联，考虑如下方法的动态分派：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法动态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"woman say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里选择调用的方法版本不可能再根据静态类型来决定的，因为静态类型同样都是<code>Human</code>的两个变量<code>man</code>和<code>woman</code>在调用<code>sayHello()</code>方法时产生了不同的行为。导致这个现象的原因很明显，是因为这两个变量的<code>实际类型</code>不同。</p>
<p>从子节码看，这两条调用指令无论是指令（都是<code>invokevirtual</code>）还是参数都完全一样，但是这两句指令最终执行的目标方法并不相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span><br><span class="line">20: aload_2</span><br><span class="line">21: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span><br></pre></td></tr></table></figure>
<p><code>invokevirtual</code>指令的运行时解析过程大致分为以下几步：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的<code>实际类型</code>，记作<code>C</code>。</li>
<li>如果在类型<code>C</code>中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回<code>java.lang.IllegalAccessError</code>异常。</li>
<li>否则，按照继承关系从下往上依次对<code>C</code>的各个父类进行第二步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li>
</ol>
<p><code>invokevirtual</code>指令执行的第一步就是在运行期确定<code>接收者（Receiver）</code>的<code>实际类型</code>，所以两次调用中的 <code>invokevirtual</code>指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。</p>
<blockquote>
<p>把这种在运行期根据<code>实际类型</code>确定方法执行版本的分派过程称为<code>动态分派</code>。</p>
</blockquote>
<h5 id="2-2-3-单分派与多分派"><a href="#2-2-3-单分派与多分派" class="headerlink" title="2.2.3 单分派与多分派"></a>2.2.3 单分派与多分派</h5><p>方法的<code>接收者</code>与方法的<code>参数</code>统称为方法的<code>宗量</code>，根据分派基于多少种宗量，可以将分派划分为<code>单分派</code>和<code>多分派</code>两种。</p>
<ul>
<li><code>单分派</code>是根据一个宗量对目标方法进行选择；</li>
<li><code>多分派</code>则是根据多于一个宗量对目标方法进行选择。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单分派、多分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>首先是编译阶段中编译器的选择过程，也就是<code>静态分派</code>的过程。选择目标方法的依据有两点：</p>
<ul>
<li>一是静态类型是Father还是Son；</li>
<li>二是方法参数是QQ还是360。</li>
</ul>
</li>
<li><p>选择结果的最终产生了两条<code>invokevirtual</code>指令，两条指令的参数分别为常量池中指向<code>Father::hardChoice(360)</code>及<code>Father::hardChoice(QQ)</code>方法的符号引用。</p>
</li>
</ul>
<blockquote>
<p>因为是根据两个宗量进行选择，所以Java语言的<code>静态分派</code>属于<code>多分派</code>类型。</p>
</blockquote>
<ul>
<li>然后是运行阶段中虚拟机的选择，也就是动态分派的过程：<ul>
<li>执行<code>“son.hardChoice(new QQ())”</code>所对应的<code>invokevirtual</code>指令时，由于编译期已经决定目标方法的签名必须为<code>hardChoice(QQ)</code>，这时候参数的<code>静态类型</code>、<code>实际类型</code>都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有该方法的<code>接受者的实际类型</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>因为只有一个宗量作为选择依据， 所以Java语言的<code>动态分派</code>属于<code>单分派</code>类型。</p>
</blockquote>
<p>如今的Java语言是一门<code>静态多分派</code>、<code>动态单分派</code>的语言。</p>
<h5 id="2-3-4-虚拟机动态分派的实现"><a href="#2-3-4-虚拟机动态分派的实现" class="headerlink" title="2.3.4 虚拟机动态分派的实现"></a>2.3.4 虚拟机动态分派的实现</h5><p>动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的<code>方法元数据</code>中搜索合适的目标方法。基于执行性能的考虑，一种基础而且常见的优化手段是使用<code>虚方法表索引</code>来代替元数据查找以提高性能。</p>
<ul>
<li>为类型在方法区中建立一个<code>虚方法表（Virtual Method Table</code>，也称为<code>vtable</code>）</li>
<li>在<code>invokeinterface</code>执行时也会用到接口方法表（<code>Interface Method Table</code>，简称<code>itable</code>）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/MethodTable.PNG" alt="方法表结构"></p>
<p>虚方法表中存放着各个方法的<code>实际入口地址</code>。</p>
<ul>
<li>如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。</li>
<li>如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</li>
</ul>
<p>具有<code>相同签名</code>的方法，在父类、子类的虚方法表中都应当具有一样的<code>索引序号</code>，当类型变换时仅需要变更查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p>
<p>虚拟机除了使用虚方法表之外，为了进一步提高性能，还会使用<code>类型继承关系分析（Class Hierarchy Analysis，CHA）</code>、<code>守护内联（Guarded Inlining）</code>、<code>内联缓存（Inline Cache）</code>等多种非稳定的激进优化来争取更大的性能空间。</p>
<h3 id="3-动态类型语言支持"><a href="#3-动态类型语言支持" class="headerlink" title="3. 动态类型语言支持"></a>3. 动态类型语言支持</h3><p><code>invokedynamic</code>指令是为了实现<code>动态类型语言（Dynamically Typed Language）</code>支持而进行的改进。</p>
<h4 id="3-1-动态类型语言"><a href="#3-1-动态类型语言" class="headerlink" title="3.1 动态类型语言"></a>3.1 动态类型语言</h4><p><code>动态类型语言</code>的<u>关键特征</u>是<strong><u>它的类型检查的主体过程是在运行期而不是编译期进行的</u></strong>。在编译期就进行类型检查过程的语言（譬如C++和Java等）就是<code>静态类型语言</code>。</p>
<p>动态类型语言与<code>Java</code>有一个核心的差异就是<u><strong>变量本身并没有类型，变量的值才具有类型</strong></u>，所以编译器在编译时最多只能确定<u>方法名称</u>、<u>参数</u>、<u>返回值</u>这些信息，而不会去确定方法所在的具体类型（即方法接收者不固定）。</p>
<blockquote>
<p><code>“变量无类型而变量值才有类型”</code>是动态类型语言的一个核心特征。</p>
</blockquote>
<h4 id="3-2-Java与动态类型"><a href="#3-2-Java与动态类型" class="headerlink" title="3.2 Java与动态类型"></a>3.2 Java与动态类型</h4><p><code>JDK 7</code>以前的字节码指令集中，4条方法调用指令（<code>invokevirtual</code>、<code>invokespecial</code>、<code>invokestatic</code>、 <code>invokeinterface</code>）的第一个参数都是<code>被调用方法的符号引用</code>，方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定方法的接收者。</p>
<h4 id="3-3-java-lang-invoke包"><a href="#3-3-java-lang-invoke包" class="headerlink" title="3.3 java.lang.invoke包"></a>3.3 <code>java.lang.invoke</code>包</h4><p><code>JDK 7</code>时新加入的<code>java.lang.invoke</code>包的主要目的是<u><strong>在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制</strong></u>，称为<code>“方法句柄”（Method Handle）</code>。</p>
<p>拥有方法句柄之后，Java语言也可以拥有类似于<code>函数指针</code>或者<code>委托</code>的方法别名这样的工具：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JSR 292 MethodHandle基础用法演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> ClassA();</span><br><span class="line">        <span class="comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。</span></span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">"icyfenix"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和具体参数（methodType()第二个及以后的参数）。</span></span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</span></span><br><span class="line">        <span class="comment">// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情。</span></span><br><span class="line">        <span class="keyword">return</span> lookup().findVirtual(reveiver.getClass(), <span class="string">"println"</span>, mt).bindTo(reveiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getPrintlnMH()</code>方法实际上是模拟了<code>invokevirtual</code>指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个由用户设计的Java方法来实现。而这个方法本身的返回值 <code>（MethodHandle对象）</code>，可以视为对最终调用方法的一个<code>“引用”</code>。</p>
<p><code>MethodHandle</code>与<code>Reflection</code>的区别：</p>
<ul>
<li><code>Reflection</code>和<code>MethodHandle</code>机制本质上都是在<strong>模拟方法调用</strong>，但是<code>Reflection</code>是在<strong>模拟Java代码层次</strong>的方法调用，而<code>MethodHandle</code>是在<strong>模拟字节码层次</strong>的方法调用。</li>
<li><code>Reflection</code>中的<code>java.lang.reflect.Method</code>比<code>MethodHandle</code>中的 <code>java.lang.invoke.MethodHandle</code>对象所包含的信息多。<ul>
<li>前者是方法在Java端的全面映像，包含了方法的<u>签名</u>、<u>描述符</u>以及<u>方法属性表中各种属性的Java端表示方式</u>，还包含<u>执行权限等的运行期信息</u>。</li>
<li>后者仅包含执行该方法的相关信息。<code>Reflection</code>是重量级，而<code>MethodHandle</code> 是轻量级。</li>
</ul>
</li>
<li>理论上<code>MethodHandle</code>上也可以采用虚拟机在字节码层次的各种优化方法 （如方法内联），而通过反射去调用方法则几乎不可能直接去实施各类调用点优化措施。</li>
<li><code>Reflection API</code>的设计目标是只为Java语言服务的，而<code>MethodHandle</code>则设计为可服务于所有Java虚拟机之上的语言。</li>
</ul>
<h4 id="3-4-invokedynamic指令"><a href="#3-4-invokedynamic指令" class="headerlink" title="3.4 invokedynamic指令"></a>3.4 <code>invokedynamic</code>指令</h4><p><code>invokedynamic</code>指令与<code>MethodHandle</code>机制的作用是一样的，都是把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中。两者的思路也是可类比的，只是一个用<strong>上层代码和API</strong>来实现， 另一个用<strong>字节码和Class中其他属性、常量</strong>来完成。</p>
<p>每一处含有<code>invokedynamic</code>指令的位置都被称作<code>“动态调用点（Dynamically-Computed Call Site）”</code>，这条指令的第一个参数是<code>JDK 7</code>时新加入的<code>CONSTANT_InvokeDynamic_info</code>常量，从中可以得到3项信息：</p>
<ul>
<li><code>引导方法（Bootstrap Method）</code>，该方法存放在新增的<code>BootstrapMethods</code>属性中，有固定的参数，并且返回值规定是<code>java.lang.invoke.CallSite</code>对象，这个对象代表了真正要执行的目标方法调用；</li>
<li><code>方法类型（MethodType）</code>；</li>
<li><code>名称</code>。</li>
</ul>
<h3 id="4-基于栈的字节码解释执行引擎"><a href="#4-基于栈的字节码解释执行引擎" class="headerlink" title="4. 基于栈的字节码解释执行引擎"></a>4. 基于栈的字节码解释执行引擎</h3><h4 id="4-1-解释执行"><a href="#4-1-解释执行" class="headerlink" title="4.1 解释执行"></a>4.1 解释执行</h4><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过如下各个步骤</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/compileProcess.PNG" alt="编译过程"></p>
<h4 id="4-2-基于栈的指令集与基于寄存器的指令集"><a href="#4-2-基于栈的指令集与基于寄存器的指令集" class="headerlink" title="4.2 基于栈的指令集与基于寄存器的指令集"></a>4.2 基于栈的指令集与基于寄存器的指令集</h4><p><code>基于栈的指令集架构（Instruction Set Architecture，ISA）</code>，字节码指令流里面的指令大部分都是<strong><u>零地址指令</u></strong>，它们依赖操作数栈进行工作。<code>Javac</code>编译器输出的字节码指令流基本上是基于栈的指令集架构。</p>
<ul>
<li>主要优点是可移植，因为寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。还有一些其他的优点，如代码相对更加紧凑，编译器实现更加简单。</li>
<li>主要缺点是理论上执行速度相对来说会稍慢一些。完成相同功能所需的指令数量一般会比寄存器架构来得更多，更重要的是栈实现在内存中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。</li>
</ul>
<p><code>基于寄存器的指令集</code>，就是现在我们主流PC机中物理硬件直接支持的指令集架构，这些指令依赖寄存器进行工作。最典型的就是<code>x86</code>的<strong><u>二地址指令集</u></strong>。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--11. Container With Most Water</title>
    <url>/2019/04/03/LeetCode--11-Container-With-Most-Water.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given n non-negative integers <strong>a1, a2, …, an</strong> , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br><a id="more"></a></p>
</blockquote>
<p><strong>Note:</strong> You may not slant the container and n is at least 2.</p>
<p><img src="https://i.niupic.com/images/2019/04/03/5Ujc.jpg" alt=""><br>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example :</strong></p>
<blockquote>
<p>Input: [1,8,6,2,5,4,8,3,7]<br>Output: 49</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>首先想到的是暴力解法，直接遍历所有可能的二元组，最终可以找到满足题目要求的最大值。但是题目对时间有要求，这种时间复杂度O(n^2)的方法超时了。所以需要使用更优的方法，一种优化的方法思路如下：</p>
<blockquote>
<p>使用两个变量，一个表示底的开始，一个表示底的终点。一开始底的起点是数组第一位，终点是数组最后一位。这样去计算两者之间围成的区域，如果比当前记录的最大区域大，则将之记为最大区域值。之后，将两边中较短的一边向中间移动一个单位，再次计算区域大小，重复刚才的后续过程。<br>这里的难点是为什么移动的是两边中较小的一条呢？因为这条是这个区域增加的“短板“。移动较短的一边，也许会遇到一条更大的边，这样的话这种增加有可能抵消了底边的变短，甚至可能使得区域面积变得更大。相反的，如果移动的是较大的一边，最好的情况是遇到一条比较短边还要长的边，但是因为“木桶效应“，整个区域大小还是取决于较短的边，所以移动较长的一边是不可能得到更好的结果的。</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArea = min(height[i],height[j])*j;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            maxArea = max(maxArea,min(height[i],height[j])*(j-i));</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;height[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--9 类加载及执行子系统的案例与实战</title>
    <url>/2021/05/31/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_9_Case_and_practice_of_class_loading_and_execution_subsystem.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变。<br><a id="more"></a></p>
</blockquote>
<p>能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能。</p>
<h3 id="1-案例分析"><a href="#1-案例分析" class="headerlink" title="1. 案例分析"></a>1. 案例分析</h3><h4 id="1-1-Tomcat：正统的类加载器架构"><a href="#1-1-Tomcat：正统的类加载器架构" class="headerlink" title="1.1 Tomcat：正统的类加载器架构"></a>1.1 <code>Tomcat</code>：正统的类加载器架构</h4><p>主流的<code>Java Web服务器</code>，如<code>Tomcat</code>、<code>Jetty</code>、<code>WebLogic</code>、<code>WebSphere</code>等，都实现了自己定义的类加载器，而且一般不止一个。一个功能健全的Web服务器，要解决如下的这些问题：</p>
<ul>
<li>部署在<u>同一个服务器</u>上的两个Web应用程序所使用的Java类库可以实现<strong><u>相互隔离</u></strong>。</li>
<li>部署在<u>同一个服务器</u>上的两个Web应用程序所使用的Java类库可以<u><strong>互相共享</strong></u>。</li>
<li>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响。</li>
<li>支持<code>JSP</code>应用的Web服务器，十有八九都需要支持<code>HotSwap</code>功能。<code>JSP</code>文件由于其<u>纯文本存储</u>的特性，被运行时修改的概率远大于第三方类库或程序自己的Class文件。而且<code>ASP</code>、<code>PHP</code>和<code>JSP</code>这些网页应用也把<u><strong>修改后无须重启</strong></u>作为一 个很大的“优势”来看待，因此“主流”的Web服务器都会支持<code>JSP</code>生成类的<strong><code>热替换</code></strong>。</li>
</ul>
<p>由于存在上述问题，在部署Web应用时，各种Web服务器都提供了好几个有着不同含义的<code>ClassPath</code>路径供用户存放<u>第三方类库</u>，这些路径一般会以<code>“lib”</code>或<code>“classes”</code>命名。通常每一个目录都会有一个相应的<strong><code>自定义类加载器</code></strong>去加载放置在里面的Java类库。</p>
<h4 id="1-2-OSGi：灵活的类加载器架构"><a href="#1-2-OSGi：灵活的类加载器架构" class="headerlink" title="1.2 OSGi：灵活的类加载器架构"></a>1.2 <code>OSGi</code>：灵活的类加载器架构</h4><p><code>OSGi （Open Service Gateway Initiative）</code>是<code>OSGi联盟（OSGi Alliance）</code>制订的一个基于Java语言的<code>动态模块化规范</code>。<code>OSGi</code>中的每个模块（称为<code>Bundle</code>）与普通的Java类库区别并不太大，两者一般都以<code>JAR</code>格式进行封装，并且内部存储的都是Java的<code>Package</code>和<code>Class</code>。</p>
<ul>
<li>但是一个<code>Bundle</code>可以声明它所依赖的<code>Package</code>（通过<code>Import-Package</code>描述），也可以声明它允许导出发布的<code>Package</code>（通过<code>Export-Package</code>描述）。</li>
<li>在<code>OSGi</code>里面，<code>Bundle</code>之间的依赖关系从传统的上层模块依赖底层模块转变为<strong>平级模块之间的依赖</strong>，而且类库的可见性能得到非常精确的控制，一个模块里只有被<code>Export</code>过的<code>Package</code>才可能被外界访问，其他的<code>Package</code>和<code>Class</code>将会被隐藏起来。</li>
</ul>
<p>但引入<code>OSGi</code>的主要理由是基于<code>OSGi</code>架构的程序很可能会实现模块级的<strong><u>热插拔功能</u></strong>，该特性要归功于它灵活的类加载器架构：</p>
<ul>
<li><code>OSGi</code>的<code>Bundle</code>类加载器之间只有规则，没有固定的委派关系。例如，某个<code>Bundle</code>声明了一个它依赖的<code>Package</code>，如果有其他<code>Bundle</code>声明了发布这个<code>Package</code>后，那么所有对这个<code>Package</code>的类加载动作都会委派给发布它的<code>Bundle</code>类加载器去完成。</li>
<li>不涉及某个具体的Package时，各个Bundle加载器都是平级的关系，只有具体使用到某个<code>Package</code>和<code>Class</code>的时候，才会根据<code>Package</code><strong>导入导出定义</strong>来构造<code>Bundle</code>间的委派和依赖。</li>
<li>一个<code>Bundle</code>类加载器为其他<code>Bundle</code>提供服务时，会根据<code>Export-Package</code>列表严格控制访问范围。</li>
</ul>
<p>假设存在<code>Bundle A</code>、<code>Bundle B</code>、<code>Bundle C</code>这<code>3</code>个模块，并且这<code>3</code>个<code>Bundle</code>定义的依赖关系如下：</p>
<ul>
<li><code>Bundle A</code>：声明发布了<code>package A</code>，依赖了<code>java.*</code>的包；</li>
<li><code>Bundle B</code>：声明依赖了<code>package A</code>和<code>package C</code>，同时也依赖了<code>java.*</code>的包；</li>
<li><code>Bundle C</code>：声明发布了<code>package C</code>，依赖了<code>package A</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OSGiClassloaderArchitecture.PNG" alt="OSGi的类加载器架构"></p>
<p>在 <code>OSGi</code>里，类加载时可能进行的查找规则如下：</p>
<ul>
<li>以<code>java.*</code>开头的类，委派给父类加载器加载。</li>
<li>否则，委派列表名单内的类，委派给父类加载器加载。</li>
<li>否则，<code>Import</code>列表中的类，委派给<code>Export</code>这个类的<code>Bundle</code>的类加载器加载。</li>
<li>否则，查找当前<code>Bundle</code>的<code>Classpath</code>，使用自己的类加载器加载。</li>
<li>否则，查找是否在自己的<code>Fragment Bundle</code>中，如果是则委派给<code>Fragment Bundle</code>的类加载器加载。</li>
<li>否则，查找<code>Dynamic Import</code>列表的<code>Bundle</code>，委派给对应<code>Bundle</code>的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ul>
<h4 id="1-3-字节码生成技术与动态代理的实现"><a href="#1-3-字节码生成技术与动态代理的实现" class="headerlink" title="1.3 字节码生成技术与动态代理的实现"></a>1.3 字节码生成技术与动态代理的实现</h4><h5 id="1-3-1-字节码生成技术"><a href="#1-3-1-字节码生成技术" class="headerlink" title="1.3.1 字节码生成技术"></a>1.3.1 字节码生成技术</h5><p>要深入从Java源码到字节码编译过程，阅读<code>Javac</code>的源码是个很好的途径。在Java世界里面除了<code>Javac</code>和字节码类库外，使用到字节码生成的例子比比皆是：</p>
<ul>
<li>Web服务器中的<code>JSP编译器</code>，编译时植入的<code>AOP框架</code>；</li>
<li>动态代理技术；</li>
<li>使用反射的时候虚拟机有可能会在运行时生成字节码来提高执行速度。</li>
</ul>
<h5 id="1-3-2-动态代理技术"><a href="#1-3-2-动态代理技术" class="headerlink" title="1.3.2 动态代理技术"></a>1.3.2 动态代理技术</h5><p>动态代理的优势在于，<u>实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中</u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        Object originalObj;</span><br><span class="line"></span><br><span class="line">        <span class="function">Object <span class="title">bind</span><span class="params">(Object originalObj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.originalObj = originalObj;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"welcome"</span>);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(originalObj, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IHello hello = (IHello) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> Hello());</span><br><span class="line">        hello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Proxy::newProxyInstance()</code>方法返回一个实现了<code>IHello</code>的接口，并且代理了<code>new Hello()</code>实例行为的对象，程序进行过验证、优化、缓存、同步、生成字节码、显式类加载等操作，它最后调用<code>sun.misc.ProxyGenerator::generateProxyClass()</code>方法来完成<code>生成字节码</code>的动作，这个方法会在运行时产生一个描述代理类的字节码<strong>byte[]数组</strong>。</p>
<h4 id="1-4-Backport工具：Java的时光机器"><a href="#1-4-Backport工具：Java的时光机器" class="headerlink" title="1.4 Backport工具：Java的时光机器"></a>1.4 <code>Backport</code>工具：Java的时光机器</h4><p>“Java逆向移植”的工具（<code>Java Backporting Tools</code>）用于把<strong>高版本JDK</strong>中编写的代码放到低版本JDK环境中去部署使用。<code>Retrotranslator</code>和<code>Retrolambda</code>是这类工具中的杰出代表。</p>
<ul>
<li><code>Retrotranslator</code>的作用是将<code>JDK 5</code>编译出来的Class文件转变为可以在<code>JDK 1.4</code>或<code>1.3</code>上部署的版本，它能很好地支持<u>自动装箱</u>、<u>泛型</u>、<u>动态注解</u>、<u>枚举</u>、<u>变长参数</u>、<u>遍历循环</u>、<u>静态导入</u>这些语法特性， 甚至还可以支持<code>JDK 5</code>中新增的<u>集合改进</u>、<u>并发包</u>及<u>对泛型、注解等的反射操作</u>。</li>
<li><code>Retrolambda</code>将<code>JDK 8</code>的<code>Lambda</code>表达式和<code>try-resources</code>语法转变为可以在<code>JDK 5</code>、<code>JDK 6</code>、<code>JDK 7</code>中使用的形式，同时也对<code>接口默认方法</code>提供了<strong>有限度</strong>的支持。</li>
</ul>
<p>JDK的每次升级新增的功能大致可以分为以下五类：</p>
<ol>
<li>对Java类库API的代码增强。</li>
<li>在前端编译器层面做的改进。</li>
<li>需要在字节码中进行支持的改动。</li>
<li>需要在JDK整体结构层面进行支持的改进。</li>
<li>集中在虚拟机内部的改进。</li>
</ol>
<p>上述的5类新功能中，逆向移植工具能比较完美地模拟了前两类。</p>
<h3 id="2-实战：自己动手实现远程执行功能"><a href="#2-实战：自己动手实现远程执行功能" class="headerlink" title="2. 实战：自己动手实现远程执行功能"></a>2. 实战：自己动手实现远程执行功能</h3><p>做程序维护的时候会遇到只要在服务中执行一小段程序代码，就可以定位或排除问题，但就是偏偏找不到可以让服务器执行时代码的途径。通常解决这类问题有以下几种途径：</p>
<ol>
<li>可以使用<code>BTrace</code>这类<code>JVMTI</code>工具去动态修改程序中某一部分的运行代码，类似的<code>JVMTI</code>工具还有阿里巴巴的<code>Arthas</code>等。</li>
<li>使用<code>JDK 6</code>之后提供了<code>Compiler API</code>，可以动态地编译Java程序，这样虽然达不到动态语言的灵活度，但让服务器执行临时代码的需求是可以得到解决的。</li>
<li>写一个<code>JSP文件</code>上传到服务器，然后在浏览器中运行它，或者在服务端程序中加入一个<code>BeanShell Script</code>、<code>JavaScript</code>等的执行引擎去执行动态脚本。</li>
<li>在应用程序中内置动态执行的功能。</li>
</ol>
<h4 id="2-1-目标"><a href="#2-1-目标" class="headerlink" title="2.1 目标"></a>2.1 目标</h4><p>希望最终的产品：</p>
<ul>
<li>不依赖某个JDK版本才加入的特性（包括<code>JVMTI</code>），能在目前还被普遍使用的JDK中部署。</li>
<li>不改变原有服务端程序的部署，不依赖任何第三方类库。</li>
<li>不侵入原有程序，即无须改动原程序的任何代码。也不会对原有程序的运行带来任何影响。</li>
<li>考虑到<code>BeanShell Script</code>或<code>JavaScript</code>等脚本与Java对象交互起来不太方便，<code>“临时代码”</code>应该直接支持Java语言。</li>
<li><code>“临时代码”</code>应当具备足够的自由度，不需要依赖特定的类或实现特定的接口。</li>
<li><code>“临时代码”</code>的执行结果能返回到客户端，执行结果可以包括程序中输出的信息及抛出的异常等。</li>
</ul>
<h4 id="2-2-思路"><a href="#2-2-思路" class="headerlink" title="2.2 思路"></a>2.2 思路</h4><p>需要解决以下3个问题：</p>
<ol>
<li>如何编译提交到服务器的Java代码？<ul>
<li>在服务器上编译，在<code>JDK 6</code>以后可以使用<code>Compiler API</code>，在<code>JDK 6</code>以前可以使用<code>tools.jar</code>包中的 <code>com.sun.tools.Javac.Main</code>类来编译Java文件。这种思路的缺点是引入了额外的依赖，而且把程序绑死在<strong>特定</strong>的<code>JDK</code>上了。</li>
<li>在客户端编译好，把<strong><u>字节码</u></strong>传到服务端。</li>
</ul>
</li>
<li>如何执行编译之后的Java代码？<ul>
<li>让类加载器加载这个类生成一个Class对象，然后反射调用一下某个方法；</li>
</ul>
</li>
<li>如何收集Java代码的执行结果？<ul>
<li>把程序往<code>标准输出（System.out）</code>和<code>标准错误输出（System.err）</code>中打印的信息收集起来。但会对原有程序产生影响：<u>会把其他线程向标准输出中打印的信息也收集了</u>。</li>
<li>直接在执行的类中把对<code>System.out</code>的符号引用替换为我们准备的<code>PrintStream</code>的符号引用。</li>
</ul>
</li>
</ol>
<h4 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h4><p>实现过程中需要用到的4个支持类：</p>
<h5 id="2-3-1-HotSwapClassLoader"><a href="#2-3-1-HotSwapClassLoader" class="headerlink" title="2.3.1 HotSwapClassLoader"></a>2.3.1 <code>HotSwapClassLoader</code></h5><p><code>HotSwapClassLoader</code>类于实现<code>“同一个类的代码可以被多次加载”</code>这个需求。<code>HotSwapClassLoader</code>所做的事情仅仅是公开父类（即<code>java.lang.ClassLoader</code>）中的<code>protected</code>方法<code>defineClass()</code>，我们将会使用这个方法<u><strong>把提交执行的Java类的<code>byte[]</code>数组转变为Class对象</strong></u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了多次载入执行类而加入的加载器</span></span><br><span class="line"><span class="comment"> * 把defineClass方法开放出来，只有外部显式调用的时候才会使用到loadByte方法</span></span><br><span class="line"><span class="comment"> * 由虚拟机调用时，仍然按照原有的双亲委派规则使用loadClass方法进行类加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotSwapClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HotSwapClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HotSwapClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadByte</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, classByte, <span class="number">0</span>, classByte.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-2-ClassModifier"><a href="#2-3-2-ClassModifier" class="headerlink" title="2.3.2 ClassModifier"></a>2.3.2 <code>ClassModifier</code></h5><p><code>ClassModifier</code>类实现将<code>java.lang.System</code>替换为我们自己定义的<code>HackSystem</code>类的过程，它<strong><u>直接修改符合Class文件格式的byte[]数组中的<code>常量池</code>部分，将常量池中指定内容的<code>CONSTANT_Utf8_info</code>常量替换为新的字符串</u></strong>。</p>
<p>经过<code>ClassModifier</code>处理后的<code>byte[]数组</code>才会传给<code>HotSwapClassLoader.loadByte()</code>方法进行类加载，<code>byte[]数组</code>在这里替换符号引用之后，与客户端直接在Java代码中引用<code>HackSystem</code>类再编译生成的Class是完全一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** 修改Class文件，暂时只提供修改常量池常量的功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassModifier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class文件中常量池的起始偏移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_POOL_COUNT_INDEX = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CONSTANT_Utf8_info常量的tag标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_Utf8_info = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量池中11种常量所占的长度，CONSTANT_Utf8_info型常量除外，因为它不是定长的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] CONSTANT_ITEM_LENGTH = &#123; -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] classByte;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassModifier</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classByte = classByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改常量池中CONSTANT_Utf8_info常量的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldStr 修改前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newStr 修改后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 修改结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] modifyUTF8Constant(String oldStr, String newStr) &#123;</span><br><span class="line">        <span class="keyword">int</span> cpc = getConstantPoolCount();</span><br><span class="line">        <span class="keyword">int</span> offset = CONSTANT_POOL_COUNT_INDEX + u2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cpc; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tag = ByteUtils.bytes2Int(classByte, offset, u1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tag == CONSTANT_Utf8_info) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = ByteUtils.bytes2Int(classByte, offset + u1, u2);</span><br><span class="line">                offset += (u1 + u2);</span><br><span class="line">                String str = ByteUtils.bytes2String(classByte, offset, len);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (str.equalsIgnoreCase(oldStr)) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] strBytes = ByteUtils.string2Bytes(newStr);</span><br><span class="line">                    <span class="keyword">byte</span>[] strLen = ByteUtils.int2Bytes(newStr.length(), u2);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset - u2, u2, strLen);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset, len, strBytes);</span><br><span class="line">                    <span class="keyword">return</span> classByte;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    offset += len;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                offset += CONSTANT_ITEM_LENGTH[tag];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classByte;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取常量池中常量的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 常量池数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getConstantPoolCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ByteUtils.bytes2Int(classByte, CONSTANT_POOL_COUNT_INDEX, u2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-3-ByteUtils"><a href="#2-3-3-ByteUtils" class="headerlink" title="2.3.3 ByteUtils"></a>2.3.3 <code>ByteUtils</code></h5><p><code>ClassModifier</code>中涉及对<code>byte[]数组</code>操作的部分， 主要是将<code>byte[]</code>与<code>int</code>和<code>String</code>互相转换，以及把对<code>byte[]数据</code>的替换操作封装在<code>ByteUtils</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** Bytes数组处理工具</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bytes2Int</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = start + len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = ((<span class="keyword">int</span>) b[i]) &amp; <span class="number">0xff</span>;</span><br><span class="line">            n &lt;&lt;= (--len) * <span class="number">8</span>;</span><br><span class="line">            sum = n + sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] int2Bytes(<span class="keyword">int</span> value, <span class="keyword">int</span> len) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            b[len - i - <span class="number">1</span>] = (<span class="keyword">byte</span>) ((value &gt;&gt; <span class="number">8</span> * i) &amp; <span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytes2String</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(b, start, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] string2Bytes(String str) &#123;</span><br><span class="line">        <span class="keyword">return</span> str.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] bytesReplace(<span class="keyword">byte</span>[] originalBytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, <span class="keyword">byte</span>[] replaceBytes) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] newBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[originalBytes.length + (replaceBytes.length - len)];</span><br><span class="line">        System.arraycopy(originalBytes, <span class="number">0</span>, newBytes, <span class="number">0</span>, offset);</span><br><span class="line">        System.arraycopy(replaceBytes, <span class="number">0</span>, newBytes, offset, replaceBytes.length);</span><br><span class="line">        System.arraycopy(originalBytes, offset + len, newBytes, offset + replaceBytes.length, originalBytes.length - offset - len);</span><br><span class="line">        <span class="keyword">return</span> newBytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-4-HackSystem"><a href="#2-3-4-HackSystem" class="headerlink" title="2.3.4 HackSystem"></a>2.3.4 <code>HackSystem</code></h5><p>用来代替<code>java.lang.System</code>的<code>HackSystem</code>，主要把<code>out</code>和<code>err</code>两个静态变量改成使用<code>ByteArrayOutputStream</code>作为打印目标的同一个<code>PrintStream</code>对象，以及增加了<u><strong>读取</strong></u>、<u><strong>清理</strong></u><code>ByteArrayOutputStream</code>中内容的<code>getBufferString()</code>和 <code>clearBuffer()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为Javaclass劫持java.lang.System提供支持</span></span><br><span class="line"><span class="comment"> * 除了out和err外，其余的都直接转发给System处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HackSystem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> InputStream in = System.in;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out = <span class="keyword">new</span> PrintStream(buffer);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream err = out;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getBufferString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buffer.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSecurityManager</span><span class="params">(<span class="keyword">final</span> SecurityManager s)</span> </span>&#123;</span><br><span class="line">        System.setSecurityManager(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecurityManager <span class="title">getSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.getSecurityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(src, srcPos, dest, destPos, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">identityHashCode</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.identityHashCode(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面所有的方法都与java.lang.System的名称一样</span></span><br><span class="line">    <span class="comment">// 实现都是字节转调System的对应方法</span></span><br><span class="line">    <span class="comment">// 因版面原因，省略了其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-5-JavaclassExecuter"><a href="#2-3-5-JavaclassExecuter" class="headerlink" title="2.3.5 JavaclassExecuter"></a>2.3.5 <code>JavaclassExecuter</code></h5><p><code>JavaclassExecuter</code>是提供给外部调用的入口，调用前面几个支持类组装逻辑，完成类加载工作。</p>
<ul>
<li>用输入的符合Class文件格式的<code>byte[]数组</code>替换掉<code>java.lang.System</code>的符号引用后，使用<code>HotSwapClassLoader</code>加载生成一个Class对象；</li>
<li>然后<code>反射</code>调用这个Class对象的<code>main()</code>方法，如果期间出现任何异常，将异常信息打印到<code>HackSystem.out</code>中，</li>
<li>最后把缓冲区中的信息作为方法的结果来返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Javaclass执行工具</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaclassExecuter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行外部传过来的代表一个Java类的Byte数组&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 将输入类的byte数组中代表java.lang.System的CONSTANT_Utf8_info常量修改为劫持后的HackSystem类</span></span><br><span class="line"><span class="comment">     * 执行方法为该类的static main(String[] args)方法，输出结果为该类向System.out/err输出的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classByte 代表一个Java类的Byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">execute</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        HackSystem.clearBuffer();</span><br><span class="line">        ClassModifier cm = <span class="keyword">new</span> ClassModifier(classByte);</span><br><span class="line">        <span class="keyword">byte</span>[] modiBytes = cm.modifyUTF8Constant(<span class="string">"java/lang/System"</span>, <span class="string">"org/fenixsoft/classloading/execute/HackSystem"</span>);</span><br><span class="line">        HotSwapClassLoader loader = <span class="keyword">new</span> HotSwapClassLoader();</span><br><span class="line">        Class clazz = loader.loadByte(modiBytes);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = clazz.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[]&#123;String[]<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            method.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> String[]&#123; <span class="keyword">null</span> &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace(HackSystem.out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HackSystem.getBufferString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-验证"><a href="#2-4-验证" class="headerlink" title="2.4 验证"></a>2.4 验证</h4><p>写一个Java类，只要向<code>System.out</code>输出信息即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test executor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立一个测试代码，就可以在输出这个类的运行结果(原文是通过<code>JSP</code>来实现的，这里没有搭建服务器，就用这个小例子试试，可能不是那么合适的代替)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecuter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/Users/yunjiewu/IdeaProjects/JavaLearning/out/production/JavaLearning/JVMLearning/JavaclassExecuter/TestClass.class"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line">            is.close();</span><br><span class="line">            System.out.println(JavaclassExecuter.execute(b));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--16. 3Sum Closest</title>
    <url>/2019/04/09/LeetCode--16-3Sum-Closest.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array <strong>nums</strong> of n integers and an integer <strong>target</strong>, find three integers in <strong>nums</strong> such that the sum is closest to <strong>target</strong>. Return the sum of the three integers. You may assume that each input would have exactly one solution.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given array nums = [-1, 2, 1, -4], and target = 1.</p>
<p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这个题和它的前一道题<a href="http://wuyunjie.top/2019/04/07/LeetCode-15-3Sum/" title="15. 3Sum">15. 3Sum</a>很像，前一道题可以看做本题在target = 0时的特殊情况。但这道题进行了一定的改写和简化：</p>
<blockquote>
<ol>
<li>存在且仅存在一个解，所以我们可以在找到一个最优解后立即停止;</li>
<li>要寻找的是最接近target的三数和。也就是说可能会没有等于target的情况，比如题目的例子就是如此；另一方面只需要返回这三个数的和，不需要记录这三个数，所以对结果的记录和判断简化了。</li>
</ol>
</blockquote>
<p>我们只需要在15题的算法的基础上进行一定的修改就可以得到这道题的结果了。我们可以用同样的方法，先对数组进行排序，固定一个数a，然后去找另外两个数b和c的组合：</p>
<ol>
<li>如果我们只要找到两个数且和(b+c)为(target - a)，那么找到了最接近的三数和即target;</li>
<li>否者我们记录下当前数以及与target的距离(定义为|target-(a+b+c)|)，继续遍历数组找下一个更相近的三数和。</li>
</ol>
<p>同样的，在寻找过程中，我们可以跳过那些重复的组合，并且进行合适的剪枝进行优化。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> closesetDistance = <span class="built_in">abs</span>(nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[nums.size()<span class="number">-1</span>] - target);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>,high = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[low] + nums[high];</span><br><span class="line">                <span class="keyword">if</span>(sum == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(sum-target &lt; closesetDistance)</span><br><span class="line">                    &#123;</span><br><span class="line">                        closesetDistance = sum-target;</span><br><span class="line">                        res = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] == nums[--high]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target-sum &lt; closesetDistance)</span><br><span class="line">                    &#123;</span><br><span class="line">                        closesetDistance = target-sum;</span><br><span class="line">                        res = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] == nums[++low]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--15. 3Sum</title>
    <url>/2019/04/07/LeetCode--15-3Sum.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array <strong>nums</strong> of n integers, are there elements a, b, c in <strong>nums</strong> such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br><a id="more"></a></p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>The solution set must not contain duplicate triplets.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given array nums = [-1, 0, 1, 2, -1, -4],</p>
<p>A solution set is:<br>[<br> [-1, 0, 1],<br> [-1, -1, 2]<br>]</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这个题和第一题Two Sum有些类似，但是要比那道题复杂一些。它的结果不止一个，而且返回的结果里不能有重复的解，由于用向量保存解，可能同一个解有不同的排列方式，去重的话会很麻烦。需要想一种算法，在计算结果的同时，跳过重复解。所以这道题应该不是考察Two Sum的解法。</p>
<p>分析一下这道题的特点，要我们找出三个数且和为0，那么除了三个数全是0的情况之外，肯定会有负数和正数。我们可以先固定一个数a，然后去找另外两个数b和c，我们只要找到两个数且和(b+c)为第一个数a的相反数就行了。在寻找这两个数组合的过程中，我们肯定不希望遍历所有两个数的组合。最先想到的就是，对原数组先进行一个排序，然后遍历这个排序后的数组，寻找合适的解。主要过程大致如下：</p>
<blockquote>
<ol>
<li>设置low, high，分别从左边和右边向中间遍历数组:如果找到了 a+b+c=0，把结果放入答案集内;若a+b+c &lt; 0，则(b+c)过小，增大low；若a+b+c &gt; 0，则(b+c)过大，减小high</li>
<li>在遍历过程中，若两个数相同，在数组中一定是相邻的，可以跳过这些相同的数。</li>
<li>我们也可以先做个剪枝优化，就是当遍历到正数a的时候就break，因为我们的数组现在是有序的了，如果第一个要数a就是正数了，那么后面的数字b,c就都是正数，就永远不会出现和为0的情况了。</li>
</ol>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">2</span> || nums.front()&gt;<span class="number">0</span> || nums.back() &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>,high = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[low] + nums[high];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tuple = &#123;nums[i], nums[low], nums[high]&#125;;</span><br><span class="line">                    res.push_back(tuple);</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] == nums[++low] );</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] == nums[--high] );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) high--;</span><br><span class="line">                <span class="keyword">else</span> low++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--14. Longest Common Prefix</title>
    <url>/2019/04/07/LeetCode--14-Longest-Common-Prefix.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Write a function to find the longest common prefix string amongst an array of strings.<br><a id="more"></a><br>If there is no common prefix, return an empty string “”.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: [“flower”,”flow”,”flight”]<br>Output: “fl”</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: [“dog”,”racecar”,”car”]<br>Output: “”<br>Explanation: There is no common prefix among the input strings.</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>All given inputs are in lowercase letters <strong>a-z</strong>.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目很简单，求一组字符串的最长公共前缀。因为是公共前缀，所以必定所有字符串都包含这个前缀。想法是用一个字符串LCP保存已经比较过的字符串的公共前缀，然后逐个遍历修正这个公共前缀，最终就可以得到结果。</p>
<p>看了题解后，发现这种方法叫做水平扫描法，除了这种方法外，还有许多其他方法可以求解。</p>
<p>算法二： 垂直扫描法</p>
<blockquote>
<p>若数组末尾有一个非常短的字符串，使用水平扫描法依旧会进行S次比较，可以对其进行优化。即从前往后扫描字符串每一列，先判断每个字符串相同列上字符是否相同。</p>
</blockquote>
<p>算法三： 分治</p>
<blockquote>
<p>使用分治的技巧，将原问题 LCP(Si…Sj) 分成两个子问题 LCP(Si…Smid) 与 LCP(Smid+1…Sj)，其中mid = (i+j)/2.用子问题的解 lcpLeft 与 lcpRight 构造原问题的解 LCP(Si…Sj)。</p>
</blockquote>
<p><img src="https://leetcode-cn.com/media/original_images/14_lcp_diviso_et_lmpera.png" alt=""></p>
<p>算法四：</p>
<blockquote>
<p>还有一种解法，这种方法给输入字符串数组排了个序。按字母顺序排序的话，那么有共同字母多的两个字符串会被排到一起，而跟大家相同的字母越少的字符串会被挤到首尾两端，那么如果有共同前缀的话，一定会出现在首尾两端的字符串中，所以我们只需要找首尾字母串的共同前缀即可。<br>比如例子1排序后为 [“flight”, “flow”, “flower”]，例子2排序后为 [“car”, “dog”, “racecar”]，虽然例子2没有共同前缀，但也可以认为共同前缀是空串，且出现在首尾两端的字符串中。由于是按字母顺序排的，而不是按长度，所以首尾字母的长度关系不知道，为了防止溢出错误，我们只遍历而这种较短的那个的长度，找出共同前缀返回即可。</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="水平扫描"><a href="#水平扫描" class="headerlink" title="水平扫描"></a>水平扫描</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> lcp = strs[<span class="number">0</span>]; <span class="comment">//初始化公共前缀</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逐个遍历，不断修正</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; strs.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j &lt; lcp.length() &amp;&amp; j &lt; strs[i].length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lcp[j] != strs[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            lcp = lcp.substr(<span class="number">0</span>,j);</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="垂直扫描"><a href="#垂直扫描" class="headerlink" title="垂直扫描"></a>垂直扫描</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> lcp = strs[<span class="number">0</span>]; <span class="comment">//初始化公共前缀</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逐个遍历，不断修正</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lcp.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; strs.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == strs[j].size() || strs[j][i] != lcp[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> lcp.substr(<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">commomPredix</span><span class="params">(<span class="built_in">string</span> left, <span class="built_in">string</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; left.length() &amp;&amp; i &lt; right.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left[i] != right[i]) <span class="keyword">return</span> left.substr(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.substr(<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LCP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">string</span> leftLCP = LCP(strs, l, mid);</span><br><span class="line">            <span class="built_in">string</span> rightLCP = LCP(strs, mid+<span class="number">1</span>, r);</span><br><span class="line">            <span class="keyword">return</span> commomPredix(leftLCP,rightLCP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> LCP(strs, <span class="number">0</span>, strs.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="算法四"><a href="#算法四" class="headerlink" title="算法四"></a>算法四</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        sort(strs.begin(), strs.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = min(strs[<span class="number">0</span>].size(), strs.back().size());</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; strs[<span class="number">0</span>][i] == strs.back()[i]) ++i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--17. Letter Combinations of a Phone Number</title>
    <url>/2019/04/10/LeetCode--17-Letter-Combinations-of-a-Phone-Number.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.<br><a id="more"></a><br>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p>
<p><strong>Example :</strong></p>
<blockquote>
<p>Input: “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目让模拟手机9键的键盘，给定一个数字字符串(代表按键顺序)，给出可能的所有字母组合。简单理解，就是求每个数字所代表的字符集合的笛卡尔积，找出所有可能的情况。</p>
<p>想法是先在一个vector数组内放入一个空字符””。之后扫描字符串，每次识别到一个数字，就将这个数字所对应的字符分别与vector数组内的字符串连接加入数组，然后删去连接前的旧字符串，继续下一次扫描。当扫描完数字字符串时，就可以成功得到结果了。除此之外还有其他方法：</p>
<blockquote>
<p><strong>回溯法(Backtracking)</strong><br>回溯法是寻找所有可能的候选结果的一种算法。定义一个回溯函数<code>backtrack(combination, next_digits)</code>，生成结果并逐个字符检查。</p>
<ul>
<li>若已经没有digits需要继续处理，说明结果已经成功生成，存入结果集。</li>
<li>如果仍然有还未检查的digits字符，继续处理该字符：<ul>
<li>将该字符代表的字母加入当前生成的结果 <code>combination = combination + letter</code></li>
<li>继续处理剩余的字符：<code>backtrack(combination + letter, next_digits[1:])</code></li>
</ul>
</li>
</ul>
</blockquote>
<p><a href="https://imgchr.com/i/AT0u8J" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/10/AT0u8J.png" alt="AT0u8J.png"></a></p>
<blockquote>
<p>这是一种递归迭代的方法。方法思想差不多，只是这种方法用递归实现。</p>
<p>其中还可以继续优化的是，可以不使用unordered_map，直接用一个一维string数组来存储mapping数组。</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; mapping = &#123;</span><br><span class="line">        &#123;<span class="string">'1'</span>,<span class="string">""</span>&#125;, &#123;<span class="string">'2'</span>,<span class="string">"abc"</span>&#125;,&#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,&#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;, &#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,&#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(<span class="number">1</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; digits.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res_length = res.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mapping[digits[i]].length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; res_length;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(res[k]+mapping[digits[i]][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.erase(res.begin(),res.begin()+res_length);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; mapping = &#123;</span><br><span class="line">        &#123;<span class="string">'1'</span>,<span class="string">""</span>&#125;, &#123;<span class="string">'2'</span>,<span class="string">"abc"</span>&#125;,&#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,&#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;, &#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,&#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">string</span> combination, <span class="built_in">string</span> digits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(combination);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> letters = mapping[digits[<span class="number">0</span>]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;letters.length();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                backtrack(combination+letters[i], digits.substr(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() != <span class="number">0</span>) </span><br><span class="line">            backtrack(<span class="string">""</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法三-不使用unordered-map"><a href="#方法三-不使用unordered-map" class="headerlink" title="方法三(不使用unordered_map)"></a>方法三(不使用unordered_map)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> mapping[<span class="number">10</span>] = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(<span class="number">1</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; digits.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res_length = res.size();</span><br><span class="line">            <span class="built_in">string</span> letters = mapping[digits[i]-<span class="string">'0'</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; letters.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; res_length;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(res[k]+letters[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.erase(res.begin(),res.begin()+res_length);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--2. Add Two Numbers</title>
    <url>/2019/03/28/LeetCode--2-Add-Two-Numbers.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br><a id="more"></a><br>You may assume the two numbers do not contain any leading zero, except the number 0 itself. </p>
</blockquote>
<p><strong>Example:</strong></p>
<blockquote>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目意思即，两个数是用链表按逆序存储的，现在要求两个数的和。实现算法思想即，模拟一个加法器，按位(这里即每一个链表结点)相加，需要设置一个进位标志位。这里只需要注意几种特殊情况即可：<br>1.两个数不一样长时，需要额外处理；<br>2.如果最终计算结果超过两个数的长度时，需要多增加一位。<br>在实现过程中，用一个新的链表来存储计算结果。<br>在查看讨论区后，发现算法思路大致相同，但是别人的代码更加精简，可以从中借鉴代码的一些简化方法和思想</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li>解法1</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> CF=<span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>; <span class="comment">//每位计算的中间结果</span></span><br><span class="line">        ListNode* result=<span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//新链表存储结果，头结点</span></span><br><span class="line">        ListNode* present=result; <span class="comment">//结果链表当前节点</span></span><br><span class="line">        <span class="comment">//两个数都有节点还未计算是，循环按位计算</span></span><br><span class="line">		<span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//加法结果</span></span><br><span class="line">            tmp=(l1-&gt;val+l2-&gt;val+CF)%<span class="number">10</span>;</span><br><span class="line">            present-&gt;val=tmp;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//进位</span></span><br><span class="line">            CF=(l1-&gt;val+l2-&gt;val+CF)/<span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//链表指针后移</span></span><br><span class="line">			l1=l1-&gt;next;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//如果其中一个数已经加完，不再new新节点</span></span><br><span class="line">            <span class="keyword">if</span>(l1&amp;&amp;l2)</span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                present=present-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//若其中一个数未加完，即比另外一个数要长，需要结合进位进一步处理</span></span><br><span class="line">		<span class="comment">//两个数的处理方式相同</span></span><br><span class="line">        <span class="keyword">while</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//有进位，需要加上进位继续处理</span></span><br><span class="line">            <span class="keyword">if</span>(CF==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                present=present-&gt;next;</span><br><span class="line"></span><br><span class="line">                tmp=(l1-&gt;val+CF)%<span class="number">10</span>;</span><br><span class="line">                present-&gt;val=tmp;</span><br><span class="line"></span><br><span class="line">                CF=(l1-&gt;val+CF)/<span class="number">10</span>;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//若已经没进位，计算结果后面的数与该数剩下的数相同</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=l1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(CF==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                present=present-&gt;next;</span><br><span class="line"></span><br><span class="line">                tmp=(l2-&gt;val+CF)%<span class="number">10</span>;</span><br><span class="line">                present-&gt;val=tmp;</span><br><span class="line"></span><br><span class="line">                CF=(l2-&gt;val+CF)/<span class="number">10</span>;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=l2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果两个数都加完了，还有进位，那么new一个新节点，保存该进位</span></span><br><span class="line">        <span class="keyword">if</span>(CF==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>精简的解法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode preHead(0), *p = &amp;preHead;</span><br><span class="line">        <span class="keyword">int</span> extra = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || extra) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + extra;</span><br><span class="line">            extra = sum / <span class="number">10</span>;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--18. 4Sum</title>
    <url>/2019/04/10/LeetCode--18-4Sum.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array <code>nums</code> of n integers and an integer <code>target</code>, are there elements a, b, c, and d in <code>nums</code> such that a + b + c + d = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.<br><a id="more"></a></p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>The solution set must not contain duplicate quadruplets.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</p>
<p>A solution set is:<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题和前面几道关于数字之和的题应该是同一个系列(<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%941-Two-Sum/" title="Two Sum">Two Sum</a>，<a href="http://wuyunjie.top/2019/04/07/LeetCode-15-3Sum/" title="3Sum">3Sum</a>，<a href="http://wuyunjie.top/2019/04/09/LeetCode-16-3Sum-Closest/" title="3Sum Closest">3Sum Closest</a>)。尽管难度有所提升，但是解题的思想和算法实际上都一致，其实也就是多了层循环。比如四个数a,b,c,d，我们可以先固定数a，然后寻找b,c,d，这就转换成了三数和的问题。</p>
<p>现在遇到了许多类似的问题，而且可以看出他们的解决方法具有一定规律，可以进行拓展。那么是不是可以找到一种泛化的方法计算KSUM，使得我们以后遇到5sum, 6sum…等等类似的问题时，不必再去重写这些算法，只用一个泛化的算法就可以搞定这一些。翻看评论区后，发现已经有人实现了这样的算法，主要是通过递归DFS实现的。每次先固定一个数，然后递归找到K-1SUM的结果。依次类推，直到找到2SUM返回最终结果，开始回溯。代码实现如下。</p>
<p>参考文献：<br><a href="https://leetcode.com/problems/4sum/discuss/8641/12ms-KSum-c%2B%2B-code" target="_blank" rel="noopener" title="12ms KSum, c++ code">[1] 12ms KSum, c++ code</a><br><a href="https://leetcode.com/problems/4sum/discuss/163559/C%2B%2B-solution-for-all-Ksum-question" target="_blank" rel="noopener" title="[1] C++ solution for all Ksum question">[2] C++ solution for all Ksum question</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="4SUM"><a href="#4SUM" class="headerlink" title="4SUM"></a>4SUM</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">3</span> || (nums.front() &gt; target &amp;&amp; nums.front() &gt; <span class="number">0</span>) || (nums.back() &lt; target &amp;&amp; nums.back() &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[n<span class="number">-3</span>]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>]&lt;target) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> tmp_target = target - nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n <span class="number">-2</span>  ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[j+<span class="number">1</span>]+nums[j+<span class="number">2</span>]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>]&lt;target) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> low = j+<span class="number">1</span>,high = n<span class="number">-1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>( low &lt; high)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[j] + nums[low] + nums[high];</span><br><span class="line">                    <span class="keyword">if</span>(sum == tmp_target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tuple = &#123;nums[i], nums[j], nums[low], nums[high]&#125;;</span><br><span class="line">                        res.push_back(tuple);</span><br><span class="line">                        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] == nums[++low] );</span><br><span class="line">                        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] == nums[--high] );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; tmp_target) high--;</span><br><span class="line">                    <span class="keyword">else</span> low++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="KSUM"><a href="#KSUM" class="headerlink" title="KSUM"></a>KSUM</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Valid for K &gt;= 2</span></span><br><span class="line">    <span class="comment">// k表示求ksum,nums是目标数组,l,r分别是左右游标</span></span><br><span class="line">    <span class="comment">// target是当前目标数, retVal是最终结果, cur是当前阶段的中间结果</span></span><br><span class="line">    <span class="comment">// ci表示当前是正在求第ci个数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">KSum</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; retVal, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="keyword">int</span> ci )</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mn, mx; <span class="comment">//mn表示当前最小的数，mx表示当前最大的数</span></span><br><span class="line">        <span class="keyword">int</span> km1 = k - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( r-l+<span class="number">1</span> &lt; k ) <span class="keyword">return</span>; <span class="comment">//若剩余的数比K小，已经无法找到结果，结束递归</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ( l &lt; r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新当前最小数和最大数</span></span><br><span class="line">            mn = nums[l];</span><br><span class="line">            mx = nums[r];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 若mn + (k-1)*mx &lt; target，mn太小，l右移</span></span><br><span class="line">            <span class="keyword">if</span> ( ( mn + km1*mx ) &lt; target ) l++;</span><br><span class="line">            <span class="comment">// 若(k-1)*mn + mx &gt; target，mx太大，r左移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( ( km1*mn + mx ) &gt; target ) r--;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// K=2,直接求出最终结果，其中包括去重操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( k == <span class="number">2</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                cur[ci] = mn;</span><br><span class="line">                cur[ci+<span class="number">1</span>] = mx;</span><br><span class="line">                retVal.push_back( cur );</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">while</span> ( ( l &lt; r ) &amp;&amp; ( nums[l] == mn ) ) l++;</span><br><span class="line">                r--;</span><br><span class="line">                <span class="keyword">while</span> ( ( l &lt; r ) &amp;&amp; ( nums[r] == mx ) ) r--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否者，递归转化为k-1 Sum的问题，递归求解</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur[ci] = mn; <span class="comment">//记录下当前可能的第ci个数</span></span><br><span class="line">                <span class="comment">//递归求解k-1 Sum</span></span><br><span class="line">                KSum( km1, nums, ++l, r, target - mn, retVal, cur, ci+<span class="number">1</span> );</span><br><span class="line">                <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">while</span> ( ( l &lt; r ) &amp;&amp; ( nums[l] == nums[l<span class="number">-1</span>] ) ) l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; RetVal;</span><br><span class="line">        <span class="comment">//初始化中间结果向量</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序，用于后面去重</span></span><br><span class="line">        sort( nums.begin(), nums.end() );</span><br><span class="line">        </span><br><span class="line">        KSum( <span class="number">4</span>, nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>, target, RetVal, cur, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RetVal;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--22. Generate Parentheses</title>
    <url>/2019/04/14/LeetCode--22-Generate-Parentheses.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.<br><a id="more"></a><br>For example, given n = 3, a solution set is:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &quot;((()))&quot;,</span><br><span class="line">    &quot;(()())&quot;,</span><br><span class="line">    &quot;(())()&quot;,</span><br><span class="line">    &quot;()(())&quot;,</span><br><span class="line">    &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>以前做过类似的题，也就是求一组数字可以通过栈得到的所有合法排序。当时的做法是，先求出所有可能的排序，然后判断每一种排序的合法性。获取全排序可以通过函数next_permutation()做到：</p>
<blockquote>
<p>C++ STL中提供了std::next_permutation与std::prev_permutation可以获取数字或者是字符的全排列，其中std::next_permutation提供升序、std::prev_permutation提供降序。</p>
</blockquote>
<p>所以结合前面有一题判断括号是否有效。最开始的想法是将括号全排序后，找到有效的括号排列，放入结果集。遍历完所有可能后，就可以找到最终的结果了。</p>
<p>但是这种方法效率很低。另一种方法是，使用递归回溯，每次生成合法的括号序列加入结果集中，这种方法避免了生成无效排序。</p>
<blockquote>
<p>长度为 n 的序列就是 ‘(‘ 加上所有长度为 n-1 的序列，以及 ‘)’ 加上所有长度为 n-1 的序列。只有在保证序列仍然保持有效时才添加 ‘(‘ or ‘)’，我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号。</p>
</blockquote>
<p>还有一种方法，LeetCode上称之为Closure number，但感觉很像分治。我们可以把一个合法的括号字符串看做一个闭包，它必然起于左括号止于右括号，且每个合法括号串都可以从某个位置分为两个同样合法的括号串（包括空串），因此对于给定的n所可能构造的所有括号串都可以一步步划分为两个子闭包并解构（去掉头尾的一对左右括号）直到最小闭包——空串为止。基于以上分析，我们就可以从空串开始逆向一步步对两个子闭包之一构造新的闭包（在头尾各添加一个左/右括号）然后合并。这种方法还不是特别懂，只是跟着算法用c++重写了一遍。</p>
<p>参考文献：<br>[1] <a href="https://www.cnblogs.com/aiguona/p/7304945.html" target="_blank" rel="noopener" title="C++ STL 全排列函数详解">C++ STL 全排列函数详解</a><br>[2] <a href="https://blog.csdn.net/weixin_34216107/article/details/86906251" target="_blank" rel="noopener" title="LeetCode Record C++">LeetCode Record C++</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="全排序后筛选"><a href="#全排序后筛选" class="headerlink" title="全排序后筛选"></a>全排序后筛选</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; brackets;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    brackets.pop();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> brackets.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(brackets.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> parentheses = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) parentheses+=<span class="string">"()"</span>;</span><br><span class="line">        </span><br><span class="line">        sort(parentheses.begin(), parentheses.end());</span><br><span class="line">        result.push_back(parentheses);</span><br><span class="line">        <span class="keyword">while</span>(next_permutation(parentheses.begin(), parentheses.end()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(parentheses)) result.push_back(parentheses);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result, <span class="built_in">string</span> cur, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.length() == max*<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(open &lt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrack(result, cur+<span class="string">"("</span>, open+<span class="number">1</span>, close, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(close &lt; open)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrack(result, cur+<span class="string">")"</span>, open, close+<span class="number">1</span>, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        backtrack(result, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="闭包数"><a href="#闭包数" class="headerlink" title="闭包数"></a>闭包数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> left:generateParenthesis(c))</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> right:generateParenthesis(n<span class="number">-1</span>-c))</span><br><span class="line">                        result.push_back(<span class="string">"("</span>+left+<span class="string">")"</span>+right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--20. Valid Parentheses</title>
    <url>/2019/04/14/LeetCode--20-Valid-Parentheses.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.<br><a id="more"></a><br>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: “()”<br>Output: true</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: “()[]{}”<br>Output: true</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: “(]”<br>Output: false</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input: “([)]”<br>Output: false</p>
</blockquote>
<p><strong>Example 5:</strong></p>
<blockquote>
<p>Input: “{[]}”<br>Output: true</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题很经典，也就是让我们判断给定的括号字符串是不是合法的，考察的应该是栈的运用。通过栈就可以很容易的解决问题，遍历字符串：</p>
<blockquote>
<ol>
<li>若遍历到是左括号<code>&#39;(&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;[&#39;</code>，将其推入栈中；</li>
<li>若遇到的是右括号，在栈顶找是否有匹配的左括号：若匹配成功，将栈顶弹出，继续遍历；若匹配失败，代表括号不合法，返回false.</li>
<li>遍历完字符串后，检查栈是否为空，若不空，代表不合法。</li>
</ol>
</blockquote>
<p>评论区有一种不使用stack的解法，它是直接在原字符串上模拟一个栈，保证只有左括号在栈内。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="使用stack"><a href="#使用stack" class="headerlink" title="使用stack"></a>使用stack</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; brackets;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'('</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        brackets.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">                    <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'&#123;'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        brackets.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">                    <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'['</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        brackets.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    brackets.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(brackets.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不使用stack"><a href="#不使用stack" class="headerlink" title="不使用stack"></a>不使用stack</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(top&lt;<span class="number">0</span> || !isMatch(s[top], s[i]))&#123;</span><br><span class="line">                ++top;</span><br><span class="line">                s[top] = s[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                --top;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">'('</span> &amp;&amp; c2 == <span class="string">')'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">'['</span> &amp;&amp; c2 == <span class="string">']'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">'&#123;'</span> &amp;&amp; c2 == <span class="string">'&#125;'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--21. Merge Two Sorted Lists</title>
    <url>/2019/04/14/LeetCode--21-Merge-Two-Sorted-Lists.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.<br><a id="more"></a><br>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>要求合并两个有序链表，新链表是由两个链表结点拼接得到，考察的是对链表的操作。思想是，每次从两个链表上取下一个结点，比较值的大小，较小的结点拼接到新链表后，较大的结点继续进行下一次比较。</p>
<p>这里需要注意的是链表边界的处理，比如对链表头结点的处理方式。可以先单独处理两个链表头结点，确定下新链表的头结点后，再继续继续下面的处理。也可以重新定义一个新的头结点，把链表结点都当做普通结点处理。最后可能有一个链表还有剩余的结点，直接将这些结点拼接到新链表末尾即可。</p>
<p>还可以使用递归的方式求解，但是递归的缺点是，若链表过长，可能会溢出。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> || l2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1 == <span class="literal">NULL</span>? l2 : l1;</span><br><span class="line">        </span><br><span class="line">        ListNode* resHead = l1-&gt;val &lt; l2-&gt;val?l1 : l2;</span><br><span class="line">        ListNode* cur = resHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val) l1=l1-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> l2=l2-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;next = l1==<span class="literal">NULL</span>?l2:l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> resHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义新的头结点dummy"><a href="#定义新的头结点dummy" class="headerlink" title="定义新的头结点dummy"></a>定义新的头结点dummy</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> || l2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1 == <span class="literal">NULL</span>? l2 : l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l2-&gt;next, l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--19. Remove Nth Node From End of List</title>
    <url>/2019/04/11/LeetCode--19-Remove-Nth-Node-From-End-of-List.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a linked list, remove the n-th node from the end of list and return its head.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>Given n will always be valid.</p>
</blockquote>
<p><strong>Follow up :</strong></p>
<blockquote>
<p>Could you do this in one pass?</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目要求我们找到并删除链表的倒数第n个数。由于链表不支持随机访问，并且链表长度也不容易求，所以题目看似会很麻烦。但是以前经常会碰到这样的问题，比如求链表中间位置的数等等，对这类题目有过一定了解。其实很简单，只需要用两个指针就可实现一次扫描得到结果。</p>
<blockquote>
<p>首先第一个指针end先前进n，到达第n个结点后，第二个结点pre开始前进遍历；<br>两个指针end和pre同步前进，他们之间的距离是n，当end到达链表尾部时，pre指向的就是倒数第n个结点。<br>此时我们可以继续操作，进行要求的插入，删除等等。</p>
</blockquote>
<p>在寻找链表中点时，可以使用同样的方法。使用两个指针end,mid，两个指针同时前进，但此时，mid每前进一步，end会前进两步。那么当end到达终点时，mid恰好走过一半的结点，也就找到了链表的中点。</p>
<p>当然还有一种暴力解法，就是先计算出链表的长度L，然后找到第(L-n)个结点，把第 (L−n) 个结点的 next 指针重新链接至第 (L−n+2) 个结点。同样可以完成该算法。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *end = head;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) end = end-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(end == <span class="literal">NULL</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(end-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            end = end-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *count = head;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L++;</span><br><span class="line">            count=count-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> Lmn = L - n;</span><br><span class="line">        <span class="keyword">if</span>(Lmn == <span class="number">0</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Lmn<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode *temp = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--5 超强力方法</title>
    <url>/2021/05/12/JavaLearning_Head_First_Java_5_Extra-Strength_Methods.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>让方法产生更大的作用。创建一个类似战舰的游戏：攻击达康<br><a id="more"></a></p>
</blockquote>
<h3 id="1-创建一个类似战舰的游戏：攻击达康"><a href="#1-创建一个类似战舰的游戏：攻击达康" class="headerlink" title="1. 创建一个类似战舰的游戏：攻击达康"></a>1. 创建一个类似战舰的游戏：攻击达康</h3><h4 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1. 简介"></a>1.1. 简介</h4><p>一种棋盘类的战舰游戏，目标是猜测对方战舰的坐标，然后轮流开炮攻击，命中数发可以击沉对方战舰。</p>
<ul>
<li><strong>游戏目标</strong>：以最少的猜测次数打掉计算机安排的<code>达康公司(Dot Com)</code>网站。计算机根据表现来评分。</li>
<li><strong>初始设置</strong>：程序启动后，计算机会在虚拟的<code>7×7</code>方格上安排3个达康网站。然后开始要求猜坐标。</li>
<li><strong>进行游戏</strong>：目前先在命令栏上进行游戏。计算机根据输入所猜测的位置(比如<code>A3</code>或<code>C5</code>)等，返回命中<code>Hit</code>，未命中<code>Miss</code>或击沉<code>Sunk</code>等回应。清关所有网站后，会列出分数并结束。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/sunk_site.PNG" alt="攻击达康棋盘"></p>
<h4 id="1-2-顶层设计"><a href="#1-2-顶层设计" class="headerlink" title="1.2 顶层设计"></a>1.2 顶层设计</h4><p>首先，了解游戏流程。基本思路：</p>
<ol>
<li>玩家启动游戏</li>
</ol>
<blockquote>
<p>A. 计算机创建3个网站<br>B. 将3个网站停在虚拟战场(棋盘)上</p>
</blockquote>
<ol>
<li>游戏开始</li>
</ol>
<blockquote>
<p>重复以下操作直到所有网站被歼灭<br>A. 提示玩家输入坐标<br>B. 检查是否命中、未命中或击沉。命中删除格子，击沉删除网站。</p>
</blockquote>
<ol>
<li>游戏结束</li>
</ol>
<blockquote>
<p>根据猜测次数给分。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/flow_of_sunk_dotcom.PNG" alt="游戏流程图"></p>
<h4 id="1-3-简单的开始"><a href="#1-3-简单的开始" class="headerlink" title="1.3 简单的开始"></a>1.3 简单的开始</h4><p>至少需要两个类：<code>Game</code>类和<code>DotCom</code>类。首先从一个简单版本开始。</p>
<blockquote>
<p>只使用一个横列作为棋盘(即一维数组)，并只设定一家达康公司。游戏目标依旧相同。</p>
</blockquote>
<p>要注意虚拟的横列是虚幻的，即并没有真正在程序中声明一个一维数组。只需要玩家和计算机直到有3个连续格子会出现在7格的横列中。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simple_sunk_site.PNG" alt="简单版游戏"></p>
<h3 id="2-开发类"><a href="#2-开发类" class="headerlink" title="2 开发类"></a>2 开发类</h3><p>在创建Java程序时，主要依照以下过程：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/process_of_create_javaapp.PNG" alt="Java程序开发基本流程"></p>
<blockquote>
<p>最后一条是认真的吗</p>
</blockquote>
<p>我们会为每个类写出：<code>伪码(prep code)</code>、<code>测试码(test code)</code>和<code>真实码(real code)</code></p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/prepTestReal.PNG" alt="`伪码`、`测试码`和`真实码`"></p>
<blockquote>
<p><strong>伪码</strong>：帮助我们专注于逻辑而无需考虑程序语法</p>
<p><strong>测试码</strong>：测试用的程序代码</p>
<p><strong>真实码</strong>：实际设计出的真正Java程序代码</p>
</blockquote>
<h4 id="2-1-SimpleDotCom类"><a href="#2-1-SimpleDotCom类" class="headerlink" title="2.1 SimpleDotCom类"></a>2.1 <code>SimpleDotCom</code>类</h4><h5 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h5><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComPrep.PNG" alt="`SimpleDotCom`类伪码"></p>
<p>伪码介于Java程序和正常英语之间，大致包括3个部分：实例变量的声明、方法的声明和方法的逻辑。</p>
<blockquote>
<p>伪码最重要的部分是<strong>方法的逻辑</strong>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComPrepCode.PNG" alt="`SimpleDotCom`类伪码"></p>
<h5 id="测试码"><a href="#测试码" class="headerlink" title="测试码"></a>测试码</h5><p>编写方法的实现部分，实现可用的方法程序代码。先编写测试用代码的概念来自于<code>极限编程(Extreme Programming, XP)</code>方法论，可以使我们更快更任意写出程序代码。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/Extreme_Programming.PNG" alt="极限编程"></p>
<p>首先实现<code>SimpleDotCom</code>类中的方法，先实现<code>checkYourself()</code>这个方法。（至于<code>setLocationCells()</code>这个方法，可以很容易直到它是个<code>setter</code>方法）。首先要知道<code>checkYourself()</code>方法应该要测试的部分：</p>
<blockquote>
<ol>
<li><code>SimpleDotCom</code>对象的初始化；</li>
<li>赋值位置(即一个<code>int</code>数组)；</li>
<li>创建代表玩家猜测的字符串；</li>
<li>传入伪造的玩家猜测来调用<code>checkYourself()</code>方法；</li>
<li>列出结果观察结果是否正确。</li>
</ol>
</blockquote>
<p><code>SimpleDotCom</code>测试码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotComDrive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleDotCom dot = <span class="keyword">new</span> SimpleDotCom(); <span class="comment">// 初始化SimpleDotCom对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] locations = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// 创建 dot com 位置数组</span></span><br><span class="line">        dot.setLocationCells(locations); <span class="comment">// 调用 dot com 的 setter</span></span><br><span class="line"></span><br><span class="line">        String userGuess = <span class="string">"2"</span>; <span class="comment">// 假的猜测</span></span><br><span class="line">        String result = dot.checkYourself(userGuess); <span class="comment">// 调用被测试的方法, 传入假数据</span></span><br><span class="line">        String testResult = <span class="string">"failed"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.equals(<span class="string">"hit"</span>)) &#123;</span><br><span class="line">            testResult = <span class="string">"passed"</span>; <span class="comment">// 测试返回 "hit" 才算成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.println(testResult); <span class="comment">// 输出测试结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思索与编写测试用的程序代码能够帮助我们了解被测试的应用程序应该要做哪些事情。当实作代码完成时，也可以有准备好地测试代码进行验证。</p>
<p>理想上，先写出一点测试码，然后编写能够通过该测试的方法。之后再编写测试码，编写新的实现使其通过测试。如此循环，就可以证明新加入代码不会破坏原有已经测试过的部分。</p>
</blockquote>
<h5 id="真实码"><a href="#真实码" class="headerlink" title="真实码"></a>真实码</h5><p>从伪码到真正的Java程序代码之间，不会完美对应，需要有一些调整。下面使<code>checkYourself()</code>方法的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotCom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] locationCells;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfHIts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLocationCells</span> <span class="params">(<span class="keyword">int</span>[] locations)</span> </span>&#123;</span><br><span class="line">        locationCells = locations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkYourself</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> guess = Integer.parseInt(userGuess); <span class="comment">// 字符串转int</span></span><br><span class="line">        String result = <span class="string">"miss"</span>; <span class="comment">// 创建保存返回结果的变量, 以miss作为默认值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cell: locationCells) &#123; <span class="comment">// 对每个格子重复执行</span></span><br><span class="line">            <span class="keyword">if</span> (guess == cell) &#123; <span class="comment">// 比较格子与猜测值</span></span><br><span class="line">                result = <span class="string">"hit"</span>; <span class="comment">// 命中</span></span><br><span class="line">                numOfHIts++;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 离开循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numOfHIts == locationCells.length) &#123; <span class="comment">// 判断是否击沉</span></span><br><span class="line">            result = <span class="string">"kill"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result); <span class="comment">// 显式结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-SimpleDotComGame类"><a href="#2-2-SimpleDotComGame类" class="headerlink" title="2.2 SimpleDotComGame类"></a>2.2 <code>SimpleDotComGame</code>类</h4><h5 id="伪码-1"><a href="#伪码-1" class="headerlink" title="伪码"></a>伪码</h5><p><code>SimpleDotComGame</code>类伪码如下：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComGamePrepCode.PNG" alt="`SimpleDotComGame`类伪码"></p>
<p><code>SimpleDotComGame</code>类需要有以下功能：</p>
<blockquote>
<ol>
<li>创建出<code>SimpleDotCom</code>对象</li>
<li>初始化赋值该对象</li>
<li>要求玩家开始猜测</li>
<li>检查猜测值</li>
<li>重复猜测直到击沉为止</li>
<li>显示玩家猜测次数</li>
</ol>
</blockquote>
<h5 id="真实码-1"><a href="#真实码-1" class="headerlink" title="真实码"></a>真实码</h5><p>这里跳过了这个类的测试程序，因为次游戏测试程序只有一个<code>main</code>方法。其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotComGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfGuesses = <span class="number">0</span>; <span class="comment">// 记录玩家猜测次数</span></span><br><span class="line">        GameHelper helper = <span class="keyword">new</span> GameHelper(); <span class="comment">// 使用该类来获取玩家输入</span></span><br><span class="line"></span><br><span class="line">        SimpleDotCom theDotCom = <span class="keyword">new</span> SimpleDotCom();</span><br><span class="line">        <span class="keyword">int</span> randomNum = (<span class="keyword">int</span>) (Math.random() * <span class="number">5</span>); <span class="comment">// 随机数用作第一格的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] locations = &#123;randomNum, randomNum+<span class="number">1</span>, randomNum+<span class="number">2</span>&#125;;</span><br><span class="line">        theDotCom.setLocationCells(locations);</span><br><span class="line">        <span class="keyword">boolean</span> isAlive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(isAlive) &#123;</span><br><span class="line">            String guess = helper.getUserInput(<span class="string">"enter a guess number"</span>);</span><br><span class="line">            String result = theDotCom.checkYourself(guess);</span><br><span class="line">            numOfGuesses++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"kill"</span>)) &#123;</span><br><span class="line">                isAlive = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(<span class="string">"You took "</span> + numOfGuesses + <span class="string">" guesses!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有一个带有<code>getUserInput</code>方法的类<code>GameHelper</code>。它可以从命令行获取输入，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInput</span><span class="params">(String prompt)</span> </span>&#123;</span><br><span class="line">        String inputLine = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(prompt + <span class="string">"  "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">            );</span><br><span class="line">            inputLine = is.readLine();</span><br><span class="line">            <span class="keyword">if</span> (inputLine.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inputLine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-要点"><a href="#2-3-要点" class="headerlink" title="2.3 要点"></a>2.3 要点</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/keyPointOfChapter5.PNG" alt="要点"></p>
<h3 id="3-关于for循环"><a href="#3-关于for循环" class="headerlink" title="3. 关于for循环"></a>3. 关于<code>for</code>循环</h3><h4 id="3-1-基本的for循环"><a href="#3-1-基本的for循环" class="headerlink" title="3.1 基本的for循环"></a>3.1 基本的<code>for</code>循环</h4><p>一个基本的<code>for</code>循环如下：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/regularForLoops.PNG" alt="基本的`for`循环"></p>
<p>即重复执行代码100次，编译器解释为:</p>
<blockquote>
<ol>
<li>创建变量<code>i</code>并赋值为<code>0</code>；</li>
<li>只要<code>i</code>小于<code>100</code>就重复执行；</li>
<li>每次重复过程最后把<code>i</code>加<code>1</code>。</li>
</ol>
</blockquote>
<p>主要分为三个部分：</p>
<h5 id="第一部分：初始化-initialization"><a href="#第一部分：初始化-initialization" class="headerlink" title="第一部分：初始化(initialization)"></a>第一部分：初始化(initialization)</h5><p>声明和初始化在循环体内的变量，通常将该变量作为<code>计数器</code>。</p>
<h5 id="第二部分：boolean测试-boolean-test"><a href="#第二部分：boolean测试-boolean-test" class="headerlink" title="第二部分：boolean测试(boolean test)"></a>第二部分：boolean测试(boolean test)</h5><p>测试条件计算出一个<code>boolean</code>值。可以使boolean表达式，或返回boolean值的方法。</p>
<h5 id="第三部分：重复表达式-iteration-expression"><a href="#第三部分：重复表达式-iteration-expression" class="headerlink" title="第三部分：重复表达式( iteration expression)"></a>第三部分：重复表达式( iteration expression)</h5><p>安置每趟循环完成后要执行的项目。</p>
<blockquote>
<p><code>whlie</code>循环与<code>for</code>循环的区别是，<code>while</code>循环只有<code>boolean</code>测试，它并没有内建的初始化或重复表达式。</p>
<ul>
<li><code>while</code>适合在不清楚循环次数的循环上；</li>
<li><code>for</code>相对来说更容易阅读。</li>
</ul>
</blockquote>
<p>此外，这里可以说明一下前置与后置的递增/递减操作符：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/IncrementDecrementOperator.PNG" alt="基本的`for`循环"></p>
<h4 id="3-2-加强版的for循环"><a href="#3-2-加强版的for循环" class="headerlink" title="3.2 加强版的for循环"></a>3.2 加强版的<code>for</code>循环</h4><p>从<code>Java 5.0</code>开始，有加强版的<code>for</code>循环，可以逐个运行数组或其他集合的元素。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/enhancedforloop.PNG" alt="加强版的`for`循环"></p>
<p>即对<code>nameArray</code>中每个元素执行一次，编译器解释为:</p>
<blockquote>
<ol>
<li>创建名称为<code>name</code>的<code>String</code>变量；</li>
<li>将<code>nameArray</code>的第一个元素赋值给<code>name</code>；</li>
<li>执行重复内容；</li>
<li>赋值给下一个元素<code>name</code>；</li>
<li>重复执行直到所有元素都被运行为止。</li>
</ol>
</blockquote>
<p>主要分为两个部分：</p>
<h5 id="第一部分：声明循环变量-iteration-variable-declaration"><a href="#第一部分：声明循环变量-iteration-variable-declaration" class="headerlink" title="第一部分：声明循环变量(iteration variable declaration)"></a>第一部分：声明循环变量(iteration variable declaration)</h5><p>声明和初始化用在循环体内的变量，循环过程中该变量的值会不断变化。此变量的类型需要与数组元素类型匹配。</p>
<h5 id="第二部分：要运行的集合-the-actual-collection"><a href="#第二部分：要运行的集合-the-actual-collection" class="headerlink" title="第二部分：要运行的集合(the actual collection)"></a>第二部分：要运行的集合(the actual collection)</h5><p>必须是对数组或其他集合的引用。</p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--25. Reverse Nodes in k-Group</title>
    <url>/2019/04/16/LeetCode--25-Reverse-Nodes-in-k-Group.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.<br><a id="more"></a><br>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
</blockquote>
<p><strong>Note :</strong></p>
<ul>
<li>Only constant extra memory is allowed.</li>
<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>
</ul>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题又是对上一题的推广，leetcode这种由简入难的题挺多的。这次是要求对链表的K个结点反转，这里的K可以是任意的。我们可以依旧按照上一题的那种方式，将链表分为若干段：每次从链表上“摘下”k个结点的链表，把这个链表进行反转后，再放回原来的位置。对于链表的反转操作，我们可以利用构建链表时用的头插法来进行。这里在解决时碰到几个问题：</p>
<blockquote>
<ol>
<li>若剩下链表长度不够K时，我们不需要对这段链表进行反转，所以我们需要提前计算出链表的长度</li>
<li>需要记录下反转后的最后一个结点，用于在放回原链表时，可以和下一段连接起来。</li>
</ol>
</blockquote>
<p>还有一种方法，实现如下，这种方法思想上大致相同，这种方法不用单独计算链表长度，而是边计算长度边处理链表，每当数到k个结点时就反转一次。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.next = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* count = head;</span><br><span class="line">        <span class="keyword">int</span> Len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count)</span><br><span class="line">        &#123;</span><br><span class="line">            count=count-&gt;next;</span><br><span class="line">            Len++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* pre = &amp;dummy;</span><br><span class="line">        ListNode* last = head;</span><br><span class="line">        ListNode* temp = last;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        <span class="keyword">while</span>(Len &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//下一个待取的结点</span></span><br><span class="line">                next = temp-&gt;next;</span><br><span class="line">                <span class="comment">//插入头部</span></span><br><span class="line">                temp-&gt;next = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = temp;</span><br><span class="line">                temp = next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = last;last=next;</span><br><span class="line">            Len-=k;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = last;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *pre = dummy, *cur = head;</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; cur; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % k == <span class="number">0</span>) &#123;</span><br><span class="line">                pre = reverseOneGroup(pre, cur-&gt;next);</span><br><span class="line">                cur = pre-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseOneGroup</span><span class="params">(ListNode* pre, ListNode* next)</span> </span>&#123;</span><br><span class="line">        ListNode *last = pre-&gt;next, *cur = last-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur != next) &#123;</span><br><span class="line">            last-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            cur = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--24. Swap Nodes in Pairs</title>
    <url>/2019/04/16/LeetCode--24-Swap-Nodes-in-Pairs.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.<br><a id="more"></a><br>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>要求交换链表中相邻两个结点的位置，并且要求不能修改结点的值，也就是只能将结点整个交换过去。我的思路很简单，从链表上依次“摘下”两个结点，交换其位置后再将得到的结果拼接回链表，题目并不难，主要是对链表的操作。可以按下面的图来表示(图参考自<a href="https://leetcode.com/problems/swap-nodes-in-pairs/discuss/11183/C%2B%2B-solution-with-graph-explanation." target="_blank" rel="noopener" title="C++ solution with graph explanation.">C++ solution with graph explanation.</a>)<br>/*</p>
<pre><code>   node1 = pre-&gt;next;node2 = node1-&gt;next
   #----&gt;@----&gt;@----&gt;@----&gt;@----&gt;@----&gt;@
               ^     ^     ^
               pre   node1 node2

  1. pre-&gt;next = node2
                __________
               /          \
   #----&gt;@----&gt;@     @----&gt;@----&gt;@----&gt;@
               ^     ^     ^
               pre   node1 node2

  2. node1-&gt;next = node2-&gt;next
                __________
               /          \
   #----&gt;@----&gt;@     @     @----&gt;@----&gt;@
                      \_________/
               ^     ^     ^
               pre   node1 node2

  3. node2-&gt;next = node1
               __________
              /          \
  #----&gt;@----&gt;@     @&lt;----@     @----&gt;@
                     \_________/
              ^     ^     ^
              pre   node1 node2

  4. pre = node1;
               __________
              /          \
  #----&gt;@----&gt;@     @&lt;----@     @----&gt;@
                     \_________/
                    ^
                    pre
</code></pre><p> */</p>
<p>同样的思想也可以用递归来实现</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode *pre = &amp;dummy;</span><br><span class="line">        ListNode *node1,*node2;</span><br><span class="line">        <span class="keyword">while</span>(pre)</span><br><span class="line">        &#123;</span><br><span class="line">            node1 = pre-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(node1&amp;&amp;node1-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                node2 = node1-&gt;next;</span><br><span class="line">                pre-&gt;next = node2;</span><br><span class="line">                node1-&gt;next = node2-&gt;next;</span><br><span class="line">                node2-&gt;next = node1;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !(head-&gt;next))</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *res = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(res-&gt;next);</span><br><span class="line">        res-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--23. Merge k Sorted Lists</title>
    <url>/2019/04/16/LeetCode--23-Merge-k-Sorted-Lists.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Input:<br>[<br> 1-&gt;4-&gt;5,<br> 1-&gt;3-&gt;4,<br> 2-&gt;6<br>]<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>前面有一题是合并两个有序的链表，这道题就相当于进一步泛化。</p>
<p>考虑到我们已经有了合并两个链表的方法，那么我们就可以把这个问题分解。每次把链表数组中的两个链表合并，直到只剩下一个链表为之。这时这个剩下的链表就是我们需要的结果。实现后的确解决了问题，但是效率不高。</p>
<p>进一步思考，既然合并链表的过程都是类似的，那么是不是可以用分治来做，将合并K个链表分解为合并两个子问题的结果——合并K/2个链表。这样逐步分解下去，可以划分为许多更容易解决的子问题。结合递归实现后，效率得到了极大提升，分治算法的思想果然厉害。细想起来，归并排序的思想似乎也是这样。</p>
<p>在题解中发现还有一种有意思的解法，使用priority_queue求解。由priority_queue的特性，我们可以设置在队列头部总是一个值最小的结点，那么我们就可以把所有链表第一个结点输入这个队列中。每次从队列得到最小的结点放入新链表，将该节点对应链表的下一个结点放入队列。这个重复不断进行，最终可以得到一个新的有序链表。这时候的priority_queue其实相当于一个小顶堆。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="逐一合并"><a href="#逐一合并" class="headerlink" title="逐一合并"></a>逐一合并</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode* newList = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(lists.size() &gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists.size() == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                newList = lists.back();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* list1 = lists.back();</span><br><span class="line">                lists.pop_back();</span><br><span class="line">                ListNode* list2 = lists.back();</span><br><span class="line">                lists.pop_back();</span><br><span class="line">                newList = mergeTwoLists(list1,list2);</span><br><span class="line">                lists.push_back(newList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKL</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end - begin == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(lists[begin],lists[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(end == begin) <span class="keyword">return</span> lists[begin];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(end &lt; begin) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (begin+end)/<span class="number">2</span>;</span><br><span class="line">            ListNode* list1 = mergeKL(lists, begin, mid);</span><br><span class="line">            ListNode* list2 = mergeKL(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(list1, list2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeKL(lists, <span class="number">0</span>, lists.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="priority-queue解法"><a href="#priority-queue解法" class="headerlink" title="priority_queue解法"></a>priority_queue解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp=[](ListNode* a, ListNode* b) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;ListNode*,<span class="built_in">vector</span>&lt;ListNode*&gt;,<span class="keyword">decltype</span>(cmp)&gt; pq(cmp);</span><br><span class="line">        ListNode dummy(0),*p=&amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (ListNode *node:lists) <span class="keyword">if</span> (node) pq.push(node);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.top()-&gt;next) pq.push(pq.top()-&gt;next);</span><br><span class="line">            p-&gt;next=pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--29. Divide Two Integers</title>
    <url>/2019/04/22/LeetCode--29-Divide-Two-Integers.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.<br><a id="more"></a><br>Return the quotient after dividing <strong>dividend</strong> by <strong>divisor</strong>.</p>
<p>The integer division should truncate toward zero.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: dividend = 10, divisor = 3<br>Output: 3</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: dividend = 7, divisor = -3<br>Output: -2</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<ul>
<li>Both dividend and divisor will be 32-bit signed integers.</li>
<li>The divisor will never be 0.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.</li>
</ul>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目要求实现除法，并且不能使用乘法、除法和模这些操作。这就意味着我们只能使用加减或者位运算，来实现除法的过程。</p>
<p>第一种思路是，用被除数减去除数，知道被除数小于除数时，返回减法进行的次数。</p>
<p>这需要先对输入的两个数进行处理，若除数或被除数是负数，不能直接进行减法，需要先取他们的绝对值。但这是会出现越界的情况，如-2^31的绝对值就越界了，int不能存储。但是题目要求的是只能用32-bit的环境，所以不能用long来解决了，这里想到的是使用unsigned int来保存绝对值结果。这时又碰到了另一个问题，abs()函数也无法处理越界的数，即求abs(-2^31)时会报错，解决方法是使用labs()函数，或者重写一个abs()，可以实现需要的_abs()如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> temp = value;</span><br><span class="line">    <span class="keyword">return</span> (temp &gt; <span class="number">0x80000000</span>) ? -value : temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除此之外，还需要单独判断一种结果溢出的情况，也就是<code>dividend = -2^31，divisor = -1</code> 的情况，这时直接输出INT_MAX即可。</p>
<p>这种方法效率太低，最后超时了。在这种方法基础上可以进行优化。可以加入位运算，如果被除数大于除数，找到小于被除数的，且是除数2^n的最大的数，被除数减去该数，结果加上n后，重复上述操作，直到被除数小于除数为止。这里寻找这个符合条件的数时，就可以运用位运算。</p>
<p>还有一种比较有意思的解法，就是运用对数求解。首先分别求出被除数和除数的对数，算出它们的差后，将其作为指数，求 e 的指数结果。公式如下：<br>    a/b = e^(log(a) - log(b))<br>但是计算对数时，应该使用了除法/，所以可能违反了条件。</p>
<p>参考：<br><a href="https://blog.csdn.net/zephyr_be_brave/article/details/8722397" target="_blank" rel="noopener" title="C++自己实现abs">C++自己实现abs</a><br><a href="https://leetcode.com/problems/divide-two-integers/discuss/13407/C%2B%2B-bit-manipulations" target="_blank" rel="noopener" title="C++ bit manipulations">C++ bit manipulations</a><br><a href="https://leetcode.com/problems/divide-two-integers/discuss/13460/6-line-solution-C%2B%2B" target="_blank" rel="noopener" title="6 line solution C++">6 line solution C++</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="只用加减法（超时）"><a href="#只用加减法（超时）" class="headerlink" title="只用加减法（超时）"></a>只用加减法（超时）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divd = __abs(dividend);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divr = __abs(divisor);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(divd &gt;= divr)</span><br><span class="line">        &#123;</span><br><span class="line">            divd -= divr;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> copyed_value = value;</span><br><span class="line">        <span class="keyword">return</span> (copyed_value &gt; <span class="number">0x80000000</span>) ? -value : copyed_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="加入位运算"><a href="#加入位运算" class="headerlink" title="加入位运算"></a>加入位运算</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divd = __abs(dividend);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divr = __abs(divisor);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(divd &gt;= divr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> temp = divr; <span class="keyword">unsigned</span> m = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>((temp &lt;&lt; <span class="number">1</span>) &lt;= divd &amp;&amp; temp != <span class="number">2147483648</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            divd -= temp;</span><br><span class="line">            result += m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> copyed_value = value;</span><br><span class="line">        <span class="keyword">return</span> (copyed_value &gt; <span class="number">0x80000000</span>) ? -value : copyed_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="对数求解"><a href="#对数求解" class="headerlink" title="对数求解"></a>对数求解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divd = __abs(dividend);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divr = __abs(divisor);</span><br><span class="line">        </span><br><span class="line">        result = <span class="built_in">exp</span>(<span class="built_in">log</span>(divd)-<span class="built_in">log</span>(divr));</span><br><span class="line">        <span class="keyword">return</span> sign * result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> copyed_value = value;</span><br><span class="line">        <span class="keyword">return</span> (copyed_value &gt; <span class="number">0x80000000</span>) ? -value : copyed_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--3. Longest Substring Without Repeating Characters</title>
    <url>/2019/03/28/LeetCode--3-Longest-Substring-Without-Repeating-Characters.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3. </p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>Input: “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</p>
</blockquote>
<p><strong>Example3:</strong></p>
<blockquote>
<p>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3. </p>
<ul>
<li>Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</li>
</ul>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目要求的是，最长不含重复元素的字串。<br>最开始的想法是，用一个向量数组，存储以每一个位置为终点，包含该位置字符在内的最长不含重复元素的字串的长度，相当于一个dp的算法。数组更新方式是：用一个二重循环，外循环是从第一个字符到最后一个字符一次遍历；内循环用于判断，以该位置字符为终点，可以得到的最长不重复字串有多长。该算法成功解决了问题。<br>后来继续分析程序，发现可以不使用向量数组，因为数组内的每一个元素的值只需要访问一次，直接用一个变量保存即可。用此方法改进后，速度和空间都得到了优化。</p>
<blockquote>
<p>讨论区有另外一种更优化的解法，代码中用vector生成256个-1，用来存储每个字符上一次出现的下标。代码比较抽象，理解如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v(<span class="number">256</span>,<span class="number">-1</span>); <span class="comment">//构造字符串的容器。初始化为-1，意思是暂时不存在这个字符。</span></span><br><span class="line">start=<span class="number">-1</span>; <span class="comment">//start用来记录子串开始的位置，初始化为-1，表示没有开始构造子字符串。</span></span><br><span class="line"><span class="keyword">if</span>(v[s[i]]&gt;start)<span class="comment">//已经在该字符出现之前出现过相同的字符了，那么就将start也就是开始位置标记为上次该字符的出现位置。</span></span><br><span class="line">	start=v[s[i]]; </span><br><span class="line">v[s[i]]=i; <span class="comment">//更新字符在容器中对应的下标</span></span><br><span class="line">ans=max(ans,i-start); <span class="comment">//i-start的意思是，当前for循环的i（也就是子字符串的结束字符）减去子字符串结束的字符的下标位置，结果就是子字符串的长度。</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li>解法1(使用了向量数组)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="comment">//空字符串，直接返回0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>; <span class="comment">//非空字符串，最短为1</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; longestsub; <span class="comment">//每个位置的最长不重复字串长度</span></span><br><span class="line">        longestsub.push_back(<span class="number">1</span>); <span class="comment">//初始化第一个位置</span></span><br><span class="line">		<span class="comment">//遍历每一个位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            longestsub.push_back(<span class="number">1</span>);</span><br><span class="line">			<span class="comment">//从上一个位置的最长不重复字串为起点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-longestsub[i<span class="number">-1</span>];j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">//没有重复，继续计算</span></span><br><span class="line">                <span class="keyword">if</span>(s[j]!=s[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    longestsub[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//有重复，从1开始重新计数</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    longestsub[i]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//记录最长长度</span></span><br><span class="line">            <span class="keyword">if</span>(longestsub[i]&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                max=longestsub[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>不使用数组</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> Longest=<span class="number">1</span>,Last=<span class="number">1</span>;<span class="comment">//记录最长长度和上一字符的最长不重复字串长度</span></span><br><span class="line">        <span class="comment">//vector&lt;int&gt; longestsub;</span></span><br><span class="line">        <span class="comment">//longestsub.push_back(1);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//longestsub.push_back(1);</span></span><br><span class="line">            <span class="keyword">int</span> present=<span class="number">1</span>;<span class="comment">//计算当前位置最长不重复字串长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-Last;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j]!=s[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    present++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    present=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Longest=max(Longest,present);</span><br><span class="line">            Last=present;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.解法3</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict[s[i]] &gt; start)</span><br><span class="line">                start = dict[s[i]];</span><br><span class="line">            dict[s[i]] = i;</span><br><span class="line">            maxLen = max(maxLen, i - start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--28. Implement strStr()</title>
    <url>/2019/04/17/LeetCode--28-Implement-strStr.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Implement strStr().<br><a id="more"></a><br>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: haystack = “hello”, needle = “ll”<br>Output: 2</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: haystack = “aaaaa”, needle = “bba”<br>Output: -1</p>
</blockquote>
<p><strong>Clarification :</strong></p>
<blockquote>
<p>What should we return when needle is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这个题要求实现strStr()函数。实际上就是个字符串匹配过程，要求从haystack中寻找子串needle，若找到，返回子串开始位置；否知返回-1.</p>
<p>想到的有两种解法，一种是直接暴力求解，另一种是用KMP算法。</p>
<p>首先实现了暴力求解的算法。将haystack所有与needle一样长的子串进行比较，若成功找到，就返回当前子串其实位置；若最终未找到，返回-1.这种方法实现后，发现效果还算不错，没有想象的那么差。</p>
<p>之后实现了KMP算法，KMP算法可以利用next数组加速匹配过程。</p>
<blockquote>
<p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p>
<ul>
<li>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</li>
<li>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值.</li>
</ul>
</blockquote>
<p>这里重点是构造next数组，next数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next[j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀。</p>
<p>参考文献：<br>[1] <a href="https://www.cnblogs.com/yjiyjige/p/3263858.html" target="_blank" rel="noopener">（原创）详解KMP算法</a><br>[2] <a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" target="_blank" rel="noopener">很详尽KMP算法</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="暴力算法1"><a href="#暴力算法1" class="headerlink" title="暴力算法1"></a>暴力算法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.size(), n = needle.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m - n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="暴力算法2"><a href="#暴力算法2" class="headerlink" title="暴力算法2"></a>暴力算法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.size(), n = needle.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m - n; i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> substr = haystack.substr(i, n);</span><br><span class="line">            <span class="keyword">if</span> (substr == needle) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_KMP_Next(<span class="built_in">string</span> s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(s.length());</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>, k=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; s.length()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">-1</span> || s[j] == s[k])</span><br><span class="line">            &#123;</span><br><span class="line">                next[++j] = ++k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.length(), n = needle.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = get_KMP_Next(needle);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || haystack[i] == needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j == needle.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--33. Search in Rotated Sorted Array</title>
    <url>/2019/04/23/LeetCode--33-Search-in-Rotated-Sorted-Array.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br><a id="more"></a><br>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: nums = [4,5,6,7,0,1,2], target = 0<br>Output: 4</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: nums = [4,5,6,7,0,1,2], target = 3<br>Output: -1</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>看见要求算法复杂度O(log n)，并且数组有序（轮转有序），最先想到的是，用二分查找。</p>
<p>但是二分法需要进行修改，不能直接使用。第一中方法是，对二分查早进行改进，使它符合这道题：</p>
<blockquote>
<p>二分搜索法的关键在于获得了中间数后，判断下面要搜索左半段还是右半段，我们可以观察到一种规律，如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了。</p>
</blockquote>
<p>另一种方法是，我们还是使用原来的二分查找算法。不过我们需要先找到数组轮转的位置。如对于数组 <code>[4,5,6,7,0,1,2]</code>，可以找到轮转pivot是7，下标是3。根据pivot，可以把数组分为真正有序的两部分，判断target可能出现在哪部分，再继续用原来的二分查找就可以得到结果了。这里寻找pivot也可以用二分查找实现，复杂度依旧是O(log n)。</p>
<p>可以用异或来编写判断语句使代码更精简，代码如下。</p>
<p>参考：<br><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14419/" target="_blank" rel="noopener">Pretty short C++/Java/Ruby/Python</a><br><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14435/Clever-idea-making-it-simple" target="_blank" rel="noopener">Clever idea making it simple</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="修改后的二分查找"><a href="#修改后的二分查找" class="headerlink" title="修改后的二分查找"></a>修改后的二分查找</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="寻找pivot"><a href="#寻找pivot" class="headerlink" title="寻找pivot"></a>寻找pivot</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPivot</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])</span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low == high &amp;&amp; nums[low] == target) <span class="keyword">return</span> low;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = findPivot(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target &lt;= nums[pivot] &amp;&amp; target &gt;= nums[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(nums, <span class="number">0</span>, pivot, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(nums, pivot+<span class="number">1</span>, nums.size()<span class="number">-1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用异或"><a href="#使用异或" class="headerlink" title="使用异或"></a>使用异或</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="keyword">int</span>(nums.size()) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((nums[<span class="number">0</span>] &gt; target) ^ (nums[<span class="number">0</span>] &gt; nums[mid]) ^ (target &gt; nums[mid]))</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hi = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo == hi &amp;&amp; nums[lo] == target ? lo : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--32. Longest Valid Parentheses</title>
    <url>/2019/04/23/LeetCode--32-Longest-Valid-Parentheses.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: “(()”<br>Output: 2<br>Explanation: The longest valid parentheses substring is “()”</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: “)()())”<br>Output: 4<br>Explanation: The longest valid parentheses substring is “()()”</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>给定了一个括号的字符串，求最长有效子串的长度。</p>
<p>首先就是暴力解法，逐个字符遍历字符串，判断从当前字符开始的最大有效括号长度，若大于已经找到的最大有效长度，则更新最大有效长度。遍历完成后，也就找到了最长有效长度。这种方法思路简单而且没有超时，但是效率很低。</p>
<p>主要是因为整个过程会有许多重复的判断。这个问题可以用动态规划来求解：定义一个数组dp，保存以字符串中第i个字符为结尾的最长有效子串的长度。由于有效字符串是以 ‘)’ 结束的，所以 ‘(‘ 必定不构成有效子串。所以我们将dp初始化为全0，当遇到 ‘)’ 时才更新dp数组，更新规则如下：</p>
<blockquote>
<ol>
<li>若s[i] == ‘)’ 且 s[i-1] == ‘(‘，即形如“……()”，更新dp[i] = dp[i - 2] + 2</li>
<li>若s[i] == ‘)’ 且 s[i-1] == ‘)’，即形如”……))”，此时若s[i - dp[i-1] - 1] == ‘(‘，更新dp[i] = dp[i - 1] + dp[i - dp[i-1] - 2] + 2</li>
</ol>
</blockquote>
<p>每次更新dp后，判断当前更新后的值是否比已经找到的最长有效长度大，若是则更新最长有效长度。当dp更新完成后，也就找到了最长有效长度。这种方法只需要扫描一遍字符串，避免了重复的判断。</p>
<p>除了这两种方法外，还有两种算法：</p>
<blockquote>
<ol>
<li><p>使用栈<br>初始化一个栈，先在栈中存入-1。之后遍历给定的字符串，判断当前扫描的字符串是不是有效的，同时更新最长有效长度。<br> 1) 若遇到 ‘(‘，将其下标推入栈内<br> 2) 若遇到 ‘)’，从栈顶弹出一个元素后，用当前元素下标减去剩下栈顶的元素，得到一个当前元素的有效子串长度。若从栈顶弹出元素后，栈空，就将当前元素的下标放入栈内继续遍历。<br>遍历完字符串后，找到最长有效长度。</p>
</li>
<li><p>不使用额外空间<br>用两个计数器 left 和 right ，记录当前遇到的有效左括号数和右括号数。分两遍扫描字符串：<br> 1) 先从左向右扫描，遇到 “(“ 就增加left，遇到 ‘)’ 就增加right，当left和right相等时，得到一个有效子串，计算该有效子串长度并更新最长有效长度。若right大于left，将left和right都置0，继续扫描。<br> 2) 用相同的步骤，从右向左再扫描一编。</p>
</li>
</ol>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur = <span class="number">0</span>; cur &lt; s.length(); cur++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> open = <span class="number">0</span>, close = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=cur; i&lt;s.length(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    open++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ++close;</span><br><span class="line">                    <span class="keyword">if</span>(close == open)</span><br><span class="line">                        longest = max(longest, i-cur+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(close &gt; open)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(longest &gt;= (s.length() - cur))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="DP算法"><a href="#DP算法" class="headerlink" title="DP算法"></a>DP算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.length(), <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = i<span class="number">-2</span> &gt;= <span class="number">0</span> ? dp[i<span class="number">-2</span>]+<span class="number">2</span> : <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i - dp[i<span class="number">-1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i - dp[i<span class="number">-1</span>] - <span class="number">1</span>] == <span class="string">'('</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>] + <span class="number">2</span> + ((i-dp[i<span class="number">-1</span>]<span class="number">-2</span> &gt;= <span class="number">0</span>)?dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]:<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                longest = max(dp[i], longest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">stack</span>.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> curlen = i - <span class="built_in">stack</span>.top();</span><br><span class="line">                    longest = max(longest, curlen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不使用额外空间，两遍扫描"><a href="#不使用额外空间，两遍扫描" class="headerlink" title="不使用额外空间，两遍扫描"></a>不使用额外空间，两遍扫描</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>, close = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>) open++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++close;</span><br><span class="line">                <span class="keyword">if</span>(close == open)</span><br><span class="line">                    longest = max(longest, <span class="number">2</span>* open);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(close &gt; open)</span><br><span class="line">                &#123;</span><br><span class="line">                    open = close = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        open = close = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (<span class="keyword">int</span>)s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) close++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++open;</span><br><span class="line">                <span class="keyword">if</span>(close == open)</span><br><span class="line">                    longest = max(longest, <span class="number">2</span>* open);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(open &gt; close)</span><br><span class="line">                &#123;</span><br><span class="line">                    open = close = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--30. Substring with Concatenation of All Words</title>
    <url>/2019/04/22/LeetCode--30-Substring-with-Concatenation-of-All-Words.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in <strong>s</strong> that is a concatenation of each word in <strong>words</strong> exactly once and without any intervening characters.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input:<br>&nbsp;&nbsp;&nbsp;&nbsp; s = “barfoothefoobarman”,<br>&nbsp;&nbsp;&nbsp;&nbsp; words = [“foo”,”bar”]<br>Output: [0,9]<br>Explanation: Substrings starting at index 0 and 9 are “barfoor” and “foobar” respectively.<br>The output order does not matter, returning [9,0] is fine too.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input:<br>&nbsp;&nbsp;&nbsp;&nbsp; s = “wordgoodgoodgoodbestword”,<br>&nbsp;&nbsp;&nbsp;&nbsp; words = [“word”,”good”,”best”,”word”]<br>Output: []</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题让我们求串联所有单词的子串，就是说给定一个长字符串，再给定几个长度相同的单词，让从长字符串中找出串联给定所有单词的子串的起始位置。</p>
<p>最开始以为单词不重复，所以最初的想法是。用一个map来记录每次单词上一次出现的位置，以及用indexStart记录当前子串开始位置。之后不断检查，若检测到单词不在words内或者单词上次出现在indexStart之后即重复了，就重新进行下一次检查。但是words内单词是可以重复的，所以这种方法行不通，需要记录单词出现的次数。</p>
<p>所以要用到两个map，第一个map内存入words内每个单词可以出现的次数，第二个map存储当前扫描的子串内，单词已经出现的次数。从头开始扫描字符串，每次得到一个单词，看其是否在word内以及出现次数是否在要求范围内，如果不满足，则进行下一次扫描。如果正好匹配完给定单词集里所有的单词，则把开始地址存入结果中。</p>
<p>算法可以继续优化，我们不必每次都从头开始判断每个单词。可以设置一个单词组成字符串大小的滑动窗口。</p>
<blockquote>
<p>若当前判断的单词超过限制的出现次数时导致匹配失败，将窗口后移到该子串中该单词第一个出现的位置之后；<br>若当前判断的单词不在words中导致匹配失败，将窗口完全移动到该单词之后。<br>若判断到窗口最后的位置且匹配成功，记录下当前窗口的开始位置，将窗口后移一个单词长度，继续下一次判断。</p>
</blockquote>
<p>我们同时也可以减少到只使用一个map，map记录单词可以出现的次数，没出现一次就减一。在窗口移动时，我们可以同时恢复现场。这种使用滑动窗口的方法，省去了大量重复的或者不必要的判断，所以算法性能得到极大提升。</p>
<p>查看评论区发现还有一种解法，这种解法思想很巧妙，有些复杂也不是特别懂，在这写下大致思想：</p>
<blockquote>
<ol>
<li>定义一个hash函数，将每个单词映射到一个唯一的值上</li>
<li>用定义好的hash函数，计算出words总的hash值words_hashsum</li>
<li>还是使用一个窗口，先计算第一个窗口内对应字符串的hashsum,与words的hash_sum比较，若相等则把窗口开始位置记录下来。</li>
<li>窗口后移一个位置，继续计算其hashsum进行判断。</li>
</ol>
</blockquote>
<p>这种方法尽管最后能求解ac，但感觉可能存在问题，比如两个单词 a, c的hash值分别为1 3, b的hash值为2, 那么可能(a,c)的组合和(b,b)的组合hashsum相等，所以是有可能会出错的。</p>
<p>参考：<br><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/13791/" target="_blank" rel="noopener">My 24ms C++ solution (O(N) time, using an unordered_map)</a><br><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/192123/" target="_blank" rel="noopener">O(n) C++ solution, 8ms, beats 100%</a><br><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/13700/" target="_blank" rel="noopener">My AC c++ code, O(n) complexity, 26ms</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="两个哈希表"><a href="#两个哈希表" class="headerlink" title="两个哈希表"></a>两个哈希表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordfound,counts;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.empty() || words.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> wordsize = words.size(), wordlen = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> slen = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words) counts[word]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= slen - wordsize * wordlen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; wordsize; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> temp = s.substr(i + j*wordlen, wordlen);</span><br><span class="line">                <span class="keyword">if</span>(counts[temp] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                wordfound[temp]++;</span><br><span class="line">                <span class="keyword">if</span>(wordfound[temp] &gt; counts[temp]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == wordsize) res.push_back(i);</span><br><span class="line">            wordfound.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="滑动窗口的方法"><a href="#滑动窗口的方法" class="headerlink" title="滑动窗口的方法"></a>滑动窗口的方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; counts;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.empty() || words.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> wordsize = words.size(), wordlen = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> slen = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(slen &lt; wordsize * wordlen) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start, cur, founded;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words) counts[word]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordlen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            start = cur = i;</span><br><span class="line">            founded = wordsize;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(start &lt;= slen - wordsize * wordlen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//单词不在words内,整个窗口后移到后一个单词</span></span><br><span class="line">                <span class="keyword">if</span>(counts.count(s.substr(cur,wordlen)) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    founded = wordsize;</span><br><span class="line">                    <span class="keyword">for</span>(;start != cur; start += wordlen)</span><br><span class="line">                        counts[s.substr(start,wordlen)]++;</span><br><span class="line">                    start += wordlen;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(counts[s.substr(cur,wordlen)] == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//单词出现次数超过限制,窗口移动到该单词第一次出现的下一个位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(;s.substr(start,wordlen) != s.substr(cur,wordlen);start += wordlen)</span><br><span class="line">                    &#123;</span><br><span class="line">                        counts[s.substr(start,wordlen)]++;</span><br><span class="line">                        founded++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    start += wordlen;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    counts[s.substr(cur,wordlen)]--;</span><br><span class="line">                    <span class="keyword">if</span>(--founded == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(start);</span><br><span class="line">                        counts[s.substr(start,wordlen)]++;</span><br><span class="line">                        start += wordlen;</span><br><span class="line">                        founded++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += wordlen;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(;start&lt;cur;start+=wordlen)</span><br><span class="line">                counts[s.substr(start,wordlen)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; retVal;</span><br><span class="line">        <span class="keyword">if</span> (words.size()&lt;<span class="number">1</span> || s.size()&lt;<span class="number">1</span>) <span class="keyword">return</span> retVal;</span><br><span class="line">        <span class="comment">// Hash all the words seperately then add them together to get a magic number</span></span><br><span class="line">        <span class="built_in">std</span>::hash&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; hash_fn;</span><br><span class="line">        <span class="keyword">size_t</span> magicNumber = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.size(); i++) &#123;</span><br><span class="line">            magicNumber += hash_fn(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> wordLength = words[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// Concatenated substring will be a given length</span></span><br><span class="line">        <span class="keyword">int</span> minimumSize = words.size()*wordLength;</span><br><span class="line">        <span class="comment">// We do a sliding window calculation for each 'offset' a pattern might have</span></span><br><span class="line">        <span class="comment">// This is faster than re-hashing the entire window because we can just drop the least recently hashed value</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> startOffset=<span class="number">0</span>; startOffset&lt;wordLength; startOffset++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">size_t</span> hashSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> minimum = <span class="number">0L</span>L-minimumSize-startOffset+s.size();</span><br><span class="line">            <span class="comment">// This means that the requested offset does not leave us with enough characters in the string!</span></span><br><span class="line">            <span class="keyword">if</span> (minimum &lt; <span class="number">0</span>) <span class="keyword">return</span> retVal;</span><br><span class="line">            <span class="keyword">for</span> (i=s.size()-startOffset-wordLength; i&gt;=minimum; i-=wordLength) &#123;</span><br><span class="line">                hashSum+=hash_fn(s.substr(i,wordLength));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hashSum==magicNumber) retVal.push_back(i+wordLength);</span><br><span class="line">            <span class="keyword">for</span> (;i&gt;=<span class="number">0</span>; i-=wordLength) &#123;</span><br><span class="line">                hashSum-=hash_fn(s.substr(i+minimumSize,wordLength));</span><br><span class="line">                hashSum+=hash_fn(s.substr(i,wordLength));</span><br><span class="line">                <span class="keyword">if</span> (hashSum==magicNumber) retVal.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--36. Valid Sudoku</title>
    <url>/2019/04/24/LeetCode--36-Valid-Sudoku.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated <strong>according to the following</strong> .<br><a id="more"></a><br><strong>rules :</strong></p>
<ol>
<li>Each row must contain the digits 1-9 without repetition. </li>
<li>Each column must contain the digits 1-9 without repetition. </li>
<li>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li>
</ol>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="A partially filled sudoku which is valid." title="A partially filled sudoku which is valid."></p>
<blockquote>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>&#39;.&#39;</code>.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input:<br>[<br>&nbsp;&nbsp;[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>&nbsp;&nbsp;[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>&nbsp;&nbsp;[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>&nbsp;&nbsp;[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>&nbsp;&nbsp;[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>&nbsp;&nbsp;[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>&nbsp;&nbsp;[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>&nbsp;&nbsp;[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>&nbsp;&nbsp;[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>Output: true</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input:<br>[<br>&nbsp;&nbsp;[“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>&nbsp;&nbsp;[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>&nbsp;&nbsp;[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>&nbsp;&nbsp;[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>&nbsp;&nbsp;[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>&nbsp;&nbsp;[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>&nbsp;&nbsp;[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>&nbsp;&nbsp;[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>&nbsp;&nbsp;[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>Output: false<br>Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8’s in the top left 3x3 sub-box, it is invalid.</p>
</blockquote>
<p><strong>Note :</strong></p>
<ul>
<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>
<li>Only the filled cells need to be validated according to the mentioned rules.</li>
<li>The given board contain only digits 1-9 and the character <code>&#39;.&#39;</code>.</li>
<li>The given board size is always <code>9x9</code>.</li>
</ul>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>咋一看以为是解数独，会很复杂。读完题目后，发现只要求判断当前的棋盘上的数字是不是有效的，不需要考虑最终这个数独是不是可以解。所以相当于只需要判断当前这个已经存在的棋盘是否满足数独规则的要求。</p>
<p>数独的规则要求，每行，每列，以及每个<code>3x3</code>的子棋盘上，是否包括<code>1-9</code>这9个数字且不重复。现在考虑，肯定是需要把整个棋盘扫描一遍的，那么我们可以设置三个状态数组，来分别记录下以及扫描过的 <code>行/列/子棋盘</code> 中已经出现过的数，如果扫描到某 <code>行/列/子棋盘</code> 中有重复的元素前面已经出现过，直接返回false；若直到扫描结束，也为发现重复元素，说明棋盘有效，返回true。但是由于要记录每 <code>行/列/子棋盘</code> 的状态，需要声明三个较大的数组，所以对空间的消耗较高，应该还有更优化的解法。</p>
<p>评论区解题的大致思路都差不多，区别主要再求如何存储状态数组。有一种很优化的方法是利用位操作实现的，这种方法只使用一个short就存储了一行的状态，节省了很多空间，效率也得到了提升。</p>
<blockquote>
<ol>
<li>每行的状态初始化为0；</li>
<li>遇到一个数字num，就将1左移num位与状态数进行与操作，若结果不为0，说明有重复，返回false；否则，无重复，更新状态，即两数进行或操作。</li>
</ol>
</blockquote>
<p>参考：<br><a href="https://leetcode.com/problems/valid-sudoku/discuss/15452" target="_blank" rel="noopener">C++ very simple and easy understand. using bit operation</a><br><a href="https://leetcode.com/problems/valid-sudoku/discuss/15705/" target="_blank" rel="noopener">My C++ code (O(n2) time and space)</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; rows(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; columns(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; sub_box(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> sub_box_index = (i/<span class="number">3</span>)*<span class="number">3</span> + (j/<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">int</span> num = board[i][j] - <span class="string">'1'</span>;</span><br><span class="line">                <span class="keyword">if</span>(rows[i][num] || columns[j][num] || sub_box[sub_box_index][num])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                rows[i][num] = columns[j][num] = sub_box[sub_box_index][num] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="利用位操作"><a href="#利用位操作" class="headerlink" title="利用位操作"></a>利用位操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; col(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; block(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; row(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = <span class="number">1</span> &lt;&lt; (board[i][j] - <span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">if</span> (row[i] &amp; idx || col[j] &amp; idx || block[i/<span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>] &amp; idx)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    </span><br><span class="line">                    row[i] |= idx;</span><br><span class="line">                    col[j] |= idx;</span><br><span class="line">                    block[i/<span class="number">3</span> * <span class="number">3</span> + j/<span class="number">3</span>] |= idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> existNum[<span class="number">10</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!=<span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(existNum[i][board[i][j] - <span class="string">'0'</span>] &amp; <span class="number">0x1</span>)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// check if the i-row already has such number, LSB</span></span><br><span class="line">                    <span class="keyword">if</span>(existNum[j][board[i][j] - <span class="string">'0'</span>] &amp; <span class="number">0x2</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// check if the j-col already has such number, 2-LSB</span></span><br><span class="line">                    <span class="keyword">if</span>(existNum[(i/<span class="number">3</span>) *<span class="number">3</span> + j/<span class="number">3</span>][board[i][j] - <span class="string">'0'</span>] &amp; <span class="number">0x4</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// check if the k-subblock already has such number, 3-LSB</span></span><br><span class="line">                    existNum[i][board[i][j] - <span class="string">'0'</span>] ^=<span class="number">0x1</span>;</span><br><span class="line">                    existNum[j][board[i][j] - <span class="string">'0'</span>] ^=<span class="number">0x2</span>;</span><br><span class="line">                    existNum[(i/<span class="number">3</span>) *<span class="number">3</span> + j/<span class="number">3</span>][board[i][j] - <span class="string">'0'</span>] ^=<span class="number">0x4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--5. Longest Palindromic Substring</title>
    <url>/2019/03/28/LeetCode--5-Longest-Palindromic-Substring.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.</p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>Input: “cbbd”<br>Output: “bb”</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>最开始想到的当然还是暴力算法，想法是先用暴力算法把题目做出来理解题目，然后尝试着对实现的算法进行改进，或者再想想有没有其他思路。最开始的想法是</p>
<blockquote>
<p>设置两个游标i、j，i从前往后遍历字符串，j从后往前遍历字符串；先将i固定住，然后j从后往前遍历，依次判断从当前j到i的字符串是不是一个回文，其长度是不是最大，若满足条件，就将该字符串的位置信息记录下来，遍历完后最终输出即可。</p>
</blockquote>
<p>显然这个方法的效果不会太好，选择尝试对其进行优化。想要的优化思路如下</p>
<blockquote>
<p>若当前要判断的子串比已经找到的最长回文子串要短，那么该子串以及比它短的子串都没必要在判断了，可以通过跳过这些不必要的比较过程节省大量时间</p>
</blockquote>
<p>修改过后，时间上果然有了很大提升，但结果告诉我显然这种方法还是不好，肯定存在更优化的方法。仔细分析后发现，其实这种方法就相当于将字符串反转后找最大公共子串，它存在一些问题：</p>
<blockquote>
<p>这种方法是从两端往内部收缩的算法，如果一个字符串恰好只是最内部的一部分不是子串，那么两端的整个判断过程都是无意义的，而且很费时。我们需要能够更早发现这不是一个回文。若我们把判断过程换一个方向就可以做到，即收缩改为扩展。由内而外的判断子串是不是回文，可以在不是回文的地方及时停止，并且保证之前判断的子串的确是回文，不是无意义的判断。</p>
</blockquote>
<p>实现后发现，这种扩展的算法效率比最开始的算法效率要好太多了，因为避免了许多无意义的计算过程。总结起来就是，有时候换一个方向想问题，可以得到更加优化的结果。<br>查看解题的文档后发现还有以下几种比较巧妙的方式：</p>
<blockquote>
<p>1.最长公共子串暴力算法<br>反转 S，使之变成 S’。找到 S 和 S’之间最长的公共子串,每当我们找到最长的公共子串的候选项时，都需要检查子串的索引是否与反向子串的原始索引相同。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。我所用到的第一种方法思路根这种方法一致。</p>
<p>2.动态规划<br>考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，”ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。可以给出P(i,j)的定义如下</p>
<ul>
<li>P(i,j) = true,  如果子串Si,…,Sj是回文子串</li>
<li>P(i,j) = false, 其他情况</li>
</ul>
<p>因此P(i,j)更新公式如下：</p>
<ul>
<li>P(i,j) = (P(i+1,j−1) and Si == Sj)</li>
</ul>
<p>这是一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推</p>
<p>3.Manacher 算法<br>也叫“马拉松”算法，这个算法可以将时间复杂度提升为<strong>O(n)</strong>。</p>
<ol>
<li><p>首先对字符串进行预处理，处理原因是防止偶数问题。比如，有一个偶回文<strong>abba</strong>和一个奇回文<strong>opxpo</strong>，转换为<strong>#a#b#b#a#</strong>和<strong>#o#p#x#p#o#</strong>，长度都转换成了奇数。</p>
</li>
<li><p>定义一个辅助数组p[]，其中p[i]表示以 <strong>i</strong> 为中心的最长回文的半径</p>
</li>
<li><p>接下来的重点就是求解 p 数组。参考下图<br><img src="https://image-static.segmentfault.com/105/998/1059982876-58b966b759200" alt=""><br>设置两个变量，mx 和 id。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么：<br><code>if (i &lt; mx) p[i]=min(p[2 * id - i], mx - i);</code><br><strong>(2 * id - i)</strong>为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快更新数组。</p>
</li>
</ol>
</blockquote>
<p>参考文献：<a href="https://subetter.com/algorithm/manacher-algorithm.html" target="_blank" rel="noopener">https://subetter.com/algorithm/manacher-algorithm.html</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-改进的收缩算法-最长字符串匹配"><a href="#1-改进的收缩算法-最长字符串匹配" class="headerlink" title="1. 改进的收缩算法(最长字符串匹配)"></a>1. 改进的收缩算法(最长字符串匹配)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> begin=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> LongestLength=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=s.length()<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> forward=i;</span><br><span class="line">                <span class="keyword">int</span> backward=j;</span><br><span class="line">                <span class="keyword">while</span>(s[forward]==s[backward]&amp;&amp;forward&lt;backward)</span><br><span class="line">                &#123;</span><br><span class="line">                    forward++;</span><br><span class="line">                    backward--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(forward&gt;=backward)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(LongestLength&lt;(j-i+<span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        begin=i;</span><br><span class="line">                        LongestLength=(j-i+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(LongestLength&gt;=(j-i+<span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(LongestLength&gt;=(s.length()-i+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> s.substr(begin, LongestLength); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-扩展算法"><a href="#2-扩展算法" class="headerlink" title="2. 扩展算法"></a>2. 扩展算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> r_ptr = i; </span><br><span class="line">        <span class="keyword">int</span> l_ptr = i;</span><br><span class="line">        <span class="comment">//找到回文中心</span></span><br><span class="line">        <span class="keyword">while</span>(r_ptr &lt; s.size()<span class="number">-1</span> &amp;&amp; s[r_ptr] == s[r_ptr + <span class="number">1</span>]) r_ptr++;</span><br><span class="line">        i = r_ptr+<span class="number">1</span>;<span class="comment">//记录下次启示位置，防止重复计算</span></span><br><span class="line">        <span class="comment">//从中心开始扩展</span></span><br><span class="line">        <span class="keyword">while</span>(r_ptr &lt; s.size()<span class="number">-1</span> &amp;&amp; l_ptr &gt; <span class="number">0</span> &amp;&amp; s[r_ptr + <span class="number">1</span>] == s[l_ptr - <span class="number">1</span>]) &#123;</span><br><span class="line">            r_ptr++;</span><br><span class="line">            l_ptr--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新最长回文子串信息</span></span><br><span class="line">        <span class="keyword">int</span> new_len = r_ptr - l_ptr + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(new_len &gt; max_len) &#123;</span><br><span class="line">            start_idx = l_ptr;</span><br><span class="line">            max_len = new_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(start_idx, max_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-动态规划算法"><a href="#3-动态规划算法" class="headerlink" title="3. 动态规划算法"></a>3. 动态规划算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> LongestLength = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(len,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dist = <span class="number">1</span>;dist &lt; len - i;dist++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = dist + i;</span><br><span class="line">                dp[i][j] = (dist == <span class="number">1</span>)? s[i] == s[j] : s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; LongestLength)</span><br><span class="line">                &#123;</span><br><span class="line">                    LongestLength = j-i+<span class="number">1</span>;</span><br><span class="line">                    begin=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substr(begin, LongestLength); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-Manacher算法"><a href="#4-Manacher算法" class="headerlink" title="4. Manacher算法"></a>4. Manacher算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字符串预处理，插入 '#'</span></span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">"$#"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            t += s[i];</span><br><span class="line">            t += <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理t</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(t.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, resLen = <span class="number">0</span>, resCenter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.size(); ++i) &#123;</span><br><span class="line">            p[i] = i &lt; mx ? min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++p[i]; <span class="comment">//// 不需边界判断，因为左有'$',右有'\0'</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//希望 mx 尽可能的远</span></span><br><span class="line">            <span class="keyword">if</span> (mx &lt; i + p[i]) &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</span><br><span class="line">                resLen = p[i];</span><br><span class="line">                resCenter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr((resCenter - resLen) / <span class="number">2</span>, resLen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--26. Remove Duplicates from Sorted Array</title>
    <url>/2019/04/17/LeetCode--26-Remove-Duplicates-from-Sorted-Array.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a sorted array nums, remove the duplicates <strong>in-place</strong> such that each element appear only once and return the new length.<br><a id="more"></a><br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Given nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p>
<p>It doesn’t matter what you leave beyond the returned length.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Given nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</p>
<p>It doesn’t matter what values are set beyond the returned length.</p>
</blockquote>
<p><strong>Clarification :</strong></p>
<blockquote>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题要求去除数字中的冗余项，而且只能使用O(1)的空间复杂度。看题目说明得知，我们返回的是处理后数组的长度，我们只需要保证数组前面有效部分的值，至于超出有效部分的值我们无需关心。</p>
<p>那么就可以很好处理，我们继续下当前最后一个有效位的位置，等到下一次遇到不重复的数时，将该数字移动到下一个有效位，然后更新有效位继续扫描数组。当完成一遍扫描后，所有不重复的值都移动到了数组的前端有效部分。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[last<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[last] = nums[i];</span><br><span class="line">                last++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--4. Median of Two Sorted Arrays</title>
    <url>/2019/03/31/LeetCode--4-Median-of-Two-Sorted-Arrays.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.<br><a id="more"></a><br>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>The median is 2.0</p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>The median is (2 + 3)/2 = 2.5</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>最先想到的方法是，既然两个数组是有序的，可以直接归并两个数组，之后可以直接找到中位数。但题目对时间有要求，这种方法的时间复杂度是O(m+n)，比要求的O(log(m+n))显然要大，所以不能用这种暴力的方法。</p>
<p>仔细分析问题，既然两个数组都是有序的，那么可以不必将数组归并，可以直接挨个比较两个数组，找到中间的那两个数(数组为奇数长度下，找中间一个数)，就可以停止下来，不必继续比较后面的值，可以节省大量时间。事实证明这种方法可行，速度也够快。</p>
<p><strong>二分求解</strong><br>题目解析给出了另外一种方法，即基于二分搜索的方法。大致思想如下</p>
<blockquote>
<p>将数组A,B分别分成两部分，将 left_A 和 left_B 放入一个集合，并将 right_A 和 right_B 放入另一个集合。 再把这两个新的集合分别命名为 left_part 和 right_part：</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">left_part</th>
<th style="text-align:center">right_part</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A[0], A[1], …, A[i-1]</td>
<td style="text-align:center">A[i], A[i+1], …, A[m-1]</td>
</tr>
<tr>
<td style="text-align:center">B[0], B[1], …, B[j-1]</td>
<td style="text-align:center">B[j], B[j+1], …, B[n-1]</td>
</tr>
</tbody>
</table>
</div>
<p>如果我们可以确认：</p>
<blockquote>
<ol>
<li>len(left_part) = len(right_part)</li>
<li>max(left_part) ≤ min(right_part)</li>
</ol>
</blockquote>
<p>那么，我们已经将 {A,B} 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。这时可以很容易求出<strong>median</strong>:</p>
<blockquote>
<p>median= (max(left_part) + min(right_part)) / 2</p>
</blockquote>
<p>要确保这两个条件，我们只需要保证：</p>
<blockquote>
<ol>
<li>i + j = m − i + n − j（或：m - i + n - j + 1） 如果 n ≥ m，只需要使 i = 0 ~ m, j = (m + n + 1) / 2 - i</li>
<li>B[j−1] ≤ A[i] 以及 A[i−1] ≤ B[j]</li>
</ol>
</blockquote>
<p>接下来，按照以下步骤进行二叉树搜索，找到合适的i：</p>
<blockquote>
<ol>
<li>设 imin = 0，imax = m, 然后开始在 [imin,imax] 中进行搜索。</li>
<li>令i = (imin+imax)/2, j = (m+n+1)/2-i</li>
<li>现在有len(left_part)=len(right_part)。会遇到三种情况：<ul>
<li>B[j−1] ≤ A[i] 且 A[i−1] ≤ B[j]：这意味着我们找到了目标对象 i，所以可以停止搜索。</li>
<li>B[j−1] &gt; A[i]：这意味着 A[i] 太小，我们必须增大 i 以使 B[j−1] ≤ A[i]。也就是说，我们必须将搜索范围调整为[i+1,imax]。因此，设 imin=i+1，并转到步骤 2。</li>
<li>A[i−1] &gt; B[j]：这意味着 A[i−1] 太大，我们必须减小 i 以使 A[i−1] ≤ B[j]。也就是说，我们必须将搜索范围调整为[imin,i−1]。因此，设 imax=i−1，并转到步骤 2。</li>
</ul>
</li>
</ol>
</blockquote>
<p>当找到目标对象 i 时，中位数为：</p>
<blockquote>
<ul>
<li>max(A[i−1],B[j−1]),  当 m+n 为奇数时</li>
<li>(max(A[i−1],B[j−1])+min(A[i],B[j]))/2,  当 m+n 为偶数时</li>
</ul>
</blockquote>
<p>接下来只需要对一些边界条件进行处理就可以了，这种方法实现了O(log(m+n))的复杂度</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-解法1"><a href="#1-解法1" class="headerlink" title="1.解法1"></a>1.解法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//只有单个数组有值的情况，只需要处理单个数组</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findSingleArrayMedian</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> isOdd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isOdd) <span class="keyword">return</span> nums[nums.size()/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[nums.size()/<span class="number">2</span><span class="number">-1</span>] + nums[nums.size()/<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//vector&lt;int&gt; nums;</span></span><br><span class="line">        <span class="keyword">int</span> totalLen=nums1.size() + nums2.size();</span><br><span class="line">        <span class="keyword">int</span> isOdd = (totalLen&amp;<span class="number">1</span>); <span class="comment">//判断数组长度奇偶性</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(totalLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums1.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findSingleArrayMedian(nums2,isOdd);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums2.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findSingleArrayMedian(nums1,isOdd);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> last1=<span class="number">0</span>,last2=<span class="number">0</span>; <span class="comment">//记录最后两个值</span></span><br><span class="line">        <span class="keyword">int</span> index1=<span class="number">0</span>,index2=<span class="number">0</span>; <span class="comment">//记录两个数组当前的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=totalLen/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数组1已经没有值时</span></span><br><span class="line">            <span class="keyword">if</span>(index1 == nums1.size())</span><br><span class="line">            &#123;</span><br><span class="line">                last1=last2;</span><br><span class="line">                last2=nums2[index2];</span><br><span class="line">                <span class="comment">//nums.push_back(nums2[index2]);</span></span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数组2已经没有值时</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index2 == nums2.size())</span><br><span class="line">            &#123;</span><br><span class="line">                last1=last2;</span><br><span class="line">                last2=nums1[index1];</span><br><span class="line">                <span class="comment">//nums.push_back(nums1[index1]);</span></span><br><span class="line">                index1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[index1]&lt;nums2[index2])</span><br><span class="line">                &#123;</span><br><span class="line">                    last1=last2;</span><br><span class="line">                    last2=nums1[index1];</span><br><span class="line">                    <span class="comment">//nums.push_back(nums1[index1]);</span></span><br><span class="line">                    index1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    last1=last2;</span><br><span class="line">                    last2=nums2[index2];</span><br><span class="line">                    <span class="comment">//nums.push_back(nums2[index2]);</span></span><br><span class="line">                    index2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(isOdd) <span class="keyword">return</span> last2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (last1+last2) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-解法2（二分法）"><a href="#2-解法2（二分法）" class="headerlink" title="2.解法2（二分法）"></a>2.解法2（二分法）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = nums2.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//确保数组1长度不大于数组2小</span></span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp=nums1;nums1=nums2;nums2=tmp;</span><br><span class="line">            <span class="keyword">int</span> temp = len1;len1=len2;len2=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> iMin=<span class="number">0</span>,iMax=len1,halfLen=(len1+len2+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(iMin&lt;=iMax)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i=(iMin+iMax)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j=halfLen-i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//i过小</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;iMax &amp;&amp; nums2[j<span class="number">-1</span>]&gt;nums1[i])</span><br><span class="line">            &#123; </span><br><span class="line">                iMin=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i过大</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;iMin &amp;&amp; nums1[i<span class="number">-1</span>]&gt;nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                iMax=i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//成功找到i</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> maxLeft=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) maxLeft=nums2[j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) maxLeft=nums1[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> maxLeft=max(nums1[i<span class="number">-1</span>],nums2[j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>((len1+len2)%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> maxLeft;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> minRight=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==len1) minRight = nums2[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==len2) minRight = nums1[i];</span><br><span class="line">                <span class="keyword">else</span> minRight=min(nums1[i],nums2[j]);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--7. Reverse Integer</title>
    <url>/2019/03/28/LeetCode--7-Reverse-Integer.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a 32-bit signed integer, reverse digits of an integer..<br><a id="more"></a></p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: 123<br>Output: 321</p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>Input: -123<br>Output: -321</p>
</blockquote>
<p><strong>Example3:</strong></p>
<blockquote>
<p>Input: 120<br>Output: 21</p>
</blockquote>
<p><strong>Note:</strong></p>
<blockquote>
<p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>问题很简单，即将一个int型整数逆序。这里需要注意的是，int的表示范围是[−2^31,  2^31 − 1]，所以若逆序后的数在这个范围之外，即溢出的时候，直接输出0。<br>我的想法是，用一个更大的类型，即<strong>long</strong>来存储转化结果，然后判断结果在不在int的表示范围内，对计算结果进行处理。对比评论区，发现思路大致相同，这貌似就是最优的方法，还以为又会有啥逻辑上的转换。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> MAX=<span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">long</span> MIN=<span class="number">-2147483648</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result=result*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(result&gt;MAX||result&lt;MIN)</span><br><span class="line">        &#123;</span><br><span class="line">            result=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>据说出题人想考的是溢出判断，不能用long，只用Int的实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> MAX=<span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">long</span> MIN=<span class="number">-2147483648</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(result&gt;MAX/<span class="number">10</span>||result&lt;MIN/<span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            result=result*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>也就是计算结果的时候，先判断这次计算会不会溢出，溢出就直接返回0</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--31. Next Permutation</title>
    <url>/2019/04/22/LeetCode--31-Next-Permutation.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.<br><a id="more"></a><br>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
</blockquote>
<pre><code>1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</code></pre><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>前不久好像刚在一道题用过这个函数，现在就遇到实现这个函数了。对于全排列的具体实行过程不是很熟悉，没有什么思路。在查看题解后，发现对于这个问题，14世纪就有人已经提出了简单的解法——<a href="https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order" target="_blank" rel="noopener" title="Generation in lexicographic order">Generation in lexicographic order</a>，算法思路如下：</p>
<blockquote>
<ol>
<li>从右到左，找到第一对连续的数a[i]和a[i-1]，使得满足a[i] &gt; a[i-1];这样a[i]右边的序列就是一个降序的排列（这个序列理论上没有下一个排列，题目中让这种情况的下一个变成了第一个）。如果这一步没有找到上述连续数对，直接将数列反转即可得到最终结果。</li>
<li>从 a[i] 开始的降序排序中找到刚好大于a[i-1]的数 a[k]，将两个数进行交换。</li>
<li>将降序的数列a[i:]反转，得到下一个排列。</li>
</ol>
</blockquote>
<p><a href="https://imgchr.com/i/EkLSDe" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/22/EkLSDe.gif" alt="EkLSDe.gif"></a></p>
<p>讨论区有一种调用库实现上述算法的代码。代码很短，从里面学到了一些STL的函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = is_sorted_until(nums.rbegin(), nums.rend());</span><br><span class="line">    <span class="keyword">if</span> (i != nums.rend())</span><br><span class="line">        swap(*i, *upper_bound(nums.rbegin(), i, *i));</span><br><span class="line">    reverse(nums.rbegin(), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>is_sorted_until(), 它返回序列中“失序”的元素。 如果整个序列被排序（根据谓词），那么它将返回最后一个。</p>
<p>rbegin 和 rend, 反向迭代器, 分别返回指向容器尾元素和首元素前一位置的反向迭代器。</p>
<p>upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的<strong>地址</strong>，不存在则返回end。lower_bound( begin,end,num)类似，不过它找的是第一个小于等于num的数。</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), i, k;</span><br><span class="line">        <span class="keyword">for</span>(i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reverse(nums.begin(), nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(k = n - <span class="number">1</span>; k &gt; i; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            swap(nums[i<span class="number">-1</span>], nums[k]);</span><br><span class="line">            reverse(nums.begin() + i, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = is_sorted_until(nums.rbegin(), nums.rend());</span><br><span class="line">    <span class="keyword">if</span> (i != nums.rend())</span><br><span class="line">        swap(*i, *upper_bound(nums.rbegin(), i, *i));</span><br><span class="line">    reverse(nums.rbegin(), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--709. To Lower Case</title>
    <url>/2019/03/28/LeetCode--709-To-Lower-Case.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: “Hello”<br>Output: “hello”</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: “here”<br>Output: “here”</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: “LOVELY”<br>Output: “lovely”</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题主要用来熟悉下transform(STL transform)函数</p>
<blockquote>
<p>transform() 可以将函数应用到序列的元素上，并将这个函数返回的值保存到另一个序列中，它返回的迭代器指向输出序列所保存的最后一个元素的下一个位置。调用方法如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryOperator</span> &gt; </span></span><br><span class="line"><span class="class">	<span class="title">OutputIterator</span> <span class="title">transform</span> ( <span class="title">InputIterator</span> <span class="title">first1</span>,  // 源容器的起始地址 </span></span><br><span class="line"><span class="class">							  <span class="title">InputIterator</span> <span class="title">last1</span>,    // 源容器的终止地址 </span></span><br><span class="line"><span class="class">							  <span class="title">OutputIterator</span> <span class="title">result</span>,  // 目标容器的起始地址 </span></span><br><span class="line"><span class="class">							  <span class="title">UnaryOperator</span> <span class="title">op</span> );</span>     <span class="comment">// 函数指针 </span></span><br><span class="line"><span class="comment">// typedef 目标容器元素类型 (*UnaryOperator)(源容器元素类型); </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">BinaryOperator</span> &gt; </span></span><br><span class="line"><span class="class">	<span class="title">OutputIterator</span> <span class="title">transform</span> ( <span class="title">InputIterator1</span> <span class="title">first1</span>,     // 源容器1的起始地址 </span></span><br><span class="line"><span class="class">							  <span class="title">InputIterator1</span> <span class="title">last1</span>,       // 源容器1的终止地址 </span></span><br><span class="line"><span class="class">							  <span class="title">InputIterator2</span> <span class="title">first2</span>,      // 源容器2的起始地址，元素个数与1相同 </span></span><br><span class="line"><span class="class">							  <span class="title">OutputIterator</span> <span class="title">result</span>,      // 目标容器的起始地址，元素个数与1相同 </span></span><br><span class="line"><span class="class">							  <span class="title">BinaryOperator</span> <span class="title">binary_op</span> );</span> <span class="comment">// 函数指针 </span></span><br><span class="line"><span class="comment">// typedef 目标容器元素类型 (*BinaryOperator)(源容器1元素类型，源容器2元素类型);</span></span><br></pre></td></tr></table></figure>
<p>所以transform结合大小写转换函数tolower，只需要一行即可完成任务</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toLowerCase</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        transform(str.begin(),str.end(),str.begin(),::<span class="built_in">tolower</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--27. Remove Element</title>
    <url>/2019/04/17/LeetCode--27-Remove-Element.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array <strong>nums</strong> and a value <strong>val</strong>, remove all instances of that value in-place and return the new length.<br><a id="more"></a><br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Given nums = [3,2,2,3], val = 3,</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p>It doesn’t matter what you leave beyond the returned length.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Given nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<p>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</p>
<p>Note that the order of those five elements can be arbitrary.</p>
<p>It doesn’t matter what values are set beyond the returned length.</p>
</blockquote>
<p><strong>Clarification :</strong></p>
<blockquote>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题与上一题类似，不够这次要求删除数组中指定的值。思想还是一样的：</p>
<blockquote>
<p>设置一个有效位last，遍历数组，遇到不等于val的值，就将它移动到last+1，然后更新last<br>当遍历完数组后，不等于val的值就都移动到了数组前端有效部分。</p>
</blockquote>
<p>但是这样会移动大量的元素，考虑是不是可以只移动值等于val的元素，由于数组的顺序可以改变，那么我们可以:</p>
<blockquote>
<p>将等于val的元素与最后一个值不等于val的元素交换</p>
</blockquote>
<p>这样当遍历完成后，所有等于val的值都被移动到了数组末尾无效部分。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=val)    nums[last++]=nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解2"><a href="#解2" class="headerlink" title="解2"></a>解2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, end=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = nums[end--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--9. Palindrome Number</title>
    <url>/2019/04/02/LeetCode--9-Palindrome-Number.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: 121<br>Output: true</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: -121<br>Output: false<br>Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: 10<br>Output: false<br>Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目让判断一个数整数是不是一个回文，其中定义所有负数都不是回文。解题想法是</p>
<blockquote>
<ol>
<li>首先判断这个数是不是负数，或者是不是0~9的数(只有一位肯定是回文)。</li>
<li>然后将数字转化为一个字符串，从中心开始向两边扩展判断是不是回文。</li>
</ol>
</blockquote>
<p>这里判断回文的思路和前面做到的一道题很类似，但是这个题要更简单一点。后来才发现题目要求里面有，<strong>不能使用把数转化为字符串</strong>。<br>前面有道题是可以把一个数反转，那么可以直接把数反转后，看看两个数是否相等即可判断。但是把数反转后有可能导致数字大于int表示范围，还需要额外处理溢出的情况。一种优化的方法是，可以<strong>只反转int数字的一半</strong>，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。例如，输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 1221 是回文。这里还需要对一些特殊情况进行处理，比如数字是奇数长，或者10^n时，需要额外判断。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="转化为字符串的解法"><a href="#转化为字符串的解法" class="headerlink" title="转化为字符串的解法"></a>转化为字符串的解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToStr</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = (x%<span class="number">10</span>)+<span class="string">'0'</span>;</span><br><span class="line">            res = tmp + res;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;<span class="number">10</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> num = intToStr(x);</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">if</span>(num.length()%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i=num.length()/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            j=num.length()/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i=num.length()/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            j=num.length()/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;=num.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=num[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i--;j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不转化解法"><a href="#不转化解法" class="headerlink" title="不转化解法"></a>不转化解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span> || (x!=<span class="number">0</span> &amp;&amp; x%<span class="number">10</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; revertedNumber)</span><br><span class="line">        &#123;</span><br><span class="line">            revertedNumber = revertedNumber*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x==(revertedNumber/<span class="number">10</span>) || x==revertedNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--929. Unique Email Addresses</title>
    <url>/2019/03/28/LeetCode--929-Unique-Email-Addresses.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Every email consists of a local name and a domain name, separated by the @ sign.</p>
<p>For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name.<br><a id="more"></a><br>Besides lowercase letters, these emails may contain ‘.’s or ‘+’s.</p>
<p>If you add periods (‘.’) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, “alice.z@leetcode.com” and “alicez@leetcode.com” forward to the same email address.  (Note that this rule does not apply for domain names.)</p>
<p>If you add a plus (‘+’) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.)</p>
<p>It is possible to use both of these rules at the same time.</p>
<p>Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails? </p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: <code>{&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;}</code><br>Output: <strong>2</strong></p>
</blockquote>
<p>Explanation: “testemail@leetcode.com” and “testemail@lee.tcode.com” actually receive mails</p>
<p><strong>Note:</strong></p>
<ul>
<li>1 &lt;= emails[i].length &lt;= 100</li>
<li>1 &lt;= emails.length &lt;= 100</li>
<li>Each emails[i] contains exactly one ‘@’ character.</li>
</ul>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目的意思是，邮箱作为一个字符串，在字符”@”前面的部分：</p>
<blockquote>
<p>1.若出现字符’.’，则可以去掉该’.’;<br>2.若出现’+’，则从’+’到’@’的字符串都可去掉。</p>
</blockquote>
<p>根据这样的规则，判断总共有多少个不同的邮箱。思路很明确，只需要将每一个邮箱转换为其最简单的形式，然后去除其中重复的字符串，计算最终剩下的字符串个数即可。<br>首先联想到的是在每次处理完字符串后，将处理过的字符串放入一个set中，由于set内不含重复元素，所以自然就可以去重。但是vector有没有什么直接去重的方法呢？查阅资料后发现还真有，在vector类型中，有一种去重的方法是：先在vector内对向量进行排序，然后用erase加unique函数即可实现去除重复元素。</p>
<blockquote>
<ul>
<li>unique函数是一个去重函数，去除相邻中的重复元素（只留一个）。其中，最关键的是：并不是把重复的元素删除，而是全部放倒数组的后面。</li>
<li>由于unique只是去除（相邻）的重复元素，因此，为了去除重复的元素，应该，首先对数组Vector进行排序，这样保证重复元素在相邻的位置。</li>
<li>unique函数，返回的是去重后的尾地址。因此对于一个内容为{2, 2, 5, 5, 6}的vector，执行unique函数以后，vector大小并没有改变，只不过顺序变成了{2, 5, 6, 2, 5}，并且函数的返回值为:3。此时需要删除重复元素，只需要将后面的数据全部删除即可。</li>
</ul>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numUniqueEmails</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; emails)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator email=emails.begin();email&lt;emails.end();email++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(*email).find(<span class="string">'@'</span>);i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((*email)[i]==<span class="string">'.'</span>)  (*email).erase(i,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((*email)[i]==<span class="string">'+'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    (*email).erase(i,(*email).find(<span class="string">'@'</span>)-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(emails.begin(),emails.end());</span><br><span class="line">        emails.erase(unique(emails.begin(), emails.end()), emails.end());</span><br><span class="line">        <span class="keyword">return</span> emails.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--35. Search Insert Position</title>
    <url>/2019/04/24/LeetCode--35-Search-Insert-Position.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br><a id="more"></a><br>You may assume no duplicates in the array.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: [1,3,5,6], 5<br>Output: 2</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: [1,3,5,6], 2<br>Output: 1</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: [1,3,5,6], 7<br>Output: 4</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input: [1,3,5,6], 0<br>Output: 0</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>显然，这道题还是可以使用二分查找求解。使用二分搜索查找target，若找到了，直接返回找到的下标。若target不存在，二分搜索结束后，low所指向的位置就是target插入的位置。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--8. String to Integer (atoi)</title>
    <url>/2019/03/31/LeetCode--8-String-to-Integer-atoi.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Implement <strong>atoi</strong> which converts a string to an integer.<br><a id="more"></a><br>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>Only the space character ‘ ‘ is considered as whitespace character.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</li>
</ul>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: “42”<br>Output: 42</p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>Input: “   -42”<br>Output: -42<br>Explanation: The first non-whitespace character is ‘-‘, which is the minus sign.Then take as many numerical digits as possible, which gets 42.</p>
</blockquote>
<p><strong>Example3:</strong></p>
<blockquote>
<p>Input: “4193 with words”<br>Output: 4193<br>Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit.</p>
</blockquote>
<p><strong>Example4:</strong></p>
<blockquote>
<p>Input: “words and 987”<br>Output: 0<br>Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.</p>
</blockquote>
<p><strong>Example5:</strong></p>
<blockquote>
<p>Input: “-91283472332”<br>Output: -2147483648<br>Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目大致意思是：将一个字符串转换成一个数，这个字符串有很多种情况需要考虑：</p>
<ol>
<li>忽略字符串头部的空白(只把” “当做空白)</li>
<li>数字可能带正负号</li>
<li>若数字超过INT表示范围，则若上溢，返回INT最大值；若下溢，返回INT最小值</li>
<li>如果除1,2情况外，第一个字符不是数字，视为无效值，返回0</li>
<li>如果数字后出现非数字，则截断，不考虑后面的字符。</li>
</ol>
<p>所以，只需要将这些情况考虑进来，把字符串进行直接处理即可。判断溢出时，可以用long来保存结果，最后再判断值是否溢出；也可以直接计算过程中对INT进行判断。这里用的后一种方法。这道题在判断溢出时，思路类似于[7.Reverse Integer]这道题。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,sign=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//去空格</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;str[i]==<span class="string">' '</span>;i++);</span><br><span class="line">        <span class="comment">//取符号</span></span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sign=<span class="number">1</span>;i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">'+'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="number">0</span>&amp;&amp;(INT_MAX-(str[i]-<span class="string">'0'</span>))/<span class="number">10</span>&lt;result) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="number">1</span>&amp;&amp;(INT_MAX-(str[i]-<span class="string">'0'</span>))/<span class="number">10</span>&lt;result) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            </span><br><span class="line">            result=result*<span class="number">10</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sign) result=-result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>My new Post</title>
    <url>/2017/09/21/My-new-Post.html</url>
    <content><![CDATA[<blockquote>
<p>a test</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>LeetCode--6. ZigZag Conversion</title>
    <url>/2019/04/01/LeetCode--6-ZigZag-Conversion.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><br>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code><br>Write the code that will take a string and make this conversion given a number of rows:<br><code>string convert(string s, int numRows);</code></p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: s = “PAYPALISHIRING”, numRows = 3<br>Output: “PAHNAPLSIIGYIR”</p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: s = “PAYPALISHIRING”, numRows = 4<br>Output: “PINALSIGYAHRPI”<br>Explanation:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题可以直接通过找规律实现。找到每行 Z 字形图案字符在原字符串中对于的位置即可，然后逐行访问。规律如下：</p>
<blockquote>
<p>对于所有整数”k”,</p>
<ol>
<li>第0行中的字符位于原字符串 k*(2⋅numRows−2) 处;</li>
<li>第(numRows−1)行中的字符位于原字符串 k*(2⋅numRows−2)+numRows−1 处;</li>
<li>其他行中字符位于原字符串 k*(2⋅numRows−2)+i 以及 (k+1)*(2⋅numRows−2)−i处；</li>
</ol>
</blockquote>
<p>找到规律后，就很容易实现了。</p>
<p>另外一种方法是，通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。所以可以分别构建每行的字符串，最后再将这些字符串连接起来即可，算法如下</p>
<blockquote>
<ol>
<li>使用 min(numRows,len(s)) 个列表来表示 Z 字形图案中的非空行。</li>
<li>从左到右迭代 s，将每个字符添加到合适的行。</li>
<li>合并所有行</li>
</ol>
</blockquote>
<p>但是这种方法效率要低一些。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-找规律的方法"><a href="#1-找规律的方法" class="headerlink" title="1. 找规律的方法"></a>1. 找规律的方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一行，无需处理直接输出</span></span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> cvStr;</span><br><span class="line">        <span class="keyword">int</span> step=numRows*<span class="number">2</span><span class="number">-2</span>;<span class="comment">//每次前进的步伐</span></span><br><span class="line">        <span class="comment">//逐行生成每行的序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;s.length();j+=step)</span><br><span class="line">            &#123;</span><br><span class="line">                cvStr+=s[j+i];</span><br><span class="line">                <span class="comment">//若是内部行，需要加上((k+1)(2⋅numRows−2)−i)处的字符</span></span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;i!=numRows<span class="number">-1</span>&amp;&amp;j+step-i&lt;s.length())</span><br><span class="line">                &#123;</span><br><span class="line">                    cvStr+=s[j+step-i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cvStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-逐行构造的方法"><a href="#2-逐行构造的方法" class="headerlink" title="2. 逐行构造的方法"></a>2. 逐行构造的方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一行，无需处理直接输出</span></span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = min(numRows,<span class="keyword">int</span>(s.length()));</span><br><span class="line">        <span class="built_in">string</span> cvStr; <span class="comment">//结果字符串</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; rows(len); <span class="comment">//每行字符串</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> curRow=<span class="number">0</span>; <span class="comment">//当前行</span></span><br><span class="line">        <span class="keyword">bool</span> curDirect=<span class="literal">false</span>; <span class="comment">//当前方向</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逐个字符串构建每行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            rows[curRow]+=s[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//边界时，确定当前方向</span></span><br><span class="line">            <span class="keyword">if</span>(curRow==<span class="number">0</span> || curRow == numRows<span class="number">-1</span>) curDirect=!curDirect;</span><br><span class="line">            </span><br><span class="line">            curRow+=curDirect?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//合成字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> row : rows) cvStr+=row;</span><br><span class="line">        <span class="keyword">return</span> cvStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy爬虫-基础使用</title>
    <url>/2019/11/16/scrapy-crawler--basic-use.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近大数据课需要用到爬虫爬数据，发现<code>scrapy</code>这个爬虫库还蛮好用的，记录一下它的基本用法。<br><a id="more"></a></p>
<h3 id="scrapy框架"><a href="#scrapy框架" class="headerlink" title="scrapy框架"></a><code>scrapy</code>框架</h3><p>如下是<code>scrapy</code>架构图，绿色箭头表示组件及在系统中发生的数据流。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/scrapy_architecture.png" alt="scrapy architecture"></p>
<blockquote>
<ul>
<li><strong>Scrapy Engine</strong> 控制数据流在组件中的流动，并在相应动作发生时触发事件</li>
<li><strong>调度器(Scheduler)</strong> 从引擎接受request并将他们入队，以便之后引擎请求他们时提供给引擎</li>
<li><strong>下载器(Downloader)</strong> 负责获取页面数据并提供给引擎，而后提供给spider</li>
<li><strong>Spiders</strong> 用户编写用于分析response并提取item(即获取到的item)或额外跟进的URL的类</li>
<li><strong>Item Pipeline</strong> Item Pipeline负责处理被spider提取出来的item，清理、 验证及持久化等</li>
<li><strong>下载器中间件(Downloader middlewares)</strong> 可以自定义扩展下载功能的组件(比如将滑动条拉到底部)</li>
</ul>
</blockquote>
<p>具体可以参考官网<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/architecture.html" target="_blank" rel="noopener">架构概览</a></p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>可以通过<code>scrapy</code>命令直接生成一个框架模板，主要有以下命令：</p>
<blockquote>
<ul>
<li>创建项目：scrapy startproject xxx</li>
<li>创建爬虫：scrapy genspider xxx（爬虫名） xxx.com （爬取域）</li>
<li>生成文件：scrapy crawl xxx -o xxx.type (生成 <code>type</code> 类型的文件)</li>
<li>运行爬虫：scrapy crawl XXX</li>
<li>列出所有爬虫：scrapy list</li>
<li>获得配置信息：scrapy settings [options]</li>
</ul>
</blockquote>
<p>如下是生成的一个爬虫项目的目录信息：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/scrapy_folder.png" alt="project folder"></p>
<p>简单的爬虫主要需要修改的就是 <code>items.py</code> 和 <code>example.py</code> 文件。其它比较高端的功能暂时也没用上：</p>
<blockquote>
<p><code>items.py</code> 创建容器的地方，爬取的信息分别放到不同容器里。item是保存爬取数据的容器，使用的方法和字典差不多, 将需要提取的信息在这里定义以下就可以了<br><code>example.py</code> 爬虫文件。负责解析start_url下载的Response 对象，根据item提取数据; 如果有新的url则加入爬取队列，负责进一步处理，URL的Request 对象</p>
</blockquote>
<h3 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h3><p>我这里主要是用的 <code>Xpath</code> 来解析文件, 语法还是比较简单的, 而且容易使用, 可以在 <code>chrome</code> 内使用插件 <code>XPath Helper</code> 来在网页内调试。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/xpath.png" alt="Xpath"></p>
<p>但是有时候 <code>XPath Helper</code> 的解析语句在 <code>scrapy</code> 得到的结果不太兼容, 可以用 <code>scrapy</code> 命令行进一步调试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy shell &lt;url&gt;</span><br></pre></td></tr></table></figure><br>两者结合起来, 基本上就可以写出合理的爬虫解析语句了。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/scrapy_shell.png" alt="scrapy shell"></p>
<p>xpath具体语法可以参考<a href="https://www.w3school.com.cn/xpath/index.asp" target="_blank" rel="noopener">XPath 教程</a>, 基本上跟着调试调试就懂了。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/7dee0837b3d2" target="_blank" rel="noopener">scrapy学习</a></li>
<li><a href="https://www.jianshu.com/p/cecb29c04cd2" target="_blank" rel="noopener">爬虫框架Scrapy个人总结（详细）熟悉</a></li>
<li><a href="https://www.jianshu.com/p/6bc5a4641629" target="_blank" rel="noopener">爬虫框架Scrapy的安装与基本使用</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--34. Find First and Last Position of Element in Sorted Array</title>
    <url>/2019/04/23/LeetCode--34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given <strong>target</strong> value.<br><a id="more"></a><br>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: nums = [5,7,7,8,8,10], target = 8<br>Output: [3,4]</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: nums = [5,7,7,8,8,10], target = 6<br>Output: [-1,-1]</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>依旧是以O(log n)复杂度查找一个数。这道题给出的数组是有序的而且可以有重复元素，要求给出target出现的范围。</p>
<p>因为数组完全有序，所以思路依旧是使用二分查找。首先用二分查找，查找一个等于target的元素的位置，然后从该位置开始左右拓展，从而找到target出现的范围。若没有找到该数，直接返回<code>{-1, -1}</code>即可。可以看出，算法思路很简单。</p>
<p>但是这可能不是严格意义上的O(logn)的算法，因为在最坏的情况下会变成O(n)，比如当数组里的数全是目标值的话，从中间向两边找边界就会一直遍历完整个数组。一种真正意义上的O(logn)的算法是，使用两次二分查找法，第一次找到左边界，第二次调用找到右边界即可。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[low] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> start = low, end = low;</span><br><span class="line">            <span class="keyword">while</span>(start &gt; <span class="number">0</span> &amp;&amp; nums[start<span class="number">-1</span>] == nums[start]) start--;</span><br><span class="line">            <span class="keyword">while</span>(end &lt; nums.size()<span class="number">-1</span> &amp;&amp; nums[end+<span class="number">1</span>] == nums[end]) end++;</span><br><span class="line">            <span class="keyword">return</span> &#123;start,end&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="两遍二分查找"><a href="#两遍二分查找" class="headerlink" title="两遍二分查找"></a>两遍二分查找</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(high &lt; <span class="number">0</span> || nums[high] != target) <span class="keyword">return</span> res;</span><br><span class="line">        res[<span class="number">0</span>] = high;high = nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>] = high - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text3 删除 Markdown Editing 插件后启动报错</title>
    <url>/2019/11/16/Sublime-Text3-removes-the-Markdown-Editing-plugin-leads-to-an-error.html</url>
    <content><![CDATA[<h3 id="Sublime-Text3启动报错"><a href="#Sublime-Text3启动报错" class="headerlink" title="Sublime Text3启动报错"></a>Sublime Text3启动报错</h3><p><code>Sublime Text3</code> 之前装了 <code>Markdown Editing</code> 插件，由于嫌弃界面太难看把他卸载了，之后再次打开<code>.md</code>格式的文件，一直报下面这个错误。<br><a id="more"></a><br><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>Error loading colour scheme Packages/MarkdownEditing/MarkdownEditor.tmTheme: Error parsing plist xml: Failed to open file In file "Packages/MarkdownEditing/MarkdownEditor.tmTheme"</span><br></pre></td></tr></table></figure></p>
<p>查阅网上有方法说<code>set syntax:html</code> 可以解决，但这好像不能根本解决问题，依旧会弹出报错弹窗。后面找到文件夹<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Usersname\AppData\Roaming\Sublime Text 3\Packages\User</span><br></pre></td></tr></table></figure><br>发现存在卸载残留文件，即 <code>Markdown Editing</code> 的配置文件，将其删除后文集解决，<code>Sublime Text3</code>正常工作。类似的还有一个<code>Error trying to parse settings</code>的报错，也是配置文件的原因，找到报错显示的对应配置文件修改一下就解决了。</p>
]]></content>
      <categories>
        <category>Sublime Text3</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>Sublime Text3</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--771. Jewels and Stones</title>
    <url>/2019/03/28/LeetCode--771-Jewels-and-Stones.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>You’re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.<br><a id="more"></a><br>The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: J = “aA”, S = “aAAbbbb”<br>Output: 3</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: J = “z”, S = “ZZ”<br>Output: 0</p>
</blockquote>
<p><strong>Note:</strong></p>
<blockquote>
<ul>
<li>S and J will consist of letters and have length at most 50.</li>
<li>The characters in J are distinct.</li>
</ul>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>1.这是一道很简单的题，只需要逐个判断字符串 <strong>S</strong> 中的每个字符,是否在字符串 <strong>J</strong> 中出现过。设置一个计数器count，每次判断后更新该计数器，带遍历完整个字符串，即可得出最终结果。比较字符串的过程中，应用了string库里的find()函数。<br>2.在看别人提交的解法中，看见了另外一种比较有趣的方法，建立了一个与字符ASCII码大小相同的数组，每次判断字符是否存在，只需直接在数组内查看该字符ASCII码对应的位置是否为1，这是一种空间换时间的方法。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li>解法1 </li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(J.find(S[i]) != J.npos)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>解法2</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> exist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; J.length();i++) &#123;</span><br><span class="line">            exist[J.at(i)] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exist[S.at(i)]) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark学习-Spark程序基本运行流程</title>
    <url>/2019/11/16/Spark-learning-record--program-running-process.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>刚好最近学习大数据需要运行简单的Spark算法，就顺便记录一下Spark程序基本上是怎么运行的，这里就不涉及那些理论或者API的用法了。只是说怎么把程序跑起来<br><a id="more"></a></p>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><p>以做的线性回归算法为例(只做了线性回归<code>-_-||</code>)，主要步骤如下：</p>
<blockquote>
<ol>
<li><p>编写 Spark 程序，这里涉及到一些 Spark 语法，暂时没看懂，以后系统学习的时候再慢慢深入</p>
</li>
<li><p>将实验数据传到 HDFS 上，配置的 Spark 基于 Hadoop 的 HDFS 运行，所以 Spark 直接访问的是 HDFS 上的数据，不能访问到本地。</p>
</li>
<li><p>将程序(调用<code>pyspark</code>的<code>.py</code>代码)提交到集群执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">spark-submit --master spark://host:port program.py</span><br></pre></td></tr></table></figure>
<p>查阅资料 Spark 还有多种运行模式，以后好好学一学(拖延症，不知道啥时候能开始学了)<br>HDFS 的主要操作有以下： </p>
</li>
</ol>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">hdfs dfs -help</td>
<td style="text-align:left">--查看hdfs帮助</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -ls folder</td>
<td style="text-align:left">--查看目录文件</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -put sourcepath savepath</td>
<td style="text-align:left">--hdfs上传文件，-f 覆盖已有文件；-p 保留原文件属性</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -get sourcepath savepath</td>
<td style="text-align:left">--hdfs下载文件</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -mkdir -p /output/dirname</td>
<td style="text-align:left">--创建多级目录</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -touchz /input/filename</td>
<td style="text-align:left">--创建文件filename</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -cat /input/filename</td>
<td style="text-align:left">--查看文件filename内容</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -du -s /input</td>
<td style="text-align:left">--查看所有文件大小和字节大小</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -cp /sourcefile /targetfile</td>
<td style="text-align:left">--复制文件</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -rm -R /directory</td>
<td style="text-align:left">--删除文件夹，-R循环删除文件夹里面的文件</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -mv /user/root/.Trash/Current/filename /filename</td>
<td style="text-align:left">--找回删除文件</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>这是一些较为常用的命令，具体其它指令可以查看<code>hdfs dfs -help</code>可以发现和<code>Linux</code>下文件系统的指令很相似，大部分指令的功能基本相同，只是增加了一些有分布式系统特性的指令，比如<code>-put</code>等。</p>
</blockquote>
<p>参考：</p>
<blockquote>
<ul>
<li><a href="https://www.cnblogs.com/zengming/p/10306706.html" target="_blank" rel="noopener">常用HDFS操作命令</a></li>
<li><a href="https://www.cnblogs.com/qiuhong10/p/8476635.html" target="_blank" rel="noopener">Spark多种运行模式</a></li>
<li><a href="https://blog.csdn.net/roguesir/article/details/83317059" target="_blank" rel="noopener">【PySpark学习笔记三】spark-submit命令详解</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.NULL: The Missing Semester of Your CS Education 学习</title>
    <url>/2020/05/27/MIT-6-NULL-The-Missing-Semester-of-Your-CS-Education-Learning.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近开始学习一下<code>MIT</code>的一门课程：<a href="https://missing.csail.mit.edu/" target="_blank" rel="noopener">6.NULL: The Missing Semester of Your CS Education</a>。主要是讲了一些Linux上常用的工具。在这个系列课程中，<code>讲授命令行、强大的文本编辑器的使用、使用版本控制系统提供的多种特性等等</code>。<br><a id="more"></a><br>最初是在知乎上一篇博客<a href="https://zhuanlan.zhihu.com/p/139361685" target="_blank" rel="noopener">6.NULL：恨不相逢“未嫁时”</a>上看见的，确实有许多Linux的工具在编程时可以让起到事半功倍的效果，刚好MIT有这样一门课程可以统一的学习了解一下。写这系列博客，一方面做一个学习笔记，另一方面也督促一下我的学习进度，实在太懒了，又有一些乱七八糟的事情，就慢慢开始学习吧。</p>
<h3 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h3><p>课程内容并不算多，看课程日常表总共有十一章，每天一章。借用知乎博客上的介绍，这门课程内容主要涉及了<code>一些好用（能大大提高生产力）的工具，如terminal、编辑器editor、tmux、profiler、数据处理工具(如awk, sed, grep, perl）等等</code>，都是一些很实用的工具，经常会被用到。课程上主要是告诉你这些工具是做什么的、能实现什么样的事情，并给了一些简单的使用示例，而如果你想要去深入地了解这些工具，课程的notes则提供了一些资料供你阅读。而且这是一门需要结合实际操作的课程，因为都是工具嘛，不用的话也就没啥用了。好了，开始了！！</p>
<h3 id="笔记索引"><a href="#笔记索引" class="headerlink" title="笔记索引"></a>笔记索引</h3><p>下面是学习过程中，每次课程的一些笔记和实战演练，不过其实官网上的介绍已经有许多了。</p>
<blockquote>
<ol>
<li><a href="../../../2020/05/27/MIT-6-NULL-one-Course-overview-plus-the-shell.html">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>MIT课程</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>MIT</tag>
      </tags>
  </entry>
  <entry>
    <title>pip/conda install 由于目标计算机积极拒绝，无法连接</title>
    <url>/2019/11/23/Pip-conda-install-unable-to-connect-bug.html</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>之前遇到一个困扰已久的问题, 使用 <code>conda/pip install</code> 安装库时一直显示代理有问题, <code>由于目标计算机积极拒绝，无法连接</code>。<a id="more"></a><br>一开始一直以为是我的代理设置出现了问题，改了很多次系统代理设置，但一直没有效果。而且这个问题也使得我的谷歌浏览器无法实现科学上网。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>最后终于通过修改注册表解决了这个问题，主要操作如下：</p>
<blockquote>
<ol>
<li>通过<code>Win+R</code>快捷键，输入<code>regedit</code>，打开注册表编辑器</li>
<li>找到<code>HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Internet Settings</code></li>
<li>将以 <strong>Proxy</strong> 开头的条目都删除</li>
</ol>
</blockquote>
<p>之后一切就都回复正常了。这个改注册表的方法还挺万用的，有时候会出现无法连上网但是无法访问百度的问题，也可通过删除<code>HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Internet Settings/Connections</code>下的相关条目来解决。</p>
<p>应该是由于科学上网后系统代理出现啥Bug，通过删除注册表可以实现初始化吧。</p>
<h3 id="查看文献"><a href="#查看文献" class="headerlink" title="查看文献"></a>查看文献</h3><blockquote>
<ul>
<li><a href="https://blog.csdn.net/lezeqe/article/details/94913345" target="_blank" rel="noopener">解决：pip install 由于目标计算机积极拒绝，无法连接</a></li>
<li><a href="https://blog.csdn.net/weixin_43323092/article/details/82962023" target="_blank" rel="noopener">解决系统代理被篡改/pip提示“目标计算机积极拒绝，无法连接”的方法</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--37. Sudoku Solver</title>
    <url>/2019/04/25/LeetCode--37-Sudoku-Solver.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Write a program to solve a Sudoku puzzle by filling the empty cells.<br><a id="more"></a><br>A sudoku solution must satisfy <strong>all of the following rules:</strong></p>
<ol>
<li>Each row must contain the digits 1-9 without repetition. </li>
<li>Each column must contain the digits 1-9 without repetition. </li>
<li>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li>
</ol>
<p>Empty cells are indicated by the character <code>&#39;.&#39;</code>.</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="A sudoku puzzle..." title="A sudoku puzzle..."></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="...and its solution numbers marked in red." title="...and its solution numbers marked in red."></p>
<p><strong>Note :</strong></p>
<ul>
<li>The given board contain only digits <code>1-9</code> and the character <code>&#39;.&#39;</code>.</li>
<li>You may assume that the given Sudoku puzzle will have a single unique solution.</li>
<li>The given board size is always <code>9x9</code>.</li>
</ul>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>还是遇到这道题了，解数独。有了上一道题的经验，对于解数独的问题也不是毫无头绪了。</p>
<p>既然我们已经有了判断当前棋盘是否符合数独规则的算法，那么一种直观的方法就是利用递归回溯法，将所有可能的合法数字都尝试一遍，判断哪种方法最终可以将整个棋盘填满并且符合数独的规则。尽管思路是有了，但是实现起来还是有点磕磕碰碰，对于递归回溯的使用还是不熟悉呀。实现后不出所料，性能不够好，耗时太多了，暴力解法的缺点就是思路简单，但一般复杂度不会太好。</p>
<p>对这个方法的一种优化是，每次填入一个数的时候，不必要对整个棋盘都判断一遍是不是有效的，只需要判断加入的这个数有没有违反规则。若每次加入的数都没有违反规则，那么到最后填满整个棋盘的数，所有的数也就都是有效的。这样就省去大量重复的比较时间，使得效率得到了提升。</p>
<p>除此之外还有一些比较高深复杂的解法，暂时还没看懂，后面补充。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        solveSudo(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solveSudo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">9</span>) <span class="keyword">return</span> solveSudo(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; ++k) </span><br><span class="line">            &#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>)(k + <span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span> (isValidSudoku(board)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (solveSudo(board, i, j + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> solveSudo(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; col(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; block(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; row(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = <span class="number">1</span> &lt;&lt; (board[i][j] - <span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">if</span> (row[i] &amp; idx || col[j] &amp; idx || block[i/<span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>] &amp; idx)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    </span><br><span class="line">                    row[i] |= idx;</span><br><span class="line">                    col[j] |= idx;</span><br><span class="line">                    block[i/<span class="number">3</span> * <span class="number">3</span> + j/<span class="number">3</span>] |= idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        solveSudo(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solveSudo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">9</span>) <span class="keyword">return</span> solveSudo(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; ++k) </span><br><span class="line">            &#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>)(k + <span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span> (isValidSudoku(board, i, j)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (solveSudo(board, i, j + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> solveSudo(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; ++col) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (col != j &amp;&amp; board[i][j] == board[i][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; ++row) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (row != i &amp;&amp; board[i][j] == board[row][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = i / <span class="number">3</span> * <span class="number">3</span>; row &lt; i / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; ++row) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = j / <span class="number">3</span> * <span class="number">3</span>; col &lt; j / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; ++col) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((row != i || col != j) &amp;&amp; board[i][j] == board[row][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-10-矩形覆盖</title>
    <url>/2021/05/26/JZ10_Rectangular_coverage.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用<code>n</code>个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，从同一个方向看总共有多少种不同的方法？<br><a id="more"></a></p>
<p>比如<code>n=3</code>时，<code>2*3</code>的矩形块有<code>3</code>种不同的覆盖方法(从同一个方向看)：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ10/JZ10.png" alt="矩形覆盖"></p>
<p><strong>示例1</strong></p>
<blockquote>
<p>输入：0<br>返回值：0</p>
</blockquote>
<p><strong>示例2</strong></p>
<blockquote>
<p>输入：1<br>返回值：1</p>
</blockquote>
<p><strong>示例3</strong></p>
<blockquote>
<p>输入：4<br>返回值：5</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>实际上还是一个类似于斐波那契数列的问题(连续好几个题了)，初始化两个基本的组合，<code>1</code>个<code>2*1</code>的小矩形只有<code>1</code>种组合方式，<code>2</code>个这样的矩阵有两种组合方式，然后是这两个基本组合之上的不断叠加的组合方法。所以可以写为：</p>
<script type="math/tex; mode=display">
F(1)=1\\
F(2)=2\\
F(n) = F(n-1) + F(n-2) (n \geq 3, n \in N^*)</script><p>剩下的就是利用之前的递归法，迭代法来实现该算法。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1. 递归法"></a>1. 递归法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;=<span class="number">2</span>) <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rectCover(target-<span class="number">1</span>) + rectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-迭代法"><a href="#2-迭代法" class="headerlink" title="2. 迭代法"></a>2. 迭代法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;=<span class="number">2</span>) <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum = sum + one;</span><br><span class="line">            one = sum - one;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo学习记录--基本操作</title>
    <url>/2019/11/11/hexo-learning-record--basic-operation.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>终于决定重新开始写博客了。这次一定得坚持下来，写写学习进度，定期自我总结。太久没写博客了，基本操作又给忘了，这次就索性先从怎么写博客开始，把基本指令都记录下来，省得下次半途而废回来的时候又全忘了到处查。</p>
</blockquote>
<a id="more"></a>
<h3 id="Hexo写博客的基本操作"><a href="#Hexo写博客的基本操作" class="headerlink" title="Hexo写博客的基本操作"></a>Hexo写博客的基本操作</h3><h4 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h4><blockquote>
<p>最重要的就是写文章部分了，首先了解如何新建一篇文章。Hexo博客建立开始，就自带一篇 <a href="http://wuyunjie.top/2017/09/20/hello-world/">Hello World</a> 简易教程。新建文章主要用下面这条命令：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里可以指定文章的布局(layout)，默认为 <code>post</code>。这样所有的文章都会以<code>md</code>形式在<code>source</code>文件夹下的<code>_post</code>文件夹中被创建，之后我们就可以愉快的编辑文章了，这是一个<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">markdown的学习文档</a>。</p>
</blockquote>
<h4 id="添加分类页"><a href="#添加分类页" class="headerlink" title="添加分类页"></a>添加分类页</h4><blockquote>
<p>新建一个分类页面，命名为 <code>categories</code>。命令如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page [categories]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以将 <code>categories</code> 改为自己需要的新页面，会在 <code>source</code> 文件夹下新建一个对应名为<code>categories</code>的文件夹。然后编辑主题的 <code>_config.yml</code>，即<code>themes/next</code>下的配置文件，区别于网站根目录下的配置文件，将 <code>menu</code> 中的 <code>categories: /categories || th</code> 注释去掉，在菜单中添加链接。</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure>
<h4 id="文章分类归档"><a href="#文章分类归档" class="headerlink" title="文章分类归档"></a>文章分类归档</h4><blockquote>
<p>当然也可以个文章进行分类归档，在编辑文章时，为文章添加 <code>tags</code> 和 <code>categories</code>即可。<br><figure class="highlight mkdown"><table><tr><td class="code"><pre><span class="line">title: a title</span><br><span class="line">date: a date</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">    - </span>tag1</span><br><span class="line"><span class="bullet">    - </span>tag2</span><br><span class="line"><span class="bullet">    - </span>tag3</span><br><span class="line">categories: a category</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a>编辑工具</h4><blockquote>
<p>为了方便，感觉又两个在线编辑<code>markdown</code>文档的工具挺好用的。</p>
<blockquote>
<ol>
<li><a href="http://markdown.xiaoshujiang.com/" target="_blank" rel="noopener">小书匠</a></li>
<li><a href="https://www.mdeditor.com/" target="_blank" rel="noopener">MdEditor</a></li>
</ol>
</blockquote>
<p>当然也可以配置离线工具，但是不太熟。我配了个<code>sublime</code>的，感觉不好看，也不怎么好用。</p>
</blockquote>
<h3 id="生成和部署"><a href="#生成和部署" class="headerlink" title="生成和部署"></a>生成和部署</h3><blockquote>
<p>当编辑完一个博客页面后，我们需要生成静态页面。可以用如下指令。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g #生成</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们不需要急于将页面提交到<code>github</code>，可以先在本地预览效果进行调整，等到达到满意后，再部署到<code>github</code>。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s #启动服务, 通过 `localhost:4000`访问本地页面</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一切准备就绪后，就可以提交了。然后通过自己的域名就可以成功访问博客。不过这一步可能会存在延迟，不会立即看到效果。应该是由于缓存的关系。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d #上传部署到github</span><br></pre></td></tr></table></figure>
<h3 id="常用命令和缩写"><a href="#常用命令和缩写" class="headerlink" title="常用命令和缩写"></a>常用命令和缩写</h3><blockquote>
<p>常用命令有以下几个</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new "postName" #新建文章</span><br><span class="line">hexo new page "pageName" #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一些缩写形式</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>
<blockquote>
<p>至此我们可以开始愉快的玩耍了。</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p>[1] <a href="https://www.jianshu.com/p/1bcad7700c46" target="_blank" rel="noopener">使用hexo搭建github博客</a><br>[2] <a href="https://www.cnblogs.com/fengzheng/p/8031518.html" target="_blank" rel="noopener">Hexo + github 打造个人博客</a><br>[3] <a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">使用hexo+github搭建免费个人博客详细教程</a><br>[4] <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo 指令</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>学习记录</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-12-数值的整数次方</title>
    <url>/2021/05/26/JZ12_Integer_power.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>给定一个<code>double</code>类型的浮点数<code>base</code>和<code>int</code>类型的整数<code>exponent</code>。求<code>base</code>的<code>exponent</code>次方。</p>
<p>保证<code>base</code>和<code>exponent</code>不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面<code>0</code>的位数。<br><a id="more"></a></p>
<p><strong>示例1</strong></p>
<blockquote>
<p>输入：2.00000, 3<br>返回值：8.00000</p>
</blockquote>
<p><strong>示例2</strong></p>
<blockquote>
<p>输入：2.10000, 3<br>返回值：9.26100</p>
</blockquote>
<p><strong>示例3</strong></p>
<blockquote>
<p>输入：2.00000,-2<br>返回值：0.25000</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>根据题意，不需要考虑大数情况，并且<code>exponent</code>是整数，那么直接的方法就是先对<code>exponent</code>的正负判断：</p>
<ul>
<li>若为正整数，直接循环<code>exponent</code>次乘法求出结果</li>
<li>若为负整数，循环<code>-exponent</code>次乘法求出结果，然后对结果求倒数</li>
</ul>
<h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>假设我们求$x^{8}$，如果我们知道$x^{4}$，那么$x^{8} = (x^{4})^{2}$，$x^{n} = (x^{\frac{n}{2}})^{2}$。但是还有个小问题，如果n是偶数，那么上述没问题。如果$n$是奇数，$x^{n} = (x^{\frac{n}{2}})^{2}<em>x$，比如$x^{7} = (x^{3})^{2} </em> x$。</p>
<h4 id="非递归的快速幂"><a href="#非递归的快速幂" class="headerlink" title="非递归的快速幂"></a>非递归的快速幂</h4><p>假设求$x^{6}$,已知<code>6</code>可以表示成二进制<code>110</code><br>可以表示成$6 = 0<em>2^{0} + 1 </em> 2^{1} + 1 <em> 2^{2}$, 所以$x^{6}$可以表示成$x^{6} = x^ {0</em>2^{0} + 1<em>2^{1} + 1</em>2^{2}} = x^{0} <em> x^{1</em>2^{1}}<em>x^{1</em>2^{2}}$所以，对于二进制数，遇到位数是<code>1</code>的就乘到答案中。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-直接法"><a href="#1-直接法" class="headerlink" title="1. 直接法"></a>1. 直接法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exponent; i++)</span><br><span class="line">                result *= base;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; -exponent; i++)</span><br><span class="line">                result *= base;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/result;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-快速幂-递归法"><a href="#2-快速幂-递归法" class="headerlink" title="2. 快速幂(递归法)"></a>2. 快速幂(递归法)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickPower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> res = quickPower(base, exponent/<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res * res * base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res * res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quickPower(base, exponent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-快速幂-非递归法"><a href="#3-快速幂-非递归法" class="headerlink" title="3. 快速幂(非递归法)"></a>3. 快速幂(非递归法)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> x = base;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (exponent != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res *= x; <span class="comment">// 二进制位数是1的，乘进答案。</span></span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            exponent &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-13-调整数组顺序使奇数位于偶数前面</title>
    <url>/2021/05/26/JZ13_the_odd_numbers_come_before_the_even_numbers.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 <a id="more"></a></p>
<p><strong>示例1</strong></p>
<blockquote>
<p>输入：[1,2,3,4] 返回值：[1,3,2,4]</p>
</blockquote>
<p><strong>示例2</strong></p>
<blockquote>
<p>输入：[2,4,6,5,7] 返回值：[5,7,2,4,6]</p>
</blockquote>
<h3 id="二解题思路">二、解题思路</h3>
<p>这个题还有一个简单版本，即只需要保证奇数在偶数之前，不需要保证相对位置不变，先考虑这种情况下的解法。主要有两种方法：<strong>首尾双指针</strong>和<strong>快慢双指针</strong>。都是利用<code>双指针</code>求解，只是方向不一样：</p>
<h4 id="首尾双指针">1. 首尾双指针</h4>
<p>定义头指针<code>low</code>，尾指针<code>high</code>。</p>
<ul>
<li><code>low</code>向右移动，直到指向的值为偶数，<code>high</code>一直往左移， 直到指向的值为奇数。交换 <code>nums[low]</code>和<code>nums[high]</code>。</li>
<li>重复上述操作，直到<code>low == high</code> .</li>
</ul>
<h4 id="快慢双指针">2. 快慢双指针</h4>
<p>思路与首尾双指针大致相同，只是此时两个指针向同一个方向移动。定义快慢双指针<code>fast</code>和<code>slow</code>，<code>fast</code>在前，<code>slow</code>在后。</p>
<ul>
<li><code>fast</code>向前搜索奇数位置，slow指向下一个奇数应当存放的位置。<code>fast</code>搜索到奇数时，将它和<code>nums[slow]</code>交换，此时<code>slow</code>向前移动一个位置。</li>
<li>重复上述操作，直到<code>fast</code>指向数组末尾。</li>
</ul>
<p>但是基于首位指针的方法会改变奇数和奇数，偶数和偶数之间的相对位置，所以并不适合于本题。主要有两种思路：</p>
<h4 id="基于插入排序的思想">3. 基于插入排序的思想</h4>
<p>第一种方法基于插入排序的思想，记录已经满足奇数在前面的位置（视为排序中的已经有序部分），然后向前搜索发现奇数进行插入。这种方法只需要少量的额外空间，但时间复杂度较高。</p>
<h4 id="开辟新空间存储排序数组">4. 开辟新空间存储排序数组</h4>
<p>另一种方法事声明一个与原数组相同大小的新数组，用来存储排序后的数组，同时保持相对位置。可以利用首尾双指针的思想，对数组进行一次遍历，头指针处理奇数，尾指针处理偶数。头指针将奇数按顺序放到新数组前，尾指针将偶数按顺序放到新数组后。</p>
<p>为了对空间进一步优化，可以使用一个队列，将偶数放入队列中，按顺序放在原数组中，最后将队列中数据放入剩余的原数组空间，这时只需要额外开辟偶数大小的空间用于存放数据。</p>
<h3 id="三代码实现">三、代码实现</h3>
<h4 id="首尾双指针-1">1. 首尾双指针</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( low &lt; nums.length &amp;&amp; (nums[low] &amp; <span class="number">1</span>) == <span class="number">1</span>) low++;</span><br><span class="line">            <span class="keyword">while</span> ( high &gt;= <span class="number">0</span> &amp;&amp; (nums[high] &amp; <span class="number">1</span>) == <span class="number">0</span>) high--;</span><br><span class="line">            <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">                nums[low] ^= nums[high];</span><br><span class="line">                nums[high] ^= nums[low];</span><br><span class="line">                nums[low] ^= nums[high];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快慢双指针-1">2. 快慢双指针</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (nums[fast] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[slow];</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                nums[fast] = temp;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于插入排序的思想-1">3. 基于插入排序的思想</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>( array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> array;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> oddIndex = <span class="number">0</span>;<span class="comment">//记录已经是奇数的位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (array[i] &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> k = i;</span><br><span class="line">                temp = array[k];</span><br><span class="line">                <span class="keyword">while</span>(k &gt; oddIndex)&#123;</span><br><span class="line">                    array[k] = array[k-<span class="number">1</span>];<span class="comment">//这区间整体向后移动一位</span></span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                array[k] = temp;</span><br><span class="line">                oddIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="开辟原数组大小的额外空间">4.1 开辟原数组大小的额外空间</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index_head = head;</span><br><span class="line">        <span class="keyword">int</span> index_tail = tail;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; array.length &amp;&amp; tail &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[head] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//奇数，放前面</span></span><br><span class="line">                nums[index_head] = array[head];</span><br><span class="line">                index_head++;</span><br><span class="line">            &#125;</span><br><span class="line">            head++;</span><br><span class="line">            <span class="keyword">if</span>(array[tail] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//从后到前，如果为偶数，则从后开始填</span></span><br><span class="line">                nums[index_tail] = array[tail];</span><br><span class="line">                index_tail--;</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="开辟数组中偶数数量大小的额外空间">4.2 开辟数组中偶数数量大小的额外空间</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index_head = head;</span><br><span class="line">        <span class="keyword">int</span> index_tail = tail;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; array.length &amp;&amp; tail &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[head] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//奇数，放前面</span></span><br><span class="line">                nums[index_head] = array[head];</span><br><span class="line">                index_head++;</span><br><span class="line">            &#125;</span><br><span class="line">            head++;</span><br><span class="line">            <span class="keyword">if</span>(array[tail] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//从后到前，如果为偶数，则从后开始填</span></span><br><span class="line">                nums[index_tail] = array[tail];</span><br><span class="line">                index_tail--;</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考文献">参考文献</h3>
<ol type="1">
<li><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/solution/ti-jie-shou-wei-shuang-zhi-zhen-kuai-man-shuang-zh/" target="_blank" rel="noopener">【题解】：首尾双指针，快慢双指针</a></li>
</ol>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-11-二进制中1的个数</title>
    <url>/2021/05/26/JZ11_Number_of_1s_in_binary.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>输入一个整数，输出该数<code>32</code>位二进制表示中<code>1</code>的个数。其中负数用补码表示。<br><a id="more"></a></p>
<p><strong>示例1</strong></p>
<blockquote>
<p>输入：10<br>返回值：2</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><h4 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1. 位运算"></a>1. 位运算</h4><p>考查的应该就是位操作吧。实际上要统计<code>1</code>的个数很简单，只需要将整数逐位右移，统计最低位<code>1</code>的出现次数。判断最低为是否为<code>1</code>可以使用等式：<code>n &amp; 1</code>，结果为<code>1</code>即为<code>1</code>，否则为<code>0</code>。</p>
<p>这里有一个需要注意的点是，由于整数是补码表示，所以在右移的时候，若数字为负数会将高位自动补<code>1</code>。这里刚好之前学到<code>Java</code>里有一个无符号右移的运算符: <code>&gt;&gt;&gt;</code>，可以直接解决这个问题。</p>
<ul>
<li><a href="https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html">[Java学习|Head_First_Java]—十大遗珠之憾</a></li>
</ul>
<h4 id="2-技巧法"><a href="#2-技巧法" class="headerlink" title="2. 技巧法"></a>2. 技巧法</h4><p>考虑二进制数：<code>val :1101000</code>, <code>val-1: 1100111</code> 那么<code>val &amp; （val-1） : 1100000</code>。即：</p>
<blockquote>
<p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p>
</blockquote>
<p>把一个整数减去<code>1</code>，再和原整数做与运算，会把该整数最右边一个<code>1</code>变成<code>0</code>.那么一个整数的二进制有多少个<code>1</code>，就可以进行多少次这样的操作。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-位运算-1"><a href="#1-位运算-1" class="headerlink" title="1. 位运算"></a>1. 位运算</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfOnes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            numOfOnes += (n &amp; <span class="number">1</span>);</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numOfOnes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-技巧法："><a href="#2-技巧法：" class="headerlink" title="2. 技巧法："></a>2. 技巧法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfOnes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            numOfOnes++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numOfOnes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/09/20/Hello-World.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>学习记录</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-3-从尾到头打印链表</title>
    <url>/2021/04/20/JZ3-print-LinkList-reverse.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>输入一个链表，按链表从尾到头的顺序返回一个<code>ArrayList</code>。<br><a id="more"></a></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:   {67,0,24,58}<br>返回值: [58,24,0,67]</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题也挺简单的，感觉都是考察基础啊，怎么都标为较难。思路很简单，就是遍历链表元素，存入新建的ArrayList对象，最后通过一个反转函数对ArrayList反转。此外还有基于递归的方法，或者先对链表反转，再存入ArrayList。</p>
<p>这里对反转链表操作简单复习一下，可以总结为先存储当前节点的下一节点，再反转当前节点的pnext指针，最后重置head头部。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ3/reverse_linklist.gif" alt="反转链表"></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li>解法1 存入ArrayList后反转<br>1.1. 直接加入到ArrayList第一个位置实现反转<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; List = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            List.add(<span class="number">0</span>, listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> List;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>1.2. 调用<code>Collections.reverse()</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; List = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            List.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(List);</span><br><span class="line">        <span class="keyword">return</span> List;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>解法2 反转链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = listNode;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(pre.val);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法3  递归方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol>
<li><p>Java <code>ArrayList</code>类<br>ArrayList 类是一个<strong>可以动态修改</strong>的数组，与普通数组的区别就是它是<strong>没有固定大小的限制</strong>，我们可以添加或删除元素。ArrayList 类位于<code>java.util</code>包中，使用前需要引入它，语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 引入 ArrayList 类</span></span><br><span class="line">ArrayList&lt;E&gt; objectName =<span class="keyword">new</span> ArrayList&lt;&gt;();　 <span class="comment">// 初始化</span></span><br></pre></td></tr></table></figure>
<p>ArrayList 是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p>
</li>
<li><p>Collections<br><code>Collections</code>是JDK提供的工具类，同样位于<code>java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。</p>
</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://www.runoob.com/java/java-arraylist.html" target="_blank" rel="noopener">String、StringBuffer和StringBuilder的区别</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-6-旋转数组的最小数字</title>
    <url>/2021/05/24/JZ6_rotate_the_smallest_number_of_the_array.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br><strong>NOTE</strong>：给出的所有元素都大于0，若数组大小为0，请返回0。<br><a id="more"></a></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:   [3,4,5,1,2]<br>返回值: 1</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题应该是类似于查找的问题，其中数组为非递减序列是一个很关键的信息。</p>
<h4 id="1-暴力方法"><a href="#1-暴力方法" class="headerlink" title="1. 暴力方法"></a>1. 暴力方法</h4><p>对于查找类型的问题，都存在暴力方法，即将整个数组都遍历一遍，总会找到最小值。</p>
<h4 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h4><p>可以发现，选择数组中要找到的最小元素，即为分界线处的元素。即需要通过二分查找的方法，找到数组中的分界线。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ6/JZ61.png" alt="旋转数组"></p>
<p>在分界线左边的元素一定是要比分界线右边元素大的。所以可以基于二分查找方法，设定<code>low</code>和<code>high</code>的位置，然后判断<code>mid</code>位置是在数组的<code>左半部分</code>还是<code>右半部分</code>，逐渐缩小范围找到最小值。</p>
<ul>
<li>处于左半部分，<code>low</code>移到<code>mid</code>处</li>
<li>处于右半部分，<code>high</code>移到<code>mid</code>处</li>
<li>其他情况<code>low++</code></li>
</ul>
<p>但后来检测发现一个<code>bug</code>，遇到<code>[1, 0, 1, 1, 1]</code>这样的情况会出错：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ6/JZ62.png" alt="错过了最小值`0`"></p>
<p>为了解决该问题，只需要在提前检查数列，如果是非递减数列，返回最低位<code>low</code>的值。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">1</span>) <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[low] &lt; array[high])</span><br><span class="line">                <span class="keyword">return</span> array[low];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((mid + <span class="number">1</span>) &lt; array.length &amp;&amp; array[mid] &gt; array[mid + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> array[mid + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>((mid - <span class="number">1</span>) &gt; -<span class="number">1</span> &amp;&amp; array[mid] &lt; array[mid - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> array[mid];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[low])</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; array[high])</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更简单的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rotateArray.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = rotateArray.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="comment">// 子数组是非递减的数组，10111</span></span><br><span class="line">        <span class="keyword">if</span> (rotateArray[low] &lt; rotateArray[high]) </span><br><span class="line">            <span class="keyword">return</span> rotateArray[low];</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[low])</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[high])</span><br><span class="line">            high = mid; <span class="comment">// 如果是mid-1，则可能会错过最小值，因为找的就是最小值</span></span><br><span class="line">        <span class="keyword">else</span> low++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rotateArray[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://blog.nowcoder.net/n/dcb0f2e6ffd44e1895b7a5297e362778" target="_blank" rel="noopener">【剑指offer T11】旋转数组的最小数字</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.NULL(一) Course overview + the shell</title>
    <url>/2020/05/27/MIT-6-NULL-one-Course-overview-plus-the-shell.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://missing-semester-cn.github.io/2020/course-shell/" target="_blank" rel="noopener">第一章</a>主要介绍课程概览，shell的一些基础知识。<br><a id="more"></a><br>课程分为11个时长一小时的讲座，每次围绕一个特定主题。第一次课程主要介绍了shell的使用，这是计算机的一个对外接口，这次课程介绍的许多工具都要通过shell来操作。</p>
<h3 id="主题-1-The-Shell"><a href="#主题-1-The-Shell" class="headerlink" title="主题 1: The Shell"></a>主题 1: The Shell</h3><h4 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h4><p>图形界面等交互式接口会限制我们对计算机的操作，比如无法在GUI上点击一个不存在的按钮。所以需要用到最根本的文字接口：<strong>Shell</strong>。大部分<strong>Shell</strong>的核心功能都是：<code>它允许你执行程序，输入并获取某种半结构化都输出。</code>课程中使用<code>Bourne Again SHell</code>, 简称 <code>“bash”</code>。</p>
<h4 id="shell使用"><a href="#shell使用" class="headerlink" title="shell使用"></a>shell使用</h4><p>这里我通过虚拟机安装的ubuntu系统完成课程中的各个实验。首先打开终端，有提示符</p>
<blockquote>
<p><code>wuyunjie@ubuntu:~$</code> </p>
</blockquote>
<p>这是shell最主要的文本接口。它告诉你，当前登陆用户是<code>wuyunjie</code>，主机名是 <code>missing</code> 并且当前的工作目录（”current working directory”）或者说当前所在的位置是<code>~</code> (表示 “home”)。 <code>$</code>符号表示您现在的身份不是<code>root</code>用户。可以在其中输入 <em>命令</em> ，命令最终会被shell解析。课程用到的例子如下：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_introduction.png" alt="Shell Introduction"></p>
<p>首先执行了 <code>date</code> 程序，打印出当前的日前和时间。然后，shell等待输入其他命令。</p>
<p>可以在执行命令的同时向程序传递 <code>参数</code>，比如<code>echo hello</code>中，<code>hello</code>是指定输入给<code>echo</code>程序的参数。shell基于<strong>空格</strong>分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），要么用使用单引号，双引号将<code>包含空格的参数</code>包裹起来，要么使用转义符号<code>\</code>进行处理(My\ Photos)。</p>
<p>shell其实也是一个编程环境，它具备<code>变量、条件、循环和函数</code>。当在shell中执行命令时，实际上是在<code>执行一段shell可以解释执行的简短代码</code>。如果要求shell执行某个指令，但是该指令并不是shell所了解的编程关键字，那么它会去查询 <em>环境变量</em> <code>$PATH</code>，它会列出当shell接到某条指令时，进行程序搜索的路径。要确定某个程序名代表的是哪个具体的程序(程序的路径)，可以使用 <code>which</code> 命令。</p>
<h4 id="shell中的路径"><a href="#shell中的路径" class="headerlink" title="shell中的路径"></a>shell中的路径</h4><p>shell中的路径是一组<em>被分割的目录</em>，在 Linux 和 macOS 上使用 <code>/</code> 分割，而在Windows上是 <code>\</code> 。路径 <code>/</code> 代表的是系统的根目录，在Windows上每个盘都有一个根目录（例如： C:\）。</p>
<p>Linux文件系统中如果某个路径以 <code>/</code> 开头，那么它是一个 <em>绝对路径</em>，其他的都术语 <em>相对路径</em>。相对路径是指相对于<em>当前工作目录</em>的路径，当前工作目录可以使用 <code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code> 命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录。</p>
<p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令。大多数的命令接受<em>标记和选项</em>，它们以 <code>-</code> 开头。通常，在执行程序时使用 <code>-h</code> 或 <code>--help</code> 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_path.png" alt="Shell Path"></p>
<p><code>ls -l</code>命令可以打印出更加详细地列出目录下文件或文件夹的信息。</p>
<ol>
<li>首先，本行第一个字符 <code>d</code> 表示是一个目录。</li>
<li>然后接下来的九个字符，每三个字符 (<code>rwx</code>).构成一组。它们分别代表了<code>文件所有者</code>，<code>用户组</code>以及<code>其他所有人</code>具有的权限。其中 <code>-</code> 表示该用户不具备相应的权限，<code>w</code>表示”<em>可修改</em>“，<code>x</code>表示“<em>可执行</em>”，<code>r</code>表示”<code>可读</code>“。</li>
</ol>
<p>还有一些比较常用的命令：<code>mv</code> （用于重命名或移动文件）、 <code>cp</code> (拷贝文件)以及 <code>mkdir</code> (新建文件夹)。可以使用 <code>man</code> 查阅某条命令的文档（用户手册），比如<code>man ls</code>。</p>
<h4 id="“流”和”管道”"><a href="#“流”和”管道”" class="headerlink" title="“流”和”管道”"></a>“流”和”管道”</h4><h5 id="流"><a href="#流" class="headerlink" title="流"></a>流</h5><p>在shell中，程序有两个主要的“流”：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ol>
<li>当程序尝试读取信息时，它们会从输入流中进行读取；</li>
<li>当程序打印信息时，它们会将信息输出到输出流中。<br>通常，一个程序的输入输出流都是终端。我们也可以重定向这些流！</li>
</ol>
<p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件。还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_stream.png" alt="Shell Stream"></p>
<h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>使用管道（ <em>pipes</em>），能够更好的利用文件重定向。<code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_pipe.png" alt="Shell Pipe"></p>
<p>可以发现 <code>&gt;</code> 会将之后的单词视为文件名导致，是文件上的重定向。而 <code>|</code> 可以是不同程序之间的重定向。之前总感觉这个地方很混乱，也没仔细深究，现在也算补了一个坑。</p>
<h4 id="功能全面又强大的工具"><a href="#功能全面又强大的工具" class="headerlink" title="功能全面又强大的工具"></a>功能全面又强大的工具</h4><p>对于大多数的类Unix系统，<code>根用户</code>（<code>root</code>用户）是非常特殊的。根用户<strong>几乎不受任何限制</strong>，他可以创建、读取、更新和删除系统中的任何文件。当遇到<code>拒绝访问（permission denied）</code>的错误时，通常是因为必须是根用户才能操作。</p>
<blockquote>
<p>通常在我们并不会以根用户的身份直接登陆系统，因为这样可能会因为某些错误的操作而破坏系统。取而代之的是我们会在需要的时候使用 <code>sudo</code> 命令。顾名思义，它的作用是可以以 <code>su</code>（<code>super user</code> 或 <code>root</code>的简写）的身份 <strong>do</strong> 一些事情。 </p>
</blockquote>
<p>比如有一件事情是必须作为根用户才能做的，那就是<strong>Linux</strong>下向 <code>sysfs</code> 文件写入内容。系统被挂在在 <code>/sys</code> 下，<code>sysfs</code> 文件则暴露了一些内核（kernel）参数。 因此不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。</p>
<p>课程里那个改屏幕亮度的例子没实现，不知道是不是由于虚拟机配置的关系，这里直接把他的内容摘过来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo find -L /sys/class/backlight -maxdepth 2 -name <span class="string">'*brightness*'</span></span></span><br><span class="line">/sys/class/backlight/thinkpad_screen/brightness</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /sys/class/backlight/thinkpad_screen</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo <span class="built_in">echo</span> 3 &gt; brightness</span></span><br><span class="line">An error occurred while redirecting file 'brightness'</span><br><span class="line">open: Permission denied</span><br></pre></td></tr></table></figure>
<p>尽管用了<code>sudo</code>，但仍然报错了。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过shell执行的，而不是被各个程序单独执行。 <code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， shell在设置 <code>sudo echo</code> 前尝试打开 <code>brightness</code> 文件并写入，但是系统拒绝了shell的操作因为此时shell不是根用户。可以将上述操作修改为 <code>echo 3 | sudo tee brightness</code>，打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。</p>
<h3 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h3><ol>
<li>前面1-7还好，是对shell的一个熟悉。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_exercise.png" alt="Shell exercise1"></p>
<p>主要简单了解了一下<code>shebang</code>，即在脚本开头由字符数字符号和感叹号（<code>＃!</code>）组成的字符序列。当使用带有<code>Shebang</code>的文本文件时，程序加载机制会将文件的其余行解析为解释器指令。加载程序执行指定的解释程序，将尝试运行脚本时最初使用的路径作为参数传递给它，以便程序可以将文件用作输入数据。</p>
<p><code>shebang</code> 解释器指令的形式如下：</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!interpreter [optional-arg]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>interpreter</code>是解释器的绝对路径，<code>optional-arg</code>是表示单个参数的字符串，可选。</p>
<ol>
<li>8题需要查到<em>最后更改日期信息</em>，并且将其写入文件，这里主要就是如何找到<code>last-modified</code>这一行。刚开始使用<code>find</code>，但它适用于查找文件，查找文本更多用的<code>grep</code>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_exercise2.png" alt="Shell exercise2"></p>
]]></content>
      <categories>
        <category>MIT课程</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>MIT</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-5-用两个栈实现队列</title>
    <url>/2021/05/24/JZ5_implement_the_queue_with_two_stacks.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><a id="more"></a></p>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>队列的特性是先进先出(<code>FIFO</code>)，栈的特点是先进后出(<code>FILO</code>)。很容易想到一个直观的方法：</p>
<ol>
<li>将队列数据先存入一个栈；</li>
<li>当需要<code>pop</code>出队列的元素时，将该栈元素逐个弹出存入另一个栈，然后弹出栈顶。</li>
</ol>
<p>但这样会有冗余操作，比如连续的<code>push</code>和连续的<code>pop</code>可以只在其中一个栈中操作，所以可以优化为：</p>
<ol>
<li>需要插入时，直接<code>push</code>到<code>stack1</code>；</li>
<li>需要弹出时，若<code>stack2</code>不为空，弹出<code>stack2</code>的栈顶元素；若<code>stack2</code>为空，将 <code>stack1</code> 中的全部数逐个出栈入栈 <code>stack2</code>，再弹出 <code>stack2</code> 栈顶元素</li>
</ol>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-2-替换空格</title>
    <url>/2021/04/20/JZ2-replace-spaces.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成<code>&quot;%20&quot;</code>。例如，当字符串为<code>We Are Happy</code>，则经过替换之后的字符串为<code>We%20Are%20Happy</code>。<br><a id="more"></a></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:   “We Are Happy”<br>返回值: “We%20Are%20Happy”</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题挺简单的，就是逐个判断String数组的字符，然后基于拼接构建出要求的字符串。也有方法直接调用内置的替换函数，不知道为何难度为<strong>较难</strong>，可能还有特殊的优化解。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li><p>解法1 暴力求法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">                result += <span class="string">"%20"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2 调用 <code>String.replaceAll()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">   <span class="keyword">return</span> s.replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法3 调用 <code>Spring.split()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        String[] strs = s.split(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">" "</span>.equals(str))</span><br><span class="line">                sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            sb.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol>
<li>String、StringBuffer和StringBuilder</li>
</ol>
<ul>
<li>String<br><code>String</code>类是<strong>不可变</strong>类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。通过一个字符串对象a的内存存储空间图对String类的不可变性理解。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ2/String.png" alt="`String`类不可变"></p>
<p>再次给a赋值时，并不是对原来堆中实例对象进行重新赋值，而是生成一个新的实例对象，并且指向“456”这个字符串，a则指向最新生成的实例对象，<em>之前的实例对象仍然存在，如果没有被再次引用，则会被垃圾回收</em>。</p>
<ul>
<li>StringBuffer<br><code>StringBuffer</code>对象则代表一个字符序列<strong>可变</strong>的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的<code>append()</code>、<code>insert()</code>、<code>reverse()</code>、<code>setCharAt()</code>、<code>setLength()</code>等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的<code>toString()</code>方法将其转换为一个String对象。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ2/StringBuffer.png" alt="`StringBuffer`类"></p>
<p>字符串连接的情况，方便和直接的方式是通过”+”符号来实现，但是这种方式达到目的的效率比较低，且<em>每执行一次都会创建一个String对象</em>，<strong>即耗时，又浪费空间</strong>。使用StringBuilder类就可以避免这种问题的发生</p>
<ul>
<li>StringBuilder<br><code>StringBuilder</code>类也代表<strong>可变</strong>字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：<strong>StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高</strong>。StringBuffer类中的方法都添加了<code>synchronized</code>关键字，也就是给这个方法添加了一个锁，用来保证线程安全。</li>
</ul>
<p><strong>Java9改进了字符串</strong>（包括String、StringBuffer、StringBuilder）的实现。在Java9以前字符串采用<code>char[]</code>数组来保存字符，因此字符串的每个字符占<code>2</code>字节；而Java9的字符串采用<code>byte[]</code>数组再加一个<code>encoding-flag</code>字段来保存字符，因此字符串的每个字符只占<code>1</code>字节。所以Java9的字符串更加节省空间，字符串的功能方法也没有受到影响。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://blog.csdn.net/csxypr/article/details/92378336" target="_blank" rel="noopener">String、StringBuffer和StringBuilder的区别</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-1-二维数组中的查找</title>
    <url>/2021/04/02/JZ1-Lookup-in-a-two-dimensional-array.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><a id="more"></a></p>
<blockquote>
<p>[<br>  [1,2,8,9],<br>  [2,4,9,12],<br>  [4,7,10,13],<br>  [6,8,11,15]<br>]</p>
</blockquote>
<p>给定 target = 7，返回 true。<br>给定 target = 3，返回 false。</p>
<p><strong>示例1:</strong></p>
<blockquote>
<p>输入:   7, [[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]<br>返回值: true<br>说明:   存在7，返回true</p>
</blockquote>
<p><strong>示例2:</strong></p>
<blockquote>
<p>输入:   3, [[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]<br>返回值: false<br>说明:   不存在3，返回false</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题考察的应该是二维数组上的二分查找，因为数组是按从顺序排列的，所有很容易想到将一维数组的思想扩展到二维数组上。但这种思想似乎并不可行，在实现过程中遇到了难度。</p>
<h4 id="方法1-暴力求解"><a href="#方法1-暴力求解" class="headerlink" title="方法1: 暴力求解"></a>方法1: 暴力求解</h4><p>暴力求解法思路很直接，直接将数组中所有数据都遍历一遍，自然可以判断<code>target</code>是否存在于数组中。但该方法复杂度为<code>O(n^2)</code>，即最坏情况下所有元素都需要访问一次。</p>
<h4 id="方法2-二分查找"><a href="#方法2-二分查找" class="headerlink" title="方法2: 二分查找"></a>方法2: 二分查找</h4><p>暴力求解方法未用到数组有序这一信息，针对数组有序自然想到二分查找的方法。这里基于题解[1]复习一下二分查找的思想。假设目标tar在arr[1]处，那么二分过程就是：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ1/Binary_Search.png" alt="Binary Search"></p>
<blockquote>
<p>1）设初始值：定义一个二分的开始下标为l，结束下标为r;<br>2）二分一半，中间位置为 <code>mid = l + （（r - l) &gt;&gt; 1)</code>(val&gt;&gt;1表示<code>val</code>右移一位相当于<code>val／2</code>)，相当于 <code>l+(r-l)/2</code>，这样的写法是<strong>防止溢出</strong>。如果写成 <code>mid = （l+r)/2;</code> l+r可能会溢出;<br>3) 如果 <code>tar == arr[mid]</code>，说明找到tar;<br>4）如果 <code>tar &gt; arr[mid]</code>, 说明tar在区间 <code>[mid+1, r]</code> 中，<code>l = mid + 1</code>;<br>5）如果 <code>tar &lt; arr[mid]</code>, 说明tar在区间 <code>[l, mid-1]</code> 中, <code>r = mid - 1</code>;</p>
</blockquote>
<p>最初的思想是依样在右上角开始，实现二分查找，思路稍微接近正确的求解，但二分后仍然存在问题，实现上不简洁。如果从左上位置开始二分，每次二分之后，难以确定下一次二分的走向，整个二维数组上顺序被打乱。最开始我的思路是按行从大到小二分，按列从小到大二分，每次将范围固定到某一个片段区域，但实际实现时逻辑不够清晰，代码越写越乱。当然可能仍然是可以按这样的思想实现的，只是我太菜了写不出来。</p>
<p>按照最终答案的思想，也是将二分值固定到右上或者左下的元素上，实现从两个方向不断缩小值所在的范围，这种思想实现上比我之前想的简洁太多了。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ1/Binary_Search_BinArr.png" alt="Binary Search"></p>
<blockquote>
<p>1）设初始值为右上角元素;<br>2）二分一半，中间位置为 <code>mid = l + （（r - l) &gt;&gt; 1)</code>(val&gt;&gt;1表示<code>val</code>右移一位相当于<code>val／2</code>)，相当于 <code>l+(r-l)/2</code>，这样的写法是<strong>防止溢出</strong>。如果写成 <code>mid = （l+r)/2;</code> l+r可能会溢出;<br>3) 如果 <code>val == target</code>, 直接返回;<br>4）如果 <code>tar &gt; val</code>, 说明 <code>target</code> 在更大的位置，val左边的元素显然都是 <code>&lt; val &lt; tar</code>，说明第 0 行都是无效的，所以val下移到arr[1][5];<br>5）如果 <code>tar &lt; val</code>, 说明 <code>target</code> 在更小的位置，val下边的元素显然都是 <code>&gt; val &gt; tar</code>，说明第 5 列都是无效的，所以val左移到arr[0][4];</p>
</blockquote>
<p>时间复杂度：<code>O(m+n)</code> ，其中m为行数，n为列数，最坏情况下，需要遍历m+n次。</p>
<h4 id="方法3-双折半查找法"><a href="#方法3-双折半查找法" class="headerlink" title="方法3: 双折半查找法"></a>方法3: 双折半查找法</h4><p>参考自题解[2]，该思路与我最开始的思路很相似，看了之后发现还是可以实现的，果然是我太菜了。最坏情况下时间复杂度为<code>O(M * logN)</code></p>
<blockquote>
<p>1）在二维数组分为上下左右四个边界top，bottom，left，right;<br>2）对上边界<code>top</code>进行折半查找，假设终止点为 <code>E</code>，则可以将二维数组位于终止点<code>E</code>右边的矩形<code>Rr</code>排除，因为终止点<code>E</code>小于其右边相邻的元素<code>E+1</code>，而<code>E+1</code>是右边矩形Rr的最小元素(左上元素);<br>3) 对下边界<code>bottom</code>折半，可以排除二维数组位于终止点<code>E</code>左边的矩形<code>Rl</code>排除;<br>4）对左边界<code>left</code>折半，可以排除二维数组位于终止点<code>E</code>下边的矩形<code>Rb</code>排除;<br>5）对右边界<code>right</code>折半，可以排除二维数组位于终止点<code>E</code>上边的矩形<code>Rt</code>排除;<br>6) 对由新边界组成的矩形重复以上操作，直到范围缩小为只有一个元素</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li><p>解法1 暴力求法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] vec: array)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: vec)&#123;</span><br><span class="line">                <span class="keyword">if</span> (num == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2 两遍哈希表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt; array.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target == array[row][col])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[row][col])&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法3 双折半查找法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, bottom = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sLeft = <span class="number">0</span>, sRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sTop = <span class="number">0</span>, sBottom = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt; right || top &lt; bottom)&#123;</span><br><span class="line">            <span class="comment">// 在上边界查找，缩小右边界</span></span><br><span class="line">            sLeft = left; sRight = right;</span><br><span class="line">            <span class="keyword">while</span> (sLeft &lt;= sRight) &#123;</span><br><span class="line">                mid = (sLeft + sRight) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[top][mid] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[top][mid] &lt; target)</span><br><span class="line">                    sLeft = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sRight = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; right) right = mid;</span><br><span class="line">            top++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在下边界查找，缩小左边界</span></span><br><span class="line">            sLeft = left; sRight = right;</span><br><span class="line">            <span class="keyword">while</span> (sLeft &lt;= sRight) &#123;</span><br><span class="line">                mid = (sLeft + sRight) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[bottom][mid] == target) </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[bottom][mid] &lt; target) </span><br><span class="line">                    sLeft = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    sRight = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; mid) left = mid; <span class="comment">//利用终止点缩小左边界</span></span><br><span class="line">            bottom--;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对左边界进行折半，可以缩小下边界</span></span><br><span class="line">            sTop = top; sBottom = bottom;</span><br><span class="line">            <span class="keyword">while</span> (sTop &lt;= sBottom) &#123;</span><br><span class="line">                mid = (sTop + sBottom) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[mid][left] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[mid][left] &lt; target)</span><br><span class="line">                    sTop = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sBottom = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; bottom) bottom = mid; <span class="comment">//利用终止点缩小下边界</span></span><br><span class="line">            left++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对右边界进行折半，可以缩小上边界</span></span><br><span class="line">            sTop = top; sBottom = bottom;</span><br><span class="line">            <span class="keyword">while</span> (sTop &lt;= sBottom) &#123;</span><br><span class="line">                mid = (sTop + sBottom) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[mid][right] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[mid][right] &lt; target)</span><br><span class="line">                    sTop = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sBottom = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top&lt;mid) top = mid; <span class="comment">//利用终止点缩小上边界</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (top &lt; array.length &amp;&amp; left &lt; array[<span class="number">0</span>].length &amp;&amp; array[top][left] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol>
<li>For-Each循环<br><code>For-Each</code>语句(也叫增强型的for循环)是<code>java5</code>的新特征之一，在遍历数组、集合方面，<code>foreach</code>为开发人员提供了极大的方便。但是<code>foreach</code>语句并不能完全取代<code>for</code>语句，任何的<code>foreach</code>语句都可以改写为<code>for</code>语句。值得注意的是，<code>foreach</code>并不是一个关键字，语法如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(type element: array)&#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其缺点是丢掉了索引信息，foreach只能挨个遍历数组或者集合一遍。但在可以使用foreach的地方，其简化了编程，<em>提高了代码的可读性和安全性（不用怕数组越界）</em>。foreach一般结合泛型使用。</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://blog.nowcoder.net/n/f146364d1331407080adbbb5a062e067" target="_blank" rel="noopener">二维数组中的查找</a><br>[2] <a href="https://blog.nowcoder.net/n/d332492753844d18aa4edc484e3c1318" target="_blank" rel="noopener">《剑指Offer》二维数组中的查找</a><br>[3] <a href="https://blog.csdn.net/qq_32671287/article/details/79420736" target="_blank" rel="noopener">java中foreach循环</a><br>[4] <a href="https://www.cnblogs.com/mengdd/archive/2013/01/21/2870019.html" target="_blank" rel="noopener">Java 增强型的for循环 for each</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-9-跳台阶扩展问题</title>
    <url>/2021/05/26/JZ9_Jumping_expanding.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><a id="more"></a></p>
<blockquote>
<p>输入：3<br>返回值：4</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><h4 id="1-迭代递归法"><a href="#1-迭代递归法" class="headerlink" title="1. 迭代递归法"></a>1. 迭代递归法</h4><p>还是可以转换为递归的形式，只是这里递归的计算需要改进为遍历所有小于等于n的台阶数：</p>
<script type="math/tex; mode=display">
F(0)=1\\
F(1)=1\\
F(n) = F(n-1) + F(n-2) + \cdots + F(n-n) (n \geq 2, n \in N^*)</script><p>那么将最后的递归改进为一个循环，就可以继续利用递归算法来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">	sum += jumpFloorII(target-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-等式推导"><a href="#2-等式推导" class="headerlink" title="2. 等式推导"></a>2. 等式推导</h4><p>可以将该等式化简成一个简单的形式：</p>
<script type="math/tex; mode=display">
F(n) = F(n-1) + F(n-2) + \cdots + F(n-n) (n \geq 2, n \in N^*)</script><p>那么可以继续得到$F(n-1)$的计算等式：</p>
<script type="math/tex; mode=display">
F(n-1) = F(n-2) + F(n-3) + \cdots + F(n-n) (n \geq 3, n \in N^*)</script><p>可以把上述两式合并得到：</p>
<script type="math/tex; mode=display">
F(n) = F(n-1) \times 2</script><p>利用改等式，可以写出递归，迭代的算法。进一步优化可以将其简化为：</p>
<script type="math/tex; mode=display">
F(n) = 2^{(n-1)}</script><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-递归方法"><a href="#1-递归方法" class="headerlink" title="1. 递归方法"></a>1. 递归方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum += jumpFloorII(target-i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-迭代方法"><a href="#2-迭代方法" class="headerlink" title="2. 迭代方法"></a>2. 迭代方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i ; j++)&#123;</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-等式推导-递归"><a href="#3-等式推导-递归" class="headerlink" title="3. 等式推导(递归)"></a>3. 等式推导(递归)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> jumpFloorII(target-<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-等式推导-迭代法"><a href="#4-等式推导-迭代法" class="headerlink" title="4. 等式推导(迭代法)"></a>4. 等式推导(迭代法)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-等式推导-最简化形式"><a href="#5-等式推导-最简化形式" class="headerlink" title="5. 等式推导(最简化形式)"></a>5. 等式推导(最简化形式)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>第一周LeetCode</title>
    <url>/2019/03/28/first-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第一周LeetCode刷题记录"><a href="#第一周LeetCode刷题记录" class="headerlink" title="第一周LeetCode刷题记录"></a>第一周LeetCode刷题记录</h2><a id="more"></a>
<p>1.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%941-Two-Sum/" title="LeetCode——1. Two Sum">LeetCode——1. Two Sum</a><br>2.<a href="http://wuyunjie.top/2019/03/28/LeLeetCode%E2%80%94%E2%80%942-Add-Two-Numbers/" title="LeetCode——2. Add Two Numbers">LeetCode——2. Add Two Numbers</a><br>3.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%943-Longest-Substring-Without-Repeating-Characters/" title="LeetCode——3. Longest Substring Without Repeating Characters">LeetCode——3. Longest Substring Without Repeating Characters</a><br>4.<a href="http://wuyunjie.top/2019/03/28/LeLeetCode%E2%80%94%E2%80%947-Reverse-Integer/" title="LeetCode——7. Reverse Integer">LeetCode——7. Reverse Integer</a><br>5.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94709-To-Lower-Case/" title="LeetCode——709. To Lower Case">LeetCode——709. To Lower Case</a><br>6.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94771-Jewels-and-Stones/" title="LeetCode——771. Jewels and Stones">LeetCode——771. Jewels and Stones</a><br>7.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94929-Unique-Email-Addresses/" title="LeetCode——929. Unique Email Addresses">LeetCode——929. Unique Email Addresses</a></p>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-7-斐波那契数列</title>
    <url>/2021/05/25/JZ7_Fibonacci_sequence.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。（<code>n≤39</code>）<br><a id="more"></a></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:  4<br>返回值: 3</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>斐波那契数列的标准公式为：</p>
<script type="math/tex; mode=display">
F(1)=1\\F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)</script><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h4><p>可以发现很符合递归的定义，所以递归是一种直接的思路。但递归法的时间复杂度过高($O(2^n)$)。</p>
<h4 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h4><ul>
<li><p>另一种方法是直接利用循环，将$F(n), F(n-1), F(n-2)$保存在三个临时变量内，不断迭代计算出最终值。时间复杂度位($O(n)$)。</p>
</li>
<li><p>继续对空间进行优化，因为$F(n)$只在计算第$n$项的时候使用，所以可以只存储$F(n)$和$F(n-2)$，$F(n-1)$可以由$F(n)-F(n-2)$计算得到</p>
</li>
</ul>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1. 递归法"></a>1. 递归法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-迭代法"><a href="#2-迭代法" class="headerlink" title="2. 迭代法"></a>2. 迭代法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            FibArray_n = FibArray_n_1 + FibArray_n_2;</span><br><span class="line">            FibArray_n_2 = FibArray_n_1;</span><br><span class="line">            FibArray_n_1 = FibArray_n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FibArray_n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-优化的迭代法-只使用两个变量"><a href="#3-优化的迭代法-只使用两个变量" class="headerlink" title="3. 优化的迭代法(只使用两个变量)"></a>3. 优化的迭代法(只使用两个变量)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            FibArray_n = FibArray_n + FibArray_n_1;</span><br><span class="line">            FibArray_n_1 = FibArray_n - FibArray_n_1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FibArray_n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>《最近怎么样?》</title>
    <url>/2021/04/12/how-are-things.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="密码" />
    <label for="hbePass">密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="c3e0de82f472701900a54ddf79f15a12a8eb35ba7261ef7c9443dcf5638698f0">1078a00ac6efef4a296ae3dbff2cdbb335c5d38c1443e44f749fa23b2d07f66b0625b6f6c3de706fb45603268858acc1d40aa0989add4f3f58583c81942779f2ed847b63fb8d535791837982cba872a080bc37df73cc34a6269a603231f803229967502b0e7f3c31078db1a47a2d39b8e95c4948905fccfba01a2666d31b0db50c2ef8810b556aabbfd7118164b581df1929e3161f6d8a169d12cff7310298894688a08098a0086d602523e41bc81135ab8f3f85bf9074bbb186c18c318197e2b9a7db7c2dc5f26ec0fc642f580cb8ef338827f4de3244a7356f95bd8938aa4a8fd2345bdbfd2f69be28c309fbfc8a336c86050e21c03fe95d25b8cd9887ef8b8c6765dfdd39c5c145304e6889119fbd11575bc23bd562a85c5d89e74d4209650941369db32d35ac3785b911860525def80324ee09e8e439bae24582e261ee974da7e4a00cc428dd190160139451f25fbc0a8cf15b98c7a021154742f338c1b47a6f2bd707046ca056f17bc09c2ffa7589bda127d542cc25b282d8a9cec41a47360f556f486383386b484ed6231ec64c38083e55000757b24292bf9f5ae5a501072ec762dd99e4ce41f118737b341d2a1a1629e1c0f99206f2fdd2f21c80b47c841aa91a6b600736a3181caebfcca9914df64a136aefba460be79546c02e066941a774cd1b83d99e027b60e137f915cbaaf47562a385f28995313b975c988078d42b0bf4a74fe7baf0c0fa1e7c0c345e8d635dfa207034927324a6c69159cf7ee277a2cca25ecf9065a5be8a157d80488e787eefa925766bcf6d2c08ee65f48e0feee0fe2425bdfdba8eb4f2149005781a0b8d2c7f0afa5f5bba0c32dd6e93aced9ed9714741337b1a5afb09b42cea450e412112a48662fd25b1dfdcf29d8c62faf56053236cf4f6828b24204aece7e63cddbf6af4cb4abff7b59d907b40281821822ad7a370b4e951877885fe74fd70e29d09f38caab63cde1492b2c7f82ca0fe5f931968eaf700250f71d6f33d14656037bcac118c72de6cc87d7e4eb13172cfa44ed7ead29d465f27e138879b711527f3deea2c62cb7c7f7e448b99b50decc84a88941b33a079b182d48a8d0ad98d074fe0dee9720ff0490b3c908a9d0ae6cd3bc738459c66d8dfa87df8f408c96426602f4758b552ca99d284f11da8a7b45f4b861d3559081a9a5d85af7dbd4b4c032e17a88ae33954ac94fe6186be488bbbe3a19fc649525180ffa5e638751b259ccd694e977061e1cf843f963dcd18330944e92bd1503f61e9a2c92f708f5429a4983068151c3ed534f38d5c5fe16f287734d32141ca934f3db6673acf2656faa67f9da0c5e44c2758ec8ee96948a3ebf267ae74160d4388a9ff922b6ff9bc84df7cbffebf00561c3bd21f80389e655c388c8fd8c130eae76e668c2ea9c10bcb5806566a5198232cc76184198b92f565107be7d83194121d00fa179be23ad539f5350d332d45de652ef6d45cb29c7eb8fb93edbcc72d569d01d6df481a69699ccb5d051d8b3e462486dd23f8bc8240286d1a640dca69c48b418a2e76719139829cfd9cbf726fa224f0effb176afc957ef54512556a111566e941ff862eabcca6ab436737fb4f77f8c28f40b942b9f16581be8f393543f8c89c5352bd4b0cc8c0e2f20d4bf6beeb2a9a957607a60c284aa6566f793424dd7969a81b6298363ce40be60eb772892eebe9271af77668c0b938f631dad869d8653e017bead558a0eb72f01cddbfffc7de2df5bb009c3bc83f65c3a05523198bb772838b46258cb1dafd26fc775435d702bb240371076a60a086eb362e6199d5580e79a7e51b91d56d76e5994a599d8717dab3dc0f721ae3061644ee6a3fe95eef3765f3b4440c3f7d9a6762bdab772eceb0048ad557027a12e24ab5f7d495b09ae4097a8780961845829ad781feb95fb2bbf671453c316c0e664a5d03b66a2fc1579724fe03127f7e4e4144a800a3c7f7549e5bafa3fb13034e6795dfbfc61db00f973effbc615ad3711839cd1dd83f496f0efea28d0dbd74b51dcf5bc061352fe1854be6346f6989836c82f9d2640cefd6153b92fe7347360e4f59e78f8cf9a8c84dbd344b4a174c74d3e4fb237d43721d5f41a907b7a18869f0b79f92b3d93f9373b55e06628f413101a12fdc1498c06f6217985d86947ecd8f96831b516bd9c8fb329713511fdb899f43d82de80495385ebc6a9a40ec4344239f6cf54d9ecf75315b751c559a33bad4bc2806e52825d239018f93bfe69daa8ecf1f78e90bbbcf15dff143a69f77f6fa2a1b90cd734b9644aaa08d01285548837049f64830895c1d8f14e1d794b93631480adce4aea0ac5415d6b3ee6255930f2e53c4c0d8edb1daf7480c6edf028cea27d39b78a7517cee0ec02876b8956be565a5acbccb0bacdfe052f6ca9f0619ac9c547b545846728e20d110e63d6ad147df21287cf8e24910a4c954c18e8e2a6027ee0eb86298a20e0094146d5ee4f45a5ca219f8d2e3e3ca5ee5775e3d29209b5664a16a43a44db3c82ddfae20654d9d0920a57196f9dc0d655b2c4f03975a26dcb7b8c0d0a34da0175bdce0e8992e27cec6b7fe9f91bfc7527b91f587bd85bdd2e917c1596286d05a18212155471be5d27b3bbf4d3bb987af8cd400c4764cbb80adb4406e79921fda76f85d91dd390f3dbd8d26a6005b432491e3eb3f5483226a0d7ee4308ab50dfcef3fe7207fd3d097b9e12abd9c573e7c04191ed0a1813083480d56fd6d80f8cc3f7cdc9c29dc442f7679e5947a56c9341f433c2fc9edc031fc93013e322c0d329c54e18250b569fa09ac496644e5e1f44d75f166e72fdcff6e745b27f39554aa1557899dfd380cb545aee7d514b6a5b324ae0c4143f2a1c619855eec7816b268f79c9d2f36348f90494f1b38bb9ffcb502a2a7ec96d5b2f7f6b961890ae3b49e8e7803f77515c34cfdeddb8f6c6590c3e972dc6dcc3a34db40c2274bfe25ca7911c30697a4f422a4d749f3adc24f55daeb39573f5b84310a3576dc4b704f9769dcb902024c41dd19063dd4f3bd17eced0a389bcbf761c5377fd597cbe3a90d4a684196eeb37db9574ced719a914d17588148adc45d746905fb8d49eb63416a1630f96b86a12da9ea34fda63e45cbb77231b6152e49c7b70f655824b62f17f2ae7ebd5dfeb6927ba96ca5cd5c9f453e758fb5c8f712dbb669e305b73f22d1de4f00746d7daec9b8faf49eb2581cd5f42020ccb1f4afce8c0a1eb1beec43e710edd4a71bbcd8c354499a4b73164910a869e07f27b72522fdd94bd6343cfec6089ac390f4f3f4ec4e4c474447b95cd1510f3f8783fcf0ff6468f098370e2084d1eed8de8cd23c6ff0d2f3956d08583738f965c92db0b144b3401c00cec2ac4fdbe2c12e4664ef4701e4428ce3cc4584ebf6e77bf2534da8dc705c983270c4d549ca278ad99cb916261b015b38f1368cadd1c8ac5708f89bd48fe855cca83cf256d19b98a4ad0febd7cee9174ae953c806a1ab638b1dc7e5e35e9959059d7b371433bc0e4f5bc7cc787a947caa78cad72157c4aa8f554a9cf95d5f32a9dc3bc89b56841959522fdb98a492f45fa91b28a96e60db8a08df5388d23712d878d7f1ca91869db70fec74d3aae50fc30ddf85d583bd2412bc3f0adce6f36d26015c35ff2237c7b8e5bea1e8a7f98d274919a3819e7fcda2d73143a5c9c7961036c88d62933b45294441bb4a910fc8ea7486b9d7b0f742222c5cf8b146ea49ea86a2e13a379129530de7f51648a42dcacbdd014faf2129bb7ec437cedeb13816e72d5509a823bdfcbcf3b2bda8ee571b63a4cdf6ba8673f5f89d7b55e476a49e7e23890e115f84f17fb1488415f03263e9d0e48122aeec7a8853d52971e01aecedb1ff4f0fa345abdad82f4e84fafa364961cc64217bf0b9ff8cd915a6447d9bc50f08ccc4ca583a177c0659089c3710bf634078664597bb804e4c064a8b6b94b917987b14ab404ba888867b6dce0a0151c905924800c5527687248ecac72f1a55665371deb15db9b25f0f2987d8bcb8067fed6dbef0dabcc78121c57c074dc99cdc64edad37f5322ace88f4b11af0a06869c9a655e045a089fa5aedf97f130023b895e7f7f19fa4d3f6aca638b93d45dbd53f2f4e180c9db045dd544e16909d5972dc11e70c59512a7f004c6f36921317cbd83144407c16e11dc1bcfe8de8aca600310921212a507ad47625acfc6e68614cfb4b7ddc4cdd374c2043f0bbb9a840489d2b32e930c2e43fadac3f645bf763a2721a4ae0c3d67fac73e309177de79bebb2ef2018d6fd11d687c501044e019065fbae3845e00b19d55709b7222fee7d38e1385b84ba77407ffe7b737c9c58e8d99069a586db0347807ae6668f1ff9e89ee706422d3c63280039e3fe6344ad79945dbe570d4e9adb668989fee7794da331f3ad8cad6945e8f88cac86ce1074d336eaff8ffa9c9e42cab20de5a7697673f0ad45fa234e5adc7c5b6892ae33bb8319b546497f174d5c642b549466465c9d37a531a8c0d97e9a2de8a55481d955f0c12d89c22e4ddb1a868ad6aadab9b091ffb0e911e60bef5b518225161ed55224829f83561ff1d64b7ffbbcdf01cc37ebdafd855f124be0a9ca9142640b68cf85f839bc7ffb0dd78a390cc24db86acb409d299a88116a85d382c17f6259d9df08a8c5b7a58ff15d8ea1fd4a7e4e92c893de6b85b932efbfbfe172d336f5282d9f9574421719c1fa3fa9baadbede97e254a64cb41e66cee7c5b2c6e1e8c32e63b42a68b449dba8d34feff2e872f6f79c9b82b007a0ca1b847a7ae26e18f395f1b7ca2055a7e6e76dc71f07c56ab1b1cfb01daf28c2a337cf45a149678e0241da1e409564e2da52d47bc7f9340edef7c04da56f115e543c03781a68d9e82e4b38dfd78d966a1d040e9a69c64976906cb418b820694290d755283852b33274db6032c0d1ed65886329ecf7df9017dd96a8f4f6ed23f1b9872824567ea70f006874353a0ddfb6800049700ea074369722b51e4b55a3a6e0a6c32e0d41a134dee6f7539affa0e5fc4885546e3d2e42c50b40261585af58aceb490339fb16fd014dbb7d80e4f3bf83d3049ead29681521cf0cf2405186065e70f9dd5ae28bd0127bbd3305c86d45a57d18eb824405f266d6b81b3518deae9a4572d3c3fa68b592776216ad2efc2851cdc5ddf097cdb370116a3c443eeb195511a2ffb2900fa031f7de708d2b54b8eda2333beed130c5087234072bd9a095d50d6527125e9fcc283c3ee5682f53ce527ef597894bed7b5fdedcfa3f57ba54904203b1cc01fc8295514bba8f75f41bfdc54d0d785615321d4e18e9e5176e154ebdd4db1efd13239488cacd3988d7fbe0367b23661743c91d6299af62357d55d1ab141d3d3a662a1d55abc95c7bd6ab3221168dadc24a4bf1f5e010d22ca177f580a13909e563952d9e8a1eb5e01341aef03e327aa17c9263ab1b04684da2acd85815444fefd5d01ac1b23180c86b35c8b3e99e9c350f1780ea00c431362c9f2342cb75baf63855c6167083f4474d3bf09d526bf419f919790d301ece038dfefcf76c5769a25c3d81e81844771580cb8afacbe876f5bfce786c3ef5cc654571b1d32323e04aebccf441a2faee6e2d7475f15ce954bf1740f708ab9cf231dfab61194bf37f22a2c62dd9555f9791ba3227ce3809123eb28e9fb49e391e548a069f7b5934e060c1f08339003ad9e26c53d03d308eea521adeb2ad965a713a2fc57b2bdcacdc92dd5a0b6c874bd4b9443edaa4d7a00efb8a1fbee089fe9c5a41f62e105b04b3835c200348a0dc4ddebb2f0e599ca3e39446484d3c55cfa41081200c32ca76de9117c806b470e30279603ce3f2df0aa01c7377ec9e2877f6e9737802eb446883a2ecf914264fcbbbee20cf2dbd20a9ab02ced73f364688b8a069f2b1dc0e09ecdf1f85b1ccab00039f38d65070322525e60e470fbdc37c222b24a128f61ff8f08419e772cc02ce4cd94717bc0ccc478d7b8fcb2ed4b4a79e387d1a821970919725cb53df400863f6b5a2aa9a6c1850f0854d96e4508cd38b897ed83e7643a85e836ba6db6cafecd18ddc85370b88905b86a40e3dd24ae6c79795634c8c45fc1309b0ac95dc71f68af0719e06eb2f0ec1aa3953061b2053cb492439752733e37c1c0fb435b97266748cdfede8c6eb7eaf8444aa7c6d1f912a26605d82c955e299faa0b8367fada1306768cd8c282350c1f959dbf9fc54be0ab29b5dbaa157cace6540d852d87f0b4fc98d9e277cf9aadcd227e114a1462169e29f6227f24292990ab57199560dd67f53f15d50506562fa712799e7c968127c17c6cc4a12f5a9ea626f2ea7fb10c7178da530227ff568609294618679774fa7335fab469744f5a310f8cc2e3878b8b4fd4946546e873193ad34af2e9e1d8ecef26b5e237fdb587e063e9f4f7fa2d379420621ca7fe7eb9e0cb52fab7eb77b995b2487d640e246d46575356cbd11440be76b41a2ad24da903fd546559f62ff3d3a86ce08ec8449abc71d83f242dc41e26783094a9e773adcba9a636f1aa972253921ff4483b5cef47ad51ac70947acae3fd24bf3098298f21cef34a0fb59c09f4644e9e3499041f97b4c7a0c50df42e6c3d308767bc0dad44eb5e7a6d7b266e75f8e64998dcb7c0ac4613cd40bec60c110501cc34027c6317f67ade6f7e71e8d4a333e9b93ac30c5ffdf61646f41f3a374bd022f0206066e623bdf89fb055e7e9859ca7f41f7e7e4b5b401f8d2771b9f8197b91d945958e63b936b098794a5c2326c7bca7909ca124f21870e4e196b41da30aaa0cd620c679ae7e9a3f8b2da4cfc287dde3812dd8898a4b47b8e58fb3475b7242e4e80e7d58fb15d48771a36aed43d20c6d8642ffb1a89b96243d289c0e45d6a188ff0938f8f15bc0fcdd7486a585da8108357e66fd23b54c1cc1a2d200f0a1749e1eabf03afc9865f2987a8a916d1bb682a064842061cd817134714b65677ef020f21baa0b32365efc6a9ae1597f801263c64a462560a7e6661c69a3ed3661770ed187f7ca03ad03b84eba364763139d2773e02533ae65eca203a8f4c853edd04c98a927f170712bfe561694c618e1be31a0bc592d1d63f013f8a0f5a075f74856b23c28d53d3233b878332a5de9d55e33c6c10f0aa74ade2bca1cb9ec38ea8449bd0d545cedaa8054a38cf1b221f27c369e70d2737454b6076cb4e3e5903371f3a195a77990caf71b975be32f1aa4a8fdd4e4941557ed5aac2e6206d866fe4ce6efd3e79f3b33485898a907034f7dbfa6070ed96e5d5d4728f5279e63d6bbeb5995eeb57fe76f2bb5307195c7cbe2e6ba3af21d72179eee566931d1283b823f19e6f756b999858031d4a7d4e98bb9585886b07a52dd9b0b81e91546a925fa4d1cbef8696f7ea3e4d03be4a2fd7848380a4c57c863161772544607d8930914cd7df5df1b0db3913641f520ceee90d47fe60a1026ff7237a246bd93e9adc10b481aefa0f118eee012c1434ea6cd2b186fb7011b20a9fe93a33630bc002398c960cea9bf767d2be9fcc6c336210478850cc8894e988d24f70a944c31a601e58164dbc951c892bd572b10acf7c8fdbf2b940d473356b83a6baa2bd013d4a0c4cfd4ef4488ecaab7ee106ffcec74bc91493b2a9d20589d7c1ef51f3e2c30e04b1efca21a4e35953a0a6932068db9a167e072d092490c624e95871a21b1b0c948ffce51228d4198c54029313493063afdc24fa7f32232de91dc95cb5182f48be4066f27de4911371def66f7af3576f088131880541dee441c581c801b949b0dfdfa6d9f50a4e3a7acbc1d37ad5eea9adefc11a98e10c695a7fa854a443ec5d894473027b6dede3569efdbba637e2aca5ca8900891b42e32549dd8f31e4f3d07dea323ffe9726ccd3c87833759935a06437dfe278b54e4dd9d352cb3cd68ee7c7a947178dfde434d36be4aa58231503b6e19682d0999d0a420211efb25b9b318be1e0952285675e059d6b8e49dc6b87ff820c6f445b44ba3110015e9c5eedab9661fd58b0718df3aa74be04af0df185afe7544fc8050cf24dea1e5977ef21051897a9b5b1415c4b0dd048b6f60dd770061b75d8b20938632ca3625c4c7a3fc1e51660e6d5067197d7a10a325ec493c22ee221020160332e91d591f339bf81e15b8fc8f3a3c3c28e11ab01f73e07b6a2587be97b821af5ed96169e6b6a7aa6f96afea8de50e40b4cd677bd3ffc5bd6074dd88a1481e5f19f236af4db45b9b65c0fee88ecb3d30f70a7b4dff9a51704149f1ee5ac5271a28029535bcd9740c23e34e385ecd48195abb403ffc483d78fe2412ea2265737cb4bdf210d0afcea047b80054ab14dfccc988bd5bde9d843b3bbfd9d39ea3d7549e4939e6114deb4d537d075a27a0b24615d301d280986500c86f1b464c5ecdc35f875bd01d15c3f04583b75ba330f0b79d2c04856fd0809fe3b9b798a86af43a8962622b69f49a9b59a5f29ac4c61f6eb57597880f7950f83aa8111d4e96fab1da2a7f2ab45a5d991d32ba400e220bbbdb15fec06eb2d127b40f0c4ffb1a1c08ab45dddbd2f5a3b6450dcfcb05d4774b2bda7736edb27040bc0fcba72d060b78f25e02ee3f7ad18b9d90af0354137acde27f638f08e04e5b8243ba38dc7bc800a3e349bb6ac4eac5c37d0b72e019ba903bbd3c55573b660107347d58814b907e857ffad2daf3d0d6f10ec2efaffbb81a959fd14d2d8adf40e752c84a32f5915581fce10b2b3bcee2d47a4d140cb955036bf59967caa4d4dceec38a853e95b65a126ecb72c4d65d8fda71980996c42c9caf9bb6029b6499ff63eaedcd602769a3c26e96d9dbe8502594ff8c733a2ada2a5b4452ab4d2a169c9fcd9b402f393639ecc2b1631eac150e69a10e218b4207d0713c6f196f42834252e42f9ce8297a99ed0397de1e7e500b4e49d16b808054b427c5db46706ffb2c172af0aea52b8829f25d240ede1744b8f75ad736194d53af0a7f78a573a873b2f6bfe117e100cd17d5ef061ac6f2892e3669d50e6141d2cdae03f7bce65a9c8252c5c5f05684c37d2d4637d66547951b0ce455f9bf6b1b9f050b96785a3796005ee6eb8601a0621d3be9bb9f50291b5cb7b3d3689d56d4f7e41437e2b1d254b7cc8b7524fd77f8d10deaed39d1d208e5a6eb1f3efad95f00096581a55e3c41a87085bddd22df69082cc52606b1bb7c1c80aaf1d04773fa14321e8d6e3f9e892dc57095003601aa6fae149ed3851d3cba44b526a465cf8f9a24a5a8b91f0057a450085426e9dd55e6d9887eba0f91dc477368b229a31166b76d1f5a8dc48a632f71aaa44f2a2b5e007888428bbdf6c50ed0ac00659d41930cc3097068b0429f38951ef8445a44d3dc34b1ecb2aa09a01fad0d7873a9ebd69ef8f336257e15647226e74e043e8bcb44fe6c1388a5e94fa86af7f6665728bdd16d6d9e7f31a6de61b3a2edd547a3d237116f72b1c84ffbe888659ba9adb23f362275d11d5719f5c32c95e2d0bcf02ffd3743b50d91ee87314001870f9ffaee56fc12ee582e6337eaa1edc35ff221e4289fb3d15675b9529064757a7a2b14d3d29940af76c03c94cf2b4ead1415c10863e2a896cdbfd33498fa3e6016672ad85a1b81b9b381013bccfa140c7bb5c5b709a2e78d2c20c471c8a9c22d9ae8625316d3d37b3b4e93057ae694f4d5dd018d21842a25a00e1abb9f65988f4af6dc3f0883f4237ccf8a53d4d83c3ccf9ad89c7b61f4a74303d0e1935981ff9d1adb3df35e30e1e40b425a64f00ec026e10d54e56dbac00bd6dc0f9be0beaf9b3aeb6d27d9af4fa4d3dd4ae6d7604b3d24d7fb534aee29f4d724840057ce2a3834b87e3dbd4e77f55fb7210ab6023a4d2bf88922cf051f8b291c3f7210a6fdaefc45f73e22df110747fd2ac2ae596594dc99db83563a2b9261d2b03238ded5b1b5e764312532d774a831d787758c5ae446ccbf6753769f43e3d1a4c9a4889a1e84c2e6ca19275a4270f52625af7e03120dbf1c5da62e4da5845660e08767716cc4ef906f8862fb2aa5ac613ce66ca1ba7a6ea9937b7861dbc4fa817eb72644318e89cef6d27b2b976138e0c2df6b3759bba4340ba1c55df6caac13af72b926b7f317ccbe0289dd11104487bc96c9821341630a29d0034707626517afbc221eeaa0fd2c16a4b92270bebe61f65cbb0ed4cbb2b1d8c1e904cd93cb27d6c540627580474a4528d76f09bb6bdfacccd976288ba3268ca6bc7574fe45939b83bdba9a5a1b0292f2aa959a10e5be5160726d7e8721e82162cee431225027ba9b5135d661e838b5302f39ab6d16238f4881523bc6bd4600e76d246b97d6f34d8a72cdbe6b97407dcf2b21139423ecaa0e71562e5231ca01c2e80cd7339b43c1ed33d36a5bf5180ceeb61bb930eba21afb92298309590ede465f8d1d462321e23a1b8f24b65d5c9fdaebb64d5697e48d61b03f25492aeccbf5c43b3eb51eebd56b602c6951d0045d0092786255bffdee0342ed5df08c34d3e2f19b5393038b1f76bf71249eb51560f9b694f3797858e0847ad62df4e0dc7de811a09e10a441a7a5d4eec206bc7721006c77f18eb69f918823bcde323ca89e743cfa4aea0fd7b5fde8cd44f6256b656be52659f11d67ecc459be85017c46b69f0bdcdc2dfa618743c63dbf0c25286e4bf9524913064e48a0fed16bcb4c8e648f2ba0f1cf198d00b44d8f96e57b5846f55262384984984946c4fbd85c8738dea5292fa45615f6792a0468a6b17b1d6a2009c0bec6d1a64c3a7032fe8ef8ca95bb1a047b7cdb1fcc659e61c56a729f1ece8f42262fa596dad005ebca7485e80036a2e047eeed2f2da53b2021a6ad14104da89c60921bc093c8d90cad34b9283393bdf50f994daa71082925cb0773f5c0e36aa8c73fad8b99f8298dcf72721dbe59ae326a3aca1f40585f81f143d999a56dbc87f0e5c52347fba98127e637bdcdee3b037044f2ed901c16f2186989a786960750b2ef351ab05ea39cd46d686c474bada3bb964bcaa2ae406552d9f0bb02316e149a6f1f90006db6db341c9b93193129503d9413d0fb9607101e3abd550b3119603de247c8e8fa13e55c1edcd2c0adbb976440d2bcbc861fca200bd295021fe720ca79c666f9980a21a14cfce37f5e7e328453e98eb22980b60219cb5ee38ec933d9990441262616143039fe1c76d9d0c2461bc79d3efabfa1d049f8e5e8982a4d4afbf1d302af95c312ed98e6c2f39f6be9cd94f9399102d5816b16ee3275541a7707b61ed3f25dea1dec24e7a683254845bc9d1c1c07d34ceeb34942b101a039432a4e0e6cdfe7fc3eee427e8a9a46a43901d09972ce1dc4a72f405076cd42d98a0c912b7fde24c35164bc4a7a148f83da495dd1daf0c8c55a66562f78fe6cffee0a0fc783e9c8fd030b30e6a8870a67d302a743a46918bfa50bec72eb36bd35c495156b1274142f928c99c2268164e02525667f4a5d9a360f6b00e52fee28127ab02590ea7bbe1bf7f92fb3a421f8c6de4564d59aec4ced8be32b0b3f8907f46a946d7556802a18bbbbd6f0699893a2c67b464cb39356c503c43dc8ce3daec9684213a02d620f0b59fa1994c238190186261535d0f6221a76752f9c3b2aea9b5a88ae587286c0551fa5a40173d0ab90aa60cc021dbce2a83bfeb3ed1b106077b1a9c2139c4b0d939d373bb63b233fece3fc2c7283301323ad0d3799dd72cb72391e6cd61ea7545f46045de4cdfca6bec8f36b3a2cdaa2e0a714b616341e85c5db01694e98a231a4a9cffdae3e20cb4bd54f0f2d9ef06a137af7ebd9ad4a9d834bb7b83f0dd7513cbdaba7ce946374be3c3cf276c4e767d931a97fd50f8e368ce2221f960b2b74b9a181bafdb2c51a2fe1474ecec24e59c93ac4e64ddd5c609cb38cf185381fde5285234d92e5cb65425bc413f0ef9a37f7135799dc49c8f094e82983676700636a2ba50e047ee012228ed7b049813c78f98ec0ebefda1d5502458c815571ecb34210c62fa8bdf1edb6ed2970215e60b0a80da1f5733ca3629242b11091d82dd2f52dfeb4fdf094fc4a8c9d1fa482e313542e3fd173e5cac052604058e8844d71927d4cd8a408337c2328fe47478e81af38fa393ab0c3597288e2bdb31e5f415d14da02d1d1fa5dbf3cad2644791f1ed8d29153a6f03e07cfa4487deb785afc596c05bffe037e2c66a4f144ceb8b44b1d2cc7b6775b39e420722420a4f79459c2bf9d4cfec39106520db04a161a367799681ef3362c4a90ab6c55f65571abc5507ef6ed594680a07841c54023bc74c40427476930552d000dbb7647bb615daa2eae5e29cb99f503db8b3b38b648593113e753610347671553075e126b19dc29b20005e4660c63bba9c717cbd9d7eeb6cb19e22a6e8de29b07af8b6a764449ea390d375a198e1587ccbfbf5a465bb2df058d095f1d380a2300771636c9b327ab0a695067ab45bf35bc5af4fb52ad3d4afa4d24555cfe1eca2dc1f837558ff66f2ef4a3110e661013f6f27f0330e6cacc281a4d9ce873f0b63883144bec75f4be61da6e017c6cb93fe66f629acd4fd2f8921541faba05e83935e2880d5f7126a2601c2010330f68fe75e5bf31177aaf5e27b10c00809a08606f0568e28d46e047ef68f7c469d4b1ccd0899a3de23d6bab94505fac91d18955357cfaba16925f4df78c05ff5838b47372be294c4ff146923b71d5335aa4ab7b893f303a233a2137196889e61882501975183143a8bfd7e90ff327365cfa87aeef37fb630600a21398000471f7040c64700a9bcdac4951485fb7b36f5a32621cf6d58b58854d9ad430ae99b1ac1119f1130141327b74bb0dc7481085a474568715d3f2bf3a8968245ea79ef2a2d42009127c0189b268461b302af9b9a930aa5f7364fc6c36a43527c12a0bb6a8bc6bb7441ba0b7e68592b57d353bd99c34ab92bd2c0befa83e7d5f81921c81a93087f7df003b290cfbe23393416705a0b3db6eee9507ec8f3c2e378a724f49ff4ff374958827daffdc8e0f576d0555ec2fc4d74bba3ac5d97747ea771c8e882b08aeeb71a0d88dbb4a48332acef25077c58bea059b987324c18d0e7362fbfb476400c56d5b4c51b4d8890ac8a7dfcb7f6710d39b82a236e3c37a04740f98c8355537b22c276bab7ba9dc4342a2807ed4714017504f58fd86aa5083258aa5269304f780be3f9e004b4e83d69d91120ef09ea216654ecb3c29b5b1d4dc219d9394fad27a749303f4f2aadf2638f47b8bab62abcfd459c6ce89ebcbbbf4cb4f56b54bc66b615494f20346ee0f3e91920b0f6fa377fdbd166b4f0319dbc3e8f2b6ca3032cb5f5494c9713d93f398bd1467043c62debe0ad6e17fe2ee738d2c147d4e4a0d8bd9f19ba9856397bf79ed9fcdaba81d66cfc10bf23f718c07f541540861d317c5816fddcb14415ed256c32af746dbcff1f44706d80fad4eb1b0b88d5d5f827bd6af4ae34df0d513bc538aef9db3889c0ad4aac6dd44f5c3806377772f7c40ecb4ecc2e719e1f6e0f4b0f1c500f51f5c0b41c4672e16875490cb3d53e779c8c2651d177f0e620e7d2727c24e3fe5fa873398eae889a2970984ae6426af7c187d90731ede601af1999560eca2edc70a58200b6c16d6686ddd910867b01182431a6ad5e82cdc7a216dce5d8d6b54a3d73ede582906a2d709fbc9652eb5fd3481e07e221f55f8b3b37f592418839f20e8b27c5ddb6e3941df108167f9416938b3e72dddc5c3f444d0feddd2538365ea3646da8a7b67d918e1041f6b93e85cfa4f8a2c4ae4cd5d663e04f447b4e792e6ced5f1f2d0fed39c5c924203b221dcf357816a846ee8a376abfd1d68f9d5071f11d93fa36bbd29f73368cbff07c084fec17bf102c966ce8efafa013be034be08b8bcb49c94cc7119b3c9debfae228011ee1c23c1e434243b8ae2141703c4931798caa524c89edd12dcd349eecbebef80e748852c9de09e778e45b70969054179db8313575478faa0e862f584aeed9fb3981ede8cfe4f33fa1e523d08da0d215210331275fad00598c7c33ee77fb7a5706ec7911de5ca4583790bee1840036294e70ea843fc9b79076ac8ca5ba1443dd87c35deaf7d1571b2d35249b4b8b73c9dff1f80159df7febe5461fbb16663bae8ad2a1d4dfeab137c8791383fb63424af0084d02f5d1b3b1e7f2fc66dad1d9e2161bf9ebbe5422d2c4876bda0c214249d448e5f4b5bd5976b53813b6a2ce9613bcc25d32e3f1d5bba118cca9b0f9165a6643214f91913d91d78105e9b4e3a7b9b435bbd4e06f393248ec08d595907ea3a6f2de5e8841d96a2a60829bb720efbf46223630d13418c9d16a685c9d52b1a70e41052e10f5445ce48c8a4aef4a5893dc2e0b9a684bb6647896e4a73aec1b56e9edeee85ef1418495c9f2a5ebbcc00d02cf7334ef134d4645287077495227cfb2945a014f5bc4e938f0dbe1c0e74305d47cc81b413679ad72ce4296e35c527c90c4a7fe317cd17625107047c38e2abff5cb1be45839727ff9e6a0195b0b90859005b2644135db4f25cc2112c4a238f4352c2377356dcb5fc454f3832a960d7afbf0251959a7e1cb4f01aec5d90dc69faecb355cbf41acf674f1757b331c0e31e48ee417ab84057e7bbff59b1782b3e7c211cbe97312779fa1d25a4879566eb26a1e7e97f08e29d050347ae05ac485f1ccb5dde688eb1b075baa466f57cd3bd4ffa73bbec0d1a50d8e3d37281e56dd57762a836a57e82faf5bbe38b10e6b1d7ee076291858eefdf3889dbf55267e35165084afccbd09e0c9ac290b72b0fbbf27a40b59e58660509f8077f33f7fc1c5603e31cca3b98dd7064cb465bebf92bbb963ac5feb790ca43255d8d5910d6f7cfe3aa92f9eaf007deac95cd2cd9ae5c2f16ae0abcbc6f1e11347a25446b9ff63639f798c62c76cd23f627f8b010a7df77a866c20f1cfe77a0ec97bcf840a9d447682e50de65b9d438d6b69abeddedbc5a0be7cf56a8d51f9618ba0ffc9bbf9cee8376b1c33bb0b83543525e1bc68547d32327e97474606353a8d6fd4b1451665c04e6416d5d5646392b463bf24492c37fe919c9d583e12309d5c198e0c69650d39078ec209c372952a925033ef556ba8a60485b83e21cff450a5dfcef737e5118e748371be3b9003ffe4cc56b9ba9f0e898536b11c417e45a41b5066f63d6c1b31899e0985c5b85c6566335f8adf194808dbb1abdef866b6087345f81fc0b6d41b45ce45d724ac0e8d3892ae9dc5283d157ecd897a28b14041939da671f1d2abbf74ab2e4283fe95d1c44d3fb51425288c32140dea459f8225aaf435c1e86b23cb13a4c8f5ace35566804bf90c02cfe2ff530cfdb84b670178d9be867af2986175ba120ee58fde6146901dbb0e20b1372d9ee16028d918a0ca25c51fe41b7894a1d2f96a267a0c90ac21970a59b85c17a2bcbcbc230cd2406ea91e3d0657ffb18df1e20503f40e24938f9e9a870acfd1925895aaa6cf8d8fc82b9f5a346ba2d8b8187b5b950a24c5fbd0eba1eac20bc2279ac8994b024e5f7b330d9b7311b9bcde8374001a9fe311bb5e1d335cd8ffab613ff20ad262c369ebfdd48caf7754d11b2aaa8087acdd597f5ac731d7deaa447214538f622504bc54692c75a5ecfd2763c7e40caf551a777161b31aeb43e1b93d125ace81c4cbc40c6e0fa8a6377d9993ca1092dca15ad6c8a30f6324e26ea6cee5506a60e9b9ed8fd1765f4123302f21be605ae5138c96a89b2c61ea31983c4a7b01945108e647cc0b1f43142b09adcd6e9599289434b73d554316d91286c72107578543e6f74351f97fdd2103b2611e1477d442fc7368a046f52a519285e2796011ecd84a433e4eaab147df1843e30df20ce5f77cd04349b4b6d3946e3f8a7465fff1965ddaa8fb07752edebaaeb8e1e4605bdbcf9665def535fdd5ade1a0261d144052694c411f7e208f6383a511d30f821849ca0a9a23c88309fa2576093d161fa245dc074db5f29ff9c62a9754e71e8caeeae56a5bff4e12328b46bea9d59061e2de18979f71562d2d8f104658bf3ddc3ff819a869d2a42eadf2bd25a1e71a6c206c3c30363df2775c38af105267a952c62993cc8760f95fccff710f2c3fb172817e735f8c00da8fa5cf872ca5a7a7a34a879a14b1839fdaf03f801a8c40d18e10993eecfca6e055fe1306db117423d24c1cc421424eac59332a73ebcdb25c72cd77975fa8c060c676fa50f0fdd0503473efb4af253160e1fc7a12e12870b3b1e1ef15137ff0bf6708f84df4c62aec02b238d69d9c6080b2c4d9d6da9c4de40c58df842c86cf8b0c1a42349d90545d504ca5cfe2a4832c37d800efe597a66d8579bbbbd9f83b8b16d8c56b826b88323bcb3956c059d2d1962e63cb522fa6005628fc41c43277aae38fe02df53c22b6ef38515105523d54804ea1580f5287d18d1dc146dc40c356fdaae651790f340762cc3c0dbe5528e63c4368544cac8f0a77ec75e092f87d54b36a509237a8b7764f7d7462e725c9fbc2342984132d013cd72dc815ca53b40535669d9e3e50d5c9bdfb1ec474bd32c0379a69c288e4e214f74aa73411220974da79625b51d782df8c2e38b44cf042c443870eece38e4b8ec976b98cf51b95103e324dec09130c473cecff1783901dc454676a73ef332f5ab1b49f2a087035307824b09cac7dc535725e7ae5211cf9e5ae02441290f78606761ae8893d55b3f0d17d0a6a779788476e803c63420fbe974ed715c3bac50a00204708cfc971f27ca7c7969560685e894423295feafdba82597feb990509534dd995fa8cfff2ebb28570d95ddc454cfd37a92be83e467c93c02a8ba7a5b8c08fdfff9d743758678b9fbebc5f8954cf532342a326bd906bc522fb25b40d5ea761cf09fe2bfd1a17df7ff6996a396c298487e15d93c5f6c2304a293ebf83d2f5a5e3cb45aee093e61160d00cd8aa7107f8bbe0ff716956d1c301c7b86f9b84388445755c9620e5b07aff164092dbf9c6926cf9e2bde8af51e9826d1057f6c28dc6297b664a969925245c3009b5149a976bbdd0ef1b69a745d8af7cf0790ea6f1f7e2c458ba5393f0a7a2330fc007b9bbca8adc37efa9bc02153311d0b7c9347644c34b113bbd25a9740440707a8e607dd43bc8a7c501f40053374a62d1e35cc68e4ef4a6f51ff6530f53fea79ed828fc96af3b0668cf87ed9151acb9d7b7170d59ae12ba774888e3493ec6a39615a4db3000332dc564bea904ed963a976a8ffc7acf2cb49d9882a424c283d0f5e3069e511ccee27847d722272f0cf686e645f0fe931a6cba505dacd8d96fc47caafcc177f4760828cb2c46dd7c1bb4c409d77501d6c8ce8803008aac484f5359f936c204e7df7be9fc44af493bf0d2f449bd1316191a2fd31a3db608d788b1367fce828e5e64cc8306347b8cee456ced9b0b5568e81b6d4b8349e577b7435ddb78ef3dcb72b553c6e56cfa39c4dc87456c90a4335eaea10e0bb2fbd323ea2d09527af18dd64e6ced2fb5f2d77c7c57fb244f9602ab103023bae33d8e8f6a5e8f5d347de67722be0825ec7156777f6c73db43b0f3e43b4e814ad8c82cd0346581f01d7a6434f4edb204e820ebab56dcc439a6a33a9a19861ca4f885d2f4c0463b6d69bd186e6bf1317b2d61d013b5392099a0937239fc3991564642503907436ca32c430d69a93cb86a38dd071e3592ff55dd6d5d302265be44debac01debefc2ccd569957d80fa0b0864ccb2a29841d1db981f54d527fdd64442facf39e98b276c380aa6f65048fd1aca935233aed0587c37523e706880922bd93dbfa3c94ebae91ad2d8fcd86bd68fe8b70bff2f71d5ddcaaee5f0a5ff6d911edae92a76cb2a7022ec9c8246346c46ccbe63e819d1b4a4bbff8d9ce997e32286a9a559362c5acc323262c6896a0f25509610f0dd8975b2c00ea389362ebda8a09bca7dd0aeca411a21311146399d7a72fd97b055beaaea3bc68863062dd7e4ae405ba62c4b4f892066f67a9a1a1997dfdc5ca6b9dcc8d2fa774522c40d3cfe90478c998813f598c1cf6f905e95bb9f07c032f224441b361af4ae1670a88b82d10dcc7074df1736cc43dff4575a0cf0c0bcfcf2fdd424343a6431a6b94212c595367b7bbdb3acd13d9de2aa75aa06baab8581b45d7d6418677977a54c998c782080a15cd59c97585494187121a0d35c2d4fdc78f882a2e5bd0d17d9c9d9f12a4c08c1e7018b274717e06833c68cd682a7b1e4576e359dedb3be4cff35a6936ef867db0c4f9332204d0c25e92088d2e2e986127f183f39d112ec541441c4b84db5baf9b19a8582754a3053667b73d2274dddefae84074a3229df5fcfb78ace82f6cf19991b5b37a8f5f0ef117fa4e08e2cae823ca2363f5434cdf285eb69db4c8656beffc75e8c9ddd2ed393dc1b0e7236cf36a2bf650fc89f8da7ab5c4933eba784d3ef0e9b7eaa54bcc91e61a5d6451cb83ba5fead0900d97b8a7b58d16edab50836b665203efe5473d7e99d54489c7d772e006efdb0c0e19d813905ac2b646ff3d52557c2cc2f772f415e8875742a01ecbaca1a6a497550bd7c9235d6d71ac2a773365896e5f4a7c40b5e03c8f28a4708eb56068f0deaad26dac6d4004d99e3fb62215f4d604b729e2bd7f7c81223786da0e93f37bc9b551e90df5b0fe352bff7a63747f28fbc1096b697ad53f46fde1ef80ddb7cdfe98326303780a45150819d2f7e9e5c8b48f45cd45cde02dc2c6d3a8cc93bbd14727d7b671c2ed6d8618df6051906c3c28190095de2e42cc4f7a26bf235892dcfdee663765a342911091706690ead81b03dff66633ab37ca5fb696ab4aba8cc9ae0ae74a5b03b69a2672a97fbc249d7b03151d919907b4056592c7a83bff6559ebe0105ea6f3cee9ac6bc32dae56d5b93311abd829efae71234749b0e122c7432cf3c2468ba9bd986e67f9e364e4de87072f2a251753a7c2d7eea2a7362ba94a8f157d563dfa3af710aa40c350f4d925db2a20bb5a26fe645f1d4570efb0137d23d09d38a9b1c9735647c83f9c27a804414fef684e9dcf07ef072a7bed272ea43642708c671e5adc5d93b12424b0ca5741733199cc93e486729cc70821d9952a905ad718d95177144494cdb08ff66e9231bad3baedeb98b87ced2863efeff031accbd023256a14e149e4ac3728883c3f5545c9416182f780a1ee120b09e8c9f7636ae84a024ecc55f1308d88c2b39d2306f2f5f491e51b529d58c3986bd20942ec82023b7b0c1744d6aa0c76abf416ef7f4e12f3dd6a18be843f3213b82dc27339557c249e1b4011dd9e69297a3773c97f5efd863bcfb77af3c109d886917fff58530a1b8cf252f05a2e315439356c51d445252922c052926e8c36fc732a26ff658c19ad650f370a67c748bb941842211e5225e81e828202b8361288106c3e08e685c77434118793f32827e58d249eec073980977fbf1828e6dfa6c34f460f998e598beb89554a9a24e0235fee11738c5fc2c220b9f4f84e1f7c117a7cd7b4657cd9facbdc2a48c021ea8d0df865a6344afb6ad3fa398231d2847b38a9385ca3de173694d35136eda81344f4826668bea53e79e22f920d3483ece459a88f0df41dba7bc23d19b71b7f9eb9c434532ea535b465b0e4a4fe855bf387d7938afe2826b71245807104142919be1c35f0b9fef113cee5c49b6fd15ac4a0b5b35787099473b0e2d628873082aac1fea5be76219bcff44dcbb5328e0f8bd3d7f83c9caf0117f9309b556440be726fc6038aa05be242d52a6809c523db68b8f5977dc056593b94d0b3662741f677f02c41e9c5ad63ed0102eee996a507a17b8597773c0f1afcee19a1eff5cf233552f14ff1746878f181027bd5841f3b5fb899708fbcd9ef72f5cf42032fb5f4f1501a071205d93960c33d892194d4aab813d526181b47961cf093d0cebe8fe67ffb7e489b302873b9cd26b7685293875080314a40dee12df383e49151aef3017373f2f71d74caa9b64b71bb0cbe61de51899a377231f9f435a03eb0b68fca35cabd2f830bc60440063ec120a0be6302e1cfdbe3190053453b712a8b2d1dfab9ed2bc2e515c47ee484f8f9cdd8e9cfd7e8417d87e1e68dd8d09816841cfbafdb003323dbf2b0721af4e2d819f1587f682d581cb2a1ddbd2038ed1cc5f3a6b54c97de497e89d3a45052da71ea129c4928474463ac480273efb0816d26dad5c698dc6ba6ff1e1f7ea1248fda3f748218bbbbf8ffb77f045ab332bf69aee2d6fcac6a591b4c8895272bee7fdb37da4406658d9315ee0e5439f840aafc15547cd68b58be561bab7d241d210edeae2b30b9ccd6fbd6009cd4b3cc2587f4658b14623da7fa924580de3b7433d4f3b7b249b2f69800d9cf6b464b92ff0d3cd24e597a1f1e3f89124a49e4d2c4df60f1075b9fe49bca413e472c1dfc78716e9e31f1054c19f3b39b8c0e4c30370238fc35304d427b1c554791d55dd568ce940c7d2cab5c85f87c09df7c95198862e34637e30abb99f31cc1ae214b40850a648fda35f2ccfec8049d8856c6362941203a2f2f618c10c46b37401f1f864276de463e58e99d8c7c732528a400f240e7fd9a73fe84050c149d1701dbc003925cd1c33cd5fc701df3f46f0205bb3a4a641a3089dc832271629081a9ee58a9efe168a6994364a2c664bde0a423eb1df281eaa0f3ea26773709d04d148c45ba5064d1bdeff1e82eed64501fec4e0c35c4cbc8faaa8dd7af4ac5eb9e67477cce691d33c77847a693a378de7934195137b0c5283750429fffe159d655fe6fe0ac641a4197e17c63c53c5a8cd1ffd186d44c3bc05dbe16832eedbb1731c4ef0ae2c3661f5f8b32f2e3c4ff97d98104a0401ab938cbbb16e33706a59f0297a09e9dfe2c1c1be45613d970b3d7dc731860f21a0d5cb0b7bc906870b443eb1546def73c3fe8ce6e0a09d8543770e524e3eeaaae8334428fbe483ca48e056c64172f96a42fbf3c07f8442eaee0e160a797dd8d0dd569faf042a1a8e172898ac3f30c6d2bae555c6bc43b4ee37f648d3985739050aafe25f4a456edcdf6ae0a3791fa084d23ea9faa8e3c9bcf1ed076a245c7cd69b05f1f97279aa097e534144e98964c262c65ea3c1cbeaa0dea884878d0770a5b5117ba41415b02eccb48b0b9b40ca196cd933913ed65cf778454ea80fec9b56091acc7fd03315079064646403d12751efbdb122983e8fa2bbc03b7beb4b7ef404f7e0f9c257558dd9254ad99067922f3898b0f44338bc776622f432ecc58813072a73a4f0caab81657b736ec15d6c0c93ac56889194374a94615090271ad0c87ae5d7b9f2c911e195071a09cddf08fa13ebc6dfee32158b8940305c138abd092e288e57002d241a48ec1977a449951c2e8fdc08417bf6d038a201fa284fc65323d985daa67ee81fac8849d76d2af2203d476a4a6c551c8ed870982518e4d7643a1171ac1a206e0855a8ed3d947b420c5fc9ff7723044215607ff23310982e1fb145ad72abad67c2c78ea11fdabffc9704dfee1427faac3dd8d559714976776c988163f485a69dd4cf5f4631cecb06ca53abf116955ea2140f3e8a6041cb6177315dcd5153c0bec772f2a6edd3e8848eced8ba164dcbb6dbff1acc86ebf15af97da7b9012450e0c03e904dab6d8baec5f8ae218350ae6822f465e60f30c3fd0e65b4f54e5ae7790b961b1d7b7c260c5253038d25145db1adf113ef35cf6f84331537905a037aa09ee3a7674825801e6c31ba7612f31ea4a13b9975c0dd27f61c5b05c5f7e34cfde42acb91c2a19b6e21a68ff7b5971d2465bc2c230ce5fa0b3d28d18c5b12a5e5d72ed44da96c8f27d3bf323c8bddccc74cc2fdab7047803d808f22524192d0bd6ed9012e95a84a6d804465db39e6709a776c5a0f23463fb25f6ac1c79f191bb7708cf1d88ab62f077144ba8f1ca848e3a5c715f94f3b2583f3c17448896c408f17a1db55c62c84802c783eb6d1817a11843e5b8f91202f71adf7cadabdfd38aff5e93030f1e2d3706c78d38c3b0b74f2f689285098ab6b18494a7a94d726c6e5d1dc06052ebcca54292a2520417aa0cac2887032c543778bb9d3941032f36be6d0e5b219d87e6134c071c8a161d6de4bbd2cfe768160a11081a730f7836f6b36852ef653e75baaf5b12d28c5487b3b956172656aebbe8ed9a85293197221252073d047c7c88b412f8af5620a4d4338b4ecbe3ab52233725eec456a130006143992f0f6e2efc1d7c9b3d516fe6311d64d1735919488c6342dd56cb47447d9a697b52989ba681664b17ebe05732959a4a08809ef4566c5e80358e74ea4de10e66285c3bb184ed249e8e8f1b44f02ed9c642385dbfc235db99e1811a74d1eb8674f00ba3c81da91ff0540fb9b3657708c944b63da3a45ec3934083de7626543fee763e879c12e8b71a6b0c70eae57ce5ade3b8869a662358e97a9ef2b16209dd1afa3ddf50f42b062e665b495b71c02472b29d3b627a4525c4c80545e1085eacb3aef15d9fb704b321f37ec18665e10e1a2bb2568528b767cf8f3505d68e67caab75425f31b404f9be8ccd259d7730ae821d3704f11607867d24b4d6c35b994491fc05f8dc2a2338036782bdf08d9967e4d8f8f7ce3b6d0beb34a8a2d0a7b70da7edc30ff570a46aac834f2357aca14d20871d09abed20fc0912cebec18d727a1d5ba78e548b67f175b508d4200980ebf84da05e7684a10257a78247be7c8bde02826b20144a4159ac66cfd6e6f9d8f6028385219e2a00f746b9c9750fed384e837610a13b671ed57c4b3d4fa7930543978b6fb3590937727494746f1f76fff30d6d421e9a8f7b47c6cb529cb373e4d829f85ab74420390c7288f4f15d3690e27f31c6e64ed28f8250b0b64dd5da4bf7a4aaa54fa33c07777dbe72c7494afa951b2d17307c93e69af1e34501844c9f00bc9e0f898712d9c04120e391590d3d1a5a94277071b20c45eecadaad2acef34ab2d17cc4aff81c3b04631a30ce504acea1c92fb97da8d217f05593d47019ba0459971fac1458335429c6ce38e9437962bdbb3466758aef9666068efdb904cfb6d9bd5d06be7733ee1a04b209cecb182fece54ff13280f20ed43020850299365a186a00dcd76f94ef89d3ff402d7daefcf006eee2bc3917ea147487ca768011142ef417df341fcb9cca6b4afd210001108feba041b546f11b94e0cffb4903e8515b472c7181ac4d10c52a2a6049a0132a826b57442e2aa7e14d325f673efe4eb0b09c74e7eb09690e1251fe8f4ff369bff38c9b44f6a68b4f754611b97fc451a34a9e22fe50bbe3007a300fbffc19f0db17b37c15890990de48b4459b8267437afad2ec1953dae0a572cf0eb4c9a5d49c108b03fd9af2d11644663e2c043789c7085e04310bdc932401c4191129b8d55e4b07185e822fbcb024c52c7253e5b083be71bbe904723b9bba0ef29460c324bdecff340380cd563f17b4fc2f4506fe79d989c4d148d170cf5f30dfbaaf617d33e4728517c98d44cb70a3d99b2ca61e754f324c63b1cbcb3be099d14388af4b3238f6d5077225cf91633547f5cca959f0ffcd5080d6df627e456b15dee4ad6d39812a7df42da6d3512c839f251d134eddbf40e18f4b3adf6230ed2ef1ec9f3d3c511c2261b6c7d86115ef070e67101272c2411df232103943e0a39344b81367700d0dc126368a9e62dab843bccbcbf0afc2a38e0060995da4532721a171b7bc493155b22f1a12a2791828d5a2a8bf909557c2a1f7536602629a1f0f6fc4a4e3fbfb36524f83c65edcc429c254129f92036640917e20dba7967022c66a6397f8cd7be1ac79df0a59563d88236dad61f09f43196e236cc8893a6e70b8151136455ebfe57ef6b84987a8b3bf973011ed9257a51518ef95a00ccb583506d6043d39712dd7bf32b4d5b00f9bbb4629cfe3d7049dbf5a7301e2500ae85fa2d97542e3d48750f012e30b482a37e272c3c5420011fc52b70457ebda45371f7e3ecb4a6646306718407368e48566f9efa8717f80750804877bd810ae9b54a467c9a259dfc5af44ebe31ef40b99edf0380d09c99be1b2fb5a326a990a6d7f3121a1e79da236658990ec94c134c526889afb2af3de0edf1749d62df044287863f1e81e31b879e185a84374a15058ade7f234bc4c344d04c50841edf6fcb143ead29154b2b13eb45cde01ffafa05c5be47d5025d124990ee4cf1d24f9e72993428b1f2930100aa0788780c8ffadd1f193d7fa9706fbdd3bd1e292de8493c8cc54724becad1fb13e9cdf0000e09c0c3996122cb5edc0a3326a237e0f6ab176c878ecfdaa4e1d74eee54bcbc357ba4afe6299f69f268c31e5fc8d949cf73a9bfc2cb3bc3cc53f6c80a6bf80664f87c40b7ea0ad13d1e3cdd38848f2036c86384d5a60547e626fa7e5604f7035cb91ff1e81d7bebecfec71282cd6b957992082fcc7e73117ccd17b211f5a579cd4668600314a73f2d3d4e3b5b7db1f0606e9f2eaa235a75855e59037d64509645cff14a6c8d16d86922125c2b189fe7b9820c6a2b364878f0c1a02b629f53d139a4755b6c2bdc7ba782c461db9c88770a3caebe30152c4318a98ee371afa93c81936cf4b330465ef192a361185e01a925a105544362c3d31d12f96041c7b3d464220731780b18c4aee0b64c984b7b6c308c43bc16d18ebe0caabe6b94d8254e27f80be62654800e77aac42d42c3e1008dcc6891aa13e40af4179279a4f90d1c005b579db226e84567b94ea81e17844541ea9239f1f2a6f183098a432eb95956e1d688b55a7a809486ad34c9be58c3e7151831e466b4cb7cbd64f5d7e246a8ac7ee7869ea853adcac0b163da7bfbaeb32ce026a2ddd670efbe4060ddad00915736ac1dd3a0daa657cae33ba4eeed6e4cd83027d67eca9d454ba607c0a259f5719935481a0f880e123145c5ff03aeb108b3f702925816d0fe631a196fe29bd3313aa6d9e9b852b5fa232dd08f2afe4321b44d929f9ae52c42c515b6e40cbb649aa176becec55a61b3d7c00d2a4ba15583c94807cd09ccf6c256c53c84f67955aae06dcfca746ed093943ba7adb4126644acdec64e77fbaf2fdb09236520d2d8033a51221120d4220baf42bbba0b6376790e14f6cb6ef5d3d5d3625e1791d241bf130d40ad50e461e01df31ecafaf1a1e0c310f7d2fad582eee691bec5eb562837006a1ced9e0f6ee348dc9487301107744ff0e114a4469625aa493b4f9115703faf20262f5ebdad38d887ad8b9b7dcbdd0d76604ea12535c71fc59fe9898bb837efce2c631a89e4e03efe6a069e94bb47bd948821086549ee9aa72fe7adab340ebb60c4c7881c249f846ac23ef6ba9444c9193bfcbdbcf5da4ba011bf20a02ad0d982e4d44519b6732b599a94906b27eed3c68b1344315c206796a1e8ae031bf3416c9c8c8725f720c1fa83c478cf6a413e9ca9556e035634e3ba18a06736ea616a9db834e58e1120e41ce92416bc0f1879e26c1f62484072479dd7a711a465d5bd420af005be04da1a409dbeac6ec5b2d0915066c710b3d076cb34e2fda0cf05ee730f856feb86408fa87a55b36989501bd11cba40b6039c86aca957f6a97e131763296fd061d2dacd26ab57adb4c1253ddc1a548188d8716966adef9abb23166b107ab37836fec4ab6fa01a2ea3b000c16c6dc7e254a847098fd592432f4441fcbd5c9f0ac59d3a1cc75e5ca37126aabd89f144ed5a2923c9adb1f03a9bc45be3b453a46082233cce498be6a83e5cfd21cc641ed69608dfb3fac0a4e7f4148b9d17d91707abc457ff7592218b108c7c579146c1f93cd5baeed3fd56d0dad31d19c0ed73f21155207153f9e2093d282be80b6b390a1033a01f1456e8b1323f39b1af375827177960d05ef5e7d82b7b3e73f96c140d8899c02a8fc9629f642b4568e8d6cf5fa6f92d1dad47bf35f63f8566159bb203c24e62396f399e5194c145f916eea1876d20f06a40446af7229fc32b49fdca6e7f4186ff5fc078c7cd2333b0957f70c9e8a0b5a4cff57b5d87bdbe28b4fd27b6d4fc7870ef93519c94fc765579191741e532b3391597742a2e78bd268d8516ac0c4da09fd09ef3ab10a76525df3f3c7bb84c1613ae53cd5beb27608a05f8384edee6a87893cd9f22cc50eff048f4d8928da3e511f3cfe79729f311504616e09fcb6c1512dd4f9d7c089dc9f2ff31a8bb7f802e1a485cd30285770dc4050f0b56208d4a50700307dae941c17d3cec7b7998b11e7bb12f6669215a114366bb786b6085ba6b37d526eaf5ad36ae9555b8194d07bb25b6ea48ca2bb85e57fd9dcc90b2f8fac07d6deb4f5a30ae0f7014c116010cf87aaff332cd9620aa6ad2f3bc2d40e7ad11a5a2efc72aa23c744e0de121d5451982153230c794d2280242ee3c70fd4e4c53c52ef994063204be94655ff25dad8f2ec20c78cd665443187d8ffed2ce42b29e116eca572f13ff80b98c97b74088ded756b17edc4e11251ece0dc392c0084e2f7d0f28a7bccedd561fed6d59029f963b46310903f25399cd4e6dfc79e72ff955707adbfe780b6d48418f57bae624d3f89c8cae6525c2f79eb11ac12c73b8c333990e514480a0d76826e20737e2134743aa0c7ed74605d08f17ead23b486d86761e879bb795eabb5eefef62d098c76dc778105bb15643870cbf6342810fdd31a7b283b7d4caeb4589f5bbc10b864a2a51e18f8a251b59c7e09321a1db29e0c9b42b41105c4fe9f2efdcc83f31afb7cfb80f79ef4da409b43b51dbadeb66e9d1621a15464f3d572e9b9c570c1c3f0e6a2b1c18a08d3bc814b775d22ae16ecdce0c458a3b5b54aa5a1c55ebae34435908e614adfd3c6e926ede77ca242a70b3e80266a7b3690eaa5476d521432fc050f4aa66b203ae02c45a7da2bdde6e335a9ae1144272764ce464d5faa716c848d6ca32d879c1651b735534434c46743374d4f3979a00d82675fd68f750dd113a33895ee43414cc012dcb9960785deb562dbb319a46bba3b318b749e1ead2cf970a2812779ec3852b453418b8d6aa2ad3a507c5996eaba5e1a4ad0832b8926726d0494c09184269a37efd91c21e2c1b0cc3989cb3c0f12bd4ec1833ebde5a7ed7dc91e6cd6cc3e48474d87afc109e38e5b749d6cd3969297518e5899ae8fd10248c288a15759f031d64d2b37517c1e64a183e213b9310b6a20e35f8ba9dc9c8f4e8300173f92d7af6e0fe4afda73d1268bd9e92ac02536cb1966b9eed3f27629b308864dc7884bbaa947d1e7b849e0257204b5180bcee7a7633c6f62fab6703d023b09716e509c2fccbf4c96014922b2d7f65fa079b793fcb4f3e57fbabceff6a1dbc0d5ba944e74dc439b9250c8b4bc079e60dd61aafbdc8536c58188ee50a205ae82db15f3d2c2e3f40d892da3023f6bfd0c593710d2166525092a858fe425b4f6770b3c924becf0e2b89c424eeeec6692776d35fe40a0f0bcb61f9fae8839921f4609e46a1863ab77f61f9c34febec4450a4bb4bba39183ad5dad78492a67a6e43e559ea176ba1fa46614dcf37700123cd7a36b96ef1b4f58985339fd3f097daaabcef997b14d19a7a00d363763af970d690e4e112ab6d1022111a150b08bbaa181c116a889fb60b3968f818501e7811380775c959372721b438fa28eea4308f583dd7baf5f196d846f2a6023c257f1ad055a8e844898068795908654aee104549d0dad346b873aaa323d73e52c7a185923d0c1b00a0b8fc67a623c66a1ff1983c7ae44876ba08f593d7eefb09c42cbb099511c039dc53143bcd68a91bcd5e17afbdf81a5c55dfd4a8b1ec30083144d5f1eab68bfa9de983d3241bd8703836fd6e63428bff021cdffc50dd662666d106e96fcf7047b00c18dbc2a47fbd3316f1ca63a427e96bbec7c12483bd0b6e701898ec804e8d33e468dbd6896f0398cd46166ef7404cd28d385eb78f616d43b99f82b3d3c6a60b4b5f05e0ccff1ccada39911dd2f372eeb3db34d5b8d58b3545a9432a0370681c2fcc038ac522f3d5a9e1824b445d1d37f5636ec864102880b1fa140e3aef8fb775d888de8b73318575ac12472a6a4854627fe1ff152f0b411a09281d51b5404a58fb1840cd33c1efbc052d7ebaa97283150a8b2db8f9679e15de65891b8d7448c9ccf98722e0516ab2aaf445ca79590f04a118aa3ac825ab4469c8e27964101040536b1e5b8c938d9f6521f82d2f802946f858fe713a53bdc3a53c52f6185c870f5c7f03c64c38786a5a26dfc5dc26265bce967b3466d50e65246752738b385251ad332f34ffb7103776eb05cc7a3ba3eff2c9845316d9f629ee37373501f8a1dfb86f75ab3bb9ba978bd8dc7c9f352362216ed0df4651604d67261e9bf68d17b2da4f7f41a90867314b7cf90f77d1ffc177e8b2b9907d884adad1165e5a016fddfbae82cd5f1e98dec3f464b0900577d1568df602a821b68f53269c0743c5aeb0e1c55ab284b54aa65b3a8856d6836b287da3f2045ab806799ccde06329124678c1e960698f67ff06de3ec89b7e696f6ded2c37dc438c9ecc70ed45d7deec0e7cb2c93628c1604a89919cdb2d3729005b0c849eb7f2640ee5fbb1258140ce1ecacbbd905b2ff73dcaa62a0b7ff70a06f8bd60e6ab4886b726065345ea794a848686032647e79ca8dea4f6b0328997b89ed16f8d289e1e35ea9029ca174e8f3e3d1cc9ebdd319f703ecbec87abebebe97ff50309d806ae4264d9ccb6acfdd0f79debf470340adbfb79aa7b044911274d84bd8b2967ad9cb077c24fe08032452f8f52f8d119d088bb3297026645c78c1edd0453915b96d951e6cebeb3f4b77724c943d3b6ef75ab95a10962bdbc63bc5857d23981398e890d6649d390ab83b8e07f6c3bb121df22de291f97fb273160b31b60024506117e1ee45a827c3470674f55e96b27ec87356188e36b558b6a1307b6b0d4b7bf4553af0935b9b07897edfc61206067b3531a44e92d619fd8176c047f4ed60d18f95c66dbcdb27be22e7fdc54a09d6f71a627957653147c23b0cc48ff38c1c0000a4899489983d5bd0512b4f74d430d094ce29e46f6ad2c5759462327b1bb81225985fd00742beed0ab9b5c3e5763ea279f076d212f5737788f036352f0af1e6562f8b4ef93a5e12a2b26295eb1db4b373883e83c39bd16d76a1e71d83522e135411b1e369cda8d630e85078165837760b09359421f622d4285b30eed20b450b962fd7c90116e02f273ac4f1109f92750a9efb0c0ca305621cab97528ec900cb104b44e17bbb511640fe68ff392b36da05cf758a54eef9c221eb6e1b7e709825d6e9ad630760e50ae260a91a2eb4b20f431a042f5f567322d35dceb16747ac40218502f7371c68554eae3c904216c7d2aafc2ca6a3db9d4329d318a73ef51c8f8fbe4a8dc24f255fb8206c831e4ec7722e0621add69eebf49012369012eed2a5b0331b3f188a1170034c2be6a19eb2ea729696a87a8036aeaed41c70b97757785fc4ee934a929e5f090abe58a0c0a83a5b9634ec4de9a4aab1b6f8bb5069746ad70e91766a1f95b6b9b5226092686cd01b99f4c24869ccc6c1d4bf5dd653d8947d0cfff5969aba292d43d94105e8ff3ab199d9604751e977f86f65c8ecd2711a9804a82128756f8107abc7bbe4473583110d96a5ff595fba1eced33b8a8f59482ff9d4920cf6a772d3a90d2f5ab032272df35f1ba807da11b7de201b852070e9db9f1bce1aac8988596ac0c0e195822e1367899b3b746308134d8e6660d466acf01a1fc74fada88d0e6deb99427bea3b8e4413b70fccaa9c3cffa329c144ed533c50c0873a04dfb930ab0de9cc397e76c7f07501098d4554a3b2ead69e168f9e9edbe9619d584636e17e9f4fcf5dd7f8c60d12c5ae3483a5f4d55244b8894143a2abd414340def1b79d4ae2dea955367d007a16fa1521b8929b8bbcdeefaec8d38116ccc5f256d16f234fdbf4abcd4e2d5e0f78a51486e826534b5e224421ca0c516b9ce40685f381e862faedea62b3abfa57563543073908116da1f8ca3c09d79c2a8a6562ee84287c1865e697221cfeb4bd101a26fcf555fcdb17b0aab04de0800354ef68d3ef27c9c8da564da1ac607cdd0c2bbf51b13d90055de3852fc052c0d71161139541071bff0ece995f32507a5914375d2134efc62ee715ee833cc0420e7afd8907fd8ea45d636c9d62bf5cb9a5a803e25fe64464af6e4d84d822cbe48c65fcca4a120a5563635ebfa50336abc9f76f06c910dce389ec05922465b5e674b6c9bea19a755e285d01272f97006875f6a0b29940a576523f5e9361d97aa89345e46b211a7494097253b39ca0f9fd58ccd72f845dbcf270670e0c70f1ecc587f4e961b5c908a99334a1df7e199d748f11928566ff99562a6e99956ee3c488310cadccd8276fe9930c40033969b89fbc25c17269176d4c8cdec265238356b5ff525f6eff655f2ea6cb3ca08cb37994a4f516a8ab8a8c632ecb6eb4c1b22aaa8b9cb4f6d7330f35fc7fb3df0eef7df952565765e8ecc868943aa2bb6dfa4835418342a79600e7fa110121889792b30aa8cb7f0f390d81469732e7431b1c1a67eddbcfcb040549ba11cff02a4a79b5fe86e6b2cd957066287f1c4eaa72b0fb58c47a8c0de849d9dc1299b04717de430005354c6594582ebb3d7c405a335e09d2f8bd48c9ecc25424889dff82d3a67391714cf90fee68aab7c46179d8c79bb111f86c9d3cad3a2ca340c8d63b55e0f041fff5588ae76ce84baee2c7f2a4f624c2e3199611be5c911ddfcc0764fc01be47a556350827b45ae1c68f1bae6e661eb5522ac9a3c8ebc57f15ec2816d3dce11bf24d99d2509e20d044b5774bca5234309ea63e328e5c1bcc7fac6e5540ded460176150df4f6aa795f586662e563192ee7806d50c26db369375366928d59f410efe4743a1440fdbfdab4270850e46f98196e4ab3ae1bdf61fae43f7bef08b58fedbed3916b2b12a248497dde2e554a1c5ed01447fc98feb2e22567881dfbbeeee9d79b2e3a9964ea83d41b0756bb8c7ac4c3652f7a4955a346eb5901b32783559575fb17f315fc7c8eaf798a6576b2f387acea0b27f626f9cbc1b73fff6c53ce783a34a8f05bf0954598cea21e9b28138f1c174a40c1189ac3a86ac8afab0347832e758e86669ae7620cd753f93e1a256c2f8a2e5613fccd02f12e13a049045b1faffb8049c15f7a38394e10377714bea194e0c27d16ea0e1c91abb91298fd0de20305e4fdabc17eb014d97941b5f8b80be606dc1e6cc04b17d7575d457bf24371c41783a9e16e995159aa3c9068fc460a06b13c49e336a2ad3183e7b82161a23af89dedb0a4f557384f83bab0f7e937a2f82a076704133b39d76fdf0960778d31bc062565edee9a11725f742acc1eda95a981937911ce49ee1a2942a12a2ef97ef652f4d2d2ba490a12eb45901dff2a31287cc40501fa4a32e7631ea0fdcb3c40f7b2b66f03dcb4f99175c1447349cc16fea70ec66758315c557a98343d81184079b1493b9aef3396cc06d4849bf8cfbeca74427e21684f54afe05589e8abfc30ba9681d232704636b851f5eecc918bebc0850174abd52cd5f4d4a93221cbf91012f005b92a1027e0d84a0f7951312c2a3732b74ae1150733a0ddbbcc4989bd5b8ea621b0cc759c73b396ea1facfce25f4d806534150b190d7f97e73fda897ad28876f47461f1246c183eccd5d08f71a2b1718bcb56fa733bee56d8236a214c2d1a3d3cd856cfd10f8abedb3372a244b9b7a039f17d11fc46523eb5994c9a4efedc75323d4a254552330304364dd3b91e46000d1536a40627f46ce037311eb6afb21e8dfe8a9d7f396be846fe71e0f00c824926adbc4d01a85a70db6a5116e7b9ae5730bd11891c33b91a4934e0e8c7e90b24c0c66370fd9e41b8001c776e95142238b68b7f046d537de0380b09dfa65817ea95f22f53bf0212c17cece98286ef5777bdbf5236582dc33d6bc1371018cd77dace0068514400f8e4b5bf7b7b1fe9d33c31950fd04a6974472d3d345d6fe02c027d131a1fb4826ec83063b81b4cad278f0ab601f287e1daf5ffc2816ddbbdb60ad12180f4636863566377ab0f418ffb3e5d9a5a03029ba136bcc6752eccdd206b738a3811ea8eda57642283280cf91995ae57865a3efdf400dc129f7ca2721271b3da22ce34a1d0de4b321ec15d7ae1a0e469b5f057fd07eda19f95ed82a3b25c3c1a6c6c1613041f66a86ce63e750513c1505246febdf6220bb54119828b0c8bdb1054e9822886347554d484e96c40a0008b170cce58d585fa233128260c818e7a56faeec2f1a2923b9812db5d9c39c675c9d88dd98277b783a51c3402c3738886fca92ab41c50d947c214ed504fee0c209465466a6d836b3beeef0f8979bc16109f3c7cbb90fecd5c4628f40f399f041cd362630c2e59cf5806b1dc33cdd2844052ce50553a646495ed4cc2e74421722654e82d2ece9270589cb164007bbcf240fdb0301c3f63b7544a976dfd2050511cef71b4573b019206f9e5e5b30ac5043505e2a2d55cb32fe746e4e8c8347ab4b6fb8cd7089cd4f744cb42028ff0fd6dc95afe6bb2121de3fe4bf7d7cf981aec36d0fbfda31b87c48c145504273a0671d8824667bb6c42c5d4ff83e2fb10fd3bfc68cee746649379207525ed9c96c72a68a6ebb700836d755ba741c8e146094c098d0c4bb90ef5f8d3eca659df6f0c5c1468fcf0ae15906e468fcc9fb7a177bed27e7c477b30cec7533984f7cc163b22a73ad91f99513764e72df943c8e86d61fae3e5384101f8c6053a9c13962a08dd23e24b05dd20120d05029432b079cf555102a68dd178a6c3ce2adc747b9793ec0b8763b3125fe7b2e2ec3c632136028c1e0514b64fba078ac59a1daefe1f2c33c0c1b130b238cb6fb75596c64ed63f1cc00629b148c6c3e5aadb3d2093a36d6f2040cd7b2df8417010e5d92a60dbbff56caf9a43d339a6aecfbe0267c0e3a2bd4c744004688fd0bd628715642ca47cb7a50c6b8390f9468365d966da68c4397b8ec2388bf8a87ea50297763f587c2a00f03a095f011dde62e939a457e975021e05db111170aacb4b3911340ef5d3f2b21e338a72f8d7292c3c08ee0846e6abb07faeb5ad1d6e5f66739ddcc74f9c34a253bb99ecd3288f80881ad726484a31c4233121d9e4ac380772f69a9701a1ab2dbd721227882325ff33aa6503397da55f9d9e89835c3111748f308cb600c0549aa30022d7679e1a02fbe75ca5c2d359565b643c99d0acca76c4ac90938993ada97658b1c2ce93836e077ec5526dd074d6cc1aea098640aa01e62ef2760c8f6b77e6d49211ce624302100cd64df14ed8559b7dcc42ebcf2b7ee5ba3deb90a45ae5fc8ebb0e49688fb0770ca6706133bc340eb0dd1c7da4c1e98d0ad4a309200f059779eca1030369a9cf2478d5d9d9a76deccdbb5301491b517f2ccc6c197ee72b2c5657fa77b3013746be7ea1c458ed9336fc13685dbe2eda317ecf292ae3de06fd0742f1a3c07f6658abb1e7019e33054bead3d392cca658b275082835b57ece2770710b7f216e1d979cf3458714a5487b75dedbdf883253b1a9a70ce9fb691575ca7a9ac5d8199ba07b8eff6361405fd9366f29c603bea007fe46f46d4305f4b4f8445802213f7e3d5282b24144f1b5c4cb2e7ff28c38727858d9c63647ba85a5db8cfbbd8b404162f33e1c22e4bc838dd8e37b5cb39e1bf0cd59d9c5e6e2283235e44479c9ad27f11ec9c822cb8523034b3320193d4145e353ee9ee8e28d9d05f67cf82df0094a590ad813ae802c489f2efa76e394cbe7250882eca17039c5c1176ab00f330fa7fae0adc96008bfc083280de5d7599d04137cd2d4027adf3e4e414d3d1ae4b90931f855cc98ba9d7a6b4d058cc43f6915fa905ab04220d707500aa20052d689153e31369bcbf599bc48792fa7cea4400aed3022a5853512b1c09817c838b2e408c3ae43e5bcd29bbdca8e53e27434451bb95e2bbf0d77d16482f3c08d3b775eef8c4fbfbccebe1cd203fd44b7423b7f66bc2f6a046046e0ceda7927b162132b8a0f9ff2e06c82bcb526a18df06d9f364000a5c6fccc09591b1bd22c0f358c218d7f8527e00e1b8fc6d34293aa70a18e169810ccb2ee00e893e6226cab05261afe5436d31320d9470a192d194bea0c48c60d07d951c710dc3505005833b9e9189655db7dd3bf9ee664ca506970765a1aafd88d6c996e54871eb994ab3313c526114b7ed0017f442c8b6184802455321b3a914c7e03aa84abfddcc1668570b6a8cc3b66330dfae2462abc892bcf6247c54e12543e6f7a06ac7d14cfc5371388bf51e392c6fb5599320ba737d04a75d1e7ef46371e610a6b275bec9efc45866828c624d88f0ae3cb3655800540384f8cd679ab38a58af37942bdd386ffca719f2d5dcdc64f716594f8c485d09dab4135ffde49fbb62121483dc0cb94393ffd488d4063668b60cda37cfdb1f59bdb572d1017665f1aaff60b26c6a9eba70f55390d49c943519ca45114f34c745aa31b2153f0776b777d30d5d60a4338cfdbb690d438611f07f49ff0ca8366ad881541124de7c5a18adbf1d2aefa5c597f87738fe4183e4c85d8f430aa63c9ef8f60746aa241a875dc429496d0d674739cf10a5be07639b9706c57ef8f2c5fcc1e640490cfe2bc26896d5be2426fa3158277dcee2e98550357101d51fd51f9f1895fdc6409c503a79aa45a123ac714aa09b4863f12976bdb632f6f1b0aea36433d7c42e0dfe4028619695f327db05cd6ff3007338a086c67a83ad3956b956abb7aa1bc1512a6a935c8dc857add822dfa5b3522cd3e06fa377b754f264bdae7c42db1b8900b467860c6e51731f8392056e7f1db8bf65a950850678683811221ac01057c65d69c9e9baec411ed775fb80c0b023d5902eaf89111439cc04f74e7f1670b7ee13131a50bb99d2785aad9fa9e8988747d46289675bbec4d98a74d99e7caa650a5409dce923fbe39d6e2e4f76d09489b5e8c778f791d87db99b8e4f3bdd873b24c2ac3d12d7e3629bd9c649d2b1f5ed686efa450cc2e73319b6aec5828f6b1a20d6ea7d46ed4ca21bbb775b66241608227d3c3b970d25b78f978fb883be0838a33a218f7a6d8fe8c66ca2f9eb4cdfbf7b96b020975329f6e854a32eda96c8785a373d779226b614a00bd3474d06421fea026c4e6d4936ef9ac8e38d96b1f19ef339e06ffa2b2334c2325e2859bc84c379773cd79dfd807782a6db576a61c81036150a5bcb49b139c14a4b280db925bb21729444c2c2657c808ce95a0d80242abfbe05d302fc9f6f493cb5502c777b0328a0877f2f78877f3f0c30e88422dd999fe790eeb20b5009580a4b306c918a24d852f61647350355143e000d48ef8380f038442a907fab61759d400eb2add92324728d88777a990e92683256f24b2ff11aacf81526c45e98965486f45d9d55bac48e92818dbed9c587cae1785c0ba7c49bde23311f5a3b1a12521605f09a9fe4c9bf1d36766160034668b45bf5739c68f729f04c07ba32cb741fdd2717ccace5c4cd52a78d42cfd7f049e853599ea56c8303ca4137a98df66eb280279a0d5cf8c20be77969ca882803ea6b7c109fd47dfb525480c8176045b7b7492a21612cf26f5f726f601e25fdf23815ca4b12edfd42a9cd73a013b3bc9beaa82867374055b5047e545eac85241506d305bac9926a075bb844645e9611df4181b5096bd77d95b6617457c19c6069a7a12df48b552a400072bad8b41aafe11fb9ee0dc69884b02325332381d3c431c214dbb4a9c1684c18f03589dd457830bfe62c2d97347c2eb24587e108bc655b340bab9fd7a57b35b15f9d97babc32825f397b42a396878d2d5a0a7cfe6dae5363696b7bfb8afff3cf41d63e41b4daedd5565485ecab6d95fb0ff02744b6e658e49fd69b0a783c7d534579f10f2e4ad23919e3d071aad94fb3604fd8e8f39515c396a5ab09f4eb56588162dbd316d2d9159452daa91df55788678d7b3a2c3c07864953dd3119e1e8a59f832e4072bdfa24ab84f0b742afad318e9eb5b3084223c10523252f3d774fb0534e243bb670964234bd17de8e7c7371f91f9abd1c87c021d1d8b668b0c135cabd9ce2fac68186184740854f7ac556400314e5313dd5fa9fea03b496a617fa10ed83f506ab8af53829f0363617fcc32a2221f8d7477e44b86ba022fc0243736f2da49a7e2db94b642f85d8816d016ef761ba406ae210d2426ce9e2feb5590814870ebe32ce4832b654c8ff782e42f0c76cdb66f49e62d026bb1b7e0f9d44bb6e794ebe7048afed06481765432c54cdbfa50b3c2c26c73840b977b0902bf9521cce2f17615708683c772471a47bb1417e57809f886f2df2fdecd2dbf250b4db71d3cdc7baf794497ea07b9947a492098e96861a2d29c31601a411379780c416991d4bd498ad45186eaa6fdf7fa618d0e8e79558f0eb6ce288f5b1005984819be25a938cef4d8906136ad32ae64f8f4d7c624cb2fd229a51181c99ed24f5d706a51cc73a398849239969fec2e7e98b87de7b904848bcdace43db7b5badcabc02fcdfdad4301d740056eace3b00e1a47888c493886e949cf58e7a2dd8a3b63d00349cf3bf7ab927699c17053273b5fbf3b3e04e40739bc79a09b669f3ac25bd550f5ab6814b8506e31efcdc5a02e3026a4cbdb60798419f7c030328acaeba56cc207ec1c7aaf6760f7d2300042ba9d9b36041925755a5d22f3480e6d21642ebdfb99f28628cff4d6f6ef1508703bc3b0cea0c69aa74e1bab3084c7f65235d0369666a71bc2c6fb8a4453a9ed2523fa313b19c81a3c78b242073c56cc5be722dca0cb311ed8de97fd8f05282d85cc6b284ff6855c85cca272b39df8e0dba46bbd222e7e7b6bf35eec79cc8fcaa2efc6c169c72872f62da4e639d3822cbe10555000590d6ebece9d62c6ee3507cc160d6d0177fe732b106a3b797ea5c5f519584939749d99ffc89d44d9cdeae4fe9e1659fbb2e5556a1dfefd9c227d62b2191344f2905d5db876619a2b5320fa7210422930b82d2eabf9bbe89201a7f0279cf63da0eee86ea39317027c0ea226a0accfd623da65070a6ea8ee8279d872a5252cf66add68e3e1faa538191aa51fada4f5f500326403315e7469fdcb37b31c18d52ed64762938308804246f296ad6cdddd1ce2192ffd6101e98468855a460ae9099295850ec457f7aea5b07c76d8e51502b93527c387488334ffa69e9b5d564f308b2c04eedd6b083cc3565a828b745b5b8bea16622c73b156ae2b73067c664167658b9c906a932686693fa9fd63edbb98072651f5fa79dfac9ba96e87c5329f2a5cd576d3e3cef349ea6a55f96bb3389963dfa54acec4a67a7c6c52674e246282fd351a2dc990fd1997ac94173ea859a2271b6eeaa4607f04cb19ae7672083590fe61db1a3bd599e9d88392f5cf686a41df9edb8cdfb19f9bc914b885c89ac2cda1734d6632af0ab55c4028710df569f2971a32c8de1b7af32bc1b11ff1fef7b42808745c3b59708475b80ec71b62c01c47741d291843f22a363a67b49d981953623385f2e2d404438932df0a8de3fb4996b8b724f914d7f385c7c025895167d89119de8d6fe47e2fa1ad1f6319ea2f3182671171f5177da76ae8a35c333fec51d54014c0318039b213409f1913c94e3e6f4d51280641e15f9d5128f2ee7b0cc3fbb4cfa3dc0d0d2884f02650e8bb8acdc051836b72c58a022d9c88245e90a41a832aa96c1c33fef77216187f7253b472ed5fd610fc5c2ea159a58971e02c9f60b2e557251b0188acaae1ad4f99d6d3d66857df486bfa3685ca086795529ce1b2dca03ab0aafd87b18b80e17d0e3fab7f7600106f71c5547db221965fe60d77d5f1975dd85b4b899f16212d1d28859b2a666f6f9a10278943389eaab5f245c7ddc289b2887bd8240d08743629e7c1995d41824b3f18d4efe05293f6f46147cad9d6982cdeb25dcc4379acc58a7cc0331bda9ba90b461572bb62ac983b14825fe06a81bbf16fab75b6ce7c1ba89f70839b3609facf21ed4ef55502331f232468e0b82c68904e9827f247573a7d76aef2ef3a85ae574bddd1cfbb1e8f6c53e7eea6422408cc05864552a753789d6aa56dd0ce03c25a57d3337708604c6ab3cd0043b4f1eb9de75360df43fe96f313790648dcb2bc325d2137c19b2fa600cbe3607419e7c28cb25b8a4be7b1d894131ca9fb4803e1179939e9d2968848ef11bef64039380e656f582a4b905c9a0aa046ac9237a75c971973115494914f829603ade29dbc7d3807fe5fac2d2d3801fce44982abe3b418d2852aeca4ad141d329d8073618fa183f62c9e48b56c4b21e431998fc07b7c0ffbde91a27e285ea7215683d5c233a019c0ffbb8c1b0c876baefbc6226e01c9265416a9334977f035caab94ae2b1604bade0caa8c51ad9b40a1fd4979bd87630e48f08800a282b67c9ca918c5d06dd6c63cfab50a751c3c9b38fb0027f878483c912b4ce48916be01f5f7a10afe0d3d910e39634958d54f2bccd17c87ce15878c61107230951493cde4521f4afef679971ca16ae3d58f12f43bbc1c58b3104f9b34194b95c44c536eef398925b8702c49be8d853d4294120b038de798732f5b718f744b98984e41dde717136ce1ba3f6928d9844e25d81fbbacd1143fd91d2f84fb31b80321aac6f01ba5023a4fd6c2c1003eb9c08d3705d2daa8647d1c6e285edf85e5844b8598b6691447608029ba66a503465dee6bc3d08c5b8e37dcc2c8c0f1937fba86e3072c8bd0446a0010a82c030a74da47ae8182b6548e65822fbfa6b3b9ac4314d3f13474c7f260737774648ca731a6e8d5e4cc8618f18ea0324229742389993905e077bb9a3fdf807db67357b01ee2c4d817bdc3998ce804e2b87e4bb7fc553c27b505e42d8b3d5aa7d1669b9ae7b20bc551f2df9b1ead2097cdbffa8dde9093ff078181cd5851eace6e6caa4b75ad22a49d05d9ccaa811e1c9e61cd3487d9225250b3df13464e1b4231e77540102e7c72f901092b818d8c564d083ab74449a140a3e56ffc6c201b8c161bd6723c6d321efb306e285104d789a8d689e9b8a521f2951fa29163f4963ac36d63e19f6184e57381d2bf730cb5e1b3d2f3a605ae1e850d36e20fc3fa0fe066b0608f4ded193b260f38516b92782caa046c4a5a1580756d5d61d12a65f85bc93df446a851a7ceb3ea3fda47a93c385c66305474ed0ca613288d35156343f7fc705a66d8757c4fa5438ac251cf3842c9c2f0b9a1508da56edd7bcabd66c00d565c6aded61b73d1fe258fe14b8c6ff0e67aa4fc9a045b90b6e3a567cee40250458bdf5c0ac681a7836980e4da9f4f20bdb0c8cb965eb3f766fd36221ea289709f64ab24f107f50acbf0e23594bcf499a93defda6ef0a9c3f13c94e7e4c2436236045e7c7586fd0cbabaab73ff16314f05ffce5cbca86d4e4f8bd6db405927b27cc0976d02397609d219a8ad1759bc6b0a2fa6528f250c3ce99c2b4224255033467c1cf17c8368e8822df9da267e76b230a7ce85485e203563470c40cd927f94240daf73aeaf552567a39c03126bbe8a350116929965db5d7db212472cbd086a7a4f6a59a3c2828fc319c62286b294bd2bf75475df3f4dad9c56358445082a6734ebd54b686c59e58be99116d7dc7fa01e391eeb82d7cb94a59abd118dafb6b154e13de22dced33762daf2a70b9eee3563c3130b12919f8bd1372ea8bbe9a43a6171e0c303d024ba2f8d7ba4c182cd9bcc0de037da3708bd41a2157dee9adcd62715f76f8ac5185b0fdf5453e73c6641612dcc6824bf8e4aa8d7271147d786bb33c203b939f8578cab06c44f191da40cc754931f7c02be6a26fab84c56995d648b20e093827e5a14ae104abaca8dbc672a4196bdb2b33552de94577640ac18ea0ba0666b7a79336849cad5bf07a91ab3a2d4ff810309081138ebd7b7e7c545da6384328cdf07e50394eac355afed07a9b2b2c366a26e2dbced7a975a583f9cbbbdef46a67903e7aa266a1f4f97df2ed466c9e18387c170143833f62bc1ea398c1320a1f8bd46d5ba42b3e365d832e7226b86554d6963fac6d4e955fcf05983ca9b5b08ec104e1108490719f73635d1ee679033ca6a3569b394afe7bc1704c15a8c2ff637d19094c3bd78e1806dcb7e9b4cdc4e92f95b6c928f39f9826699fc215742e6b3cba412cb3c7c58cb4fc08f0e48b37d503bce770a301d7ff79176d69e5c8360e2c1b3e5c9a5020ff0aa85041c9783a39bb7b3d58d406cc01fe4b362c68e1fa120c08adc8a8ffba4ccd1d4f2511532781b46186b98a65a1fed829ad5df5ebde25033351415175577963691da4f65b6c4aa31d9ce2297740852a332ca4f9f473b3dac41ca6fb702470add8020287aa79a05d373aa7ae7d8c56f99edda1e26f4168504ba14883185ecc46706ddab0506c111c6ebf429c9ca698e88f024ab1290170df614fac1c35f766622e0a08b25cdfbdd76da114bb675f6ef561ee13d90979acda3cc41a74ca85c38ae40dfd8e33af9269a343daa561dd6dc37baf89e2f8c3bf04c060f5633adba2500306f6004edfd430b1df4d10e989d4e64a1dee7fa135c72d91a188ada2a09eb210adde7ff5eed41000d5d61b8b41e1b1c3fd6bf491930c1cdf4fbdc01e16bc290194e3f0a0025fbf8ff52b227cfa73839a5d8e3da0e079dbb8a9b1b26277a19e3ab396af81061735a6ff963125db048335b453dc9f0361184f21bd6ca51e4f880f785c51f2493c39a8ae1b4693824617438f0c63c89e3d1e25ba595ea58661b84cb405ed9a0776f952c6cc794dbce3704e46031bc49a39a901cf9420e2e26a15047342b45aadf9c4e4392e843d3c081efeee466e826d85cb6be5e530dd413533a2dd8cb53b1178158f6d5186396161e0d516e057bcf67e660fc43d972017c48a396cf5e2d9c3a5d9e5f9757fcf9ab45df3e113539805a90553758cfac63660bacbce08c967674f4a9249d6a1ddb5fe361f67d9a88c7fed28f8c86a31575cdb4ce5277997f912b599e030d403ede2cc1536121d2e00f262797bc1aefb6c4c7232fb4275128fe9bd907ac50109dc00bd32cf23ff34b07f5099af4acd364b0689b060923b98a52185153365288302cc163bd299e742b4b98ec2a06cff719ec807d593bd7c558572d17cb5b4551f4326e7f192e3316fb810169bb4904ad9d6cccfc41ca063a4c06fd9394e7e95fc504fcf68e3c4d82158efc93305ba85a0de1ad7c766eaa884a5ff5d30aafe76a0067b4ba400cbd80dc78f6c22bd974737e361bb5f6ab984e755a0d89219a2d0044cefa58b024e35aa40a0c31c1095e566c6d4489a44050746a43f9678ecec01387c17f0d97096871adccb5336950972562eb4b4e9cf854fa6845c8ac5c2192c0c73dd5b4c9810e07d44a1713b22e4616fa66423e208dae347519389a4036368763d3170818978f9c21618b88b86cc9d96966ec01e9e2e5eeae278c6c8b79dc7a0cc41f15a3a72f7de135cd284676d7acff44fcd222413de7a9ebdd2d66dfe3655c95af2b81528fea7f5489f92216ccae28d42a35b5734f41421cc305df472f8fb6106f791969883454fc24732018f932b6afc6780eb5901f935da03d30921eb9582ea2b49904840f6500accb77458eeddb88e0877aace86786c9c37218de6721e3615f396ebbb3a8d1b654dc28488bc88ae71fd654b09fc4edd240bfcdc59267b39f586c00c3d020789de3f7f37ff871127138ad11b7f2cbf8dd295cf2e26ddcab3f204ecfe5d70e8957447b606c9f01ed4a14e0c200bd136b83d929dfd44dc66eee9024ccc59789340f5df8e9926ac7caec1b67b55a04199c9ac12b7dde6f18ffd23ae649aadb3ac86c5f620b2bbdb1cf041896913c2f9f911a0e3ad12b11916e250875e8b33ac2dc0010171d34eb6837ea10effdd879b3ab14ae1ec9b7af7fb27418cc4eff8e42d72846d8eedb27f4f8e76b7583efd7fa653c5d2450a4ebbcd0111713bcba8a630d161afa7d208f4ada93bbc10000f17fa2ec276951325b60f75c7411f2c9c138d3f812140a6dfafeb0eb7cc4ab52482856985e8faecf05c0213bd4db90723208bfc7b4c06d9334c559892cdf62e0ca6b51340f1145d85356b2db4e30dabf0c8df85712dd8095b08010a92179c36b89dd26c9393aab53a637ca7675c9194e0237203e7e724dab76cf8c15921632560fccedc602f2ff05075cc484410d8307fe5b7b0421841f781ae6b91174b9391fcadac4022e3229d15872479dd2c1121c8cca4a6c2a66b3337ec5b576abfbebc8a88c28d0790bfed99b7f232be33dac839234721fda77aaf70b5e2681e2455610dcb13e3b76ed5ac5c97156b893676ea7761eea558ae7a4ab3514aeb85e0389d94cafd8380e3ecdbb2ac1f889dcfd6922563009d595099a60e8002878ed78cb799528bc846170d3b615671febc71e865a8202db493a1317bf0e34cb989b0bd9c1bc97fc44cc6755afec0b0373509535382fe0a79b960181ff67f90e1d2640e7939e99bed81d4b25e32c2dd1dc746c540fd82c6eaf08d12d650fa81f3ba8497a3f9b68e15a1477a93ad337f463151cc7dcfad267426f3704e27356663352c8681aa42a8bb68b38a46df8193e9e9893230c21a2482f8888ce0fb00bd188bb8d0cf23ab81a6eab841f38428ae314fe81a9a737fa2e13fd95e33e22c5cd09b0a5b30d8c27d9b8e4e14f2437afb5c62182f74232acd13ca7e003fd9106ed98781068bdb0cb9bbeff67618ed001299a26bcba40a0dece3a2dfa01cc33fde3d20e4c20dc29639f7cbc6b7051e80348ae2536305c88c984b4adf02339f7133d411968b56d7445277bd860aeb24dab70ff77ed370f50e6c5257eba7efea784b5aef647d6bea5e5444b4a3b0627ef3bcd68ab130aaebc9d7b8e093d37390f2887140a8ebd99e045acf39dde3cb2ba0c35e4307aea78a38dbb401f8290f7ecc732a60d9831e882f18040112e0de24d230583a7eb591140b10d64212fe369f119ea3b63158dd57fe645f420bd2cb2041bc3b278fdfbdbe12cc3896bb590bdcc81456ba69e0e5c4fa60c897ed733b67e37cb0e63f1c0e532f07d3d9a1d12daed948320d5cae49b0f3a51c014235b60039d3a1a5da31fc5886a430442ea79ef5ee04477bb353c8671a6b56057769a87b06adfaacf42fdd62408be2f8031ece7b508fad29f4dfd47ad442532a3799388af9230e78a54ad99049523b8ab5f6da1f681e6b6c73edd6e78ea9d85e428aac5065c1ca5efd590c9db32080431f3e770f746143c914028ebbe77a9e1effd78347e72933135d269447cf433913b350a0bbedc8a41e26382e70f95489981f9ce923db46a4f115b89c1b721f44b4254cd7c2ff2268300e8b4106163b43e467bedcd578001c651b14ccba73db89f8a4b26f3831f9b6be9818add3240ee73419f8b0422e3218be8310c430f2251ff87b078953deafe192a5577c1283d1d5724f03b454cd619b8f3784431c1405263f906faec210976688af6b26ec42c8a92401c1a54378e1f44bb539beb20ac36acb432fe83b1f19b3bc243154dd55dd635a14bc38647af89fad2328bdee4c1f32782d17829516e17f18033056078c9dfe7ae0d7785fe96cfd44ea9ae45bdcf66ed1df1f592f986d6362429f855d807ae1f2babc881a8c8d34f8fbe92f1790b39d7084913286917a23274254b56ef0c47b78b76d76fbbcadd5c6d004349ef1377c6698711370a7a5b70265f59f8336ee48ba136971a668861280cb4661db4a0a4c8201b9feb9ad1b748c5ff40b4f21b3192c4d9de1007555e8c4736eb29f28106bd405fedb54e5a13fdc42ba7acf837068c691fa11b3cf632302897b1f5dc13f4ff362e5510cea2d85b77d73d5d3243483e2ebac273036477923b5fae56f7c59a2e23b2a13aa83ca2b2f7068176e2eccf60bc44229508957a04ed6eafd84e7905a7475bca54ce4d052455d93d658792550cbc78eefa844d4c9ebec2fa7853e6c6ca77d8249dd62fe9a27cb2c8cc7c7e25a63599130dd17f419105e40fe4b7fa1324156a977311dc53664fcff917683d3c42d2e1fa6a4fcec3c40d06984269cd3b96dc1506a64b6cd8d6845bd2c3e237534523f63b86c898fb774c2be23f033f7c4b0b96833c3285cd31c79e32faeecf5e72288d6397d907b4fdc83b905726d5fe64ea92f8ae7dd03ca316221c0cecd9828d02738d1fc5212dd322acca6a6762eb10a0b56dc16e34ad1516564cdf6bf855a2a29c7105975465901f3de0d51765d21e3068fe51bb024060ba65d784fc9bc3b1d5b73020065c0386d8992af5df3c44ab9c263b72d37b9c7f9278cba7aecc9457acdc97220fc07027acf772a7cad97de68d09574cf11806f376b89fdf561f4555b6f8b8a4d981392ed86e2d38bf07d277f83650d2083949fcde3ff15478f9f6fce38227cb3368bd7f3ab754cd8b9f8f0f6fdfcdab8a689d8fad996f79430bd1ce05f5803fc6fc895ff68dd3969986523b200e3995751d85f03e39c184da57e513370ee4036215e164fc88f22b8455fad615c149fd4acab8edc71dde7614a768f0ca3ce4a27765e385aa0c5f020e63523145a2b44005be059c1dbb6c816879e2df35c8cf1c40d380fbae94648c1c4eddf3a978b9a7eb42eb78a439f16505ace09c8e0d891dff8d6d33000a99e22a95e49e5913cc5b9dc34de38e4a1e31e759efdb1f345f60b945ed39d47c03f25403e7131cb7d208976bc80ffa7f07b7fcaa3dd1f9a119b0a2b1027b0c1e902864f509788833f7cc80062ee34896c40f70b0ed1cde66faf9e1d2c9813ddf81b29e8436e8eb16ccb5909aea4eb972c4b558947a562301e7f75e4c0a4a2a73c94f5b83cf6dae37437131764f1ad376077dfad7fc2bde36214907f699dc2389a96794b7f9478b5566710ec364ccd8f0841ef8591051c2fcbb8d55369384990c7191b50b24870832b68d7dd3d3c5ef62ee93b05af53f2accb2abac86349e79f072fc061b546be1a98d1fdb57f8cf5ef698715f846a57ed9e49bbee751d0f6a2b0e6bf616c220c2246dcfd01bf15b5084dcdb161c6c0b2061f9f0d31af6b31aab0e74eb3ec2fb0add8e1ed8b66ac2499bb7d1421374dc93fafa4848589342407f0f77bf8bccb9f857e4c9e11371fb75c4dab7c9ca58d9886ff10fc5259bfa09bedb248969dea98d70961c9ee3fac4ef7f1c08891ec20a81dd085b82ce84a2f6a4591e16923185e55e79b190b1b14630430d49c9d48b569a0eb3d77f97a9e37282808b9641f0b7e06e50a9e772626a70c33d245e32fc03d7af7d1b346bb1f5ba14275b8fb492804ebac9629dc0f65f82a5e641ecfff624d91225e2ce3a8ffe5391b500eef673e668edf82e7e2099a720dc0507b1b14ff5334713b8790061ece844296182b60cd5f98c0868b1c2953ae1e7b574a0b177e0609915450d8ca6329c297e7aa032c866fc555c8d7545d2183be3a71db35dd6816b9ed9303124363a4f97428df47160c2ae5785b1b488b6ce861bf6611e13bf1af9329da2f3fcf2c1a016e33ddccb743aa0b03f4a17da417200cb8239ea98e7c9e7f41d5786c92e7bcbbf85afe17f7377ccbd80b2aadd803ee10b307019a68bd31da2ff5dc4efcd611b40124f5846afc831e95fabbe0015a6113e2e2bb00fd7a826c9f766302736bc0e98a2fccdfdb5b203a7e74d752cfd341e90a97a43870a2e9be3566edf290ee37e79cfbca7fc1862967b0ab9bc8e67766d1d0805725779cbc9f3bfce3c2a27be6e534db7b440dcf04d367650f8a984fc9ae2a995aa6e80bbf448bc86d1faa519e8721896aac4cd2c81d1993502da0f99b1fea369162950bc51c712173ab7533ccf160ce2202f16a88e1da744e8bcd27ddcfd538945fad8b0504234a93c69a08fd874a5e1cc763d1a11b9db2957182a5d0c090675b58c2e450d512ecd26cc329b52c60d9d6e14a0595b9852358095ac543517f8f465c9d9e60068e68cebcd9905affd3dd7b4e2f212e2c2d507f01e1b88476873ae0c94a842bef0798f3789617956c2059ec57d88d45cca4c10f5edf4c246fdd6e8033639c30832302baf5268d77fe6848fd6b9fd1a12ada9d981ac27814bb8d47220ea7812010740525171076d74eaebbd1658a63bdd81bc705589c7db64eb00b30a1bcf21838a37658b292512017c10a5481a425d7ac68a52e92571b9d775e9ade6974c6a450e07f4f23ed9b8371569bc2f06ca4414af82df582c7bb0ee020db70ed55c7da65f50c7a520b605733a27749ce593cefa45c6037aa95fc550654834c9a2e1e95c72dd13e7eba95ded5202623a85e899651795eed85641ac8a82b3cd000f5aca6583d3a559fc884c65387dfbe5fe46a6790944b3540c814ccfcf32b3a2ae21745160d4cc3a35bc9426592f578ef8b0c217afefb6c98fb7d8a28b1a877b6cc703d41601a8c0a8a443dfc107b32447c7651f366f07e4fea79fa927c71fff793bfa4a2d2616ae9cb2e6e377cee89e3a549d54a7b392118af1da3b2b78881b88fc19586fa3940a63796b84f98848f16fdebf8e3850ba23582931f79f80ab1c56675a52f5ecdf4c4ab0bfa99fa26e19edf6f8a32feeb5d929b5df0672a39f75fd1d3c7285ce698ef4aee6e6d4c0a23e9f280f79663a68c9bd2446d4f2c825596a4d87bc642d8623cec0471b093e70c99edf537a8abb104038755874b8f2937d357429b21ccacfeda7b484c314a0dac6cccfb1fb262c3009cc8706e36368406e0cab52c5af57c92aaeee50c5031431d0535457791c7cf3221f3f23bff1bb8492a7cb6541607e82666c8191f7853236a351e1e5435a0740921b4f17be1154714931238ff528f2e51a7726a6e01930322e505691fe45e7e944cb426ceb96ae671bf00d847ce3d0b35edaef00cc9cff5beb05b030fe274c5bd76415b2d1dce2f6b91f574a8d4d02f95281f452cb63d2058ca8419f506fa93ea9884af55d7e6bd1c8e86d9bf36f67296859c95014521b1881f22d9473e03b51c2633758f9a5ed601989366bbd34027dc1bd2d91f9440c6eab4104d3d20dd005720a804a17691ad88915fa90901851f3d000384a766081cf8ca10a4dddf223329f6fd0c9f38fdccd214de1b86200632a7ace276b9f1a7a9612503cb4190ed123ce5817d290786af62e1404c4c413ef6d22a64e338052ddf443d5dc01417c9d0d291239550cc2dcd54ce9a1c5492239dcaa86117242b16b540dc5894a10e914d754af0ed35aad12d08b1c7e22bdac91d764ab8b2ac6199896d8d105f7830603ec337da37acb5df196dbc3ee4dca42d5318166a0dcf75442b2473d4cb7cf498fa97ca6d87b1cbb4ec4242573c2c9276fd310d111d9f459428571e0823c22c9a2065c3e5f8251b4da149eb646047e981480fdcdd557b5775ecd39b00539944507a237e761d5a92795e22d8d0</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>青春回忆</tag>
        <tag>我与她</tag>
      </tags>
  </entry>
  <entry>
    <title>第二周LeetCode</title>
    <url>/2019/04/03/second-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第二周LeetCode刷题记录"><a href="#第二周LeetCode刷题记录" class="headerlink" title="第二周LeetCode刷题记录"></a>第二周LeetCode刷题记录</h2><a id="more"></a>
<ol>
<li><a href="http://wuyunjie.top/2019/03/31/LeetCode-4-Median-of-Two-Sorted-Arrays/" title="LeetCode--4. Median of Two Sorted Arrays">LeetCode—4. Median of Two Sorted Arrays</a></li>
<li><a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%945-Longest-Palindromic-Substring/" title="LeetCode——5. Longest Palindromic Substring">LeetCode—5. Longest Palindromic Substring</a></li>
<li><a href="http://wuyunjie.top/2019/04/01/LeetCode%E2%80%94%E2%80%946-ZigZag-Conversion/" title="LeetCode——6. ZigZag Conversion">LeetCode—6. ZigZag Conversion</a></li>
<li><a href="http://wuyunjie.top/2019/03/31/LeetCode-8-String-to-Integer-atoi/" title="LeetCode--8. String to Integer (atoi)">LeetCode—8. String to Integer (atoi)</a></li>
<li><a href="http://wuyunjie.top/2019/04/02/LeetCode-9-Palindrome-Number/" title="LeetCode--9. Palindrome Number">LeetCode—9. Palindrome Number</a></li>
<li><a href="http://wuyunjie.top/2019/04/03/LeetCode-11-Container-With-Most-Water/" title="LeetCode--11. Container With Most Water">LeetCode—11. Container With Most Water</a></li>
<li><a href="http://wuyunjie.top/2019/04/03/LeetCode-12-Integer-to-Roman/" title="LeetCode--12. Integer to Roman">LeetCode—12. Integer to Roman</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>第三周LeetCode</title>
    <url>/2019/04/11/third-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第三周LeetCode刷题记录"><a href="#第三周LeetCode刷题记录" class="headerlink" title="第三周LeetCode刷题记录"></a>第三周LeetCode刷题记录</h2><a id="more"></a>
<ol>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-10-Regular-Expression-Matching/" title="LeetCode--10. Regular Expression Matching">LeetCode—10. Regular Expression Matching</a></li>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-13-Roman-to-Integer/" title="LeetCode--13. Roman to Integer">LeetCode—13. Roman to Integer</a></li>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-14-Longest-Common-Prefix/" title="LeetCode--14. Longest Common Prefix">LeetCode—14. Longest Common Prefix</a></li>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-15-3Sum/" title="LeetCode--15. 3Sum">LeetCode—15. 3Sum</a></li>
<li><a href="http://wuyunjie.top/2019/04/09/LeetCode-16-3Sum-Closest/" title="LeetCode--16. 3Sum Closest">LeetCode—16. 3Sum Closest</a></li>
<li><a href="http://wuyunjie.top/2019/04/10/LeetCode-17-Letter-Combinations-of-a-Phone-Number/" title="LeetCode--17. Letter Combinations of a Phone Number">LeetCode—17. Letter Combinations of a Phone Number</a></li>
<li><a href="http://wuyunjie.top/2019/04/10/LeetCode-18-4Sum/" title="LeetCode--18. 4Sum">LeetCode—18. 4Sum</a></li>
<li><a href="http://wuyunjie.top/2019/04/11/LeetCode-19-Remove-Nth-Node-From-End-of-List/" title="LeetCode--19. Remove Nth Node From End of List">LeetCode—19. Remove Nth Node From End of List</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>第五周LeetCode</title>
    <url>/2019/04/25/fifth-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第五周LeetCode刷题记录"><a href="#第五周LeetCode刷题记录" class="headerlink" title="第五周LeetCode刷题记录"></a>第五周LeetCode刷题记录</h2><a id="more"></a>
<ol>
<li><a href="http://wuyunjie.top/2019/04/17/LeetCode-27-Remove-Element/" title="LeetCode--27. Remove Element">LeetCode—27. Remove Element</a></li>
<li><a href="http://wuyunjie.top/2019/04/17/LeetCode-28-Implement-strStr/" title="LeetCode--28. Implement strStr()">LeetCode—28. Implement strStr()</a></li>
<li><a href="http://wuyunjie.top/2019/04/22/LeetCode-29-Divide-Two-Integers/" title="LeetCode--29. Divide Two Integers">LeetCode—29. Divide Two Integers</a></li>
<li><a href="http://wuyunjie.top/2019/04/22/LeetCode-30-Substring-with-Concatenation-of-All-Words/" title="LeetCode--30. Substring with Concatenation of All Words">LeetCode—30. Substring with Concatenation of All Words</a></li>
<li><a href="http://wuyunjie.top/2019/04/22/LeetCode-31-Next-Permutation/" title="LeetCode--31. Next Permutation">LeetCode—31. Next Permutation</a></li>
<li><a href="http://wuyunjie.top/2019/04/23/LeetCode-32-Longest-Valid-Parentheses/" title="LeetCode--32. Longest Valid Parentheses">LeetCode—32. Longest Valid Parentheses</a></li>
<li><a href="http://wuyunjie.top/2019/04/23/LeetCode-33-Search-in-Rotated-Sorted-Array/" title="LeetCode--33. Search in Rotated Sorted Array">LeetCode—33. Search in Rotated Sorted Array</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>第四周LeetCode</title>
    <url>/2019/04/18/forth-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第四周LeetCode刷题记录"><a href="#第四周LeetCode刷题记录" class="headerlink" title="第四周LeetCode刷题记录"></a>第四周LeetCode刷题记录</h2><a id="more"></a>
<ol>
<li><a href="http://wuyunjie.top/2019/04/14/LeetCode-20-Valid-Parentheses/" title="LeetCode--20. Valid Parentheses">LeetCode—20. Valid Parentheses</a></li>
<li><a href="http://wuyunjie.top/2019/04/14/LeetCode-21-Merge-Two-Sorted-Lists/" title="LeetCode--21. Merge Two Sorted Lists">LeetCode—21. Merge Two Sorted Lists</a></li>
<li><a href="http://wuyunjie.top/2019/04/14/LeetCode-22-Generate-Parentheses/" title="LeetCode--22. Generate Parentheses">LeetCode—22. Generate Parentheses</a></li>
<li><a href="http://wuyunjie.top/2019/04/16/LeetCode-23-Merge-k-Sorted-Lists/" title="LeetCode--23. Merge k Sorted Lists">LeetCode—23. Merge k Sorted Lists</a></li>
<li><a href="http://wuyunjie.top/2019/04/16/LeetCode-24-Swap-Nodes-in-Pairs/" title="LeetCode--24. Swap Nodes in Pairs">LeetCode—24. Swap Nodes in Pairs</a></li>
<li><a href="http://wuyunjie.top/2019/04/16/LeetCode-25-Reverse-Nodes-in-k-Group/" title="LeetCode--25. Reverse Nodes in k-Group">LeetCode—25. Reverse Nodes in k-Group</a></li>
<li><a href="http://wuyunjie.top/2019/04/17/LeetCode-26-Remove-Duplicates-from-Sorted-Array/" title="LeetCode--26. Remove Duplicates from Sorted Array">LeetCode—26. Remove Duplicates from Sorted Array</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书|2021阅读]--《如何阅读一本书》</title>
    <url>/2021/05/14/Reading_2021--How_to_Read_a_Book.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>如何阅读一本书<br><a id="more"></a></p>
</blockquote>
<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><iframe src='https://www.xmind.net/embed/3TzT/' width='750' height='1000' frameborder='0' scrolling='no' allowfullscreen="true"></iframe>]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-4-重建二叉树</title>
    <url>/2021/04/26/JZ4-rebuild-binaryTree.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><a id="more"></a></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:   [1,2,3,4,5,6,7],[3,2,4,1,6,5,7]<br>返回值: {1,2,5,3,4,6,7}</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>考察二叉树很经典的题，需要理解前序遍历、中序遍历的方法，然后据此重建二叉树。</p>
<h4 id="二叉树的遍历方法"><a href="#二叉树的遍历方法" class="headerlink" title="二叉树的遍历方法"></a>二叉树的遍历方法</h4><blockquote>
<ol>
<li>前序遍历：根左右</li>
<li>中序遍历：左根右</li>
<li>后序遍历：左右根</li>
</ol>
</blockquote>
<p>一般使用递归方法实现遍历，在遍历过程中每个子树都可当作一颗新树递归处理。此外也可以利用栈实现非递归的遍历方法。</p>
<h4 id="方法1-递归方法"><a href="#方法1-递归方法" class="headerlink" title="方法1: 递归方法"></a>方法1: 递归方法</h4><p>对于任意一棵树，前序遍历的形式总是：</p>
<blockquote>
<p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</p>
</blockquote>
<p>中序遍历的形式总是：</p>
<blockquote>
<p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p>
</blockquote>
<p>所以在中序遍历中定位到根节点，就可以得到左子树和右子树的节点及节点数目。由此可以进一步在前序遍历结果中，分别得到左右子树。依次类推可以递归构造出子树的左右子树，知道最终左右子树都只剩一个节点，得到一颗完整的树。</p>
<blockquote>
<ol>
<li><p>在中序遍历中对根节点进行定位时，一种简单的方法是<strong>直接扫描整个中序遍历的结果并找出根节点</strong>，但这样做的时间复杂度较高。</p>
</li>
<li><p>考虑使用<code>哈希表</code>来快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，对中序遍历列表进行一遍扫描，构造出这个哈希映射。在此后构造二叉树的过程中，只需要 <code>O(1)</code> 的时间对根节点进行定位。</p>
</li>
</ol>
</blockquote>
<h4 id="方法2-非递归-迭代-方法"><a href="#方法2-非递归-迭代-方法" class="headerlink" title="方法2: 非递归(迭代)方法"></a>方法2: 非递归(迭代)方法</h4><p>根据前序遍历原理，对于前序遍历中的任意两个连续节点 <em>u</em> 和 <em>v</em>，只有两种可能的关系：</p>
<blockquote>
<ul>
<li><em>v</em> 是 <em>u</em> 的左儿子。因为在遍历到 <em>u</em> 之后，下一个遍历的节点就是 <em>u</em> 的左儿子，即 <em>v</em>；</li>
<li><em>u</em> 没有左儿子，并且 <em>v</em> 是 <em>u</em> 的某个祖先节点（或者 <em>u</em> 本身）的右儿子。<ul>
<li>如果 <em>u</em> 没有左儿子，那么下一个遍历的节点就是 <em>u</em> 的右儿子。</li>
<li>如果 <em>u</em> 没有右儿子，就会向上回溯，直到遇到第一个有右儿子（且 <em>u</em> 不在它的右儿子的子树中）的节点 <em>a</em>，那么 <em>v</em> 就是 <em>a</em> 的右儿子。</li>
</ul>
</li>
</ul>
</blockquote>
<p>用一个<code>栈 stack</code> 来维护<code>「当前节点的所有还没有考虑过右儿子的祖先节点」</code>，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，用一个<code>指针 index</code> 指向<strong>中序遍历</strong>的某个位置，初始值为 <code>0</code>。<code>index</code> 对应的节点是<code>「当前节点不断往左走达到的最终节点」</code>，这也是符合中序遍历。算法流程如下：</p>
<blockquote>
<ol>
<li><p>用一个<code>栈</code>和一个<code>指针</code>辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p>
</li>
<li><p>依次枚举前序遍历中除了第一个节点以外的每个节点。</p>
<ul>
<li>如果 <code>index</code> 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 <code>index</code>，并将当前节点作为最后一个弹出的节点的右儿子；</li>
<li>如果 <code>index</code> 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</li>
</ul>
</li>
<li>无论是哪一种情况，最后都将当前的节点入栈。</li>
</ol>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li><p>解法1  递归方法(<strong>直接扫描</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> [] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startPre &gt; endPre) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == pre[startPre])&#123;</span><br><span class="line">                root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + i - startIn, in, startIn, startIn + i - <span class="number">1</span>);</span><br><span class="line">                root.right = reConstructBinaryTree(pre, startPre + i - startIn + <span class="number">1</span>, endPre, in, i + <span class="number">1</span>, endIn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法1  递归方法(<strong>哈希表</strong>)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            indexMap.put(in[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> [] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startPre &gt; endPre) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> inRoot = indexMap.get(pre[startPre]);</span><br><span class="line">        root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + inRoot - startIn, in, startIn, startIn + inRoot - <span class="number">1</span>);</span><br><span class="line">        root.right = reConstructBinaryTree(pre, startPre + inRoot - startIn + <span class="number">1</span>, endPre, in, inRoot + <span class="number">1</span>, endIn);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>解法2 迭代法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span> || pre.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> preVal = pre[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="comment">// 左子树</span></span><br><span class="line">            <span class="keyword">if</span> (node.val != in[inIndex]) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(preVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右子树</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == in[inIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(preVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol>
<li><p>思考：如果给你中序遍历序列和后序遍历序列<br>思路类似于中序遍历和前序遍历的情况，只是在从后续遍历找根节点时，从后序遍历数组末端元素开始。后序遍历的形式总是：</p>
<blockquote>
<p>[  [左子树的前序遍历结果], [右子树的前序遍历结果] ,根节点]</p>
</blockquote>
<p>伪代码表示为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设元素在数组v中，并且尾结点的下标为 root_index, first &lt; root_index &lt; last,</span></span><br><span class="line">TreeNode* build(<span class="keyword">int</span> first, <span class="keyword">int</span> last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt; last) <span class="keyword">return</span> nullptr;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(v[root_index]);</span><br><span class="line">    root-&gt;left = build(first, root_index - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = build(root_index + <span class="number">1</span>, last);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，这里中序遍历起到很重要的作用，基于中序遍历可以分隔开左右子树。而仅仅给定前序遍历和后序遍历时，是无法得到唯一子树的。比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">树1：</span><br><span class="line">        3</span><br><span class="line">       /</span><br><span class="line">      9</span><br><span class="line">     /</span><br><span class="line">    8</span><br><span class="line">   / </span><br><span class="line">  5</span><br><span class="line"> /</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">树2：</span><br><span class="line">        3</span><br><span class="line">         \</span><br><span class="line">          9</span><br><span class="line">           \</span><br><span class="line">            8</span><br><span class="line">             \</span><br><span class="line">              5</span><br><span class="line">               \</span><br><span class="line">                4</span><br></pre></td></tr></table></figure>
<p>以上这两棵特殊的树，其前序遍历，后续遍历结果都是：[3, 9, 8, 5, 4]，[4, 5, 8, 9, 3]。难以构造出唯一的树。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">力扣官方题解——重建二叉树</a></p>
</blockquote>
</li>
</ol>
<p>[2] <a href="https://blog.nowcoder.net/n/c56eeb5b1845432a903db1c3c0cbc80a" target="_blank" rel="noopener">[编程题]重建二叉树</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书|2021阅读]--《围城》</title>
    <url>/2021/05/11/Reading_2021--Fortress_Besieged.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><code>这个时间落伍的计时机无意中包涵对人生的讽刺和感伤，深于一切语言、一切啼笑。</code><br><a id="more"></a></p>
</blockquote>
<h4 id="《围城》"><a href="#《围城》" class="headerlink" title="《围城》"></a>《围城》</h4><p>早已听闻过《围城》的鼎鼎大名，尤其是那一句<code>&quot;城外的人想冲进去，城里的人想逃出来&quot;</code>听闻依旧，似乎暗含了人生至理，但对其也似懂非懂。这段时间也总算有些许空余时间，把这本讽刺小说给读完了。</p>
<p>初读第一章头几段就被钱钟书先生的辞藻，比喻给经验到了，有趣而又不失生动。对场景心境的描述都恰到好处，或许要比亲眼看见都更加形象，钟书先生不愧为文学大家，仿佛这些文字都信手拈来一般。这里摘几段对场景的描写：</p>
<blockquote>
<p>“红海早过了，船在印度洋面上开驶着，但是太阳依然不饶人地迟落早起，侵占去大部分的夜。夜仿佛纸浸了油，变成半透明体；它给太阳拥抱住了，分不出身来，也许是给太阳陶醉了，所以夕照晚霞隐褪后的夜色也带着酡红。”</p>
<p>“谁知道从冷盘到咖啡，没有一样东西可口：上来的汤是凉的，冰淇淋倒是热的；鱼像海军陆战队，已登陆了好几天；肉像潜水艇士兵，会长时期伏在水里；除醋以外，面包、牛油、红酒无一不酸。”</p>
<p>“满天的星又密又忙，它们声息全无，而看来只觉得天上热闹。一梳月亮像形容未长成的女孩子，但见人已不羞缩，光明和轮廓都清新刻露，渐渐可烘衬夜景。小园草地里的小虫琐琐屑屑地在夜谈。不知哪里的蛙群齐心协力地干号，像声浪给火煮得发沸。几只萤火虫游来游去，不像飞行，像在厚密的空气里漂浮，月光不到的阴黑处，一点萤火忽明，像夏夜的一只微绿的小眼睛。”</p>
</blockquote>
<p>这样的描述在书中很常见，我这样囫囵吞枣地读完，也不知道是不是能学到几分。除了用词外，钟书先生对人物心境的描写也是活灵活现，很容易引起我的共鸣，尤其是对爱而不得的失恋心态，入夜难眠的困扰，仕途不如意的烦躁……这些心境让人感觉，这好像就是我经历时候的想法，尽管经过百十年的变迁，现在看来这些人之常情的伤心困惑还是如出一辙，或者也可以说历史总是惊人的相似，我们所经历的不过都是历史的重演，并没有什么稀奇事。对自己来说它的确是痛苦万分，感觉难以熬过的坎，确实对每个人来说都是第一次经历。但从全景来看，这也不过是芸芸众生所共通的人生经历，那么平庸平凡，甚至没有一丝波澜。或许人生之事，尤其是感情上的事，无非也就那几分田地，无论多新式的现代自由恋爱观，也逃脱不了冥冥之中的定律。扯远了，来看看钱钟书先生对心理感受的描写吧.</p>
<p>比如对上台时紧张的心理变化，这不正是上台紧张忘词的状态吗。只能着急，但再着急都记不起自己的稿子。</p>
<blockquote>
<p>“拚命追忆，只像把筛子去盛水。一着急，注意力集中不起来，思想的线索要打成结又松散了。隐约还有些事实的影子，但好比在热闹地方等人，瞥眼人堆里像是他，走上去找，又不见了。“</p>
</blockquote>
<p>浑浑噩噩的人生状态：</p>
<blockquote>
<p>“早晨方醒，听见窗外树上鸟叫，无理由地高兴，无目的地期待，心似乎减轻重量，直升上去。可是这欢喜是空的，像小孩子放的气球，上去不到几尺，便爆裂归于乌有，只留下忽忽若失的无名怅惘。他坐立不安地要活动，却颓唐使不出劲来，好比杨花在春风里飘荡，而身轻无力，终飞不远。”</p>
</blockquote>
<p>对失恋后一段时间心态的描写，感觉很相似，真的失去一个人，就是这样感觉世界昏暗，自己也再也融不进去，与一切都格格不入，仿佛置身到了另一个世界。</p>
<blockquote>
<p>”方鸿渐把信还给唐小姐时，痴钝并无感觉。过些时，他才像从昏厥里醒过来，开始不住地心痛，就像因蜷曲而麻木的四肢，到伸直了血脉流通，就觉得刺痛。昨天囫囵吞地忍受的整块痛苦，当时没工夫辨别滋味，现在，牛反刍似的，零星断续，细嚼出深深没底的回味。卧室里的沙发书桌，卧室窗外的树木和草地，天天碰见的人，都跟往常一样，丝毫没变，对自己伤心丢脸这种大事全不理会似的。奇怪的是，他同时又觉得天地惨淡，至少自己的天地变了相。他个人的天地忽然从世人公共生活的天地里分出来，宛如与活人幽明隔绝的孤鬼，瞧着阳世的乐事，自己插不进，瞧着阳世的太阳，自己晒不到。人家的天地里，他进不去，而他的天地里，谁都可以进来。“</p>
</blockquote>
<p>也曾经有个这样的幻想，钱钟书先生倒是把所有可能，所有境遇都给补全了，这就是失恋人心理还存在着的不甘和侥幸吧：</p>
<blockquote>
<p>”每出门，心里总偷偷希望，在路上，在车子里，在电影院门口，会意外碰见唐小姐。碰见了怎样呢？有时理想自己冷淡、骄傲，对她视若无睹，使她受不了。有时理想中的自己是微笑地镇静，挑衅地多礼，对她客气招呼，她倒窘得不知所措。有时他的想像力愈雄厚了，跟一个比唐小姐更美的女人勾手同行，忽与尚无男友的唐小姐劈面相逢；可是，只要唐小姐有伤心绝望的表示，自己立刻甩了那女人来和她言归于好。理想里的唐小姐时而骂自己“残忍”，时而强抑情感，别转了脸，不让睫毛上眼泪给自己看见。“</p>
</blockquote>
<p>思恋与错过，爱而不得地无奈与痛苦:</p>
<blockquote>
<p>”心里仿佛黑牢里的禁锢者摸索着一根火柴，刚划亮，火柴就熄了，眼前没看清的一片又滑回黑暗里。譬如黑夜里两条船相迎擦过，一个在这条船上，瞥见对面船舱的灯光里正是自己梦寐不忘的脸，没来得及叫唤，彼此早距离远了。这一刹那的接近，反见得暌隔的渺茫。无抵抗、无救援地让痛苦蚕食虫蚀着他的心。“</p>
<p>”那种情感，追想起来也可怕，把人扰乱得做事吃饭睡觉都没有心思，一刻都不饶人，简直就是神经病，真要不得！不过，生这种病有它的快乐，有时宁可再生一次病。”</p>
</blockquote>
<p>或许多年以后回想起曾经，遇见故人，也会被时间冲淡，木然无动于衷。把曾经的感情或立碑志墓，或暴尸荒野。只是不知道这个时间对我来说会是多久。</p>
<blockquote>
<p>“等柔嘉睡熟了，他想现在想到重逢唐晓芙的可能性，木然无动于衷，真见了面，准也如此。缘故是一年前爱她的自己早死了，爱她、怕苏文纨、给鲍小姐诱惑这许多自己，一个个全死了。有几个死掉的自己埋葬在记忆里，立碑志墓，偶一凭吊，像对唐晓芙的一番情感。有几个自己，仿佛是路毙的，不去收拾，让它们烂掉化掉，给鸟兽吃掉——不过始终消灭不了，譬如向爱尔兰人买文凭的自己。”</p>
</blockquote>
<p>在文末，鸿渐悲伤到绝望麻木，或许也不过如此吧：</p>
<blockquote>
<p>鸿渐走出门，神经麻木，不感觉冷，意识里只有左颊在发烫。头脑里，情思弥漫纷乱像个北风飘雪片的天空。他信脚走着，彻夜不睡的路灯把他的影子一盏盏彼此递交。他仿佛另外有一个自己在说：“完了！完了！”散杂的心思立刻一撮似的集中，开始觉得伤心。左颊忽然星星作痛，他一摸湿腻腻的，以为是血，吓得心倒定了，腿里发软。走到灯下，瞧手指上没有痕迹，才知道流了眼泪。</p>
<p>不知不觉中黑地昏天合拢、裹紧，像灭尽灯火的夜，他睡着了。最初睡得脆薄，饥饿像镊子要镊破他的昏迷，他潜意识挡住它。渐渐这镊子松子、钝了，他的睡也坚实得镊不破了，没有梦，没有感觉，人生最原始的睡，同时也是死的样品。</p>
</blockquote>
<p>此外，本以为是书中金句应该出现得比较正式，至少是个什么深沉的感叹，隆重地引出这样的人生哲学。没想到确实一次开玩笑般的谈话里引出了，甚至不是主角所言，鸿渐这时候还在旁边插科打诨呢：</p>
<blockquote>
<p>慎明道：“关于Bertie结婚离婚的事，我也和他谈过。他引一句英国古话，说结婚仿佛金漆的鸟笼，笼子外面的鸟想住进去，笼内的鸟想飞出来；所以结而离，离而结，没有了局。”</p>
<p>苏小姐道：“法国也有这么一句话。不过，不说是鸟笼，说是被围困的城堡fortresse     assiégée，城外的人想冲进去，城里的人想逃出来。鸿渐，是不？”鸿渐摇头表示不知道。</p>
</blockquote>
<p>各个角色的形象性格也很鲜明，随着故事情节的发展愈发饱满。比较出乎意料的是赵辛楣，最初出场时与方鸿渐争风吃醋的情敌，或许是网络爽文看多了，把这样一个角色初步定位成了一个小反派，为了苏文纨故意刁难不爱苏文纨的方鸿渐，自以为出尽风头，反而弄巧成拙。看着就好像故意为了衬托方鸿渐而设置的一个悲剧角色。但愈到后面愈发感觉到赵辛楣可能是书中最为直率坦诚的人物了，也是我在里面最喜欢的角色。最初开始发生改观是他作为方鸿渐情敌，与之争论时发表的意见，语出惊人：</p>
<blockquote>
<p>“教书是开发民智，板报也是，两者都是精神动员，但论影响，还是教育来的深。”</p>
</blockquote>
<p>这么一看突然肃然起敬，没想法这个反派人物还有这样的思想高度，确实比网络爽文里面的无脑反派立体多了。看起来只是个因为爱情的醋意，冲昏头脑的有志青年。后面当他与方鸿渐和解，成为朋友后，大量的笔墨对他进行了进一步的描写。重情重义，为人坦诚，风趣可爱，这时候反过头看他开始的表现，反而感觉合情合理，衬托出他的深情与坦然直率。当然也并不是个完美人物，但这些已然让他散发出独特的人格魅力，不禁想跟他学习一些东西。说起来，书中看见他在喜欢了二十年的苏文纨结婚后，发表了这样一番话：</p>
<blockquote>
<p>“我没见过曹元朗，最初以为苏小姐赏识他，一定他比我强；我给人家比下去了，心上很难过。那天看见这样一个怪东西，苏小姐竟会看中他！老实说，眼光如此的女人就不配嫁我赵辛楣，我也不希罕她。”</p>
</blockquote>
<p>这时候对他肃然起敬，感觉这个豁达开朗，拿得起放得下。但后面看也不尽然，这里面或许还是有傲娇生气的成分在。后面还是是不是透露出对这份感情的悲伤遗憾，对其的执念，要不然也不会因为汪太太与苏文纨相似而迷了心，这也算是他的一份情深吧。此外，他对朋友的热情体贴，绅士风格也很让人钦佩。比如专门为朋友温牛奶，为鸿渐疏通工作，备厚礼等等，都感觉这是一个值得深交的好友。最后杨绛先生说到这个人物脱胎于一个五六岁男孩，小孩子的直率天真或许是我们逐渐失去，也奋力追求的事物。</p>
<p>不过除了正文部分，杨绛先生写的后记也生动有趣，感觉丝毫不弱于正文。反而看见她描述的带有“痴气”的钱钟书先生，感觉比正文更加精彩，或许正因为钱钟书先生的”顽皮”，才有了围城里面大量幽默风趣的描述。</p>
<p>全书围绕围城这一说法，或许婚姻是并不会如想象中那么美好，挤破头想进入婚姻的殿堂，最后反倒是柴米油盐酱醋茶的争吵，感情逐渐消磨，让人想逃离这样的困境。但尽管如此，我反而对这座围城有种更加的期待，那种点点滴滴的美好甜蜜也令人向往，或许我现在还是被美好冲昏了头脑，因为刚刚失去，反而更加憧憬希望，感觉自己可以妥善经营，将矛盾拒之门外。不过也可能是目前的一厢情愿了，真正面对时，可能又是另一番心态了。</p>
<p>最后全文以老钟的鸣响结束:</p>
<blockquote>
<p>那只祖传的老钟从容自在地打起来，仿佛积蓄了半天的时间，等夜深人静，搬出来一一细数：“当、当、当、当、当、当”响了六下。六点钟是五个钟头以前，那时候鸿渐在回家的路上走，蓄心要待柔嘉好，劝她别再为昨天的事弄得夫妇不欢；那时候，柔嘉在家里等鸿渐回来吃晚饭，希望他会跟姑母和好，到她厂里做事。这个时间落伍的计时机无意中包涵对人生的讽刺和感伤，深于一切语言、一切啼笑。</p>
</blockquote>
<p>生活就是这般讽刺，巧合。但一切却又只能随着老钟的鸣响，滴答滴答的往前行进，无论多么不舍不甘，多么令人啼笑皆非的错过误会，最终都会化为人生长河里的尘土，消散在过去，带不往未来。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/Fortress_Besieged.jpg" alt="围城"></p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-8-跳台阶</title>
    <url>/2021/05/26/JZ8_Step_up.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><a id="more"></a></p>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>转换一下思路，其实就是在一颗树上不断搜索，其实可以很容易转化位斐波那契数列的形式，依靠递归算法求解：</p>
<script type="math/tex; mode=display">
F(1)=1\\F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)</script><p>那么进一步就可以利用斐波那契数列的优化方法，对该算法从时间复杂度和空间复杂度的角度，不断优化。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ8/JZ8.png" alt="递归树结构"></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-递归方法"><a href="#1-递归方法" class="headerlink" title="1. 递归方法"></a>1. 递归方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> jumpFloor(target-<span class="number">1</span>) + jumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-迭代方法"><a href="#2-迭代方法" class="headerlink" title="2. 迭代方法"></a>2. 迭代方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum = sum + one;</span><br><span class="line">            one = sum - one;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书]--2020 阅读清单</title>
    <url>/2020/09/11/Reading--2020_Reading_List.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>决定要开始好好读书了，需要一个仪式感来督促自己，写个书单记录一下<br><a id="more"></a></p>
</blockquote>
<h4 id="1-天蓝色的彼岸"><a href="#1-天蓝色的彼岸" class="headerlink" title="1. 天蓝色的彼岸"></a>1. 天蓝色的彼岸</h4><blockquote>
<p>这本书是一个温馨的童话故事，由 <strong><code>梁忆云</code></strong> 小姑娘倾情推荐。从一个小孩子的角度描述了去世后的世界，没有天堂，没有地域，只有<code>天蓝色的彼岸</code>，那是我们的最终归宿。</p>
<p>没有花大量笔墨描述另一个世界是什么，而是回到了原来的世界去弥补遗憾，顺带看看没有了<code>我</code>的世界会不会不一样。遗憾的是，世界照样会正常运转，只有最亲近的人会为<code>我</code>哀思。哈里从不可思议到不留遗憾向世界告别，整个过程穿插着各种人物的小故事，有阿瑟的温馨，也有依旧等待着温斯顿的斯坦。它教导我们: <strong>要珍惜生，但不必畏惧死</strong>。很治愈。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/The_Great_Blue_Yonder.jpg" alt="天蓝色的彼岸"></p>
<h4 id="2-追风筝的人"><a href="#2-追风筝的人" class="headerlink" title="2. 追风筝的人"></a>2. 追风筝的人</h4><blockquote>
<p>这本书还是去年开始读的, 或者准确来说是<code>听</code>的。去年刚上研究生独自留校, 在学校附件租房, 晚上回去的路上十分宁静寻思找点事做。从最最开始听歌听相声后, 开始逐渐喜欢上了听书, 也是这段时间在喜马拉雅上听了<code>追风筝的人</code>。但后来开学后没时间听书了, 也就搁置了, 一年了也没看完最后两章结局(这拖延症也是绝了)。最近两天开始读书, 又把它拿出来读了读。</p>
<p>最开始听说这本书时, 以为是逐梦+友谊的治愈类小说, 但实际上是遗憾、成长, 以及阿富汗的战乱, 二十年后的物是人非。阿米尔和仆人哈桑少年的友谊纯粹而干净, 但在残酷的社会环境现实面前, 懦弱而渐生偏见的阿米尔, 选择了沉默和逃避。他做了最错误的选择，设计赶走了哈桑, 可以<code>“为你，千千万万遍”</code> 的挚友。此后阿富汗战乱, 社会动荡, 哈桑也就此与阿米尔阴阳两隔。之后是寻求救赎的成长, 阿米尔收到拉辛汗来信决定赴约阿富汗并救回了哈桑的儿子, 自己的侄子索拉博。他不再是少年时对哈桑沉默逃避的阿米尔, 是在寻求救赎中勇敢果决, 抛弃偏见挺身而出, 最终坦然接受的阿米尔。阿米尔与哈桑的友谊固然光芒闪耀令人生叹, 但阿米尔的成长却更加打动人心。</p>
<p>在故事结尾, 作者对<code>结局</code>进行了一个简短讨论。</p>
<blockquote>
<p><code>阿富汗人喜欢说: 生活总会继续。他们不关心开始或结束、成功或失败、危在旦夕或柳暗花明，只顾像游牧部落那样风尘仆仆地缓慢前行</code>。</p>
</blockquote>
<p>或许我们有时候并不知道人生的方向, 路的终点, 但也不必知道, 我们在风尘仆仆的路途经历或许更加诱人而回味。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/kite_runner.jpg" alt="追风筝的人"></p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 GitHub 下载单个文件夹</title>
    <url>/2019/11/16/githun-download-single-folder.html</url>
    <content><![CDATA[<p>在<code>GitHub</code>上浏览开源项目时或者在查看自己的仓库时，<a id="more"></a>我们可能只需要其中单独几个文件夹下的内容，而不需要整个仓库。但一般<code>GitHub</code>只能克隆整个仓库。可以通过一个在线网站<code>DownGit</code>自动打包下载对应文件夹：</p>
<blockquote>
<p><a href="https://www.itsvse.com/downgit/#/home" target="_blank" rel="noopener">DownGit</a></p>
</blockquote>
<p>只需要找到仓库中对应文件夹的url，输入之后，点击 download 自动打包下载。<br><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/DownGit.PNG" alt="DownGit"></p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书|2021阅读]--《月亮与六便士》</title>
    <url>/2021/04/22/Reading_2021--The_Moon_and_Sixpence.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>2021阅读开始啦，尽管之前也零零碎碎看了几本书，但我还是适合写写叙事类的小说吧，今年就从《月亮与六便士》开始了。<br><a id="more"></a></p>
</blockquote>
<h4 id="《月亮与六便士》"><a href="#《月亮与六便士》" class="headerlink" title="《月亮与六便士》"></a>《月亮与六便士》</h4><blockquote>
<p>阅读这本书的动机不大，只是最近失恋了，想多读读书提升自己，恰好这本书名声在外，没看书评和简介就开始读了。好巧不巧，这本书还真就包含了一部分爱情和梦想，跟预想的治愈心灵大相径庭，反而有种雪上加霜的感觉，这是天意吗/(ㄒoㄒ)/。</p>
<p>刚看开头枯燥难懂，讲的都是什么艺术家，什么艺术体系流派。咋一看真被唬住了，以为是一本介绍文艺复兴的纪实史，或者是针对开头介绍的人物的个人传记，会包含各种高深莫测的艺术赏析思想和术语，没想到到后面画风突变，又变成了一段爱恨情仇的小说。有人说这本书是讲追逐梦想的，也有人说这里面是包含了一种不正的爱情三观，只是被出版商的把戏炒成了畅销书。从我的角度来看，还是有收获的吧，这本书的故事并不轻松，甚至可以说有些沉重。结局也不好评判，对生活有不同态度的人会对结局有不同的看法吧。</p>
<p>首先从梦想的角度看吧，斯特里克兰依旧被塑造成为了一个性格怪异的传奇人物。尽管作者在文中提到:</p>
<blockquote>
<p><code>人类天生具有制造神话的特性，对于那些出类拔萃的人物，人们对发生在他们身上的奇闻逸事往往好奇心极强，编造出一个个传奇故事，然后对此深信不疑，达到近乎狂热的地步。这其实是浪漫主义对平庸生活的一种抗议。因此，一些传奇故事顺理成章地成为铸就不朽英雄的通行证。</code></p>
</blockquote>
<p>但实际上最后毛姆还是造就了一个与众不同的斯特里克兰，或许这样的大师本就与众不同，才能在芸芸众生之间鹤立鸡群。另一方面也或许正因为他们是大师/天才，业界传奇，所以他们的一切都被放大了，成为解释他们成功的理由。斯特里克兰四十多岁抛家弃子，放弃衣食无忧的生活走上了追逐艺术的道路，而且他很笃定，他不在意别人的看法，这是真的不在意，这是笃定地不断向前，不需要别人地认可，只是表达自己所想，活在自己自由的世界里。从生活环境的角度看，他是不幸的，大多数人都把梦想艺术看作酒足饭饱之后的精神满足，只有保证温饱后才能追求高层次的精神需求，这正式<code>马斯洛需求金字塔</code>，但斯特里克兰不一样，他似乎更看重自我实现上，当然这可能是我的片面理解。从这一点来说对主角很敬佩，但我也绝不大可能像主角一样放弃一切去逐梦，打破精神上的那层枷锁，实现自我。可能我是个大俗人吧。</p>
<p>如果看斯特里克兰的爱情，可以用一塌糊涂来形容吧。抛家弃子，拆散救命恩人的家庭，最后在孤岛上也留下苦命的妻女。可以说他似乎完全不在乎别人，他只在乎他自己还有他的画家梦，或者说是他对一种美，对一种精神上的追求，懵懵懂懂。但从他的绝情上看，确实描述得入木三分，对不爱的人那种绝情的言辞，真的让人很心痛，却又无懈可击，他这样的人活在自己想要的世界就已然足够了，别人的非议无关紧要，别人的生死哀愁痛苦也入不了他们的内心，可能连同情都没有，只有不屑一顾。从这方面来说，尽管敬佩他这样的处事态度，但这样的人却也是无论如何都喜欢不起来。</p>
<p>最后引用两段平常人的平庸爱情吧，感觉这是大多数人的人生：</p>
<blockquote>
<p>我能想象他们的生活，无灾无祸，日子过得踏实、体面，还有两个端庄、可爱的孩子，他们注定会弘扬良好的家风和地位。夫妻两个会在不知不觉中慢慢变老，看到一双儿女长大成人。到了适当的年龄他们的儿女便会结婚生子，漂亮的女儿将来会做个贤妻良母，生出健康活泼的孩子；而帅气的儿子也会成为英气逼人的男子汉，没准会成为一名军人。最后，这对夫妻开枝散叶后就会体面地隐退，子孙承欢膝下，过着充实、幸福的生活，到时寿终正寝，入土为安。</p>
</blockquote>
<hr>
<blockquote>
<p>爱情需要人们全神贯注，它使人忘掉自己去爱对方。最聪明的人虽然可能知道爱有尽头这道理，在实际中却不愿相信这一点。人们明知爱是虚幻，却还是为其放弃实实在在的东西，于他们而言，爱情胜过现实。爱情使一个人变得更强大，同时也使他变得更渺小。他们不再是自己。他们不再是人，而是成为一个物件、一个工具，要实现对于他们而言十分陌生的目的。</p>
</blockquote>
<hr>
<blockquote>
<p>“上帝的磨盘转得很慢，却也磨得很细。”<br>碰上这种情况一准会说：”魔鬼为达到目的总是会引用《圣经》。”</p>
</blockquote>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/The_Moon_and_Sixpence.jpg" alt="月亮与六便士"></p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
</search>
