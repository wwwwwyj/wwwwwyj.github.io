<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo学习记录-博文加密</title>
    <url>/2019/11/16/hexo-learning-record--post-encryption.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="密码是 password" />
    <label for="hbePass">密码是 password</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="77fa5be6fed2d407a88ebb433f7f586eeace7d6f5171c17aef3a81aeba17e56d">818ffb39eb08dc7f13d5091f8a8f23c74cbcacf9d9efc5a1642c7ce851f7a2cca16e40aae9f8b3a7cfd18a133ef0859b982999ae55cdd79958a18d381cf93b0184c5fc7597fbe1ff53861ac035aa40e7ed09f930b69762c7ba529ba705428eeb0bd56fa727216c8a4b6a8079a205f214439b1eee967f2d56bd584ace969d7aa65b7b007e79691869b0453d312e4a86536df140e382ff630abbb475d551ea2f2a194d35e83b3bf6591ef4fa058c39db1a1c3b718427aaa867ce1fa0326ab0201510b208adc6a3814e96279ee824d2cbd216726a06df5605bb0441b398f24ac4aa708655a5fe415df8c9735c0f931c86b4dc42c336c272012d8ca716288bbb825d48ac68f7248bd46a81ffe415f6158b1831a18aa8eeb4f308f8e7656fc7aa0d73cb9251c1d87dfb85d6a0ac450bdc8de0f70610b6810c3704ea941f6610ea39087fcb063ed9088af7091a83de257e31ef7b1ab65129923e6211845527900985314e4b51d5d4a6e9f34d3b7d1ac31705c42110d7991409d8cc44b490a6b9ae824444e34ec6905c08ceaa748f73c609839aa7fccfaacd90400bef600a1823233518648b82eaf24cdbb91e38649d60dfd3a209f5274d1ac2acd778647b2a4f0fa8ee4fa88dd70cfe106ce3d14c986face0c19a7bec1996243721a1200a615b81785b61a51301ee8673199636a50cca2813b60250b33ac38f807c494e40e51ab5a51a01bb213842d0779b49b1b3b59b99c63894f7e8bff5ec1ada82b9e3d8c538ff2396d46ba8d7d305a06694fef4019310b0e81598b6fd2f31e256fca15d667b8c6fc96f7b62216b4480db7160f5ffcc65b5f52d1d260c43241083cc9bb022547201ed9583994257ec0816613bb5828475d0bf2a37fbb828ca554dc56d2d2a9ecbfed122be2009cafb5974fa8edb13a4759ef27b91f2c5ebb99ded649edf00e9259bd5eda19acfeb2e321857bd9eda5bbddb6a800d7d1967468568c90fd49f1a85233cf787011dcd2d74486d61184ff13dac072a83f2df4026f71769ba5dc5df1f1dd8474ec212006d1c3a8c0880cdc810fab2df97e4fe09108b583cbcc11fb5cc8e314271329292d167abdfcf07a888e9cd30896bfe2f2a226cb5182e7fca300adc775cc8f8441486b8f93bad378f18f1d938e36bdcbc003b8535c02bb68f14b701bb103b228b4ccabd893fb880bc8c61e33a18cdf185b52bb3a17a2a9b8a0a1dfeb4923a9e7aa152943ee2d3bccb1506bc9221ac3953e24699415bf2cbab350ad82fb8ad9c113b309ac6d965d286c18c29d867771ca72e507ca2583f825cf9981df7fa7e458b93cb26dd22f607e68ac326e08077a2a59b74b3e8451d58a0d5d0e30f65dbc59846a654b33deda3d115dcc21f8df26554942b424e4ee7b8dc276938b1e6f2b5b0b82cb23fbd20abbf7a12a00c69b97c392b146a4b127d0802118b3aab543fc76f54b01351063090071657758cc4ac103b8169038757c3db5c933fce25a8578781024d4242b964ea3c0722e46ab1c867bebf10bd129f2a4e86b05130b7f911b1f9b9d1c3dd26da0b46f3e5cd11172c5daca6b1ae5b322afb73014e10fa9d823ba9aff1ebbee6b4059fc4f5a99ffad5db5afe23067cd3e7a223e3eec5f81eda2643dc3854916c660e5764a5fca419ce4574f57e51c4f3874fa3b2b278098c4d412989d5534d1ee24741193bfbf10563a73ee14e174c22ae9c015104b87b36abf48a06281cff66e4c9df44066bf68f54fa4c225fa2d6aa7a233f8322c3ac0c07316cfc20b7211e15f2c0aad834248ed7e98d07e4262cc7b595583fc8dabf11e78d857bde0ba38268e004ad079544126201c858664ba21aeb663c1cab40b12cfd63d8d09f3ec376b7268a5d491294e7503834f1b4afce6167b81c54df34705a756b44ce5a7d1074684e13840719adcef8adddd44e12093fd5661794fcf31e949f0b169d3180d146bffe3ec4e1e026e757dbc697b2cad5be56df0fe357c61d2fa625394e800e9a9f24671cb6cdbc344692c8ded8c79c0a4cafcf688a746fb257323b04a2956f297aa014968e8a5bb66c9abebc1193a2a840820d97fbbb653975a1d56b4943bb5046b89de996b367c17d8fc6658be8517c5008348cd5f0b9fce0bc1d58736a892402e8c5b58eebb145ddd90fc13b74bd7f3ef8fba7e5861acb3357fbdf3bb651ff077c5a47a6771f4cb1a821a3785b47cb39cbc33febd6a0a69f439f99c6119fd18246c857ec43b2d682e3a83dc6599e2323f6ae07a1687be365ebd7aad0188f7586b177ca7047ef72428026a3c7db2dbd7f07fb3c00850ceb288fa025bf68e967a67848df52a122b392ff03e998b27961fa9641f2f3f822ad39da17e93806ac7cfdcb0cec1aa1e8f31d07f2422b478944f396190299e3508c60956105a38cb82c21754d05d6948eaac78ba5c3aaa68594d8c81d3c9c1b6c84f0c94a01deefe058cd5a258b2a861e9846e20cea369b9173a4aba0403721a2a5fa05a49825455cc521d2e61ff423b44e17d589a328f98c769ad7292d59972f9b7c830c1ba69810ad74142b7a06ed05b5a5c998bca97196f99f334ce97e378167d20915974090d4a6e6f45e29b69dd7e81cac42c1294f38ce1dfaccbe51f3eaf661301d97c3fded67af615a60020a29d84c9d145f489b776bb7350ebf8238f06b9cd03288ecc58a2a7a43a83d19f89ba7fb910ca474f8b169a67d72a6c87fb9437a71d78c13daca49269d26b09ba4783e23ecce661bdae2d3b10c2c6ea0aa22e7dd36ded1cf0e7dddd8e13924c460f93e6e2cf78a128f9c381465b7ecede906d1c746ee5bd60229b16875cd82d8383f605c89e4ce3dd9f5067ac93d207c6353a475b842fb35bedc5b91b32835c5b456673a22c2239be58f70b8a725a5bec1c461216fb364bbbfdce8126ac11eab28c5f316d582f4aa4d501393855534b620c3e58631848f952a08abf93e95f488577cd63a3a348bd3f2d3fb51a93e4d9e4d6a595d51345e3821ce59093da6f2db7f7baff7c34dbd526766bff313a399f61c7106bd76b8d99be596f9fdbb221f60f58f6d5971e8236d0146889f124e94ca80988f6b16cb18306633dc65dbbc391f17ba7a5cd4ed2f3bcd3f461340c550a9a353737c30ad9dcc5c22e22c7557553b4454860f69eedc9f40793168f023d7342d02b140c0d0f4fab5b3f83f51430c1c1e8337235b0c14f79724eeaf8ad4c76e88587ce7ac2de9d3484840ee7f661f8221ae3ecc9a77f223af3658090cb8588cc0ee56ba414598540151c1af453070730c2c28af76192448ca146e8b39dd749e7cd23db6b5a5afc288318deeb3c3f44adffe5a884e64800624d9bdf3c754c1abbe391917b77c6283f08091f3ead401d5ca2c5a1b59c8cf0b10acea04c0e6036dfd89c2760c668c63e4810b3a03cc019d4ec179f9c0cb505d65bcb8efa51ee1b745f2d8bb372b0939fdb6718d533a0dac264f6a94c238e92ff78c6e872411a6675fee303a99e05b0ba45f68185e323a29bdcf35552b3156fa100b322da4b0710c975b06fb308e386697148ab663e6e8873f434c7e6b6a9490fef86e1b79b34465fb66f9d1b1bb2e92eeb2c128ce128be3c55eec88cf6af82c87de9ddf2f5130333bbd34dbf5023fff91c18c20a30725b8d0c61ac4414df2d040b7bbcd9e0a30b0b483e75c42b5fd1e37adebacfb5df53607b8943c244f81ebf7c5d9cdbeefadd00a8b4e244af1503c8677911af955ae8c4ac40081e704295660c3c4c68b27fe06effa8aa6ae7af4ac62abbfb5ce8ad83fb36bf2f12d202719954503ed4756180670257802761d84fc45c68b99c68b6913d65e11500e2ef6efbdcf3fcc3d57bdf591f343545179b78ae7f06136cff9e0f20a85129faba51432d0789a9892f34aa7c477f45b2c44ba321b4151fcd93347f43c6807948737a6927617eed2d70b4889c9cbdfc37bca158870b2d47e3a5771cc6fca5d49e69a4b3730b5c5017ba72516f679f67e64a456ee75549a7ecb811ec9dae9890a5aa82e7927651dfe00acaedb7516655ceb479e3945124962738b3e9c0438821c5dce6d563a590ad01765418cf1fc06e0845686271c81af59c6afdccc4e149f53e0833df48a7b96b43ec0ed79fbe04e91a962cd95fe5fa2acc2ea7f13aafd58b74f48aa643a7848972bd683ab6951897aa4afc66b7e82d6fa4d223f553fdb1ad7d3cc7a3cab891e5db8dad378d3bcf97d95638b95dd6902cd098e0b0590e7400785cfa1a6f645c63ee4505fd31c137a6c3d19d797eae891e34b2a5da705c7a263466aaa0e34ca3f0f957a94a913735e2f38e28f3320562af92846883ce3d696c5be428362b2c8adf4dfe1d13efc48ba95daa47e62c79f24ee5968c5e91bb41bb42d546512c5d2e3d5af06b19977d6f19dde8b363725ea9f92b4f444e9505af140decffb731b79280d9169861cb1ef6cf236739e61269a4f062a305676b4c98c41e42805201e3e943003c2fb0354bdfde5e2404fcf0b4884f189ee181e8efae01eaba64fef48f266e7349b027ec47415e7943541bb750141d8c42e620ee4c91c2e7d7e25041442cd6f9757ed3a213c621780ecafbb9e2b12cc472f0c83aa767e1858029a9513c74e56ed8edc36abbcaed822413096c009c60e7245c91b6da8819dc3ed647b63cbc1bfac32c690c9ed279b17319a2ec2c3771278a5f72745d212d2af8d38d6942ef43df4110d666d564ec6909578e2a0a2f960fd9340a9ad260a730f16e7813a1536bef5a236e5b77ee361552d84a4e235f98ae70393500d11d539226fc45a3ea31eaae1444f7064f4bad63e463d1e8e868acb8f9162fae7d20087690f816b9176495e357e818be5d9b11af86b1685a1dd8582d9817d3bd781bb6d4c0e12ebb01dc693c519d112387cd6bad227d6201dbaee61e76a40cb311af394ca5404f59f17154f062be7fc4ff7080191799b8e71fb658a0695c5f72857155e4af4c2ce62439c5179cfee3a5d2168f3bba6d0a04804969ed387f3671de0738ab3216319c794de805aec9be49294033c016f9dae18253a066e29a3b1b8037910e3b9b7cb4b3ef3ab7b787ec4a0a8abf65ca54ffe2564a5d1242f58432d3a3a107c35618dc62fb54333c509b5f654a9064336c804b672bdd200e2f7a419ab3564de92f62f80b4f2510ce589180107c6de56da1ae7d8caea96f6c62b95ea5ff1c1a329486e6661a5354b6dd15b9705e3fab91a849858cc71c0a019d5950b5d9f691deaac1f294b0b99f1561256cb3c79e3c204399c1b5879cf77401b5bd0a96c3ad378e06957ff637e8d7e1ba868fb907c237cc18262ce605200de80dfd28074b75abd055ec30e8485d6c0bfc0ba006f4e79b880784931cb91ec0f0d608b1cd330efeb46437ae502a4623315d48dd40cfdc5d01bc6cf443812d41282907050090eeac5f5b0e4aa40235cf23cdafee2b2fb5a7de0fd84c93aa7477125896cff030323370b1a3fa627260717ef11136dc78ee65cdeea851327c927b584094bfafa2d98907898734aedc7a4fffd38953778ca8b4658ec784fae7a96f75c2b086b137dd9080bd68470efcc47148a7b52f55a7100cc850e827d816fdcc72a6c02c3e09f85ae4ae0026dfbca9825f6decd2658c4da5b6fef7b69161e8374f553934369758e95e13b9f682a8906429abc46ed8344c5a399241d6ece5c9eef8341920828fa508e740cacd71a7232aa96f92d7f510c83b0ad9208ee84d7a2442005e64006d937fd409536498f02c1e95a5222df5b67e25eded37d90bd22e57e08459069d0d111df1cc1985e53ad0d6623dc52ca32f7f61ffb908e039225d8ac439ccf9563de42d6b5c7a941e0eedeb1554ae387f70ea0b40ed8cd41fc9c10d931c3b68892c49617e9a1bd193be2460951db6ab116ae3d34ef5b54c5d31fa8756cec268e38c8d04c0ed663f2a560120af45c96a1c03040a35642ec9d08d140bccc21a345377b8f193c2a6ae10ca5226de1c3ef2f308990131879e62aedaa4a375468c76ceba4594f60c5d0e8cc92a050d1a72327a0fb1fd15d2a64731c5aff0ccad7b5830f43f4abe2cd19f9403e54c6beeb0aac5bb984ac4bb2c7c2fb87145117f82d42c148373a1d195d4d9334fd43c60fd29f9610c9e46a3823023a562a44d54cce4b5b36aa828c7135a5fe68f3fdea6dad5e5ea306c337f5c3afe13a27a7fd6bd4004a2a424b7c33b5c5e08f4994b6f4b2a4711158b36153228172800acd8671c9cd6e99fca40ce6f1d4dc47f181ef88acf927af14900bacecf84188411bd83286904df6630562dd675a5ca129f0f1251c4f818d898bf233dabcc0da9c79e7eb417da7aac4d70289fb3e84a2c92a52fe55a053815ded1eae12b9e6a8872a0a859e116efe2c46af2adeae72c8a8a6c88e0ee48e1bdecd7e697dac91aff9c2f6cfffb0b0a92607bdb468fd044e2f2763a7001b3a40d0c7dd6529198332cc4b0b4543a0f97642dcc6ab68e958f66bc9cdefbc0387a9f96b98e8488cb2041dfbacd9ba7efeaba0eaed72e9ed5ef303d16e6306b63b4a1ff4207a19f117f31c3c3149ef4052be5c22bd032a24c3e23d8868f125c047d1c190f1211c08d2f9c1aa639607f0246775715f2d4d8efa24444a933d47a4b3cfaee7fee8d048e5b29622096162906c7d053c57a9bde0ad01ff507defc01f67cd90e71ef0f97545978a02e0b7aced57f08f65b7a39ed00ff4a87bcf2acfc68e19c61eb1f56fbd3e8b1be73763572e18b5a2def95b7678d793dc7b7102c1c3a386c9269d60f74e0a3ffe3d438edc1ff1ada4a2781fd7d7c8d85dc557679db9782f2ac3afa7a37a974fc75795cd80d155c9b8a451ccda45e5eafce61ea89f554242dffa2e70b59beaf46fb829085c8f610eae37582079ed19deb0704086c58f676372794fb1514d858c4dfc967a843d6b80930f19629f879d82ffb309cd75df83f3c9a7b078f135794dce2036a31c1af831a0ec75ae3243150e0fc639ac0bd95765a40f242e8c3f282683f42a73d73a151c1c4b138bec46b6eaa9d8994cea592a3c8122f5cd554b7e34c92f393b01c5d8aa752e2a9ed591076f7d774ffa64f926e0c82b5c75fd479d8d03bca940a07cbba02f6b89b3ce7458ba9bf6e9fd51d4d64a73b9833832d8fe4651e989e20fa97e475aa8b946ca3049bb192dc2adcd3792e35763199a0e23e6ae267d2c7ffbeabde73d087ce50636e10ac4ab402e52b0f1e3ab3ba80fb8e6d269195c85a60b92ad60d2eda8df41d620ddad674ba87dea22d1c482ff3677c4674ac6f831ed6b5003ebe8b9174ed309337f0071a98d0ee7198bc971f572e9ba737440341c0978a5d257816bd25f3c621c393e5b4c46171baf8fb8fc39434917422e0a1ca390f4df739e7085c8bd242c9a77ab6b9bd971f703a9caf405cf0de890d9c04315eb198fc4fc7d3d2fa4fc9cc36a61cdb5391b6bb4b7fbb0655f60d464db99baf864503a32dea5d503fb06cc62ed2e60ec0ed678418bf6649511873047e65e24cd8d303fb520df914e468a6ab71d2667c3bb6c3f99f4ec084591c210c97b7170c1082e4f4cf1f8e7c07ae31dce6f2bf5cce08f682e4cae50156b84b8e2978549a77394f0ffd9360085db514e31ab387637598e10f216e4ce7c678cda6980d48f6212e5fc6e25b996a6fe4e4144cf154a4c2ee3bd122cfc088d2356015c58c4b4666d2c5def6a90ab31e9c39e4dee4fcd907859311f1b2ac537591d568e9659ba1b445b2db387b799b106e5ec1713b82f72918773258844715cdcae15b1fdf4909d25c44fcca1a5976853986e20df1c89516fbb94e0c32cb7fc2d73fb47e590066506609ba6512250d4c4b1447ad364f00423bc34b26360c2213c177f133b36fa3c111dd3d85de6a70e0407f96931aba09dcc60f42753f49cde1acbd54b283397481003f9e144fa98b016f9bbee30a600b869723044746a62b96ffd48d774743d901ee184b4db0a49a2979d80a36e82da19fb4374f7fe6f3c689fba1fb1cd01d03b806db1f93a65011dbceb9eed6f1545f693c8c8c467f52dbb8c8e9630fa866d3397f93662c3008d9d0a3cff0e954dda24b300fdcdcd3d7a34be1449f6357829d867a643d49f3bca016723dabcd4a3369416f39ad71a319d90cfd39c8e358dce26433c03a1af6089c0e0b5f7b310d88269b928bb5c48905bcd8c72069542ee2fd03130c22f4041d6d7c16c146f0b2e5f6e79a85835e960af81d64acd1288de6a19a77fdaeef8a5dd21fb0cb06e229e52690d51e78d3cf9a0061ab13a13dee84810d6674d182d3da33bce908abe7ec7e7a35ff7ee6f538b1bcef75f892b19876cfe29fbdedb4300cf839366d61be096cac0bb3c352fd6ff4ea5b1750ed7e4e1dd9bcdd25882f9924a34af41e0e2b42009a67e898997dbafc3bdf69df3e3b4b86a32a7c7deac62797db0cf2a7cb7262ddd22147caea7071a3b2d20e3682ce0dcbef4cf7a625ba3e93667e1914ff75fd45ecaab1a23f44c2e2a9c028b1ef2a08ba3cf3bc5e2f69255463a3f1229e73c624cc6bab8626ab847ae081ed66e23100c9aa9172e17ee093b9e184d70c8e7913ed8ed706b0361a632f9249df3d4fffbcce3029f4b40e2219970b610a3eb4234fb9657df67d6484278a10503819da81db69a30d721edcacf3468cb7c2535d805ad44decff3c4ef606e57df2026df623c4890f390b5af4a761aa7057f61fd0acf95be342454c37eb92a846d92c858f3869cc105de438a110bf0176b0f4ac503d0b730cb863ea2f84179405906fd48479ceee4c284f71a9758b85ee790a9868b7e97cb16860566038d76f221548bbbc89736d0a475729993d0b1f829ae6aca1a5ea36d74eb3a4defebbee90fd00de67dc592980f243929715bbcbb6590998fd8368b554a49bd4a8d39674df23185a9729a5a37ec228ef42fded6ffa4fb8056dffefae4da149069af78b1207c2bf544542de7b2af610e0e74856539b010fa0bf6629d0a86134f67519745ffc5fbedabb970a91ac340af495efece5a85daedf42c9e9359ba1bfd01568837df6d927444f67aebbb8493340ccd055fe0a85535cd5b9a9f37d1526198bf524e4108af7221aa9d080ecdba2cf3d7caab31a30a8c7c06e875b3f4e6442101759c91283ab9f6e8e16fc9fadd21fa87d72e9f76675667807f51c4a2d9a9762094dc2b8f0ff80488e8d00e223b4dc0f50ec67da09f6c8cfe4f5d67acd9bea191f9af3b30623ad4b237e20626c39e11be4fd3156c5c9a8485d1aab4df194ac4494b6fb247cb2df431fb58e111f7816871a42c9890e372653839841dcf403a04368b2502b5a1c96d3b4abf631b297272422caa5dc105995c06b041ee432eb72d6519b299b3287acad660d1be6dc1a7b2ac204869fe19d139c54d39473ee215f51c302b583dd30b156c16a9f932f7991d1cd70a9f2d627b91e1972d4a0cef007fbe7ecdb6334f7017e50ab5ceb4d086753b60e08e53ac411b7b770f3b8b3526beb4bb2d5a80e314d9a774108cb45bd18b78c3ae86f6ced8bf44a781535dca748894fd46605a9fd055ab630ff65bc28a0c761f77e9c70679f85c269d3961e7f7f74edd37f9d592c4d34a6a4545b377907343dc18c4d4c2737b5c173f098c542e673178b7fc5e9a1b6123611e4c28d90a67467cc187c51f48c8e11c550bf9d505221249a4698f0abb9ad6dedc524d38ae6f51de51be21429ccbd3e93b0888b970bd93db54952dd2c7f8951f62330b4fd30513aa73f0954573f21bebbbbd98f94146c03195ad4884467c608a163d921868237ca60e1d67d5500178fd38f758720bc7ea96dbe0ddc18018355aedfc45e3a0c7158f8bccffa7e5f1e6aaeebf0b78b4fdd4723430bad48b928371318f5e837756248f40a2eebdd433a2f7cb9258f1ef91aab64ac464cdf68d658f9d65553d2cf9bacdc5127f454ccdafe71455d577e5001d717f125853842c583b7b3cc4c97c8c268756f2483d827bdd9ce80456a7c711e7e1234cdd792d99ff0b1717fe2f431ce76fe7689e33f1b46eee888e3e77adfa0b32c6763f579ce7ee190027495fb634a3f659fc9ab495e60322d8b00ba74a801f10a32667638f3d3c690bbeb97b9b1e4e6fb675c1cce259e693f612eba8b454be98e536ab9082689334a7bbda70ef966370939506a511e6833f585dea7efde3b26337b6509c3ec052478a5a19a82468436d95fca87e0ab58bb3cc53de1dbd7cc4bf41e04f986c9dcb43fc27a81728b08f7528770cf1a97d437f475a805962af9f96aba853b7e67995ec13132bc51496b5a215522c48716698fca73dde113175e993b22a14f92eab48a51b888a7a1c3f190359b7b1a72530507ddc448f2a3f193e53953ca9fedc4d1b4aa77dd75559e031c955b18e8f912450534bea95d886ee59cae699ce127c0417148659d1d747acc8df50e56196b19fc15c414df5cae3fad3f55a7cb5928dcdf589c033fae03138860ef213bfbbf378508404645a2bc4a59e854c56fdc21bc9b322a2f99655364b7b203e57599a6f6d7ba39558d2744d881409c8370e551ce7ebf0c4dd1435480e7595f29504e302b5280837a27d8797806211a2a16a63f824eae73b44a76aebad86eb3dee995a58fc48821fd8524bfd62c89e4dd39e59d960df75ce9ae3f7e62c48c35ed68eaaa9687eb1043daf8b001feae2d7dd4e6aa82e150d912b664dd8887f6f4422db3d0e3f9dc63ba5040383201cdc2d406785de46fc15df8d7cf4c8d9933b5409c9ff9b01ed8f086032c6a6865fd9293a4c30c0c8584e7048a716ba36fc96dea7bb6f1cc0a8197102213b19800e771a7f8558a2ee8fae21d82201a32826295752d070850122d618abc29847ebc19382ae0bef762dd2d8e18429d67109db52780a3ec75ed4dab3c7f9d2c9bb3c522ef6dd01d6562fba21427549a977e0fc3fa7ed4ba2f9fef8f14227807567e91c5b6a026fafc18969ee23faa51a1a0dfa8a8e62e8a1a8727ee519a07f838903db0dfe45ca58bd48bbd35fdc7460664f5470e96d5d3744ceb27602b63972f4be9f199d16d33ce3ad8c0f60c074886b84bdb5a9efb6b1e4065a5104e435a6d8c55f0af40fdbf1e68a5a32f2dde62c60edc42eaf390704195cecf6c880ea86ef035555d87005e5a297cc9e50a66f3b0e2fbff339228a82a2d1754582b8ccdcc7ff74a8a8b3e35d9bef5c528f69e45300893ad2c467cc36bef9f8ec48aaa96ff914b868be799da3ffcf50c8e8f43001456d89d88ac7d1b15e891314483344c0684909f13dc131622d769c3a4487291a38548de241c0bc0cecc3e472caf1ff7f57d0863549c724a1ac8a64c4ee44d641876ba045593c25024630afa146b20de66013bdae5848c50f0212c99b1119a4c589d43b41809b3d3847a9cee5cc152c467ffd518feb5946d54beee5963e0e16166b3fde939cfda71c0a935aa2b18094b0acfc5e2b5727a2cd0df7312c152846a77ce76331e0a87b1c343e0181677e75ca364f6b1e9e889ecfc3b4f7df6e59fdf568cac441e8c317b9a541c7fd61eb9b2fede20676ace6d0635403cd38adcadb6b15ebe7a74af8e4408e5a38c755f9c66ae58e4a95cd11f55b00cb62f8be43d83cf8c8a6313e603863d560817147926161f681ecc2e19d10bf31f63dacf3fea7b8ac6504b2c522c9335ac372e4ce457841951c065158f3404532359b3ad7e0f8fc49567bdf4bd3ba2c65d0af60e468a94ff2bae006f78a323df707a58749c2047a3c069d42b3137796cd05183815a7dc34e0ec391a7ce73ae60320e1ce65c4c20a330e173b075237150e53283ec95261fbc60f3ec7a30992fd344898f4b9f60acfb72ed60a98dffc26a4d53d3f1f63623cd06f28a6c18364a2d2571fcdf5b5f6f04d8d63dde2f77fd2db6e6d73bc43d88970d9dad59920f258adbc539bac44c6dd59d62dc368339b2671e3595529deb7fcc39b154bcd8a40f6f698733227d9433958f2855df5dcf96c6d68b728d806fb216f95632e748692dea981f53edd70352e4fc60532239d68fdea2190474a5a6f33f7777c2ca7d6422fe37cd9de57b5dc5675b8805e05187e6e5d740b9b7bb6e553813bc7d18f8cb7788bdd16e0cd32d820b76de33d19182fd9ccdb67e4962ea23f8a317d10a421f236f6c4cc491dd0bbd5e8a9d60448f2ba912ba79141c4be3a2a30685362e728af8f8522188f92c41a4dddb8c322d4cb446585a9630279d1606d697ac278e11c484b98a46662362e926c0501a4c58ee6902c39715fc0f34c080d85768d0a449240627cfd1df2d4f4eeca042e396833f977d6344fbaca0a65ac9d7fc76c5a6283e2591d15ba3c25034dec9c0d8c7b0c95d7467ba434de1dfa70fdc3292f6b1eba1d563876b999285c5c743e1f4c4f5f0813e51f8a04133f08f7a450b7b211650ca1f13e1e02148e78a8df3396f1bb938f7d786fd31de7b12ac729fbfa6f052fbc023f522a35a62ee8e340ef1ccb59aa537cbf1212262c45f8e1570c65052d687d51c5460f128e3318a8916d93a1f12086e50c70766aac9f088b81ab134641a1406b9cba907f247ac3e517d6ad3e98d0253cfeac89ef45b47a65348468389bcaa0105afd000900499291d9c00da35b1117c9405087e9f46f0094b362cdfa0a8b54a03a566b48de2ca431bf5a1ba130ada530ce03d030a838c4a04c11848feb3324163171bf6415ce73a1a2d0970cb615431825eaa042a09fd6d63e8ce1f22c6f0aa4fd0f8d7d1ad774b1daa9653234e417bca2af79e3cd7d2656fa486ebbd9d69283b540412e9be25aa266a0c1aff19acd323081cf3c90465a0837217922fc8736d45628807dc8e28159f71dbb729a6f15e3ed7a67a77716dbdcdcdbe3dc3a7fa2f1a9063bea281da8c44129516e5e419e20a35df819c7c8039e3883228ec1e1a9116990923f8cc6c4ed576fcb84b82373c26882bc623136c70588c342947a6463d6216d69ef7492a9d81f34ac23e7855f8fea23d513f3464be1c7643d5388fc043a5804fec9205e8a3d5a28fb51a4cbf3fb83568b446dc41372d66c4dd7d8ca1ed6dfab3afefb415eaa3924b365fed171324f59ceed75927ed97d16b2b4afb6577ac6262fcaaa7d4d94380977d04dccbc510411ce9aa461b85d9648ce0e927eed10569b07228d5e9dda60aae7af50f6a753a83824442651e0b7c7203b467396b6e3c1e069371ca432cd621e204e0d0d6de477d9b45eb1781ee063d6a1880d306905c6fa8a4037813deb16572638248f8fb028a1068db25608c6b1e34d667873371e152b27a45002df135fd1540064c55c50629d926e58700db9b0744ee039e7f7c8a990499054fe84872115ad490cec7e0c85dc9e5428c6089ef69e076ab9db10fe5deef408772af024d4b8ccf38748cc439b2f30108ff00a2bc4654ba3227f3637dd256d0b3d0f6c37e379c7ebce44d739cdc1e9540951791b70f09498fddad17f6baf81770f386f2d6db823feb6b7da602f18577c16a965ac54ee3476b4121c115e2d09386ac9cc9823d979654a3c7c568505c073847da0c253aa7a6536888b741ad1ca9fd9712392ff3ee98f410aecb48d9aafc4b746c6c8862eb2d813a6f2e681e50afb503aed1e8453ef70be5ef32f9daedd7520e5204bbc7933c1a2f8f316e8489f1ce6ea55ae01ff1c2e66aadc1361ae416bb738968768fe144e1ea128486db4303b76a4c0d2412ccc0e8d0a948f37f14560768dcbcb41807144f4b5f01df6e8594975df1d52c05a5a5fbc1a2fb3faabdd5aa3011eaded043a44328cff5868360ac0220006506014296923379b0c39dc018dedd881e3b6f828b2d49bd636b6669b3dec202d64700aa4fe4cfed5c3ff9734750fe97fd276ab4de3a0713f124a0daf7a8c0bd180396bb39243a30eec911843410d3aebcdf710d149ef28632f523ae39ac2066492a4d25d517ba90531668183ae5748c389de08bae99975c67d7743c105a6d040292cda973a466ca6f728baa5a4ef883688824ba5603c50e039da0776d316945f72c59ca49370275ccff4af70154d22c92583624801f7ecbbf22e3a1ac180be7521f3fcddfaef073ad9fcbfb467d0cd1d344ab9b47659895f0c236e127c17a174c5883d6243083ac080eeea0a0c15f6bda4ed76f38e1636a645c8b9a2dad32f591bc6b4580181c9234734283041bad38e2ead004520590190bea8e35b58224a467f813aed65db4692c5d6abcf7c557168e1b4a65d1091842b3dc21311a05dabdbff07a58311c91f6034a3f5adeda6d6584811c9356341e5ec6dde0e0b4ea98e6922a943b0f06264dfe7a4c8a7cfbb7a68af2dd31ba578c8d970e4f34ef328249f79a2b932eda4eee304490fee5faf6801aa88adb0e9f3ee8cfa05cc2cadb88617e3993bef37932454259254e5f5fa81e683dec6fff8da413dcc2e3c8db1de3e57b33296ba8c2d7797aa7e25ccf0e47ef874e859157a3f093c7c6c476174fa6bc9945bee343f34e76cb1d1af06917ab29890518c8b2e67f89ff7c7f436e44e36db6e0b58b0d1095c4c215a6ba3a735e1ea93699c696121499756faf1db453e25251f60fd3c89b991693fda42a053e7a2f2762505bc0f05631f19f744758b4fc0803fcaab259f5507a76aac5f9e2c067d2e7ddb2af2748a255e21f352bdb6a01b69f54267cc0b4100cbadbba80424b0091f9eab3d323a97d07ae65f1b6158bb4d17cc40c286435479bfd0abf3123d152a0f442b09adcefe59d592aeb0743cb32dfc73d42984525f524c52907c95b8349128f30eb2683c2e32d97b9363821c98287aae605e080ce40cb8cc21cb1df86f24d88f958f29dbf0daa88c31dc60be68cefccdae9d10e5106d733502219d29c0c38ec64fabb50f2afbaf183d5d06715e6f280a64d0429a3f5a8f2c28c65eff140d9099f4ea74cb0fbda57e35f6eed54646d3a3a1bb775b1736158d90ea552f6c164771c293f24a61eedc0f1f37c80875ee716149de26745ac94bdfeed561e6ef698b19570e46422f8ef691b230bcb9afa6a90ce79446376ee655766d1ce47ac607bffde36ef1e72542f1f26369e9fd4d5daf3c7b0f4110512d6cb48a42fe1e857d40c09f6457baf9aec6c9866759b125c750742cafefba404c3000477670359217d5b38da5ae430e34ba7479a3c021b6d15bf887d6c87862e33aac40384e906bf3bd90fe5eec52bc4a8404b611ca229e803a5131a141bc5117ff16d80f5a7f625fcbe4d0a74a7124bdc893d6194aba1ac0057c14585a88e4f907d339a58614d042f385b276c24f31faa7fa49c26fc5a687144f6adb07721e32079c7077eff94664a8d6629c0264e250e3fff276869f3c86e6bf4a726b38f8b4412fc9e370fe215c78e1ac064bfcd50c7439a1e3e014d42cbab83bf22fdc63205187838217e806d51b8ed623fd62870ec6648320600160f6e5b7e722422e140e6478a71909195b5efd497f38e1f17a6dab6f0ec914ac2de16281bee4f14e0a8cfc15bae816d8ce9ba54aae274fd8950125ca5f9d3d8f58ed775922aaf608272659f4a88584a3c3507f850dc04120abf0c59f62a3c33e843ebce28b26b6e928aa8c06a819a8c80b3a4e39f576dc751cd27d7ea03ea17dd86b62200c550e4b0bc9bffaa1380b7bd3751eb8f88b0373a582a429b107ff1e00395ac4fad944f7018b952ca3494150651294ab28eb0a717d7502ac2f1bbc2f04db98c3f5422647d64f60304b0a88ddca35281d40bf52eb6a71c8a85beacc445d1023b30b4301fd13b14646c526b90f0e901305d4697482124785a8657d557e2c339c768b38aa0de42d879d2e7dd7316bd283bf5a2e9e57213395aa52d0408b83f83f461e5be220ebb7ebb301131e5e04865b380b0f20522def1adc1ca616482c77054db3a72aab8a4cdf5ec1812fefab122fdf8e356e91693a146e7c8fda004192cb5cb83c2a0ee0e11a3d77d25cef80f8d0cfcd55b9a94c18f95a65b7a80b9d0f1010a84310</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>学习记录</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo学习记录--功能升级</title>
    <url>/2019/11/14/hexo-learning-record--Feature-Upgrade.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>增加一些新功能, 丰富一下博客内容和界面, 就是一些花里胡哨的东西。<br><a id="more"></a></p>
<h3 id="LeanCloud添加文章阅读量"><a href="#LeanCloud添加文章阅读量" class="headerlink" title="LeanCloud添加文章阅读量"></a>LeanCloud添加文章阅读量</h3><p>操作很简单，在 <code>LeanCloud</code>注册账号后，创建一个应用即可，主要参考官网教程和一些网上的博客：</p>
<blockquote>
<ul>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">开始使用</a></li>
<li><a href="https://blog.csdn.net/weixin_39345384/article/details/80787998" target="_blank" rel="noopener">NexT主题下，用Leancloud统计文章阅读量</a></li>
</ul>
</blockquote>
<p>这里需要注意的主要是需要安装 <strong>Web安全</strong> 模块，否者无法正常使用<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-leancloud-counter-security --save</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>主要参考这个博客解决问题 <a href="https://blog.csdn.net/w573719227/article/details/100704952" target="_blank" rel="noopener">HEXO博客使用LeanCloud报错“Counter not initialized! See more at console err msg.”</a></li>
</ul>
</blockquote>
<p>这里还有一个问题, 就是链接里带中文名, 所以导致链接在<code>leancloud</code>中以特殊字符形式存在, 在统计访问次数时出错。需要将其转换为英文的链接地址, 这里使用<a href="https://hexo.io/zh-cn/docs/permalinks.html" target="_blank" rel="noopener">Hexo-永久链接(Permalinks)</a>的方法，自定义链接地址，最终阅读量正常实现。</p>
<h3 id="永久链接（Permalinks）"><a href="#永久链接（Permalinks）" class="headerlink" title="永久链接（Permalinks）"></a>永久链接（Permalinks）</h3><p>可以在博客根目录的配置文件（<code>_config.yml</code>）中这样修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:entitle.html</span></span><br></pre></td></tr></table></figure>
<p>其中<code>entitle</code>是自定义的一个属性，同时在<code>.\scaffolds\post.md</code>中修改：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">entitle: </span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这样在编写文章时，可以在<code>entitle</code>输入指定字符，作为文章链接地址</p>
<blockquote>
<ul>
<li>参考文章<a href="https://blog.csdn.net/Likianta/article/details/79343427" target="_blank" rel="noopener">如何让你的Hexo博客网址使用全英文路径</a></li>
</ul>
</blockquote>
<h3 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a>不蒜子统计</h3><p>更新到新版本后，启用不蒜子统计很简单，只需要在主题配置文件中启用即可：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">false</span> <span class="comment"># 与leancloud重复，故注释掉</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure>
<p>应该也可以用leancloud实现类似功能，但懒得折腾了，就直接<code>不蒜子统计</code>一块用吧。</p>
<h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><p>启用字数统计需要安装一个插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>之后设置配置文件即可：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>
<h3 id="加载进度条"><a href="#加载进度条" class="headerlink" title="加载进度条"></a>加载进度条</h3><p>同样需要安装一下依赖库，不过他的安装方法与之前不同，不是用<code>npm</code>命令来安装，而是直接添加到主题的<code>lib</code>中：</p>
<ol>
<li><p>进入博客文件夹的<code>/themes/next</code>文件夹下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog_folder/themes/next-update # 注意转换为对应主题路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>载安装<code>Progress module</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-pace source/lib/pace</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>/themes/next/_config.yml</code>中设置使生效</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">bounce</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="GitHub图床"><a href="#GitHub图床" class="headerlink" title="GitHub图床"></a>GitHub图床</h3><p>在写博客时，我们常常需要在博客中插入图片什么的。这时一般需要一个图床，免费的图床有很多，但是上传文件后只能得到一个链接，不知道什么时候会丢失链接或者干脆图床网站不维护了。我们可以利用<code>GitHub</code>建立一个图床仓库，方便管理。顺便也可以练习一下<code>Git</code>的使用。如下图就是建立的一个图床仓库：<br><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/GitHubImageRepository.PNG" alt="GitHub图床"></p>
<blockquote>
<p>这里需要注意的一点是，GitHub图片的地址需要是源文件地址，比如上图的地址：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/GitHubImageRepository.PNG</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>之前一直用的<code>GitHub</code>下文件的url(<code>https://github.com</code>开头)，一直不显示，还以为是图片格式不兼容，笑哭。</p>
<h3 id="表格显示问题"><a href="#表格显示问题" class="headerlink" title="表格显示问题"></a>表格显示问题</h3><p><code>table</code>表格显示异常，直接不显示表格。一开始以为是渲染器，语法什么的问题，后来发现原来解决方法很简单，表格和正文之间需要空行。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">测试</th>
<th style="text-align:left">表格</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">正常</td>
<td style="text-align:left">显示</td>
</tr>
</tbody>
</table>
</div>
<h3 id="加入豆瓣书单"><a href="#加入豆瓣书单" class="headerlink" title="加入豆瓣书单"></a>加入豆瓣书单</h3><p>直接安装豆瓣依赖模块 <code>$ npm install hexo-douban --save</code>, 简单易操作。配置上需要在 <code>hexo</code> 配置文件中加入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">douban:</span><br><span class="line">  user: mythsman</span><br><span class="line">  builtin: false</span><br><span class="line">  book:</span><br><span class="line">    title: &apos;This is my book title&apos;</span><br><span class="line">    quote: &apos;This is my book quote&apos;</span><br><span class="line">  movie:</span><br><span class="line">    title: &apos;This is my movie title&apos;</span><br><span class="line">    quote: &apos;This is my movie quote&apos;</span><br><span class="line">  game:</span><br><span class="line">    title: &apos;This is my game title&apos;</span><br><span class="line">    quote: &apos;This is my game quote&apos;</span><br><span class="line">  timeout: 10000</span><br></pre></td></tr></table></figure></p>
<p>然后部署到主题文件中, <code>next</code> 主题下设置为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives</span><br><span class="line">  books: /books     # 这是链接到books页面</span><br><span class="line">  movies: /movies   #  这是链接到movies页面</span><br><span class="line">  games: /games   # 这是链接到games页面</span><br></pre></td></tr></table></figure></p>
<p>之后在启动过程中加入命令 <code>hexo douban -bgm</code> 自动抓取相关信息生成页面。 其中开启 <code>hexo-douban</code> 的命令中，<code>-bgm</code> 代表的是 <code>book、game、movie</code> 三个参数。</p>
<h3 id="加入搜索功能"><a href="#加入搜索功能" class="headerlink" title="加入搜索功能"></a>加入搜索功能</h3><ol>
<li><p>安装本地搜索插件 <code>hexo-generator-search</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
<p>安装之后，会在站点目录的 <code>public</code> 文件夹下创建一个 <code>search.xml</code> 文件</p>
</li>
<li><p>在站点配置文件 <code>_config.yml</code> 中添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Search </span><br><span class="line">search:</span><br><span class="line">  path: ./public/search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p><code>field</code>：搜索范围，默认是 <code>post</code>，还可以选择 <code>page</code>、<code>all</code>，设置成 <code>all</code> 表示搜索所有页面<br><code>limit</code>：限制搜索的条目数</p>
</li>
<li><p>主题配置文件<br>在主题配置文件 <code>_config.yml</code> 中找到如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  trigger: auto</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>
<p>确保 <code>enable</code> 设成 <code>true</code>。</p>
</li>
</ol>
<h3 id="加入评论系统-基于Valine"><a href="#加入评论系统-基于Valine" class="headerlink" title="加入评论系统(基于Valine)"></a>加入评论系统(基于Valine)</h3><ol>
<li><p>获取 <code>APP ID</code> 和 <code>APP Key</code><br> 先登录或注册 <code>LeanCloud</code>, 进入控制台后创建应用。选择<code>设置</code>&gt;<code>应用Key</code>，就可以获取<code>APP ID</code>和<code>APP Key</code>了。</p>
</li>
<li><p>在<code>next</code>主题中配置<code>valine</code><br>在主题配置文件 <code>_config.yml</code> 中找到<code>comments</code>栏目并开启<code>valine</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comments:</span><br><span class="line">  active: valine</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>然后在该配置文件中找到<code>valine</code>设置栏，开启<code>valine</code>并填入<code>appid</code>和<code>appkey</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid: # your app id</span><br><span class="line">  appkey: # your app key</span><br><span class="line">  notify: true # 评论回复邮件提醒, See: https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # 验证码服务</span><br><span class="line">  placeholder: 留言区 # 评论框占位提示符</span><br><span class="line">  avatar: mm # 头像配置</span><br><span class="line">  guest_info: nick,mail,link # 回复要填写的信息</span><br><span class="line">  pageSize: 10 # 评论列表分页，每页条数</span><br><span class="line">  visitor: false # 文章访问量统计 </span><br><span class="line">  comment_count: true # if false, comment count will only be displayed in post page, not in home page</span><br></pre></td></tr></table></figure></p>
<ol>
<li>由于<code>valine 1.4</code>版本后，不再支持自带的<code>邮件提醒</code>，所以这里使用第三方<code>Valine-Admin</code>，基于<code>Leancloud</code>的云引擎与云函数。功能更完善，主要部署方法可以查阅<code>github</code>:<a href="https://github.com/DesertsP/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a>。</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>学习记录</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>AdPart复现--问题集锦</title>
    <url>/2019/11/23/AdPart-Repeat-Problem-Collect.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在复现分布式RDF引擎<code>AdPart</code>, 复现过程中遇到了一些小问题, 就在这里记录一下吧。<br><a id="more"></a></p>
<h3 id="Problem-and-Solve"><a href="#Problem-and-Solve" class="headerlink" title="Problem and Solve"></a>Problem and Solve</h3><h4 id="g-编译问题"><a href="#g-编译问题" class="headerlink" title="g++ 编译问题"></a>g++ 编译问题</h4><p>因为对 <code>g++</code> 编译项目不太熟悉, 这也是第一次自己写一个完整的项目并用 <code>g++</code> 来编译, 难免许多基础都不会。遇到了下面这个报错:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">undefined reference to &apos;Foo::Foo(std::string)&apos;</span><br></pre></td></tr></table></figure><br>这个问题卡了我很久, 什么修改 <code>g++</code> 版本, 不使用<code>c++11</code>都试过，还一度怀疑是不是我代码写的有问题。后来发现是一个很简单的原因，没有在编译的时候将<code>Foo.cpp</code>(用这个来代指我的问题)添加进去, 也就是我编译的时候差不多是这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o testFoo</span><br></pre></td></tr></table></figure><br>但是实际上需要是这样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ main.cpp Foo.cpp -o testFoo</span><br></pre></td></tr></table></figure><br>修改完之后成功编译, 还是对 <code>g++</code> 不熟, 得抽时间学学 <code>g++</code> 怎么编译 <code>c++</code> 代码了。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<ul>
<li><a href="https://stackoverflow.com/questions/3656050/c-undefined-reference-to-foofoostdstring" target="_blank" rel="noopener">c++ “ undefined reference to ‘Foo::Foo(std::string)’ ”</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>AdPart复现</category>
      </categories>
      <tags>
        <tag>AdPart</tag>
        <tag>代码复现</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--1 走近Java</title>
    <url>/2021/04/23/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_1_Approaching_Java.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><code>世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。</code><br><a id="more"></a></p>
</blockquote>
<h4 id="1-Java技术体系"><a href="#1-Java技术体系" class="headerlink" title="1. Java技术体系"></a>1. Java技术体系</h4><p><code>JCP(Java Community Process)</code>所定义的Java技术体系包括了以下几个组成部分：</p>
<ul>
<li>Java程序设计语言</li>
<li>各种硬件平台上的Java虚拟机实现</li>
<li>Class文件格式</li>
<li>Java类库API</li>
<li>来自商业机构和开源社区的第三方Java类库</li>
</ul>
<p><code>JDK(Java Development Kit)</code>是用于支持Java程序开发的最小环境，主要分为三部分：</p>
<ul>
<li>Java程序设计语言</li>
<li>Java虚拟机</li>
<li>Java类库</li>
</ul>
<p><code>JRE(Java Runtime Environment)</code>是支持Java程序运行的标准环境，主要包括：</p>
<ul>
<li>Java SE API子集</li>
<li>Java虚拟机</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Java_technology_system.PNG" alt="Java技术体系"></p>
<p>按照技术关注的重点业务来划分，可以分为以下四条主要的产品线：</p>
<ul>
<li><strong>Java Card</strong>：支持Java小程序（Applets）运行在<strong><code>小内存设备（如智能卡）</code></strong>上的平台。</li>
<li><strong>Java ME（Micro Edition）</strong>：支持Java程序运行在<strong><code>移动终端（手机、PDA）</code></strong>上的平台，对Java API 有所精简，并加入了移动终端的针对性支持，这条产品线在JDK 6以前被称为<code>J2ME</code>。</li>
<li><strong>Java SE（Standard Edition）</strong>：支持面向<strong><code>桌面级应用（如Windows下的应用程序）</code></strong>的Java平台，提 供了完整的Java核心API，这条产品线在JDK 6以前被称为<code>J2SE</code>。</li>
<li><strong>Java EE（Enterprise Edition）</strong>：支持<strong><code>使用多层架构的企业应用（如ERP、MIS、CRM应用）</code></strong>的 Java平台，除了提供Java SE API外，还对其做了大量有针对性的扩充，并提供了相关的部署支持， 这条产品线在JDK 6以前被称为<code>J2EE</code>；在JDK 10以后被Oracle放弃，捐献给Eclipse基金会管理，此后被 称为<code>Jakarta EE</code>。(PS:扩展一般以<code>javax.*</code>作为包名，而以<code>java.*</code>为包名的包都是Java SE API的核心包。一部分曾经是扩展包的API后来进入了核心包中，因此核心包中也包含了不少<code>javax.*</code>开头的包名)</li>
</ul>
<h4 id="2-Java虚拟机家族"><a href="#2-Java虚拟机家族" class="headerlink" title="2. Java虚拟机家族"></a>2. Java虚拟机家族</h4><h5 id="2-1-虚拟机始祖：Sun-Classic-Exact-VM"><a href="#2-1-虚拟机始祖：Sun-Classic-Exact-VM" class="headerlink" title="2.1 虚拟机始祖：Sun Classic/Exact VM"></a>2.1 虚拟机始祖：Sun Classic/Exact VM</h5><p><code>Classic VM</code>只能使用<strong>纯解释器方式</strong>来执行Java代码，如果要使用<strong>即时编译器</strong>就必须进行外挂，但是假如外挂了即时编译器的话，即时编译器就会完全接管虚拟机的执行系统，解释器便不能再工作了。由于解释器和编译器不能配合工作，这就意味着<code>如果要使用编译执行，编译器就不得不对每一个方法、每一行代码都进行编译，而无论它们执行的频率是否具有编译的价值</code>。</p>
<p><code>Exact VM</code>因它使用<code>准确式内存管理</code>（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management）而得名。准确式内存管理是指<code>虚拟机可以知道内存中某个位置的数据具体是什么类型</code>。已经具备现代高性能虚拟机雏形，如热点探测、两级即时编译器、编译器与解释器混合工作模式等。</p>
<h5 id="2-2-武林盟主：HotSpot-VM"><a href="#2-2-武林盟主：HotSpot-VM" class="headerlink" title="2.2 武林盟主：HotSpot VM"></a>2.2 武林盟主：HotSpot VM</h5><p><code>HotSpot VM</code>是Sun/OracleJDK和OpenJDK中的默认Java虚拟机，也是目前<em>使用范围最广</em>的Java虚拟机。</p>
<blockquote>
<p>它是由一家名为<code>“Longview Technologies”</code>的小公司设计；甚至这个虚拟机最初<em>并非是为Java语言而研发的</em>，它来源于<code>Strongtalk虚拟机</code>，而这款虚拟机中相当多的技术又是来源于一款为<em>支持Self语言</em>实现“达到C语言50%以上的执行效率”的目标而设计的Self虚拟机， 最终甚至可以追溯到20世纪80年代中期开发的<code>Berkeley Smalltalk</code>上。</p>
</blockquote>
<p>它名称中的HotSpot指的就是它的<code>热点代码探测技术</code>。</p>
<blockquote>
<p>HotSpot虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器<strong>以方法为单位进行编译</strong>。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发<code>标准即时编译和栈上替换编译（On-Stack Replacement，OSR）行为</code>。</p>
</blockquote>
<h5 id="2-3-小家碧玉：Mobile-Embedded-VM"><a href="#2-3-小家碧玉：Mobile-Embedded-VM" class="headerlink" title="2.3 小家碧玉：Mobile/Embedded VM"></a>2.3 小家碧玉：Mobile/Embedded VM</h5><p>面对移动和嵌入式市场，在Java ME这条产品线上的虚拟机名为CDC-HI（C Virtual Machine， CVM）和CLDC-HI（Monty VM）。</p>
<blockquote>
<p>CDC/CLDC全称是<code>Connected（Limited）Device Configuration</code>，HI则是<code>HotSpot Implementation</code>的缩写，但它们并不是由HotSpot直接裁剪而来，只是借鉴过其中一些技术，并没有血缘关系，充其量能叫有所渊源。</p>
</blockquote>
<h5 id="2-4-天下第二：BEA-JRockit-IBM-J9-VM"><a href="#2-4-天下第二：BEA-JRockit-IBM-J9-VM" class="headerlink" title="2.4 天下第二：BEA JRockit/IBM J9 VM"></a>2.4 天下第二：BEA JRockit/IBM J9 VM</h5><p>BEA System公司的<code>JRockit</code>与 IBM公司的<code>IBM J9</code>曾经与HotSpot并称<strong>“三大商业Java虚拟机”</strong>。</p>
<p>JRockit虚拟机曾经号称是“世界上速度最快的Java虚拟机”，BEA将其发展为一款<strong>专门为服务器硬件和服务端应用场景高度优化的虚拟机</strong>，由于专注于服务端应用，它可以不太关注于程序启动速度，因此JRockit内部<em>不包含解释器实现</em>，全部代码都靠<code>即时编译器编译后执行</code>。JRockit的<strong>垃圾收集器</strong>和<strong>Java Mission Control故障处理套件</strong>等部分的实现，在当时众多的Java虚拟机中也处于领先水平。</p>
<p>IBM J9虚拟机机最初是由IBM Ottawa实验室的一个<code>SmallTalk虚拟机</code>项目扩展而来。IBM J9虚拟机的市场定位与HotSpot比较接近，它是一款在<em>设计上全面考虑服务端、桌面应用，再到嵌入式的多用途虚拟机</em>。</p>
<blockquote>
<p>IBM J9虚拟机的<code>职责分离与模块化</code>做得比HotSpot更优秀，由J9 虚拟机中抽象封装出来的核心组件库（包括垃圾收集器、即时编译器、诊断监控子系统等）就单独构成了IBM OMR项目</p>
</blockquote>
<h5 id="2-5-软硬合璧：BEA-Liquid-VM-Azul-VM"><a href="#2-5-软硬合璧：BEA-Liquid-VM-Azul-VM" class="headerlink" title="2.5 软硬合璧：BEA Liquid VM/Azul VM"></a>2.5 软硬合璧：BEA Liquid VM/Azul VM</h5><p>一类<strong>与特定硬件平台绑定、软硬件配合工作的专有虚拟机</strong>，往往能够实现更高的执行性能，或提供某些特殊的功能特性。</p>
<blockquote>
<p>Liquid VM也被称为JRockit VE(Virtual Edition，VE)，BEA公司开发的可以直接运行在自家 Hypervisor系统上的JRockit虚拟机的虚拟化版本。Liquid VM不需要操作系统的支持，或者说<strong>它自己本身实现了一个专用操作系统的必要功能</strong>。</p>
<p>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的<strong>专有硬件Vega系统</strong>上的Java虚拟机。</p>
<p>Zing虚拟机(Azul Systems公司研发)是一个从HotSpot某旧版代码分支基础上独立出来重新开发的高性能Java虚拟机。在要求低延迟、快速预热等场景中，Zing VM都要比HotSpot表现得更好。Zing的PGC、 C4收集器可以轻易支持TB级别的Java堆内存，而且保证暂停时间仍然可以维持在不超过10毫秒的范围里。</p>
</blockquote>
<h5 id="2-6-挑战者：Apache-Harmony-Google-Android-Dalvik-VM"><a href="#2-6-挑战者：Apache-Harmony-Google-Android-Dalvik-VM" class="headerlink" title="2.6 挑战者：Apache Harmony/Google Android Dalvik VM"></a>2.6 挑战者：Apache Harmony/Google Android Dalvik VM</h5><p>Harmony虚拟机（准确地说是Harmony里的DRLVM）和Dalvik虚拟机<code>只能称作“虚拟 机”，而不能称作“Java虚拟机”</code>。</p>
<h5 id="2-7-没有成功，但并非失败：Microsoft-JVM及其他"><a href="#2-7-没有成功，但并非失败：Microsoft-JVM及其他" class="headerlink" title="2.7 没有成功，但并非失败：Microsoft JVM及其他"></a>2.7 没有成功，但并非失败：Microsoft JVM及其他</h5><p>微软为了在Internet Explorer 3浏览器中支持Java Applets应用而开发了自己的Java虚拟机，</p>
<h5 id="2-8-百家争鸣"><a href="#2-8-百家争鸣" class="headerlink" title="2.8 百家争鸣"></a>2.8 百家争鸣</h5><p>一些Java虚拟机是单纯为了用于生产，甚至在设计之初就仅仅是用于研究、验证某种技术和观点，又或者是作为一些规范的标准实现：</p>
<blockquote>
<ul>
<li>KVM。KVM中的K是“Kilobyte”的意思，它强调简单、轻量、高度可移植，但是运行速度比较慢。主要用于手机平台。</li>
<li>Java Card VM。JCVM必须精简到能放入智能卡、SIM卡、银行信用卡、借记卡内。</li>
<li>Squawk VM。运行于Sun SPOT（Sun Small Programmable Object Tech-nology，一种手持的Wi-Fi设备），也曾经运用于Java Card。</li>
<li>JavaInJava。试图以Java语言来实现Java语言本身的运行环境，既所谓的“元循环”（Meta-Circular，是指使用语言自身来实现其运行环境）虚拟机。</li>
<li>Maxine VM。也是一个几乎全部以Java代码实现（只有用于启动 Java虚拟机的加载器使用C语言编写）的元循环Java虚拟机。</li>
<li>Jikes RVM。是IBM开发的专门用来研究Java虚拟机实现技术的项目，也是一个元循环虚拟机。</li>
<li>IKVM.NET。基于微软.NET框架实现的Java虚拟机，并借助Mono获得一定的跨平台能力。</li>
</ul>
</blockquote>
<h4 id="3-实战：自己编译JDK"><a href="#3-实战：自己编译JDK" class="headerlink" title="3. 实战：自己编译JDK"></a>3. 实战：自己编译JDK</h4><h5 id="3-1-OpenJDK和OracleJDK"><a href="#3-1-OpenJDK和OracleJDK" class="headerlink" title="3.1 OpenJDK和OracleJDK"></a>3.1 OpenJDK和OracleJDK</h5><p>OpenJDK和 OracleJDK在程序上是非常接近的，两者共用了绝大部分相同的代码。在JDK 11以前，OracleJDK中还会存在一些OpenJDK没有的、闭源的功能，即OracleJDK 的“商业特性”。许多功能在JDK 11时全部开源到了OpenJDK中。到了这个阶段，已经可以认为OpenJDK与OracleJDK代码实质上已达到完全一致的程度。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OpenJDK_and_OracleJDK.PNG" alt="OpenJDK和 OracleJDK的关系"></p>
<p>OpenJDK内部不同版本之间的关系，按照开发习惯，新的功能或Bug修复通常是在最新分支上进行的，当功能或修复在最新分支上稳定之后会同步到其他老版本的维护分支上。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Relationship_between_OpenJDK_versions.PNG" alt="OpenJDK版本之间的关系"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--1 基础概念</title>
    <url>/2021/01/09/JavaLearning_Head_First_Java_1_basic_concepts.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>重新开始学习Java，同时为找工作开始做准备，加油。从《Head First Java》开始吧！<br><a id="more"></a></p>
</blockquote>
<h3 id="1-Java的工作方式"><a href="#1-Java的工作方式" class="headerlink" title="1. Java的工作方式"></a>1. Java的工作方式</h3><p>基于Java写出应用程序并在任意设备上运行主要分为4步：</p>
<blockquote>
<ol>
<li>源代码。编写源码文件</li>
<li>编译器。用编译器运行源代码，检查错误</li>
<li>输出。编译器对源码编译输出字节文件，编译后的<code>字节文件与平台无关</code></li>
<li>Java虚拟机。Java虚拟机可以读取及执行字节文件</li>
</ol>
</blockquote>
<h3 id="2-Java的程序结构"><a href="#2-Java的程序结构" class="headerlink" title="2. Java的程序结构"></a>2. Java的程序结构</h3><p>类存在于源文件里，方法存在于类中，语句存在于方法中。<br><img src="https://github.com/wwwwwyj/image_repository/blob/master/img/blog/JavaLearning/HeadFirstJava/JavaProgramStructure.PNG?raw=true" alt="Java程序结构"></p>
<h4 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h4><p>源文件(<code>.java</code>)带有类定义，类用于表示程序的一个组件。</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>类带有一个或多个方法。<br><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JavaClassStructure.PNG" alt="Java类的结构"></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>在方法中包含需要执行的指令，方法由一组语句组成，可以当作一个函数或过程。</p>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a><code>Tips</code></h4><h5 id="Java中integer与boolean不兼容"><a href="#Java中integer与boolean不兼容" class="headerlink" title="Java中integer与boolean不兼容"></a>Java中integer与boolean不兼容</h5><p>Java中integer与boolean不兼容，所以int类型不能用作条件，如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Java中执行会报错，需要将其修改为boolean类型变量来实现相同功能：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isHot = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (isHot) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习--基础</title>
    <url>/2019/11/23/Git-learning-foundation.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Git</code> 是一个”版本控制”工具, 可以用来管理我们的代码。简单来说, 就是可以像玩游戏一样, 给一定时间的代码存档, 以后就可以通过”读档”回退到以前的状态。<br><a id="more"></a><br>Git 是<strong>分布式版本控制系统</strong>, 每个项目协作者电脑里都有完整的版本库, 完成修改后, 只需把各自的修改推送给其他人就可以让别人看见自己的修改, 也有充当“中央服务器”的电脑方便“交换”大家的修改。</p>
<p>这里版本库又名仓库，即<em>repository</em>，可以简单理解成一个目录，这个目录里面的所有文件都可以被<code>Git</code>管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以”还原”。</p>
<h3 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h3><p>安装 Git 之后, 使用之前需要先进行一些配置, 主要进行如下配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Zhang San&quot;            # your name</span><br><span class="line">$ git config --global user.email &quot;zhangsan@foo.com&quot;    # your email</span><br><span class="line">$ git config --global core.editor vim                  # your favourite editor</span><br><span class="line">$ git config --global color.ui true                    # your git color</span><br></pre></td></tr></table></figure><br>前两个命令设置基本的用户信息, <code>core.editor</code>可以设置自己喜欢的文本编辑器, <code>color.ui</code> 能为输出到你终端的内容着色，以便你可以凭直观进行快速、简单地分析</p>
<h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>现在可以开始用<code>Git</code>来管理代码了。首先需要将项目的目录初始化为Git可以管理的仓库, 切换到实验/项目的目录中, 然后输入:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init    # 初始化仓库</span><br></pre></td></tr></table></figure><br>我们通过 git clone 命令下载项目, 里面已经包含一些 git 记录, 因此不需要额外进行初始化。</p>
<h4 id="查看版本信息"><a href="#查看版本信息" class="headerlink" title="查看版本信息"></a>查看版本信息</h4><p>主要使用以下两条命令查看版本信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log        # 查看目前为止所有的存档.</span><br><span class="line">$ git status     # 查看与当前存档相比, 哪些文件发生了变化</span><br></pre></td></tr></table></figure></p>
<h4 id="存档"><a href="#存档" class="headerlink" title="存档"></a>存档</h4><p>首先你需要使用 git status 查看是否有新的文件或已修改的文件未被跟踪, 可以使用以下命令将修改的文件加入跟踪列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add file.c    # 将文件 file.c 加入跟踪列表</span><br></pre></td></tr></table></figure><br>如果需要一次添加所有未被跟踪的文件, 也可以使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add .     # 把工作时的所有变化提交到暂存区, 包括文件内容修改(modified)以及新文件(new), 但不包括被删除的文件</span><br><span class="line">$ git add -u    # 仅监控已经被add的文件(即tracked file), 他会将被修改的文件提交到暂存区。(git add --update的缩写)</span><br><span class="line">$ git add -A    # 是上面两个功能的合集(git add --all的缩写), 提交所有变化</span><br></pre></td></tr></table></figure><br>可以通过编辑 <code>.gitignore</code> 文件, 在里面给出需要被 git 忽略的文件和文件类型从而筛选文件。新文件加入跟踪列表, 确认无误后就可以存档了:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit    # 提交工程当前的状态</span><br></pre></td></tr></table></figure><br>执行这条命令后, 需要添加本次存档的注释, 可以根据这些注释来区别和寻找不同的存档。</p>
<h4 id="读档"><a href="#读档" class="headerlink" title="读档"></a>读档</h4><p>首先使用 git log 来查看已有的存档, 并通过存档的 <code>hash code</code> 来回到过去。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard &lt;code&gt;</span><br></pre></td></tr></table></figure><br><code>hard</code>模式会把你工作目录中所有未提交的内容清空, 所以需要慎用。</p>
<h4 id="分支功能"><a href="#分支功能" class="headerlink" title="分支功能"></a>分支功能</h4><p>这就是 <code>Git</code> 的分支功能可以让我们创建不同的世界线, 即在一个时刻, 我们可以做出不同的选择, 使得多个”平行宇宙”并行存在:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch    # 查看所有分支</span><br></pre></td></tr></table></figure><br>使用 <code>git init</code> 初始化之后会自动建立主分支 <code>master</code>。可以用以下命令创建一个新的分支:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b &lt;分支名&gt;    # 创建并切换分支</span><br></pre></td></tr></table></figure><br>我们可以将新分支上的修改合并到主分支上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge &lt;分支名&gt;    # 合并指定分支到当前分支</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<ul>
<li><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/git.html" target="_blank" rel="noopener">git快速入门</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></li>
<li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Git Book(官方文档)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--2 类与对象</title>
    <url>/2021/04/27/JavaLearning_Head_First_Java_2_class_and_objects.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>有人告诉我那里遍地都是对象！<br><a id="more"></a></p>
</blockquote>
<h3 id="1-椅子大战——阿花的”对象”"><a href="#1-椅子大战——阿花的”对象”" class="headerlink" title="1. 椅子大战——阿花的”对象”"></a>1. 椅子大战——阿花的”对象”</h3><p>面向对象信徒阿花利用面向对象的思想赢得了椅子大战(但最后赢家是阿娇——老板娘的侄女，作者调皮了)。</p>
<h4 id="类与继承-inheritance"><a href="#类与继承-inheritance" class="headerlink" title="类与继承(inheritance)"></a>类与继承(inheritance)</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_inheritance.PNG" alt="继承(inheritance)"></p>
<h4 id="覆盖-override"><a href="#覆盖-override" class="headerlink" title="覆盖(override)"></a>覆盖(override)</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_override.PNG" alt="覆盖(override)"></p>
<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h3><blockquote>
<p> <code>对象</code>是依靠类的模型塑造出来的，对象也可以叫做<code>实例</code>。可以把对象分为两部分看：</p>
<ul>
<li>对象是已知的事物<ul>
<li><code>实例变量</code>(instance variable)。对象本身已知的事物，代表对象的状态(数据)，且该类型的每一个对象都会独立地拥有一份该类型的值。</li>
</ul>
</li>
<li>对象会执行的当作<ul>
<li><code>方法</code>(methods)。对象可以执行的动作，读取或操作实例变量。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_override.PNG" alt="Java对象"></p>
<h4 id="类与对象的区别"><a href="#类与对象的区别" class="headerlink" title="类与对象的区别"></a>类与对象的区别</h4><blockquote>
<p>”<em>类不是对象，却是用来创建对象的模型</em>‘“。类是对象的<strong>蓝图</strong>，告诉虚拟机如何创建某种类型的对象。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_object_relation.PNG" alt="类与对象"></p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>创建对象后，使用<code>圆点(.)</code>符号所代表的操作数来<em>存取该对象的变量和方法</em>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_create_object.PNG" alt="创建对象"></p>
<h4 id="逃出main"><a href="#逃出main" class="headerlink" title="逃出main()"></a>逃出main()</h4><blockquote>
<p><code>main()</code>的两种用途</p>
<ul>
<li>测试真正的类</li>
<li>启动JAVA应用程序</li>
</ul>
</blockquote>
<p>Java程序普遍只会让对象与对象交互，即相互调研方法。猜数字游戏示例：</p>
<blockquote>
<p><strong>摘要：</strong></p>
<p>涉及到<code>game</code>和<code>player</code>两个对象，<code>game</code>会产生介于0~9之间的随机数，3个<code>player</code>对象会猜测该数字。</p>
<p><strong>类：</strong></p>
<ul>
<li>GuessGame.class</li>
<li>Player.class</li>
<li>GameLauncher.class</li>
</ul>
<p><strong>程序逻辑：</strong></p>
<ol>
<li><code>GameLauncher</code>类带有<code>main()</code>方法，是应用程序<strong>入口点</strong>；</li>
<li><code>main()</code>中会创建<code>GuessGame</code>对象，并调用它的<code>startGame()</code>方法；</li>
<li><code>startGame()</code>方法是游戏的起点。它会创建3个player，然后挑出要猜测的随机数字。它会要求player猜测并检查结果，列出过程。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.schoolLearning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        number = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"I'm guessing "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    Player p1;</span><br><span class="line">    Player p2;</span><br><span class="line">    Player p3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        p1 = <span class="keyword">new</span> Player();</span><br><span class="line">        p2 = <span class="keyword">new</span> Player();</span><br><span class="line">        p3 = <span class="keyword">new</span> Player();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> guessp1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> guessp2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> guessp3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> p1isRight = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> p2isRight = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> p3isRight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetNumber = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"I'm thinking of a number between 0 and 9..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Number to guess is "</span> + targetNumber);</span><br><span class="line"></span><br><span class="line">            p1.guess();</span><br><span class="line">            p2.guess();</span><br><span class="line">            p3.guess();</span><br><span class="line"></span><br><span class="line">            guessp1 = p1.number;</span><br><span class="line">            System.out.println(<span class="string">"Player one guessed "</span> + guessp1);</span><br><span class="line">            guessp2 = p2.number;</span><br><span class="line">            System.out.println(<span class="string">"Player two guessed "</span> + guessp2);</span><br><span class="line">            guessp3 = p3.number;</span><br><span class="line">            System.out.println(<span class="string">"Player three guessed "</span> + guessp3);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (guessp1 == targetNumber) &#123;</span><br><span class="line">                p1isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp2 == targetNumber) &#123;</span><br><span class="line">                p2isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp3 == targetNumber) &#123;</span><br><span class="line">                p3isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p1isRight || p2isRight || p3isRight) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"We have a winner!"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Player one got it right? "</span> + p1isRight);</span><br><span class="line">                System.out.println(<span class="string">"Player two got it right? "</span> + p2isRight);</span><br><span class="line">                System.out.println(<span class="string">"Player three got it right? "</span> + p3isRight);</span><br><span class="line">                System.out.println(<span class="string">"Game is over."</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Players will have to try again."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameLauncher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GuessGame game = <span class="keyword">new</span> GuessGame();</span><br><span class="line">        game.startGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol>
<li><p>在创建类时，<code>.java</code>文件内只能有一个<code>public</code>声明的类，且类名需要与文件名一致，一般设定为包含<code>main()</code>函数的类。更规范的写法是为不同的类分别创建<code>.java</code>文件，维护各自的代码，通过文件之间的调用(<code>import</code>)实现交互。</p>
</li>
<li><p>Java垃圾回收。</p>
<p>创建对象时，不管对象如何创建的，它都会被存放于称为<code>堆</code>的内存区域，在Java中是<code>可回收垃圾的堆(Garbage-Collectible Heap)</code>。Java会根据对象的大小来分配内存空间，当Java虚拟机察觉到对象不再会被使用到时，该对象会被标记为可回收的。如果内存不足，垃圾收集器就会启动来清理垃圾、回收空间。</p>
</li>
<li><p>包装多个类成为单一应用程序形式。</p>
<p>可以把所有文件包装进依据<code>pkzip</code>格式来存档的<code>Java Archive-.jar文件</code>。在该<code>jar</code>文件中可以引入一个简单文字格式的文字文件，被称为<code>manifest</code>，里面有定义出<code>jar</code>中的哪一个文件带有启动应用程序的<code>main()</code>方法。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--10. Regular Expression Matching</title>
    <url>/2019/04/07/LeetCode--10-Regular-Expression-Matching.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an input string (s) and a pattern (p), implement regular expression matching with support for <strong>‘.’</strong> and <strong>‘*’</strong>.<br><a id="more"></a></p>
<ul>
<li>‘.’ Matches any single character.</li>
<li>‘*’ Matches zero or more of the preceding element.</li>
</ul>
<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<ul>
<li>s could be empty and contains only lowercase letters a-z.</li>
<li>p could be empty and contains only lowercase letters a-z, and characters like . or *.</li>
</ul>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input:<br>s = “aa”<br>p = “a*“<br>Output: true<br>Explanation: ‘*‘ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input:<br>s = “ab”<br>p = “.*“<br>Output: true<br>Explanation: “.*“ means “zero or more (*) of any character (.)”.</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input:<br>s = “aab”<br>p = “c*a*b”<br>Output: true<br>Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”.</p>
</blockquote>
<p><strong>Example 5:</strong></p>
<blockquote>
<p>Input:<br>s = “mississippi”<br>p = “mis*is*p*.”<br>Output: false</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题主要是看了题目的题解后才解出来的，这里就主要对这道题总结一下。一种直观的方法是<br>使用递归求解，我们发现在进行匹配时有如下考虑：</p>
<blockquote>
<ol>
<li>如果没有”*“，那么我们可以简单的从左到右逐个字符比较，判断是否匹配；</li>
<li>如果有”*“，我们需要检查各种可能的情况，观察是否存在一种匹配的扩展方式。</li>
</ol>
</blockquote>
<p>所以可以看出递归是一种简单直观的实现方式。如果存在”*“，那么它必定出现在一个字符后面。我们要么忽略这段表达式(即假设它重复0次)，要么从字符串S中后移一位(即假设它重复至少1次)。在匹配完所有情况后，若有匹配成功的情况，那么就匹配成功了。</p>
<p>这种方法尽管简单，但是效率不高。一种优化的解法是，我们将中间结果保存起来，不使用递归。这样可以省略大量的计算。这种方法也就是DP算法，定义DP[i][j]如下：若S[0:i]与P[0:j]匹配，那么DP[i][j]值为真；否者，值为假。</p>
<blockquote>
<ol>
<li>dp[i][j] = dp[i - 1][j - 1], if p[j - 1] != ‘*’ &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’);</li>
<li>dp[i][j] = dp[i][j - 2], if p[j - 1] == ‘*’ 且表达式重复0次;</li>
<li>dp[i][j] = dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == ‘.’), if p[j - 1] == ‘*’ 且表达式重复至少1次.</li>
</ol>
</blockquote>
<p><strong>参考文献：</strong><a href="https://leetcode.com/problems/regular-expression-matching/discuss/5684/9-lines-16ms-c-dp-solutions-with-explanations" target="_blank" rel="noopener" title="C++ O(n)-space DP">C++ O(n)-space DP</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.empty()) <span class="keyword">return</span> s.empty();</span><br><span class="line">        <span class="keyword">bool</span> first_match = (!s.empty() &amp;&amp; (p[<span class="number">0</span>] == s[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p.length() &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p.substr(<span class="number">2</span>)) || (first_match &amp;&amp; isMatch(s.substr(<span class="number">1</span>),p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; isMatch(s.substr(<span class="number">1</span>),p.substr(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="DP算法"><a href="#DP算法" class="headerlink" title="DP算法"></a>DP算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length(),plen=p.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(slen+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(plen+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= slen; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">'*'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-2</span>] || (i &amp;&amp; dp[i<span class="number">-1</span>][j] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">'.'</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = i &amp;&amp; dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">'.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法三-Bottom-Up-Variation"><a href="#解法三-Bottom-Up-Variation" class="headerlink" title="解法三 (Bottom-Up Variation)"></a>解法三 (Bottom-Up Variation)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.length()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(p.length()+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        dp[s.length()][p.length()] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length();i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = p.length()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> first_match = (i&lt; s.length() &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'.'</span>));</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span> &lt; p.length() &amp;&amp; p[j+<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">2</span>] || first_match &amp;&amp; dp[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = first_match &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--11. Container With Most Water</title>
    <url>/2019/04/03/LeetCode--11-Container-With-Most-Water.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given n non-negative integers <strong>a1, a2, …, an</strong> , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br><a id="more"></a></p>
</blockquote>
<p><strong>Note:</strong> You may not slant the container and n is at least 2.</p>
<p><img src="https://i.niupic.com/images/2019/04/03/5Ujc.jpg" alt=""><br>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example :</strong></p>
<blockquote>
<p>Input: [1,8,6,2,5,4,8,3,7]<br>Output: 49</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>首先想到的是暴力解法，直接遍历所有可能的二元组，最终可以找到满足题目要求的最大值。但是题目对时间有要求，这种时间复杂度O(n^2)的方法超时了。所以需要使用更优的方法，一种优化的方法思路如下：</p>
<blockquote>
<p>使用两个变量，一个表示底的开始，一个表示底的终点。一开始底的起点是数组第一位，终点是数组最后一位。这样去计算两者之间围成的区域，如果比当前记录的最大区域大，则将之记为最大区域值。之后，将两边中较短的一边向中间移动一个单位，再次计算区域大小，重复刚才的后续过程。<br>这里的难点是为什么移动的是两边中较小的一条呢？因为这条是这个区域增加的“短板“。移动较短的一边，也许会遇到一条更大的边，这样的话这种增加有可能抵消了底边的变短，甚至可能使得区域面积变得更大。相反的，如果移动的是较大的一边，最好的情况是遇到一条比较短边还要长的边，但是因为“木桶效应“，整个区域大小还是取决于较短的边，所以移动较长的一边是不可能得到更好的结果的。</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArea = min(height[i],height[j])*j;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            maxArea = max(maxArea,min(height[i],height[j])*(j-i));</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;height[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--1. Two Sum</title>
    <url>/2019/03/28/LeetCode--1-Two-Sum.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.<br><a id="more"></a><br>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the same element twice.</p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>给定一个数组，和一个目标数target，要求数组中，和为target的两个数的下标。<br>想到的方法是暴力求法，即直接逐个遍历数组，找出满足要求的两个数。尽管这种方法能成功AC,但显然效率不高，这种方法比较耗时。需要寻找更加优化的算法。<br>查阅资料和题解思路得知，更加优化的方法是使用哈希表，这是一种通过以空间换取速度的方式，我们可以将查找时间从 O(n)降低到 O(1)。主要有以下两种：</p>
<blockquote>
<p>1.两遍哈希表<br>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。</p>
<p>2.一遍哈希表<br>更优化的方法是，我们可以一次完成计算。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
</blockquote>
<p>这里将这两种方法都实现了一遍。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li><p>解法1 暴力求法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indices;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            indices.push_back(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==target-nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    indices.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> indices;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            indices.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2 两遍哈希表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  indices;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.count(complement) &amp;&amp; hash[complement] != i)</span><br><span class="line">            &#123;</span><br><span class="line">                indices.push_back(i);</span><br><span class="line">                indices.push_back(hash[complement]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一遍哈希表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  indices;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.count(complement))</span><br><span class="line">            &#123;</span><br><span class="line">                indices.push_back(i);</span><br><span class="line">                indices.push_back(hash[complement]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>更新：map与unordered_map区别<br>原文：<a href="https://blog.csdn.net/BillCYJ/article/details/78985895" target="_blank" rel="noopener">https://blog.csdn.net/BillCYJ/article/details/78985895</a><br><strong>1.内部实现机理不同</strong><br><strong>map</strong>： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。</p>
<p><strong>unordered_map</strong>: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p>
<p><strong>2.优缺点以及适用处</strong><br><strong>map：</strong><br>优点：</p>
<ol>
<li>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</li>
<li>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</li>
</ol>
<p>缺点：<br>空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间</p>
<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>
<p><strong>unordered_map：</strong><br>优点： 因为内部实现了哈希表，因此其查找速度非常的快</p>
<p>缺点： 哈希表的建立比较耗费时间</p>
<p>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<p><strong>总结：</strong></p>
<ol>
<li>内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。</li>
<li>但是unordered_map执行效率要比map高很多</li>
<li>对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--12. Integer to Roman</title>
    <url>/2019/04/03/LeetCode--12-Integer-to-Roman.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<ul>
<li>I can be placed before V (5) and X (10) to make 4 and 9. </li>
<li>X can be placed before L (50) and C (100) to make 40 and 90. </li>
<li>C can be placed before D (500) and M (1000) to make 400 and 900.</li>
</ul>
<p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: 3<br>Output: “III”</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: 4<br>Output: “IV”</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: 9<br>Output: “IX”</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input: 58<br>Output: “LVIII”<br>Explanation: L = 50, V = 5, III = 3.</p>
</blockquote>
<p><strong>Example 5:</strong></p>
<blockquote>
<p>Input: 1994<br>Output: “MCMXCIV”<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目描述很长，但意思很简单，就是将普通的阿拉伯数字转换为罗马数字。罗马数字有自己的表示规则，所以需要进行一定处理。其实处理方法很简单：</p>
<blockquote>
<p>每次找到数字中包含的最大罗马数字，然后减去这个数，并把该罗马数加入表示数的字符串中。不断重复这个过程，直到数字为0停止，输出结果。</p>
</blockquote>
<p>最开始实现时，写了一长串的if-else语句，尽管能够成功解决。但是代码不够简洁，需要想办法使代码美观规范。可以将这些罗马数字和其对应的阿拉伯数字从大到小存放到数组或者map中，之后直接从大到小遍历这个数组即可，可以省去大部分if-else语句，且结构更加清晰。</p>
<p>评论区有另一种解法，直接把0~10,10~100,100~1000,1000~3999范围类，罗马数的可能表示直接列出来放到一个数字中，然后直接按位查表，O(1)的时间复杂度。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= val[i]) &#123;</span><br><span class="line">                num -= val[i];</span><br><span class="line">                res += str[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> THOUS[];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> HUNDS[];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> TENS[];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> ONES[];</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        result += THOUS[(<span class="keyword">int</span>)(num/<span class="number">1000</span>)%<span class="number">10</span>];</span><br><span class="line">        result += HUNDS[(<span class="keyword">int</span>)(num/<span class="number">100</span>)%<span class="number">10</span>];</span><br><span class="line">        result += TENS[(<span class="keyword">int</span>)(num/<span class="number">10</span>)%<span class="number">10</span>];</span><br><span class="line">        result += ONES[num%<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::THOUS[]	= &#123;<span class="string">""</span>,<span class="string">"M"</span>,<span class="string">"MM"</span>,<span class="string">"MMM"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::HUNDS[]	= &#123;<span class="string">""</span>,<span class="string">"C"</span>,<span class="string">"CC"</span>,<span class="string">"CCC"</span>,<span class="string">"CD"</span>,<span class="string">"D"</span>,<span class="string">"DC"</span>,<span class="string">"DCC"</span>,<span class="string">"DCCC"</span>,<span class="string">"CM"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::TENS[]	= &#123;<span class="string">""</span>,<span class="string">"X"</span>,<span class="string">"XX"</span>,<span class="string">"XXX"</span>,<span class="string">"XL"</span>,<span class="string">"L"</span>,<span class="string">"LX"</span>,<span class="string">"LXX"</span>,<span class="string">"LXXX"</span>,<span class="string">"XC"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::ONES[]	= &#123;<span class="string">""</span>,<span class="string">"I"</span>,<span class="string">"II"</span>,<span class="string">"III"</span>,<span class="string">"IV"</span>,<span class="string">"V"</span>,<span class="string">"VI"</span>,<span class="string">"VII"</span>,<span class="string">"VIII"</span>,<span class="string">"IX"</span>&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--15. 3Sum</title>
    <url>/2019/04/07/LeetCode--15-3Sum.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array <strong>nums</strong> of n integers, are there elements a, b, c in <strong>nums</strong> such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br><a id="more"></a></p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>The solution set must not contain duplicate triplets.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given array nums = [-1, 0, 1, 2, -1, -4],</p>
<p>A solution set is:<br>[<br> [-1, 0, 1],<br> [-1, -1, 2]<br>]</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这个题和第一题Two Sum有些类似，但是要比那道题复杂一些。它的结果不止一个，而且返回的结果里不能有重复的解，由于用向量保存解，可能同一个解有不同的排列方式，去重的话会很麻烦。需要想一种算法，在计算结果的同时，跳过重复解。所以这道题应该不是考察Two Sum的解法。</p>
<p>分析一下这道题的特点，要我们找出三个数且和为0，那么除了三个数全是0的情况之外，肯定会有负数和正数。我们可以先固定一个数a，然后去找另外两个数b和c，我们只要找到两个数且和(b+c)为第一个数a的相反数就行了。在寻找这两个数组合的过程中，我们肯定不希望遍历所有两个数的组合。最先想到的就是，对原数组先进行一个排序，然后遍历这个排序后的数组，寻找合适的解。主要过程大致如下：</p>
<blockquote>
<ol>
<li>设置low, high，分别从左边和右边向中间遍历数组:如果找到了 a+b+c=0，把结果放入答案集内;若a+b+c &lt; 0，则(b+c)过小，增大low；若a+b+c &gt; 0，则(b+c)过大，减小high</li>
<li>在遍历过程中，若两个数相同，在数组中一定是相邻的，可以跳过这些相同的数。</li>
<li>我们也可以先做个剪枝优化，就是当遍历到正数a的时候就break，因为我们的数组现在是有序的了，如果第一个要数a就是正数了，那么后面的数字b,c就都是正数，就永远不会出现和为0的情况了。</li>
</ol>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">2</span> || nums.front()&gt;<span class="number">0</span> || nums.back() &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>,high = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[low] + nums[high];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tuple = &#123;nums[i], nums[low], nums[high]&#125;;</span><br><span class="line">                    res.push_back(tuple);</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] == nums[++low] );</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] == nums[--high] );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) high--;</span><br><span class="line">                <span class="keyword">else</span> low++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--13. Roman to Integer</title>
    <url>/2019/04/07/LeetCode--13-Roman-to-Integer.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br><a id="more"></a></p>
</blockquote>
<p>剩余部分略，描述与它前一道题<a href="http://wuyunjie.top/2019/04/03/LeetCode-12-Integer-to-Roman/" target="_blank" rel="noopener" title="12. Integer to Roman">12. Integer to Roman</a>大致相同</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: “III”<br>Output: 3</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: “IV”<br>Output: 4</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: “IX”<br>Output: 9</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input: “LVIII”<br>Output: 58<br>Explanation: L = 50, V= 5, III = 3.</p>
</blockquote>
<p><strong>Example 5:</strong></p>
<blockquote>
<p>Input: “MCMXCIV”<br>Output: 1994<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题与它前一道题恰好相反，是从罗马数变成阿拉伯数字。细心观察可以发现，罗马数字一般都是大的数字在前面，如果存在某个较小的数字在某个较大的数字前——比如”IV”，那么他们表示的是一个数字4，即 V - I 。</p>
<p>利用这种特性，一开始思考，是否可以设置一个优先级，来判断某个数字应该比另一个优先出现。转念一想，他们的大小就已经代表优先级了，那么处理起来就很简单了：</p>
<blockquote>
<ol>
<li>若一个数比它下一个数优先级高，加入该数的值；</li>
<li>若一个数比它下一个数优先级低，减去该数的值。</li>
</ol>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; roToInt = &#123;</span><br><span class="line">            &#123;<span class="string">'I'</span>,<span class="number">1</span>&#125;, &#123;<span class="string">'V'</span>,<span class="number">5</span>&#125;, &#123;<span class="string">'X'</span>,<span class="number">10</span>&#125;, </span><br><span class="line">            &#123;<span class="string">'L'</span>,<span class="number">50</span>&#125;,&#123;<span class="string">'C'</span>,<span class="number">100</span>&#125;,&#123;<span class="string">'D'</span>,<span class="number">500</span>&#125;,&#123;<span class="string">'M'</span>,<span class="number">1000</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// int roToInt[256] = &#123;0&#125;;</span></span><br><span class="line">        <span class="comment">// roToInt['I']=1;roToInt['V']=5;roToInt['X']=10;</span></span><br><span class="line">        <span class="comment">// roToInt['L']=50;roToInt['C']=100;roToInt['D']=500;roToInt['M']=1000;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(roToInt[s[i]]&lt;roToInt[s[i+<span class="number">1</span>]])</span><br><span class="line">            &#123;</span><br><span class="line">                result-=roToInt[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result+=roToInt[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--14. Longest Common Prefix</title>
    <url>/2019/04/07/LeetCode--14-Longest-Common-Prefix.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Write a function to find the longest common prefix string amongst an array of strings.<br><a id="more"></a><br>If there is no common prefix, return an empty string “”.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: [“flower”,”flow”,”flight”]<br>Output: “fl”</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: [“dog”,”racecar”,”car”]<br>Output: “”<br>Explanation: There is no common prefix among the input strings.</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>All given inputs are in lowercase letters <strong>a-z</strong>.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目很简单，求一组字符串的最长公共前缀。因为是公共前缀，所以必定所有字符串都包含这个前缀。想法是用一个字符串LCP保存已经比较过的字符串的公共前缀，然后逐个遍历修正这个公共前缀，最终就可以得到结果。</p>
<p>看了题解后，发现这种方法叫做水平扫描法，除了这种方法外，还有许多其他方法可以求解。</p>
<p>算法二： 垂直扫描法</p>
<blockquote>
<p>若数组末尾有一个非常短的字符串，使用水平扫描法依旧会进行S次比较，可以对其进行优化。即从前往后扫描字符串每一列，先判断每个字符串相同列上字符是否相同。</p>
</blockquote>
<p>算法三： 分治</p>
<blockquote>
<p>使用分治的技巧，将原问题 LCP(Si…Sj) 分成两个子问题 LCP(Si…Smid) 与 LCP(Smid+1…Sj)，其中mid = (i+j)/2.用子问题的解 lcpLeft 与 lcpRight 构造原问题的解 LCP(Si…Sj)。</p>
</blockquote>
<p><img src="https://leetcode-cn.com/media/original_images/14_lcp_diviso_et_lmpera.png" alt=""></p>
<p>算法四：</p>
<blockquote>
<p>还有一种解法，这种方法给输入字符串数组排了个序。按字母顺序排序的话，那么有共同字母多的两个字符串会被排到一起，而跟大家相同的字母越少的字符串会被挤到首尾两端，那么如果有共同前缀的话，一定会出现在首尾两端的字符串中，所以我们只需要找首尾字母串的共同前缀即可。<br>比如例子1排序后为 [“flight”, “flow”, “flower”]，例子2排序后为 [“car”, “dog”, “racecar”]，虽然例子2没有共同前缀，但也可以认为共同前缀是空串，且出现在首尾两端的字符串中。由于是按字母顺序排的，而不是按长度，所以首尾字母的长度关系不知道，为了防止溢出错误，我们只遍历而这种较短的那个的长度，找出共同前缀返回即可。</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="水平扫描"><a href="#水平扫描" class="headerlink" title="水平扫描"></a>水平扫描</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> lcp = strs[<span class="number">0</span>]; <span class="comment">//初始化公共前缀</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逐个遍历，不断修正</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; strs.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j &lt; lcp.length() &amp;&amp; j &lt; strs[i].length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lcp[j] != strs[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            lcp = lcp.substr(<span class="number">0</span>,j);</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="垂直扫描"><a href="#垂直扫描" class="headerlink" title="垂直扫描"></a>垂直扫描</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> lcp = strs[<span class="number">0</span>]; <span class="comment">//初始化公共前缀</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逐个遍历，不断修正</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lcp.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; strs.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == strs[j].size() || strs[j][i] != lcp[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> lcp.substr(<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">commomPredix</span><span class="params">(<span class="built_in">string</span> left, <span class="built_in">string</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; left.length() &amp;&amp; i &lt; right.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left[i] != right[i]) <span class="keyword">return</span> left.substr(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.substr(<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LCP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">string</span> leftLCP = LCP(strs, l, mid);</span><br><span class="line">            <span class="built_in">string</span> rightLCP = LCP(strs, mid+<span class="number">1</span>, r);</span><br><span class="line">            <span class="keyword">return</span> commomPredix(leftLCP,rightLCP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> LCP(strs, <span class="number">0</span>, strs.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="算法四"><a href="#算法四" class="headerlink" title="算法四"></a>算法四</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        sort(strs.begin(), strs.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = min(strs[<span class="number">0</span>].size(), strs.back().size());</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; strs[<span class="number">0</span>][i] == strs.back()[i]) ++i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--17. Letter Combinations of a Phone Number</title>
    <url>/2019/04/10/LeetCode--17-Letter-Combinations-of-a-Phone-Number.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.<br><a id="more"></a><br>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p>
<p><strong>Example :</strong></p>
<blockquote>
<p>Input: “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目让模拟手机9键的键盘，给定一个数字字符串(代表按键顺序)，给出可能的所有字母组合。简单理解，就是求每个数字所代表的字符集合的笛卡尔积，找出所有可能的情况。</p>
<p>想法是先在一个vector数组内放入一个空字符””。之后扫描字符串，每次识别到一个数字，就将这个数字所对应的字符分别与vector数组内的字符串连接加入数组，然后删去连接前的旧字符串，继续下一次扫描。当扫描完数字字符串时，就可以成功得到结果了。除此之外还有其他方法：</p>
<blockquote>
<p><strong>回溯法(Backtracking)</strong><br>回溯法是寻找所有可能的候选结果的一种算法。定义一个回溯函数<code>backtrack(combination, next_digits)</code>，生成结果并逐个字符检查。</p>
<ul>
<li>若已经没有digits需要继续处理，说明结果已经成功生成，存入结果集。</li>
<li>如果仍然有还未检查的digits字符，继续处理该字符：<ul>
<li>将该字符代表的字母加入当前生成的结果 <code>combination = combination + letter</code></li>
<li>继续处理剩余的字符：<code>backtrack(combination + letter, next_digits[1:])</code></li>
</ul>
</li>
</ul>
</blockquote>
<p><a href="https://imgchr.com/i/AT0u8J" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/10/AT0u8J.png" alt="AT0u8J.png"></a></p>
<blockquote>
<p>这是一种递归迭代的方法。方法思想差不多，只是这种方法用递归实现。</p>
<p>其中还可以继续优化的是，可以不使用unordered_map，直接用一个一维string数组来存储mapping数组。</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; mapping = &#123;</span><br><span class="line">        &#123;<span class="string">'1'</span>,<span class="string">""</span>&#125;, &#123;<span class="string">'2'</span>,<span class="string">"abc"</span>&#125;,&#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,&#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;, &#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,&#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(<span class="number">1</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; digits.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res_length = res.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mapping[digits[i]].length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; res_length;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(res[k]+mapping[digits[i]][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.erase(res.begin(),res.begin()+res_length);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; mapping = &#123;</span><br><span class="line">        &#123;<span class="string">'1'</span>,<span class="string">""</span>&#125;, &#123;<span class="string">'2'</span>,<span class="string">"abc"</span>&#125;,&#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,&#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;, &#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,&#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">string</span> combination, <span class="built_in">string</span> digits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(combination);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> letters = mapping[digits[<span class="number">0</span>]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;letters.length();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                backtrack(combination+letters[i], digits.substr(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() != <span class="number">0</span>) </span><br><span class="line">            backtrack(<span class="string">""</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法三-不使用unordered-map"><a href="#方法三-不使用unordered-map" class="headerlink" title="方法三(不使用unordered_map)"></a>方法三(不使用unordered_map)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> mapping[<span class="number">10</span>] = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(<span class="number">1</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; digits.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res_length = res.size();</span><br><span class="line">            <span class="built_in">string</span> letters = mapping[digits[i]-<span class="string">'0'</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; letters.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; res_length;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(res[k]+letters[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.erase(res.begin(),res.begin()+res_length);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--2. Add Two Numbers</title>
    <url>/2019/03/28/LeetCode--2-Add-Two-Numbers.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br><a id="more"></a><br>You may assume the two numbers do not contain any leading zero, except the number 0 itself. </p>
</blockquote>
<p><strong>Example:</strong></p>
<blockquote>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目意思即，两个数是用链表按逆序存储的，现在要求两个数的和。实现算法思想即，模拟一个加法器，按位(这里即每一个链表结点)相加，需要设置一个进位标志位。这里只需要注意几种特殊情况即可：<br>1.两个数不一样长时，需要额外处理；<br>2.如果最终计算结果超过两个数的长度时，需要多增加一位。<br>在实现过程中，用一个新的链表来存储计算结果。<br>在查看讨论区后，发现算法思路大致相同，但是别人的代码更加精简，可以从中借鉴代码的一些简化方法和思想</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li>解法1</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> CF=<span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>; <span class="comment">//每位计算的中间结果</span></span><br><span class="line">        ListNode* result=<span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//新链表存储结果，头结点</span></span><br><span class="line">        ListNode* present=result; <span class="comment">//结果链表当前节点</span></span><br><span class="line">        <span class="comment">//两个数都有节点还未计算是，循环按位计算</span></span><br><span class="line">		<span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//加法结果</span></span><br><span class="line">            tmp=(l1-&gt;val+l2-&gt;val+CF)%<span class="number">10</span>;</span><br><span class="line">            present-&gt;val=tmp;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//进位</span></span><br><span class="line">            CF=(l1-&gt;val+l2-&gt;val+CF)/<span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//链表指针后移</span></span><br><span class="line">			l1=l1-&gt;next;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//如果其中一个数已经加完，不再new新节点</span></span><br><span class="line">            <span class="keyword">if</span>(l1&amp;&amp;l2)</span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                present=present-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//若其中一个数未加完，即比另外一个数要长，需要结合进位进一步处理</span></span><br><span class="line">		<span class="comment">//两个数的处理方式相同</span></span><br><span class="line">        <span class="keyword">while</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//有进位，需要加上进位继续处理</span></span><br><span class="line">            <span class="keyword">if</span>(CF==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                present=present-&gt;next;</span><br><span class="line"></span><br><span class="line">                tmp=(l1-&gt;val+CF)%<span class="number">10</span>;</span><br><span class="line">                present-&gt;val=tmp;</span><br><span class="line"></span><br><span class="line">                CF=(l1-&gt;val+CF)/<span class="number">10</span>;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//若已经没进位，计算结果后面的数与该数剩下的数相同</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=l1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(CF==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                present=present-&gt;next;</span><br><span class="line"></span><br><span class="line">                tmp=(l2-&gt;val+CF)%<span class="number">10</span>;</span><br><span class="line">                present-&gt;val=tmp;</span><br><span class="line"></span><br><span class="line">                CF=(l2-&gt;val+CF)/<span class="number">10</span>;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=l2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果两个数都加完了，还有进位，那么new一个新节点，保存该进位</span></span><br><span class="line">        <span class="keyword">if</span>(CF==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>精简的解法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode preHead(0), *p = &amp;preHead;</span><br><span class="line">        <span class="keyword">int</span> extra = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || extra) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + extra;</span><br><span class="line">            extra = sum / <span class="number">10</span>;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--18. 4Sum</title>
    <url>/2019/04/10/LeetCode--18-4Sum.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array <code>nums</code> of n integers and an integer <code>target</code>, are there elements a, b, c, and d in <code>nums</code> such that a + b + c + d = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.<br><a id="more"></a></p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>The solution set must not contain duplicate quadruplets.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</p>
<p>A solution set is:<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题和前面几道关于数字之和的题应该是同一个系列(<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%941-Two-Sum/" target="_blank" rel="noopener" title="Two Sum">Two Sum</a>，<a href="http://wuyunjie.top/2019/04/07/LeetCode-15-3Sum/" target="_blank" rel="noopener" title="3Sum">3Sum</a>，<a href="http://wuyunjie.top/2019/04/09/LeetCode-16-3Sum-Closest/" target="_blank" rel="noopener" title="3Sum Closest">3Sum Closest</a>)。尽管难度有所提升，但是解题的思想和算法实际上都一致，其实也就是多了层循环。比如四个数a,b,c,d，我们可以先固定数a，然后寻找b,c,d，这就转换成了三数和的问题。</p>
<p>现在遇到了许多类似的问题，而且可以看出他们的解决方法具有一定规律，可以进行拓展。那么是不是可以找到一种泛化的方法计算KSUM，使得我们以后遇到5sum, 6sum…等等类似的问题时，不必再去重写这些算法，只用一个泛化的算法就可以搞定这一些。翻看评论区后，发现已经有人实现了这样的算法，主要是通过递归DFS实现的。每次先固定一个数，然后递归找到K-1SUM的结果。依次类推，直到找到2SUM返回最终结果，开始回溯。代码实现如下。</p>
<p>参考文献：<br><a href="https://leetcode.com/problems/4sum/discuss/8641/12ms-KSum-c%2B%2B-code" target="_blank" rel="noopener" title="12ms KSum, c++ code">[1] 12ms KSum, c++ code</a><br><a href="https://leetcode.com/problems/4sum/discuss/163559/C%2B%2B-solution-for-all-Ksum-question" target="_blank" rel="noopener" title="[1] C++ solution for all Ksum question">[2] C++ solution for all Ksum question</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="4SUM"><a href="#4SUM" class="headerlink" title="4SUM"></a>4SUM</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">3</span> || (nums.front() &gt; target &amp;&amp; nums.front() &gt; <span class="number">0</span>) || (nums.back() &lt; target &amp;&amp; nums.back() &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[n<span class="number">-3</span>]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>]&lt;target) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> tmp_target = target - nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n <span class="number">-2</span>  ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[j+<span class="number">1</span>]+nums[j+<span class="number">2</span>]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>]&lt;target) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> low = j+<span class="number">1</span>,high = n<span class="number">-1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>( low &lt; high)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[j] + nums[low] + nums[high];</span><br><span class="line">                    <span class="keyword">if</span>(sum == tmp_target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tuple = &#123;nums[i], nums[j], nums[low], nums[high]&#125;;</span><br><span class="line">                        res.push_back(tuple);</span><br><span class="line">                        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] == nums[++low] );</span><br><span class="line">                        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] == nums[--high] );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; tmp_target) high--;</span><br><span class="line">                    <span class="keyword">else</span> low++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="KSUM"><a href="#KSUM" class="headerlink" title="KSUM"></a>KSUM</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Valid for K &gt;= 2</span></span><br><span class="line">    <span class="comment">// k表示求ksum,nums是目标数组,l,r分别是左右游标</span></span><br><span class="line">    <span class="comment">// target是当前目标数, retVal是最终结果, cur是当前阶段的中间结果</span></span><br><span class="line">    <span class="comment">// ci表示当前是正在求第ci个数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">KSum</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; retVal, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="keyword">int</span> ci )</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mn, mx; <span class="comment">//mn表示当前最小的数，mx表示当前最大的数</span></span><br><span class="line">        <span class="keyword">int</span> km1 = k - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( r-l+<span class="number">1</span> &lt; k ) <span class="keyword">return</span>; <span class="comment">//若剩余的数比K小，已经无法找到结果，结束递归</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ( l &lt; r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新当前最小数和最大数</span></span><br><span class="line">            mn = nums[l];</span><br><span class="line">            mx = nums[r];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 若mn + (k-1)*mx &lt; target，mn太小，l右移</span></span><br><span class="line">            <span class="keyword">if</span> ( ( mn + km1*mx ) &lt; target ) l++;</span><br><span class="line">            <span class="comment">// 若(k-1)*mn + mx &gt; target，mx太大，r左移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( ( km1*mn + mx ) &gt; target ) r--;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// K=2,直接求出最终结果，其中包括去重操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( k == <span class="number">2</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                cur[ci] = mn;</span><br><span class="line">                cur[ci+<span class="number">1</span>] = mx;</span><br><span class="line">                retVal.push_back( cur );</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">while</span> ( ( l &lt; r ) &amp;&amp; ( nums[l] == mn ) ) l++;</span><br><span class="line">                r--;</span><br><span class="line">                <span class="keyword">while</span> ( ( l &lt; r ) &amp;&amp; ( nums[r] == mx ) ) r--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否者，递归转化为k-1 Sum的问题，递归求解</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur[ci] = mn; <span class="comment">//记录下当前可能的第ci个数</span></span><br><span class="line">                <span class="comment">//递归求解k-1 Sum</span></span><br><span class="line">                KSum( km1, nums, ++l, r, target - mn, retVal, cur, ci+<span class="number">1</span> );</span><br><span class="line">                <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">while</span> ( ( l &lt; r ) &amp;&amp; ( nums[l] == nums[l<span class="number">-1</span>] ) ) l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; RetVal;</span><br><span class="line">        <span class="comment">//初始化中间结果向量</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序，用于后面去重</span></span><br><span class="line">        sort( nums.begin(), nums.end() );</span><br><span class="line">        </span><br><span class="line">        KSum( <span class="number">4</span>, nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>, target, RetVal, cur, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RetVal;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--16. 3Sum Closest</title>
    <url>/2019/04/09/LeetCode--16-3Sum-Closest.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array <strong>nums</strong> of n integers and an integer <strong>target</strong>, find three integers in <strong>nums</strong> such that the sum is closest to <strong>target</strong>. Return the sum of the three integers. You may assume that each input would have exactly one solution.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given array nums = [-1, 2, 1, -4], and target = 1.</p>
<p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这个题和它的前一道题<a href="http://wuyunjie.top/2019/04/07/LeetCode-15-3Sum/" target="_blank" rel="noopener" title="15. 3Sum">15. 3Sum</a>很像，前一道题可以看做本题在target = 0时的特殊情况。但这道题进行了一定的改写和简化：</p>
<blockquote>
<ol>
<li>存在且仅存在一个解，所以我们可以在找到一个最优解后立即停止;</li>
<li>要寻找的是最接近target的三数和。也就是说可能会没有等于target的情况，比如题目的例子就是如此；另一方面只需要返回这三个数的和，不需要记录这三个数，所以对结果的记录和判断简化了。</li>
</ol>
</blockquote>
<p>我们只需要在15题的算法的基础上进行一定的修改就可以得到这道题的结果了。我们可以用同样的方法，先对数组进行排序，固定一个数a，然后去找另外两个数b和c的组合：</p>
<ol>
<li>如果我们只要找到两个数且和(b+c)为(target - a)，那么找到了最接近的三数和即target;</li>
<li>否者我们记录下当前数以及与target的距离(定义为|target-(a+b+c)|)，继续遍历数组找下一个更相近的三数和。</li>
</ol>
<p>同样的，在寻找过程中，我们可以跳过那些重复的组合，并且进行合适的剪枝进行优化。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> closesetDistance = <span class="built_in">abs</span>(nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[nums.size()<span class="number">-1</span>] - target);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>,high = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[low] + nums[high];</span><br><span class="line">                <span class="keyword">if</span>(sum == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(sum-target &lt; closesetDistance)</span><br><span class="line">                    &#123;</span><br><span class="line">                        closesetDistance = sum-target;</span><br><span class="line">                        res = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] == nums[--high]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target-sum &lt; closesetDistance)</span><br><span class="line">                    &#123;</span><br><span class="line">                        closesetDistance = target-sum;</span><br><span class="line">                        res = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] == nums[++low]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--20. Valid Parentheses</title>
    <url>/2019/04/14/LeetCode--20-Valid-Parentheses.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.<br><a id="more"></a><br>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: “()”<br>Output: true</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: “()[]{}”<br>Output: true</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: “(]”<br>Output: false</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input: “([)]”<br>Output: false</p>
</blockquote>
<p><strong>Example 5:</strong></p>
<blockquote>
<p>Input: “{[]}”<br>Output: true</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题很经典，也就是让我们判断给定的括号字符串是不是合法的，考察的应该是栈的运用。通过栈就可以很容易的解决问题，遍历字符串：</p>
<blockquote>
<ol>
<li>若遍历到是左括号<code>&#39;(&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;[&#39;</code>，将其推入栈中；</li>
<li>若遇到的是右括号，在栈顶找是否有匹配的左括号：若匹配成功，将栈顶弹出，继续遍历；若匹配失败，代表括号不合法，返回false.</li>
<li>遍历完字符串后，检查栈是否为空，若不空，代表不合法。</li>
</ol>
</blockquote>
<p>评论区有一种不使用stack的解法，它是直接在原字符串上模拟一个栈，保证只有左括号在栈内。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="使用stack"><a href="#使用stack" class="headerlink" title="使用stack"></a>使用stack</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; brackets;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'('</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        brackets.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">                    <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'&#123;'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        brackets.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">                    <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'['</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        brackets.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    brackets.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(brackets.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不使用stack"><a href="#不使用stack" class="headerlink" title="不使用stack"></a>不使用stack</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(top&lt;<span class="number">0</span> || !isMatch(s[top], s[i]))&#123;</span><br><span class="line">                ++top;</span><br><span class="line">                s[top] = s[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                --top;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">'('</span> &amp;&amp; c2 == <span class="string">')'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">'['</span> &amp;&amp; c2 == <span class="string">']'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">'&#123;'</span> &amp;&amp; c2 == <span class="string">'&#125;'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--21. Merge Two Sorted Lists</title>
    <url>/2019/04/14/LeetCode--21-Merge-Two-Sorted-Lists.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.<br><a id="more"></a><br>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>要求合并两个有序链表，新链表是由两个链表结点拼接得到，考察的是对链表的操作。思想是，每次从两个链表上取下一个结点，比较值的大小，较小的结点拼接到新链表后，较大的结点继续进行下一次比较。</p>
<p>这里需要注意的是链表边界的处理，比如对链表头结点的处理方式。可以先单独处理两个链表头结点，确定下新链表的头结点后，再继续继续下面的处理。也可以重新定义一个新的头结点，把链表结点都当做普通结点处理。最后可能有一个链表还有剩余的结点，直接将这些结点拼接到新链表末尾即可。</p>
<p>还可以使用递归的方式求解，但是递归的缺点是，若链表过长，可能会溢出。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> || l2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1 == <span class="literal">NULL</span>? l2 : l1;</span><br><span class="line">        </span><br><span class="line">        ListNode* resHead = l1-&gt;val &lt; l2-&gt;val?l1 : l2;</span><br><span class="line">        ListNode* cur = resHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val) l1=l1-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> l2=l2-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;next = l1==<span class="literal">NULL</span>?l2:l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> resHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义新的头结点dummy"><a href="#定义新的头结点dummy" class="headerlink" title="定义新的头结点dummy"></a>定义新的头结点dummy</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> || l2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1 == <span class="literal">NULL</span>? l2 : l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l2-&gt;next, l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--24. Swap Nodes in Pairs</title>
    <url>/2019/04/16/LeetCode--24-Swap-Nodes-in-Pairs.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.<br><a id="more"></a><br>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>要求交换链表中相邻两个结点的位置，并且要求不能修改结点的值，也就是只能将结点整个交换过去。我的思路很简单，从链表上依次“摘下”两个结点，交换其位置后再将得到的结果拼接回链表，题目并不难，主要是对链表的操作。可以按下面的图来表示(图参考自<a href="https://leetcode.com/problems/swap-nodes-in-pairs/discuss/11183/C%2B%2B-solution-with-graph-explanation." target="_blank" rel="noopener" title="C++ solution with graph explanation.">C++ solution with graph explanation.</a>)<br>/*</p>
<pre><code>   node1 = pre-&gt;next;node2 = node1-&gt;next
   #----&gt;@----&gt;@----&gt;@----&gt;@----&gt;@----&gt;@
               ^     ^     ^
               pre   node1 node2

  1. pre-&gt;next = node2
                __________
               /          \
   #----&gt;@----&gt;@     @----&gt;@----&gt;@----&gt;@
               ^     ^     ^
               pre   node1 node2

  2. node1-&gt;next = node2-&gt;next
                __________
               /          \
   #----&gt;@----&gt;@     @     @----&gt;@----&gt;@
                      \_________/
               ^     ^     ^
               pre   node1 node2

  3. node2-&gt;next = node1
               __________
              /          \
  #----&gt;@----&gt;@     @&lt;----@     @----&gt;@
                     \_________/
              ^     ^     ^
              pre   node1 node2

  4. pre = node1;
               __________
              /          \
  #----&gt;@----&gt;@     @&lt;----@     @----&gt;@
                     \_________/
                    ^
                    pre
</code></pre><p> */</p>
<p>同样的思想也可以用递归来实现</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode *pre = &amp;dummy;</span><br><span class="line">        ListNode *node1,*node2;</span><br><span class="line">        <span class="keyword">while</span>(pre)</span><br><span class="line">        &#123;</span><br><span class="line">            node1 = pre-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(node1&amp;&amp;node1-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                node2 = node1-&gt;next;</span><br><span class="line">                pre-&gt;next = node2;</span><br><span class="line">                node1-&gt;next = node2-&gt;next;</span><br><span class="line">                node2-&gt;next = node1;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !(head-&gt;next))</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *res = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(res-&gt;next);</span><br><span class="line">        res-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--19. Remove Nth Node From End of List</title>
    <url>/2019/04/11/LeetCode--19-Remove-Nth-Node-From-End-of-List.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a linked list, remove the n-th node from the end of list and return its head.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>Given n will always be valid.</p>
</blockquote>
<p><strong>Follow up :</strong></p>
<blockquote>
<p>Could you do this in one pass?</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目要求我们找到并删除链表的倒数第n个数。由于链表不支持随机访问，并且链表长度也不容易求，所以题目看似会很麻烦。但是以前经常会碰到这样的问题，比如求链表中间位置的数等等，对这类题目有过一定了解。其实很简单，只需要用两个指针就可实现一次扫描得到结果。</p>
<blockquote>
<p>首先第一个指针end先前进n，到达第n个结点后，第二个结点pre开始前进遍历；<br>两个指针end和pre同步前进，他们之间的距离是n，当end到达链表尾部时，pre指向的就是倒数第n个结点。<br>此时我们可以继续操作，进行要求的插入，删除等等。</p>
</blockquote>
<p>在寻找链表中点时，可以使用同样的方法。使用两个指针end,mid，两个指针同时前进，但此时，mid每前进一步，end会前进两步。那么当end到达终点时，mid恰好走过一半的结点，也就找到了链表的中点。</p>
<p>当然还有一种暴力解法，就是先计算出链表的长度L，然后找到第(L-n)个结点，把第 (L−n) 个结点的 next 指针重新链接至第 (L−n+2) 个结点。同样可以完成该算法。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *end = head;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) end = end-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(end == <span class="literal">NULL</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(end-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            end = end-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *count = head;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L++;</span><br><span class="line">            count=count-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> Lmn = L - n;</span><br><span class="line">        <span class="keyword">if</span>(Lmn == <span class="number">0</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Lmn<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode *temp = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--26. Remove Duplicates from Sorted Array</title>
    <url>/2019/04/17/LeetCode--26-Remove-Duplicates-from-Sorted-Array.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a sorted array nums, remove the duplicates <strong>in-place</strong> such that each element appear only once and return the new length.<br><a id="more"></a><br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Given nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p>
<p>It doesn’t matter what you leave beyond the returned length.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Given nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</p>
<p>It doesn’t matter what values are set beyond the returned length.</p>
</blockquote>
<p><strong>Clarification :</strong></p>
<blockquote>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题要求去除数字中的冗余项，而且只能使用O(1)的空间复杂度。看题目说明得知，我们返回的是处理后数组的长度，我们只需要保证数组前面有效部分的值，至于超出有效部分的值我们无需关心。</p>
<p>那么就可以很好处理，我们继续下当前最后一个有效位的位置，等到下一次遇到不重复的数时，将该数字移动到下一个有效位，然后更新有效位继续扫描数组。当完成一遍扫描后，所有不重复的值都移动到了数组的前端有效部分。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[last<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[last] = nums[i];</span><br><span class="line">                last++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--25. Reverse Nodes in k-Group</title>
    <url>/2019/04/16/LeetCode--25-Reverse-Nodes-in-k-Group.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.<br><a id="more"></a><br>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
</blockquote>
<p><strong>Note :</strong></p>
<ul>
<li>Only constant extra memory is allowed.</li>
<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>
</ul>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题又是对上一题的推广，leetcode这种由简入难的题挺多的。这次是要求对链表的K个结点反转，这里的K可以是任意的。我们可以依旧按照上一题的那种方式，将链表分为若干段：每次从链表上“摘下”k个结点的链表，把这个链表进行反转后，再放回原来的位置。对于链表的反转操作，我们可以利用构建链表时用的头插法来进行。这里在解决时碰到几个问题：</p>
<blockquote>
<ol>
<li>若剩下链表长度不够K时，我们不需要对这段链表进行反转，所以我们需要提前计算出链表的长度</li>
<li>需要记录下反转后的最后一个结点，用于在放回原链表时，可以和下一段连接起来。</li>
</ol>
</blockquote>
<p>还有一种方法，实现如下，这种方法思想上大致相同，这种方法不用单独计算链表长度，而是边计算长度边处理链表，每当数到k个结点时就反转一次。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.next = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* count = head;</span><br><span class="line">        <span class="keyword">int</span> Len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count)</span><br><span class="line">        &#123;</span><br><span class="line">            count=count-&gt;next;</span><br><span class="line">            Len++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* pre = &amp;dummy;</span><br><span class="line">        ListNode* last = head;</span><br><span class="line">        ListNode* temp = last;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        <span class="keyword">while</span>(Len &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//下一个待取的结点</span></span><br><span class="line">                next = temp-&gt;next;</span><br><span class="line">                <span class="comment">//插入头部</span></span><br><span class="line">                temp-&gt;next = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = temp;</span><br><span class="line">                temp = next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = last;last=next;</span><br><span class="line">            Len-=k;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = last;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *pre = dummy, *cur = head;</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; cur; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % k == <span class="number">0</span>) &#123;</span><br><span class="line">                pre = reverseOneGroup(pre, cur-&gt;next);</span><br><span class="line">                cur = pre-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseOneGroup</span><span class="params">(ListNode* pre, ListNode* next)</span> </span>&#123;</span><br><span class="line">        ListNode *last = pre-&gt;next, *cur = last-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur != next) &#123;</span><br><span class="line">            last-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            cur = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--27. Remove Element</title>
    <url>/2019/04/17/LeetCode--27-Remove-Element.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array <strong>nums</strong> and a value <strong>val</strong>, remove all instances of that value in-place and return the new length.<br><a id="more"></a><br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Given nums = [3,2,2,3], val = 3,</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p>It doesn’t matter what you leave beyond the returned length.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Given nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<p>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</p>
<p>Note that the order of those five elements can be arbitrary.</p>
<p>It doesn’t matter what values are set beyond the returned length.</p>
</blockquote>
<p><strong>Clarification :</strong></p>
<blockquote>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题与上一题类似，不够这次要求删除数组中指定的值。思想还是一样的：</p>
<blockquote>
<p>设置一个有效位last，遍历数组，遇到不等于val的值，就将它移动到last+1，然后更新last<br>当遍历完数组后，不等于val的值就都移动到了数组前端有效部分。</p>
</blockquote>
<p>但是这样会移动大量的元素，考虑是不是可以只移动值等于val的元素，由于数组的顺序可以改变，那么我们可以:</p>
<blockquote>
<p>将等于val的元素与最后一个值不等于val的元素交换</p>
</blockquote>
<p>这样当遍历完成后，所有等于val的值都被移动到了数组末尾无效部分。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=val)    nums[last++]=nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解2"><a href="#解2" class="headerlink" title="解2"></a>解2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, end=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = nums[end--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--28. Implement strStr()</title>
    <url>/2019/04/17/LeetCode--28-Implement-strStr.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Implement strStr().<br><a id="more"></a><br>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: haystack = “hello”, needle = “ll”<br>Output: 2</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: haystack = “aaaaa”, needle = “bba”<br>Output: -1</p>
</blockquote>
<p><strong>Clarification :</strong></p>
<blockquote>
<p>What should we return when needle is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这个题要求实现strStr()函数。实际上就是个字符串匹配过程，要求从haystack中寻找子串needle，若找到，返回子串开始位置；否知返回-1.</p>
<p>想到的有两种解法，一种是直接暴力求解，另一种是用KMP算法。</p>
<p>首先实现了暴力求解的算法。将haystack所有与needle一样长的子串进行比较，若成功找到，就返回当前子串其实位置；若最终未找到，返回-1.这种方法实现后，发现效果还算不错，没有想象的那么差。</p>
<p>之后实现了KMP算法，KMP算法可以利用next数组加速匹配过程。</p>
<blockquote>
<p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p>
<ul>
<li>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</li>
<li>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值.</li>
</ul>
</blockquote>
<p>这里重点是构造next数组，next数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next[j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀。</p>
<p>参考文献：<br>[1] <a href="https://www.cnblogs.com/yjiyjige/p/3263858.html" target="_blank" rel="noopener">（原创）详解KMP算法</a><br>[2] <a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" target="_blank" rel="noopener">很详尽KMP算法</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="暴力算法1"><a href="#暴力算法1" class="headerlink" title="暴力算法1"></a>暴力算法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.size(), n = needle.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m - n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="暴力算法2"><a href="#暴力算法2" class="headerlink" title="暴力算法2"></a>暴力算法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.size(), n = needle.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m - n; i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> substr = haystack.substr(i, n);</span><br><span class="line">            <span class="keyword">if</span> (substr == needle) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_KMP_Next(<span class="built_in">string</span> s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(s.length());</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>, k=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; s.length()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">-1</span> || s[j] == s[k])</span><br><span class="line">            &#123;</span><br><span class="line">                next[++j] = ++k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.length(), n = needle.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = get_KMP_Next(needle);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || haystack[i] == needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j == needle.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--22. Generate Parentheses</title>
    <url>/2019/04/14/LeetCode--22-Generate-Parentheses.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.<br><a id="more"></a><br>For example, given n = 3, a solution set is:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &quot;((()))&quot;,</span><br><span class="line">    &quot;(()())&quot;,</span><br><span class="line">    &quot;(())()&quot;,</span><br><span class="line">    &quot;()(())&quot;,</span><br><span class="line">    &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>以前做过类似的题，也就是求一组数字可以通过栈得到的所有合法排序。当时的做法是，先求出所有可能的排序，然后判断每一种排序的合法性。获取全排序可以通过函数next_permutation()做到：</p>
<blockquote>
<p>C++ STL中提供了std::next_permutation与std::prev_permutation可以获取数字或者是字符的全排列，其中std::next_permutation提供升序、std::prev_permutation提供降序。</p>
</blockquote>
<p>所以结合前面有一题判断括号是否有效。最开始的想法是将括号全排序后，找到有效的括号排列，放入结果集。遍历完所有可能后，就可以找到最终的结果了。</p>
<p>但是这种方法效率很低。另一种方法是，使用递归回溯，每次生成合法的括号序列加入结果集中，这种方法避免了生成无效排序。</p>
<blockquote>
<p>长度为 n 的序列就是 ‘(‘ 加上所有长度为 n-1 的序列，以及 ‘)’ 加上所有长度为 n-1 的序列。只有在保证序列仍然保持有效时才添加 ‘(‘ or ‘)’，我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号。</p>
</blockquote>
<p>还有一种方法，LeetCode上称之为Closure number，但感觉很像分治。我们可以把一个合法的括号字符串看做一个闭包，它必然起于左括号止于右括号，且每个合法括号串都可以从某个位置分为两个同样合法的括号串（包括空串），因此对于给定的n所可能构造的所有括号串都可以一步步划分为两个子闭包并解构（去掉头尾的一对左右括号）直到最小闭包——空串为止。基于以上分析，我们就可以从空串开始逆向一步步对两个子闭包之一构造新的闭包（在头尾各添加一个左/右括号）然后合并。这种方法还不是特别懂，只是跟着算法用c++重写了一遍。</p>
<p>参考文献：<br>[1] <a href="https://www.cnblogs.com/aiguona/p/7304945.html" target="_blank" rel="noopener" title="C++ STL 全排列函数详解">C++ STL 全排列函数详解</a><br>[2] <a href="https://blog.csdn.net/weixin_34216107/article/details/86906251" target="_blank" rel="noopener" title="LeetCode Record C++">LeetCode Record C++</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="全排序后筛选"><a href="#全排序后筛选" class="headerlink" title="全排序后筛选"></a>全排序后筛选</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; brackets;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    brackets.pop();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> brackets.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(brackets.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> parentheses = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) parentheses+=<span class="string">"()"</span>;</span><br><span class="line">        </span><br><span class="line">        sort(parentheses.begin(), parentheses.end());</span><br><span class="line">        result.push_back(parentheses);</span><br><span class="line">        <span class="keyword">while</span>(next_permutation(parentheses.begin(), parentheses.end()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(parentheses)) result.push_back(parentheses);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result, <span class="built_in">string</span> cur, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.length() == max*<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(open &lt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrack(result, cur+<span class="string">"("</span>, open+<span class="number">1</span>, close, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(close &lt; open)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrack(result, cur+<span class="string">")"</span>, open, close+<span class="number">1</span>, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        backtrack(result, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="闭包数"><a href="#闭包数" class="headerlink" title="闭包数"></a>闭包数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> left:generateParenthesis(c))</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> right:generateParenthesis(n<span class="number">-1</span>-c))</span><br><span class="line">                        result.push_back(<span class="string">"("</span>+left+<span class="string">")"</span>+right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--23. Merge k Sorted Lists</title>
    <url>/2019/04/16/LeetCode--23-Merge-k-Sorted-Lists.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Input:<br>[<br> 1-&gt;4-&gt;5,<br> 1-&gt;3-&gt;4,<br> 2-&gt;6<br>]<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>前面有一题是合并两个有序的链表，这道题就相当于进一步泛化。</p>
<p>考虑到我们已经有了合并两个链表的方法，那么我们就可以把这个问题分解。每次把链表数组中的两个链表合并，直到只剩下一个链表为之。这时这个剩下的链表就是我们需要的结果。实现后的确解决了问题，但是效率不高。</p>
<p>进一步思考，既然合并链表的过程都是类似的，那么是不是可以用分治来做，将合并K个链表分解为合并两个子问题的结果——合并K/2个链表。这样逐步分解下去，可以划分为许多更容易解决的子问题。结合递归实现后，效率得到了极大提升，分治算法的思想果然厉害。细想起来，归并排序的思想似乎也是这样。</p>
<p>在题解中发现还有一种有意思的解法，使用priority_queue求解。由priority_queue的特性，我们可以设置在队列头部总是一个值最小的结点，那么我们就可以把所有链表第一个结点输入这个队列中。每次从队列得到最小的结点放入新链表，将该节点对应链表的下一个结点放入队列。这个重复不断进行，最终可以得到一个新的有序链表。这时候的priority_queue其实相当于一个小顶堆。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="逐一合并"><a href="#逐一合并" class="headerlink" title="逐一合并"></a>逐一合并</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode* newList = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(lists.size() &gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists.size() == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                newList = lists.back();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* list1 = lists.back();</span><br><span class="line">                lists.pop_back();</span><br><span class="line">                ListNode* list2 = lists.back();</span><br><span class="line">                lists.pop_back();</span><br><span class="line">                newList = mergeTwoLists(list1,list2);</span><br><span class="line">                lists.push_back(newList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKL</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end - begin == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(lists[begin],lists[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(end == begin) <span class="keyword">return</span> lists[begin];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(end &lt; begin) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (begin+end)/<span class="number">2</span>;</span><br><span class="line">            ListNode* list1 = mergeKL(lists, begin, mid);</span><br><span class="line">            ListNode* list2 = mergeKL(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(list1, list2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeKL(lists, <span class="number">0</span>, lists.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="priority-queue解法"><a href="#priority-queue解法" class="headerlink" title="priority_queue解法"></a>priority_queue解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp=[](ListNode* a, ListNode* b) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;ListNode*,<span class="built_in">vector</span>&lt;ListNode*&gt;,<span class="keyword">decltype</span>(cmp)&gt; pq(cmp);</span><br><span class="line">        ListNode dummy(0),*p=&amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (ListNode *node:lists) <span class="keyword">if</span> (node) pq.push(node);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.top()-&gt;next) pq.push(pq.top()-&gt;next);</span><br><span class="line">            p-&gt;next=pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--29. Divide Two Integers</title>
    <url>/2019/04/22/LeetCode--29-Divide-Two-Integers.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.<br><a id="more"></a><br>Return the quotient after dividing <strong>dividend</strong> by <strong>divisor</strong>.</p>
<p>The integer division should truncate toward zero.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: dividend = 10, divisor = 3<br>Output: 3</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: dividend = 7, divisor = -3<br>Output: -2</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<ul>
<li>Both dividend and divisor will be 32-bit signed integers.</li>
<li>The divisor will never be 0.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.</li>
</ul>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目要求实现除法，并且不能使用乘法、除法和模这些操作。这就意味着我们只能使用加减或者位运算，来实现除法的过程。</p>
<p>第一种思路是，用被除数减去除数，知道被除数小于除数时，返回减法进行的次数。</p>
<p>这需要先对输入的两个数进行处理，若除数或被除数是负数，不能直接进行减法，需要先取他们的绝对值。但这是会出现越界的情况，如-2^31的绝对值就越界了，int不能存储。但是题目要求的是只能用32-bit的环境，所以不能用long来解决了，这里想到的是使用unsigned int来保存绝对值结果。这时又碰到了另一个问题，abs()函数也无法处理越界的数，即求abs(-2^31)时会报错，解决方法是使用labs()函数，或者重写一个abs()，可以实现需要的_abs()如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> temp = value;</span><br><span class="line">    <span class="keyword">return</span> (temp &gt; <span class="number">0x80000000</span>) ? -value : temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除此之外，还需要单独判断一种结果溢出的情况，也就是<code>dividend = -2^31，divisor = -1</code> 的情况，这时直接输出INT_MAX即可。</p>
<p>这种方法效率太低，最后超时了。在这种方法基础上可以进行优化。可以加入位运算，如果被除数大于除数，找到小于被除数的，且是除数2^n的最大的数，被除数减去该数，结果加上n后，重复上述操作，直到被除数小于除数为止。这里寻找这个符合条件的数时，就可以运用位运算。</p>
<p>还有一种比较有意思的解法，就是运用对数求解。首先分别求出被除数和除数的对数，算出它们的差后，将其作为指数，求 e 的指数结果。公式如下：<br>    a/b = e^(log(a) - log(b))<br>但是计算对数时，应该使用了除法/，所以可能违反了条件。</p>
<p>参考：<br><a href="https://blog.csdn.net/zephyr_be_brave/article/details/8722397" target="_blank" rel="noopener" title="C++自己实现abs">C++自己实现abs</a><br><a href="https://leetcode.com/problems/divide-two-integers/discuss/13407/C%2B%2B-bit-manipulations" target="_blank" rel="noopener" title="C++ bit manipulations">C++ bit manipulations</a><br><a href="https://leetcode.com/problems/divide-two-integers/discuss/13460/6-line-solution-C%2B%2B" target="_blank" rel="noopener" title="6 line solution C++">6 line solution C++</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="只用加减法（超时）"><a href="#只用加减法（超时）" class="headerlink" title="只用加减法（超时）"></a>只用加减法（超时）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divd = __abs(dividend);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divr = __abs(divisor);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(divd &gt;= divr)</span><br><span class="line">        &#123;</span><br><span class="line">            divd -= divr;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> copyed_value = value;</span><br><span class="line">        <span class="keyword">return</span> (copyed_value &gt; <span class="number">0x80000000</span>) ? -value : copyed_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="加入位运算"><a href="#加入位运算" class="headerlink" title="加入位运算"></a>加入位运算</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divd = __abs(dividend);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divr = __abs(divisor);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(divd &gt;= divr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> temp = divr; <span class="keyword">unsigned</span> m = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>((temp &lt;&lt; <span class="number">1</span>) &lt;= divd &amp;&amp; temp != <span class="number">2147483648</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            divd -= temp;</span><br><span class="line">            result += m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> copyed_value = value;</span><br><span class="line">        <span class="keyword">return</span> (copyed_value &gt; <span class="number">0x80000000</span>) ? -value : copyed_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="对数求解"><a href="#对数求解" class="headerlink" title="对数求解"></a>对数求解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divd = __abs(dividend);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divr = __abs(divisor);</span><br><span class="line">        </span><br><span class="line">        result = <span class="built_in">exp</span>(<span class="built_in">log</span>(divd)-<span class="built_in">log</span>(divr));</span><br><span class="line">        <span class="keyword">return</span> sign * result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> copyed_value = value;</span><br><span class="line">        <span class="keyword">return</span> (copyed_value &gt; <span class="number">0x80000000</span>) ? -value : copyed_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--31. Next Permutation</title>
    <url>/2019/04/22/LeetCode--31-Next-Permutation.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.<br><a id="more"></a><br>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
</blockquote>
<pre><code>1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</code></pre><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>前不久好像刚在一道题用过这个函数，现在就遇到实现这个函数了。对于全排列的具体实行过程不是很熟悉，没有什么思路。在查看题解后，发现对于这个问题，14世纪就有人已经提出了简单的解法——<a href="https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order" target="_blank" rel="noopener" title="Generation in lexicographic order">Generation in lexicographic order</a>，算法思路如下：</p>
<blockquote>
<ol>
<li>从右到左，找到第一对连续的数a[i]和a[i-1]，使得满足a[i] &gt; a[i-1];这样a[i]右边的序列就是一个降序的排列（这个序列理论上没有下一个排列，题目中让这种情况的下一个变成了第一个）。如果这一步没有找到上述连续数对，直接将数列反转即可得到最终结果。</li>
<li>从 a[i] 开始的降序排序中找到刚好大于a[i-1]的数 a[k]，将两个数进行交换。</li>
<li>将降序的数列a[i:]反转，得到下一个排列。</li>
</ol>
</blockquote>
<p><a href="https://imgchr.com/i/EkLSDe" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/22/EkLSDe.gif" alt="EkLSDe.gif"></a></p>
<p>讨论区有一种调用库实现上述算法的代码。代码很短，从里面学到了一些STL的函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = is_sorted_until(nums.rbegin(), nums.rend());</span><br><span class="line">    <span class="keyword">if</span> (i != nums.rend())</span><br><span class="line">        swap(*i, *upper_bound(nums.rbegin(), i, *i));</span><br><span class="line">    reverse(nums.rbegin(), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>is_sorted_until(), 它返回序列中“失序”的元素。 如果整个序列被排序（根据谓词），那么它将返回最后一个。</p>
<p>rbegin 和 rend, 反向迭代器, 分别返回指向容器尾元素和首元素前一位置的反向迭代器。</p>
<p>upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的<strong>地址</strong>，不存在则返回end。lower_bound( begin,end,num)类似，不过它找的是第一个小于等于num的数。</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), i, k;</span><br><span class="line">        <span class="keyword">for</span>(i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reverse(nums.begin(), nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(k = n - <span class="number">1</span>; k &gt; i; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            swap(nums[i<span class="number">-1</span>], nums[k]);</span><br><span class="line">            reverse(nums.begin() + i, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = is_sorted_until(nums.rbegin(), nums.rend());</span><br><span class="line">    <span class="keyword">if</span> (i != nums.rend())</span><br><span class="line">        swap(*i, *upper_bound(nums.rbegin(), i, *i));</span><br><span class="line">    reverse(nums.rbegin(), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--3. Longest Substring Without Repeating Characters</title>
    <url>/2019/03/28/LeetCode--3-Longest-Substring-Without-Repeating-Characters.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3. </p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>Input: “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</p>
</blockquote>
<p><strong>Example3:</strong></p>
<blockquote>
<p>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3. </p>
<ul>
<li>Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</li>
</ul>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目要求的是，最长不含重复元素的字串。<br>最开始的想法是，用一个向量数组，存储以每一个位置为终点，包含该位置字符在内的最长不含重复元素的字串的长度，相当于一个dp的算法。数组更新方式是：用一个二重循环，外循环是从第一个字符到最后一个字符一次遍历；内循环用于判断，以该位置字符为终点，可以得到的最长不重复字串有多长。该算法成功解决了问题。<br>后来继续分析程序，发现可以不使用向量数组，因为数组内的每一个元素的值只需要访问一次，直接用一个变量保存即可。用此方法改进后，速度和空间都得到了优化。</p>
<blockquote>
<p>讨论区有另外一种更优化的解法，代码中用vector生成256个-1，用来存储每个字符上一次出现的下标。代码比较抽象，理解如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v(<span class="number">256</span>,<span class="number">-1</span>); <span class="comment">//构造字符串的容器。初始化为-1，意思是暂时不存在这个字符。</span></span><br><span class="line">start=<span class="number">-1</span>; <span class="comment">//start用来记录子串开始的位置，初始化为-1，表示没有开始构造子字符串。</span></span><br><span class="line"><span class="keyword">if</span>(v[s[i]]&gt;start)<span class="comment">//已经在该字符出现之前出现过相同的字符了，那么就将start也就是开始位置标记为上次该字符的出现位置。</span></span><br><span class="line">	start=v[s[i]]; </span><br><span class="line">v[s[i]]=i; <span class="comment">//更新字符在容器中对应的下标</span></span><br><span class="line">ans=max(ans,i-start); <span class="comment">//i-start的意思是，当前for循环的i（也就是子字符串的结束字符）减去子字符串结束的字符的下标位置，结果就是子字符串的长度。</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li>解法1(使用了向量数组)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="comment">//空字符串，直接返回0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>; <span class="comment">//非空字符串，最短为1</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; longestsub; <span class="comment">//每个位置的最长不重复字串长度</span></span><br><span class="line">        longestsub.push_back(<span class="number">1</span>); <span class="comment">//初始化第一个位置</span></span><br><span class="line">		<span class="comment">//遍历每一个位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            longestsub.push_back(<span class="number">1</span>);</span><br><span class="line">			<span class="comment">//从上一个位置的最长不重复字串为起点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-longestsub[i<span class="number">-1</span>];j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">//没有重复，继续计算</span></span><br><span class="line">                <span class="keyword">if</span>(s[j]!=s[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    longestsub[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//有重复，从1开始重新计数</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    longestsub[i]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//记录最长长度</span></span><br><span class="line">            <span class="keyword">if</span>(longestsub[i]&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                max=longestsub[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>不使用数组</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> Longest=<span class="number">1</span>,Last=<span class="number">1</span>;<span class="comment">//记录最长长度和上一字符的最长不重复字串长度</span></span><br><span class="line">        <span class="comment">//vector&lt;int&gt; longestsub;</span></span><br><span class="line">        <span class="comment">//longestsub.push_back(1);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//longestsub.push_back(1);</span></span><br><span class="line">            <span class="keyword">int</span> present=<span class="number">1</span>;<span class="comment">//计算当前位置最长不重复字串长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-Last;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j]!=s[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    present++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    present=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Longest=max(Longest,present);</span><br><span class="line">            Last=present;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.解法3</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict[s[i]] &gt; start)</span><br><span class="line">                start = dict[s[i]];</span><br><span class="line">            dict[s[i]] = i;</span><br><span class="line">            maxLen = max(maxLen, i - start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--30. Substring with Concatenation of All Words</title>
    <url>/2019/04/22/LeetCode--30-Substring-with-Concatenation-of-All-Words.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in <strong>s</strong> that is a concatenation of each word in <strong>words</strong> exactly once and without any intervening characters.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input:<br>&nbsp;&nbsp;&nbsp;&nbsp; s = “barfoothefoobarman”,<br>&nbsp;&nbsp;&nbsp;&nbsp; words = [“foo”,”bar”]<br>Output: [0,9]<br>Explanation: Substrings starting at index 0 and 9 are “barfoor” and “foobar” respectively.<br>The output order does not matter, returning [9,0] is fine too.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input:<br>&nbsp;&nbsp;&nbsp;&nbsp; s = “wordgoodgoodgoodbestword”,<br>&nbsp;&nbsp;&nbsp;&nbsp; words = [“word”,”good”,”best”,”word”]<br>Output: []</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题让我们求串联所有单词的子串，就是说给定一个长字符串，再给定几个长度相同的单词，让从长字符串中找出串联给定所有单词的子串的起始位置。</p>
<p>最开始以为单词不重复，所以最初的想法是。用一个map来记录每次单词上一次出现的位置，以及用indexStart记录当前子串开始位置。之后不断检查，若检测到单词不在words内或者单词上次出现在indexStart之后即重复了，就重新进行下一次检查。但是words内单词是可以重复的，所以这种方法行不通，需要记录单词出现的次数。</p>
<p>所以要用到两个map，第一个map内存入words内每个单词可以出现的次数，第二个map存储当前扫描的子串内，单词已经出现的次数。从头开始扫描字符串，每次得到一个单词，看其是否在word内以及出现次数是否在要求范围内，如果不满足，则进行下一次扫描。如果正好匹配完给定单词集里所有的单词，则把开始地址存入结果中。</p>
<p>算法可以继续优化，我们不必每次都从头开始判断每个单词。可以设置一个单词组成字符串大小的滑动窗口。</p>
<blockquote>
<p>若当前判断的单词超过限制的出现次数时导致匹配失败，将窗口后移到该子串中该单词第一个出现的位置之后；<br>若当前判断的单词不在words中导致匹配失败，将窗口完全移动到该单词之后。<br>若判断到窗口最后的位置且匹配成功，记录下当前窗口的开始位置，将窗口后移一个单词长度，继续下一次判断。</p>
</blockquote>
<p>我们同时也可以减少到只使用一个map，map记录单词可以出现的次数，没出现一次就减一。在窗口移动时，我们可以同时恢复现场。这种使用滑动窗口的方法，省去了大量重复的或者不必要的判断，所以算法性能得到极大提升。</p>
<p>查看评论区发现还有一种解法，这种解法思想很巧妙，有些复杂也不是特别懂，在这写下大致思想：</p>
<blockquote>
<ol>
<li>定义一个hash函数，将每个单词映射到一个唯一的值上</li>
<li>用定义好的hash函数，计算出words总的hash值words_hashsum</li>
<li>还是使用一个窗口，先计算第一个窗口内对应字符串的hashsum,与words的hash_sum比较，若相等则把窗口开始位置记录下来。</li>
<li>窗口后移一个位置，继续计算其hashsum进行判断。</li>
</ol>
</blockquote>
<p>这种方法尽管最后能求解ac，但感觉可能存在问题，比如两个单词 a, c的hash值分别为1 3, b的hash值为2, 那么可能(a,c)的组合和(b,b)的组合hashsum相等，所以是有可能会出错的。</p>
<p>参考：<br><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/13791/" target="_blank" rel="noopener">My 24ms C++ solution (O(N) time, using an unordered_map)</a><br><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/192123/" target="_blank" rel="noopener">O(n) C++ solution, 8ms, beats 100%</a><br><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/13700/" target="_blank" rel="noopener">My AC c++ code, O(n) complexity, 26ms</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="两个哈希表"><a href="#两个哈希表" class="headerlink" title="两个哈希表"></a>两个哈希表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordfound,counts;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.empty() || words.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> wordsize = words.size(), wordlen = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> slen = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words) counts[word]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= slen - wordsize * wordlen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; wordsize; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> temp = s.substr(i + j*wordlen, wordlen);</span><br><span class="line">                <span class="keyword">if</span>(counts[temp] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                wordfound[temp]++;</span><br><span class="line">                <span class="keyword">if</span>(wordfound[temp] &gt; counts[temp]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == wordsize) res.push_back(i);</span><br><span class="line">            wordfound.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="滑动窗口的方法"><a href="#滑动窗口的方法" class="headerlink" title="滑动窗口的方法"></a>滑动窗口的方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; counts;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.empty() || words.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> wordsize = words.size(), wordlen = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> slen = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(slen &lt; wordsize * wordlen) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start, cur, founded;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words) counts[word]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordlen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            start = cur = i;</span><br><span class="line">            founded = wordsize;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(start &lt;= slen - wordsize * wordlen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//单词不在words内,整个窗口后移到后一个单词</span></span><br><span class="line">                <span class="keyword">if</span>(counts.count(s.substr(cur,wordlen)) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    founded = wordsize;</span><br><span class="line">                    <span class="keyword">for</span>(;start != cur; start += wordlen)</span><br><span class="line">                        counts[s.substr(start,wordlen)]++;</span><br><span class="line">                    start += wordlen;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(counts[s.substr(cur,wordlen)] == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//单词出现次数超过限制,窗口移动到该单词第一次出现的下一个位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(;s.substr(start,wordlen) != s.substr(cur,wordlen);start += wordlen)</span><br><span class="line">                    &#123;</span><br><span class="line">                        counts[s.substr(start,wordlen)]++;</span><br><span class="line">                        founded++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    start += wordlen;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    counts[s.substr(cur,wordlen)]--;</span><br><span class="line">                    <span class="keyword">if</span>(--founded == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(start);</span><br><span class="line">                        counts[s.substr(start,wordlen)]++;</span><br><span class="line">                        start += wordlen;</span><br><span class="line">                        founded++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += wordlen;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(;start&lt;cur;start+=wordlen)</span><br><span class="line">                counts[s.substr(start,wordlen)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; retVal;</span><br><span class="line">        <span class="keyword">if</span> (words.size()&lt;<span class="number">1</span> || s.size()&lt;<span class="number">1</span>) <span class="keyword">return</span> retVal;</span><br><span class="line">        <span class="comment">// Hash all the words seperately then add them together to get a magic number</span></span><br><span class="line">        <span class="built_in">std</span>::hash&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; hash_fn;</span><br><span class="line">        <span class="keyword">size_t</span> magicNumber = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.size(); i++) &#123;</span><br><span class="line">            magicNumber += hash_fn(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> wordLength = words[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// Concatenated substring will be a given length</span></span><br><span class="line">        <span class="keyword">int</span> minimumSize = words.size()*wordLength;</span><br><span class="line">        <span class="comment">// We do a sliding window calculation for each 'offset' a pattern might have</span></span><br><span class="line">        <span class="comment">// This is faster than re-hashing the entire window because we can just drop the least recently hashed value</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> startOffset=<span class="number">0</span>; startOffset&lt;wordLength; startOffset++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">size_t</span> hashSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> minimum = <span class="number">0L</span>L-minimumSize-startOffset+s.size();</span><br><span class="line">            <span class="comment">// This means that the requested offset does not leave us with enough characters in the string!</span></span><br><span class="line">            <span class="keyword">if</span> (minimum &lt; <span class="number">0</span>) <span class="keyword">return</span> retVal;</span><br><span class="line">            <span class="keyword">for</span> (i=s.size()-startOffset-wordLength; i&gt;=minimum; i-=wordLength) &#123;</span><br><span class="line">                hashSum+=hash_fn(s.substr(i,wordLength));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hashSum==magicNumber) retVal.push_back(i+wordLength);</span><br><span class="line">            <span class="keyword">for</span> (;i&gt;=<span class="number">0</span>; i-=wordLength) &#123;</span><br><span class="line">                hashSum-=hash_fn(s.substr(i+minimumSize,wordLength));</span><br><span class="line">                hashSum+=hash_fn(s.substr(i,wordLength));</span><br><span class="line">                <span class="keyword">if</span> (hashSum==magicNumber) retVal.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--34. Find First and Last Position of Element in Sorted Array</title>
    <url>/2019/04/23/LeetCode--34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given <strong>target</strong> value.<br><a id="more"></a><br>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: nums = [5,7,7,8,8,10], target = 8<br>Output: [3,4]</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: nums = [5,7,7,8,8,10], target = 6<br>Output: [-1,-1]</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>依旧是以O(log n)复杂度查找一个数。这道题给出的数组是有序的而且可以有重复元素，要求给出target出现的范围。</p>
<p>因为数组完全有序，所以思路依旧是使用二分查找。首先用二分查找，查找一个等于target的元素的位置，然后从该位置开始左右拓展，从而找到target出现的范围。若没有找到该数，直接返回<code>{-1, -1}</code>即可。可以看出，算法思路很简单。</p>
<p>但是这可能不是严格意义上的O(logn)的算法，因为在最坏的情况下会变成O(n)，比如当数组里的数全是目标值的话，从中间向两边找边界就会一直遍历完整个数组。一种真正意义上的O(logn)的算法是，使用两次二分查找法，第一次找到左边界，第二次调用找到右边界即可。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[low] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> start = low, end = low;</span><br><span class="line">            <span class="keyword">while</span>(start &gt; <span class="number">0</span> &amp;&amp; nums[start<span class="number">-1</span>] == nums[start]) start--;</span><br><span class="line">            <span class="keyword">while</span>(end &lt; nums.size()<span class="number">-1</span> &amp;&amp; nums[end+<span class="number">1</span>] == nums[end]) end++;</span><br><span class="line">            <span class="keyword">return</span> &#123;start,end&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="两遍二分查找"><a href="#两遍二分查找" class="headerlink" title="两遍二分查找"></a>两遍二分查找</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(high &lt; <span class="number">0</span> || nums[high] != target) <span class="keyword">return</span> res;</span><br><span class="line">        res[<span class="number">0</span>] = high;high = nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>] = high - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--33. Search in Rotated Sorted Array</title>
    <url>/2019/04/23/LeetCode--33-Search-in-Rotated-Sorted-Array.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br><a id="more"></a><br>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: nums = [4,5,6,7,0,1,2], target = 0<br>Output: 4</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: nums = [4,5,6,7,0,1,2], target = 3<br>Output: -1</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>看见要求算法复杂度O(log n)，并且数组有序（轮转有序），最先想到的是，用二分查找。</p>
<p>但是二分法需要进行修改，不能直接使用。第一中方法是，对二分查早进行改进，使它符合这道题：</p>
<blockquote>
<p>二分搜索法的关键在于获得了中间数后，判断下面要搜索左半段还是右半段，我们可以观察到一种规律，如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了。</p>
</blockquote>
<p>另一种方法是，我们还是使用原来的二分查找算法。不过我们需要先找到数组轮转的位置。如对于数组 <code>[4,5,6,7,0,1,2]</code>，可以找到轮转pivot是7，下标是3。根据pivot，可以把数组分为真正有序的两部分，判断target可能出现在哪部分，再继续用原来的二分查找就可以得到结果了。这里寻找pivot也可以用二分查找实现，复杂度依旧是O(log n)。</p>
<p>可以用异或来编写判断语句使代码更精简，代码如下。</p>
<p>参考：<br><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14419/" target="_blank" rel="noopener">Pretty short C++/Java/Ruby/Python</a><br><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14435/Clever-idea-making-it-simple" target="_blank" rel="noopener">Clever idea making it simple</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="修改后的二分查找"><a href="#修改后的二分查找" class="headerlink" title="修改后的二分查找"></a>修改后的二分查找</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="寻找pivot"><a href="#寻找pivot" class="headerlink" title="寻找pivot"></a>寻找pivot</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPivot</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])</span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low == high &amp;&amp; nums[low] == target) <span class="keyword">return</span> low;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = findPivot(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target &lt;= nums[pivot] &amp;&amp; target &gt;= nums[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(nums, <span class="number">0</span>, pivot, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(nums, pivot+<span class="number">1</span>, nums.size()<span class="number">-1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用异或"><a href="#使用异或" class="headerlink" title="使用异或"></a>使用异或</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="keyword">int</span>(nums.size()) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((nums[<span class="number">0</span>] &gt; target) ^ (nums[<span class="number">0</span>] &gt; nums[mid]) ^ (target &gt; nums[mid]))</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hi = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo == hi &amp;&amp; nums[lo] == target ? lo : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--32. Longest Valid Parentheses</title>
    <url>/2019/04/23/LeetCode--32-Longest-Valid-Parentheses.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: “(()”<br>Output: 2<br>Explanation: The longest valid parentheses substring is “()”</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: “)()())”<br>Output: 4<br>Explanation: The longest valid parentheses substring is “()()”</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>给定了一个括号的字符串，求最长有效子串的长度。</p>
<p>首先就是暴力解法，逐个字符遍历字符串，判断从当前字符开始的最大有效括号长度，若大于已经找到的最大有效长度，则更新最大有效长度。遍历完成后，也就找到了最长有效长度。这种方法思路简单而且没有超时，但是效率很低。</p>
<p>主要是因为整个过程会有许多重复的判断。这个问题可以用动态规划来求解：定义一个数组dp，保存以字符串中第i个字符为结尾的最长有效子串的长度。由于有效字符串是以 ‘)’ 结束的，所以 ‘(‘ 必定不构成有效子串。所以我们将dp初始化为全0，当遇到 ‘)’ 时才更新dp数组，更新规则如下：</p>
<blockquote>
<ol>
<li>若s[i] == ‘)’ 且 s[i-1] == ‘(‘，即形如“……()”，更新dp[i] = dp[i - 2] + 2</li>
<li>若s[i] == ‘)’ 且 s[i-1] == ‘)’，即形如”……))”，此时若s[i - dp[i-1] - 1] == ‘(‘，更新dp[i] = dp[i - 1] + dp[i - dp[i-1] - 2] + 2</li>
</ol>
</blockquote>
<p>每次更新dp后，判断当前更新后的值是否比已经找到的最长有效长度大，若是则更新最长有效长度。当dp更新完成后，也就找到了最长有效长度。这种方法只需要扫描一遍字符串，避免了重复的判断。</p>
<p>除了这两种方法外，还有两种算法：</p>
<blockquote>
<ol>
<li><p>使用栈<br>初始化一个栈，先在栈中存入-1。之后遍历给定的字符串，判断当前扫描的字符串是不是有效的，同时更新最长有效长度。<br> 1) 若遇到 ‘(‘，将其下标推入栈内<br> 2) 若遇到 ‘)’，从栈顶弹出一个元素后，用当前元素下标减去剩下栈顶的元素，得到一个当前元素的有效子串长度。若从栈顶弹出元素后，栈空，就将当前元素的下标放入栈内继续遍历。<br>遍历完字符串后，找到最长有效长度。</p>
</li>
<li><p>不使用额外空间<br>用两个计数器 left 和 right ，记录当前遇到的有效左括号数和右括号数。分两遍扫描字符串：<br> 1) 先从左向右扫描，遇到 “(“ 就增加left，遇到 ‘)’ 就增加right，当left和right相等时，得到一个有效子串，计算该有效子串长度并更新最长有效长度。若right大于left，将left和right都置0，继续扫描。<br> 2) 用相同的步骤，从右向左再扫描一编。</p>
</li>
</ol>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur = <span class="number">0</span>; cur &lt; s.length(); cur++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> open = <span class="number">0</span>, close = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=cur; i&lt;s.length(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    open++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ++close;</span><br><span class="line">                    <span class="keyword">if</span>(close == open)</span><br><span class="line">                        longest = max(longest, i-cur+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(close &gt; open)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(longest &gt;= (s.length() - cur))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="DP算法"><a href="#DP算法" class="headerlink" title="DP算法"></a>DP算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.length(), <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = i<span class="number">-2</span> &gt;= <span class="number">0</span> ? dp[i<span class="number">-2</span>]+<span class="number">2</span> : <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i - dp[i<span class="number">-1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i - dp[i<span class="number">-1</span>] - <span class="number">1</span>] == <span class="string">'('</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>] + <span class="number">2</span> + ((i-dp[i<span class="number">-1</span>]<span class="number">-2</span> &gt;= <span class="number">0</span>)?dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]:<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                longest = max(dp[i], longest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">stack</span>.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> curlen = i - <span class="built_in">stack</span>.top();</span><br><span class="line">                    longest = max(longest, curlen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不使用额外空间，两遍扫描"><a href="#不使用额外空间，两遍扫描" class="headerlink" title="不使用额外空间，两遍扫描"></a>不使用额外空间，两遍扫描</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>, close = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>) open++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++close;</span><br><span class="line">                <span class="keyword">if</span>(close == open)</span><br><span class="line">                    longest = max(longest, <span class="number">2</span>* open);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(close &gt; open)</span><br><span class="line">                &#123;</span><br><span class="line">                    open = close = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        open = close = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (<span class="keyword">int</span>)s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) close++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++open;</span><br><span class="line">                <span class="keyword">if</span>(close == open)</span><br><span class="line">                    longest = max(longest, <span class="number">2</span>* open);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(open &gt; close)</span><br><span class="line">                &#123;</span><br><span class="line">                    open = close = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--35. Search Insert Position</title>
    <url>/2019/04/24/LeetCode--35-Search-Insert-Position.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br><a id="more"></a><br>You may assume no duplicates in the array.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: [1,3,5,6], 5<br>Output: 2</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: [1,3,5,6], 2<br>Output: 1</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: [1,3,5,6], 7<br>Output: 4</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input: [1,3,5,6], 0<br>Output: 0</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>显然，这道题还是可以使用二分查找求解。使用二分搜索查找target，若找到了，直接返回找到的下标。若target不存在，二分搜索结束后，low所指向的位置就是target插入的位置。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--4. Median of Two Sorted Arrays</title>
    <url>/2019/03/31/LeetCode--4-Median-of-Two-Sorted-Arrays.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.<br><a id="more"></a><br>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>The median is 2.0</p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>The median is (2 + 3)/2 = 2.5</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>最先想到的方法是，既然两个数组是有序的，可以直接归并两个数组，之后可以直接找到中位数。但题目对时间有要求，这种方法的时间复杂度是O(m+n)，比要求的O(log(m+n))显然要大，所以不能用这种暴力的方法。</p>
<p>仔细分析问题，既然两个数组都是有序的，那么可以不必将数组归并，可以直接挨个比较两个数组，找到中间的那两个数(数组为奇数长度下，找中间一个数)，就可以停止下来，不必继续比较后面的值，可以节省大量时间。事实证明这种方法可行，速度也够快。</p>
<p><strong>二分求解</strong><br>题目解析给出了另外一种方法，即基于二分搜索的方法。大致思想如下</p>
<blockquote>
<p>将数组A,B分别分成两部分，将 left_A 和 left_B 放入一个集合，并将 right_A 和 right_B 放入另一个集合。 再把这两个新的集合分别命名为 left_part 和 right_part：</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">left_part</th>
<th style="text-align:center">right_part</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A[0], A[1], …, A[i-1]</td>
<td style="text-align:center">A[i], A[i+1], …, A[m-1]</td>
</tr>
<tr>
<td style="text-align:center">B[0], B[1], …, B[j-1]</td>
<td style="text-align:center">B[j], B[j+1], …, B[n-1]</td>
</tr>
</tbody>
</table>
</div>
<p>如果我们可以确认：</p>
<blockquote>
<ol>
<li>len(left_part) = len(right_part)</li>
<li>max(left_part) ≤ min(right_part)</li>
</ol>
</blockquote>
<p>那么，我们已经将 {A,B} 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。这时可以很容易求出<strong>median</strong>:</p>
<blockquote>
<p>median= (max(left_part) + min(right_part)) / 2</p>
</blockquote>
<p>要确保这两个条件，我们只需要保证：</p>
<blockquote>
<ol>
<li>i + j = m − i + n − j（或：m - i + n - j + 1） 如果 n ≥ m，只需要使 i = 0 ~ m, j = (m + n + 1) / 2 - i</li>
<li>B[j−1] ≤ A[i] 以及 A[i−1] ≤ B[j]</li>
</ol>
</blockquote>
<p>接下来，按照以下步骤进行二叉树搜索，找到合适的i：</p>
<blockquote>
<ol>
<li>设 imin = 0，imax = m, 然后开始在 [imin,imax] 中进行搜索。</li>
<li>令i = (imin+imax)/2, j = (m+n+1)/2-i</li>
<li>现在有len(left_part)=len(right_part)。会遇到三种情况：<ul>
<li>B[j−1] ≤ A[i] 且 A[i−1] ≤ B[j]：这意味着我们找到了目标对象 i，所以可以停止搜索。</li>
<li>B[j−1] &gt; A[i]：这意味着 A[i] 太小，我们必须增大 i 以使 B[j−1] ≤ A[i]。也就是说，我们必须将搜索范围调整为[i+1,imax]。因此，设 imin=i+1，并转到步骤 2。</li>
<li>A[i−1] &gt; B[j]：这意味着 A[i−1] 太大，我们必须减小 i 以使 A[i−1] ≤ B[j]。也就是说，我们必须将搜索范围调整为[imin,i−1]。因此，设 imax=i−1，并转到步骤 2。</li>
</ul>
</li>
</ol>
</blockquote>
<p>当找到目标对象 i 时，中位数为：</p>
<blockquote>
<ul>
<li>max(A[i−1],B[j−1]),  当 m+n 为奇数时</li>
<li>(max(A[i−1],B[j−1])+min(A[i],B[j]))/2,  当 m+n 为偶数时</li>
</ul>
</blockquote>
<p>接下来只需要对一些边界条件进行处理就可以了，这种方法实现了O(log(m+n))的复杂度</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-解法1"><a href="#1-解法1" class="headerlink" title="1.解法1"></a>1.解法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//只有单个数组有值的情况，只需要处理单个数组</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findSingleArrayMedian</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> isOdd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isOdd) <span class="keyword">return</span> nums[nums.size()/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[nums.size()/<span class="number">2</span><span class="number">-1</span>] + nums[nums.size()/<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//vector&lt;int&gt; nums;</span></span><br><span class="line">        <span class="keyword">int</span> totalLen=nums1.size() + nums2.size();</span><br><span class="line">        <span class="keyword">int</span> isOdd = (totalLen&amp;<span class="number">1</span>); <span class="comment">//判断数组长度奇偶性</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(totalLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums1.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findSingleArrayMedian(nums2,isOdd);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums2.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findSingleArrayMedian(nums1,isOdd);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> last1=<span class="number">0</span>,last2=<span class="number">0</span>; <span class="comment">//记录最后两个值</span></span><br><span class="line">        <span class="keyword">int</span> index1=<span class="number">0</span>,index2=<span class="number">0</span>; <span class="comment">//记录两个数组当前的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=totalLen/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数组1已经没有值时</span></span><br><span class="line">            <span class="keyword">if</span>(index1 == nums1.size())</span><br><span class="line">            &#123;</span><br><span class="line">                last1=last2;</span><br><span class="line">                last2=nums2[index2];</span><br><span class="line">                <span class="comment">//nums.push_back(nums2[index2]);</span></span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数组2已经没有值时</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index2 == nums2.size())</span><br><span class="line">            &#123;</span><br><span class="line">                last1=last2;</span><br><span class="line">                last2=nums1[index1];</span><br><span class="line">                <span class="comment">//nums.push_back(nums1[index1]);</span></span><br><span class="line">                index1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[index1]&lt;nums2[index2])</span><br><span class="line">                &#123;</span><br><span class="line">                    last1=last2;</span><br><span class="line">                    last2=nums1[index1];</span><br><span class="line">                    <span class="comment">//nums.push_back(nums1[index1]);</span></span><br><span class="line">                    index1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    last1=last2;</span><br><span class="line">                    last2=nums2[index2];</span><br><span class="line">                    <span class="comment">//nums.push_back(nums2[index2]);</span></span><br><span class="line">                    index2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(isOdd) <span class="keyword">return</span> last2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (last1+last2) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-解法2（二分法）"><a href="#2-解法2（二分法）" class="headerlink" title="2.解法2（二分法）"></a>2.解法2（二分法）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = nums2.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//确保数组1长度不大于数组2小</span></span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp=nums1;nums1=nums2;nums2=tmp;</span><br><span class="line">            <span class="keyword">int</span> temp = len1;len1=len2;len2=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> iMin=<span class="number">0</span>,iMax=len1,halfLen=(len1+len2+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(iMin&lt;=iMax)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i=(iMin+iMax)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j=halfLen-i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//i过小</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;iMax &amp;&amp; nums2[j<span class="number">-1</span>]&gt;nums1[i])</span><br><span class="line">            &#123; </span><br><span class="line">                iMin=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i过大</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;iMin &amp;&amp; nums1[i<span class="number">-1</span>]&gt;nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                iMax=i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//成功找到i</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> maxLeft=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) maxLeft=nums2[j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) maxLeft=nums1[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> maxLeft=max(nums1[i<span class="number">-1</span>],nums2[j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>((len1+len2)%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> maxLeft;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> minRight=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==len1) minRight = nums2[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==len2) minRight = nums1[i];</span><br><span class="line">                <span class="keyword">else</span> minRight=min(nums1[i],nums2[j]);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--37. Sudoku Solver</title>
    <url>/2019/04/25/LeetCode--37-Sudoku-Solver.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Write a program to solve a Sudoku puzzle by filling the empty cells.<br><a id="more"></a><br>A sudoku solution must satisfy <strong>all of the following rules:</strong></p>
<ol>
<li>Each row must contain the digits 1-9 without repetition. </li>
<li>Each column must contain the digits 1-9 without repetition. </li>
<li>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li>
</ol>
<p>Empty cells are indicated by the character <code>&#39;.&#39;</code>.</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="A sudoku puzzle..." title="A sudoku puzzle..."></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="...and its solution numbers marked in red." title="...and its solution numbers marked in red."></p>
<p><strong>Note :</strong></p>
<ul>
<li>The given board contain only digits <code>1-9</code> and the character <code>&#39;.&#39;</code>.</li>
<li>You may assume that the given Sudoku puzzle will have a single unique solution.</li>
<li>The given board size is always <code>9x9</code>.</li>
</ul>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>还是遇到这道题了，解数独。有了上一道题的经验，对于解数独的问题也不是毫无头绪了。</p>
<p>既然我们已经有了判断当前棋盘是否符合数独规则的算法，那么一种直观的方法就是利用递归回溯法，将所有可能的合法数字都尝试一遍，判断哪种方法最终可以将整个棋盘填满并且符合数独的规则。尽管思路是有了，但是实现起来还是有点磕磕碰碰，对于递归回溯的使用还是不熟悉呀。实现后不出所料，性能不够好，耗时太多了，暴力解法的缺点就是思路简单，但一般复杂度不会太好。</p>
<p>对这个方法的一种优化是，每次填入一个数的时候，不必要对整个棋盘都判断一遍是不是有效的，只需要判断加入的这个数有没有违反规则。若每次加入的数都没有违反规则，那么到最后填满整个棋盘的数，所有的数也就都是有效的。这样就省去大量重复的比较时间，使得效率得到了提升。</p>
<p>除此之外还有一些比较高深复杂的解法，暂时还没看懂，后面补充。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        solveSudo(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solveSudo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">9</span>) <span class="keyword">return</span> solveSudo(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; ++k) </span><br><span class="line">            &#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>)(k + <span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span> (isValidSudoku(board)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (solveSudo(board, i, j + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> solveSudo(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; col(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; block(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; row(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = <span class="number">1</span> &lt;&lt; (board[i][j] - <span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">if</span> (row[i] &amp; idx || col[j] &amp; idx || block[i/<span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>] &amp; idx)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    </span><br><span class="line">                    row[i] |= idx;</span><br><span class="line">                    col[j] |= idx;</span><br><span class="line">                    block[i/<span class="number">3</span> * <span class="number">3</span> + j/<span class="number">3</span>] |= idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        solveSudo(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solveSudo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">9</span>) <span class="keyword">return</span> solveSudo(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; ++k) </span><br><span class="line">            &#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>)(k + <span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span> (isValidSudoku(board, i, j)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (solveSudo(board, i, j + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> solveSudo(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; ++col) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (col != j &amp;&amp; board[i][j] == board[i][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; ++row) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (row != i &amp;&amp; board[i][j] == board[row][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = i / <span class="number">3</span> * <span class="number">3</span>; row &lt; i / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; ++row) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = j / <span class="number">3</span> * <span class="number">3</span>; col &lt; j / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; ++col) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((row != i || col != j) &amp;&amp; board[i][j] == board[row][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--5. Longest Palindromic Substring</title>
    <url>/2019/03/28/LeetCode--5-Longest-Palindromic-Substring.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.</p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>Input: “cbbd”<br>Output: “bb”</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>最开始想到的当然还是暴力算法，想法是先用暴力算法把题目做出来理解题目，然后尝试着对实现的算法进行改进，或者再想想有没有其他思路。最开始的想法是</p>
<blockquote>
<p>设置两个游标i、j，i从前往后遍历字符串，j从后往前遍历字符串；先将i固定住，然后j从后往前遍历，依次判断从当前j到i的字符串是不是一个回文，其长度是不是最大，若满足条件，就将该字符串的位置信息记录下来，遍历完后最终输出即可。</p>
</blockquote>
<p>显然这个方法的效果不会太好，选择尝试对其进行优化。想要的优化思路如下</p>
<blockquote>
<p>若当前要判断的子串比已经找到的最长回文子串要短，那么该子串以及比它短的子串都没必要在判断了，可以通过跳过这些不必要的比较过程节省大量时间</p>
</blockquote>
<p>修改过后，时间上果然有了很大提升，但结果告诉我显然这种方法还是不好，肯定存在更优化的方法。仔细分析后发现，其实这种方法就相当于将字符串反转后找最大公共子串，它存在一些问题：</p>
<blockquote>
<p>这种方法是从两端往内部收缩的算法，如果一个字符串恰好只是最内部的一部分不是子串，那么两端的整个判断过程都是无意义的，而且很费时。我们需要能够更早发现这不是一个回文。若我们把判断过程换一个方向就可以做到，即收缩改为扩展。由内而外的判断子串是不是回文，可以在不是回文的地方及时停止，并且保证之前判断的子串的确是回文，不是无意义的判断。</p>
</blockquote>
<p>实现后发现，这种扩展的算法效率比最开始的算法效率要好太多了，因为避免了许多无意义的计算过程。总结起来就是，有时候换一个方向想问题，可以得到更加优化的结果。<br>查看解题的文档后发现还有以下几种比较巧妙的方式：</p>
<blockquote>
<p>1.最长公共子串暴力算法<br>反转 S，使之变成 S’。找到 S 和 S’之间最长的公共子串,每当我们找到最长的公共子串的候选项时，都需要检查子串的索引是否与反向子串的原始索引相同。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。我所用到的第一种方法思路根这种方法一致。</p>
<p>2.动态规划<br>考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，”ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。可以给出P(i,j)的定义如下</p>
<ul>
<li>P(i,j) = true,  如果子串Si,…,Sj是回文子串</li>
<li>P(i,j) = false, 其他情况</li>
</ul>
<p>因此P(i,j)更新公式如下：</p>
<ul>
<li>P(i,j) = (P(i+1,j−1) and Si == Sj)</li>
</ul>
<p>这是一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推</p>
<p>3.Manacher 算法<br>也叫“马拉松”算法，这个算法可以将时间复杂度提升为<strong>O(n)</strong>。</p>
<ol>
<li><p>首先对字符串进行预处理，处理原因是防止偶数问题。比如，有一个偶回文<strong>abba</strong>和一个奇回文<strong>opxpo</strong>，转换为<strong>#a#b#b#a#</strong>和<strong>#o#p#x#p#o#</strong>，长度都转换成了奇数。</p>
</li>
<li><p>定义一个辅助数组p[]，其中p[i]表示以 <strong>i</strong> 为中心的最长回文的半径</p>
</li>
<li><p>接下来的重点就是求解 p 数组。参考下图<br><img src="https://image-static.segmentfault.com/105/998/1059982876-58b966b759200" alt=""><br>设置两个变量，mx 和 id。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么：<br><code>if (i &lt; mx) p[i]=min(p[2 * id - i], mx - i);</code><br><strong>(2 * id - i)</strong>为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快更新数组。</p>
</li>
</ol>
</blockquote>
<p>参考文献：<a href="https://subetter.com/algorithm/manacher-algorithm.html" target="_blank" rel="noopener">https://subetter.com/algorithm/manacher-algorithm.html</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-改进的收缩算法-最长字符串匹配"><a href="#1-改进的收缩算法-最长字符串匹配" class="headerlink" title="1. 改进的收缩算法(最长字符串匹配)"></a>1. 改进的收缩算法(最长字符串匹配)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> begin=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> LongestLength=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=s.length()<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> forward=i;</span><br><span class="line">                <span class="keyword">int</span> backward=j;</span><br><span class="line">                <span class="keyword">while</span>(s[forward]==s[backward]&amp;&amp;forward&lt;backward)</span><br><span class="line">                &#123;</span><br><span class="line">                    forward++;</span><br><span class="line">                    backward--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(forward&gt;=backward)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(LongestLength&lt;(j-i+<span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        begin=i;</span><br><span class="line">                        LongestLength=(j-i+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(LongestLength&gt;=(j-i+<span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(LongestLength&gt;=(s.length()-i+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> s.substr(begin, LongestLength); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-扩展算法"><a href="#2-扩展算法" class="headerlink" title="2. 扩展算法"></a>2. 扩展算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> r_ptr = i; </span><br><span class="line">        <span class="keyword">int</span> l_ptr = i;</span><br><span class="line">        <span class="comment">//找到回文中心</span></span><br><span class="line">        <span class="keyword">while</span>(r_ptr &lt; s.size()<span class="number">-1</span> &amp;&amp; s[r_ptr] == s[r_ptr + <span class="number">1</span>]) r_ptr++;</span><br><span class="line">        i = r_ptr+<span class="number">1</span>;<span class="comment">//记录下次启示位置，防止重复计算</span></span><br><span class="line">        <span class="comment">//从中心开始扩展</span></span><br><span class="line">        <span class="keyword">while</span>(r_ptr &lt; s.size()<span class="number">-1</span> &amp;&amp; l_ptr &gt; <span class="number">0</span> &amp;&amp; s[r_ptr + <span class="number">1</span>] == s[l_ptr - <span class="number">1</span>]) &#123;</span><br><span class="line">            r_ptr++;</span><br><span class="line">            l_ptr--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新最长回文子串信息</span></span><br><span class="line">        <span class="keyword">int</span> new_len = r_ptr - l_ptr + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(new_len &gt; max_len) &#123;</span><br><span class="line">            start_idx = l_ptr;</span><br><span class="line">            max_len = new_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(start_idx, max_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-动态规划算法"><a href="#3-动态规划算法" class="headerlink" title="3. 动态规划算法"></a>3. 动态规划算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> LongestLength = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(len,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dist = <span class="number">1</span>;dist &lt; len - i;dist++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = dist + i;</span><br><span class="line">                dp[i][j] = (dist == <span class="number">1</span>)? s[i] == s[j] : s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; LongestLength)</span><br><span class="line">                &#123;</span><br><span class="line">                    LongestLength = j-i+<span class="number">1</span>;</span><br><span class="line">                    begin=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substr(begin, LongestLength); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-Manacher算法"><a href="#4-Manacher算法" class="headerlink" title="4. Manacher算法"></a>4. Manacher算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字符串预处理，插入 '#'</span></span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">"$#"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            t += s[i];</span><br><span class="line">            t += <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理t</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(t.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, resLen = <span class="number">0</span>, resCenter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.size(); ++i) &#123;</span><br><span class="line">            p[i] = i &lt; mx ? min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++p[i]; <span class="comment">//// 不需边界判断，因为左有'$',右有'\0'</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//希望 mx 尽可能的远</span></span><br><span class="line">            <span class="keyword">if</span> (mx &lt; i + p[i]) &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</span><br><span class="line">                resLen = p[i];</span><br><span class="line">                resCenter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr((resCenter - resLen) / <span class="number">2</span>, resLen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--6. ZigZag Conversion</title>
    <url>/2019/04/01/LeetCode--6-ZigZag-Conversion.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><br>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code><br>Write the code that will take a string and make this conversion given a number of rows:<br><code>string convert(string s, int numRows);</code></p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: s = “PAYPALISHIRING”, numRows = 3<br>Output: “PAHNAPLSIIGYIR”</p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: s = “PAYPALISHIRING”, numRows = 4<br>Output: “PINALSIGYAHRPI”<br>Explanation:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题可以直接通过找规律实现。找到每行 Z 字形图案字符在原字符串中对于的位置即可，然后逐行访问。规律如下：</p>
<blockquote>
<p>对于所有整数”k”,</p>
<ol>
<li>第0行中的字符位于原字符串 k*(2⋅numRows−2) 处;</li>
<li>第(numRows−1)行中的字符位于原字符串 k*(2⋅numRows−2)+numRows−1 处;</li>
<li>其他行中字符位于原字符串 k*(2⋅numRows−2)+i 以及 (k+1)*(2⋅numRows−2)−i处；</li>
</ol>
</blockquote>
<p>找到规律后，就很容易实现了。</p>
<p>另外一种方法是，通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。所以可以分别构建每行的字符串，最后再将这些字符串连接起来即可，算法如下</p>
<blockquote>
<ol>
<li>使用 min(numRows,len(s)) 个列表来表示 Z 字形图案中的非空行。</li>
<li>从左到右迭代 s，将每个字符添加到合适的行。</li>
<li>合并所有行</li>
</ol>
</blockquote>
<p>但是这种方法效率要低一些。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-找规律的方法"><a href="#1-找规律的方法" class="headerlink" title="1. 找规律的方法"></a>1. 找规律的方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一行，无需处理直接输出</span></span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> cvStr;</span><br><span class="line">        <span class="keyword">int</span> step=numRows*<span class="number">2</span><span class="number">-2</span>;<span class="comment">//每次前进的步伐</span></span><br><span class="line">        <span class="comment">//逐行生成每行的序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;s.length();j+=step)</span><br><span class="line">            &#123;</span><br><span class="line">                cvStr+=s[j+i];</span><br><span class="line">                <span class="comment">//若是内部行，需要加上((k+1)(2⋅numRows−2)−i)处的字符</span></span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;i!=numRows<span class="number">-1</span>&amp;&amp;j+step-i&lt;s.length())</span><br><span class="line">                &#123;</span><br><span class="line">                    cvStr+=s[j+step-i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cvStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-逐行构造的方法"><a href="#2-逐行构造的方法" class="headerlink" title="2. 逐行构造的方法"></a>2. 逐行构造的方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一行，无需处理直接输出</span></span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = min(numRows,<span class="keyword">int</span>(s.length()));</span><br><span class="line">        <span class="built_in">string</span> cvStr; <span class="comment">//结果字符串</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; rows(len); <span class="comment">//每行字符串</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> curRow=<span class="number">0</span>; <span class="comment">//当前行</span></span><br><span class="line">        <span class="keyword">bool</span> curDirect=<span class="literal">false</span>; <span class="comment">//当前方向</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逐个字符串构建每行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            rows[curRow]+=s[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//边界时，确定当前方向</span></span><br><span class="line">            <span class="keyword">if</span>(curRow==<span class="number">0</span> || curRow == numRows<span class="number">-1</span>) curDirect=!curDirect;</span><br><span class="line">            </span><br><span class="line">            curRow+=curDirect?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//合成字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> row : rows) cvStr+=row;</span><br><span class="line">        <span class="keyword">return</span> cvStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--771. Jewels and Stones</title>
    <url>/2019/03/28/LeetCode--771-Jewels-and-Stones.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>You’re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.<br><a id="more"></a><br>The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: J = “aA”, S = “aAAbbbb”<br>Output: 3</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: J = “z”, S = “ZZ”<br>Output: 0</p>
</blockquote>
<p><strong>Note:</strong></p>
<blockquote>
<ul>
<li>S and J will consist of letters and have length at most 50.</li>
<li>The characters in J are distinct.</li>
</ul>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>1.这是一道很简单的题，只需要逐个判断字符串 <strong>S</strong> 中的每个字符,是否在字符串 <strong>J</strong> 中出现过。设置一个计数器count，每次判断后更新该计数器，带遍历完整个字符串，即可得出最终结果。比较字符串的过程中，应用了string库里的find()函数。<br>2.在看别人提交的解法中，看见了另外一种比较有趣的方法，建立了一个与字符ASCII码大小相同的数组，每次判断字符是否存在，只需直接在数组内查看该字符ASCII码对应的位置是否为1，这是一种空间换时间的方法。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li>解法1 </li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(J.find(S[i]) != J.npos)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>解法2</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> exist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; J.length();i++) &#123;</span><br><span class="line">            exist[J.at(i)] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exist[S.at(i)]) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--7. Reverse Integer</title>
    <url>/2019/03/28/LeetCode--7-Reverse-Integer.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a 32-bit signed integer, reverse digits of an integer..<br><a id="more"></a></p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: 123<br>Output: 321</p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>Input: -123<br>Output: -321</p>
</blockquote>
<p><strong>Example3:</strong></p>
<blockquote>
<p>Input: 120<br>Output: 21</p>
</blockquote>
<p><strong>Note:</strong></p>
<blockquote>
<p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>问题很简单，即将一个int型整数逆序。这里需要注意的是，int的表示范围是[−2^31,  2^31 − 1]，所以若逆序后的数在这个范围之外，即溢出的时候，直接输出0。<br>我的想法是，用一个更大的类型，即<strong>long</strong>来存储转化结果，然后判断结果在不在int的表示范围内，对计算结果进行处理。对比评论区，发现思路大致相同，这貌似就是最优的方法，还以为又会有啥逻辑上的转换。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> MAX=<span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">long</span> MIN=<span class="number">-2147483648</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result=result*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(result&gt;MAX||result&lt;MIN)</span><br><span class="line">        &#123;</span><br><span class="line">            result=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>据说出题人想考的是溢出判断，不能用long，只用Int的实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> MAX=<span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">long</span> MIN=<span class="number">-2147483648</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(result&gt;MAX/<span class="number">10</span>||result&lt;MIN/<span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            result=result*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>也就是计算结果的时候，先判断这次计算会不会溢出，溢出就直接返回0</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--9. Palindrome Number</title>
    <url>/2019/04/02/LeetCode--9-Palindrome-Number.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: 121<br>Output: true</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: -121<br>Output: false<br>Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: 10<br>Output: false<br>Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目让判断一个数整数是不是一个回文，其中定义所有负数都不是回文。解题想法是</p>
<blockquote>
<ol>
<li>首先判断这个数是不是负数，或者是不是0~9的数(只有一位肯定是回文)。</li>
<li>然后将数字转化为一个字符串，从中心开始向两边扩展判断是不是回文。</li>
</ol>
</blockquote>
<p>这里判断回文的思路和前面做到的一道题很类似，但是这个题要更简单一点。后来才发现题目要求里面有，<strong>不能使用把数转化为字符串</strong>。<br>前面有道题是可以把一个数反转，那么可以直接把数反转后，看看两个数是否相等即可判断。但是把数反转后有可能导致数字大于int表示范围，还需要额外处理溢出的情况。一种优化的方法是，可以<strong>只反转int数字的一半</strong>，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。例如，输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 1221 是回文。这里还需要对一些特殊情况进行处理，比如数字是奇数长，或者10^n时，需要额外判断。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="转化为字符串的解法"><a href="#转化为字符串的解法" class="headerlink" title="转化为字符串的解法"></a>转化为字符串的解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToStr</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = (x%<span class="number">10</span>)+<span class="string">'0'</span>;</span><br><span class="line">            res = tmp + res;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;<span class="number">10</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> num = intToStr(x);</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">if</span>(num.length()%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i=num.length()/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            j=num.length()/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i=num.length()/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            j=num.length()/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;=num.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=num[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i--;j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不转化解法"><a href="#不转化解法" class="headerlink" title="不转化解法"></a>不转化解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span> || (x!=<span class="number">0</span> &amp;&amp; x%<span class="number">10</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; revertedNumber)</span><br><span class="line">        &#123;</span><br><span class="line">            revertedNumber = revertedNumber*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x==(revertedNumber/<span class="number">10</span>) || x==revertedNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--8. String to Integer (atoi)</title>
    <url>/2019/03/31/LeetCode--8-String-to-Integer-atoi.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Implement <strong>atoi</strong> which converts a string to an integer.<br><a id="more"></a><br>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>Only the space character ‘ ‘ is considered as whitespace character.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</li>
</ul>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: “42”<br>Output: 42</p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>Input: “   -42”<br>Output: -42<br>Explanation: The first non-whitespace character is ‘-‘, which is the minus sign.Then take as many numerical digits as possible, which gets 42.</p>
</blockquote>
<p><strong>Example3:</strong></p>
<blockquote>
<p>Input: “4193 with words”<br>Output: 4193<br>Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit.</p>
</blockquote>
<p><strong>Example4:</strong></p>
<blockquote>
<p>Input: “words and 987”<br>Output: 0<br>Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.</p>
</blockquote>
<p><strong>Example5:</strong></p>
<blockquote>
<p>Input: “-91283472332”<br>Output: -2147483648<br>Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目大致意思是：将一个字符串转换成一个数，这个字符串有很多种情况需要考虑：</p>
<ol>
<li>忽略字符串头部的空白(只把” “当做空白)</li>
<li>数字可能带正负号</li>
<li>若数字超过INT表示范围，则若上溢，返回INT最大值；若下溢，返回INT最小值</li>
<li>如果除1,2情况外，第一个字符不是数字，视为无效值，返回0</li>
<li>如果数字后出现非数字，则截断，不考虑后面的字符。</li>
</ol>
<p>所以，只需要将这些情况考虑进来，把字符串进行直接处理即可。判断溢出时，可以用long来保存结果，最后再判断值是否溢出；也可以直接计算过程中对INT进行判断。这里用的后一种方法。这道题在判断溢出时，思路类似于[7.Reverse Integer]这道题。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,sign=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//去空格</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;str[i]==<span class="string">' '</span>;i++);</span><br><span class="line">        <span class="comment">//取符号</span></span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sign=<span class="number">1</span>;i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">'+'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="number">0</span>&amp;&amp;(INT_MAX-(str[i]-<span class="string">'0'</span>))/<span class="number">10</span>&lt;result) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="number">1</span>&amp;&amp;(INT_MAX-(str[i]-<span class="string">'0'</span>))/<span class="number">10</span>&lt;result) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            </span><br><span class="line">            result=result*<span class="number">10</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sign) result=-result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--36. Valid Sudoku</title>
    <url>/2019/04/24/LeetCode--36-Valid-Sudoku.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated <strong>according to the following</strong> .<br><a id="more"></a><br><strong>rules :</strong></p>
<ol>
<li>Each row must contain the digits 1-9 without repetition. </li>
<li>Each column must contain the digits 1-9 without repetition. </li>
<li>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li>
</ol>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="A partially filled sudoku which is valid." title="A partially filled sudoku which is valid."></p>
<blockquote>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>&#39;.&#39;</code>.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input:<br>[<br>&nbsp;&nbsp;[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>&nbsp;&nbsp;[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>&nbsp;&nbsp;[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>&nbsp;&nbsp;[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>&nbsp;&nbsp;[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>&nbsp;&nbsp;[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>&nbsp;&nbsp;[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>&nbsp;&nbsp;[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>&nbsp;&nbsp;[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>Output: true</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input:<br>[<br>&nbsp;&nbsp;[“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>&nbsp;&nbsp;[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>&nbsp;&nbsp;[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>&nbsp;&nbsp;[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>&nbsp;&nbsp;[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>&nbsp;&nbsp;[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>&nbsp;&nbsp;[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>&nbsp;&nbsp;[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>&nbsp;&nbsp;[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>Output: false<br>Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8’s in the top left 3x3 sub-box, it is invalid.</p>
</blockquote>
<p><strong>Note :</strong></p>
<ul>
<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>
<li>Only the filled cells need to be validated according to the mentioned rules.</li>
<li>The given board contain only digits 1-9 and the character <code>&#39;.&#39;</code>.</li>
<li>The given board size is always <code>9x9</code>.</li>
</ul>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>咋一看以为是解数独，会很复杂。读完题目后，发现只要求判断当前的棋盘上的数字是不是有效的，不需要考虑最终这个数独是不是可以解。所以相当于只需要判断当前这个已经存在的棋盘是否满足数独规则的要求。</p>
<p>数独的规则要求，每行，每列，以及每个<code>3x3</code>的子棋盘上，是否包括<code>1-9</code>这9个数字且不重复。现在考虑，肯定是需要把整个棋盘扫描一遍的，那么我们可以设置三个状态数组，来分别记录下以及扫描过的 <code>行/列/子棋盘</code> 中已经出现过的数，如果扫描到某 <code>行/列/子棋盘</code> 中有重复的元素前面已经出现过，直接返回false；若直到扫描结束，也为发现重复元素，说明棋盘有效，返回true。但是由于要记录每 <code>行/列/子棋盘</code> 的状态，需要声明三个较大的数组，所以对空间的消耗较高，应该还有更优化的解法。</p>
<p>评论区解题的大致思路都差不多，区别主要再求如何存储状态数组。有一种很优化的方法是利用位操作实现的，这种方法只使用一个short就存储了一行的状态，节省了很多空间，效率也得到了提升。</p>
<blockquote>
<ol>
<li>每行的状态初始化为0；</li>
<li>遇到一个数字num，就将1左移num位与状态数进行与操作，若结果不为0，说明有重复，返回false；否则，无重复，更新状态，即两数进行或操作。</li>
</ol>
</blockquote>
<p>参考：<br><a href="https://leetcode.com/problems/valid-sudoku/discuss/15452" target="_blank" rel="noopener">C++ very simple and easy understand. using bit operation</a><br><a href="https://leetcode.com/problems/valid-sudoku/discuss/15705/" target="_blank" rel="noopener">My C++ code (O(n2) time and space)</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; rows(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; columns(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; sub_box(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> sub_box_index = (i/<span class="number">3</span>)*<span class="number">3</span> + (j/<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">int</span> num = board[i][j] - <span class="string">'1'</span>;</span><br><span class="line">                <span class="keyword">if</span>(rows[i][num] || columns[j][num] || sub_box[sub_box_index][num])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                rows[i][num] = columns[j][num] = sub_box[sub_box_index][num] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="利用位操作"><a href="#利用位操作" class="headerlink" title="利用位操作"></a>利用位操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; col(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; block(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; row(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = <span class="number">1</span> &lt;&lt; (board[i][j] - <span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">if</span> (row[i] &amp; idx || col[j] &amp; idx || block[i/<span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>] &amp; idx)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    </span><br><span class="line">                    row[i] |= idx;</span><br><span class="line">                    col[j] |= idx;</span><br><span class="line">                    block[i/<span class="number">3</span> * <span class="number">3</span> + j/<span class="number">3</span>] |= idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> existNum[<span class="number">10</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!=<span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(existNum[i][board[i][j] - <span class="string">'0'</span>] &amp; <span class="number">0x1</span>)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// check if the i-row already has such number, LSB</span></span><br><span class="line">                    <span class="keyword">if</span>(existNum[j][board[i][j] - <span class="string">'0'</span>] &amp; <span class="number">0x2</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// check if the j-col already has such number, 2-LSB</span></span><br><span class="line">                    <span class="keyword">if</span>(existNum[(i/<span class="number">3</span>) *<span class="number">3</span> + j/<span class="number">3</span>][board[i][j] - <span class="string">'0'</span>] &amp; <span class="number">0x4</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// check if the k-subblock already has such number, 3-LSB</span></span><br><span class="line">                    existNum[i][board[i][j] - <span class="string">'0'</span>] ^=<span class="number">0x1</span>;</span><br><span class="line">                    existNum[j][board[i][j] - <span class="string">'0'</span>] ^=<span class="number">0x2</span>;</span><br><span class="line">                    existNum[(i/<span class="number">3</span>) *<span class="number">3</span> + j/<span class="number">3</span>][board[i][j] - <span class="string">'0'</span>] ^=<span class="number">0x4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.NULL: The Missing Semester of Your CS Education 学习</title>
    <url>/2020/05/27/MIT-6-NULL-The-Missing-Semester-of-Your-CS-Education-Learning.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近开始学习一下<code>MIT</code>的一门课程：<a href="https://missing.csail.mit.edu/" target="_blank" rel="noopener">6.NULL: The Missing Semester of Your CS Education</a>。主要是讲了一些Linux上常用的工具。在这个系列课程中，<code>讲授命令行、强大的文本编辑器的使用、使用版本控制系统提供的多种特性等等</code>。<br><a id="more"></a><br>最初是在知乎上一篇博客<a href="https://zhuanlan.zhihu.com/p/139361685" target="_blank" rel="noopener">6.NULL：恨不相逢“未嫁时”</a>上看见的，确实有许多Linux的工具在编程时可以让起到事半功倍的效果，刚好MIT有这样一门课程可以统一的学习了解一下。写这系列博客，一方面做一个学习笔记，另一方面也督促一下我的学习进度，实在太懒了，又有一些乱七八糟的事情，就慢慢开始学习吧。</p>
<h3 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h3><p>课程内容并不算多，看课程日常表总共有十一章，每天一章。借用知乎博客上的介绍，这门课程内容主要涉及了<code>一些好用（能大大提高生产力）的工具，如terminal、编辑器editor、tmux、profiler、数据处理工具(如awk, sed, grep, perl）等等</code>，都是一些很实用的工具，经常会被用到。课程上主要是告诉你这些工具是做什么的、能实现什么样的事情，并给了一些简单的使用示例，而如果你想要去深入地了解这些工具，课程的notes则提供了一些资料供你阅读。而且这是一门需要结合实际操作的课程，因为都是工具嘛，不用的话也就没啥用了。好了，开始了！！</p>
<h3 id="笔记索引"><a href="#笔记索引" class="headerlink" title="笔记索引"></a>笔记索引</h3><p>下面是学习过程中，每次课程的一些笔记和实战演练，不过其实官网上的介绍已经有许多了。</p>
<blockquote>
<ol>
<li><a href="../../../2020/05/27/MIT-6-NULL-one-Course-overview-plus-the-shell.html">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>MIT课程</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>MIT</tag>
      </tags>
  </entry>
  <entry>
    <title>My new Post</title>
    <url>/2017/09/21/My-new-Post.html</url>
    <content><![CDATA[<blockquote>
<p>a test</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>LeetCode--929. Unique Email Addresses</title>
    <url>/2019/03/28/LeetCode--929-Unique-Email-Addresses.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Every email consists of a local name and a domain name, separated by the @ sign.</p>
<p>For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name.<br><a id="more"></a><br>Besides lowercase letters, these emails may contain ‘.’s or ‘+’s.</p>
<p>If you add periods (‘.’) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, “alice.z@leetcode.com” and “alicez@leetcode.com” forward to the same email address.  (Note that this rule does not apply for domain names.)</p>
<p>If you add a plus (‘+’) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.)</p>
<p>It is possible to use both of these rules at the same time.</p>
<p>Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails? </p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: <code>{&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;}</code><br>Output: <strong>2</strong></p>
</blockquote>
<p>Explanation: “testemail@leetcode.com” and “testemail@lee.tcode.com” actually receive mails</p>
<p><strong>Note:</strong></p>
<ul>
<li>1 &lt;= emails[i].length &lt;= 100</li>
<li>1 &lt;= emails.length &lt;= 100</li>
<li>Each emails[i] contains exactly one ‘@’ character.</li>
</ul>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目的意思是，邮箱作为一个字符串，在字符”@”前面的部分：</p>
<blockquote>
<p>1.若出现字符’.’，则可以去掉该’.’;<br>2.若出现’+’，则从’+’到’@’的字符串都可去掉。</p>
</blockquote>
<p>根据这样的规则，判断总共有多少个不同的邮箱。思路很明确，只需要将每一个邮箱转换为其最简单的形式，然后去除其中重复的字符串，计算最终剩下的字符串个数即可。<br>首先联想到的是在每次处理完字符串后，将处理过的字符串放入一个set中，由于set内不含重复元素，所以自然就可以去重。但是vector有没有什么直接去重的方法呢？查阅资料后发现还真有，在vector类型中，有一种去重的方法是：先在vector内对向量进行排序，然后用erase加unique函数即可实现去除重复元素。</p>
<blockquote>
<ul>
<li>unique函数是一个去重函数，去除相邻中的重复元素（只留一个）。其中，最关键的是：并不是把重复的元素删除，而是全部放倒数组的后面。</li>
<li>由于unique只是去除（相邻）的重复元素，因此，为了去除重复的元素，应该，首先对数组Vector进行排序，这样保证重复元素在相邻的位置。</li>
<li>unique函数，返回的是去重后的尾地址。因此对于一个内容为{2, 2, 5, 5, 6}的vector，执行unique函数以后，vector大小并没有改变，只不过顺序变成了{2, 5, 6, 2, 5}，并且函数的返回值为:3。此时需要删除重复元素，只需要将后面的数据全部删除即可。</li>
</ul>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numUniqueEmails</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; emails)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator email=emails.begin();email&lt;emails.end();email++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(*email).find(<span class="string">'@'</span>);i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((*email)[i]==<span class="string">'.'</span>)  (*email).erase(i,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((*email)[i]==<span class="string">'+'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    (*email).erase(i,(*email).find(<span class="string">'@'</span>)-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(emails.begin(),emails.end());</span><br><span class="line">        emails.erase(unique(emails.begin(), emails.end()), emails.end());</span><br><span class="line">        <span class="keyword">return</span> emails.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy爬虫-基础使用</title>
    <url>/2019/11/16/scrapy-crawler--basic-use.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近大数据课需要用到爬虫爬数据，发现<code>scrapy</code>这个爬虫库还蛮好用的，记录一下它的基本用法。<br><a id="more"></a></p>
<h3 id="scrapy框架"><a href="#scrapy框架" class="headerlink" title="scrapy框架"></a><code>scrapy</code>框架</h3><p>如下是<code>scrapy</code>架构图，绿色箭头表示组件及在系统中发生的数据流。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/scrapy_architecture.png" alt="scrapy architecture"></p>
<blockquote>
<ul>
<li><strong>Scrapy Engine</strong> 控制数据流在组件中的流动，并在相应动作发生时触发事件</li>
<li><strong>调度器(Scheduler)</strong> 从引擎接受request并将他们入队，以便之后引擎请求他们时提供给引擎</li>
<li><strong>下载器(Downloader)</strong> 负责获取页面数据并提供给引擎，而后提供给spider</li>
<li><strong>Spiders</strong> 用户编写用于分析response并提取item(即获取到的item)或额外跟进的URL的类</li>
<li><strong>Item Pipeline</strong> Item Pipeline负责处理被spider提取出来的item，清理、 验证及持久化等</li>
<li><strong>下载器中间件(Downloader middlewares)</strong> 可以自定义扩展下载功能的组件(比如将滑动条拉到底部)</li>
</ul>
</blockquote>
<p>具体可以参考官网<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/architecture.html" target="_blank" rel="noopener">架构概览</a></p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>可以通过<code>scrapy</code>命令直接生成一个框架模板，主要有以下命令：</p>
<blockquote>
<ul>
<li>创建项目：scrapy startproject xxx</li>
<li>创建爬虫：scrapy genspider xxx（爬虫名） xxx.com （爬取域）</li>
<li>生成文件：scrapy crawl xxx -o xxx.type (生成 <code>type</code> 类型的文件)</li>
<li>运行爬虫：scrapy crawl XXX</li>
<li>列出所有爬虫：scrapy list</li>
<li>获得配置信息：scrapy settings [options]</li>
</ul>
</blockquote>
<p>如下是生成的一个爬虫项目的目录信息：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/scrapy_folder.png" alt="project folder"></p>
<p>简单的爬虫主要需要修改的就是 <code>items.py</code> 和 <code>example.py</code> 文件。其它比较高端的功能暂时也没用上：</p>
<blockquote>
<p><code>items.py</code> 创建容器的地方，爬取的信息分别放到不同容器里。item是保存爬取数据的容器，使用的方法和字典差不多, 将需要提取的信息在这里定义以下就可以了<br><code>example.py</code> 爬虫文件。负责解析start_url下载的Response 对象，根据item提取数据; 如果有新的url则加入爬取队列，负责进一步处理，URL的Request 对象</p>
</blockquote>
<h3 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h3><p>我这里主要是用的 <code>Xpath</code> 来解析文件, 语法还是比较简单的, 而且容易使用, 可以在 <code>chrome</code> 内使用插件 <code>XPath Helper</code> 来在网页内调试。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/xpath.png" alt="Xpath"></p>
<p>但是有时候 <code>XPath Helper</code> 的解析语句在 <code>scrapy</code> 得到的结果不太兼容, 可以用 <code>scrapy</code> 命令行进一步调试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy shell &lt;url&gt;</span><br></pre></td></tr></table></figure><br>两者结合起来, 基本上就可以写出合理的爬虫解析语句了。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/scrapy_shell.png" alt="scrapy shell"></p>
<p>xpath具体语法可以参考<a href="https://www.w3school.com.cn/xpath/index.asp" target="_blank" rel="noopener">XPath 教程</a>, 基本上跟着调试调试就懂了。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/7dee0837b3d2" target="_blank" rel="noopener">scrapy学习</a></li>
<li><a href="https://www.jianshu.com/p/cecb29c04cd2" target="_blank" rel="noopener">爬虫框架Scrapy个人总结（详细）熟悉</a></li>
<li><a href="https://www.jianshu.com/p/6bc5a4641629" target="_blank" rel="noopener">爬虫框架Scrapy的安装与基本使用</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--709. To Lower Case</title>
    <url>/2019/03/28/LeetCode--709-To-Lower-Case.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: “Hello”<br>Output: “hello”</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: “here”<br>Output: “here”</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: “LOVELY”<br>Output: “lovely”</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题主要用来熟悉下transform(STL transform)函数</p>
<blockquote>
<p>transform() 可以将函数应用到序列的元素上，并将这个函数返回的值保存到另一个序列中，它返回的迭代器指向输出序列所保存的最后一个元素的下一个位置。调用方法如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryOperator</span> &gt; </span></span><br><span class="line"><span class="class">	<span class="title">OutputIterator</span> <span class="title">transform</span> ( <span class="title">InputIterator</span> <span class="title">first1</span>,  // 源容器的起始地址 </span></span><br><span class="line"><span class="class">							  <span class="title">InputIterator</span> <span class="title">last1</span>,    // 源容器的终止地址 </span></span><br><span class="line"><span class="class">							  <span class="title">OutputIterator</span> <span class="title">result</span>,  // 目标容器的起始地址 </span></span><br><span class="line"><span class="class">							  <span class="title">UnaryOperator</span> <span class="title">op</span> );</span>     <span class="comment">// 函数指针 </span></span><br><span class="line"><span class="comment">// typedef 目标容器元素类型 (*UnaryOperator)(源容器元素类型); </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">BinaryOperator</span> &gt; </span></span><br><span class="line"><span class="class">	<span class="title">OutputIterator</span> <span class="title">transform</span> ( <span class="title">InputIterator1</span> <span class="title">first1</span>,     // 源容器1的起始地址 </span></span><br><span class="line"><span class="class">							  <span class="title">InputIterator1</span> <span class="title">last1</span>,       // 源容器1的终止地址 </span></span><br><span class="line"><span class="class">							  <span class="title">InputIterator2</span> <span class="title">first2</span>,      // 源容器2的起始地址，元素个数与1相同 </span></span><br><span class="line"><span class="class">							  <span class="title">OutputIterator</span> <span class="title">result</span>,      // 目标容器的起始地址，元素个数与1相同 </span></span><br><span class="line"><span class="class">							  <span class="title">BinaryOperator</span> <span class="title">binary_op</span> );</span> <span class="comment">// 函数指针 </span></span><br><span class="line"><span class="comment">// typedef 目标容器元素类型 (*BinaryOperator)(源容器1元素类型，源容器2元素类型);</span></span><br></pre></td></tr></table></figure>
<p>所以transform结合大小写转换函数tolower，只需要一行即可完成任务</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toLowerCase</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        transform(str.begin(),str.end(),str.begin(),::<span class="built_in">tolower</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.NULL(一) Course overview + the shell</title>
    <url>/2020/05/27/MIT-6-NULL-one-Course-overview-plus-the-shell.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://missing-semester-cn.github.io/2020/course-shell/" target="_blank" rel="noopener">第一章</a>主要介绍课程概览，shell的一些基础知识。<br><a id="more"></a><br>课程分为11个时长一小时的讲座，每次围绕一个特定主题。第一次课程主要介绍了shell的使用，这是计算机的一个对外接口，这次课程介绍的许多工具都要通过shell来操作。</p>
<h3 id="主题-1-The-Shell"><a href="#主题-1-The-Shell" class="headerlink" title="主题 1: The Shell"></a>主题 1: The Shell</h3><h4 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h4><p>图形界面等交互式接口会限制我们对计算机的操作，比如无法在GUI上点击一个不存在的按钮。所以需要用到最根本的文字接口：<strong>Shell</strong>。大部分<strong>Shell</strong>的核心功能都是：<code>它允许你执行程序，输入并获取某种半结构化都输出。</code>课程中使用<code>Bourne Again SHell</code>, 简称 <code>“bash”</code>。</p>
<h4 id="shell使用"><a href="#shell使用" class="headerlink" title="shell使用"></a>shell使用</h4><p>这里我通过虚拟机安装的ubuntu系统完成课程中的各个实验。首先打开终端，有提示符</p>
<blockquote>
<p><code>wuyunjie@ubuntu:~$</code> </p>
</blockquote>
<p>这是shell最主要的文本接口。它告诉你，当前登陆用户是<code>wuyunjie</code>，主机名是 <code>missing</code> 并且当前的工作目录（”current working directory”）或者说当前所在的位置是<code>~</code> (表示 “home”)。 <code>$</code>符号表示您现在的身份不是<code>root</code>用户。可以在其中输入 <em>命令</em> ，命令最终会被shell解析。课程用到的例子如下：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_introduction.png" alt="Shell Introduction"></p>
<p>首先执行了 <code>date</code> 程序，打印出当前的日前和时间。然后，shell等待输入其他命令。</p>
<p>可以在执行命令的同时向程序传递 <code>参数</code>，比如<code>echo hello</code>中，<code>hello</code>是指定输入给<code>echo</code>程序的参数。shell基于<strong>空格</strong>分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），要么用使用单引号，双引号将<code>包含空格的参数</code>包裹起来，要么使用转义符号<code>\</code>进行处理(My\ Photos)。</p>
<p>shell其实也是一个编程环境，它具备<code>变量、条件、循环和函数</code>。当在shell中执行命令时，实际上是在<code>执行一段shell可以解释执行的简短代码</code>。如果要求shell执行某个指令，但是该指令并不是shell所了解的编程关键字，那么它会去查询 <em>环境变量</em> <code>$PATH</code>，它会列出当shell接到某条指令时，进行程序搜索的路径。要确定某个程序名代表的是哪个具体的程序(程序的路径)，可以使用 <code>which</code> 命令。</p>
<h4 id="shell中的路径"><a href="#shell中的路径" class="headerlink" title="shell中的路径"></a>shell中的路径</h4><p>shell中的路径是一组<em>被分割的目录</em>，在 Linux 和 macOS 上使用 <code>/</code> 分割，而在Windows上是 <code>\</code> 。路径 <code>/</code> 代表的是系统的根目录，在Windows上每个盘都有一个根目录（例如： C:\）。</p>
<p>Linux文件系统中如果某个路径以 <code>/</code> 开头，那么它是一个 <em>绝对路径</em>，其他的都术语 <em>相对路径</em>。相对路径是指相对于<em>当前工作目录</em>的路径，当前工作目录可以使用 <code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code> 命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录。</p>
<p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令。大多数的命令接受<em>标记和选项</em>，它们以 <code>-</code> 开头。通常，在执行程序时使用 <code>-h</code> 或 <code>--help</code> 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_path.png" alt="Shell Path"></p>
<p><code>ls -l</code>命令可以打印出更加详细地列出目录下文件或文件夹的信息。</p>
<ol>
<li>首先，本行第一个字符 <code>d</code> 表示是一个目录。</li>
<li>然后接下来的九个字符，每三个字符 (<code>rwx</code>).构成一组。它们分别代表了<code>文件所有者</code>，<code>用户组</code>以及<code>其他所有人</code>具有的权限。其中 <code>-</code> 表示该用户不具备相应的权限，<code>w</code>表示”<em>可修改</em>“，<code>x</code>表示“<em>可执行</em>”，<code>r</code>表示”<code>可读</code>“。</li>
</ol>
<p>还有一些比较常用的命令：<code>mv</code> （用于重命名或移动文件）、 <code>cp</code> (拷贝文件)以及 <code>mkdir</code> (新建文件夹)。可以使用 <code>man</code> 查阅某条命令的文档（用户手册），比如<code>man ls</code>。</p>
<h4 id="“流”和”管道”"><a href="#“流”和”管道”" class="headerlink" title="“流”和”管道”"></a>“流”和”管道”</h4><h5 id="流"><a href="#流" class="headerlink" title="流"></a>流</h5><p>在shell中，程序有两个主要的“流”：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ol>
<li>当程序尝试读取信息时，它们会从输入流中进行读取；</li>
<li>当程序打印信息时，它们会将信息输出到输出流中。<br>通常，一个程序的输入输出流都是终端。我们也可以重定向这些流！</li>
</ol>
<p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件。还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_stream.png" alt="Shell Stream"></p>
<h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>使用管道（ <em>pipes</em>），能够更好的利用文件重定向。<code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_pipe.png" alt="Shell Pipe"></p>
<p>可以发现 <code>&gt;</code> 会将之后的单词视为文件名导致，是文件上的重定向。而 <code>|</code> 可以是不同程序之间的重定向。之前总感觉这个地方很混乱，也没仔细深究，现在也算补了一个坑。</p>
<h4 id="功能全面又强大的工具"><a href="#功能全面又强大的工具" class="headerlink" title="功能全面又强大的工具"></a>功能全面又强大的工具</h4><p>对于大多数的类Unix系统，<code>根用户</code>（<code>root</code>用户）是非常特殊的。根用户<strong>几乎不受任何限制</strong>，他可以创建、读取、更新和删除系统中的任何文件。当遇到<code>拒绝访问（permission denied）</code>的错误时，通常是因为必须是根用户才能操作。</p>
<blockquote>
<p>通常在我们并不会以根用户的身份直接登陆系统，因为这样可能会因为某些错误的操作而破坏系统。取而代之的是我们会在需要的时候使用 <code>sudo</code> 命令。顾名思义，它的作用是可以以 <code>su</code>（<code>super user</code> 或 <code>root</code>的简写）的身份 <strong>do</strong> 一些事情。 </p>
</blockquote>
<p>比如有一件事情是必须作为根用户才能做的，那就是<strong>Linux</strong>下向 <code>sysfs</code> 文件写入内容。系统被挂在在 <code>/sys</code> 下，<code>sysfs</code> 文件则暴露了一些内核（kernel）参数。 因此不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。</p>
<p>课程里那个改屏幕亮度的例子没实现，不知道是不是由于虚拟机配置的关系，这里直接把他的内容摘过来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo find -L /sys/class/backlight -maxdepth 2 -name <span class="string">'*brightness*'</span></span></span><br><span class="line">/sys/class/backlight/thinkpad_screen/brightness</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /sys/class/backlight/thinkpad_screen</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo <span class="built_in">echo</span> 3 &gt; brightness</span></span><br><span class="line">An error occurred while redirecting file 'brightness'</span><br><span class="line">open: Permission denied</span><br></pre></td></tr></table></figure>
<p>尽管用了<code>sudo</code>，但仍然报错了。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过shell执行的，而不是被各个程序单独执行。 <code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， shell在设置 <code>sudo echo</code> 前尝试打开 <code>brightness</code> 文件并写入，但是系统拒绝了shell的操作因为此时shell不是根用户。可以将上述操作修改为 <code>echo 3 | sudo tee brightness</code>，打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。</p>
<h3 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h3><ol>
<li>前面1-7还好，是对shell的一个熟悉。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_exercise.png" alt="Shell exercise1"></p>
<p>主要简单了解了一下<code>shebang</code>，即在脚本开头由字符数字符号和感叹号（<code>＃!</code>）组成的字符序列。当使用带有<code>Shebang</code>的文本文件时，程序加载机制会将文件的其余行解析为解释器指令。加载程序执行指定的解释程序，将尝试运行脚本时最初使用的路径作为参数传递给它，以便程序可以将文件用作输入数据。</p>
<p><code>shebang</code> 解释器指令的形式如下：</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!interpreter [optional-arg]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>interpreter</code>是解释器的绝对路径，<code>optional-arg</code>是表示单个参数的字符串，可选。</p>
<ol>
<li>8题需要查到<em>最后更改日期信息</em>，并且将其写入文件，这里主要就是如何找到<code>last-modified</code>这一行。刚开始使用<code>find</code>，但它适用于查找文件，查找文本更多用的<code>grep</code>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_exercise2.png" alt="Shell exercise2"></p>
]]></content>
      <categories>
        <category>MIT课程</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>MIT</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo学习记录--基本操作</title>
    <url>/2019/11/11/hexo-learning-record--basic-operation.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>终于决定重新开始写博客了。这次一定得坚持下来，写写学习进度，定期自我总结。太久没写博客了，基本操作又给忘了，这次就索性先从怎么写博客开始，把基本指令都记录下来，省得下次半途而废回来的时候又全忘了到处查。</p>
</blockquote>
<a id="more"></a>
<h3 id="Hexo写博客的基本操作"><a href="#Hexo写博客的基本操作" class="headerlink" title="Hexo写博客的基本操作"></a>Hexo写博客的基本操作</h3><h4 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h4><blockquote>
<p>最重要的就是写文章部分了，首先了解如何新建一篇文章。Hexo博客建立开始，就自带一篇 <a href="http://wuyunjie.top/2017/09/20/hello-world/" target="_blank" rel="noopener">Hello World</a> 简易教程。新建文章主要用下面这条命令：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里可以指定文章的布局(layout)，默认为 <code>post</code>。这样所有的文章都会以<code>md</code>形式在<code>source</code>文件夹下的<code>_post</code>文件夹中被创建，之后我们就可以愉快的编辑文章了，这是一个<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">markdown的学习文档</a>。</p>
</blockquote>
<h4 id="添加分类页"><a href="#添加分类页" class="headerlink" title="添加分类页"></a>添加分类页</h4><blockquote>
<p>新建一个分类页面，命名为 <code>categories</code>。命令如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page [categories]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以将 <code>categories</code> 改为自己需要的新页面，会在 <code>source</code> 文件夹下新建一个对应名为<code>categories</code>的文件夹。然后编辑主题的 <code>_config.yml</code>，即<code>themes/next</code>下的配置文件，区别于网站根目录下的配置文件，将 <code>menu</code> 中的 <code>categories: /categories || th</code> 注释去掉，在菜单中添加链接。</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure>
<h4 id="文章分类归档"><a href="#文章分类归档" class="headerlink" title="文章分类归档"></a>文章分类归档</h4><blockquote>
<p>当然也可以个文章进行分类归档，在编辑文章时，为文章添加 <code>tags</code> 和 <code>categories</code>即可。<br><figure class="highlight mkdown"><table><tr><td class="code"><pre><span class="line">title: a title</span><br><span class="line">date: a date</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">    - </span>tag1</span><br><span class="line"><span class="bullet">    - </span>tag2</span><br><span class="line"><span class="bullet">    - </span>tag3</span><br><span class="line">categories: a category</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a>编辑工具</h4><blockquote>
<p>为了方便，感觉又两个在线编辑<code>markdown</code>文档的工具挺好用的。</p>
<blockquote>
<ol>
<li><a href="http://markdown.xiaoshujiang.com/" target="_blank" rel="noopener">小书匠</a></li>
<li><a href="https://www.mdeditor.com/" target="_blank" rel="noopener">MdEditor</a></li>
</ol>
</blockquote>
<p>当然也可以配置离线工具，但是不太熟。我配了个<code>sublime</code>的，感觉不好看，也不怎么好用。</p>
</blockquote>
<h3 id="生成和部署"><a href="#生成和部署" class="headerlink" title="生成和部署"></a>生成和部署</h3><blockquote>
<p>当编辑完一个博客页面后，我们需要生成静态页面。可以用如下指令。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g #生成</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们不需要急于将页面提交到<code>github</code>，可以先在本地预览效果进行调整，等到达到满意后，再部署到<code>github</code>。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s #启动服务, 通过 `localhost:4000`访问本地页面</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一切准备就绪后，就可以提交了。然后通过自己的域名就可以成功访问博客。不过这一步可能会存在延迟，不会立即看到效果。应该是由于缓存的关系。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d #上传部署到github</span><br></pre></td></tr></table></figure>
<h3 id="常用命令和缩写"><a href="#常用命令和缩写" class="headerlink" title="常用命令和缩写"></a>常用命令和缩写</h3><blockquote>
<p>常用命令有以下几个</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new "postName" #新建文章</span><br><span class="line">hexo new page "pageName" #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一些缩写形式</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>
<blockquote>
<p>至此我们可以开始愉快的玩耍了。</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p>[1] <a href="https://www.jianshu.com/p/1bcad7700c46" target="_blank" rel="noopener">使用hexo搭建github博客</a><br>[2] <a href="https://www.cnblogs.com/fengzheng/p/8031518.html" target="_blank" rel="noopener">Hexo + github 打造个人博客</a><br>[3] <a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">使用hexo+github搭建免费个人博客详细教程</a><br>[4] <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo 指令</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>学习记录</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/09/20/Hello-World.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>学习记录</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>pip/conda install 由于目标计算机积极拒绝，无法连接</title>
    <url>/2019/11/23/Pip-conda-install-unable-to-connect-bug.html</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>之前遇到一个困扰已久的问题, 使用 <code>conda/pip install</code> 安装库时一直显示代理有问题, <code>由于目标计算机积极拒绝，无法连接</code>。<a id="more"></a><br>一开始一直以为是我的代理设置出现了问题，改了很多次系统代理设置，但一直没有效果。而且这个问题也使得我的谷歌浏览器无法实现科学上网。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>最后终于通过修改注册表解决了这个问题，主要操作如下：</p>
<blockquote>
<ol>
<li>通过<code>Win+R</code>快捷键，输入<code>regedit</code>，打开注册表编辑器</li>
<li>找到<code>HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Internet Settings</code></li>
<li>将以 <strong>Proxy</strong> 开头的条目都删除</li>
</ol>
</blockquote>
<p>之后一切就都回复正常了。这个改注册表的方法还挺万用的，有时候会出现无法连上网但是无法访问百度的问题，也可通过删除<code>HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Internet Settings/Connections</code>下的相关条目来解决。</p>
<p>应该是由于科学上网后系统代理出现啥Bug，通过删除注册表可以实现初始化吧。</p>
<h3 id="查看文献"><a href="#查看文献" class="headerlink" title="查看文献"></a>查看文献</h3><blockquote>
<ul>
<li><a href="https://blog.csdn.net/lezeqe/article/details/94913345" target="_blank" rel="noopener">解决：pip install 由于目标计算机积极拒绝，无法连接</a></li>
<li><a href="https://blog.csdn.net/weixin_43323092/article/details/82962023" target="_blank" rel="noopener">解决系统代理被篡改/pip提示“目标计算机积极拒绝，无法连接”的方法</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark学习-Spark程序基本运行流程</title>
    <url>/2019/11/16/Spark-learning-record--program-running-process.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>刚好最近学习大数据需要运行简单的Spark算法，就顺便记录一下Spark程序基本上是怎么运行的，这里就不涉及那些理论或者API的用法了。只是说怎么把程序跑起来<br><a id="more"></a></p>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><p>以做的线性回归算法为例(只做了线性回归<code>-_-||</code>)，主要步骤如下：</p>
<blockquote>
<ol>
<li><p>编写 Spark 程序，这里涉及到一些 Spark 语法，暂时没看懂，以后系统学习的时候再慢慢深入</p>
</li>
<li><p>将实验数据传到 HDFS 上，配置的 Spark 基于 Hadoop 的 HDFS 运行，所以 Spark 直接访问的是 HDFS 上的数据，不能访问到本地。</p>
</li>
<li><p>将程序(调用<code>pyspark</code>的<code>.py</code>代码)提交到集群执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">spark-submit --master spark://host:port program.py</span><br></pre></td></tr></table></figure>
<p>查阅资料 Spark 还有多种运行模式，以后好好学一学(拖延症，不知道啥时候能开始学了)<br>HDFS 的主要操作有以下： </p>
</li>
</ol>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">hdfs dfs -help</td>
<td style="text-align:left">--查看hdfs帮助</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -ls folder</td>
<td style="text-align:left">--查看目录文件</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -put sourcepath savepath</td>
<td style="text-align:left">--hdfs上传文件，-f 覆盖已有文件；-p 保留原文件属性</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -get sourcepath savepath</td>
<td style="text-align:left">--hdfs下载文件</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -mkdir -p /output/dirname</td>
<td style="text-align:left">--创建多级目录</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -touchz /input/filename</td>
<td style="text-align:left">--创建文件filename</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -cat /input/filename</td>
<td style="text-align:left">--查看文件filename内容</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -du -s /input</td>
<td style="text-align:left">--查看所有文件大小和字节大小</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -cp /sourcefile /targetfile</td>
<td style="text-align:left">--复制文件</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -rm -R /directory</td>
<td style="text-align:left">--删除文件夹，-R循环删除文件夹里面的文件</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -mv /user/root/.Trash/Current/filename /filename</td>
<td style="text-align:left">--找回删除文件</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>这是一些较为常用的命令，具体其它指令可以查看<code>hdfs dfs -help</code>可以发现和<code>Linux</code>下文件系统的指令很相似，大部分指令的功能基本相同，只是增加了一些有分布式系统特性的指令，比如<code>-put</code>等。</p>
</blockquote>
<p>参考：</p>
<blockquote>
<ul>
<li><a href="https://www.cnblogs.com/zengming/p/10306706.html" target="_blank" rel="noopener">常用HDFS操作命令</a></li>
<li><a href="https://www.cnblogs.com/qiuhong10/p/8476635.html" target="_blank" rel="noopener">Spark多种运行模式</a></li>
<li><a href="https://blog.csdn.net/roguesir/article/details/83317059" target="_blank" rel="noopener">【PySpark学习笔记三】spark-submit命令详解</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-2-替换空格</title>
    <url>/2021/04/20/JZ2-replace-spaces.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成<code>&quot;%20&quot;</code>。例如，当字符串为<code>We Are Happy</code>，则经过替换之后的字符串为<code>We%20Are%20Happy</code>。<br><a id="more"></a></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:   “We Are Happy”<br>返回值: “We%20Are%20Happy”</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题挺简单的，就是逐个判断String数组的字符，然后基于拼接构建出要求的字符串。也有方法直接调用内置的替换函数，不知道为何难度为<strong>较难</strong>，可能还有特殊的优化解。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li><p>解法1 暴力求法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">                result += <span class="string">"%20"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2 调用 <code>String.replaceAll()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">   <span class="keyword">return</span> s.replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法3 调用 <code>Spring.split()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        String[] strs = s.split(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">" "</span>.equals(str))</span><br><span class="line">                sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            sb.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol>
<li>String、StringBuffer和StringBuilder</li>
</ol>
<ul>
<li>String<br><code>String</code>类是<strong>不可变</strong>类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。通过一个字符串对象a的内存存储空间图对String类的不可变性理解。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ2/String.png" alt="`String`类不可变"></p>
<p>再次给a赋值时，并不是对原来堆中实例对象进行重新赋值，而是生成一个新的实例对象，并且指向“456”这个字符串，a则指向最新生成的实例对象，<em>之前的实例对象仍然存在，如果没有被再次引用，则会被垃圾回收</em>。</p>
<ul>
<li>StringBuffer<br><code>StringBuffer</code>对象则代表一个字符序列<strong>可变</strong>的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的<code>append()</code>、<code>insert()</code>、<code>reverse()</code>、<code>setCharAt()</code>、<code>setLength()</code>等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的<code>toString()</code>方法将其转换为一个String对象。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ2/StringBuffer.png" alt="`StringBuffer`类"></p>
<p>字符串连接的情况，方便和直接的方式是通过”+”符号来实现，但是这种方式达到目的的效率比较低，且<em>每执行一次都会创建一个String对象</em>，<strong>即耗时，又浪费空间</strong>。使用StringBuilder类就可以避免这种问题的发生</p>
<ul>
<li>StringBuilder<br><code>StringBuilder</code>类也代表<strong>可变</strong>字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：<strong>StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高</strong>。StringBuffer类中的方法都添加了<code>synchronized</code>关键字，也就是给这个方法添加了一个锁，用来保证线程安全。</li>
</ul>
<p><strong>Java9改进了字符串</strong>（包括String、StringBuffer、StringBuilder）的实现。在Java9以前字符串采用<code>char[]</code>数组来保存字符，因此字符串的每个字符占<code>2</code>字节；而Java9的字符串采用<code>byte[]</code>数组再加一个<code>encoding-flag</code>字段来保存字符，因此字符串的每个字符只占<code>1</code>字节。所以Java9的字符串更加节省空间，字符串的功能方法也没有受到影响。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://blog.csdn.net/csxypr/article/details/92378336" target="_blank" rel="noopener">String、StringBuffer和StringBuilder的区别</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-3-从尾到头打印链表</title>
    <url>/2021/04/20/JZ3-print-LinkList-reverse.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>输入一个链表，按链表从尾到头的顺序返回一个<code>ArrayList</code>。<br><a id="more"></a></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:   {67,0,24,58}<br>返回值: [58,24,0,67]</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题也挺简单的，感觉都是考察基础啊，怎么都标为较难。思路很简单，就是遍历链表元素，存入新建的ArrayList对象，最后通过一个反转函数对ArrayList反转。此外还有基于递归的方法，或者先对链表反转，再存入ArrayList。</p>
<p>这里对反转链表操作简单复习一下，可以总结为先存储当前节点的下一节点，再反转当前节点的pnext指针，最后重置head头部。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ3/reverse_linklist.gif" alt="反转链表"></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li>解法1 存入ArrayList后反转<br>1.1. 直接加入到ArrayList第一个位置实现反转<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; List = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            List.add(<span class="number">0</span>, listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> List;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>1.2. 调用<code>Collections.reverse()</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; List = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            List.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(List);</span><br><span class="line">        <span class="keyword">return</span> List;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>解法2 反转链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = listNode;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(pre.val);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法3  递归方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol>
<li><p>Java <code>ArrayList</code>类<br>ArrayList 类是一个<strong>可以动态修改</strong>的数组，与普通数组的区别就是它是<strong>没有固定大小的限制</strong>，我们可以添加或删除元素。ArrayList 类位于<code>java.util</code>包中，使用前需要引入它，语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 引入 ArrayList 类</span></span><br><span class="line">ArrayList&lt;E&gt; objectName =<span class="keyword">new</span> ArrayList&lt;&gt;();　 <span class="comment">// 初始化</span></span><br></pre></td></tr></table></figure>
<p>ArrayList 是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p>
</li>
<li><p>Collections<br><code>Collections</code>是JDK提供的工具类，同样位于<code>java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。</p>
</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://www.runoob.com/java/java-arraylist.html" target="_blank" rel="noopener">String、StringBuffer和StringBuilder的区别</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-1-二维数组中的查找</title>
    <url>/2021/04/02/JZ1-Lookup-in-a-two-dimensional-array.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><a id="more"></a></p>
<blockquote>
<p>[<br>  [1,2,8,9],<br>  [2,4,9,12],<br>  [4,7,10,13],<br>  [6,8,11,15]<br>]</p>
</blockquote>
<p>给定 target = 7，返回 true。<br>给定 target = 3，返回 false。</p>
<p><strong>示例1:</strong></p>
<blockquote>
<p>输入:   7, [[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]<br>返回值: true<br>说明:   存在7，返回true</p>
</blockquote>
<p><strong>示例2:</strong></p>
<blockquote>
<p>输入:   3, [[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]<br>返回值: false<br>说明:   不存在3，返回false</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题考察的应该是二维数组上的二分查找，因为数组是按从顺序排列的，所有很容易想到将一维数组的思想扩展到二维数组上。但这种思想似乎并不可行，在实现过程中遇到了难度。</p>
<h4 id="方法1-暴力求解"><a href="#方法1-暴力求解" class="headerlink" title="方法1: 暴力求解"></a>方法1: 暴力求解</h4><p>暴力求解法思路很直接，直接将数组中所有数据都遍历一遍，自然可以判断<code>target</code>是否存在于数组中。但该方法复杂度为<code>O(n^2)</code>，即最坏情况下所有元素都需要访问一次。</p>
<h4 id="方法2-二分查找"><a href="#方法2-二分查找" class="headerlink" title="方法2: 二分查找"></a>方法2: 二分查找</h4><p>暴力求解方法未用到数组有序这一信息，针对数组有序自然想到二分查找的方法。这里基于题解[1]复习一下二分查找的思想。假设目标tar在arr[1]处，那么二分过程就是：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ1/Binary_Search.png" alt="Binary Search"></p>
<blockquote>
<p>1）设初始值：定义一个二分的开始下标为l，结束下标为r;<br>2）二分一半，中间位置为 <code>mid = l + （（r - l) &gt;&gt; 1)</code>(val&gt;&gt;1表示<code>val</code>右移一位相当于<code>val／2</code>)，相当于 <code>l+(r-l)/2</code>，这样的写法是<strong>防止溢出</strong>。如果写成 <code>mid = （l+r)/2;</code> l+r可能会溢出;<br>3) 如果 <code>tar == arr[mid]</code>，说明找到tar;<br>4）如果 <code>tar &gt; arr[mid]</code>, 说明tar在区间 <code>[mid+1, r]</code> 中，<code>l = mid + 1</code>;<br>5）如果 <code>tar &lt; arr[mid]</code>, 说明tar在区间 <code>[l, mid-1]</code> 中, <code>r = mid - 1</code>;</p>
</blockquote>
<p>最初的思想是依样在右上角开始，实现二分查找，思路稍微接近正确的求解，但二分后仍然存在问题，实现上不简洁。如果从左上位置开始二分，每次二分之后，难以确定下一次二分的走向，整个二维数组上顺序被打乱。最开始我的思路是按行从大到小二分，按列从小到大二分，每次将范围固定到某一个片段区域，但实际实现时逻辑不够清晰，代码越写越乱。当然可能仍然是可以按这样的思想实现的，只是我太菜了写不出来。</p>
<p>按照最终答案的思想，也是将二分值固定到右上或者左下的元素上，实现从两个方向不断缩小值所在的范围，这种思想实现上比我之前想的简洁太多了。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ1/Binary_Search_BinArr.png" alt="Binary Search"></p>
<blockquote>
<p>1）设初始值为右上角元素;<br>2）二分一半，中间位置为 <code>mid = l + （（r - l) &gt;&gt; 1)</code>(val&gt;&gt;1表示<code>val</code>右移一位相当于<code>val／2</code>)，相当于 <code>l+(r-l)/2</code>，这样的写法是<strong>防止溢出</strong>。如果写成 <code>mid = （l+r)/2;</code> l+r可能会溢出;<br>3) 如果 <code>val == target</code>, 直接返回;<br>4）如果 <code>tar &gt; val</code>, 说明 <code>target</code> 在更大的位置，val左边的元素显然都是 <code>&lt; val &lt; tar</code>，说明第 0 行都是无效的，所以val下移到arr[1][5];<br>5）如果 <code>tar &lt; val</code>, 说明 <code>target</code> 在更小的位置，val下边的元素显然都是 <code>&gt; val &gt; tar</code>，说明第 5 列都是无效的，所以val左移到arr[0][4];</p>
</blockquote>
<p>时间复杂度：<code>O(m+n)</code> ，其中m为行数，n为列数，最坏情况下，需要遍历m+n次。</p>
<h4 id="方法3-双折半查找法"><a href="#方法3-双折半查找法" class="headerlink" title="方法3: 双折半查找法"></a>方法3: 双折半查找法</h4><p>参考自题解[2]，该思路与我最开始的思路很相似，看了之后发现还是可以实现的，果然是我太菜了。最坏情况下时间复杂度为<code>O(M * logN)</code></p>
<blockquote>
<p>1）在二维数组分为上下左右四个边界top，bottom，left，right;<br>2）对上边界<code>top</code>进行折半查找，假设终止点为 <code>E</code>，则可以将二维数组位于终止点<code>E</code>右边的矩形<code>Rr</code>排除，因为终止点<code>E</code>小于其右边相邻的元素<code>E+1</code>，而<code>E+1</code>是右边矩形Rr的最小元素(左上元素);<br>3) 对下边界<code>bottom</code>折半，可以排除二维数组位于终止点<code>E</code>左边的矩形<code>Rl</code>排除;<br>4）对左边界<code>left</code>折半，可以排除二维数组位于终止点<code>E</code>下边的矩形<code>Rb</code>排除;<br>5）对右边界<code>right</code>折半，可以排除二维数组位于终止点<code>E</code>上边的矩形<code>Rt</code>排除;<br>6) 对由新边界组成的矩形重复以上操作，直到范围缩小为只有一个元素</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li><p>解法1 暴力求法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] vec: array)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: vec)&#123;</span><br><span class="line">                <span class="keyword">if</span> (num == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2 两遍哈希表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt; array.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target == array[row][col])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[row][col])&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法3 双折半查找法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, bottom = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sLeft = <span class="number">0</span>, sRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sTop = <span class="number">0</span>, sBottom = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt; right || top &lt; bottom)&#123;</span><br><span class="line">            <span class="comment">// 在上边界查找，缩小右边界</span></span><br><span class="line">            sLeft = left; sRight = right;</span><br><span class="line">            <span class="keyword">while</span> (sLeft &lt;= sRight) &#123;</span><br><span class="line">                mid = (sLeft + sRight) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[top][mid] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[top][mid] &lt; target)</span><br><span class="line">                    sLeft = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sRight = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; right) right = mid;</span><br><span class="line">            top++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在下边界查找，缩小左边界</span></span><br><span class="line">            sLeft = left; sRight = right;</span><br><span class="line">            <span class="keyword">while</span> (sLeft &lt;= sRight) &#123;</span><br><span class="line">                mid = (sLeft + sRight) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[bottom][mid] == target) </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[bottom][mid] &lt; target) </span><br><span class="line">                    sLeft = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    sRight = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; mid) left = mid; <span class="comment">//利用终止点缩小左边界</span></span><br><span class="line">            bottom--;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对左边界进行折半，可以缩小下边界</span></span><br><span class="line">            sTop = top; sBottom = bottom;</span><br><span class="line">            <span class="keyword">while</span> (sTop &lt;= sBottom) &#123;</span><br><span class="line">                mid = (sTop + sBottom) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[mid][left] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[mid][left] &lt; target)</span><br><span class="line">                    sTop = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sBottom = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; bottom) bottom = mid; <span class="comment">//利用终止点缩小下边界</span></span><br><span class="line">            left++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对右边界进行折半，可以缩小上边界</span></span><br><span class="line">            sTop = top; sBottom = bottom;</span><br><span class="line">            <span class="keyword">while</span> (sTop &lt;= sBottom) &#123;</span><br><span class="line">                mid = (sTop + sBottom) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[mid][right] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[mid][right] &lt; target)</span><br><span class="line">                    sTop = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sBottom = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top&lt;mid) top = mid; <span class="comment">//利用终止点缩小上边界</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (top &lt; array.length &amp;&amp; left &lt; array[<span class="number">0</span>].length &amp;&amp; array[top][left] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol>
<li>For-Each循环<br><code>For-Each</code>语句(也叫增强型的for循环)是<code>java5</code>的新特征之一，在遍历数组、集合方面，<code>foreach</code>为开发人员提供了极大的方便。但是<code>foreach</code>语句并不能完全取代<code>for</code>语句，任何的<code>foreach</code>语句都可以改写为<code>for</code>语句。值得注意的是，<code>foreach</code>并不是一个关键字，语法如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(type element: array)&#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其缺点是丢掉了索引信息，foreach只能挨个遍历数组或者集合一遍。但在可以使用foreach的地方，其简化了编程，<em>提高了代码的可读性和安全性（不用怕数组越界）</em>。foreach一般结合泛型使用。</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://blog.nowcoder.net/n/f146364d1331407080adbbb5a062e067" target="_blank" rel="noopener">二维数组中的查找</a><br>[2] <a href="https://blog.nowcoder.net/n/d332492753844d18aa4edc484e3c1318" target="_blank" rel="noopener">《剑指Offer》二维数组中的查找</a><br>[3] <a href="https://blog.csdn.net/qq_32671287/article/details/79420736" target="_blank" rel="noopener">java中foreach循环</a><br>[4] <a href="https://www.cnblogs.com/mengdd/archive/2013/01/21/2870019.html" target="_blank" rel="noopener">Java 增强型的for循环 for each</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text3 删除 Markdown Editing 插件后启动报错</title>
    <url>/2019/11/16/Sublime-Text3-removes-the-Markdown-Editing-plugin-leads-to-an-error.html</url>
    <content><![CDATA[<h3 id="Sublime-Text3启动报错"><a href="#Sublime-Text3启动报错" class="headerlink" title="Sublime Text3启动报错"></a>Sublime Text3启动报错</h3><p><code>Sublime Text3</code> 之前装了 <code>Markdown Editing</code> 插件，由于嫌弃界面太难看把他卸载了，之后再次打开<code>.md</code>格式的文件，一直报下面这个错误。<br><a id="more"></a><br><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>Error loading colour scheme Packages/MarkdownEditing/MarkdownEditor.tmTheme: Error parsing plist xml: Failed to open file In file "Packages/MarkdownEditing/MarkdownEditor.tmTheme"</span><br></pre></td></tr></table></figure></p>
<p>查阅网上有方法说<code>set syntax:html</code> 可以解决，但这好像不能根本解决问题，依旧会弹出报错弹窗。后面找到文件夹<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Usersname\AppData\Roaming\Sublime Text 3\Packages\User</span><br></pre></td></tr></table></figure><br>发现存在卸载残留文件，即 <code>Markdown Editing</code> 的配置文件，将其删除后文集解决，<code>Sublime Text3</code>正常工作。类似的还有一个<code>Error trying to parse settings</code>的报错，也是配置文件的原因，找到报错显示的对应配置文件修改一下就解决了。</p>
]]></content>
      <categories>
        <category>Sublime Text3</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>Sublime Text3</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-4-重建二叉树</title>
    <url>/2021/04/26/JZ4-rebuild-binaryTree.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><a id="more"></a></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:   [1,2,3,4,5,6,7],[3,2,4,1,6,5,7]<br>返回值: {1,2,5,3,4,6,7}</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>考察二叉树很经典的题，需要理解前序遍历、中序遍历的方法，然后据此重建二叉树。</p>
<h4 id="二叉树的遍历方法"><a href="#二叉树的遍历方法" class="headerlink" title="二叉树的遍历方法"></a>二叉树的遍历方法</h4><blockquote>
<ol>
<li>前序遍历：根左右</li>
<li>中序遍历：左根右</li>
<li>后序遍历：左右根</li>
</ol>
</blockquote>
<p>一般使用递归方法实现遍历，在遍历过程中每个子树都可当作一颗新树递归处理。此外也可以利用栈实现非递归的遍历方法。</p>
<h4 id="方法1-递归方法"><a href="#方法1-递归方法" class="headerlink" title="方法1: 递归方法"></a>方法1: 递归方法</h4><p>对于任意一棵树，前序遍历的形式总是：</p>
<blockquote>
<p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</p>
</blockquote>
<p>中序遍历的形式总是：</p>
<blockquote>
<p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p>
</blockquote>
<p>所以在中序遍历中定位到根节点，就可以得到左子树和右子树的节点及节点数目。由此可以进一步在前序遍历结果中，分别得到左右子树。依次类推可以递归构造出子树的左右子树，知道最终左右子树都只剩一个节点，得到一颗完整的树。</p>
<blockquote>
<ol>
<li><p>在中序遍历中对根节点进行定位时，一种简单的方法是<strong>直接扫描整个中序遍历的结果并找出根节点</strong>，但这样做的时间复杂度较高。</p>
</li>
<li><p>考虑使用<code>哈希表</code>来快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，对中序遍历列表进行一遍扫描，构造出这个哈希映射。在此后构造二叉树的过程中，只需要 <code>O(1)</code> 的时间对根节点进行定位。</p>
</li>
</ol>
</blockquote>
<h4 id="方法2-非递归-迭代-方法"><a href="#方法2-非递归-迭代-方法" class="headerlink" title="方法2: 非递归(迭代)方法"></a>方法2: 非递归(迭代)方法</h4><p>根据前序遍历原理，对于前序遍历中的任意两个连续节点 <em>u</em> 和 <em>v</em>，只有两种可能的关系：</p>
<blockquote>
<ul>
<li><em>v</em> 是 <em>u</em> 的左儿子。因为在遍历到 <em>u</em> 之后，下一个遍历的节点就是 <em>u</em> 的左儿子，即 <em>v</em>；</li>
<li><em>u</em> 没有左儿子，并且 <em>v</em> 是 <em>u</em> 的某个祖先节点（或者 <em>u</em> 本身）的右儿子。<ul>
<li>如果 <em>u</em> 没有左儿子，那么下一个遍历的节点就是 <em>u</em> 的右儿子。</li>
<li>如果 <em>u</em> 没有右儿子，就会向上回溯，直到遇到第一个有右儿子（且 <em>u</em> 不在它的右儿子的子树中）的节点 <em>a</em>，那么 <em>v</em> 就是 <em>a</em> 的右儿子。</li>
</ul>
</li>
</ul>
</blockquote>
<p>用一个<code>栈 stack</code> 来维护<code>「当前节点的所有还没有考虑过右儿子的祖先节点」</code>，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，用一个<code>指针 index</code> 指向<strong>中序遍历</strong>的某个位置，初始值为 <code>0</code>。<code>index</code> 对应的节点是<code>「当前节点不断往左走达到的最终节点」</code>，这也是符合中序遍历。算法流程如下：</p>
<blockquote>
<ol>
<li><p>用一个<code>栈</code>和一个<code>指针</code>辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p>
</li>
<li><p>依次枚举前序遍历中除了第一个节点以外的每个节点。</p>
<ul>
<li>如果 <code>index</code> 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 <code>index</code>，并将当前节点作为最后一个弹出的节点的右儿子；</li>
<li>如果 <code>index</code> 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</li>
</ul>
</li>
<li>无论是哪一种情况，最后都将当前的节点入栈。</li>
</ol>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li><p>解法1  递归方法(<strong>直接扫描</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> [] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startPre &gt; endPre) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == pre[startPre])&#123;</span><br><span class="line">                root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + i - startIn, in, startIn, startIn + i - <span class="number">1</span>);</span><br><span class="line">                root.right = reConstructBinaryTree(pre, startPre + i - startIn + <span class="number">1</span>, endPre, in, i + <span class="number">1</span>, endIn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法1  递归方法(<strong>哈希表</strong>)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            indexMap.put(in[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> [] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startPre &gt; endPre) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> inRoot = indexMap.get(pre[startPre]);</span><br><span class="line">        root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + inRoot - startIn, in, startIn, startIn + inRoot - <span class="number">1</span>);</span><br><span class="line">        root.right = reConstructBinaryTree(pre, startPre + inRoot - startIn + <span class="number">1</span>, endPre, in, inRoot + <span class="number">1</span>, endIn);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>解法2 迭代法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span> || pre.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> preVal = pre[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="comment">// 左子树</span></span><br><span class="line">            <span class="keyword">if</span> (node.val != in[inIndex]) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(preVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右子树</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == in[inIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(preVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol>
<li><p>思考：如果给你中序遍历序列和后序遍历序列<br>思路类似于中序遍历和前序遍历的情况，只是在从后续遍历找根节点时，从后序遍历数组末端元素开始。后序遍历的形式总是：</p>
<blockquote>
<p>[  [左子树的前序遍历结果], [右子树的前序遍历结果] ,根节点]</p>
</blockquote>
<p>伪代码表示为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设元素在数组v中，并且尾结点的下标为 root_index, first &lt; root_index &lt; last,</span></span><br><span class="line">TreeNode* build(<span class="keyword">int</span> first, <span class="keyword">int</span> last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt; last) <span class="keyword">return</span> nullptr;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(v[root_index]);</span><br><span class="line">    root-&gt;left = build(first, root_index - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = build(root_index + <span class="number">1</span>, last);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，这里中序遍历起到很重要的作用，基于中序遍历可以分隔开左右子树。而仅仅给定前序遍历和后序遍历时，是无法得到唯一子树的。比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">树1：</span><br><span class="line">        3</span><br><span class="line">       /</span><br><span class="line">      9</span><br><span class="line">     /</span><br><span class="line">    8</span><br><span class="line">   / </span><br><span class="line">  5</span><br><span class="line"> /</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">树2：</span><br><span class="line">        3</span><br><span class="line">         \</span><br><span class="line">          9</span><br><span class="line">           \</span><br><span class="line">            8</span><br><span class="line">             \</span><br><span class="line">              5</span><br><span class="line">               \</span><br><span class="line">                4</span><br></pre></td></tr></table></figure>
<p>以上这两棵特殊的树，其前序遍历，后续遍历结果都是：[3, 9, 8, 5, 4]，[4, 5, 8, 9, 3]。难以构造出唯一的树。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">力扣官方题解——重建二叉树</a></p>
</blockquote>
</li>
</ol>
<p>[2] <a href="https://blog.nowcoder.net/n/c56eeb5b1845432a903db1c3c0cbc80a" target="_blank" rel="noopener">[编程题]重建二叉树</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>第一周LeetCode</title>
    <url>/2019/03/28/first-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第一周LeetCode刷题记录"><a href="#第一周LeetCode刷题记录" class="headerlink" title="第一周LeetCode刷题记录"></a>第一周LeetCode刷题记录</h2><a id="more"></a>
<p>1.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%941-Two-Sum/" target="_blank" rel="noopener" title="LeetCode——1. Two Sum">LeetCode——1. Two Sum</a><br>2.<a href="http://wuyunjie.top/2019/03/28/LeLeetCode%E2%80%94%E2%80%942-Add-Two-Numbers/" target="_blank" rel="noopener" title="LeetCode——2. Add Two Numbers">LeetCode——2. Add Two Numbers</a><br>3.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%943-Longest-Substring-Without-Repeating-Characters/" target="_blank" rel="noopener" title="LeetCode——3. Longest Substring Without Repeating Characters">LeetCode——3. Longest Substring Without Repeating Characters</a><br>4.<a href="http://wuyunjie.top/2019/03/28/LeLeetCode%E2%80%94%E2%80%947-Reverse-Integer/" target="_blank" rel="noopener" title="LeetCode——7. Reverse Integer">LeetCode——7. Reverse Integer</a><br>5.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94709-To-Lower-Case/" target="_blank" rel="noopener" title="LeetCode——709. To Lower Case">LeetCode——709. To Lower Case</a><br>6.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94771-Jewels-and-Stones/" target="_blank" rel="noopener" title="LeetCode——771. Jewels and Stones">LeetCode——771. Jewels and Stones</a><br>7.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94929-Unique-Email-Addresses/" target="_blank" rel="noopener" title="LeetCode——929. Unique Email Addresses">LeetCode——929. Unique Email Addresses</a></p>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 GitHub 下载单个文件夹</title>
    <url>/2019/11/16/githun-download-single-folder.html</url>
    <content><![CDATA[<p>在<code>GitHub</code>上浏览开源项目时或者在查看自己的仓库时，<a id="more"></a>我们可能只需要其中单独几个文件夹下的内容，而不需要整个仓库。但一般<code>GitHub</code>只能克隆整个仓库。可以通过一个在线网站<code>DownGit</code>自动打包下载对应文件夹：</p>
<blockquote>
<p><a href="https://www.itsvse.com/downgit/#/home" target="_blank" rel="noopener">DownGit</a></p>
</blockquote>
<p>只需要找到仓库中对应文件夹的url，输入之后，点击 download 自动打包下载。<br><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/DownGit.PNG" alt="DownGit"></p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>第三周LeetCode</title>
    <url>/2019/04/11/third-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第三周LeetCode刷题记录"><a href="#第三周LeetCode刷题记录" class="headerlink" title="第三周LeetCode刷题记录"></a>第三周LeetCode刷题记录</h2><a id="more"></a>
<ol>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-10-Regular-Expression-Matching/" target="_blank" rel="noopener" title="LeetCode--10. Regular Expression Matching">LeetCode—10. Regular Expression Matching</a></li>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-13-Roman-to-Integer/" target="_blank" rel="noopener" title="LeetCode--13. Roman to Integer">LeetCode—13. Roman to Integer</a></li>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-14-Longest-Common-Prefix/" target="_blank" rel="noopener" title="LeetCode--14. Longest Common Prefix">LeetCode—14. Longest Common Prefix</a></li>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-15-3Sum/" target="_blank" rel="noopener" title="LeetCode--15. 3Sum">LeetCode—15. 3Sum</a></li>
<li><a href="http://wuyunjie.top/2019/04/09/LeetCode-16-3Sum-Closest/" target="_blank" rel="noopener" title="LeetCode--16. 3Sum Closest">LeetCode—16. 3Sum Closest</a></li>
<li><a href="http://wuyunjie.top/2019/04/10/LeetCode-17-Letter-Combinations-of-a-Phone-Number/" target="_blank" rel="noopener" title="LeetCode--17. Letter Combinations of a Phone Number">LeetCode—17. Letter Combinations of a Phone Number</a></li>
<li><a href="http://wuyunjie.top/2019/04/10/LeetCode-18-4Sum/" target="_blank" rel="noopener" title="LeetCode--18. 4Sum">LeetCode—18. 4Sum</a></li>
<li><a href="http://wuyunjie.top/2019/04/11/LeetCode-19-Remove-Nth-Node-From-End-of-List/" target="_blank" rel="noopener" title="LeetCode--19. Remove Nth Node From End of List">LeetCode—19. Remove Nth Node From End of List</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>第五周LeetCode</title>
    <url>/2019/04/25/fifth-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第五周LeetCode刷题记录"><a href="#第五周LeetCode刷题记录" class="headerlink" title="第五周LeetCode刷题记录"></a>第五周LeetCode刷题记录</h2><a id="more"></a>
<ol>
<li><a href="http://wuyunjie.top/2019/04/17/LeetCode-27-Remove-Element/" target="_blank" rel="noopener" title="LeetCode--27. Remove Element">LeetCode—27. Remove Element</a></li>
<li><a href="http://wuyunjie.top/2019/04/17/LeetCode-28-Implement-strStr/" target="_blank" rel="noopener" title="LeetCode--28. Implement strStr()">LeetCode—28. Implement strStr()</a></li>
<li><a href="http://wuyunjie.top/2019/04/22/LeetCode-29-Divide-Two-Integers/" target="_blank" rel="noopener" title="LeetCode--29. Divide Two Integers">LeetCode—29. Divide Two Integers</a></li>
<li><a href="http://wuyunjie.top/2019/04/22/LeetCode-30-Substring-with-Concatenation-of-All-Words/" target="_blank" rel="noopener" title="LeetCode--30. Substring with Concatenation of All Words">LeetCode—30. Substring with Concatenation of All Words</a></li>
<li><a href="http://wuyunjie.top/2019/04/22/LeetCode-31-Next-Permutation/" target="_blank" rel="noopener" title="LeetCode--31. Next Permutation">LeetCode—31. Next Permutation</a></li>
<li><a href="http://wuyunjie.top/2019/04/23/LeetCode-32-Longest-Valid-Parentheses/" target="_blank" rel="noopener" title="LeetCode--32. Longest Valid Parentheses">LeetCode—32. Longest Valid Parentheses</a></li>
<li><a href="http://wuyunjie.top/2019/04/23/LeetCode-33-Search-in-Rotated-Sorted-Array/" target="_blank" rel="noopener" title="LeetCode--33. Search in Rotated Sorted Array">LeetCode—33. Search in Rotated Sorted Array</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书|2021阅读]--《围城》</title>
    <url>/2021/05/11/Reading_2021--Fortress_Besieged.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><code>这个时间落伍的计时机无意中包涵对人生的讽刺和感伤，深于一切语言、一切啼笑。</code><br><a id="more"></a></p>
</blockquote>
<h4 id="《月亮与六便士》"><a href="#《月亮与六便士》" class="headerlink" title="《月亮与六便士》"></a>《月亮与六便士》</h4><blockquote>
<p>阅读这本书的动机不大，只是最近失恋了，想多读读书提升自己，恰好这本书名声在外，没看书评和简介就开始读了。好巧不巧，这本书还真就包含了一部分爱情和梦想，跟预想的治愈心灵大相径庭，反而有种雪上加霜的感觉，这是天意吗/(ㄒoㄒ)/。</p>
<p>刚看开头枯燥难懂，讲的都是什么艺术家，什么艺术体系流派。咋一看真被唬住了，以为是一本介绍文艺复兴的纪实史，或者是针对开头介绍的人物的个人传记，会包含各种高深莫测的艺术赏析思想和术语，没想到到后面画风突变，又变成了一段爱恨情仇的小说。有人说这本书是讲追逐梦想的，也有人说这里面是包含了一种不正的爱情三观，只是被出版商的把戏炒成了畅销书。从我的角度来看，还是有收获的吧，这本书的故事并不轻松，甚至可以说有些沉重。结局也不好评判，对生活有不同态度的人会对结局有不同的看法吧。</p>
<p>首先从梦想的角度看吧，斯特里克兰依旧被塑造成为了一个性格怪异的传奇人物。尽管作者在文中提到:</p>
<blockquote>
<p><code>人类天生具有制造神话的特性，对于那些出类拔萃的人物，人们对发生在他们身上的奇闻逸事往往好奇心极强，编造出一个个传奇故事，然后对此深信不疑，达到近乎狂热的地步。这其实是浪漫主义对平庸生活的一种抗议。因此，一些传奇故事顺理成章地成为铸就不朽英雄的通行证。</code></p>
</blockquote>
<p>但实际上最后毛姆还是造就了一个与众不同的斯特里克兰，或许这样的大师本就与众不同，才能在芸芸众生之间鹤立鸡群。另一方面也或许正因为他们是大师/天才，业界传奇，所以他们的一切都被放大了，成为解释他们成功的理由。斯特里克兰四十多岁抛家弃子，放弃衣食无忧的生活走上了追逐艺术的道路，而且他很笃定，他不在意别人的看法，这是真的不在意，这是笃定地不断向前，不需要别人地认可，只是表达自己所想，活在自己自由的世界里。从生活环境的角度看，他是不幸的，大多数人都把梦想艺术看作酒足饭饱之后的精神满足，只有保证温饱后才能追求高层次的精神需求，这正式<code>马斯洛需求金字塔</code>，但斯特里克兰不一样，他似乎更看重自我实现上，当然这可能是我的片面理解。从这一点来说对主角很敬佩，但我也绝不大可能像主角一样放弃一切去逐梦，打破精神上的那层枷锁，实现自我。可能我是个大俗人吧。</p>
<p>如果看斯特里克兰的爱情，可以用一塌糊涂来形容吧。抛家弃子，拆散救命恩人的家庭，最后在孤岛上也留下苦命的妻女。可以说他似乎完全不在乎别人，他只在乎他自己还有他的画家梦，或者说是他对一种美，对一种精神上的追求，懵懵懂懂。但从他的绝情上看，确实描述得入木三分，对不爱的人那种绝情的言辞，真的让人很心痛，却又无懈可击，他这样的人活在自己想要的世界就已然足够了，别人的非议无关紧要，别人的生死哀愁痛苦也入不了他们的内心，可能连同情都没有，只有不屑一顾。从这方面来说，尽管敬佩他这样的处事态度，但这样的人却也是无论如何都喜欢不起来。</p>
<p>最后引用两段平常人的平庸爱情吧，感觉这是大多数人的人生：</p>
<blockquote>
<p>我能想象他们的生活，无灾无祸，日子过得踏实、体面，还有两个端庄、可爱的孩子，他们注定会弘扬良好的家风和地位。夫妻两个会在不知不觉中慢慢变老，看到一双儿女长大成人。到了适当的年龄他们的儿女便会结婚生子，漂亮的女儿将来会做个贤妻良母，生出健康活泼的孩子；而帅气的儿子也会成为英气逼人的男子汉，没准会成为一名军人。最后，这对夫妻开枝散叶后就会体面地隐退，子孙承欢膝下，过着充实、幸福的生活，到时寿终正寝，入土为安。</p>
</blockquote>
<hr>
<blockquote>
<p>爱情需要人们全神贯注，它使人忘掉自己去爱对方。最聪明的人虽然可能知道爱有尽头这道理，在实际中却不愿相信这一点。人们明知爱是虚幻，却还是为其放弃实实在在的东西，于他们而言，爱情胜过现实。爱情使一个人变得更强大，同时也使他变得更渺小。他们不再是自己。他们不再是人，而是成为一个物件、一个工具，要实现对于他们而言十分陌生的目的。</p>
</blockquote>
<hr>
<blockquote>
<p>“上帝的磨盘转得很慢，却也磨得很细。”<br>碰上这种情况一准会说：”魔鬼为达到目的总是会引用《圣经》。”</p>
</blockquote>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/The_Moon_and_Sixpence.jpg" alt="月亮与六便士"></p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>《最近怎么样?》</title>
    <url>/2021/04/12/how-are-things.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="密码" />
    <label for="hbePass">密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="c3e0de82f472701900a54ddf79f15a12a8eb35ba7261ef7c9443dcf5638698f0">1078a00ac6efef4a296ae3dbff2cdbb335c5d38c1443e44f749fa23b2d07f66b0625b6f6c3de706fb45603268858acc1d40aa0989add4f3f58583c81942779f2ed847b63fb8d535791837982cba872a080bc37df73cc34a6269a603231f803229967502b0e7f3c31078db1a47a2d39b8e95c4948905fccfba01a2666d31b0db50c2ef8810b556aabbfd7118164b581df1929e3161f6d8a169d12cff7310298894688a08098a0086d602523e41bc81135ab8f3f85bf9074bbb186c18c318197e2b9a7db7c2dc5f26ec0fc642f580cb8ef338827f4de3244a7356f95bd8938aa4a8fd2345bdbfd2f69be28c309fbfc8a336c86050e21c03fe95d25b8cd9887ef8b8c6765dfdd39c5c145304e6889119fbd11575bc23bd562a85c5d89e74d4209650941369db32d35ac3785b911860525def80324ee09e8e439bae24582e261ee974da7e4a00cc428dd190160139451f25fbc0a8cf15b98c7a021154742f338c1b47a6f2bd707046ca056f17bc09c2ffa7589bda127d542cc25b282d8a9cec41a47360f556f486383386b484ed6231ec64c38083e55000757b24292bf9f5ae5a501072ec762dd99e4ce41f118737b341d2a1a1629e1c0f99206f2fdd2f21c80b47c841aa91a6b600736a3181caebfcca9914df64a136aefba460be79546c02e066941a774cd1b83d99e027b60e137f915cbaaf47562a385f28995313b975c988078d42b0bf4a74fe7baf0c0fa1e7c0c345e8d635dfa207034927324a6c69159cf7ee277a2cca25ecf9065a5be8a157d80488e787eefa925766bcf6d2c08ee65f48e0feee0fe2425bdfdba8eb4f2149005781a0b8d2c7f0afa5f5bba0c32dd6e93aced9ed9714741337b1a5afb09b42cea450e412112a48662fd25b1dfdcf29d8c62faf56053236cf4f6828b24204aece7e63cddbf6af4cb4abff7b59d907b40281821822ad7a370b4e951877885fe74fd70e29d09f38caab63cde1492b2c7f82ca0fe5f931968eaf700250f71d6f33d14656037bcac118c72de6cc87d7e4eb13172cfa44ed7ead29d465f27e138879b711527f3deea2c62cb7c7f7e448b99b50decc84a88941b33a079b182d48a8d0ad98d074fe0dee9720ff0490b3c908a9d0ae6cd3bc738459c66d8dfa87df8f408c96426602f4758b552ca99d284f11da8a7b45f4b861d3559081a9a5d85af7dbd4b4c032e17a88ae33954ac94fe6186be488bbbe3a19fc649525180ffa5e638751b259ccd694e977061e1cf843f963dcd18330944e92bd1503f61e9a2c92f708f5429a4983068151c3ed534f38d5c5fe16f287734d32141ca934f3db6673acf2656faa67f9da0c5e44c2758ec8ee96948a3ebf267ae74160d4388a9ff922b6ff9bc84df7cbffebf00561c3bd21f80389e655c388c8fd8c130eae76e668c2ea9c10bcb5806566a5198232cc76184198b92f565107be7d83194121d00fa179be23ad539f5350d332d45de652ef6d45cb29c7eb8fb93edbcc72d569d01d6df481a69699ccb5d051d8b3e462486dd23f8bc8240286d1a640dca69c48b418a2e76719139829cfd9cbf726fa224f0effb176afc957ef54512556a111566e941ff862eabcca6ab436737fb4f77f8c28f40b942b9f16581be8f393543f8c89c5352bd4b0cc8c0e2f20d4bf6beeb2a9a957607a60c284aa6566f793424dd7969a81b6298363ce40be60eb772892eebe9271af77668c0b938f631dad869d8653e017bead558a0eb72f01cddbfffc7de2df5bb009c3bc83f65c3a05523198bb772838b46258cb1dafd26fc775435d702bb240371076a60a086eb362e6199d5580e79a7e51b91d56d76e5994a599d8717dab3dc0f721ae3061644ee6a3fe95eef3765f3b4440c3f7d9a6762bdab772eceb0048ad557027a12e24ab5f7d495b09ae4097a8780961845829ad781feb95fb2bbf671453c316c0e664a5d03b66a2fc1579724fe03127f7e4e4144a800a3c7f7549e5bafa3fb13034e6795dfbfc61db00f973effbc615ad3711839cd1dd83f496f0efea28d0dbd74b51dcf5bc061352fe1854be6346f6989836c82f9d2640cefd6153b92fe7347360e4f59e78f8cf9a8c84dbd344b4a174c74d3e4fb237d43721d5f41a907b7a18869f0b79f92b3d93f9373b55e06628f413101a12fdc1498c06f6217985d86947ecd8f96831b516bd9c8fb329713511fdb899f43d82de80495385ebc6a9a40ec4344239f6cf54d9ecf75315b751c559a33bad4bc2806e52825d239018f93bfe69daa8ecf1f78e90bbbcf15dff143a69f77f6fa2a1b90cd734b9644aaa08d01285548837049f64830895c1d8f14e1d794b93631480adce4aea0ac5415d6b3ee6255930f2e53c4c0d8edb1daf7480c6edf028cea27d39b78a7517cee0ec02876b8956be565a5acbccb0bacdfe052f6ca9f0619ac9c547b545846728e20d110e63d6ad147df21287cf8e24910a4c954c18e8e2a6027ee0eb86298a20e0094146d5ee4f45a5ca219f8d2e3e3ca5ee5775e3d29209b5664a16a43a44db3c82ddfae20654d9d0920a57196f9dc0d655b2c4f03975a26dcb7b8c0d0a34da0175bdce0e8992e27cec6b7fe9f91bfc7527b91f587bd85bdd2e917c1596286d05a18212155471be5d27b3bbf4d3bb987af8cd400c4764cbb80adb4406e79921fda76f85d91dd390f3dbd8d26a6005b432491e3eb3f5483226a0d7ee4308ab50dfcef3fe7207fd3d097b9e12abd9c573e7c04191ed0a1813083480d56fd6d80f8cc3f7cdc9c29dc442f7679e5947a56c9341f433c2fc9edc031fc93013e322c0d329c54e18250b569fa09ac496644e5e1f44d75f166e72fdcff6e745b27f39554aa1557899dfd380cb545aee7d514b6a5b324ae0c4143f2a1c619855eec7816b268f79c9d2f36348f90494f1b38bb9ffcb502a2a7ec96d5b2f7f6b961890ae3b49e8e7803f77515c34cfdeddb8f6c6590c3e972dc6dcc3a34db40c2274bfe25ca7911c30697a4f422a4d749f3adc24f55daeb39573f5b84310a3576dc4b704f9769dcb902024c41dd19063dd4f3bd17eced0a389bcbf761c5377fd597cbe3a90d4a684196eeb37db9574ced719a914d17588148adc45d746905fb8d49eb63416a1630f96b86a12da9ea34fda63e45cbb77231b6152e49c7b70f655824b62f17f2ae7ebd5dfeb6927ba96ca5cd5c9f453e758fb5c8f712dbb669e305b73f22d1de4f00746d7daec9b8faf49eb2581cd5f42020ccb1f4afce8c0a1eb1beec43e710edd4a71bbcd8c354499a4b73164910a869e07f27b72522fdd94bd6343cfec6089ac390f4f3f4ec4e4c474447b95cd1510f3f8783fcf0ff6468f098370e2084d1eed8de8cd23c6ff0d2f3956d08583738f965c92db0b144b3401c00cec2ac4fdbe2c12e4664ef4701e4428ce3cc4584ebf6e77bf2534da8dc705c983270c4d549ca278ad99cb916261b015b38f1368cadd1c8ac5708f89bd48fe855cca83cf256d19b98a4ad0febd7cee9174ae953c806a1ab638b1dc7e5e35e9959059d7b371433bc0e4f5bc7cc787a947caa78cad72157c4aa8f554a9cf95d5f32a9dc3bc89b56841959522fdb98a492f45fa91b28a96e60db8a08df5388d23712d878d7f1ca91869db70fec74d3aae50fc30ddf85d583bd2412bc3f0adce6f36d26015c35ff2237c7b8e5bea1e8a7f98d274919a3819e7fcda2d73143a5c9c7961036c88d62933b45294441bb4a910fc8ea7486b9d7b0f742222c5cf8b146ea49ea86a2e13a379129530de7f51648a42dcacbdd014faf2129bb7ec437cedeb13816e72d5509a823bdfcbcf3b2bda8ee571b63a4cdf6ba8673f5f89d7b55e476a49e7e23890e115f84f17fb1488415f03263e9d0e48122aeec7a8853d52971e01aecedb1ff4f0fa345abdad82f4e84fafa364961cc64217bf0b9ff8cd915a6447d9bc50f08ccc4ca583a177c0659089c3710bf634078664597bb804e4c064a8b6b94b917987b14ab404ba888867b6dce0a0151c905924800c5527687248ecac72f1a55665371deb15db9b25f0f2987d8bcb8067fed6dbef0dabcc78121c57c074dc99cdc64edad37f5322ace88f4b11af0a06869c9a655e045a089fa5aedf97f130023b895e7f7f19fa4d3f6aca638b93d45dbd53f2f4e180c9db045dd544e16909d5972dc11e70c59512a7f004c6f36921317cbd83144407c16e11dc1bcfe8de8aca600310921212a507ad47625acfc6e68614cfb4b7ddc4cdd374c2043f0bbb9a840489d2b32e930c2e43fadac3f645bf763a2721a4ae0c3d67fac73e309177de79bebb2ef2018d6fd11d687c501044e019065fbae3845e00b19d55709b7222fee7d38e1385b84ba77407ffe7b737c9c58e8d99069a586db0347807ae6668f1ff9e89ee706422d3c63280039e3fe6344ad79945dbe570d4e9adb668989fee7794da331f3ad8cad6945e8f88cac86ce1074d336eaff8ffa9c9e42cab20de5a7697673f0ad45fa234e5adc7c5b6892ae33bb8319b546497f174d5c642b549466465c9d37a531a8c0d97e9a2de8a55481d955f0c12d89c22e4ddb1a868ad6aadab9b091ffb0e911e60bef5b518225161ed55224829f83561ff1d64b7ffbbcdf01cc37ebdafd855f124be0a9ca9142640b68cf85f839bc7ffb0dd78a390cc24db86acb409d299a88116a85d382c17f6259d9df08a8c5b7a58ff15d8ea1fd4a7e4e92c893de6b85b932efbfbfe172d336f5282d9f9574421719c1fa3fa9baadbede97e254a64cb41e66cee7c5b2c6e1e8c32e63b42a68b449dba8d34feff2e872f6f79c9b82b007a0ca1b847a7ae26e18f395f1b7ca2055a7e6e76dc71f07c56ab1b1cfb01daf28c2a337cf45a149678e0241da1e409564e2da52d47bc7f9340edef7c04da56f115e543c03781a68d9e82e4b38dfd78d966a1d040e9a69c64976906cb418b820694290d755283852b33274db6032c0d1ed65886329ecf7df9017dd96a8f4f6ed23f1b9872824567ea70f006874353a0ddfb6800049700ea074369722b51e4b55a3a6e0a6c32e0d41a134dee6f7539affa0e5fc4885546e3d2e42c50b40261585af58aceb490339fb16fd014dbb7d80e4f3bf83d3049ead29681521cf0cf2405186065e70f9dd5ae28bd0127bbd3305c86d45a57d18eb824405f266d6b81b3518deae9a4572d3c3fa68b592776216ad2efc2851cdc5ddf097cdb370116a3c443eeb195511a2ffb2900fa031f7de708d2b54b8eda2333beed130c5087234072bd9a095d50d6527125e9fcc283c3ee5682f53ce527ef597894bed7b5fdedcfa3f57ba54904203b1cc01fc8295514bba8f75f41bfdc54d0d785615321d4e18e9e5176e154ebdd4db1efd13239488cacd3988d7fbe0367b23661743c91d6299af62357d55d1ab141d3d3a662a1d55abc95c7bd6ab3221168dadc24a4bf1f5e010d22ca177f580a13909e563952d9e8a1eb5e01341aef03e327aa17c9263ab1b04684da2acd85815444fefd5d01ac1b23180c86b35c8b3e99e9c350f1780ea00c431362c9f2342cb75baf63855c6167083f4474d3bf09d526bf419f919790d301ece038dfefcf76c5769a25c3d81e81844771580cb8afacbe876f5bfce786c3ef5cc654571b1d32323e04aebccf441a2faee6e2d7475f15ce954bf1740f708ab9cf231dfab61194bf37f22a2c62dd9555f9791ba3227ce3809123eb28e9fb49e391e548a069f7b5934e060c1f08339003ad9e26c53d03d308eea521adeb2ad965a713a2fc57b2bdcacdc92dd5a0b6c874bd4b9443edaa4d7a00efb8a1fbee089fe9c5a41f62e105b04b3835c200348a0dc4ddebb2f0e599ca3e39446484d3c55cfa41081200c32ca76de9117c806b470e30279603ce3f2df0aa01c7377ec9e2877f6e9737802eb446883a2ecf914264fcbbbee20cf2dbd20a9ab02ced73f364688b8a069f2b1dc0e09ecdf1f85b1ccab00039f38d65070322525e60e470fbdc37c222b24a128f61ff8f08419e772cc02ce4cd94717bc0ccc478d7b8fcb2ed4b4a79e387d1a821970919725cb53df400863f6b5a2aa9a6c1850f0854d96e4508cd38b897ed83e7643a85e836ba6db6cafecd18ddc85370b88905b86a40e3dd24ae6c79795634c8c45fc1309b0ac95dc71f68af0719e06eb2f0ec1aa3953061b2053cb492439752733e37c1c0fb435b97266748cdfede8c6eb7eaf8444aa7c6d1f912a26605d82c955e299faa0b8367fada1306768cd8c282350c1f959dbf9fc54be0ab29b5dbaa157cace6540d852d87f0b4fc98d9e277cf9aadcd227e114a1462169e29f6227f24292990ab57199560dd67f53f15d50506562fa712799e7c968127c17c6cc4a12f5a9ea626f2ea7fb10c7178da530227ff568609294618679774fa7335fab469744f5a310f8cc2e3878b8b4fd4946546e873193ad34af2e9e1d8ecef26b5e237fdb587e063e9f4f7fa2d379420621ca7fe7eb9e0cb52fab7eb77b995b2487d640e246d46575356cbd11440be76b41a2ad24da903fd546559f62ff3d3a86ce08ec8449abc71d83f242dc41e26783094a9e773adcba9a636f1aa972253921ff4483b5cef47ad51ac70947acae3fd24bf3098298f21cef34a0fb59c09f4644e9e3499041f97b4c7a0c50df42e6c3d308767bc0dad44eb5e7a6d7b266e75f8e64998dcb7c0ac4613cd40bec60c110501cc34027c6317f67ade6f7e71e8d4a333e9b93ac30c5ffdf61646f41f3a374bd022f0206066e623bdf89fb055e7e9859ca7f41f7e7e4b5b401f8d2771b9f8197b91d945958e63b936b098794a5c2326c7bca7909ca124f21870e4e196b41da30aaa0cd620c679ae7e9a3f8b2da4cfc287dde3812dd8898a4b47b8e58fb3475b7242e4e80e7d58fb15d48771a36aed43d20c6d8642ffb1a89b96243d289c0e45d6a188ff0938f8f15bc0fcdd7486a585da8108357e66fd23b54c1cc1a2d200f0a1749e1eabf03afc9865f2987a8a916d1bb682a064842061cd817134714b65677ef020f21baa0b32365efc6a9ae1597f801263c64a462560a7e6661c69a3ed3661770ed187f7ca03ad03b84eba364763139d2773e02533ae65eca203a8f4c853edd04c98a927f170712bfe561694c618e1be31a0bc592d1d63f013f8a0f5a075f74856b23c28d53d3233b878332a5de9d55e33c6c10f0aa74ade2bca1cb9ec38ea8449bd0d545cedaa8054a38cf1b221f27c369e70d2737454b6076cb4e3e5903371f3a195a77990caf71b975be32f1aa4a8fdd4e4941557ed5aac2e6206d866fe4ce6efd3e79f3b33485898a907034f7dbfa6070ed96e5d5d4728f5279e63d6bbeb5995eeb57fe76f2bb5307195c7cbe2e6ba3af21d72179eee566931d1283b823f19e6f756b999858031d4a7d4e98bb9585886b07a52dd9b0b81e91546a925fa4d1cbef8696f7ea3e4d03be4a2fd7848380a4c57c863161772544607d8930914cd7df5df1b0db3913641f520ceee90d47fe60a1026ff7237a246bd93e9adc10b481aefa0f118eee012c1434ea6cd2b186fb7011b20a9fe93a33630bc002398c960cea9bf767d2be9fcc6c336210478850cc8894e988d24f70a944c31a601e58164dbc951c892bd572b10acf7c8fdbf2b940d473356b83a6baa2bd013d4a0c4cfd4ef4488ecaab7ee106ffcec74bc91493b2a9d20589d7c1ef51f3e2c30e04b1efca21a4e35953a0a6932068db9a167e072d092490c624e95871a21b1b0c948ffce51228d4198c54029313493063afdc24fa7f32232de91dc95cb5182f48be4066f27de4911371def66f7af3576f088131880541dee441c581c801b949b0dfdfa6d9f50a4e3a7acbc1d37ad5eea9adefc11a98e10c695a7fa854a443ec5d894473027b6dede3569efdbba637e2aca5ca8900891b42e32549dd8f31e4f3d07dea323ffe9726ccd3c87833759935a06437dfe278b54e4dd9d352cb3cd68ee7c7a947178dfde434d36be4aa58231503b6e19682d0999d0a420211efb25b9b318be1e0952285675e059d6b8e49dc6b87ff820c6f445b44ba3110015e9c5eedab9661fd58b0718df3aa74be04af0df185afe7544fc8050cf24dea1e5977ef21051897a9b5b1415c4b0dd048b6f60dd770061b75d8b20938632ca3625c4c7a3fc1e51660e6d5067197d7a10a325ec493c22ee221020160332e91d591f339bf81e15b8fc8f3a3c3c28e11ab01f73e07b6a2587be97b821af5ed96169e6b6a7aa6f96afea8de50e40b4cd677bd3ffc5bd6074dd88a1481e5f19f236af4db45b9b65c0fee88ecb3d30f70a7b4dff9a51704149f1ee5ac5271a28029535bcd9740c23e34e385ecd48195abb403ffc483d78fe2412ea2265737cb4bdf210d0afcea047b80054ab14dfccc988bd5bde9d843b3bbfd9d39ea3d7549e4939e6114deb4d537d075a27a0b24615d301d280986500c86f1b464c5ecdc35f875bd01d15c3f04583b75ba330f0b79d2c04856fd0809fe3b9b798a86af43a8962622b69f49a9b59a5f29ac4c61f6eb57597880f7950f83aa8111d4e96fab1da2a7f2ab45a5d991d32ba400e220bbbdb15fec06eb2d127b40f0c4ffb1a1c08ab45dddbd2f5a3b6450dcfcb05d4774b2bda7736edb27040bc0fcba72d060b78f25e02ee3f7ad18b9d90af0354137acde27f638f08e04e5b8243ba38dc7bc800a3e349bb6ac4eac5c37d0b72e019ba903bbd3c55573b660107347d58814b907e857ffad2daf3d0d6f10ec2efaffbb81a959fd14d2d8adf40e752c84a32f5915581fce10b2b3bcee2d47a4d140cb955036bf59967caa4d4dceec38a853e95b65a126ecb72c4d65d8fda71980996c42c9caf9bb6029b6499ff63eaedcd602769a3c26e96d9dbe8502594ff8c733a2ada2a5b4452ab4d2a169c9fcd9b402f393639ecc2b1631eac150e69a10e218b4207d0713c6f196f42834252e42f9ce8297a99ed0397de1e7e500b4e49d16b808054b427c5db46706ffb2c172af0aea52b8829f25d240ede1744b8f75ad736194d53af0a7f78a573a873b2f6bfe117e100cd17d5ef061ac6f2892e3669d50e6141d2cdae03f7bce65a9c8252c5c5f05684c37d2d4637d66547951b0ce455f9bf6b1b9f050b96785a3796005ee6eb8601a0621d3be9bb9f50291b5cb7b3d3689d56d4f7e41437e2b1d254b7cc8b7524fd77f8d10deaed39d1d208e5a6eb1f3efad95f00096581a55e3c41a87085bddd22df69082cc52606b1bb7c1c80aaf1d04773fa14321e8d6e3f9e892dc57095003601aa6fae149ed3851d3cba44b526a465cf8f9a24a5a8b91f0057a450085426e9dd55e6d9887eba0f91dc477368b229a31166b76d1f5a8dc48a632f71aaa44f2a2b5e007888428bbdf6c50ed0ac00659d41930cc3097068b0429f38951ef8445a44d3dc34b1ecb2aa09a01fad0d7873a9ebd69ef8f336257e15647226e74e043e8bcb44fe6c1388a5e94fa86af7f6665728bdd16d6d9e7f31a6de61b3a2edd547a3d237116f72b1c84ffbe888659ba9adb23f362275d11d5719f5c32c95e2d0bcf02ffd3743b50d91ee87314001870f9ffaee56fc12ee582e6337eaa1edc35ff221e4289fb3d15675b9529064757a7a2b14d3d29940af76c03c94cf2b4ead1415c10863e2a896cdbfd33498fa3e6016672ad85a1b81b9b381013bccfa140c7bb5c5b709a2e78d2c20c471c8a9c22d9ae8625316d3d37b3b4e93057ae694f4d5dd018d21842a25a00e1abb9f65988f4af6dc3f0883f4237ccf8a53d4d83c3ccf9ad89c7b61f4a74303d0e1935981ff9d1adb3df35e30e1e40b425a64f00ec026e10d54e56dbac00bd6dc0f9be0beaf9b3aeb6d27d9af4fa4d3dd4ae6d7604b3d24d7fb534aee29f4d724840057ce2a3834b87e3dbd4e77f55fb7210ab6023a4d2bf88922cf051f8b291c3f7210a6fdaefc45f73e22df110747fd2ac2ae596594dc99db83563a2b9261d2b03238ded5b1b5e764312532d774a831d787758c5ae446ccbf6753769f43e3d1a4c9a4889a1e84c2e6ca19275a4270f52625af7e03120dbf1c5da62e4da5845660e08767716cc4ef906f8862fb2aa5ac613ce66ca1ba7a6ea9937b7861dbc4fa817eb72644318e89cef6d27b2b976138e0c2df6b3759bba4340ba1c55df6caac13af72b926b7f317ccbe0289dd11104487bc96c9821341630a29d0034707626517afbc221eeaa0fd2c16a4b92270bebe61f65cbb0ed4cbb2b1d8c1e904cd93cb27d6c540627580474a4528d76f09bb6bdfacccd976288ba3268ca6bc7574fe45939b83bdba9a5a1b0292f2aa959a10e5be5160726d7e8721e82162cee431225027ba9b5135d661e838b5302f39ab6d16238f4881523bc6bd4600e76d246b97d6f34d8a72cdbe6b97407dcf2b21139423ecaa0e71562e5231ca01c2e80cd7339b43c1ed33d36a5bf5180ceeb61bb930eba21afb92298309590ede465f8d1d462321e23a1b8f24b65d5c9fdaebb64d5697e48d61b03f25492aeccbf5c43b3eb51eebd56b602c6951d0045d0092786255bffdee0342ed5df08c34d3e2f19b5393038b1f76bf71249eb51560f9b694f3797858e0847ad62df4e0dc7de811a09e10a441a7a5d4eec206bc7721006c77f18eb69f918823bcde323ca89e743cfa4aea0fd7b5fde8cd44f6256b656be52659f11d67ecc459be85017c46b69f0bdcdc2dfa618743c63dbf0c25286e4bf9524913064e48a0fed16bcb4c8e648f2ba0f1cf198d00b44d8f96e57b5846f55262384984984946c4fbd85c8738dea5292fa45615f6792a0468a6b17b1d6a2009c0bec6d1a64c3a7032fe8ef8ca95bb1a047b7cdb1fcc659e61c56a729f1ece8f42262fa596dad005ebca7485e80036a2e047eeed2f2da53b2021a6ad14104da89c60921bc093c8d90cad34b9283393bdf50f994daa71082925cb0773f5c0e36aa8c73fad8b99f8298dcf72721dbe59ae326a3aca1f40585f81f143d999a56dbc87f0e5c52347fba98127e637bdcdee3b037044f2ed901c16f2186989a786960750b2ef351ab05ea39cd46d686c474bada3bb964bcaa2ae406552d9f0bb02316e149a6f1f90006db6db341c9b93193129503d9413d0fb9607101e3abd550b3119603de247c8e8fa13e55c1edcd2c0adbb976440d2bcbc861fca200bd295021fe720ca79c666f9980a21a14cfce37f5e7e328453e98eb22980b60219cb5ee38ec933d9990441262616143039fe1c76d9d0c2461bc79d3efabfa1d049f8e5e8982a4d4afbf1d302af95c312ed98e6c2f39f6be9cd94f9399102d5816b16ee3275541a7707b61ed3f25dea1dec24e7a683254845bc9d1c1c07d34ceeb34942b101a039432a4e0e6cdfe7fc3eee427e8a9a46a43901d09972ce1dc4a72f405076cd42d98a0c912b7fde24c35164bc4a7a148f83da495dd1daf0c8c55a66562f78fe6cffee0a0fc783e9c8fd030b30e6a8870a67d302a743a46918bfa50bec72eb36bd35c495156b1274142f928c99c2268164e02525667f4a5d9a360f6b00e52fee28127ab02590ea7bbe1bf7f92fb3a421f8c6de4564d59aec4ced8be32b0b3f8907f46a946d7556802a18bbbbd6f0699893a2c67b464cb39356c503c43dc8ce3daec9684213a02d620f0b59fa1994c238190186261535d0f6221a76752f9c3b2aea9b5a88ae587286c0551fa5a40173d0ab90aa60cc021dbce2a83bfeb3ed1b106077b1a9c2139c4b0d939d373bb63b233fece3fc2c7283301323ad0d3799dd72cb72391e6cd61ea7545f46045de4cdfca6bec8f36b3a2cdaa2e0a714b616341e85c5db01694e98a231a4a9cffdae3e20cb4bd54f0f2d9ef06a137af7ebd9ad4a9d834bb7b83f0dd7513cbdaba7ce946374be3c3cf276c4e767d931a97fd50f8e368ce2221f960b2b74b9a181bafdb2c51a2fe1474ecec24e59c93ac4e64ddd5c609cb38cf185381fde5285234d92e5cb65425bc413f0ef9a37f7135799dc49c8f094e82983676700636a2ba50e047ee012228ed7b049813c78f98ec0ebefda1d5502458c815571ecb34210c62fa8bdf1edb6ed2970215e60b0a80da1f5733ca3629242b11091d82dd2f52dfeb4fdf094fc4a8c9d1fa482e313542e3fd173e5cac052604058e8844d71927d4cd8a408337c2328fe47478e81af38fa393ab0c3597288e2bdb31e5f415d14da02d1d1fa5dbf3cad2644791f1ed8d29153a6f03e07cfa4487deb785afc596c05bffe037e2c66a4f144ceb8b44b1d2cc7b6775b39e420722420a4f79459c2bf9d4cfec39106520db04a161a367799681ef3362c4a90ab6c55f65571abc5507ef6ed594680a07841c54023bc74c40427476930552d000dbb7647bb615daa2eae5e29cb99f503db8b3b38b648593113e753610347671553075e126b19dc29b20005e4660c63bba9c717cbd9d7eeb6cb19e22a6e8de29b07af8b6a764449ea390d375a198e1587ccbfbf5a465bb2df058d095f1d380a2300771636c9b327ab0a695067ab45bf35bc5af4fb52ad3d4afa4d24555cfe1eca2dc1f837558ff66f2ef4a3110e661013f6f27f0330e6cacc281a4d9ce873f0b63883144bec75f4be61da6e017c6cb93fe66f629acd4fd2f8921541faba05e83935e2880d5f7126a2601c2010330f68fe75e5bf31177aaf5e27b10c00809a08606f0568e28d46e047ef68f7c469d4b1ccd0899a3de23d6bab94505fac91d18955357cfaba16925f4df78c05ff5838b47372be294c4ff146923b71d5335aa4ab7b893f303a233a2137196889e61882501975183143a8bfd7e90ff327365cfa87aeef37fb630600a21398000471f7040c64700a9bcdac4951485fb7b36f5a32621cf6d58b58854d9ad430ae99b1ac1119f1130141327b74bb0dc7481085a474568715d3f2bf3a8968245ea79ef2a2d42009127c0189b268461b302af9b9a930aa5f7364fc6c36a43527c12a0bb6a8bc6bb7441ba0b7e68592b57d353bd99c34ab92bd2c0befa83e7d5f81921c81a93087f7df003b290cfbe23393416705a0b3db6eee9507ec8f3c2e378a724f49ff4ff374958827daffdc8e0f576d0555ec2fc4d74bba3ac5d97747ea771c8e882b08aeeb71a0d88dbb4a48332acef25077c58bea059b987324c18d0e7362fbfb476400c56d5b4c51b4d8890ac8a7dfcb7f6710d39b82a236e3c37a04740f98c8355537b22c276bab7ba9dc4342a2807ed4714017504f58fd86aa5083258aa5269304f780be3f9e004b4e83d69d91120ef09ea216654ecb3c29b5b1d4dc219d9394fad27a749303f4f2aadf2638f47b8bab62abcfd459c6ce89ebcbbbf4cb4f56b54bc66b615494f20346ee0f3e91920b0f6fa377fdbd166b4f0319dbc3e8f2b6ca3032cb5f5494c9713d93f398bd1467043c62debe0ad6e17fe2ee738d2c147d4e4a0d8bd9f19ba9856397bf79ed9fcdaba81d66cfc10bf23f718c07f541540861d317c5816fddcb14415ed256c32af746dbcff1f44706d80fad4eb1b0b88d5d5f827bd6af4ae34df0d513bc538aef9db3889c0ad4aac6dd44f5c3806377772f7c40ecb4ecc2e719e1f6e0f4b0f1c500f51f5c0b41c4672e16875490cb3d53e779c8c2651d177f0e620e7d2727c24e3fe5fa873398eae889a2970984ae6426af7c187d90731ede601af1999560eca2edc70a58200b6c16d6686ddd910867b01182431a6ad5e82cdc7a216dce5d8d6b54a3d73ede582906a2d709fbc9652eb5fd3481e07e221f55f8b3b37f592418839f20e8b27c5ddb6e3941df108167f9416938b3e72dddc5c3f444d0feddd2538365ea3646da8a7b67d918e1041f6b93e85cfa4f8a2c4ae4cd5d663e04f447b4e792e6ced5f1f2d0fed39c5c924203b221dcf357816a846ee8a376abfd1d68f9d5071f11d93fa36bbd29f73368cbff07c084fec17bf102c966ce8efafa013be034be08b8bcb49c94cc7119b3c9debfae228011ee1c23c1e434243b8ae2141703c4931798caa524c89edd12dcd349eecbebef80e748852c9de09e778e45b70969054179db8313575478faa0e862f584aeed9fb3981ede8cfe4f33fa1e523d08da0d215210331275fad00598c7c33ee77fb7a5706ec7911de5ca4583790bee1840036294e70ea843fc9b79076ac8ca5ba1443dd87c35deaf7d1571b2d35249b4b8b73c9dff1f80159df7febe5461fbb16663bae8ad2a1d4dfeab137c8791383fb63424af0084d02f5d1b3b1e7f2fc66dad1d9e2161bf9ebbe5422d2c4876bda0c214249d448e5f4b5bd5976b53813b6a2ce9613bcc25d32e3f1d5bba118cca9b0f9165a6643214f91913d91d78105e9b4e3a7b9b435bbd4e06f393248ec08d595907ea3a6f2de5e8841d96a2a60829bb720efbf46223630d13418c9d16a685c9d52b1a70e41052e10f5445ce48c8a4aef4a5893dc2e0b9a684bb6647896e4a73aec1b56e9edeee85ef1418495c9f2a5ebbcc00d02cf7334ef134d4645287077495227cfb2945a014f5bc4e938f0dbe1c0e74305d47cc81b413679ad72ce4296e35c527c90c4a7fe317cd17625107047c38e2abff5cb1be45839727ff9e6a0195b0b90859005b2644135db4f25cc2112c4a238f4352c2377356dcb5fc454f3832a960d7afbf0251959a7e1cb4f01aec5d90dc69faecb355cbf41acf674f1757b331c0e31e48ee417ab84057e7bbff59b1782b3e7c211cbe97312779fa1d25a4879566eb26a1e7e97f08e29d050347ae05ac485f1ccb5dde688eb1b075baa466f57cd3bd4ffa73bbec0d1a50d8e3d37281e56dd57762a836a57e82faf5bbe38b10e6b1d7ee076291858eefdf3889dbf55267e35165084afccbd09e0c9ac290b72b0fbbf27a40b59e58660509f8077f33f7fc1c5603e31cca3b98dd7064cb465bebf92bbb963ac5feb790ca43255d8d5910d6f7cfe3aa92f9eaf007deac95cd2cd9ae5c2f16ae0abcbc6f1e11347a25446b9ff63639f798c62c76cd23f627f8b010a7df77a866c20f1cfe77a0ec97bcf840a9d447682e50de65b9d438d6b69abeddedbc5a0be7cf56a8d51f9618ba0ffc9bbf9cee8376b1c33bb0b83543525e1bc68547d32327e97474606353a8d6fd4b1451665c04e6416d5d5646392b463bf24492c37fe919c9d583e12309d5c198e0c69650d39078ec209c372952a925033ef556ba8a60485b83e21cff450a5dfcef737e5118e748371be3b9003ffe4cc56b9ba9f0e898536b11c417e45a41b5066f63d6c1b31899e0985c5b85c6566335f8adf194808dbb1abdef866b6087345f81fc0b6d41b45ce45d724ac0e8d3892ae9dc5283d157ecd897a28b14041939da671f1d2abbf74ab2e4283fe95d1c44d3fb51425288c32140dea459f8225aaf435c1e86b23cb13a4c8f5ace35566804bf90c02cfe2ff530cfdb84b670178d9be867af2986175ba120ee58fde6146901dbb0e20b1372d9ee16028d918a0ca25c51fe41b7894a1d2f96a267a0c90ac21970a59b85c17a2bcbcbc230cd2406ea91e3d0657ffb18df1e20503f40e24938f9e9a870acfd1925895aaa6cf8d8fc82b9f5a346ba2d8b8187b5b950a24c5fbd0eba1eac20bc2279ac8994b024e5f7b330d9b7311b9bcde8374001a9fe311bb5e1d335cd8ffab613ff20ad262c369ebfdd48caf7754d11b2aaa8087acdd597f5ac731d7deaa447214538f622504bc54692c75a5ecfd2763c7e40caf551a777161b31aeb43e1b93d125ace81c4cbc40c6e0fa8a6377d9993ca1092dca15ad6c8a30f6324e26ea6cee5506a60e9b9ed8fd1765f4123302f21be605ae5138c96a89b2c61ea31983c4a7b01945108e647cc0b1f43142b09adcd6e9599289434b73d554316d91286c72107578543e6f74351f97fdd2103b2611e1477d442fc7368a046f52a519285e2796011ecd84a433e4eaab147df1843e30df20ce5f77cd04349b4b6d3946e3f8a7465fff1965ddaa8fb07752edebaaeb8e1e4605bdbcf9665def535fdd5ade1a0261d144052694c411f7e208f6383a511d30f821849ca0a9a23c88309fa2576093d161fa245dc074db5f29ff9c62a9754e71e8caeeae56a5bff4e12328b46bea9d59061e2de18979f71562d2d8f104658bf3ddc3ff819a869d2a42eadf2bd25a1e71a6c206c3c30363df2775c38af105267a952c62993cc8760f95fccff710f2c3fb172817e735f8c00da8fa5cf872ca5a7a7a34a879a14b1839fdaf03f801a8c40d18e10993eecfca6e055fe1306db117423d24c1cc421424eac59332a73ebcdb25c72cd77975fa8c060c676fa50f0fdd0503473efb4af253160e1fc7a12e12870b3b1e1ef15137ff0bf6708f84df4c62aec02b238d69d9c6080b2c4d9d6da9c4de40c58df842c86cf8b0c1a42349d90545d504ca5cfe2a4832c37d800efe597a66d8579bbbbd9f83b8b16d8c56b826b88323bcb3956c059d2d1962e63cb522fa6005628fc41c43277aae38fe02df53c22b6ef38515105523d54804ea1580f5287d18d1dc146dc40c356fdaae651790f340762cc3c0dbe5528e63c4368544cac8f0a77ec75e092f87d54b36a509237a8b7764f7d7462e725c9fbc2342984132d013cd72dc815ca53b40535669d9e3e50d5c9bdfb1ec474bd32c0379a69c288e4e214f74aa73411220974da79625b51d782df8c2e38b44cf042c443870eece38e4b8ec976b98cf51b95103e324dec09130c473cecff1783901dc454676a73ef332f5ab1b49f2a087035307824b09cac7dc535725e7ae5211cf9e5ae02441290f78606761ae8893d55b3f0d17d0a6a779788476e803c63420fbe974ed715c3bac50a00204708cfc971f27ca7c7969560685e894423295feafdba82597feb990509534dd995fa8cfff2ebb28570d95ddc454cfd37a92be83e467c93c02a8ba7a5b8c08fdfff9d743758678b9fbebc5f8954cf532342a326bd906bc522fb25b40d5ea761cf09fe2bfd1a17df7ff6996a396c298487e15d93c5f6c2304a293ebf83d2f5a5e3cb45aee093e61160d00cd8aa7107f8bbe0ff716956d1c301c7b86f9b84388445755c9620e5b07aff164092dbf9c6926cf9e2bde8af51e9826d1057f6c28dc6297b664a969925245c3009b5149a976bbdd0ef1b69a745d8af7cf0790ea6f1f7e2c458ba5393f0a7a2330fc007b9bbca8adc37efa9bc02153311d0b7c9347644c34b113bbd25a9740440707a8e607dd43bc8a7c501f40053374a62d1e35cc68e4ef4a6f51ff6530f53fea79ed828fc96af3b0668cf87ed9151acb9d7b7170d59ae12ba774888e3493ec6a39615a4db3000332dc564bea904ed963a976a8ffc7acf2cb49d9882a424c283d0f5e3069e511ccee27847d722272f0cf686e645f0fe931a6cba505dacd8d96fc47caafcc177f4760828cb2c46dd7c1bb4c409d77501d6c8ce8803008aac484f5359f936c204e7df7be9fc44af493bf0d2f449bd1316191a2fd31a3db608d788b1367fce828e5e64cc8306347b8cee456ced9b0b5568e81b6d4b8349e577b7435ddb78ef3dcb72b553c6e56cfa39c4dc87456c90a4335eaea10e0bb2fbd323ea2d09527af18dd64e6ced2fb5f2d77c7c57fb244f9602ab103023bae33d8e8f6a5e8f5d347de67722be0825ec7156777f6c73db43b0f3e43b4e814ad8c82cd0346581f01d7a6434f4edb204e820ebab56dcc439a6a33a9a19861ca4f885d2f4c0463b6d69bd186e6bf1317b2d61d013b5392099a0937239fc3991564642503907436ca32c430d69a93cb86a38dd071e3592ff55dd6d5d302265be44debac01debefc2ccd569957d80fa0b0864ccb2a29841d1db981f54d527fdd64442facf39e98b276c380aa6f65048fd1aca935233aed0587c37523e706880922bd93dbfa3c94ebae91ad2d8fcd86bd68fe8b70bff2f71d5ddcaaee5f0a5ff6d911edae92a76cb2a7022ec9c8246346c46ccbe63e819d1b4a4bbff8d9ce997e32286a9a559362c5acc323262c6896a0f25509610f0dd8975b2c00ea389362ebda8a09bca7dd0aeca411a21311146399d7a72fd97b055beaaea3bc68863062dd7e4ae405ba62c4b4f892066f67a9a1a1997dfdc5ca6b9dcc8d2fa774522c40d3cfe90478c998813f598c1cf6f905e95bb9f07c032f224441b361af4ae1670a88b82d10dcc7074df1736cc43dff4575a0cf0c0bcfcf2fdd424343a6431a6b94212c595367b7bbdb3acd13d9de2aa75aa06baab8581b45d7d6418677977a54c998c782080a15cd59c97585494187121a0d35c2d4fdc78f882a2e5bd0d17d9c9d9f12a4c08c1e7018b274717e06833c68cd682a7b1e4576e359dedb3be4cff35a6936ef867db0c4f9332204d0c25e92088d2e2e986127f183f39d112ec541441c4b84db5baf9b19a8582754a3053667b73d2274dddefae84074a3229df5fcfb78ace82f6cf19991b5b37a8f5f0ef117fa4e08e2cae823ca2363f5434cdf285eb69db4c8656beffc75e8c9ddd2ed393dc1b0e7236cf36a2bf650fc89f8da7ab5c4933eba784d3ef0e9b7eaa54bcc91e61a5d6451cb83ba5fead0900d97b8a7b58d16edab50836b665203efe5473d7e99d54489c7d772e006efdb0c0e19d813905ac2b646ff3d52557c2cc2f772f415e8875742a01ecbaca1a6a497550bd7c9235d6d71ac2a773365896e5f4a7c40b5e03c8f28a4708eb56068f0deaad26dac6d4004d99e3fb62215f4d604b729e2bd7f7c81223786da0e93f37bc9b551e90df5b0fe352bff7a63747f28fbc1096b697ad53f46fde1ef80ddb7cdfe98326303780a45150819d2f7e9e5c8b48f45cd45cde02dc2c6d3a8cc93bbd14727d7b671c2ed6d8618df6051906c3c28190095de2e42cc4f7a26bf235892dcfdee663765a342911091706690ead81b03dff66633ab37ca5fb696ab4aba8cc9ae0ae74a5b03b69a2672a97fbc249d7b03151d919907b4056592c7a83bff6559ebe0105ea6f3cee9ac6bc32dae56d5b93311abd829efae71234749b0e122c7432cf3c2468ba9bd986e67f9e364e4de87072f2a251753a7c2d7eea2a7362ba94a8f157d563dfa3af710aa40c350f4d925db2a20bb5a26fe645f1d4570efb0137d23d09d38a9b1c9735647c83f9c27a804414fef684e9dcf07ef072a7bed272ea43642708c671e5adc5d93b12424b0ca5741733199cc93e486729cc70821d9952a905ad718d95177144494cdb08ff66e9231bad3baedeb98b87ced2863efeff031accbd023256a14e149e4ac3728883c3f5545c9416182f780a1ee120b09e8c9f7636ae84a024ecc55f1308d88c2b39d2306f2f5f491e51b529d58c3986bd20942ec82023b7b0c1744d6aa0c76abf416ef7f4e12f3dd6a18be843f3213b82dc27339557c249e1b4011dd9e69297a3773c97f5efd863bcfb77af3c109d886917fff58530a1b8cf252f05a2e315439356c51d445252922c052926e8c36fc732a26ff658c19ad650f370a67c748bb941842211e5225e81e828202b8361288106c3e08e685c77434118793f32827e58d249eec073980977fbf1828e6dfa6c34f460f998e598beb89554a9a24e0235fee11738c5fc2c220b9f4f84e1f7c117a7cd7b4657cd9facbdc2a48c021ea8d0df865a6344afb6ad3fa398231d2847b38a9385ca3de173694d35136eda81344f4826668bea53e79e22f920d3483ece459a88f0df41dba7bc23d19b71b7f9eb9c434532ea535b465b0e4a4fe855bf387d7938afe2826b71245807104142919be1c35f0b9fef113cee5c49b6fd15ac4a0b5b35787099473b0e2d628873082aac1fea5be76219bcff44dcbb5328e0f8bd3d7f83c9caf0117f9309b556440be726fc6038aa05be242d52a6809c523db68b8f5977dc056593b94d0b3662741f677f02c41e9c5ad63ed0102eee996a507a17b8597773c0f1afcee19a1eff5cf233552f14ff1746878f181027bd5841f3b5fb899708fbcd9ef72f5cf42032fb5f4f1501a071205d93960c33d892194d4aab813d526181b47961cf093d0cebe8fe67ffb7e489b302873b9cd26b7685293875080314a40dee12df383e49151aef3017373f2f71d74caa9b64b71bb0cbe61de51899a377231f9f435a03eb0b68fca35cabd2f830bc60440063ec120a0be6302e1cfdbe3190053453b712a8b2d1dfab9ed2bc2e515c47ee484f8f9cdd8e9cfd7e8417d87e1e68dd8d09816841cfbafdb003323dbf2b0721af4e2d819f1587f682d581cb2a1ddbd2038ed1cc5f3a6b54c97de497e89d3a45052da71ea129c4928474463ac480273efb0816d26dad5c698dc6ba6ff1e1f7ea1248fda3f748218bbbbf8ffb77f045ab332bf69aee2d6fcac6a591b4c8895272bee7fdb37da4406658d9315ee0e5439f840aafc15547cd68b58be561bab7d241d210edeae2b30b9ccd6fbd6009cd4b3cc2587f4658b14623da7fa924580de3b7433d4f3b7b249b2f69800d9cf6b464b92ff0d3cd24e597a1f1e3f89124a49e4d2c4df60f1075b9fe49bca413e472c1dfc78716e9e31f1054c19f3b39b8c0e4c30370238fc35304d427b1c554791d55dd568ce940c7d2cab5c85f87c09df7c95198862e34637e30abb99f31cc1ae214b40850a648fda35f2ccfec8049d8856c6362941203a2f2f618c10c46b37401f1f864276de463e58e99d8c7c732528a400f240e7fd9a73fe84050c149d1701dbc003925cd1c33cd5fc701df3f46f0205bb3a4a641a3089dc832271629081a9ee58a9efe168a6994364a2c664bde0a423eb1df281eaa0f3ea26773709d04d148c45ba5064d1bdeff1e82eed64501fec4e0c35c4cbc8faaa8dd7af4ac5eb9e67477cce691d33c77847a693a378de7934195137b0c5283750429fffe159d655fe6fe0ac641a4197e17c63c53c5a8cd1ffd186d44c3bc05dbe16832eedbb1731c4ef0ae2c3661f5f8b32f2e3c4ff97d98104a0401ab938cbbb16e33706a59f0297a09e9dfe2c1c1be45613d970b3d7dc731860f21a0d5cb0b7bc906870b443eb1546def73c3fe8ce6e0a09d8543770e524e3eeaaae8334428fbe483ca48e056c64172f96a42fbf3c07f8442eaee0e160a797dd8d0dd569faf042a1a8e172898ac3f30c6d2bae555c6bc43b4ee37f648d3985739050aafe25f4a456edcdf6ae0a3791fa084d23ea9faa8e3c9bcf1ed076a245c7cd69b05f1f97279aa097e534144e98964c262c65ea3c1cbeaa0dea884878d0770a5b5117ba41415b02eccb48b0b9b40ca196cd933913ed65cf778454ea80fec9b56091acc7fd03315079064646403d12751efbdb122983e8fa2bbc03b7beb4b7ef404f7e0f9c257558dd9254ad99067922f3898b0f44338bc776622f432ecc58813072a73a4f0caab81657b736ec15d6c0c93ac56889194374a94615090271ad0c87ae5d7b9f2c911e195071a09cddf08fa13ebc6dfee32158b8940305c138abd092e288e57002d241a48ec1977a449951c2e8fdc08417bf6d038a201fa284fc65323d985daa67ee81fac8849d76d2af2203d476a4a6c551c8ed870982518e4d7643a1171ac1a206e0855a8ed3d947b420c5fc9ff7723044215607ff23310982e1fb145ad72abad67c2c78ea11fdabffc9704dfee1427faac3dd8d559714976776c988163f485a69dd4cf5f4631cecb06ca53abf116955ea2140f3e8a6041cb6177315dcd5153c0bec772f2a6edd3e8848eced8ba164dcbb6dbff1acc86ebf15af97da7b9012450e0c03e904dab6d8baec5f8ae218350ae6822f465e60f30c3fd0e65b4f54e5ae7790b961b1d7b7c260c5253038d25145db1adf113ef35cf6f84331537905a037aa09ee3a7674825801e6c31ba7612f31ea4a13b9975c0dd27f61c5b05c5f7e34cfde42acb91c2a19b6e21a68ff7b5971d2465bc2c230ce5fa0b3d28d18c5b12a5e5d72ed44da96c8f27d3bf323c8bddccc74cc2fdab7047803d808f22524192d0bd6ed9012e95a84a6d804465db39e6709a776c5a0f23463fb25f6ac1c79f191bb7708cf1d88ab62f077144ba8f1ca848e3a5c715f94f3b2583f3c17448896c408f17a1db55c62c84802c783eb6d1817a11843e5b8f91202f71adf7cadabdfd38aff5e93030f1e2d3706c78d38c3b0b74f2f689285098ab6b18494a7a94d726c6e5d1dc06052ebcca54292a2520417aa0cac2887032c543778bb9d3941032f36be6d0e5b219d87e6134c071c8a161d6de4bbd2cfe768160a11081a730f7836f6b36852ef653e75baaf5b12d28c5487b3b956172656aebbe8ed9a85293197221252073d047c7c88b412f8af5620a4d4338b4ecbe3ab52233725eec456a130006143992f0f6e2efc1d7c9b3d516fe6311d64d1735919488c6342dd56cb47447d9a697b52989ba681664b17ebe05732959a4a08809ef4566c5e80358e74ea4de10e66285c3bb184ed249e8e8f1b44f02ed9c642385dbfc235db99e1811a74d1eb8674f00ba3c81da91ff0540fb9b3657708c944b63da3a45ec3934083de7626543fee763e879c12e8b71a6b0c70eae57ce5ade3b8869a662358e97a9ef2b16209dd1afa3ddf50f42b062e665b495b71c02472b29d3b627a4525c4c80545e1085eacb3aef15d9fb704b321f37ec18665e10e1a2bb2568528b767cf8f3505d68e67caab75425f31b404f9be8ccd259d7730ae821d3704f11607867d24b4d6c35b994491fc05f8dc2a2338036782bdf08d9967e4d8f8f7ce3b6d0beb34a8a2d0a7b70da7edc30ff570a46aac834f2357aca14d20871d09abed20fc0912cebec18d727a1d5ba78e548b67f175b508d4200980ebf84da05e7684a10257a78247be7c8bde02826b20144a4159ac66cfd6e6f9d8f6028385219e2a00f746b9c9750fed384e837610a13b671ed57c4b3d4fa7930543978b6fb3590937727494746f1f76fff30d6d421e9a8f7b47c6cb529cb373e4d829f85ab74420390c7288f4f15d3690e27f31c6e64ed28f8250b0b64dd5da4bf7a4aaa54fa33c07777dbe72c7494afa951b2d17307c93e69af1e34501844c9f00bc9e0f898712d9c04120e391590d3d1a5a94277071b20c45eecadaad2acef34ab2d17cc4aff81c3b04631a30ce504acea1c92fb97da8d217f05593d47019ba0459971fac1458335429c6ce38e9437962bdbb3466758aef9666068efdb904cfb6d9bd5d06be7733ee1a04b209cecb182fece54ff13280f20ed43020850299365a186a00dcd76f94ef89d3ff402d7daefcf006eee2bc3917ea147487ca768011142ef417df341fcb9cca6b4afd210001108feba041b546f11b94e0cffb4903e8515b472c7181ac4d10c52a2a6049a0132a826b57442e2aa7e14d325f673efe4eb0b09c74e7eb09690e1251fe8f4ff369bff38c9b44f6a68b4f754611b97fc451a34a9e22fe50bbe3007a300fbffc19f0db17b37c15890990de48b4459b8267437afad2ec1953dae0a572cf0eb4c9a5d49c108b03fd9af2d11644663e2c043789c7085e04310bdc932401c4191129b8d55e4b07185e822fbcb024c52c7253e5b083be71bbe904723b9bba0ef29460c324bdecff340380cd563f17b4fc2f4506fe79d989c4d148d170cf5f30dfbaaf617d33e4728517c98d44cb70a3d99b2ca61e754f324c63b1cbcb3be099d14388af4b3238f6d5077225cf91633547f5cca959f0ffcd5080d6df627e456b15dee4ad6d39812a7df42da6d3512c839f251d134eddbf40e18f4b3adf6230ed2ef1ec9f3d3c511c2261b6c7d86115ef070e67101272c2411df232103943e0a39344b81367700d0dc126368a9e62dab843bccbcbf0afc2a38e0060995da4532721a171b7bc493155b22f1a12a2791828d5a2a8bf909557c2a1f7536602629a1f0f6fc4a4e3fbfb36524f83c65edcc429c254129f92036640917e20dba7967022c66a6397f8cd7be1ac79df0a59563d88236dad61f09f43196e236cc8893a6e70b8151136455ebfe57ef6b84987a8b3bf973011ed9257a51518ef95a00ccb583506d6043d39712dd7bf32b4d5b00f9bbb4629cfe3d7049dbf5a7301e2500ae85fa2d97542e3d48750f012e30b482a37e272c3c5420011fc52b70457ebda45371f7e3ecb4a6646306718407368e48566f9efa8717f80750804877bd810ae9b54a467c9a259dfc5af44ebe31ef40b99edf0380d09c99be1b2fb5a326a990a6d7f3121a1e79da236658990ec94c134c526889afb2af3de0edf1749d62df044287863f1e81e31b879e185a84374a15058ade7f234bc4c344d04c50841edf6fcb143ead29154b2b13eb45cde01ffafa05c5be47d5025d124990ee4cf1d24f9e72993428b1f2930100aa0788780c8ffadd1f193d7fa9706fbdd3bd1e292de8493c8cc54724becad1fb13e9cdf0000e09c0c3996122cb5edc0a3326a237e0f6ab176c878ecfdaa4e1d74eee54bcbc357ba4afe6299f69f268c31e5fc8d949cf73a9bfc2cb3bc3cc53f6c80a6bf80664f87c40b7ea0ad13d1e3cdd38848f2036c86384d5a60547e626fa7e5604f7035cb91ff1e81d7bebecfec71282cd6b957992082fcc7e73117ccd17b211f5a579cd4668600314a73f2d3d4e3b5b7db1f0606e9f2eaa235a75855e59037d64509645cff14a6c8d16d86922125c2b189fe7b9820c6a2b364878f0c1a02b629f53d139a4755b6c2bdc7ba782c461db9c88770a3caebe30152c4318a98ee371afa93c81936cf4b330465ef192a361185e01a925a105544362c3d31d12f96041c7b3d464220731780b18c4aee0b64c984b7b6c308c43bc16d18ebe0caabe6b94d8254e27f80be62654800e77aac42d42c3e1008dcc6891aa13e40af4179279a4f90d1c005b579db226e84567b94ea81e17844541ea9239f1f2a6f183098a432eb95956e1d688b55a7a809486ad34c9be58c3e7151831e466b4cb7cbd64f5d7e246a8ac7ee7869ea853adcac0b163da7bfbaeb32ce026a2ddd670efbe4060ddad00915736ac1dd3a0daa657cae33ba4eeed6e4cd83027d67eca9d454ba607c0a259f5719935481a0f880e123145c5ff03aeb108b3f702925816d0fe631a196fe29bd3313aa6d9e9b852b5fa232dd08f2afe4321b44d929f9ae52c42c515b6e40cbb649aa176becec55a61b3d7c00d2a4ba15583c94807cd09ccf6c256c53c84f67955aae06dcfca746ed093943ba7adb4126644acdec64e77fbaf2fdb09236520d2d8033a51221120d4220baf42bbba0b6376790e14f6cb6ef5d3d5d3625e1791d241bf130d40ad50e461e01df31ecafaf1a1e0c310f7d2fad582eee691bec5eb562837006a1ced9e0f6ee348dc9487301107744ff0e114a4469625aa493b4f9115703faf20262f5ebdad38d887ad8b9b7dcbdd0d76604ea12535c71fc59fe9898bb837efce2c631a89e4e03efe6a069e94bb47bd948821086549ee9aa72fe7adab340ebb60c4c7881c249f846ac23ef6ba9444c9193bfcbdbcf5da4ba011bf20a02ad0d982e4d44519b6732b599a94906b27eed3c68b1344315c206796a1e8ae031bf3416c9c8c8725f720c1fa83c478cf6a413e9ca9556e035634e3ba18a06736ea616a9db834e58e1120e41ce92416bc0f1879e26c1f62484072479dd7a711a465d5bd420af005be04da1a409dbeac6ec5b2d0915066c710b3d076cb34e2fda0cf05ee730f856feb86408fa87a55b36989501bd11cba40b6039c86aca957f6a97e131763296fd061d2dacd26ab57adb4c1253ddc1a548188d8716966adef9abb23166b107ab37836fec4ab6fa01a2ea3b000c16c6dc7e254a847098fd592432f4441fcbd5c9f0ac59d3a1cc75e5ca37126aabd89f144ed5a2923c9adb1f03a9bc45be3b453a46082233cce498be6a83e5cfd21cc641ed69608dfb3fac0a4e7f4148b9d17d91707abc457ff7592218b108c7c579146c1f93cd5baeed3fd56d0dad31d19c0ed73f21155207153f9e2093d282be80b6b390a1033a01f1456e8b1323f39b1af375827177960d05ef5e7d82b7b3e73f96c140d8899c02a8fc9629f642b4568e8d6cf5fa6f92d1dad47bf35f63f8566159bb203c24e62396f399e5194c145f916eea1876d20f06a40446af7229fc32b49fdca6e7f4186ff5fc078c7cd2333b0957f70c9e8a0b5a4cff57b5d87bdbe28b4fd27b6d4fc7870ef93519c94fc765579191741e532b3391597742a2e78bd268d8516ac0c4da09fd09ef3ab10a76525df3f3c7bb84c1613ae53cd5beb27608a05f8384edee6a87893cd9f22cc50eff048f4d8928da3e511f3cfe79729f311504616e09fcb6c1512dd4f9d7c089dc9f2ff31a8bb7f802e1a485cd30285770dc4050f0b56208d4a50700307dae941c17d3cec7b7998b11e7bb12f6669215a114366bb786b6085ba6b37d526eaf5ad36ae9555b8194d07bb25b6ea48ca2bb85e57fd9dcc90b2f8fac07d6deb4f5a30ae0f7014c116010cf87aaff332cd9620aa6ad2f3bc2d40e7ad11a5a2efc72aa23c744e0de121d5451982153230c794d2280242ee3c70fd4e4c53c52ef994063204be94655ff25dad8f2ec20c78cd665443187d8ffed2ce42b29e116eca572f13ff80b98c97b74088ded756b17edc4e11251ece0dc392c0084e2f7d0f28a7bccedd561fed6d59029f963b46310903f25399cd4e6dfc79e72ff955707adbfe780b6d48418f57bae624d3f89c8cae6525c2f79eb11ac12c73b8c333990e514480a0d76826e20737e2134743aa0c7ed74605d08f17ead23b486d86761e879bb795eabb5eefef62d098c76dc778105bb15643870cbf6342810fdd31a7b283b7d4caeb4589f5bbc10b864a2a51e18f8a251b59c7e09321a1db29e0c9b42b41105c4fe9f2efdcc83f31afb7cfb80f79ef4da409b43b51dbadeb66e9d1621a15464f3d572e9b9c570c1c3f0e6a2b1c18a08d3bc814b775d22ae16ecdce0c458a3b5b54aa5a1c55ebae34435908e614adfd3c6e926ede77ca242a70b3e80266a7b3690eaa5476d521432fc050f4aa66b203ae02c45a7da2bdde6e335a9ae1144272764ce464d5faa716c848d6ca32d879c1651b735534434c46743374d4f3979a00d82675fd68f750dd113a33895ee43414cc012dcb9960785deb562dbb319a46bba3b318b749e1ead2cf970a2812779ec3852b453418b8d6aa2ad3a507c5996eaba5e1a4ad0832b8926726d0494c09184269a37efd91c21e2c1b0cc3989cb3c0f12bd4ec1833ebde5a7ed7dc91e6cd6cc3e48474d87afc109e38e5b749d6cd3969297518e5899ae8fd10248c288a15759f031d64d2b37517c1e64a183e213b9310b6a20e35f8ba9dc9c8f4e8300173f92d7af6e0fe4afda73d1268bd9e92ac02536cb1966b9eed3f27629b308864dc7884bbaa947d1e7b849e0257204b5180bcee7a7633c6f62fab6703d023b09716e509c2fccbf4c96014922b2d7f65fa079b793fcb4f3e57fbabceff6a1dbc0d5ba944e74dc439b9250c8b4bc079e60dd61aafbdc8536c58188ee50a205ae82db15f3d2c2e3f40d892da3023f6bfd0c593710d2166525092a858fe425b4f6770b3c924becf0e2b89c424eeeec6692776d35fe40a0f0bcb61f9fae8839921f4609e46a1863ab77f61f9c34febec4450a4bb4bba39183ad5dad78492a67a6e43e559ea176ba1fa46614dcf37700123cd7a36b96ef1b4f58985339fd3f097daaabcef997b14d19a7a00d363763af970d690e4e112ab6d1022111a150b08bbaa181c116a889fb60b3968f818501e7811380775c959372721b438fa28eea4308f583dd7baf5f196d846f2a6023c257f1ad055a8e844898068795908654aee104549d0dad346b873aaa323d73e52c7a185923d0c1b00a0b8fc67a623c66a1ff1983c7ae44876ba08f593d7eefb09c42cbb099511c039dc53143bcd68a91bcd5e17afbdf81a5c55dfd4a8b1ec30083144d5f1eab68bfa9de983d3241bd8703836fd6e63428bff021cdffc50dd662666d106e96fcf7047b00c18dbc2a47fbd3316f1ca63a427e96bbec7c12483bd0b6e701898ec804e8d33e468dbd6896f0398cd46166ef7404cd28d385eb78f616d43b99f82b3d3c6a60b4b5f05e0ccff1ccada39911dd2f372eeb3db34d5b8d58b3545a9432a0370681c2fcc038ac522f3d5a9e1824b445d1d37f5636ec864102880b1fa140e3aef8fb775d888de8b73318575ac12472a6a4854627fe1ff152f0b411a09281d51b5404a58fb1840cd33c1efbc052d7ebaa97283150a8b2db8f9679e15de65891b8d7448c9ccf98722e0516ab2aaf445ca79590f04a118aa3ac825ab4469c8e27964101040536b1e5b8c938d9f6521f82d2f802946f858fe713a53bdc3a53c52f6185c870f5c7f03c64c38786a5a26dfc5dc26265bce967b3466d50e65246752738b385251ad332f34ffb7103776eb05cc7a3ba3eff2c9845316d9f629ee37373501f8a1dfb86f75ab3bb9ba978bd8dc7c9f352362216ed0df4651604d67261e9bf68d17b2da4f7f41a90867314b7cf90f77d1ffc177e8b2b9907d884adad1165e5a016fddfbae82cd5f1e98dec3f464b0900577d1568df602a821b68f53269c0743c5aeb0e1c55ab284b54aa65b3a8856d6836b287da3f2045ab806799ccde06329124678c1e960698f67ff06de3ec89b7e696f6ded2c37dc438c9ecc70ed45d7deec0e7cb2c93628c1604a89919cdb2d3729005b0c849eb7f2640ee5fbb1258140ce1ecacbbd905b2ff73dcaa62a0b7ff70a06f8bd60e6ab4886b726065345ea794a848686032647e79ca8dea4f6b0328997b89ed16f8d289e1e35ea9029ca174e8f3e3d1cc9ebdd319f703ecbec87abebebe97ff50309d806ae4264d9ccb6acfdd0f79debf470340adbfb79aa7b044911274d84bd8b2967ad9cb077c24fe08032452f8f52f8d119d088bb3297026645c78c1edd0453915b96d951e6cebeb3f4b77724c943d3b6ef75ab95a10962bdbc63bc5857d23981398e890d6649d390ab83b8e07f6c3bb121df22de291f97fb273160b31b60024506117e1ee45a827c3470674f55e96b27ec87356188e36b558b6a1307b6b0d4b7bf4553af0935b9b07897edfc61206067b3531a44e92d619fd8176c047f4ed60d18f95c66dbcdb27be22e7fdc54a09d6f71a627957653147c23b0cc48ff38c1c0000a4899489983d5bd0512b4f74d430d094ce29e46f6ad2c5759462327b1bb81225985fd00742beed0ab9b5c3e5763ea279f076d212f5737788f036352f0af1e6562f8b4ef93a5e12a2b26295eb1db4b373883e83c39bd16d76a1e71d83522e135411b1e369cda8d630e85078165837760b09359421f622d4285b30eed20b450b962fd7c90116e02f273ac4f1109f92750a9efb0c0ca305621cab97528ec900cb104b44e17bbb511640fe68ff392b36da05cf758a54eef9c221eb6e1b7e709825d6e9ad630760e50ae260a91a2eb4b20f431a042f5f567322d35dceb16747ac40218502f7371c68554eae3c904216c7d2aafc2ca6a3db9d4329d318a73ef51c8f8fbe4a8dc24f255fb8206c831e4ec7722e0621add69eebf49012369012eed2a5b0331b3f188a1170034c2be6a19eb2ea729696a87a8036aeaed41c70b97757785fc4ee934a929e5f090abe58a0c0a83a5b9634ec4de9a4aab1b6f8bb5069746ad70e91766a1f95b6b9b5226092686cd01b99f4c24869ccc6c1d4bf5dd653d8947d0cfff5969aba292d43d94105e8ff3ab199d9604751e977f86f65c8ecd2711a9804a82128756f8107abc7bbe4473583110d96a5ff595fba1eced33b8a8f59482ff9d4920cf6a772d3a90d2f5ab032272df35f1ba807da11b7de201b852070e9db9f1bce1aac8988596ac0c0e195822e1367899b3b746308134d8e6660d466acf01a1fc74fada88d0e6deb99427bea3b8e4413b70fccaa9c3cffa329c144ed533c50c0873a04dfb930ab0de9cc397e76c7f07501098d4554a3b2ead69e168f9e9edbe9619d584636e17e9f4fcf5dd7f8c60d12c5ae3483a5f4d55244b8894143a2abd414340def1b79d4ae2dea955367d007a16fa1521b8929b8bbcdeefaec8d38116ccc5f256d16f234fdbf4abcd4e2d5e0f78a51486e826534b5e224421ca0c516b9ce40685f381e862faedea62b3abfa57563543073908116da1f8ca3c09d79c2a8a6562ee84287c1865e697221cfeb4bd101a26fcf555fcdb17b0aab04de0800354ef68d3ef27c9c8da564da1ac607cdd0c2bbf51b13d90055de3852fc052c0d71161139541071bff0ece995f32507a5914375d2134efc62ee715ee833cc0420e7afd8907fd8ea45d636c9d62bf5cb9a5a803e25fe64464af6e4d84d822cbe48c65fcca4a120a5563635ebfa50336abc9f76f06c910dce389ec05922465b5e674b6c9bea19a755e285d01272f97006875f6a0b29940a576523f5e9361d97aa89345e46b211a7494097253b39ca0f9fd58ccd72f845dbcf270670e0c70f1ecc587f4e961b5c908a99334a1df7e199d748f11928566ff99562a6e99956ee3c488310cadccd8276fe9930c40033969b89fbc25c17269176d4c8cdec265238356b5ff525f6eff655f2ea6cb3ca08cb37994a4f516a8ab8a8c632ecb6eb4c1b22aaa8b9cb4f6d7330f35fc7fb3df0eef7df952565765e8ecc868943aa2bb6dfa4835418342a79600e7fa110121889792b30aa8cb7f0f390d81469732e7431b1c1a67eddbcfcb040549ba11cff02a4a79b5fe86e6b2cd957066287f1c4eaa72b0fb58c47a8c0de849d9dc1299b04717de430005354c6594582ebb3d7c405a335e09d2f8bd48c9ecc25424889dff82d3a67391714cf90fee68aab7c46179d8c79bb111f86c9d3cad3a2ca340c8d63b55e0f041fff5588ae76ce84baee2c7f2a4f624c2e3199611be5c911ddfcc0764fc01be47a556350827b45ae1c68f1bae6e661eb5522ac9a3c8ebc57f15ec2816d3dce11bf24d99d2509e20d044b5774bca5234309ea63e328e5c1bcc7fac6e5540ded460176150df4f6aa795f586662e563192ee7806d50c26db369375366928d59f410efe4743a1440fdbfdab4270850e46f98196e4ab3ae1bdf61fae43f7bef08b58fedbed3916b2b12a248497dde2e554a1c5ed01447fc98feb2e22567881dfbbeeee9d79b2e3a9964ea83d41b0756bb8c7ac4c3652f7a4955a346eb5901b32783559575fb17f315fc7c8eaf798a6576b2f387acea0b27f626f9cbc1b73fff6c53ce783a34a8f05bf0954598cea21e9b28138f1c174a40c1189ac3a86ac8afab0347832e758e86669ae7620cd753f93e1a256c2f8a2e5613fccd02f12e13a049045b1faffb8049c15f7a38394e10377714bea194e0c27d16ea0e1c91abb91298fd0de20305e4fdabc17eb014d97941b5f8b80be606dc1e6cc04b17d7575d457bf24371c41783a9e16e995159aa3c9068fc460a06b13c49e336a2ad3183e7b82161a23af89dedb0a4f557384f83bab0f7e937a2f82a076704133b39d76fdf0960778d31bc062565edee9a11725f742acc1eda95a981937911ce49ee1a2942a12a2ef97ef652f4d2d2ba490a12eb45901dff2a31287cc40501fa4a32e7631ea0fdcb3c40f7b2b66f03dcb4f99175c1447349cc16fea70ec66758315c557a98343d81184079b1493b9aef3396cc06d4849bf8cfbeca74427e21684f54afe05589e8abfc30ba9681d232704636b851f5eecc918bebc0850174abd52cd5f4d4a93221cbf91012f005b92a1027e0d84a0f7951312c2a3732b74ae1150733a0ddbbcc4989bd5b8ea621b0cc759c73b396ea1facfce25f4d806534150b190d7f97e73fda897ad28876f47461f1246c183eccd5d08f71a2b1718bcb56fa733bee56d8236a214c2d1a3d3cd856cfd10f8abedb3372a244b9b7a039f17d11fc46523eb5994c9a4efedc75323d4a254552330304364dd3b91e46000d1536a40627f46ce037311eb6afb21e8dfe8a9d7f396be846fe71e0f00c824926adbc4d01a85a70db6a5116e7b9ae5730bd11891c33b91a4934e0e8c7e90b24c0c66370fd9e41b8001c776e95142238b68b7f046d537de0380b09dfa65817ea95f22f53bf0212c17cece98286ef5777bdbf5236582dc33d6bc1371018cd77dace0068514400f8e4b5bf7b7b1fe9d33c31950fd04a6974472d3d345d6fe02c027d131a1fb4826ec83063b81b4cad278f0ab601f287e1daf5ffc2816ddbbdb60ad12180f4636863566377ab0f418ffb3e5d9a5a03029ba136bcc6752eccdd206b738a3811ea8eda57642283280cf91995ae57865a3efdf400dc129f7ca2721271b3da22ce34a1d0de4b321ec15d7ae1a0e469b5f057fd07eda19f95ed82a3b25c3c1a6c6c1613041f66a86ce63e750513c1505246febdf6220bb54119828b0c8bdb1054e9822886347554d484e96c40a0008b170cce58d585fa233128260c818e7a56faeec2f1a2923b9812db5d9c39c675c9d88dd98277b783a51c3402c3738886fca92ab41c50d947c214ed504fee0c209465466a6d836b3beeef0f8979bc16109f3c7cbb90fecd5c4628f40f399f041cd362630c2e59cf5806b1dc33cdd2844052ce50553a646495ed4cc2e74421722654e82d2ece9270589cb164007bbcf240fdb0301c3f63b7544a976dfd2050511cef71b4573b019206f9e5e5b30ac5043505e2a2d55cb32fe746e4e8c8347ab4b6fb8cd7089cd4f744cb42028ff0fd6dc95afe6bb2121de3fe4bf7d7cf981aec36d0fbfda31b87c48c145504273a0671d8824667bb6c42c5d4ff83e2fb10fd3bfc68cee746649379207525ed9c96c72a68a6ebb700836d755ba741c8e146094c098d0c4bb90ef5f8d3eca659df6f0c5c1468fcf0ae15906e468fcc9fb7a177bed27e7c477b30cec7533984f7cc163b22a73ad91f99513764e72df943c8e86d61fae3e5384101f8c6053a9c13962a08dd23e24b05dd20120d05029432b079cf555102a68dd178a6c3ce2adc747b9793ec0b8763b3125fe7b2e2ec3c632136028c1e0514b64fba078ac59a1daefe1f2c33c0c1b130b238cb6fb75596c64ed63f1cc00629b148c6c3e5aadb3d2093a36d6f2040cd7b2df8417010e5d92a60dbbff56caf9a43d339a6aecfbe0267c0e3a2bd4c744004688fd0bd628715642ca47cb7a50c6b8390f9468365d966da68c4397b8ec2388bf8a87ea50297763f587c2a00f03a095f011dde62e939a457e975021e05db111170aacb4b3911340ef5d3f2b21e338a72f8d7292c3c08ee0846e6abb07faeb5ad1d6e5f66739ddcc74f9c34a253bb99ecd3288f80881ad726484a31c4233121d9e4ac380772f69a9701a1ab2dbd721227882325ff33aa6503397da55f9d9e89835c3111748f308cb600c0549aa30022d7679e1a02fbe75ca5c2d359565b643c99d0acca76c4ac90938993ada97658b1c2ce93836e077ec5526dd074d6cc1aea098640aa01e62ef2760c8f6b77e6d49211ce624302100cd64df14ed8559b7dcc42ebcf2b7ee5ba3deb90a45ae5fc8ebb0e49688fb0770ca6706133bc340eb0dd1c7da4c1e98d0ad4a309200f059779eca1030369a9cf2478d5d9d9a76deccdbb5301491b517f2ccc6c197ee72b2c5657fa77b3013746be7ea1c458ed9336fc13685dbe2eda317ecf292ae3de06fd0742f1a3c07f6658abb1e7019e33054bead3d392cca658b275082835b57ece2770710b7f216e1d979cf3458714a5487b75dedbdf883253b1a9a70ce9fb691575ca7a9ac5d8199ba07b8eff6361405fd9366f29c603bea007fe46f46d4305f4b4f8445802213f7e3d5282b24144f1b5c4cb2e7ff28c38727858d9c63647ba85a5db8cfbbd8b404162f33e1c22e4bc838dd8e37b5cb39e1bf0cd59d9c5e6e2283235e44479c9ad27f11ec9c822cb8523034b3320193d4145e353ee9ee8e28d9d05f67cf82df0094a590ad813ae802c489f2efa76e394cbe7250882eca17039c5c1176ab00f330fa7fae0adc96008bfc083280de5d7599d04137cd2d4027adf3e4e414d3d1ae4b90931f855cc98ba9d7a6b4d058cc43f6915fa905ab04220d707500aa20052d689153e31369bcbf599bc48792fa7cea4400aed3022a5853512b1c09817c838b2e408c3ae43e5bcd29bbdca8e53e27434451bb95e2bbf0d77d16482f3c08d3b775eef8c4fbfbccebe1cd203fd44b7423b7f66bc2f6a046046e0ceda7927b162132b8a0f9ff2e06c82bcb526a18df06d9f364000a5c6fccc09591b1bd22c0f358c218d7f8527e00e1b8fc6d34293aa70a18e169810ccb2ee00e893e6226cab05261afe5436d31320d9470a192d194bea0c48c60d07d951c710dc3505005833b9e9189655db7dd3bf9ee664ca506970765a1aafd88d6c996e54871eb994ab3313c526114b7ed0017f442c8b6184802455321b3a914c7e03aa84abfddcc1668570b6a8cc3b66330dfae2462abc892bcf6247c54e12543e6f7a06ac7d14cfc5371388bf51e392c6fb5599320ba737d04a75d1e7ef46371e610a6b275bec9efc45866828c624d88f0ae3cb3655800540384f8cd679ab38a58af37942bdd386ffca719f2d5dcdc64f716594f8c485d09dab4135ffde49fbb62121483dc0cb94393ffd488d4063668b60cda37cfdb1f59bdb572d1017665f1aaff60b26c6a9eba70f55390d49c943519ca45114f34c745aa31b2153f0776b777d30d5d60a4338cfdbb690d438611f07f49ff0ca8366ad881541124de7c5a18adbf1d2aefa5c597f87738fe4183e4c85d8f430aa63c9ef8f60746aa241a875dc429496d0d674739cf10a5be07639b9706c57ef8f2c5fcc1e640490cfe2bc26896d5be2426fa3158277dcee2e98550357101d51fd51f9f1895fdc6409c503a79aa45a123ac714aa09b4863f12976bdb632f6f1b0aea36433d7c42e0dfe4028619695f327db05cd6ff3007338a086c67a83ad3956b956abb7aa1bc1512a6a935c8dc857add822dfa5b3522cd3e06fa377b754f264bdae7c42db1b8900b467860c6e51731f8392056e7f1db8bf65a950850678683811221ac01057c65d69c9e9baec411ed775fb80c0b023d5902eaf89111439cc04f74e7f1670b7ee13131a50bb99d2785aad9fa9e8988747d46289675bbec4d98a74d99e7caa650a5409dce923fbe39d6e2e4f76d09489b5e8c778f791d87db99b8e4f3bdd873b24c2ac3d12d7e3629bd9c649d2b1f5ed686efa450cc2e73319b6aec5828f6b1a20d6ea7d46ed4ca21bbb775b66241608227d3c3b970d25b78f978fb883be0838a33a218f7a6d8fe8c66ca2f9eb4cdfbf7b96b020975329f6e854a32eda96c8785a373d779226b614a00bd3474d06421fea026c4e6d4936ef9ac8e38d96b1f19ef339e06ffa2b2334c2325e2859bc84c379773cd79dfd807782a6db576a61c81036150a5bcb49b139c14a4b280db925bb21729444c2c2657c808ce95a0d80242abfbe05d302fc9f6f493cb5502c777b0328a0877f2f78877f3f0c30e88422dd999fe790eeb20b5009580a4b306c918a24d852f61647350355143e000d48ef8380f038442a907fab61759d400eb2add92324728d88777a990e92683256f24b2ff11aacf81526c45e98965486f45d9d55bac48e92818dbed9c587cae1785c0ba7c49bde23311f5a3b1a12521605f09a9fe4c9bf1d36766160034668b45bf5739c68f729f04c07ba32cb741fdd2717ccace5c4cd52a78d42cfd7f049e853599ea56c8303ca4137a98df66eb280279a0d5cf8c20be77969ca882803ea6b7c109fd47dfb525480c8176045b7b7492a21612cf26f5f726f601e25fdf23815ca4b12edfd42a9cd73a013b3bc9beaa82867374055b5047e545eac85241506d305bac9926a075bb844645e9611df4181b5096bd77d95b6617457c19c6069a7a12df48b552a400072bad8b41aafe11fb9ee0dc69884b02325332381d3c431c214dbb4a9c1684c18f03589dd457830bfe62c2d97347c2eb24587e108bc655b340bab9fd7a57b35b15f9d97babc32825f397b42a396878d2d5a0a7cfe6dae5363696b7bfb8afff3cf41d63e41b4daedd5565485ecab6d95fb0ff02744b6e658e49fd69b0a783c7d534579f10f2e4ad23919e3d071aad94fb3604fd8e8f39515c396a5ab09f4eb56588162dbd316d2d9159452daa91df55788678d7b3a2c3c07864953dd3119e1e8a59f832e4072bdfa24ab84f0b742afad318e9eb5b3084223c10523252f3d774fb0534e243bb670964234bd17de8e7c7371f91f9abd1c87c021d1d8b668b0c135cabd9ce2fac68186184740854f7ac556400314e5313dd5fa9fea03b496a617fa10ed83f506ab8af53829f0363617fcc32a2221f8d7477e44b86ba022fc0243736f2da49a7e2db94b642f85d8816d016ef761ba406ae210d2426ce9e2feb5590814870ebe32ce4832b654c8ff782e42f0c76cdb66f49e62d026bb1b7e0f9d44bb6e794ebe7048afed06481765432c54cdbfa50b3c2c26c73840b977b0902bf9521cce2f17615708683c772471a47bb1417e57809f886f2df2fdecd2dbf250b4db71d3cdc7baf794497ea07b9947a492098e96861a2d29c31601a411379780c416991d4bd498ad45186eaa6fdf7fa618d0e8e79558f0eb6ce288f5b1005984819be25a938cef4d8906136ad32ae64f8f4d7c624cb2fd229a51181c99ed24f5d706a51cc73a398849239969fec2e7e98b87de7b904848bcdace43db7b5badcabc02fcdfdad4301d740056eace3b00e1a47888c493886e949cf58e7a2dd8a3b63d00349cf3bf7ab927699c17053273b5fbf3b3e04e40739bc79a09b669f3ac25bd550f5ab6814b8506e31efcdc5a02e3026a4cbdb60798419f7c030328acaeba56cc207ec1c7aaf6760f7d2300042ba9d9b36041925755a5d22f3480e6d21642ebdfb99f28628cff4d6f6ef1508703bc3b0cea0c69aa74e1bab3084c7f65235d0369666a71bc2c6fb8a4453a9ed2523fa313b19c81a3c78b242073c56cc5be722dca0cb311ed8de97fd8f05282d85cc6b284ff6855c85cca272b39df8e0dba46bbd222e7e7b6bf35eec79cc8fcaa2efc6c169c72872f62da4e639d3822cbe10555000590d6ebece9d62c6ee3507cc160d6d0177fe732b106a3b797ea5c5f519584939749d99ffc89d44d9cdeae4fe9e1659fbb2e5556a1dfefd9c227d62b2191344f2905d5db876619a2b5320fa7210422930b82d2eabf9bbe89201a7f0279cf63da0eee86ea39317027c0ea226a0accfd623da65070a6ea8ee8279d872a5252cf66add68e3e1faa538191aa51fada4f5f500326403315e7469fdcb37b31c18d52ed64762938308804246f296ad6cdddd1ce2192ffd6101e98468855a460ae9099295850ec457f7aea5b07c76d8e51502b93527c387488334ffa69e9b5d564f308b2c04eedd6b083cc3565a828b745b5b8bea16622c73b156ae2b73067c664167658b9c906a932686693fa9fd63edbb98072651f5fa79dfac9ba96e87c5329f2a5cd576d3e3cef349ea6a55f96bb3389963dfa54acec4a67a7c6c52674e246282fd351a2dc990fd1997ac94173ea859a2271b6eeaa4607f04cb19ae7672083590fe61db1a3bd599e9d88392f5cf686a41df9edb8cdfb19f9bc914b885c89ac2cda1734d6632af0ab55c4028710df569f2971a32c8de1b7af32bc1b11ff1fef7b42808745c3b59708475b80ec71b62c01c47741d291843f22a363a67b49d981953623385f2e2d404438932df0a8de3fb4996b8b724f914d7f385c7c025895167d89119de8d6fe47e2fa1ad1f6319ea2f3182671171f5177da76ae8a35c333fec51d54014c0318039b213409f1913c94e3e6f4d51280641e15f9d5128f2ee7b0cc3fbb4cfa3dc0d0d2884f02650e8bb8acdc051836b72c58a022d9c88245e90a41a832aa96c1c33fef77216187f7253b472ed5fd610fc5c2ea159a58971e02c9f60b2e557251b0188acaae1ad4f99d6d3d66857df486bfa3685ca086795529ce1b2dca03ab0aafd87b18b80e17d0e3fab7f7600106f71c5547db221965fe60d77d5f1975dd85b4b899f16212d1d28859b2a666f6f9a10278943389eaab5f245c7ddc289b2887bd8240d08743629e7c1995d41824b3f18d4efe05293f6f46147cad9d6982cdeb25dcc4379acc58a7cc0331bda9ba90b461572bb62ac983b14825fe06a81bbf16fab75b6ce7c1ba89f70839b3609facf21ed4ef55502331f232468e0b82c68904e9827f247573a7d76aef2ef3a85ae574bddd1cfbb1e8f6c53e7eea6422408cc05864552a753789d6aa56dd0ce03c25a57d3337708604c6ab3cd0043b4f1eb9de75360df43fe96f313790648dcb2bc325d2137c19b2fa600cbe3607419e7c28cb25b8a4be7b1d894131ca9fb4803e1179939e9d2968848ef11bef64039380e656f582a4b905c9a0aa046ac9237a75c971973115494914f829603ade29dbc7d3807fe5fac2d2d3801fce44982abe3b418d2852aeca4ad141d329d8073618fa183f62c9e48b56c4b21e431998fc07b7c0ffbde91a27e285ea7215683d5c233a019c0ffbb8c1b0c876baefbc6226e01c9265416a9334977f035caab94ae2b1604bade0caa8c51ad9b40a1fd4979bd87630e48f08800a282b67c9ca918c5d06dd6c63cfab50a751c3c9b38fb0027f878483c912b4ce48916be01f5f7a10afe0d3d910e39634958d54f2bccd17c87ce15878c61107230951493cde4521f4afef679971ca16ae3d58f12f43bbc1c58b3104f9b34194b95c44c536eef398925b8702c49be8d853d4294120b038de798732f5b718f744b98984e41dde717136ce1ba3f6928d9844e25d81fbbacd1143fd91d2f84fb31b80321aac6f01ba5023a4fd6c2c1003eb9c08d3705d2daa8647d1c6e285edf85e5844b8598b6691447608029ba66a503465dee6bc3d08c5b8e37dcc2c8c0f1937fba86e3072c8bd0446a0010a82c030a74da47ae8182b6548e65822fbfa6b3b9ac4314d3f13474c7f260737774648ca731a6e8d5e4cc8618f18ea0324229742389993905e077bb9a3fdf807db67357b01ee2c4d817bdc3998ce804e2b87e4bb7fc553c27b505e42d8b3d5aa7d1669b9ae7b20bc551f2df9b1ead2097cdbffa8dde9093ff078181cd5851eace6e6caa4b75ad22a49d05d9ccaa811e1c9e61cd3487d9225250b3df13464e1b4231e77540102e7c72f901092b818d8c564d083ab74449a140a3e56ffc6c201b8c161bd6723c6d321efb306e285104d789a8d689e9b8a521f2951fa29163f4963ac36d63e19f6184e57381d2bf730cb5e1b3d2f3a605ae1e850d36e20fc3fa0fe066b0608f4ded193b260f38516b92782caa046c4a5a1580756d5d61d12a65f85bc93df446a851a7ceb3ea3fda47a93c385c66305474ed0ca613288d35156343f7fc705a66d8757c4fa5438ac251cf3842c9c2f0b9a1508da56edd7bcabd66c00d565c6aded61b73d1fe258fe14b8c6ff0e67aa4fc9a045b90b6e3a567cee40250458bdf5c0ac681a7836980e4da9f4f20bdb0c8cb965eb3f766fd36221ea289709f64ab24f107f50acbf0e23594bcf499a93defda6ef0a9c3f13c94e7e4c2436236045e7c7586fd0cbabaab73ff16314f05ffce5cbca86d4e4f8bd6db405927b27cc0976d02397609d219a8ad1759bc6b0a2fa6528f250c3ce99c2b4224255033467c1cf17c8368e8822df9da267e76b230a7ce85485e203563470c40cd927f94240daf73aeaf552567a39c03126bbe8a350116929965db5d7db212472cbd086a7a4f6a59a3c2828fc319c62286b294bd2bf75475df3f4dad9c56358445082a6734ebd54b686c59e58be99116d7dc7fa01e391eeb82d7cb94a59abd118dafb6b154e13de22dced33762daf2a70b9eee3563c3130b12919f8bd1372ea8bbe9a43a6171e0c303d024ba2f8d7ba4c182cd9bcc0de037da3708bd41a2157dee9adcd62715f76f8ac5185b0fdf5453e73c6641612dcc6824bf8e4aa8d7271147d786bb33c203b939f8578cab06c44f191da40cc754931f7c02be6a26fab84c56995d648b20e093827e5a14ae104abaca8dbc672a4196bdb2b33552de94577640ac18ea0ba0666b7a79336849cad5bf07a91ab3a2d4ff810309081138ebd7b7e7c545da6384328cdf07e50394eac355afed07a9b2b2c366a26e2dbced7a975a583f9cbbbdef46a67903e7aa266a1f4f97df2ed466c9e18387c170143833f62bc1ea398c1320a1f8bd46d5ba42b3e365d832e7226b86554d6963fac6d4e955fcf05983ca9b5b08ec104e1108490719f73635d1ee679033ca6a3569b394afe7bc1704c15a8c2ff637d19094c3bd78e1806dcb7e9b4cdc4e92f95b6c928f39f9826699fc215742e6b3cba412cb3c7c58cb4fc08f0e48b37d503bce770a301d7ff79176d69e5c8360e2c1b3e5c9a5020ff0aa85041c9783a39bb7b3d58d406cc01fe4b362c68e1fa120c08adc8a8ffba4ccd1d4f2511532781b46186b98a65a1fed829ad5df5ebde25033351415175577963691da4f65b6c4aa31d9ce2297740852a332ca4f9f473b3dac41ca6fb702470add8020287aa79a05d373aa7ae7d8c56f99edda1e26f4168504ba14883185ecc46706ddab0506c111c6ebf429c9ca698e88f024ab1290170df614fac1c35f766622e0a08b25cdfbdd76da114bb675f6ef561ee13d90979acda3cc41a74ca85c38ae40dfd8e33af9269a343daa561dd6dc37baf89e2f8c3bf04c060f5633adba2500306f6004edfd430b1df4d10e989d4e64a1dee7fa135c72d91a188ada2a09eb210adde7ff5eed41000d5d61b8b41e1b1c3fd6bf491930c1cdf4fbdc01e16bc290194e3f0a0025fbf8ff52b227cfa73839a5d8e3da0e079dbb8a9b1b26277a19e3ab396af81061735a6ff963125db048335b453dc9f0361184f21bd6ca51e4f880f785c51f2493c39a8ae1b4693824617438f0c63c89e3d1e25ba595ea58661b84cb405ed9a0776f952c6cc794dbce3704e46031bc49a39a901cf9420e2e26a15047342b45aadf9c4e4392e843d3c081efeee466e826d85cb6be5e530dd413533a2dd8cb53b1178158f6d5186396161e0d516e057bcf67e660fc43d972017c48a396cf5e2d9c3a5d9e5f9757fcf9ab45df3e113539805a90553758cfac63660bacbce08c967674f4a9249d6a1ddb5fe361f67d9a88c7fed28f8c86a31575cdb4ce5277997f912b599e030d403ede2cc1536121d2e00f262797bc1aefb6c4c7232fb4275128fe9bd907ac50109dc00bd32cf23ff34b07f5099af4acd364b0689b060923b98a52185153365288302cc163bd299e742b4b98ec2a06cff719ec807d593bd7c558572d17cb5b4551f4326e7f192e3316fb810169bb4904ad9d6cccfc41ca063a4c06fd9394e7e95fc504fcf68e3c4d82158efc93305ba85a0de1ad7c766eaa884a5ff5d30aafe76a0067b4ba400cbd80dc78f6c22bd974737e361bb5f6ab984e755a0d89219a2d0044cefa58b024e35aa40a0c31c1095e566c6d4489a44050746a43f9678ecec01387c17f0d97096871adccb5336950972562eb4b4e9cf854fa6845c8ac5c2192c0c73dd5b4c9810e07d44a1713b22e4616fa66423e208dae347519389a4036368763d3170818978f9c21618b88b86cc9d96966ec01e9e2e5eeae278c6c8b79dc7a0cc41f15a3a72f7de135cd284676d7acff44fcd222413de7a9ebdd2d66dfe3655c95af2b81528fea7f5489f92216ccae28d42a35b5734f41421cc305df472f8fb6106f791969883454fc24732018f932b6afc6780eb5901f935da03d30921eb9582ea2b49904840f6500accb77458eeddb88e0877aace86786c9c37218de6721e3615f396ebbb3a8d1b654dc28488bc88ae71fd654b09fc4edd240bfcdc59267b39f586c00c3d020789de3f7f37ff871127138ad11b7f2cbf8dd295cf2e26ddcab3f204ecfe5d70e8957447b606c9f01ed4a14e0c200bd136b83d929dfd44dc66eee9024ccc59789340f5df8e9926ac7caec1b67b55a04199c9ac12b7dde6f18ffd23ae649aadb3ac86c5f620b2bbdb1cf041896913c2f9f911a0e3ad12b11916e250875e8b33ac2dc0010171d34eb6837ea10effdd879b3ab14ae1ec9b7af7fb27418cc4eff8e42d72846d8eedb27f4f8e76b7583efd7fa653c5d2450a4ebbcd0111713bcba8a630d161afa7d208f4ada93bbc10000f17fa2ec276951325b60f75c7411f2c9c138d3f812140a6dfafeb0eb7cc4ab52482856985e8faecf05c0213bd4db90723208bfc7b4c06d9334c559892cdf62e0ca6b51340f1145d85356b2db4e30dabf0c8df85712dd8095b08010a92179c36b89dd26c9393aab53a637ca7675c9194e0237203e7e724dab76cf8c15921632560fccedc602f2ff05075cc484410d8307fe5b7b0421841f781ae6b91174b9391fcadac4022e3229d15872479dd2c1121c8cca4a6c2a66b3337ec5b576abfbebc8a88c28d0790bfed99b7f232be33dac839234721fda77aaf70b5e2681e2455610dcb13e3b76ed5ac5c97156b893676ea7761eea558ae7a4ab3514aeb85e0389d94cafd8380e3ecdbb2ac1f889dcfd6922563009d595099a60e8002878ed78cb799528bc846170d3b615671febc71e865a8202db493a1317bf0e34cb989b0bd9c1bc97fc44cc6755afec0b0373509535382fe0a79b960181ff67f90e1d2640e7939e99bed81d4b25e32c2dd1dc746c540fd82c6eaf08d12d650fa81f3ba8497a3f9b68e15a1477a93ad337f463151cc7dcfad267426f3704e27356663352c8681aa42a8bb68b38a46df8193e9e9893230c21a2482f8888ce0fb00bd188bb8d0cf23ab81a6eab841f38428ae314fe81a9a737fa2e13fd95e33e22c5cd09b0a5b30d8c27d9b8e4e14f2437afb5c62182f74232acd13ca7e003fd9106ed98781068bdb0cb9bbeff67618ed001299a26bcba40a0dece3a2dfa01cc33fde3d20e4c20dc29639f7cbc6b7051e80348ae2536305c88c984b4adf02339f7133d411968b56d7445277bd860aeb24dab70ff77ed370f50e6c5257eba7efea784b5aef647d6bea5e5444b4a3b0627ef3bcd68ab130aaebc9d7b8e093d37390f2887140a8ebd99e045acf39dde3cb2ba0c35e4307aea78a38dbb401f8290f7ecc732a60d9831e882f18040112e0de24d230583a7eb591140b10d64212fe369f119ea3b63158dd57fe645f420bd2cb2041bc3b278fdfbdbe12cc3896bb590bdcc81456ba69e0e5c4fa60c897ed733b67e37cb0e63f1c0e532f07d3d9a1d12daed948320d5cae49b0f3a51c014235b60039d3a1a5da31fc5886a430442ea79ef5ee04477bb353c8671a6b56057769a87b06adfaacf42fdd62408be2f8031ece7b508fad29f4dfd47ad442532a3799388af9230e78a54ad99049523b8ab5f6da1f681e6b6c73edd6e78ea9d85e428aac5065c1ca5efd590c9db32080431f3e770f746143c914028ebbe77a9e1effd78347e72933135d269447cf433913b350a0bbedc8a41e26382e70f95489981f9ce923db46a4f115b89c1b721f44b4254cd7c2ff2268300e8b4106163b43e467bedcd578001c651b14ccba73db89f8a4b26f3831f9b6be9818add3240ee73419f8b0422e3218be8310c430f2251ff87b078953deafe192a5577c1283d1d5724f03b454cd619b8f3784431c1405263f906faec210976688af6b26ec42c8a92401c1a54378e1f44bb539beb20ac36acb432fe83b1f19b3bc243154dd55dd635a14bc38647af89fad2328bdee4c1f32782d17829516e17f18033056078c9dfe7ae0d7785fe96cfd44ea9ae45bdcf66ed1df1f592f986d6362429f855d807ae1f2babc881a8c8d34f8fbe92f1790b39d7084913286917a23274254b56ef0c47b78b76d76fbbcadd5c6d004349ef1377c6698711370a7a5b70265f59f8336ee48ba136971a668861280cb4661db4a0a4c8201b9feb9ad1b748c5ff40b4f21b3192c4d9de1007555e8c4736eb29f28106bd405fedb54e5a13fdc42ba7acf837068c691fa11b3cf632302897b1f5dc13f4ff362e5510cea2d85b77d73d5d3243483e2ebac273036477923b5fae56f7c59a2e23b2a13aa83ca2b2f7068176e2eccf60bc44229508957a04ed6eafd84e7905a7475bca54ce4d052455d93d658792550cbc78eefa844d4c9ebec2fa7853e6c6ca77d8249dd62fe9a27cb2c8cc7c7e25a63599130dd17f419105e40fe4b7fa1324156a977311dc53664fcff917683d3c42d2e1fa6a4fcec3c40d06984269cd3b96dc1506a64b6cd8d6845bd2c3e237534523f63b86c898fb774c2be23f033f7c4b0b96833c3285cd31c79e32faeecf5e72288d6397d907b4fdc83b905726d5fe64ea92f8ae7dd03ca316221c0cecd9828d02738d1fc5212dd322acca6a6762eb10a0b56dc16e34ad1516564cdf6bf855a2a29c7105975465901f3de0d51765d21e3068fe51bb024060ba65d784fc9bc3b1d5b73020065c0386d8992af5df3c44ab9c263b72d37b9c7f9278cba7aecc9457acdc97220fc07027acf772a7cad97de68d09574cf11806f376b89fdf561f4555b6f8b8a4d981392ed86e2d38bf07d277f83650d2083949fcde3ff15478f9f6fce38227cb3368bd7f3ab754cd8b9f8f0f6fdfcdab8a689d8fad996f79430bd1ce05f5803fc6fc895ff68dd3969986523b200e3995751d85f03e39c184da57e513370ee4036215e164fc88f22b8455fad615c149fd4acab8edc71dde7614a768f0ca3ce4a27765e385aa0c5f020e63523145a2b44005be059c1dbb6c816879e2df35c8cf1c40d380fbae94648c1c4eddf3a978b9a7eb42eb78a439f16505ace09c8e0d891dff8d6d33000a99e22a95e49e5913cc5b9dc34de38e4a1e31e759efdb1f345f60b945ed39d47c03f25403e7131cb7d208976bc80ffa7f07b7fcaa3dd1f9a119b0a2b1027b0c1e902864f509788833f7cc80062ee34896c40f70b0ed1cde66faf9e1d2c9813ddf81b29e8436e8eb16ccb5909aea4eb972c4b558947a562301e7f75e4c0a4a2a73c94f5b83cf6dae37437131764f1ad376077dfad7fc2bde36214907f699dc2389a96794b7f9478b5566710ec364ccd8f0841ef8591051c2fcbb8d55369384990c7191b50b24870832b68d7dd3d3c5ef62ee93b05af53f2accb2abac86349e79f072fc061b546be1a98d1fdb57f8cf5ef698715f846a57ed9e49bbee751d0f6a2b0e6bf616c220c2246dcfd01bf15b5084dcdb161c6c0b2061f9f0d31af6b31aab0e74eb3ec2fb0add8e1ed8b66ac2499bb7d1421374dc93fafa4848589342407f0f77bf8bccb9f857e4c9e11371fb75c4dab7c9ca58d9886ff10fc5259bfa09bedb248969dea98d70961c9ee3fac4ef7f1c08891ec20a81dd085b82ce84a2f6a4591e16923185e55e79b190b1b14630430d49c9d48b569a0eb3d77f97a9e37282808b9641f0b7e06e50a9e772626a70c33d245e32fc03d7af7d1b346bb1f5ba14275b8fb492804ebac9629dc0f65f82a5e641ecfff624d91225e2ce3a8ffe5391b500eef673e668edf82e7e2099a720dc0507b1b14ff5334713b8790061ece844296182b60cd5f98c0868b1c2953ae1e7b574a0b177e0609915450d8ca6329c297e7aa032c866fc555c8d7545d2183be3a71db35dd6816b9ed9303124363a4f97428df47160c2ae5785b1b488b6ce861bf6611e13bf1af9329da2f3fcf2c1a016e33ddccb743aa0b03f4a17da417200cb8239ea98e7c9e7f41d5786c92e7bcbbf85afe17f7377ccbd80b2aadd803ee10b307019a68bd31da2ff5dc4efcd611b40124f5846afc831e95fabbe0015a6113e2e2bb00fd7a826c9f766302736bc0e98a2fccdfdb5b203a7e74d752cfd341e90a97a43870a2e9be3566edf290ee37e79cfbca7fc1862967b0ab9bc8e67766d1d0805725779cbc9f3bfce3c2a27be6e534db7b440dcf04d367650f8a984fc9ae2a995aa6e80bbf448bc86d1faa519e8721896aac4cd2c81d1993502da0f99b1fea369162950bc51c712173ab7533ccf160ce2202f16a88e1da744e8bcd27ddcfd538945fad8b0504234a93c69a08fd874a5e1cc763d1a11b9db2957182a5d0c090675b58c2e450d512ecd26cc329b52c60d9d6e14a0595b9852358095ac543517f8f465c9d9e60068e68cebcd9905affd3dd7b4e2f212e2c2d507f01e1b88476873ae0c94a842bef0798f3789617956c2059ec57d88d45cca4c10f5edf4c246fdd6e8033639c30832302baf5268d77fe6848fd6b9fd1a12ada9d981ac27814bb8d47220ea7812010740525171076d74eaebbd1658a63bdd81bc705589c7db64eb00b30a1bcf21838a37658b292512017c10a5481a425d7ac68a52e92571b9d775e9ade6974c6a450e07f4f23ed9b8371569bc2f06ca4414af82df582c7bb0ee020db70ed55c7da65f50c7a520b605733a27749ce593cefa45c6037aa95fc550654834c9a2e1e95c72dd13e7eba95ded5202623a85e899651795eed85641ac8a82b3cd000f5aca6583d3a559fc884c65387dfbe5fe46a6790944b3540c814ccfcf32b3a2ae21745160d4cc3a35bc9426592f578ef8b0c217afefb6c98fb7d8a28b1a877b6cc703d41601a8c0a8a443dfc107b32447c7651f366f07e4fea79fa927c71fff793bfa4a2d2616ae9cb2e6e377cee89e3a549d54a7b392118af1da3b2b78881b88fc19586fa3940a63796b84f98848f16fdebf8e3850ba23582931f79f80ab1c56675a52f5ecdf4c4ab0bfa99fa26e19edf6f8a32feeb5d929b5df0672a39f75fd1d3c7285ce698ef4aee6e6d4c0a23e9f280f79663a68c9bd2446d4f2c825596a4d87bc642d8623cec0471b093e70c99edf537a8abb104038755874b8f2937d357429b21ccacfeda7b484c314a0dac6cccfb1fb262c3009cc8706e36368406e0cab52c5af57c92aaeee50c5031431d0535457791c7cf3221f3f23bff1bb8492a7cb6541607e82666c8191f7853236a351e1e5435a0740921b4f17be1154714931238ff528f2e51a7726a6e01930322e505691fe45e7e944cb426ceb96ae671bf00d847ce3d0b35edaef00cc9cff5beb05b030fe274c5bd76415b2d1dce2f6b91f574a8d4d02f95281f452cb63d2058ca8419f506fa93ea9884af55d7e6bd1c8e86d9bf36f67296859c95014521b1881f22d9473e03b51c2633758f9a5ed601989366bbd34027dc1bd2d91f9440c6eab4104d3d20dd005720a804a17691ad88915fa90901851f3d000384a766081cf8ca10a4dddf223329f6fd0c9f38fdccd214de1b86200632a7ace276b9f1a7a9612503cb4190ed123ce5817d290786af62e1404c4c413ef6d22a64e338052ddf443d5dc01417c9d0d291239550cc2dcd54ce9a1c5492239dcaa86117242b16b540dc5894a10e914d754af0ed35aad12d08b1c7e22bdac91d764ab8b2ac6199896d8d105f7830603ec337da37acb5df196dbc3ee4dca42d5318166a0dcf75442b2473d4cb7cf498fa97ca6d87b1cbb4ec4242573c2c9276fd310d111d9f459428571e0823c22c9a2065c3e5f8251b4da149eb646047e981480fdcdd557b5775ecd39b00539944507a237e761d5a92795e22d8d0</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>青春回忆</tag>
        <tag>我与她</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书|2021阅读]--《月亮与六便士》</title>
    <url>/2021/04/22/Reading_2021--The_Moon_and_Sixpence.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>2021阅读开始啦，尽管之前也零零碎碎看了几本书，但我还是适合写写叙事类的小说吧，今年就从《月亮与六便士》开始了。<br><a id="more"></a></p>
</blockquote>
<h4 id="《月亮与六便士》"><a href="#《月亮与六便士》" class="headerlink" title="《月亮与六便士》"></a>《月亮与六便士》</h4><blockquote>
<p>阅读这本书的动机不大，只是最近失恋了，想多读读书提升自己，恰好这本书名声在外，没看书评和简介就开始读了。好巧不巧，这本书还真就包含了一部分爱情和梦想，跟预想的治愈心灵大相径庭，反而有种雪上加霜的感觉，这是天意吗/(ㄒoㄒ)/。</p>
<p>刚看开头枯燥难懂，讲的都是什么艺术家，什么艺术体系流派。咋一看真被唬住了，以为是一本介绍文艺复兴的纪实史，或者是针对开头介绍的人物的个人传记，会包含各种高深莫测的艺术赏析思想和术语，没想到到后面画风突变，又变成了一段爱恨情仇的小说。有人说这本书是讲追逐梦想的，也有人说这里面是包含了一种不正的爱情三观，只是被出版商的把戏炒成了畅销书。从我的角度来看，还是有收获的吧，这本书的故事并不轻松，甚至可以说有些沉重。结局也不好评判，对生活有不同态度的人会对结局有不同的看法吧。</p>
<p>首先从梦想的角度看吧，斯特里克兰依旧被塑造成为了一个性格怪异的传奇人物。尽管作者在文中提到:</p>
<blockquote>
<p><code>人类天生具有制造神话的特性，对于那些出类拔萃的人物，人们对发生在他们身上的奇闻逸事往往好奇心极强，编造出一个个传奇故事，然后对此深信不疑，达到近乎狂热的地步。这其实是浪漫主义对平庸生活的一种抗议。因此，一些传奇故事顺理成章地成为铸就不朽英雄的通行证。</code></p>
</blockquote>
<p>但实际上最后毛姆还是造就了一个与众不同的斯特里克兰，或许这样的大师本就与众不同，才能在芸芸众生之间鹤立鸡群。另一方面也或许正因为他们是大师/天才，业界传奇，所以他们的一切都被放大了，成为解释他们成功的理由。斯特里克兰四十多岁抛家弃子，放弃衣食无忧的生活走上了追逐艺术的道路，而且他很笃定，他不在意别人的看法，这是真的不在意，这是笃定地不断向前，不需要别人地认可，只是表达自己所想，活在自己自由的世界里。从生活环境的角度看，他是不幸的，大多数人都把梦想艺术看作酒足饭饱之后的精神满足，只有保证温饱后才能追求高层次的精神需求，这正式<code>马斯洛需求金字塔</code>，但斯特里克兰不一样，他似乎更看重自我实现上，当然这可能是我的片面理解。从这一点来说对主角很敬佩，但我也绝不大可能像主角一样放弃一切去逐梦，打破精神上的那层枷锁，实现自我。可能我是个大俗人吧。</p>
<p>如果看斯特里克兰的爱情，可以用一塌糊涂来形容吧。抛家弃子，拆散救命恩人的家庭，最后在孤岛上也留下苦命的妻女。可以说他似乎完全不在乎别人，他只在乎他自己还有他的画家梦，或者说是他对一种美，对一种精神上的追求，懵懵懂懂。但从他的绝情上看，确实描述得入木三分，对不爱的人那种绝情的言辞，真的让人很心痛，却又无懈可击，他这样的人活在自己想要的世界就已然足够了，别人的非议无关紧要，别人的生死哀愁痛苦也入不了他们的内心，可能连同情都没有，只有不屑一顾。从这方面来说，尽管敬佩他这样的处事态度，但这样的人却也是无论如何都喜欢不起来。</p>
<p>最后引用两段平常人的平庸爱情吧，感觉这是大多数人的人生：</p>
<blockquote>
<p>我能想象他们的生活，无灾无祸，日子过得踏实、体面，还有两个端庄、可爱的孩子，他们注定会弘扬良好的家风和地位。夫妻两个会在不知不觉中慢慢变老，看到一双儿女长大成人。到了适当的年龄他们的儿女便会结婚生子，漂亮的女儿将来会做个贤妻良母，生出健康活泼的孩子；而帅气的儿子也会成为英气逼人的男子汉，没准会成为一名军人。最后，这对夫妻开枝散叶后就会体面地隐退，子孙承欢膝下，过着充实、幸福的生活，到时寿终正寝，入土为安。</p>
</blockquote>
<hr>
<blockquote>
<p>爱情需要人们全神贯注，它使人忘掉自己去爱对方。最聪明的人虽然可能知道爱有尽头这道理，在实际中却不愿相信这一点。人们明知爱是虚幻，却还是为其放弃实实在在的东西，于他们而言，爱情胜过现实。爱情使一个人变得更强大，同时也使他变得更渺小。他们不再是自己。他们不再是人，而是成为一个物件、一个工具，要实现对于他们而言十分陌生的目的。</p>
</blockquote>
<hr>
<blockquote>
<p>“上帝的磨盘转得很慢，却也磨得很细。”<br>碰上这种情况一准会说：”魔鬼为达到目的总是会引用《圣经》。”</p>
</blockquote>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/The_Moon_and_Sixpence.jpg" alt="月亮与六便士"></p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>第四周LeetCode</title>
    <url>/2019/04/18/forth-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第四周LeetCode刷题记录"><a href="#第四周LeetCode刷题记录" class="headerlink" title="第四周LeetCode刷题记录"></a>第四周LeetCode刷题记录</h2><a id="more"></a>
<ol>
<li><a href="http://wuyunjie.top/2019/04/14/LeetCode-20-Valid-Parentheses/" target="_blank" rel="noopener" title="LeetCode--20. Valid Parentheses">LeetCode—20. Valid Parentheses</a></li>
<li><a href="http://wuyunjie.top/2019/04/14/LeetCode-21-Merge-Two-Sorted-Lists/" target="_blank" rel="noopener" title="LeetCode--21. Merge Two Sorted Lists">LeetCode—21. Merge Two Sorted Lists</a></li>
<li><a href="http://wuyunjie.top/2019/04/14/LeetCode-22-Generate-Parentheses/" target="_blank" rel="noopener" title="LeetCode--22. Generate Parentheses">LeetCode—22. Generate Parentheses</a></li>
<li><a href="http://wuyunjie.top/2019/04/16/LeetCode-23-Merge-k-Sorted-Lists/" target="_blank" rel="noopener" title="LeetCode--23. Merge k Sorted Lists">LeetCode—23. Merge k Sorted Lists</a></li>
<li><a href="http://wuyunjie.top/2019/04/16/LeetCode-24-Swap-Nodes-in-Pairs/" target="_blank" rel="noopener" title="LeetCode--24. Swap Nodes in Pairs">LeetCode—24. Swap Nodes in Pairs</a></li>
<li><a href="http://wuyunjie.top/2019/04/16/LeetCode-25-Reverse-Nodes-in-k-Group/" target="_blank" rel="noopener" title="LeetCode--25. Reverse Nodes in k-Group">LeetCode—25. Reverse Nodes in k-Group</a></li>
<li><a href="http://wuyunjie.top/2019/04/17/LeetCode-26-Remove-Duplicates-from-Sorted-Array/" target="_blank" rel="noopener" title="LeetCode--26. Remove Duplicates from Sorted Array">LeetCode—26. Remove Duplicates from Sorted Array</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>第二周LeetCode</title>
    <url>/2019/04/03/second-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第二周LeetCode刷题记录"><a href="#第二周LeetCode刷题记录" class="headerlink" title="第二周LeetCode刷题记录"></a>第二周LeetCode刷题记录</h2><a id="more"></a>
<ol>
<li><a href="http://wuyunjie.top/2019/03/31/LeetCode-4-Median-of-Two-Sorted-Arrays/" target="_blank" rel="noopener" title="LeetCode--4. Median of Two Sorted Arrays">LeetCode—4. Median of Two Sorted Arrays</a></li>
<li><a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%945-Longest-Palindromic-Substring/" target="_blank" rel="noopener" title="LeetCode——5. Longest Palindromic Substring">LeetCode—5. Longest Palindromic Substring</a></li>
<li><a href="http://wuyunjie.top/2019/04/01/LeetCode%E2%80%94%E2%80%946-ZigZag-Conversion/" target="_blank" rel="noopener" title="LeetCode——6. ZigZag Conversion">LeetCode—6. ZigZag Conversion</a></li>
<li><a href="http://wuyunjie.top/2019/03/31/LeetCode-8-String-to-Integer-atoi/" target="_blank" rel="noopener" title="LeetCode--8. String to Integer (atoi)">LeetCode—8. String to Integer (atoi)</a></li>
<li><a href="http://wuyunjie.top/2019/04/02/LeetCode-9-Palindrome-Number/" target="_blank" rel="noopener" title="LeetCode--9. Palindrome Number">LeetCode—9. Palindrome Number</a></li>
<li><a href="http://wuyunjie.top/2019/04/03/LeetCode-11-Container-With-Most-Water/" target="_blank" rel="noopener" title="LeetCode--11. Container With Most Water">LeetCode—11. Container With Most Water</a></li>
<li><a href="http://wuyunjie.top/2019/04/03/LeetCode-12-Integer-to-Roman/" target="_blank" rel="noopener" title="LeetCode--12. Integer to Roman">LeetCode—12. Integer to Roman</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书]--2020 阅读清单</title>
    <url>/2020/09/11/Reading--2020_Reading_List.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>决定要开始好好读书了，需要一个仪式感来督促自己，写个书单记录一下<br><a id="more"></a></p>
</blockquote>
<h4 id="1-天蓝色的彼岸"><a href="#1-天蓝色的彼岸" class="headerlink" title="1. 天蓝色的彼岸"></a>1. 天蓝色的彼岸</h4><blockquote>
<p>这本书是一个温馨的童话故事，由 <strong><code>梁忆云</code></strong> 小姑娘倾情推荐。从一个小孩子的角度描述了去世后的世界，没有天堂，没有地域，只有<code>天蓝色的彼岸</code>，那是我们的最终归宿。</p>
<p>没有花大量笔墨描述另一个世界是什么，而是回到了原来的世界去弥补遗憾，顺带看看没有了<code>我</code>的世界会不会不一样。遗憾的是，世界照样会正常运转，只有最亲近的人会为<code>我</code>哀思。哈里从不可思议到不留遗憾向世界告别，整个过程穿插着各种人物的小故事，有阿瑟的温馨，也有依旧等待着温斯顿的斯坦。它教导我们: <strong>要珍惜生，但不必畏惧死</strong>。很治愈。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/The_Great_Blue_Yonder.jpg" alt="天蓝色的彼岸"></p>
<h4 id="2-追风筝的人"><a href="#2-追风筝的人" class="headerlink" title="2. 追风筝的人"></a>2. 追风筝的人</h4><blockquote>
<p>这本书还是去年开始读的, 或者准确来说是<code>听</code>的。去年刚上研究生独自留校, 在学校附件租房, 晚上回去的路上十分宁静寻思找点事做。从最最开始听歌听相声后, 开始逐渐喜欢上了听书, 也是这段时间在喜马拉雅上听了<code>追风筝的人</code>。但后来开学后没时间听书了, 也就搁置了, 一年了也没看完最后两章结局(这拖延症也是绝了)。最近两天开始读书, 又把它拿出来读了读。</p>
<p>最开始听说这本书时, 以为是逐梦+友谊的治愈类小说, 但实际上是遗憾、成长, 以及阿富汗的战乱, 二十年后的物是人非。阿米尔和仆人哈桑少年的友谊纯粹而干净, 但在残酷的社会环境现实面前, 懦弱而渐生偏见的阿米尔, 选择了沉默和逃避。他做了最错误的选择，设计赶走了哈桑, 可以<code>“为你，千千万万遍”</code> 的挚友。此后阿富汗战乱, 社会动荡, 哈桑也就此与阿米尔阴阳两隔。之后是寻求救赎的成长, 阿米尔收到拉辛汗来信决定赴约阿富汗并救回了哈桑的儿子, 自己的侄子索拉博。他不再是少年时对哈桑沉默逃避的阿米尔, 是在寻求救赎中勇敢果决, 抛弃偏见挺身而出, 最终坦然接受的阿米尔。阿米尔与哈桑的友谊固然光芒闪耀令人生叹, 但阿米尔的成长却更加打动人心。</p>
<p>在故事结尾, 作者对<code>结局</code>进行了一个简短讨论。</p>
<blockquote>
<p><code>阿富汗人喜欢说: 生活总会继续。他们不关心开始或结束、成功或失败、危在旦夕或柳暗花明，只顾像游牧部落那样风尘仆仆地缓慢前行</code>。</p>
</blockquote>
<p>或许我们有时候并不知道人生的方向, 路的终点, 但也不必知道, 我们在风尘仆仆的路途经历或许更加诱人而回味。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/kite_runner.jpg" alt="追风筝的人"></p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
</search>
