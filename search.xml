<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AdPart复现--问题集锦</title>
    <url>/2019/11/23/AdPart-Repeat-Problem-Collect.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在复现分布式RDF引擎<code>AdPart</code>, 复现过程中遇到了一些小问题, 就在这里记录一下吧。<br><a id="more"></a></p>
<h3 id="Problem-and-Solve"><a href="#Problem-and-Solve" class="headerlink" title="Problem and Solve"></a>Problem and Solve</h3><h4 id="g-编译问题"><a href="#g-编译问题" class="headerlink" title="g++ 编译问题"></a>g++ 编译问题</h4><p>因为对 <code>g++</code> 编译项目不太熟悉, 这也是第一次自己写一个完整的项目并用 <code>g++</code> 来编译, 难免许多基础都不会。遇到了下面这个报错:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">undefined reference to &apos;Foo::Foo(std::string)&apos;</span><br></pre></td></tr></table></figure><br>这个问题卡了我很久, 什么修改 <code>g++</code> 版本, 不使用<code>c++11</code>都试过，还一度怀疑是不是我代码写的有问题。后来发现是一个很简单的原因，没有在编译的时候将<code>Foo.cpp</code>(用这个来代指我的问题)添加进去, 也就是我编译的时候差不多是这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o testFoo</span><br></pre></td></tr></table></figure><br>但是实际上需要是这样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ main.cpp Foo.cpp -o testFoo</span><br></pre></td></tr></table></figure><br>修改完之后成功编译, 还是对 <code>g++</code> 不熟, 得抽时间学学 <code>g++</code> 怎么编译 <code>c++</code> 代码了。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<ul>
<li><a href="https://stackoverflow.com/questions/3656050/c-undefined-reference-to-foofoostdstring" target="_blank" rel="noopener">c++ “ undefined reference to ‘Foo::Foo(std::string)’ ”</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>AdPart复现</category>
      </categories>
      <tags>
        <tag>AdPart</tag>
        <tag>代码复现</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习--基础</title>
    <url>/2019/11/23/Git-learning-foundation.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Git</code> 是一个”版本控制”工具, 可以用来管理我们的代码。简单来说, 就是可以像玩游戏一样, 给一定时间的代码存档, 以后就可以通过”读档”回退到以前的状态。<br><a id="more"></a><br>Git 是<strong>分布式版本控制系统</strong>, 每个项目协作者电脑里都有完整的版本库, 完成修改后, 只需把各自的修改推送给其他人就可以让别人看见自己的修改, 也有充当“中央服务器”的电脑方便“交换”大家的修改。</p>
<p>这里版本库又名仓库，即<em>repository</em>，可以简单理解成一个目录，这个目录里面的所有文件都可以被<code>Git</code>管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以”还原”。</p>
<h3 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h3><p>安装 Git 之后, 使用之前需要先进行一些配置, 主要进行如下配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Zhang San&quot;            # your name</span><br><span class="line">$ git config --global user.email &quot;zhangsan@foo.com&quot;    # your email</span><br><span class="line">$ git config --global core.editor vim                  # your favourite editor</span><br><span class="line">$ git config --global color.ui true                    # your git color</span><br></pre></td></tr></table></figure><br>前两个命令设置基本的用户信息, <code>core.editor</code>可以设置自己喜欢的文本编辑器, <code>color.ui</code> 能为输出到你终端的内容着色，以便你可以凭直观进行快速、简单地分析</p>
<h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>现在可以开始用<code>Git</code>来管理代码了。首先需要将项目的目录初始化为Git可以管理的仓库, 切换到实验/项目的目录中, 然后输入:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init    # 初始化仓库</span><br></pre></td></tr></table></figure><br>我们通过 git clone 命令下载项目, 里面已经包含一些 git 记录, 因此不需要额外进行初始化。</p>
<h4 id="查看版本信息"><a href="#查看版本信息" class="headerlink" title="查看版本信息"></a>查看版本信息</h4><p>主要使用以下两条命令查看版本信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log        # 查看目前为止所有的存档.</span><br><span class="line">$ git status     # 查看与当前存档相比, 哪些文件发生了变化</span><br></pre></td></tr></table></figure></p>
<h4 id="存档"><a href="#存档" class="headerlink" title="存档"></a>存档</h4><p>首先你需要使用 git status 查看是否有新的文件或已修改的文件未被跟踪, 可以使用以下命令将修改的文件加入跟踪列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add file.c    # 将文件 file.c 加入跟踪列表</span><br></pre></td></tr></table></figure><br>如果需要一次添加所有未被跟踪的文件, 也可以使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add .     # 把工作时的所有变化提交到暂存区, 包括文件内容修改(modified)以及新文件(new), 但不包括被删除的文件</span><br><span class="line">$ git add -u    # 仅监控已经被add的文件(即tracked file), 他会将被修改的文件提交到暂存区。(git add --update的缩写)</span><br><span class="line">$ git add -A    # 是上面两个功能的合集(git add --all的缩写), 提交所有变化</span><br></pre></td></tr></table></figure><br>可以通过编辑 <code>.gitignore</code> 文件, 在里面给出需要被 git 忽略的文件和文件类型从而筛选文件。新文件加入跟踪列表, 确认无误后就可以存档了:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit    # 提交工程当前的状态</span><br></pre></td></tr></table></figure><br>执行这条命令后, 需要添加本次存档的注释, 可以根据这些注释来区别和寻找不同的存档。</p>
<h4 id="读档"><a href="#读档" class="headerlink" title="读档"></a>读档</h4><p>首先使用 git log 来查看已有的存档, 并通过存档的 <code>hash code</code> 来回到过去。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard &lt;code&gt;</span><br></pre></td></tr></table></figure><br><code>hard</code>模式会把你工作目录中所有未提交的内容清空, 所以需要慎用。</p>
<h4 id="分支功能"><a href="#分支功能" class="headerlink" title="分支功能"></a>分支功能</h4><p>这就是 <code>Git</code> 的分支功能可以让我们创建不同的世界线, 即在一个时刻, 我们可以做出不同的选择, 使得多个”平行宇宙”并行存在:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch    # 查看所有分支</span><br></pre></td></tr></table></figure><br>使用 <code>git init</code> 初始化之后会自动建立主分支 <code>master</code>。可以用以下命令创建一个新的分支:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b &lt;分支名&gt;    # 创建并切换分支</span><br></pre></td></tr></table></figure><br>我们可以将新分支上的修改合并到主分支上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge &lt;分支名&gt;    # 合并指定分支到当前分支</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<ul>
<li><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/git.html" target="_blank" rel="noopener">git快速入门</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></li>
<li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Git Book(官方文档)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo学习记录--功能升级</title>
    <url>/2019/11/14/hexo-learning-record--Feature-Upgrade.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>增加一些新功能, 丰富一下博客内容和界面, 就是一些花里胡哨的东西。<br><a id="more"></a></p>
<h3 id="LeanCloud添加文章阅读量"><a href="#LeanCloud添加文章阅读量" class="headerlink" title="LeanCloud添加文章阅读量"></a>LeanCloud添加文章阅读量</h3><p>操作很简单，在 <code>LeanCloud</code>注册账号后，创建一个应用即可，主要参考官网教程和一些网上的博客：</p>
<blockquote>
<ul>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">开始使用</a></li>
<li><a href="https://blog.csdn.net/weixin_39345384/article/details/80787998" target="_blank" rel="noopener">NexT主题下，用Leancloud统计文章阅读量</a></li>
</ul>
</blockquote>
<p>这里需要注意的主要是需要安装 <strong>Web安全</strong> 模块，否者无法正常使用<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-leancloud-counter-security --save</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>主要参考这个博客解决问题 <a href="https://blog.csdn.net/w573719227/article/details/100704952" target="_blank" rel="noopener">HEXO博客使用LeanCloud报错“Counter not initialized! See more at console err msg.”</a></li>
</ul>
</blockquote>
<p>这里还有一个问题, 就是链接里带中文名, 所以导致链接在<code>leancloud</code>中以特殊字符形式存在, 在统计访问次数时出错。需要将其转换为英文的链接地址, 这里使用<a href="https://hexo.io/zh-cn/docs/permalinks.html" target="_blank" rel="noopener">Hexo-永久链接(Permalinks)</a>的方法，自定义链接地址，最终阅读量正常实现。</p>
<h3 id="永久链接（Permalinks）"><a href="#永久链接（Permalinks）" class="headerlink" title="永久链接（Permalinks）"></a>永久链接（Permalinks）</h3><p>可以在博客根目录的配置文件（<code>_config.yml</code>）中这样修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:entitle.html</span></span><br></pre></td></tr></table></figure>
<p>其中<code>entitle</code>是自定义的一个属性，同时在<code>.\scaffolds\post.md</code>中修改：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">entitle: </span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这样在编写文章时，可以在<code>entitle</code>输入指定字符，作为文章链接地址</p>
<blockquote>
<ul>
<li>参考文章<a href="https://blog.csdn.net/Likianta/article/details/79343427" target="_blank" rel="noopener">如何让你的Hexo博客网址使用全英文路径</a></li>
</ul>
</blockquote>
<h3 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a>不蒜子统计</h3><p>更新到新版本后，启用不蒜子统计很简单，只需要在主题配置文件中启用即可：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">false</span> <span class="comment"># 与leancloud重复，故注释掉</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure>
<p>应该也可以用leancloud实现类似功能，但懒得折腾了，就直接<code>不蒜子统计</code>一块用吧。</p>
<h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><p>启用字数统计需要安装一个插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>之后设置配置文件即可：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>
<h3 id="加载进度条"><a href="#加载进度条" class="headerlink" title="加载进度条"></a>加载进度条</h3><p>同样需要安装一下依赖库，不过他的安装方法与之前不同，不是用<code>npm</code>命令来安装，而是直接添加到主题的<code>lib</code>中：</p>
<ol>
<li><p>进入博客文件夹的<code>/themes/next</code>文件夹下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog_folder/themes/next-update # 注意转换为对应主题路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>载安装<code>Progress module</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-pace source/lib/pace</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>/themes/next/_config.yml</code>中设置使生效</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">bounce</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="GitHub图床"><a href="#GitHub图床" class="headerlink" title="GitHub图床"></a>GitHub图床</h3><p>在写博客时，我们常常需要在博客中插入图片什么的。这时一般需要一个图床，免费的图床有很多，但是上传文件后只能得到一个链接，不知道什么时候会丢失链接或者干脆图床网站不维护了。我们可以利用<code>GitHub</code>建立一个图床仓库，方便管理。顺便也可以练习一下<code>Git</code>的使用。如下图就是建立的一个图床仓库：<br><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/GitHubImageRepository.PNG" alt="GitHub图床"></p>
<blockquote>
<p>这里需要注意的一点是，GitHub图片的地址需要是源文件地址，比如上图的地址：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/GitHubImageRepository.PNG</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>之前一直用的<code>GitHub</code>下文件的url(<code>https://github.com</code>开头)，一直不显示，还以为是图片格式不兼容，笑哭。</p>
<h3 id="表格显示问题"><a href="#表格显示问题" class="headerlink" title="表格显示问题"></a>表格显示问题</h3><p><code>table</code>表格显示异常，直接不显示表格。一开始以为是渲染器，语法什么的问题，后来发现原来解决方法很简单，表格和正文之间需要空行。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">测试</th>
<th style="text-align:left">表格</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">正常</td>
<td style="text-align:left">显示</td>
</tr>
</tbody>
</table>
</div>
<h3 id="加入豆瓣书单"><a href="#加入豆瓣书单" class="headerlink" title="加入豆瓣书单"></a>加入豆瓣书单</h3><p>直接安装豆瓣依赖模块 <code>$ npm install hexo-douban --save</code>, 简单易操作。配置上需要在 <code>hexo</code> 配置文件中加入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">douban:</span><br><span class="line">  user: mythsman</span><br><span class="line">  builtin: false</span><br><span class="line">  book:</span><br><span class="line">    title: &apos;This is my book title&apos;</span><br><span class="line">    quote: &apos;This is my book quote&apos;</span><br><span class="line">  movie:</span><br><span class="line">    title: &apos;This is my movie title&apos;</span><br><span class="line">    quote: &apos;This is my movie quote&apos;</span><br><span class="line">  game:</span><br><span class="line">    title: &apos;This is my game title&apos;</span><br><span class="line">    quote: &apos;This is my game quote&apos;</span><br><span class="line">  timeout: 10000</span><br></pre></td></tr></table></figure></p>
<p>然后部署到主题文件中, <code>next</code> 主题下设置为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives</span><br><span class="line">  books: /books     # 这是链接到books页面</span><br><span class="line">  movies: /movies   #  这是链接到movies页面</span><br><span class="line">  games: /games   # 这是链接到games页面</span><br></pre></td></tr></table></figure></p>
<p>之后在启动过程中加入命令 <code>hexo douban -bgm</code> 自动抓取相关信息生成页面。 其中开启 <code>hexo-douban</code> 的命令中，<code>-bgm</code> 代表的是 <code>book、game、movie</code> 三个参数。</p>
<h3 id="加入搜索功能"><a href="#加入搜索功能" class="headerlink" title="加入搜索功能"></a>加入搜索功能</h3><ol>
<li><p>安装本地搜索插件 <code>hexo-generator-search</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
<p>安装之后，会在站点目录的 <code>public</code> 文件夹下创建一个 <code>search.xml</code> 文件</p>
</li>
<li><p>在站点配置文件 <code>_config.yml</code> 中添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Search </span><br><span class="line">search:</span><br><span class="line">  path: ./public/search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p><code>field</code>：搜索范围，默认是 <code>post</code>，还可以选择 <code>page</code>、<code>all</code>，设置成 <code>all</code> 表示搜索所有页面<br><code>limit</code>：限制搜索的条目数</p>
</li>
<li><p>主题配置文件<br>在主题配置文件 <code>_config.yml</code> 中找到如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  trigger: auto</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>
<p>确保 <code>enable</code> 设成 <code>true</code>。</p>
</li>
</ol>
<h3 id="加入评论系统-基于Valine"><a href="#加入评论系统-基于Valine" class="headerlink" title="加入评论系统(基于Valine)"></a>加入评论系统(基于Valine)</h3><ol>
<li><p>获取 <code>APP ID</code> 和 <code>APP Key</code><br> 先登录或注册 <code>LeanCloud</code>, 进入控制台后创建应用。选择<code>设置</code>&gt;<code>应用Key</code>，就可以获取<code>APP ID</code>和<code>APP Key</code>了。</p>
</li>
<li><p>在<code>next</code>主题中配置<code>valine</code><br>在主题配置文件 <code>_config.yml</code> 中找到<code>comments</code>栏目并开启<code>valine</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comments:</span><br><span class="line">  active: valine</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>然后在该配置文件中找到<code>valine</code>设置栏，开启<code>valine</code>并填入<code>appid</code>和<code>appkey</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid: # your app id</span><br><span class="line">  appkey: # your app key</span><br><span class="line">  notify: true # 评论回复邮件提醒, See: https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # 验证码服务</span><br><span class="line">  placeholder: 留言区 # 评论框占位提示符</span><br><span class="line">  avatar: mm # 头像配置</span><br><span class="line">  guest_info: nick,mail,link # 回复要填写的信息</span><br><span class="line">  pageSize: 10 # 评论列表分页，每页条数</span><br><span class="line">  visitor: false # 文章访问量统计 </span><br><span class="line">  comment_count: true # if false, comment count will only be displayed in post page, not in home page</span><br></pre></td></tr></table></figure></p>
<ol>
<li>由于<code>valine 1.4</code>版本后，不再支持自带的<code>邮件提醒</code>，所以这里使用第三方<code>Valine-Admin</code>，基于<code>Leancloud</code>的云引擎与云函数。功能更完善，主要部署方法可以查阅<code>github</code>:<a href="https://github.com/DesertsP/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a>。<blockquote>
<p>PS: 这里<code>Leancloud</code><strong>一定要用国际版</strong>，可以少去很多麻烦。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Hexo</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--10 数字和静态</title>
    <url>/2021/05/14/JavaLearning_Head_First_Java_10_numbers_and_statics.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>盘算一下。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-静态（static）"><a href="#1-静态（static）" class="headerlink" title="1. 静态（static）"></a>1. 静态（static）</h3><h4 id="1-1-静态方法"><a href="#1-1-静态方法" class="headerlink" title="1.1 静态方法"></a>1.1 静态方法</h4><p>在<code>Java</code>中没有<code>全局(global)</code>方法。但有些类中的方法不需要实例变量，为这样的类在堆上建立实例时很浪费的。</p>
<blockquote>
<p><code>Math</code>方法是最接近全局的方法。</p>
</blockquote>
<p><code>Math</code>类中所有方法都不需要实例变量，这些方法都是<code>静态(static)</code>的。而且无需也无法创建<code>Math</code>实例，只会用到它的类本身：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = Math.round(<span class="number">42.2</span>);</span><br><span class="line"><span class="keyword">int</span> y = Math.min(<span class="number">56</span>,<span class="number">12</span>);</span><br><span class="line"><span class="keyword">int</span> z = Math.abs(-<span class="number">343</span>);</span><br></pre></td></tr></table></figure>
<p><code>Java</code>中使用<code>static</code>这一关键词来标记出不需要实例的方法。一个静态方法代表<u><strong>一种不依靠实例变量(对象)的行为</strong></u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">     <span class="comment">//returns the lesser of a and b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以类名调用静态方法，以引用变量名调用非静态方法。</p>
</blockquote>
<p>带有静态方法的类通常会被设置为不可初始化。除了把类定义为抽象类之外，也可以<strong>把构造函数标记为私有</strong>防止类被初始化。但带有静态方法的类也可以被初始化(比如带有<code>main()</code>函数的类，<code>main()</code>函数是一个静态方法)</p>
<blockquote>
<p>静态方法不能调用非静态的变量。静态方法无法引用到该类的任何实例变量，静态方法也不能调用非静态的方法。</p>
</blockquote>
<p>可以用实例变量来调用静态方法，但编译器会解析出原来的类，并不会知道是哪个对象引用调用的该静态方法。</p>
<h4 id="1-2-静态变量"><a href="#1-2-静态变量" class="headerlink" title="1.2 静态变量"></a>1.2 静态变量</h4><p>静态变量的值对所有实例来说都相同，而且该变量被所有实例共享。比如要计算当前<code>Duck</code>实例的数量，或许可以在构造函数中递增计算器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> duckCount = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         duckCount++;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但由于<code>duckCount</code>是实例变量，每个<code>Duck</code>对象都会将其初始化为0。而将其设置为静态变量可以实现所需要的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> duckCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         duckCount++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">         size = s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态变量只在类第一次载入时初始化。同一个类所有实例共享一份静态变量。</p>
</blockquote>
<p><code>Java</code>虚拟机会加载某个类主要因为第一次被尝试创建该类的实例，或使用该类的静态方法或变量时。静态项目的初始化又两项保证：</p>
<blockquote>
<ul>
<li>静态变量会在该类的任何对象创建前就完成初始化。</li>
<li>静态变量会在该类的任何静态方法执行前就初始化。</li>
</ul>
</blockquote>
<p>被标记为<code>final</code>的变量代表该变量初始化后就不会改动，是一个常数。而静态的<code>final</code>变量在类加载后就会一致维持原值。</p>
<blockquote>
<p><code>静态初始化程序(static initializer)</code>是一段在加载类时会执行的程序代码，会在其他程序可以使用该类前执行，所有适合放置<code>静态final变量</code>在该部分。</p>
<p>根据<code>命名惯例(naming convention)</code>，常数变量的名称应该都是大写字母！</p>
</blockquote>
<p><code>静态final变量</code>可以通过两种方法初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 在声明时初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FOO_X = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在静态初始化程序中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> BAR_SIGN;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">static</span> &#123; <span class="comment">// 这部分代码在类加载时就执行，早于任何方法或静态变量被使用之前</span></span><br><span class="line">         BAR_SIGN = (<span class="keyword">double</span>) Math.random();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若未使用上述方法为<code>静态final变量</code>初始化，编译器会报错。</p>
<blockquote>
<p><code>final</code>还可以修饰其他变量，方法甚至类</p>
<ul>
<li><code>final</code>变量代表不能改变它的值；</li>
<li><code>final</code>方法代表不能覆盖该方法；</li>
<li><code>final</code>类代表不能继承该类；</li>
</ul>
</blockquote>
<h3 id="2-数字"><a href="#2-数字" class="headerlink" title="2. 数字"></a>2. 数字</h3><h4 id="2-1-Math方法"><a href="#2-1-Math方法" class="headerlink" title="2.1 Math方法"></a>2.1 <code>Math</code>方法</h4><p>下面是对<code>Math</code>方法的一些结束：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/mathMethods.PNG" alt="`Math`方法"></p>
<h4 id="2-2-primitive主数据类型包装"><a href="#2-2-primitive主数据类型包装" class="headerlink" title="2.2 primitive主数据类型包装"></a>2.2 <code>primitive</code>主数据类型包装</h4><p>把<code>primitive</code>主数据类型当作对象来处理，需要一个包装该数据类型的类。每个<code>primitive</code>主数据类型都有一个包装类，存放在<code>java.lang</code>这个包中。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/wrapperClasses.PNG" alt="包装类"></p>
<p>包装类将<code>primitive</code>主数据类型名称第一个字母大写，以符合命名惯例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包装值</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">288</span>;</span><br><span class="line">Integer iWrap = <span class="keyword">new</span> Integer(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解开包装</span></span><br><span class="line"><span class="keyword">int</span> unWrapped = iWrap.intValue();</span><br></pre></td></tr></table></figure>
<h4 id="2-3-autoboxing"><a href="#2-3-autoboxing" class="headerlink" title="2.3 autoboxing"></a>2.3 <code>autoboxing</code></h4><p><code>java 5.0</code>以后加入了<code>autoboxing</code>，自动将<code>primitive</code>主数据类型转换成包装过的对象。</p>
<blockquote>
<p>但依旧无法直接声明<code>ArrayList&lt;int&gt;</code>，因为<code>generic</code>类型的规则是只能指定类或接口类型，因此<code>ArrayList&lt;int&gt;</code>无法通过编译。但可以把该包装对象的<code>primitive</code>主数据类型直接放入<code>ArrayList</code>中。</p>
</blockquote>
<p><code>autoboxing</code>除了在包装或解包<code>primitive</code>主数据类型给<code>collection</code>之外，还可以用到其他地方：</p>
<ul>
<li><p>方法的参数</p>
<p>参数是包装类型，可以传入相应的<code>primitive</code>主数据类型。反之亦然。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">takeNumber</span><span class="params">(Integer i)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值</p>
<p>如果方法声明为返回某些<code>primitive</code>主数据类型，也可以返回兼容的包装类型。</p>
</li>
<li><p><code>boolean</code>表达式</p>
<p>可以使用<code>Boolean</code>包装类型</p>
</li>
<li><p>数值运算</p>
<p>可以直接对包装类型进行数值运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">42</span>); </span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">5</span>); </span><br><span class="line">Integer k = j + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值</p>
<p>将包装类型赋值给<code>primitive</code>主数据类型或相反。</p>
</li>
</ul>
<p>包装内也有实用的静态方法，比如字符串和主数据类型的转化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = Integer.parseInt(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">double</span> d = Double.parseDouble(“<span class="number">420.24</span>”);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意没有<code>Boolean.parseBoolean()</code>方法，但<code>Boolean</code>构造函数可以用<code>String</code>类型创建对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">42.5</span>;</span><br><span class="line">String doubleString = <span class="string">""</span> + d; <span class="comment">// "+"运算符是Java中唯一重载过的运算符，作为字符串拼接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">42.5</span>;</span><br><span class="line">String doubleString = Double.toString(d);</span><br></pre></td></tr></table></figure>
<h4 id="2-4-数字格式"><a href="#2-4-数字格式" class="headerlink" title="2.4 数字格式"></a>2.4 数字格式</h4><p>Java中数字与日期的<code>格式化</code>功能没有结合在输入/输出功能上。该功能在<code>java 5.0</code>以后由<code>java.lang</code>中的<code>Formatter</code>类来提供，该类的功能加入到了部分输入/输出类和<code>String</code>中。可以直接调用<strong>静态</strong>的<code>String.format()</code>来实现格式设定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = String.format(<span class="string">"%, d"</span>, <span class="number">1000000000</span>); <span class="comment">// 将数字以带逗号的形式格式化</span></span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>
<p>格式化主要由两个主要部分组成：</p>
<ol>
<li><strong>格式指令</strong>。概述要输出的特殊格式。</li>
<li><strong>要格式化的值</strong>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/formatString.PNG" alt="格式化"></p>
<p>格式化说明中，跟在<code>百分号(%)</code>后面包括类型指示(如<code>d</code>或<code>f</code>)的每个东西都是格式化指令，类型指示后的字符被视作直接输出的字符串。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/formatSpecifier.PNG" alt="格式化说明"></p>
<blockquote>
<p>类型是唯一的必填项</p>
<p><code>format()</code>使用<code>可变参数列表(variable argument lists, varargs)</code>来对应有不同数目排列组合的参数。</p>
</blockquote>
<h4 id="2-5-日期格式"><a href="#2-5-日期格式" class="headerlink" title="2.5 日期格式"></a>2.5 日期格式</h4><p><code>Date</code>类型是Java上表示时间用的，数值与日期时间格式化的主要差别在于日期格式的类型是用<code>&quot;t&quot;</code>开头的两个字符表示：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dateFormat.PNG" alt="日期格式"></p>
<p><code>java.util.Date</code>适合用于查看当前日期时间，但许多功能已经停用。更多功能推荐使用API <code>java.util.Calendar</code>。<code>Calendar</code>是一个抽象类，当需要<code>Calendar</code>类型时，需要从<code>JVM</code>获取一个子类实例。需要用到静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br></pre></td></tr></table></figure>
<p>通过调用<code>getInstance()</code>会返回一个具体子类的实例。一般默认返回<code>java.util.GregorianCalendar</code>的实例。<code>Calendar</code>类的几个关键特性：</p>
<ul>
<li>字段会保持状态。比如可以读取或设置<code>year</code>或<code>month</code>字段；</li>
<li>日期和时间可以运算。</li>
<li>日期与时间可以用<code>milliseconds</code>表示。即可以将日期转化为微秒，也可以将微秒转换为日期。(相对于<code>1970年1月1日</code>的微秒数)。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/CalendarExample.PNG" alt="Calendar示例"></p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--12 图形用户接口</title>
    <url>/2021/05/17/JavaLearning_Head_First_Java_11_getting_gui.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>面对现实，你得做出图形用户接口。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-window"><a href="#1-window" class="headerlink" title="1. window"></a>1. window</h3><p><code>JFrame</code>是代表屏幕上window的对象，可以把<code>button</code>，<code>checkbox</code>，<code>text</code>字段等接口放在window上。标准的<code>menu</code>也可以加到上面。</p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--11 异常处理</title>
    <url>/2021/05/14/JavaLearning_Head_First_Java_11_exception_handling.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>倒霉的事情就算会发生。找不到文件、服务器出现故障。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h3><p>需要对可能发生的异常情况进行处理，<strong>未雨绸缪</strong>！Java的<code>异常处理机制(exception-handling)</code>将处理错误状况的代码放在一个容易阅读的位置。如果知道调用某个方法可能会有异常情况，可以预先准备问题处理程序甚至从错误中恢复。</p>
<blockquote>
<p>异常是一种<code>Exception</code>类型的对象。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/exceptionClass.PNG" alt="异常类"></p>
<ul>
<li><p><strong>抛出异常(throws)</strong>。使用<code>throws</code>语句来抛出异常。</p>
<p>在编写可能会抛出异常的方法时，必须先声明有异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeRisk</span><span class="params">()</span> <span class="keyword">throws</span> BadException </span>&#123; <span class="comment">// 声明会抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> (abandonAllHope) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BadException(); <span class="comment">// 创建异常对象并抛出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意声明时是<code>throws</code>，抛出时是<code>throw</code>。</p>
</blockquote>
</li>
<li><p><strong>捕捉异常(catch)</strong>。使用<code>try/catch</code>块来捕捉处理异常。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 有风险的动作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>非<code>RuntimeExceptions</code>子类的异常由编译器检查，称作<code>检查异常(checked exceptions)</code>；<code>RuntimeExceptions</code>类称为<code>非检查异常</code>，编译器不会检查。编译器会确保：</p>
<ol>
<li>如果有抛出异常，一定使用了<code>throws</code>来声明</li>
<li>如果调用会抛出异常的方法，一定知道异常可能性。即会处理异常。</li>
</ol>
<h4 id="1-1-try-catch块"><a href="#1-1-try-catch块" class="headerlink" title="1.1 try/catch块"></a>1.1 try/catch块</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/tryCatchFlow.PNG" alt="try/catch块流程"></p>
<p><code>finally</code>块用来存放不管有没有异常都需要执行的程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     turnOvenOn();</span><br><span class="line">     x.bake(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (BakingException ex) &#123; </span><br><span class="line">     ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     turnOvenOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果try或catch块有<code>return</code>指令，<strong><code>finally</code>块还是会执行</strong>！流程会跳到<code>finally</code>块然后再回到return指令。</p>
</blockquote>
<h4 id="1-2-throws"><a href="#1-2-throws" class="headerlink" title="1.2 throws"></a>1.2 throws</h4><p>方法可以抛出多个异常，声明时必须要含有全部可能的检查异常。调用方法时，编译器会坚持是否处理了所有可能的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laundry</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> PantsException, LingerieException </span>&#123;</span><br><span class="line">         <span class="comment">// code that could throw either exception</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Laundry laundry = <span class="keyword">new</span> Laundry();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             laundry.doLaundry();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(PantsException pex) &#123;</span><br><span class="line">             <span class="comment">// recovery code</span></span><br><span class="line">         &#125; <span class="keyword">catch</span>(LingerieException lex) &#123;</span><br><span class="line">             <span class="comment">// recovery code</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常也是多态的，所以异常也可以用多态的方式引用。抛出异常时可以声明多个异常的共同父类，捕捉异常时也同理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     laundry.doLaundry();</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClothingException cex) &#123;</span><br><span class="line">     <span class="comment">// recovery code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的确可以用<code>Exception</code>来捕捉所有异常，但也会在处理异常时无法精确定位捕捉到了何种异常。使用<code>catch</code>来处理异常时，在继承数中高层次的异常不能放到低层次的异常之前。</p>
<h4 id="1-3-duck异常"><a href="#1-3-duck异常" class="headerlink" title="1.3 duck异常"></a>1.3 duck异常</h4><blockquote>
<p>如果不想处理异常，可以把它duck掉来避开。</p>
</blockquote>
<p>也就是不用try/catch处理异常，而是再度throw该异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Washer</span> </span>&#123;</span><br><span class="line">     Laundry laundry = <span class="keyword">new</span> Laundry();</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException </span>&#123; </span><br><span class="line">         laundry.doLaundry();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> ClothingException </span>&#123;</span><br><span class="line">         Washer a = <span class="keyword">new</span> Washer();</span><br><span class="line">         a.foo();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/duckException.PNG" alt="duck异常"></p>
<h4 id="1-4-异常处理规则"><a href="#1-4-异常处理规则" class="headerlink" title="1.4 异常处理规则"></a>1.4 异常处理规则</h4><ol>
<li><code>catch</code>与<code>finally</code>不能没有<code>try</code>；</li>
<li><code>try</code>与<code>catch</code>之间不能有程序；</li>
<li><code>try</code>一定要有<code>catch</code>或<code>finally</code>；</li>
<li>只带有<code>finally</code>的方法必须duck异常(即声明)。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/exceptionRules.PNG" alt="异常处理规则"></p>
<h3 id="2-创建MIDI音乐播放器"><a href="#2-创建MIDI音乐播放器" class="headerlink" title="2. 创建MIDI音乐播放器"></a>2. 创建<code>MIDI</code>音乐播放器</h3><p><code>MIDI</code>音乐播放器，类似一款乐队软件。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/MIDI.PNG" alt="`MIDI`音乐播放器"></p>
<h4 id="2-1-JavaSound-API"><a href="#2-1-JavaSound-API" class="headerlink" title="2.1 JavaSound API"></a>2.1 <code>JavaSound</code> API</h4><p><code>JavaSound</code> API是<code>Java 1.3</code>后加入的一组类和接口，分为两部分：<code>MIDI(Musical Instrument Digital Interface)</code>和<code>取样(sampled)</code>。<code>MIDI</code>是不同电子发声装置沟通的标准协议，可以想象成<code>乐谱</code>，可以输入到“高级多功能电子魔音琴”中。</p>
<blockquote>
<p><code>MIDI</code>本身不带有声音，它带有的是有MIDI播放功能装置的指令</p>
</blockquote>
<h4 id="2-2-Sequencer"><a href="#2-2-Sequencer" class="headerlink" title="2.2 Sequencer"></a>2.2 Sequencer</h4><p>先获取<code>Sequencer</code>对象，它会将所有MIDI数据送到正确的装置上，由装置来产生音乐。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sequencer sequencer = MidiSystem.getSequencer();</span><br></pre></td></tr></table></figure>
<p>直接调用无法通过编译，编译器显式需要处理异常。API中说明<code>getSequencer()</code>可能会抛出<code>MidiUnavailableException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MusicTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Sequencer sequencer = MidiSystem.getSequencer();</span><br><span class="line">            System.out.println(<span class="string">"We get a sequencer"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MidiUnavailableException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Bummer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MusicTest1 mt = <span class="keyword">new</span> MusicTest1();</span><br><span class="line">        mt.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以下是<code>JavaSound</code>的工作原理：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JavaSoundWorkFlow.PNG" alt="`JavaSound`的工作原理"></p>
<ul>
<li>运行该播放器需要5个步骤：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/fiveStepOfMIDI.PNG" alt="`JavaSound`的工作原理"></p>
<blockquote>
<p>第5步是开始播放：<code>player.start();</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniMiniMusicApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiniMiniMusicApp mini = <span class="keyword">new</span> MiniMiniMusicApp();</span><br><span class="line">        mini.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个Sequencer并打开</span></span><br><span class="line">            Sequencer player = MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            Sequence seq = <span class="keyword">new</span> Sequence(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取一道音轨</span></span><br><span class="line">            Track track = seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage a = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOn = <span class="keyword">new</span> MidiEvent(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            ShortMessage b = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOff = <span class="keyword">new</span> MidiEvent(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Sequence放到Sequencer上(相对于把CD放到CD机上)</span></span><br><span class="line">            player.setSequence(seq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始播放</span></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-制作MidiEvent"><a href="#2-3-制作MidiEvent" class="headerlink" title="2.3 制作MidiEvent"></a>2.3 制作<code>MidiEvent</code></h4><p><code>MidiEvent</code>是组合乐曲的指令，一连串<code>MidiEvent</code>如同乐谱。必须在<code>MidiEvent</code>中指定何时开始播放某个音符(<code>NOTE ON event</code>)以及何时停止(<code>NOTE OFF event</code>)。</p>
<p><code>Midi</code>指令实际上放在<code>Message</code>对象中，<code>MidiEvent</code>由<code>Message</code>和发音时机组成。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/MidiEvent.PNG" alt="MidiEvent"></p>
<p><code>Message</code>中信息的格式：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/AnatomyMessage.PNG" alt="信息的格式"></p>
<p>使用命令行参数版本的播放器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniMusicCmdLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiniMusicCmdLine mini = <span class="keyword">new</span> MiniMusicCmdLine();</span><br><span class="line"><span class="comment">//        if (args.length &lt; 2) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Don’t forget the instrument and note args");</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            int instrument = Integer.parseInt(args[0]);</span></span><br><span class="line"><span class="comment">//            int note = Integer.parseInt(args[1]);</span></span><br><span class="line"><span class="comment">//            mini.play(instrument, note);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Input the instrument and note"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                String instrumentS = <span class="keyword">null</span>;</span><br><span class="line">                instrumentS = is.readLine();</span><br><span class="line">                String noteS = <span class="keyword">null</span>;</span><br><span class="line">                noteS = is.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> instrument = Integer.parseInt(instrumentS);</span><br><span class="line">                <span class="keyword">int</span> note = Integer.parseInt(noteS);</span><br><span class="line">                mini.play(instrument, note);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(<span class="keyword">int</span> instrument, <span class="keyword">int</span> note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个Sequencer并打开</span></span><br><span class="line">            Sequencer player = MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            Sequence seq = <span class="keyword">new</span> Sequence(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line">            <span class="comment">// 获取一道音轨</span></span><br><span class="line">            Track track = seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage first = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            first.setMessage(<span class="number">192</span>, <span class="number">1</span>, instrument, <span class="number">0</span>);</span><br><span class="line">            MidiEvent changeInstrument = <span class="keyword">new</span> MidiEvent(first, <span class="number">1</span>);</span><br><span class="line">            track.add(changeInstrument);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage a = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOn = <span class="keyword">new</span> MidiEvent(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            ShortMessage b = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOff = <span class="keyword">new</span> MidiEvent(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Sequence放到Sequencer上(相对于把CD放到CD机上)</span></span><br><span class="line">            player.setSequence(seq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始播放</span></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo学习记录-博文加密</title>
    <url>/2019/11/16/hexo-learning-record--post-encryption.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="密码是 password" />
    <label for="hbePass">密码是 password</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="77fa5be6fed2d407a88ebb433f7f586eeace7d6f5171c17aef3a81aeba17e56d">818ffb39eb08dc7f13d5091f8a8f23c74cbcacf9d9efc5a1642c7ce851f7a2cca16e40aae9f8b3a7cfd18a133ef0859b982999ae55cdd79958a18d381cf93b0184c5fc7597fbe1ff53861ac035aa40e7ed09f930b69762c7ba529ba705428eeb0bd56fa727216c8a4b6a8079a205f214439b1eee967f2d56bd584ace969d7aa65b7b007e79691869b0453d312e4a86536df140e382ff630abbb475d551ea2f2a194d35e83b3bf6591ef4fa058c39db1a1c3b718427aaa867ce1fa0326ab0201510b208adc6a3814e96279ee824d2cbd216726a06df5605bb0441b398f24ac4aa708655a5fe415df8c9735c0f931c86b4dc42c336c272012d8ca716288bbb825d48ac68f7248bd46a81ffe415f6158b1831a18aa8eeb4f308f8e7656fc7aa0d73cb9251c1d87dfb85d6a0ac450bdc8de0f70610b6810c3704ea941f6610ea39087fcb063ed9088af7091a83de257e31ef7b1ab65129923e6211845527900985314e4b51d5d4a6e9f34d3b7d1ac31705c42110d7991409d8cc44b490a6b9ae824444e34ec6905c08ceaa748f73c609839aa7fccfaacd90400bef600a1823233518648b82eaf24cdbb91e38649d60dfd3a209f5274d1ac2acd778647b2a4f0fa8ee4fa88dd70cfe106ce3d14c986face0c19a7bec1996243721a1200a615b81785b61a51301ee8673199636a50cca2813b60250b33ac38f807c494e40e51ab5a51a01bb213842d0779b49b1b3b59b99c63894f7e8bff5ec1ada82b9e3d8c538ff2396d46ba8d7d305a06694fef4019310b0e81598b6fd2f31e256fca15d667b8c6fc96f7b62216b4480db7160f5ffcc65b5f52d1d260c43241083cc9bb022547201ed9583994257ec0816613bb5828475d0bf2a37fbb828ca554dc56d2d2a9ecbfed122be2009cafb5974fa8edb13a4759ef27b91f2c5ebb99ded649edf00e9259bd5eda19acfeb2e321857bd9eda5bbddb6a800d7d1967468568c90fd49f1a85233cf787011dcd2d74486d61184ff13dac072a83f2df4026f71769ba5dc5df1f1dd8474ec212006d1c3a8c0880cdc810fab2df97e4fe09108b583cbcc11fb5cc8e314271329292d167abdfcf07a888e9cd30896bfe2f2a226cb5182e7fca300adc775cc8f8441486b8f93bad378f18f1d938e36bdcbc003b8535c02bb68f14b701bb103b228b4ccabd893fb880bc8c61e33a18cdf185b52bb3a17a2a9b8a0a1dfeb4923a9e7aa152943ee2d3bccb1506bc9221ac3953e24699415bf2cbab350ad82fb8ad9c113b309ac6d965d286c18c29d867771ca72e507ca2583f825cf9981df7fa7e458b93cb26dd22f607e68ac326e08077a2a59b74b3e8451d58a0d5d0e30f65dbc59846a654b33deda3d115dcc21f8df26554942b424e4ee7b8dc276938b1e6f2b5b0b82cb23fbd20abbf7a12a00c69b97c392b146a4b127d0802118b3aab543fc76f54b01351063090071657758cc4ac103b8169038757c3db5c933fce25a8578781024d4242b964ea3c0722e46ab1c867bebf10bd129f2a4e86b05130b7f911b1f9b9d1c3dd26da0b46f3e5cd11172c5daca6b1ae5b322afb73014e10fa9d823ba9aff1ebbee6b4059fc4f5a99ffad5db5afe23067cd3e7a223e3eec5f81eda2643dc3854916c660e5764a5fca419ce4574f57e51c4f3874fa3b2b278098c4d412989d5534d1ee24741193bfbf10563a73ee14e174c22ae9c015104b87b36abf48a06281cff66e4c9df44066bf68f54fa4c225fa2d6aa7a233f8322c3ac0c07316cfc20b7211e15f2c0aad834248ed7e98d07e4262cc7b595583fc8dabf11e78d857bde0ba38268e004ad079544126201c858664ba21aeb663c1cab40b12cfd63d8d09f3ec376b7268a5d491294e7503834f1b4afce6167b81c54df34705a756b44ce5a7d1074684e13840719adcef8adddd44e12093fd5661794fcf31e949f0b169d3180d146bffe3ec4e1e026e757dbc697b2cad5be56df0fe357c61d2fa625394e800e9a9f24671cb6cdbc344692c8ded8c79c0a4cafcf688a746fb257323b04a2956f297aa014968e8a5bb66c9abebc1193a2a840820d97fbbb653975a1d56b4943bb5046b89de996b367c17d8fc6658be8517c5008348cd5f0b9fce0bc1d58736a892402e8c5b58eebb145ddd90fc13b74bd7f3ef8fba7e5861acb3357fbdf3bb651ff077c5a47a6771f4cb1a821a3785b47cb39cbc33febd6a0a69f439f99c6119fd18246c857ec43b2d682e3a83dc6599e2323f6ae07a1687be365ebd7aad0188f7586b177ca7047ef72428026a3c7db2dbd7f07fb3c00850ceb288fa025bf68e967a67848df52a122b392ff03e998b27961fa9641f2f3f822ad39da17e93806ac7cfdcb0cec1aa1e8f31d07f2422b478944f396190299e3508c60956105a38cb82c21754d05d6948eaac78ba5c3aaa68594d8c81d3c9c1b6c84f0c94a01deefe058cd5a258b2a861e9846e20cea369b9173a4aba0403721a2a5fa05a49825455cc521d2e61ff423b44e17d589a328f98c769ad7292d59972f9b7c830c1ba69810ad74142b7a06ed05b5a5c998bca97196f99f334ce97e378167d20915974090d4a6e6f45e29b69dd7e81cac42c1294f38ce1dfaccbe51f3eaf661301d97c3fded67af615a60020a29d84c9d145f489b776bb7350ebf8238f06b9cd03288ecc58a2a7a43a83d19f89ba7fb910ca474f8b169a67d72a6c87fb9437a71d78c13daca49269d26b09ba4783e23ecce661bdae2d3b10c2c6ea0aa22e7dd36ded1cf0e7dddd8e13924c460f93e6e2cf78a128f9c381465b7ecede906d1c746ee5bd60229b16875cd82d8383f605c89e4ce3dd9f5067ac93d207c6353a475b842fb35bedc5b91b32835c5b456673a22c2239be58f70b8a725a5bec1c461216fb364bbbfdce8126ac11eab28c5f316d582f4aa4d501393855534b620c3e58631848f952a08abf93e95f488577cd63a3a348bd3f2d3fb51a93e4d9e4d6a595d51345e3821ce59093da6f2db7f7baff7c34dbd526766bff313a399f61c7106bd76b8d99be596f9fdbb221f60f58f6d5971e8236d0146889f124e94ca80988f6b16cb18306633dc65dbbc391f17ba7a5cd4ed2f3bcd3f461340c550a9a353737c30ad9dcc5c22e22c7557553b4454860f69eedc9f40793168f023d7342d02b140c0d0f4fab5b3f83f51430c1c1e8337235b0c14f79724eeaf8ad4c76e88587ce7ac2de9d3484840ee7f661f8221ae3ecc9a77f223af3658090cb8588cc0ee56ba414598540151c1af453070730c2c28af76192448ca146e8b39dd749e7cd23db6b5a5afc288318deeb3c3f44adffe5a884e64800624d9bdf3c754c1abbe391917b77c6283f08091f3ead401d5ca2c5a1b59c8cf0b10acea04c0e6036dfd89c2760c668c63e4810b3a03cc019d4ec179f9c0cb505d65bcb8efa51ee1b745f2d8bb372b0939fdb6718d533a0dac264f6a94c238e92ff78c6e872411a6675fee303a99e05b0ba45f68185e323a29bdcf35552b3156fa100b322da4b0710c975b06fb308e386697148ab663e6e8873f434c7e6b6a9490fef86e1b79b34465fb66f9d1b1bb2e92eeb2c128ce128be3c55eec88cf6af82c87de9ddf2f5130333bbd34dbf5023fff91c18c20a30725b8d0c61ac4414df2d040b7bbcd9e0a30b0b483e75c42b5fd1e37adebacfb5df53607b8943c244f81ebf7c5d9cdbeefadd00a8b4e244af1503c8677911af955ae8c4ac40081e704295660c3c4c68b27fe06effa8aa6ae7af4ac62abbfb5ce8ad83fb36bf2f12d202719954503ed4756180670257802761d84fc45c68b99c68b6913d65e11500e2ef6efbdcf3fcc3d57bdf591f343545179b78ae7f06136cff9e0f20a85129faba51432d0789a9892f34aa7c477f45b2c44ba321b4151fcd93347f43c6807948737a6927617eed2d70b4889c9cbdfc37bca158870b2d47e3a5771cc6fca5d49e69a4b3730b5c5017ba72516f679f67e64a456ee75549a7ecb811ec9dae9890a5aa82e7927651dfe00acaedb7516655ceb479e3945124962738b3e9c0438821c5dce6d563a590ad01765418cf1fc06e0845686271c81af59c6afdccc4e149f53e0833df48a7b96b43ec0ed79fbe04e91a962cd95fe5fa2acc2ea7f13aafd58b74f48aa643a7848972bd683ab6951897aa4afc66b7e82d6fa4d223f553fdb1ad7d3cc7a3cab891e5db8dad378d3bcf97d95638b95dd6902cd098e0b0590e7400785cfa1a6f645c63ee4505fd31c137a6c3d19d797eae891e34b2a5da705c7a263466aaa0e34ca3f0f957a94a913735e2f38e28f3320562af92846883ce3d696c5be428362b2c8adf4dfe1d13efc48ba95daa47e62c79f24ee5968c5e91bb41bb42d546512c5d2e3d5af06b19977d6f19dde8b363725ea9f92b4f444e9505af140decffb731b79280d9169861cb1ef6cf236739e61269a4f062a305676b4c98c41e42805201e3e943003c2fb0354bdfde5e2404fcf0b4884f189ee181e8efae01eaba64fef48f266e7349b027ec47415e7943541bb750141d8c42e620ee4c91c2e7d7e25041442cd6f9757ed3a213c621780ecafbb9e2b12cc472f0c83aa767e1858029a9513c74e56ed8edc36abbcaed822413096c009c60e7245c91b6da8819dc3ed647b63cbc1bfac32c690c9ed279b17319a2ec2c3771278a5f72745d212d2af8d38d6942ef43df4110d666d564ec6909578e2a0a2f960fd9340a9ad260a730f16e7813a1536bef5a236e5b77ee361552d84a4e235f98ae70393500d11d539226fc45a3ea31eaae1444f7064f4bad63e463d1e8e868acb8f9162fae7d20087690f816b9176495e357e818be5d9b11af86b1685a1dd8582d9817d3bd781bb6d4c0e12ebb01dc693c519d112387cd6bad227d6201dbaee61e76a40cb311af394ca5404f59f17154f062be7fc4ff7080191799b8e71fb658a0695c5f72857155e4af4c2ce62439c5179cfee3a5d2168f3bba6d0a04804969ed387f3671de0738ab3216319c794de805aec9be49294033c016f9dae18253a066e29a3b1b8037910e3b9b7cb4b3ef3ab7b787ec4a0a8abf65ca54ffe2564a5d1242f58432d3a3a107c35618dc62fb54333c509b5f654a9064336c804b672bdd200e2f7a419ab3564de92f62f80b4f2510ce589180107c6de56da1ae7d8caea96f6c62b95ea5ff1c1a329486e6661a5354b6dd15b9705e3fab91a849858cc71c0a019d5950b5d9f691deaac1f294b0b99f1561256cb3c79e3c204399c1b5879cf77401b5bd0a96c3ad378e06957ff637e8d7e1ba868fb907c237cc18262ce605200de80dfd28074b75abd055ec30e8485d6c0bfc0ba006f4e79b880784931cb91ec0f0d608b1cd330efeb46437ae502a4623315d48dd40cfdc5d01bc6cf443812d41282907050090eeac5f5b0e4aa40235cf23cdafee2b2fb5a7de0fd84c93aa7477125896cff030323370b1a3fa627260717ef11136dc78ee65cdeea851327c927b584094bfafa2d98907898734aedc7a4fffd38953778ca8b4658ec784fae7a96f75c2b086b137dd9080bd68470efcc47148a7b52f55a7100cc850e827d816fdcc72a6c02c3e09f85ae4ae0026dfbca9825f6decd2658c4da5b6fef7b69161e8374f553934369758e95e13b9f682a8906429abc46ed8344c5a399241d6ece5c9eef8341920828fa508e740cacd71a7232aa96f92d7f510c83b0ad9208ee84d7a2442005e64006d937fd409536498f02c1e95a5222df5b67e25eded37d90bd22e57e08459069d0d111df1cc1985e53ad0d6623dc52ca32f7f61ffb908e039225d8ac439ccf9563de42d6b5c7a941e0eedeb1554ae387f70ea0b40ed8cd41fc9c10d931c3b68892c49617e9a1bd193be2460951db6ab116ae3d34ef5b54c5d31fa8756cec268e38c8d04c0ed663f2a560120af45c96a1c03040a35642ec9d08d140bccc21a345377b8f193c2a6ae10ca5226de1c3ef2f308990131879e62aedaa4a375468c76ceba4594f60c5d0e8cc92a050d1a72327a0fb1fd15d2a64731c5aff0ccad7b5830f43f4abe2cd19f9403e54c6beeb0aac5bb984ac4bb2c7c2fb87145117f82d42c148373a1d195d4d9334fd43c60fd29f9610c9e46a3823023a562a44d54cce4b5b36aa828c7135a5fe68f3fdea6dad5e5ea306c337f5c3afe13a27a7fd6bd4004a2a424b7c33b5c5e08f4994b6f4b2a4711158b36153228172800acd8671c9cd6e99fca40ce6f1d4dc47f181ef88acf927af14900bacecf84188411bd83286904df6630562dd675a5ca129f0f1251c4f818d898bf233dabcc0da9c79e7eb417da7aac4d70289fb3e84a2c92a52fe55a053815ded1eae12b9e6a8872a0a859e116efe2c46af2adeae72c8a8a6c88e0ee48e1bdecd7e697dac91aff9c2f6cfffb0b0a92607bdb468fd044e2f2763a7001b3a40d0c7dd6529198332cc4b0b4543a0f97642dcc6ab68e958f66bc9cdefbc0387a9f96b98e8488cb2041dfbacd9ba7efeaba0eaed72e9ed5ef303d16e6306b63b4a1ff4207a19f117f31c3c3149ef4052be5c22bd032a24c3e23d8868f125c047d1c190f1211c08d2f9c1aa639607f0246775715f2d4d8efa24444a933d47a4b3cfaee7fee8d048e5b29622096162906c7d053c57a9bde0ad01ff507defc01f67cd90e71ef0f97545978a02e0b7aced57f08f65b7a39ed00ff4a87bcf2acfc68e19c61eb1f56fbd3e8b1be73763572e18b5a2def95b7678d793dc7b7102c1c3a386c9269d60f74e0a3ffe3d438edc1ff1ada4a2781fd7d7c8d85dc557679db9782f2ac3afa7a37a974fc75795cd80d155c9b8a451ccda45e5eafce61ea89f554242dffa2e70b59beaf46fb829085c8f610eae37582079ed19deb0704086c58f676372794fb1514d858c4dfc967a843d6b80930f19629f879d82ffb309cd75df83f3c9a7b078f135794dce2036a31c1af831a0ec75ae3243150e0fc639ac0bd95765a40f242e8c3f282683f42a73d73a151c1c4b138bec46b6eaa9d8994cea592a3c8122f5cd554b7e34c92f393b01c5d8aa752e2a9ed591076f7d774ffa64f926e0c82b5c75fd479d8d03bca940a07cbba02f6b89b3ce7458ba9bf6e9fd51d4d64a73b9833832d8fe4651e989e20fa97e475aa8b946ca3049bb192dc2adcd3792e35763199a0e23e6ae267d2c7ffbeabde73d087ce50636e10ac4ab402e52b0f1e3ab3ba80fb8e6d269195c85a60b92ad60d2eda8df41d620ddad674ba87dea22d1c482ff3677c4674ac6f831ed6b5003ebe8b9174ed309337f0071a98d0ee7198bc971f572e9ba737440341c0978a5d257816bd25f3c621c393e5b4c46171baf8fb8fc39434917422e0a1ca390f4df739e7085c8bd242c9a77ab6b9bd971f703a9caf405cf0de890d9c04315eb198fc4fc7d3d2fa4fc9cc36a61cdb5391b6bb4b7fbb0655f60d464db99baf864503a32dea5d503fb06cc62ed2e60ec0ed678418bf6649511873047e65e24cd8d303fb520df914e468a6ab71d2667c3bb6c3f99f4ec084591c210c97b7170c1082e4f4cf1f8e7c07ae31dce6f2bf5cce08f682e4cae50156b84b8e2978549a77394f0ffd9360085db514e31ab387637598e10f216e4ce7c678cda6980d48f6212e5fc6e25b996a6fe4e4144cf154a4c2ee3bd122cfc088d2356015c58c4b4666d2c5def6a90ab31e9c39e4dee4fcd907859311f1b2ac537591d568e9659ba1b445b2db387b799b106e5ec1713b82f72918773258844715cdcae15b1fdf4909d25c44fcca1a5976853986e20df1c89516fbb94e0c32cb7fc2d73fb47e590066506609ba6512250d4c4b1447ad364f00423bc34b26360c2213c177f133b36fa3c111dd3d85de6a70e0407f96931aba09dcc60f42753f49cde1acbd54b283397481003f9e144fa98b016f9bbee30a600b869723044746a62b96ffd48d774743d901ee184b4db0a49a2979d80a36e82da19fb4374f7fe6f3c689fba1fb1cd01d03b806db1f93a65011dbceb9eed6f1545f693c8c8c467f52dbb8c8e9630fa866d3397f93662c3008d9d0a3cff0e954dda24b300fdcdcd3d7a34be1449f6357829d867a643d49f3bca016723dabcd4a3369416f39ad71a319d90cfd39c8e358dce26433c03a1af6089c0e0b5f7b310d88269b928bb5c48905bcd8c72069542ee2fd03130c22f4041d6d7c16c146f0b2e5f6e79a85835e960af81d64acd1288de6a19a77fdaeef8a5dd21fb0cb06e229e52690d51e78d3cf9a0061ab13a13dee84810d6674d182d3da33bce908abe7ec7e7a35ff7ee6f538b1bcef75f892b19876cfe29fbdedb4300cf839366d61be096cac0bb3c352fd6ff4ea5b1750ed7e4e1dd9bcdd25882f9924a34af41e0e2b42009a67e898997dbafc3bdf69df3e3b4b86a32a7c7deac62797db0cf2a7cb7262ddd22147caea7071a3b2d20e3682ce0dcbef4cf7a625ba3e93667e1914ff75fd45ecaab1a23f44c2e2a9c028b1ef2a08ba3cf3bc5e2f69255463a3f1229e73c624cc6bab8626ab847ae081ed66e23100c9aa9172e17ee093b9e184d70c8e7913ed8ed706b0361a632f9249df3d4fffbcce3029f4b40e2219970b610a3eb4234fb9657df67d6484278a10503819da81db69a30d721edcacf3468cb7c2535d805ad44decff3c4ef606e57df2026df623c4890f390b5af4a761aa7057f61fd0acf95be342454c37eb92a846d92c858f3869cc105de438a110bf0176b0f4ac503d0b730cb863ea2f84179405906fd48479ceee4c284f71a9758b85ee790a9868b7e97cb16860566038d76f221548bbbc89736d0a475729993d0b1f829ae6aca1a5ea36d74eb3a4defebbee90fd00de67dc592980f243929715bbcbb6590998fd8368b554a49bd4a8d39674df23185a9729a5a37ec228ef42fded6ffa4fb8056dffefae4da149069af78b1207c2bf544542de7b2af610e0e74856539b010fa0bf6629d0a86134f67519745ffc5fbedabb970a91ac340af495efece5a85daedf42c9e9359ba1bfd01568837df6d927444f67aebbb8493340ccd055fe0a85535cd5b9a9f37d1526198bf524e4108af7221aa9d080ecdba2cf3d7caab31a30a8c7c06e875b3f4e6442101759c91283ab9f6e8e16fc9fadd21fa87d72e9f76675667807f51c4a2d9a9762094dc2b8f0ff80488e8d00e223b4dc0f50ec67da09f6c8cfe4f5d67acd9bea191f9af3b30623ad4b237e20626c39e11be4fd3156c5c9a8485d1aab4df194ac4494b6fb247cb2df431fb58e111f7816871a42c9890e372653839841dcf403a04368b2502b5a1c96d3b4abf631b297272422caa5dc105995c06b041ee432eb72d6519b299b3287acad660d1be6dc1a7b2ac204869fe19d139c54d39473ee215f51c302b583dd30b156c16a9f932f7991d1cd70a9f2d627b91e1972d4a0cef007fbe7ecdb6334f7017e50ab5ceb4d086753b60e08e53ac411b7b770f3b8b3526beb4bb2d5a80e314d9a774108cb45bd18b78c3ae86f6ced8bf44a781535dca748894fd46605a9fd055ab630ff65bc28a0c761f77e9c70679f85c269d3961e7f7f74edd37f9d592c4d34a6a4545b377907343dc18c4d4c2737b5c173f098c542e673178b7fc5e9a1b6123611e4c28d90a67467cc187c51f48c8e11c550bf9d505221249a4698f0abb9ad6dedc524d38ae6f51de51be21429ccbd3e93b0888b970bd93db54952dd2c7f8951f62330b4fd30513aa73f0954573f21bebbbbd98f94146c03195ad4884467c608a163d921868237ca60e1d67d5500178fd38f758720bc7ea96dbe0ddc18018355aedfc45e3a0c7158f8bccffa7e5f1e6aaeebf0b78b4fdd4723430bad48b928371318f5e837756248f40a2eebdd433a2f7cb9258f1ef91aab64ac464cdf68d658f9d65553d2cf9bacdc5127f454ccdafe71455d577e5001d717f125853842c583b7b3cc4c97c8c268756f2483d827bdd9ce80456a7c711e7e1234cdd792d99ff0b1717fe2f431ce76fe7689e33f1b46eee888e3e77adfa0b32c6763f579ce7ee190027495fb634a3f659fc9ab495e60322d8b00ba74a801f10a32667638f3d3c690bbeb97b9b1e4e6fb675c1cce259e693f612eba8b454be98e536ab9082689334a7bbda70ef966370939506a511e6833f585dea7efde3b26337b6509c3ec052478a5a19a82468436d95fca87e0ab58bb3cc53de1dbd7cc4bf41e04f986c9dcb43fc27a81728b08f7528770cf1a97d437f475a805962af9f96aba853b7e67995ec13132bc51496b5a215522c48716698fca73dde113175e993b22a14f92eab48a51b888a7a1c3f190359b7b1a72530507ddc448f2a3f193e53953ca9fedc4d1b4aa77dd75559e031c955b18e8f912450534bea95d886ee59cae699ce127c0417148659d1d747acc8df50e56196b19fc15c414df5cae3fad3f55a7cb5928dcdf589c033fae03138860ef213bfbbf378508404645a2bc4a59e854c56fdc21bc9b322a2f99655364b7b203e57599a6f6d7ba39558d2744d881409c8370e551ce7ebf0c4dd1435480e7595f29504e302b5280837a27d8797806211a2a16a63f824eae73b44a76aebad86eb3dee995a58fc48821fd8524bfd62c89e4dd39e59d960df75ce9ae3f7e62c48c35ed68eaaa9687eb1043daf8b001feae2d7dd4e6aa82e150d912b664dd8887f6f4422db3d0e3f9dc63ba5040383201cdc2d406785de46fc15df8d7cf4c8d9933b5409c9ff9b01ed8f086032c6a6865fd9293a4c30c0c8584e7048a716ba36fc96dea7bb6f1cc0a8197102213b19800e771a7f8558a2ee8fae21d82201a32826295752d070850122d618abc29847ebc19382ae0bef762dd2d8e18429d67109db52780a3ec75ed4dab3c7f9d2c9bb3c522ef6dd01d6562fba21427549a977e0fc3fa7ed4ba2f9fef8f14227807567e91c5b6a026fafc18969ee23faa51a1a0dfa8a8e62e8a1a8727ee519a07f838903db0dfe45ca58bd48bbd35fdc7460664f5470e96d5d3744ceb27602b63972f4be9f199d16d33ce3ad8c0f60c074886b84bdb5a9efb6b1e4065a5104e435a6d8c55f0af40fdbf1e68a5a32f2dde62c60edc42eaf390704195cecf6c880ea86ef035555d87005e5a297cc9e50a66f3b0e2fbff339228a82a2d1754582b8ccdcc7ff74a8a8b3e35d9bef5c528f69e45300893ad2c467cc36bef9f8ec48aaa96ff914b868be799da3ffcf50c8e8f43001456d89d88ac7d1b15e891314483344c0684909f13dc131622d769c3a4487291a38548de241c0bc0cecc3e472caf1ff7f57d0863549c724a1ac8a64c4ee44d641876ba045593c25024630afa146b20de66013bdae5848c50f0212c99b1119a4c589d43b41809b3d3847a9cee5cc152c467ffd518feb5946d54beee5963e0e16166b3fde939cfda71c0a935aa2b18094b0acfc5e2b5727a2cd0df7312c152846a77ce76331e0a87b1c343e0181677e75ca364f6b1e9e889ecfc3b4f7df6e59fdf568cac441e8c317b9a541c7fd61eb9b2fede20676ace6d0635403cd38adcadb6b15ebe7a74af8e4408e5a38c755f9c66ae58e4a95cd11f55b00cb62f8be43d83cf8c8a6313e603863d560817147926161f681ecc2e19d10bf31f63dacf3fea7b8ac6504b2c522c9335ac372e4ce457841951c065158f3404532359b3ad7e0f8fc49567bdf4bd3ba2c65d0af60e468a94ff2bae006f78a323df707a58749c2047a3c069d42b3137796cd05183815a7dc34e0ec391a7ce73ae60320e1ce65c4c20a330e173b075237150e53283ec95261fbc60f3ec7a30992fd344898f4b9f60acfb72ed60a98dffc26a4d53d3f1f63623cd06f28a6c18364a2d2571fcdf5b5f6f04d8d63dde2f77fd2db6e6d73bc43d88970d9dad59920f258adbc539bac44c6dd59d62dc368339b2671e3595529deb7fcc39b154bcd8a40f6f698733227d9433958f2855df5dcf96c6d68b728d806fb216f95632e748692dea981f53edd70352e4fc60532239d68fdea2190474a5a6f33f7777c2ca7d6422fe37cd9de57b5dc5675b8805e05187e6e5d740b9b7bb6e553813bc7d18f8cb7788bdd16e0cd32d820b76de33d19182fd9ccdb67e4962ea23f8a317d10a421f236f6c4cc491dd0bbd5e8a9d60448f2ba912ba79141c4be3a2a30685362e728af8f8522188f92c41a4dddb8c322d4cb446585a9630279d1606d697ac278e11c484b98a46662362e926c0501a4c58ee6902c39715fc0f34c080d85768d0a449240627cfd1df2d4f4eeca042e396833f977d6344fbaca0a65ac9d7fc76c5a6283e2591d15ba3c25034dec9c0d8c7b0c95d7467ba434de1dfa70fdc3292f6b1eba1d563876b999285c5c743e1f4c4f5f0813e51f8a04133f08f7a450b7b211650ca1f13e1e02148e78a8df3396f1bb938f7d786fd31de7b12ac729fbfa6f052fbc023f522a35a62ee8e340ef1ccb59aa537cbf1212262c45f8e1570c65052d687d51c5460f128e3318a8916d93a1f12086e50c70766aac9f088b81ab134641a1406b9cba907f247ac3e517d6ad3e98d0253cfeac89ef45b47a65348468389bcaa0105afd000900499291d9c00da35b1117c9405087e9f46f0094b362cdfa0a8b54a03a566b48de2ca431bf5a1ba130ada530ce03d030a838c4a04c11848feb3324163171bf6415ce73a1a2d0970cb615431825eaa042a09fd6d63e8ce1f22c6f0aa4fd0f8d7d1ad774b1daa9653234e417bca2af79e3cd7d2656fa486ebbd9d69283b540412e9be25aa266a0c1aff19acd323081cf3c90465a0837217922fc8736d45628807dc8e28159f71dbb729a6f15e3ed7a67a77716dbdcdcdbe3dc3a7fa2f1a9063bea281da8c44129516e5e419e20a35df819c7c8039e3883228ec1e1a9116990923f8cc6c4ed576fcb84b82373c26882bc623136c70588c342947a6463d6216d69ef7492a9d81f34ac23e7855f8fea23d513f3464be1c7643d5388fc043a5804fec9205e8a3d5a28fb51a4cbf3fb83568b446dc41372d66c4dd7d8ca1ed6dfab3afefb415eaa3924b365fed171324f59ceed75927ed97d16b2b4afb6577ac6262fcaaa7d4d94380977d04dccbc510411ce9aa461b85d9648ce0e927eed10569b07228d5e9dda60aae7af50f6a753a83824442651e0b7c7203b467396b6e3c1e069371ca432cd621e204e0d0d6de477d9b45eb1781ee063d6a1880d306905c6fa8a4037813deb16572638248f8fb028a1068db25608c6b1e34d667873371e152b27a45002df135fd1540064c55c50629d926e58700db9b0744ee039e7f7c8a990499054fe84872115ad490cec7e0c85dc9e5428c6089ef69e076ab9db10fe5deef408772af024d4b8ccf38748cc439b2f30108ff00a2bc4654ba3227f3637dd256d0b3d0f6c37e379c7ebce44d739cdc1e9540951791b70f09498fddad17f6baf81770f386f2d6db823feb6b7da602f18577c16a965ac54ee3476b4121c115e2d09386ac9cc9823d979654a3c7c568505c073847da0c253aa7a6536888b741ad1ca9fd9712392ff3ee98f410aecb48d9aafc4b746c6c8862eb2d813a6f2e681e50afb503aed1e8453ef70be5ef32f9daedd7520e5204bbc7933c1a2f8f316e8489f1ce6ea55ae01ff1c2e66aadc1361ae416bb738968768fe144e1ea128486db4303b76a4c0d2412ccc0e8d0a948f37f14560768dcbcb41807144f4b5f01df6e8594975df1d52c05a5a5fbc1a2fb3faabdd5aa3011eaded043a44328cff5868360ac0220006506014296923379b0c39dc018dedd881e3b6f828b2d49bd636b6669b3dec202d64700aa4fe4cfed5c3ff9734750fe97fd276ab4de3a0713f124a0daf7a8c0bd180396bb39243a30eec911843410d3aebcdf710d149ef28632f523ae39ac2066492a4d25d517ba90531668183ae5748c389de08bae99975c67d7743c105a6d040292cda973a466ca6f728baa5a4ef883688824ba5603c50e039da0776d316945f72c59ca49370275ccff4af70154d22c92583624801f7ecbbf22e3a1ac180be7521f3fcddfaef073ad9fcbfb467d0cd1d344ab9b47659895f0c236e127c17a174c5883d6243083ac080eeea0a0c15f6bda4ed76f38e1636a645c8b9a2dad32f591bc6b4580181c9234734283041bad38e2ead004520590190bea8e35b58224a467f813aed65db4692c5d6abcf7c557168e1b4a65d1091842b3dc21311a05dabdbff07a58311c91f6034a3f5adeda6d6584811c9356341e5ec6dde0e0b4ea98e6922a943b0f06264dfe7a4c8a7cfbb7a68af2dd31ba578c8d970e4f34ef328249f79a2b932eda4eee304490fee5faf6801aa88adb0e9f3ee8cfa05cc2cadb88617e3993bef37932454259254e5f5fa81e683dec6fff8da413dcc2e3c8db1de3e57b33296ba8c2d7797aa7e25ccf0e47ef874e859157a3f093c7c6c476174fa6bc9945bee343f34e76cb1d1af06917ab29890518c8b2e67f89ff7c7f436e44e36db6e0b58b0d1095c4c215a6ba3a735e1ea93699c696121499756faf1db453e25251f60fd3c89b991693fda42a053e7a2f2762505bc0f05631f19f744758b4fc0803fcaab259f5507a76aac5f9e2c067d2e7ddb2af2748a255e21f352bdb6a01b69f54267cc0b4100cbadbba80424b0091f9eab3d323a97d07ae65f1b6158bb4d17cc40c286435479bfd0abf3123d152a0f442b09adcefe59d592aeb0743cb32dfc73d42984525f524c52907c95b8349128f30eb2683c2e32d97b9363821c98287aae605e080ce40cb8cc21cb1df86f24d88f958f29dbf0daa88c31dc60be68cefccdae9d10e5106d733502219d29c0c38ec64fabb50f2afbaf183d5d06715e6f280a64d0429a3f5a8f2c28c65eff140d9099f4ea74cb0fbda57e35f6eed54646d3a3a1bb775b1736158d90ea552f6c164771c293f24a61eedc0f1f37c80875ee716149de26745ac94bdfeed561e6ef698b19570e46422f8ef691b230bcb9afa6a90ce79446376ee655766d1ce47ac607bffde36ef1e72542f1f26369e9fd4d5daf3c7b0f4110512d6cb48a42fe1e857d40c09f6457baf9aec6c9866759b125c750742cafefba404c3000477670359217d5b38da5ae430e34ba7479a3c021b6d15bf887d6c87862e33aac40384e906bf3bd90fe5eec52bc4a8404b611ca229e803a5131a141bc5117ff16d80f5a7f625fcbe4d0a74a7124bdc893d6194aba1ac0057c14585a88e4f907d339a58614d042f385b276c24f31faa7fa49c26fc5a687144f6adb07721e32079c7077eff94664a8d6629c0264e250e3fff276869f3c86e6bf4a726b38f8b4412fc9e370fe215c78e1ac064bfcd50c7439a1e3e014d42cbab83bf22fdc63205187838217e806d51b8ed623fd62870ec6648320600160f6e5b7e722422e140e6478a71909195b5efd497f38e1f17a6dab6f0ec914ac2de16281bee4f14e0a8cfc15bae816d8ce9ba54aae274fd8950125ca5f9d3d8f58ed775922aaf608272659f4a88584a3c3507f850dc04120abf0c59f62a3c33e843ebce28b26b6e928aa8c06a819a8c80b3a4e39f576dc751cd27d7ea03ea17dd86b62200c550e4b0bc9bffaa1380b7bd3751eb8f88b0373a582a429b107ff1e00395ac4fad944f7018b952ca3494150651294ab28eb0a717d7502ac2f1bbc2f04db98c3f5422647d64f60304b0a88ddca35281d40bf52eb6a71c8a85beacc445d1023b30b4301fd13b14646c526b90f0e901305d4697482124785a8657d557e2c339c768b38aa0de42d879d2e7dd7316bd283bf5a2e9e57213395aa52d0408b83f83f461e5be220ebb7ebb301131e5e04865b380b0f20522def1adc1ca616482c77054db3a72aab8a4cdf5ec1812fefab122fdf8e356e91693a146e7c8fda004192cb5cb83c2a0ee0e11a3d77d25cef80f8d0cfcd55b9a94c18f95a65b7a80b9d0f1010a84310</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Hexo</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--3 认识变量</title>
    <url>/2021/05/11/JavaLearning_Head_First_Java_3_recognize_variables.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>变量有两种：<code>primitive</code>主数据类型和引用。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-声明变量"><a href="#1-声明变量" class="headerlink" title="1. 声明变量"></a>1. 声明变量</h3><p><code>Java</code>中必须声明所有变量的类型。主要分为两种变量</p>
<blockquote>
<ul>
<li><code>primitive</code>主数据类型保存基本类型的值，包括<strong>整数、布尔和浮点数等</strong>；</li>
<li><code>对象引用</code>保存对象的引用</li>
</ul>
</blockquote>
<p>变量必须有<strong>类型</strong>和<strong>名称</strong>。（<strong><code>variables must have a type and a name</code></strong>）</p>
<h4 id="primitive主数据类型"><a href="#primitive主数据类型" class="headerlink" title="primitive主数据类型"></a><code>primitive</code>主数据类型</h4><p><code>primitive</code>主数据类型有不同大小和名称：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/variable_type_size.PNG" alt="`primitive`主数据类型有不同大小"></p>
<p>这里展示了<code>primitive</code>主数据类型的名称以及对应的位数：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/primitive_variable_type_size.PNG" alt="`primitive`主数据类型名称以及对应的位数"></p>
<blockquote>
<p>这里注意在声明浮点数时，除非加上<code>f</code>，否则所有带小数点的值都会被<code>Java</code>当作<code>double</code>处理。(比如<code>float f = 32.5f</code>)</p>
</blockquote>
<p><code>Java</code>编译器不允许将较大的类型值赋给较小类型，比如<code>int</code>类型值无法赋予<code>byte</code>类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">byte</span> b = x;</span><br></pre></td></tr></table></figure>
<p>即使<code>byte</code>可以装下<code>24</code>，这条语句也不能通过编译。</p>
<h4 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h4><p>没有对象变量存在，只有<code>引用（reference）</code>到对象的变量。</p>
<blockquote>
<p>对象引用变量保存的是<strong>存取对象的方法</strong>；</p>
</blockquote>
<p>它不是对象的容器，而是类似于指向对象的指针或者说地址。</p>
<blockquote>
<p>但只有<code>Java</code>虚拟机知道如何使用引用来获取对象，我们并不知道引用变量中实际装载的是什么。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/variable_object_reference.PNG" alt="对象引用"></p>
<p>对象的声明、创建与赋值有三个步骤：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/create_object.PNG" alt="对象的声明、创建与赋值"></p>
<blockquote>
<p><strong>数组也是对象</strong></p>
</blockquote>
<p>无论声明来承载<code>primitive</code>主数据类型还是对象引用，数组永远是对象。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/array_is_object.PNG" alt="数组也是对象"></p>
<h3 id="2-变量命名规范"><a href="#2-变量命名规范" class="headerlink" title="2. 变量命名规范"></a>2. 变量命名规范</h3><p>可以根据一下规则来为类、方法或变量命名：</p>
<blockquote>
<ul>
<li>名称必须以字母、下划线(<code>_</code>)或<code>$</code>符号开头，不能用数字开头；</li>
<li>除了第一个字符外，后面就可以用数字；</li>
<li>只要符合上述两条规则，就可以进行任意命名了。但要注意避开Java<code>保留字</code>。</li>
</ul>
</blockquote>
<p>这里的规则是最为基础的规则了，实际上为了命名规范，还有更多更复杂的要求。Java<code>保留字</code>一览表：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/reserved_word.PNG" alt="Java`保留字`一览表"></p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--1 基础概念</title>
    <url>/2021/01/09/JavaLearning_Head_First_Java_1_basic_concepts.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>重新开始学习Java，同时为找工作开始做准备，加油。从《Head First Java》开始吧！<br><a id="more"></a></p>
</blockquote>
<h3 id="1-Java的工作方式"><a href="#1-Java的工作方式" class="headerlink" title="1. Java的工作方式"></a>1. Java的工作方式</h3><p>基于Java写出应用程序并在任意设备上运行主要分为4步：</p>
<blockquote>
<ol>
<li>源代码。编写源码文件</li>
<li>编译器。用编译器运行源代码，检查错误</li>
<li>输出。编译器对源码编译输出字节文件，编译后的<code>字节文件与平台无关</code></li>
<li>Java虚拟机。Java虚拟机可以读取及执行字节文件</li>
</ol>
</blockquote>
<h3 id="2-Java的程序结构"><a href="#2-Java的程序结构" class="headerlink" title="2. Java的程序结构"></a>2. Java的程序结构</h3><p>类存在于源文件里，方法存在于类中，语句存在于方法中。<br><img src="https://github.com/wwwwwyj/image_repository/blob/master/img/blog/JavaLearning/HeadFirstJava/JavaProgramStructure.PNG?raw=true" alt="Java程序结构"></p>
<h4 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h4><p>源文件(<code>.java</code>)带有类定义，类用于表示程序的一个组件。</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>类带有一个或多个方法。<br><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JavaClassStructure.PNG" alt="Java类的结构"></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>在方法中包含需要执行的指令，方法由一组语句组成，可以当作一个函数或过程。</p>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a><code>Tips</code></h4><h5 id="Java中integer与boolean不兼容"><a href="#Java中integer与boolean不兼容" class="headerlink" title="Java中integer与boolean不兼容"></a>Java中integer与boolean不兼容</h5><p>Java中integer与boolean不兼容，所以int类型不能用作条件，如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Java中执行会报错，需要将其修改为boolean类型变量来实现相同功能：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isHot = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (isHot) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--2 类与对象</title>
    <url>/2021/04/27/JavaLearning_Head_First_Java_2_class_and_objects.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>有人告诉我那里遍地都是对象！<br><a id="more"></a></p>
</blockquote>
<h3 id="1-椅子大战——阿花的”对象”"><a href="#1-椅子大战——阿花的”对象”" class="headerlink" title="1. 椅子大战——阿花的”对象”"></a>1. 椅子大战——阿花的”对象”</h3><p>面向对象信徒阿花利用面向对象的思想赢得了椅子大战(但最后赢家是阿娇——老板娘的侄女，作者调皮了)。</p>
<h4 id="类与继承-inheritance"><a href="#类与继承-inheritance" class="headerlink" title="类与继承(inheritance)"></a>类与继承(inheritance)</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_inheritance.PNG" alt="继承(inheritance)"></p>
<h4 id="覆盖-override"><a href="#覆盖-override" class="headerlink" title="覆盖(override)"></a>覆盖(override)</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_override.PNG" alt="覆盖(override)"></p>
<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h3><blockquote>
<p> <code>对象</code>是依靠类的模型塑造出来的，对象也可以叫做<code>实例</code>。可以把对象分为两部分看：</p>
<ul>
<li>对象是已知的事物<ul>
<li><code>实例变量</code>(instance variable)。对象本身已知的事物，代表对象的状态(数据)，且该类型的每一个对象都会独立地拥有一份该类型的值。</li>
</ul>
</li>
<li>对象会执行的当作<ul>
<li><code>方法</code>(methods)。对象可以执行的动作，读取或操作实例变量。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_override.PNG" alt="Java对象"></p>
<h4 id="类与对象的区别"><a href="#类与对象的区别" class="headerlink" title="类与对象的区别"></a>类与对象的区别</h4><blockquote>
<p>”<em>类不是对象，却是用来创建对象的模型</em>‘“。类是对象的<strong>蓝图</strong>，告诉虚拟机如何创建某种类型的对象。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_object_relation.PNG" alt="类与对象"></p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>创建对象后，使用<code>圆点(.)</code>符号所代表的操作数来<em>存取该对象的变量和方法</em>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_create_object.PNG" alt="创建对象"></p>
<h4 id="逃出main"><a href="#逃出main" class="headerlink" title="逃出main()"></a>逃出main()</h4><blockquote>
<p><code>main()</code>的两种用途</p>
<ul>
<li>测试真正的类</li>
<li>启动JAVA应用程序</li>
</ul>
</blockquote>
<p>Java程序普遍只会让对象与对象交互，即相互调研方法。猜数字游戏示例：</p>
<blockquote>
<p><strong>摘要：</strong></p>
<p>涉及到<code>game</code>和<code>player</code>两个对象，<code>game</code>会产生介于0~9之间的随机数，3个<code>player</code>对象会猜测该数字。</p>
<p><strong>类：</strong></p>
<ul>
<li>GuessGame.class</li>
<li>Player.class</li>
<li>GameLauncher.class</li>
</ul>
<p><strong>程序逻辑：</strong></p>
<ol>
<li><code>GameLauncher</code>类带有<code>main()</code>方法，是应用程序<strong>入口点</strong>；</li>
<li><code>main()</code>中会创建<code>GuessGame</code>对象，并调用它的<code>startGame()</code>方法；</li>
<li><code>startGame()</code>方法是游戏的起点。它会创建3个player，然后挑出要猜测的随机数字。它会要求player猜测并检查结果，列出过程。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.schoolLearning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        number = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"I'm guessing "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    Player p1;</span><br><span class="line">    Player p2;</span><br><span class="line">    Player p3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        p1 = <span class="keyword">new</span> Player();</span><br><span class="line">        p2 = <span class="keyword">new</span> Player();</span><br><span class="line">        p3 = <span class="keyword">new</span> Player();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> guessp1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> guessp2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> guessp3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> p1isRight = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> p2isRight = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> p3isRight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetNumber = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"I'm thinking of a number between 0 and 9..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Number to guess is "</span> + targetNumber);</span><br><span class="line"></span><br><span class="line">            p1.guess();</span><br><span class="line">            p2.guess();</span><br><span class="line">            p3.guess();</span><br><span class="line"></span><br><span class="line">            guessp1 = p1.number;</span><br><span class="line">            System.out.println(<span class="string">"Player one guessed "</span> + guessp1);</span><br><span class="line">            guessp2 = p2.number;</span><br><span class="line">            System.out.println(<span class="string">"Player two guessed "</span> + guessp2);</span><br><span class="line">            guessp3 = p3.number;</span><br><span class="line">            System.out.println(<span class="string">"Player three guessed "</span> + guessp3);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (guessp1 == targetNumber) &#123;</span><br><span class="line">                p1isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp2 == targetNumber) &#123;</span><br><span class="line">                p2isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp3 == targetNumber) &#123;</span><br><span class="line">                p3isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p1isRight || p2isRight || p3isRight) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"We have a winner!"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Player one got it right? "</span> + p1isRight);</span><br><span class="line">                System.out.println(<span class="string">"Player two got it right? "</span> + p2isRight);</span><br><span class="line">                System.out.println(<span class="string">"Player three got it right? "</span> + p3isRight);</span><br><span class="line">                System.out.println(<span class="string">"Game is over."</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Players will have to try again."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameLauncher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GuessGame game = <span class="keyword">new</span> GuessGame();</span><br><span class="line">        game.startGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol>
<li><p>在创建类时，<code>.java</code>文件内只能有一个<code>public</code>声明的类，且类名需要与文件名一致，一般设定为包含<code>main()</code>函数的类。更规范的写法是为不同的类分别创建<code>.java</code>文件，维护各自的代码，通过文件之间的调用(<code>import</code>)实现交互。</p>
</li>
<li><p>Java垃圾回收。</p>
<p>创建对象时，不管对象如何创建的，它都会被存放于称为<code>堆</code>的内存区域，在Java中是<code>可回收垃圾的堆(Garbage-Collectible Heap)</code>。Java会根据对象的大小来分配内存空间，当Java虚拟机察觉到对象不再会被使用到时，该对象会被标记为可回收的。如果内存不足，垃圾收集器就会启动来清理垃圾、回收空间。</p>
</li>
<li><p>包装多个类成为单一应用程序形式。</p>
<p>可以把所有文件包装进依据<code>pkzip</code>格式来存档的<code>Java Archive-.jar文件</code>。在该<code>jar</code>文件中可以引入一个简单文字格式的文字文件，被称为<code>manifest</code>，里面有定义出<code>jar</code>中的哪一个文件带有启动应用程序的<code>main()</code>方法。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--4 对象的行为</title>
    <url>/2021/05/12/JavaLearning_Head_First_Java_4_behavior_of_objects.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>状态影响行为，行为影响变量。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-对象参数"><a href="#1-对象参数" class="headerlink" title="1. 对象参数"></a>1. 对象参数</h3><h4 id="1-1-对象的状态与行为"><a href="#1-1-对象的状态与行为" class="headerlink" title="1.1. 对象的状态与行为"></a>1.1. 对象的状态与行为</h4><p>类是对象的蓝图。在编写类时，是在描述Java虚拟机应该如何制作该类型的对象。</p>
<blockquote>
<p>类所描述的是对象<code>知道什么与执行什么</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/instance_and_method.PNG" alt="实例变量与方法"></p>
<p>同一个类型的对象能有不同的方法行为。每个实例有相同的方法，但方法可以根据实例变量的值变现不同行为。</p>
<h4 id="1-2-方法的参数"><a href="#1-2-方法的参数" class="headerlink" title="1.2. 方法的参数"></a>1.2. 方法的参数</h4><p>可以传值给方法。可以使用<code>实参(argument)</code>或<code>形参(parameter)</code>来调用传给方法的参数</p>
<blockquote>
<p>方法会运用形参，调用一方会传入实参</p>
<ul>
<li>实参是传给方法的值；</li>
<li>实参传入方法后就成为了形参；</li>
<li>参数跟局部变量一样。它也有类型和名称，可以在方法内运用</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/argument_and_parameter.PNG" alt="实参与形参"></p>
<h4 id="1-3-返回值"><a href="#1-3-返回值" class="headerlink" title="1.3. 返回值"></a>1.3. 返回值</h4><p>方法可以有返回值，每个方法都需要声明返回的类型。</p>
<blockquote>
<p><code>void</code>表示没有返回任何东西。</p>
</blockquote>
<p>比如可以声明一个返回<code>int</code>类型值的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">giveSecret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果声明了方法有返回值，必须返回声明类型的值！</p>
<h4 id="1-4-多个参数"><a href="#1-4-多个参数" class="headerlink" title="1.4. 多个参数"></a>1.4. 多个参数</h4><p>方法可以有多个参数，声明和传入时都要以逗号分开。</p>
<blockquote>
<p>一定要以正确数量，类型和顺序来传递参数</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/multipe_argument.PNG" alt="多个参数"></p>
<h4 id="1-5-参数传递"><a href="#1-5-参数传递" class="headerlink" title="1.5. 参数传递"></a>1.5. 参数传递</h4><p>Java通过值传递，或者通过拷贝传递参数。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/argument_pass.PNG" alt="参数传递"></p>
<blockquote>
<p><strong>方法无法改变调用方所传入的参数。</strong></p>
</blockquote>
<h4 id="1-6-要点"><a href="#1-6-要点" class="headerlink" title="1.6. 要点"></a>1.6. 要点</h4><blockquote>
<ul>
<li>如果传入的参数是对象，那么<strong>实际上传入的是远程控制的拷贝</strong>。</li>
<li>方法只能声明单一返回值。如果需要返回多个返回值，可以使用数组。如需要返回混合不同类型值，可以使用<code>ArrayList</code></li>
</ul>
</blockquote>
<h3 id="2-封装-Encapsulation"><a href="#2-封装-Encapsulation" class="headerlink" title="2. 封装(Encapsulation)"></a>2. 封装(Encapsulation)</h3><p>不封装可能会导致数据泄露。比如直接通过圆点运算符(<code>.</code>)来存取实例变量，可能会出现异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">theCat.height = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>需要创建<code>Setter</code>方法，使得在设置变量前可以进行检查。将程序实现从不良数据改成可以保护数据，且还能保持数据可修改，可以使用两个<code>存取修饰符(access modifier)</code>：公有修饰符<code>public</code>和私有修饰符<code>private</code>。封装的基本原则是：</p>
<blockquote>
<p>将实例变量标记为私有，提供公有的<code>getter</code>与<code>setter</code>方法来控制存取动作。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/advantage_of_setter.PNG" alt="封装的好处"></p>
<h3 id="3-初始化实例变量"><a href="#3-初始化实例变量" class="headerlink" title="3. 初始化实例变量"></a>3. 初始化实例变量</h3><p>声明变量是需要名称和类型，也可以同时初始化变量(为变量赋值)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">256</span>;</span><br></pre></td></tr></table></figure>
<p>如果未明确初始化实例变量，会为实例变量设置默认值。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/init_variable.PNG" alt="实例变量默认值"></p>
<blockquote>
<p>这么看，<code>String</code>变量内存储的也是一个对象引用。</p>
</blockquote>
<h3 id="4-实例变量与局部变量"><a href="#4-实例变量与局部变量" class="headerlink" title="4. 实例变量与局部变量"></a>4. 实例变量与局部变量</h3><p>实例变量与局部变量的区别：</p>
<blockquote>
<ul>
<li>实例变量声明在类内而不是方法中；而局部变量声明在方法中</li>
<li>局部变量使用前必须初始化，即<strong>局部变量没有默认值！</strong>如果在初始化前被调用，编译器会报错。</li>
</ul>
</blockquote>
<p>方法参数基本上与局部变量是相同的。</p>
<h3 id="5-变量的比较"><a href="#5-变量的比较" class="headerlink" title="5. 变量的比较"></a>5. 变量的比较</h3><h4 id="5-1"><a href="#5-1" class="headerlink" title="5.1 =="></a>5.1 <code>==</code></h4><blockquote>
<p><code>==</code>用于比较两个变量的字节组合是否相等。</p>
</blockquote>
<p>可以使用<code>==</code>来比较两个<code>primitive</code>主数据类型是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123; <span class="comment">// true &#125;</span></span><br></pre></td></tr></table></figure>
<p>也可以用<code>==</code>来判断两个引用是否指向同一对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo a = <span class="keyword">new</span> Foo();</span><br><span class="line">Foo b = <span class="keyword">new</span> Foo();</span><br><span class="line">Foo c = a;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123; <span class="comment">// false &#125;</span></span><br><span class="line"><span class="keyword">if</span> (a == c) &#123; <span class="comment">// true &#125;</span></span><br><span class="line"><span class="keyword">if</span> (b == c) &#123; <span class="comment">// false &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2-equals"><a href="#5-2-equals" class="headerlink" title="5.2 equals()"></a>5.2 <code>equals()</code></h4><p>使用<code>equals()</code>方法来判断两个对象是否在含义上相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1,s2,s3 = <span class="string">"abc"</span>, s4 =<span class="string">"abc"</span> ;</span><br><span class="line">s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">s1==s2   是 <span class="keyword">false</span>      <span class="comment">//两个变量的内存地址不一样，也就是说它们指向的对象不一样，</span></span><br><span class="line"></span><br><span class="line">s1.equals(s2) 是 <span class="keyword">true</span>    <span class="comment">//两个变量的所包含的内容是abc，故相等。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--7 继承与多态</title>
    <url>/2021/05/12/JavaLearning_Head_First_Java_7_inheritance_and_polymorphism.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>规划程序时要考虑未来。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h3><h4 id="1-1-继承"><a href="#1-1-继承" class="headerlink" title="1.1 继承"></a>1.1 继承</h4><p>设计<strong>继承</strong>时，会把共同程序代码放在某个类中，告诉其他类此类事他们的父类。当某个类继承另一个类的时候，也就是子类继承自父类。继承的关系意味着子类继承了父类的方法和实例变量。</p>
<p>如下一个例子</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceExample.PNG" alt="继承"></p>
<p><code>PantherMan</code>会自动继承<code>SuperHero</code>的实例变量和方法，且<code>PantherMan</code>也可以加入自己的方法和实例变量，或者覆盖掉继承的方法。而<code>FriedEggMan</code>不需要独特的行为，所以没有覆盖任何方法。</p>
<blockquote>
<p>实例变量无法覆盖是因为不需要，它们没有定义特殊的行为。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceExample.PNG" alt="继承范例"></p>
<p>在这个继承范例中，<code>Family Doctor</code>增加了实例变量和方法，<code>Surgeon</code>覆盖了继承的方法并增加了一个新方法。</p>
<blockquote>
<ul>
<li><p>需要注意继承使用的关键词<code>extends</code></p>
</li>
<li><p>如果在子类中还打算引用父类的方法，可以使用<code>super</code>关键字：</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.roam();</span><br><span class="line">     <span class="comment">// my own roam stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-继承层次设计"><a href="#1-2-继承层次设计" class="headerlink" title="1.2 继承层次设计"></a>1.2 继承层次设计</h4><p>比如以设计动物仿真程序为例，主要有以下步骤：</p>
<ol>
<li>找出具有共同属性和行为的对象</li>
<li>设计代表共同状态与行为的类</li>
<li>决定子类是否需要让某项行为(即方法的实现)有特定不同的运作方式</li>
<li>通过寻找使用共同行为的子类来找出更多抽象化的机会</li>
<li>完成类的继承层次</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/animalInheritanceTree.PNG" alt="动物类继承层次"></p>
<blockquote>
<p>当调用对象引用的方法时，会调用到与该对象类型最接近的方法。即<code>最低阶</code>会胜出。Java虚拟机会从树的叶节点开始往上寻找方法。</p>
</blockquote>
<p>所有子类与其任一个上层父类之间应该都是<code>IS-A</code>的关系。</p>
<h4 id="1-3-存取权限"><a href="#1-3-存取权限" class="headerlink" title="1.3 存取权限"></a>1.3 存取权限</h4><p>父类可以通过存取权限决定子类是否能够继承某些特定的成员。主要有以下4种存取权限，左边最受限制，越往右限制程度越小：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/accessLevels.PNG" alt="存取权限"></p>
<p><code>存取权限(Access levels)</code>控制谁可以接触什么：</p>
<blockquote>
<ul>
<li><code>public</code>类型的成员会被继承</li>
<li><code>private</code>类型的成员不会被继承</li>
</ul>
</blockquote>
<h4 id="1-4-继承的意义"><a href="#1-4-继承的意义" class="headerlink" title="1.4 继承的意义"></a>1.4 继承的意义</h4><p>通过继承，子类不需要重新编译就能运行到新版本的父类。此外通过继承可以：</p>
<ol>
<li><p>避免重复的程序代码</p>
<p>即可以在父类这一单一位置定义共同程序代码。</p>
</li>
<li><p>定义出共同的协议</p>
<p>继承可以确保每个父类下的所有类都会有父类所持有的全部(可继承的)方法。也就是说，通过继承来定义相关类之间的共同协议。</p>
</li>
</ol>
<h4 id="1-5-“私有类”"><a href="#1-5-“私有类”" class="headerlink" title="1.5 “私有类”"></a>1.5 “私有类”</h4><p>实际上没有”私有类”的概念，但有三种方法可以防止这个类被继承：</p>
<ol>
<li><p>存取控制。不能标记类为私有，但可以不标记为公有。非公有类只能被同一个包的类继承。</p>
</li>
<li><p>使用<code>final</code>修饰符。表示它是继承树的末端，不能被继承。</p>
<blockquote>
<p><code>final</code>表示符主要为保证安全，确保方法都是当前版本。</p>
<p>如果想防止特定方法被覆盖，可以在该方法前表示<code>final</code>修饰符。</p>
</blockquote>
</li>
<li><p>让类只拥有<code>private</code>的构造函数。</p>
</li>
</ol>
<h3 id="2-多态"><a href="#2-多态" class="headerlink" title="2. 多态"></a>2. 多态</h3><p>一般声明引用和创建对象时，重点在于要求引用类型与对象类型必须相符。而在多态下，引用与对象可以是不同类型：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphismExample.PNG" alt="多态"></p>
<p>运用多态时，引用类型可以时实际对象类型的父类。所以可以实现<code>多态数组(polymorphic arrays)</code>这一类东西：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphicArray.PNG" alt="多态数组"></p>
<p>参数和返回类型也可以用多态。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphicArgument.PNG" alt="参数多态"></p>
<h3 id="3-覆盖的规则"><a href="#3-覆盖的规则" class="headerlink" title="3. 覆盖的规则"></a>3. 覆盖的规则</h3><p>当要覆盖父类的方法时，必须遵守以下规则：</p>
<ol>
<li>参数必须一样，且返回类型必须兼容</li>
<li><strong>不能降低</strong>方法的存取权限</li>
</ol>
<h3 id="4-方法的重载-overload"><a href="#4-方法的重载-overload" class="headerlink" title="4. 方法的重载(overload)"></a>4. 方法的重载(overload)</h3><p>重载的意义是两个方法的名称相同，但参数不同。所以<strong>重载与多态毫无关系</strong>。</p>
<blockquote>
<p>重载的方法只是刚好有相同名字的不同方法，它与继承或多态无关</p>
</blockquote>
<p>重载的方法有更多的扩展性：</p>
<ol>
<li>返回类型可以不同</li>
<li>不能只改变返回类型。重载的条件是<strong>要使用不同的参数</strong>。</li>
<li>可以任意设定存取权限</li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--5 超强力方法</title>
    <url>/2021/05/12/JavaLearning_Head_First_Java_5_Extra-Strength_Methods.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>让方法产生更大的作用。创建一个类似战舰的游戏：攻击达康<br><a id="more"></a></p>
</blockquote>
<h3 id="1-创建一个类似战舰的游戏：攻击达康"><a href="#1-创建一个类似战舰的游戏：攻击达康" class="headerlink" title="1. 创建一个类似战舰的游戏：攻击达康"></a>1. 创建一个类似战舰的游戏：攻击达康</h3><h4 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1. 简介"></a>1.1. 简介</h4><p>一种棋盘类的战舰游戏，目标是猜测对方战舰的坐标，然后轮流开炮攻击，命中数发可以击沉对方战舰。</p>
<ul>
<li><strong>游戏目标</strong>：以最少的猜测次数打掉计算机安排的<code>达康公司(Dot Com)</code>网站。计算机根据表现来评分。</li>
<li><strong>初始设置</strong>：程序启动后，计算机会在虚拟的<code>7×7</code>方格上安排3个达康网站。然后开始要求猜坐标。</li>
<li><strong>进行游戏</strong>：目前先在命令栏上进行游戏。计算机根据输入所猜测的位置(比如<code>A3</code>或<code>C5</code>)等，返回命中<code>Hit</code>，未命中<code>Miss</code>或击沉<code>Sunk</code>等回应。清关所有网站后，会列出分数并结束。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/sunk_site.PNG" alt="攻击达康棋盘"></p>
<h4 id="1-2-顶层设计"><a href="#1-2-顶层设计" class="headerlink" title="1.2 顶层设计"></a>1.2 顶层设计</h4><p>首先，了解游戏流程。基本思路：</p>
<ol>
<li>玩家启动游戏</li>
</ol>
<blockquote>
<p>A. 计算机创建3个网站<br>B. 将3个网站停在虚拟战场(棋盘)上</p>
</blockquote>
<ol>
<li>游戏开始</li>
</ol>
<blockquote>
<p>重复以下操作直到所有网站被歼灭<br>A. 提示玩家输入坐标<br>B. 检查是否命中、未命中或击沉。命中删除格子，击沉删除网站。</p>
</blockquote>
<ol>
<li>游戏结束</li>
</ol>
<blockquote>
<p>根据猜测次数给分。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/flow_of_sunk_dotcom.PNG" alt="游戏流程图"></p>
<h4 id="1-3-简单的开始"><a href="#1-3-简单的开始" class="headerlink" title="1.3 简单的开始"></a>1.3 简单的开始</h4><p>至少需要两个类：<code>Game</code>类和<code>DotCom</code>类。首先从一个简单版本开始。</p>
<blockquote>
<p>只使用一个横列作为棋盘(即一维数组)，并只设定一家达康公司。游戏目标依旧相同。</p>
</blockquote>
<p>要注意虚拟的横列是虚幻的，即并没有真正在程序中声明一个一维数组。只需要玩家和计算机直到有3个连续格子会出现在7格的横列中。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simple_sunk_site.PNG" alt="简单版游戏"></p>
<h3 id="2-开发类"><a href="#2-开发类" class="headerlink" title="2 开发类"></a>2 开发类</h3><p>在创建Java程序时，主要依照以下过程：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/process_of_create_javaapp.PNG" alt="Java程序开发基本流程"></p>
<blockquote>
<p>最后一条是认真的吗</p>
</blockquote>
<p>我们会为每个类写出：<code>伪码(prep code)</code>、<code>测试码(test code)</code>和<code>真实码(real code)</code></p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/prepTestReal.PNG" alt="`伪码`、`测试码`和`真实码`"></p>
<blockquote>
<p><strong>伪码</strong>：帮助我们专注于逻辑而无需考虑程序语法</p>
<p><strong>测试码</strong>：测试用的程序代码</p>
<p><strong>真实码</strong>：实际设计出的真正Java程序代码</p>
</blockquote>
<h4 id="2-1-SimpleDotCom类"><a href="#2-1-SimpleDotCom类" class="headerlink" title="2.1 SimpleDotCom类"></a>2.1 <code>SimpleDotCom</code>类</h4><h5 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h5><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComPrep.PNG" alt="`SimpleDotCom`类伪码"></p>
<p>伪码介于Java程序和正常英语之间，大致包括3个部分：实例变量的声明、方法的声明和方法的逻辑。</p>
<blockquote>
<p>伪码最重要的部分是<strong>方法的逻辑</strong>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComPrepCode.PNG" alt="`SimpleDotCom`类伪码"></p>
<h5 id="测试码"><a href="#测试码" class="headerlink" title="测试码"></a>测试码</h5><p>编写方法的实现部分，实现可用的方法程序代码。先编写测试用代码的概念来自于<code>极限编程(Extreme Programming, XP)</code>方法论，可以使我们更快更任意写出程序代码。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/Extreme_Programming.PNG" alt="极限编程"></p>
<p>首先实现<code>SimpleDotCom</code>类中的方法，先实现<code>checkYourself()</code>这个方法。（至于<code>setLocationCells()</code>这个方法，可以很容易直到它是个<code>setter</code>方法）。首先要知道<code>checkYourself()</code>方法应该要测试的部分：</p>
<blockquote>
<ol>
<li><code>SimpleDotCom</code>对象的初始化；</li>
<li>赋值位置(即一个<code>int</code>数组)；</li>
<li>创建代表玩家猜测的字符串；</li>
<li>传入伪造的玩家猜测来调用<code>checkYourself()</code>方法；</li>
<li>列出结果观察结果是否正确。</li>
</ol>
</blockquote>
<p><code>SimpleDotCom</code>测试码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotComDrive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleDotCom dot = <span class="keyword">new</span> SimpleDotCom(); <span class="comment">// 初始化SimpleDotCom对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] locations = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// 创建 dot com 位置数组</span></span><br><span class="line">        dot.setLocationCells(locations); <span class="comment">// 调用 dot com 的 setter</span></span><br><span class="line"></span><br><span class="line">        String userGuess = <span class="string">"2"</span>; <span class="comment">// 假的猜测</span></span><br><span class="line">        String result = dot.checkYourself(userGuess); <span class="comment">// 调用被测试的方法, 传入假数据</span></span><br><span class="line">        String testResult = <span class="string">"failed"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.equals(<span class="string">"hit"</span>)) &#123;</span><br><span class="line">            testResult = <span class="string">"passed"</span>; <span class="comment">// 测试返回 "hit" 才算成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.println(testResult); <span class="comment">// 输出测试结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思索与编写测试用的程序代码能够帮助我们了解被测试的应用程序应该要做哪些事情。当实作代码完成时，也可以有准备好地测试代码进行验证。</p>
<p>理想上，先写出一点测试码，然后编写能够通过该测试的方法。之后再编写测试码，编写新的实现使其通过测试。如此循环，就可以证明新加入代码不会破坏原有已经测试过的部分。</p>
</blockquote>
<h5 id="真实码"><a href="#真实码" class="headerlink" title="真实码"></a>真实码</h5><p>从伪码到真正的Java程序代码之间，不会完美对应，需要有一些调整。下面使<code>checkYourself()</code>方法的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotCom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] locationCells;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfHIts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLocationCells</span> <span class="params">(<span class="keyword">int</span>[] locations)</span> </span>&#123;</span><br><span class="line">        locationCells = locations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkYourself</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> guess = Integer.parseInt(userGuess); <span class="comment">// 字符串转int</span></span><br><span class="line">        String result = <span class="string">"miss"</span>; <span class="comment">// 创建保存返回结果的变量, 以miss作为默认值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cell: locationCells) &#123; <span class="comment">// 对每个格子重复执行</span></span><br><span class="line">            <span class="keyword">if</span> (guess == cell) &#123; <span class="comment">// 比较格子与猜测值</span></span><br><span class="line">                result = <span class="string">"hit"</span>; <span class="comment">// 命中</span></span><br><span class="line">                numOfHIts++;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 离开循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numOfHIts == locationCells.length) &#123; <span class="comment">// 判断是否击沉</span></span><br><span class="line">            result = <span class="string">"kill"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result); <span class="comment">// 显式结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-SimpleDotComGame类"><a href="#2-2-SimpleDotComGame类" class="headerlink" title="2.2 SimpleDotComGame类"></a>2.2 <code>SimpleDotComGame</code>类</h4><h5 id="伪码-1"><a href="#伪码-1" class="headerlink" title="伪码"></a>伪码</h5><p><code>SimpleDotComGame</code>类伪码如下：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComGamePrepCode.PNG" alt="`SimpleDotComGame`类伪码"></p>
<p><code>SimpleDotComGame</code>类需要有以下功能：</p>
<blockquote>
<ol>
<li>创建出<code>SimpleDotCom</code>对象</li>
<li>初始化赋值该对象</li>
<li>要求玩家开始猜测</li>
<li>检查猜测值</li>
<li>重复猜测直到击沉为止</li>
<li>显示玩家猜测次数</li>
</ol>
</blockquote>
<h5 id="真实码-1"><a href="#真实码-1" class="headerlink" title="真实码"></a>真实码</h5><p>这里跳过了这个类的测试程序，因为次游戏测试程序只有一个<code>main</code>方法。其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotComGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfGuesses = <span class="number">0</span>; <span class="comment">// 记录玩家猜测次数</span></span><br><span class="line">        GameHelper helper = <span class="keyword">new</span> GameHelper(); <span class="comment">// 使用该类来获取玩家输入</span></span><br><span class="line"></span><br><span class="line">        SimpleDotCom theDotCom = <span class="keyword">new</span> SimpleDotCom();</span><br><span class="line">        <span class="keyword">int</span> randomNum = (<span class="keyword">int</span>) (Math.random() * <span class="number">5</span>); <span class="comment">// 随机数用作第一格的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] locations = &#123;randomNum, randomNum+<span class="number">1</span>, randomNum+<span class="number">2</span>&#125;;</span><br><span class="line">        theDotCom.setLocationCells(locations);</span><br><span class="line">        <span class="keyword">boolean</span> isAlive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(isAlive) &#123;</span><br><span class="line">            String guess = helper.getUserInput(<span class="string">"enter a guess number"</span>);</span><br><span class="line">            String result = theDotCom.checkYourself(guess);</span><br><span class="line">            numOfGuesses++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"kill"</span>)) &#123;</span><br><span class="line">                isAlive = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(<span class="string">"You took "</span> + numOfGuesses + <span class="string">" guesses!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有一个带有<code>getUserInput</code>方法的类<code>GameHelper</code>。它可以从命令行获取输入，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInput</span><span class="params">(String prompt)</span> </span>&#123;</span><br><span class="line">        String inputLine = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(prompt + <span class="string">"  "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">            );</span><br><span class="line">            inputLine = is.readLine();</span><br><span class="line">            <span class="keyword">if</span> (inputLine.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inputLine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-要点"><a href="#2-3-要点" class="headerlink" title="2.3 要点"></a>2.3 要点</h4><p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/keyPointOfChapter5.PNG" alt="要点"></p>
<h3 id="3-关于for循环"><a href="#3-关于for循环" class="headerlink" title="3. 关于for循环"></a>3. 关于<code>for</code>循环</h3><h4 id="3-1-基本的for循环"><a href="#3-1-基本的for循环" class="headerlink" title="3.1 基本的for循环"></a>3.1 基本的<code>for</code>循环</h4><p>一个基本的<code>for</code>循环如下：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/regularForLoops.PNG" alt="基本的`for`循环"></p>
<p>即重复执行代码100次，编译器解释为:</p>
<blockquote>
<ol>
<li>创建变量<code>i</code>并赋值为<code>0</code>；</li>
<li>只要<code>i</code>小于<code>100</code>就重复执行；</li>
<li>每次重复过程最后把<code>i</code>加<code>1</code>。</li>
</ol>
</blockquote>
<p>主要分为三个部分：</p>
<h5 id="第一部分：初始化-initialization"><a href="#第一部分：初始化-initialization" class="headerlink" title="第一部分：初始化(initialization)"></a>第一部分：初始化(initialization)</h5><p>声明和初始化在循环体内的变量，通常将该变量作为<code>计数器</code>。</p>
<h5 id="第二部分：boolean测试-boolean-test"><a href="#第二部分：boolean测试-boolean-test" class="headerlink" title="第二部分：boolean测试(boolean test)"></a>第二部分：boolean测试(boolean test)</h5><p>测试条件计算出一个<code>boolean</code>值。可以使boolean表达式，或返回boolean值的方法。</p>
<h5 id="第三部分：重复表达式-iteration-expression"><a href="#第三部分：重复表达式-iteration-expression" class="headerlink" title="第三部分：重复表达式( iteration expression)"></a>第三部分：重复表达式( iteration expression)</h5><p>安置每趟循环完成后要执行的项目。</p>
<blockquote>
<p><code>whlie</code>循环与<code>for</code>循环的区别是，<code>while</code>循环只有<code>boolean</code>测试，它并没有内建的初始化或重复表达式。</p>
<ul>
<li><code>while</code>适合在不清楚循环次数的循环上；</li>
<li><code>for</code>相对来说更容易阅读。</li>
</ul>
</blockquote>
<p>此外，这里可以说明一下前置与后置的递增/递减操作符：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/IncrementDecrementOperator.PNG" alt="基本的`for`循环"></p>
<h4 id="3-2-加强版的for循环"><a href="#3-2-加强版的for循环" class="headerlink" title="3.2 加强版的for循环"></a>3.2 加强版的<code>for</code>循环</h4><p>从<code>Java 5.0</code>开始，有加强版的<code>for</code>循环，可以逐个运行数组或其他集合的元素。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/enhancedforloop.PNG" alt="加强版的`for`循环"></p>
<p>即对<code>nameArray</code>中每个元素执行一次，编译器解释为:</p>
<blockquote>
<ol>
<li>创建名称为<code>name</code>的<code>String</code>变量；</li>
<li>将<code>nameArray</code>的第一个元素赋值给<code>name</code>；</li>
<li>执行重复内容；</li>
<li>赋值给下一个元素<code>name</code>；</li>
<li>重复执行直到所有元素都被运行为止。</li>
</ol>
</blockquote>
<p>主要分为两个部分：</p>
<h5 id="第一部分：声明循环变量-iteration-variable-declaration"><a href="#第一部分：声明循环变量-iteration-variable-declaration" class="headerlink" title="第一部分：声明循环变量(iteration variable declaration)"></a>第一部分：声明循环变量(iteration variable declaration)</h5><p>声明和初始化用在循环体内的变量，循环过程中该变量的值会不断变化。此变量的类型需要与数组元素类型匹配。</p>
<h5 id="第二部分：要运行的集合-the-actual-collection"><a href="#第二部分：要运行的集合-the-actual-collection" class="headerlink" title="第二部分：要运行的集合(the actual collection)"></a>第二部分：要运行的集合(the actual collection)</h5><p>必须是对数组或其他集合的引用。</p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--6 认识Java的API</title>
    <url>/2021/05/12/JavaLearning_Head_First_Java_6_Using_the_Java_Library.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>Java内置有数百个类。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-解决上一章程序的bug"><a href="#1-解决上一章程序的bug" class="headerlink" title="1. 解决上一章程序的bug"></a>1. 解决上一章程序的bug</h3><p>上一章的简单版游戏中，一旦猜中了一格，可以持续攻击同一格结束游戏。需要一种机制判别之前是否已经猜中过。</p>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>使用第二个数组，一旦玩家猜中某格，就把对应的格设置为true，之后每次猜中都检查是否已经猜中过。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionOneForDotComBug.PNG" alt="方案一"></p>
<p>但这种方法过于耗时，每次猜中某一格，都必须检查或改变第二个数组的状态，且需要额外的空间。</p>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>只动用原来数组，将任何被命中的格子改为<code>-1</code>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionTwoForDotComBug.PNG" alt="方案二"></p>
<p>但依旧不是很有效率，已经命中过的格子还是需要再次被搜索。</p>
<h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p>在命中某个格子后，就把它删掉，格子会越来越少。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionThreeForDotComBug.PNG" alt="方案三"></p>
<p>但数组大小无法改变，必须创建新数组并进行拷贝。如果有<em>可变数组</em>就可以解决这个问题。</p>
<h3 id="2-ArrayList类"><a href="#2-ArrayList类" class="headerlink" title="2. ArrayList类"></a>2. <code>ArrayList</code>类</h3><p><code>ArrayList</code>类是Java库函数中的一个类，是一个”边长的数组”。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/someMethodsArrayList.PNG" alt="`ArrayList`类部分方法"></p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/someMethodsArrayList2.PNG" alt="`ArrayList`的操作"></p>
<p><code>ArrayList</code>与一般数组的区别：</p>
<blockquote>
<ul>
<li>一般数组在创建时必须确定大小，但<code>ArrayList</code>只需要创建出该类型对象就可以。</li>
<li>存放对象时，一般数组需要指定位置；<code>ArrayList</code>可以使用方法<code>add()</code>。</li>
<li>一般数组使用<code>[]</code>来存取对象；<code>ArrayList</code>使用<code>get</code>方法。</li>
<li>在<code>Java 5.0</code>中<code>ArrayList</code>是<strong>参数化的(parameterized)</strong>，即<code>ArrayList&lt;Type&gt;</code>。<code>&lt;Type&gt;</code>是类型参数，代表<code>Type</code>类型的集合。</li>
</ul>
</blockquote>
<h3 id="3-完整版”Sink-a-Dot-Com”"><a href="#3-完整版”Sink-a-Dot-Com”" class="headerlink" title="3. 完整版”Sink a Dot Com”"></a>3. 完整版”Sink a Dot Com”</h3><p>需要对原来的三个类进行修改：</p>
<blockquote>
<ul>
<li><code>DotCom</code>类。原来的<code>SimpleDotCom</code>类。<ul>
<li>需要增加名称变量来保存<code>DotCom</code>的名字。</li>
</ul>
</li>
<li><code>DotComBust</code>类。原来的<code>SimpleDotComGame</code>类。<ul>
<li>需要创建多个<code>DotCom</code>对象。</li>
<li>将<code>DotCom</code>对象放到方阵上。</li>
<li>每次猜测要检查多个<code>DotCom</code>，所有都击沉后才能结束游戏。</li>
<li>脱离<code>main()</code>函数。</li>
</ul>
</li>
<li><code>GameHelper</code>类。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/fullDotComGame.PNG" alt="完整版&quot;Sink a Dot Com&quot;类间关系"></p>
<h4 id="3-1-DotComBust类"><a href="#3-1-DotComBust类" class="headerlink" title="3.1 DotComBust类"></a>3.1 <code>DotComBust</code>类</h4><h5 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h5><p><code>DotComBust</code>类有3个任务：启动游戏，运行游戏以及结束游戏。可以对运行游戏任务分解，较小的方法更容易测试修改。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dotComBustPrepCode.PNG" alt="DotComBust伪码"></p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dotComBustPrepCodeContinued.PNG" alt="DotComBust伪码（续）"></p>
<h5 id="真实码"><a href="#真实码" class="headerlink" title="真实码"></a>真实码</h5><p><code>DotComBust</code>类Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotComBust</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GameHelper helper = <span class="keyword">new</span> GameHelper();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;DotCom&gt; dotComList = <span class="keyword">new</span> ArrayList&lt;DotCom&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfGuesses = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建dotCom实例，并加入到dotComList中</span></span><br><span class="line">        DotCom one = <span class="keyword">new</span> DotCom();</span><br><span class="line">        one.setName(<span class="string">"Pets.com"</span>);</span><br><span class="line">        dotComList.add(one);</span><br><span class="line"></span><br><span class="line">        DotCom two = <span class="keyword">new</span> DotCom();</span><br><span class="line">        two.setName(<span class="string">"eToys.com"</span>);</span><br><span class="line">        dotComList.add(two);</span><br><span class="line"></span><br><span class="line">        DotCom three = <span class="keyword">new</span> DotCom();</span><br><span class="line">        three.setName(<span class="string">"Go2.com"</span>);</span><br><span class="line">        dotComList.add(three);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出提示信息</span></span><br><span class="line">        System.out.println(<span class="string">"Your goal is to sink three dot coms."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Pets.com, eToys.com, Go2.com"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Try to sink them all in the fewest number of guesses"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化每个dotCom在棋盘中的位置</span></span><br><span class="line">        <span class="keyword">for</span> (DotCom dotComToSet: dotComList) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; newLocation = helper.placeDotCom(<span class="number">3</span>);</span><br><span class="line">            dotComToSet.setLocationCells(newLocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startPlaying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!dotComList.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取用户的猜测值</span></span><br><span class="line">            String userGuess = helper.getUserInput(<span class="string">"Enter a guess"</span>);</span><br><span class="line">            <span class="comment">// 检查玩家猜测值</span></span><br><span class="line">            checkUserGuess(userGuess);</span><br><span class="line">        &#125;</span><br><span class="line">        finishGame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkUserGuess</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        numOfGuesses++;</span><br><span class="line">        String result = <span class="string">"miss"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (DotCom dotComToSet: dotComList) &#123;</span><br><span class="line">            result = dotComToSet.checkYourself(userGuess);</span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"hit"</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"kill"</span>)) &#123;</span><br><span class="line">                dotComList.remove(dotComToSet);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"All Dot Coms are dead! Your stock is now worthless."</span>);</span><br><span class="line">        <span class="keyword">if</span> (numOfGuesses &lt;= <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"It only took you "</span> + numOfGuesses + <span class="string">" guesses."</span>);</span><br><span class="line">            System.out.println(<span class="string">" You got out before your options sank."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Took you long enough. "</span> + numOfGuesses + <span class="string">" guesses."</span>);</span><br><span class="line">            System.out.println(<span class="string">"Fish are dancing with your options."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotComBust game = <span class="keyword">new</span> DotComBust();</span><br><span class="line">        game.setUpGame();</span><br><span class="line">        game.startPlaying();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-DotCom类"><a href="#3-2-DotCom类" class="headerlink" title="3.2 DotCom类"></a>3.2 <code>DotCom</code>类</h4><p><code>DotCom</code>类Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotCom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; locationCells;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocationCells</span> <span class="params">(ArrayList&lt;String&gt; locations)</span> </span>&#123;</span><br><span class="line">        locationCells = locations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkYourself</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">"miss"</span>; <span class="comment">// 创建保存返回结果的变量, 以miss作为默认值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (locationCells.contains(userGuess)) &#123;</span><br><span class="line">            locationCells.remove(userGuess);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(locationCells.isEmpty()) &#123;</span><br><span class="line">                result = <span class="string">"kill"</span>;</span><br><span class="line">                System.out.println(<span class="string">"Ouch! You sunk "</span> + name + <span class="string">" :("</span>); <span class="comment">// 显式结果</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="string">"hit"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(result); // 显式结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-GameHelper类"><a href="#3-3-GameHelper类" class="headerlink" title="3.3 GameHelper类"></a>3.3 <code>GameHelper</code>类</h4><p><code>GameHelper</code>类除了获取玩家输入外，还增加了设置<code>DotCom</code>的位置这一功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String alphabet = <span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gridLength = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gridSize = <span class="number">49</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] grid = <span class="keyword">new</span> <span class="keyword">int</span>[gridSize];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> comCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInput</span><span class="params">(String prompt)</span> </span>&#123;</span><br><span class="line">        String inputLine = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(prompt + <span class="string">"  "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">            );</span><br><span class="line">            inputLine = is.readLine();</span><br><span class="line">            <span class="keyword">if</span> (inputLine.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inputLine.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">placeDotCom</span><span class="params">(<span class="keyword">int</span> comSize)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; alphaCells = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        String temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 现有字符串</span></span><br><span class="line">        <span class="keyword">int</span> [] coords = <span class="keyword">new</span> <span class="keyword">int</span> [comSize];</span><br><span class="line">        <span class="comment">// 目前测试的字符串</span></span><br><span class="line">        <span class="keyword">int</span> attempts = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到适合的位置吗？</span></span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 目前起点</span></span><br><span class="line">        <span class="keyword">int</span> location = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在处理到第n个dot com</span></span><br><span class="line">        comCount++;</span><br><span class="line">        <span class="comment">// incr是增量, 水平方向增量(+1), 垂直增量(+7, gridLength)</span></span><br><span class="line">        <span class="keyword">int</span> incr = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果是单数号dot com, 垂直增量</span></span><br><span class="line">        <span class="keyword">if</span> ((comCount % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            incr = gridLength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主要搜索循环</span></span><br><span class="line">        <span class="keyword">while</span> (!success &amp; attempts++ &lt; <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 随机起点</span></span><br><span class="line">            location = (<span class="keyword">int</span>) (Math.random() * gridSize);</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 假设是适合的位置</span></span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查找未使用的点</span></span><br><span class="line">            <span class="keyword">while</span> (success &amp;&amp; x &lt; comSize) &#123;</span><br><span class="line">                <span class="comment">// 若未使用</span></span><br><span class="line">                <span class="keyword">if</span> (grid[location] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 存储位置，尝试下一个点</span></span><br><span class="line">                    coords[x++] = location;</span><br><span class="line">                    location += incr;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 超出边缘, 失败, 不是适合的</span></span><br><span class="line">                    <span class="keyword">if</span> (location &gt;= gridSize) &#123;</span><br><span class="line">                        success = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 水平方向超出边缘, 失败</span></span><br><span class="line">                    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; (location % gridLength) == <span class="number">0</span>) &#123;</span><br><span class="line">                        success = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 该位置已经使用过</span></span><br><span class="line">                    success = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将位置转换为字符串</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(x &lt; comSize) &#123;</span><br><span class="line">            <span class="comment">// 标示格子已用</span></span><br><span class="line">            grid[coords[x]] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 行值</span></span><br><span class="line">            row = (<span class="keyword">int</span>) (coords[x] / gridLength);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 列值</span></span><br><span class="line">            column = coords[x] % gridLength;</span><br><span class="line">            temp = String.valueOf(alphabet.charAt(column));</span><br><span class="line"></span><br><span class="line">            alphaCells.add(temp.concat(Integer.toString(row)));</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  alphaCells;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-布尔表达式"><a href="#4-布尔表达式" class="headerlink" title="4. 布尔表达式"></a>4. 布尔表达式</h3><ol>
<li><p>“与”和“或”运算符(<code>&amp;&amp;</code>, <code>||</code>)</p>
</li>
<li><p>“不等于”运算符(<code>!=</code>和<code>!</code>)</p>
</li>
<li><p>短运算符(<code>&amp;&amp;</code>, <code>||</code>)</p>
<blockquote>
<p>比如<code>&amp;&amp;</code>表达式中，左右两边都为<code>true</code>这个表达式才为<code>true</code>。因此<code>Java</code>虚拟机发现左方表达式为<code>false</code>时不需要也不会计算右边表达式。<code>||</code>类似。基于这样的性质可以避免调用内容为<code>null</code>的引用变量：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (refVar != <span class="keyword">null</span> &amp;&amp; refVar.isValidType() ) &#123;</span><br><span class="line"> <span class="comment">// do ‘got a valid type’ stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>长运算符(<code>&amp;</code>, <code>|</code>)</p>
<p><code>&amp;</code>和 <code>|</code>运算符通常用于位运算，Java虚拟机会计算运算符两边的算式。</p>
</li>
</ol>
<h3 id="5-使用库函数-Java-API"><a href="#5-使用库函数-Java-API" class="headerlink" title="5. 使用库函数(Java API)"></a>5. 使用库函数(<code>Java API</code>)</h3><h4 id="5-1-库函数的使用"><a href="#5-1-库函数的使用" class="headerlink" title="5.1 库函数的使用"></a>5.1 库函数的使用</h4><p>在<code>Java API</code>中，类是包装在<code>包</code>中的。要使用<code>API</code>中的类，必须直到它在哪个包中。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/apiPakage.PNG" alt="在`Java API`中，类被包装在`包`中"></p>
<p>必须指明程序代码中所使用到的类的完整名称。(<strong>除了<code>java.lang</code>之外</strong>)</p>
<blockquote>
<p>比如<code>ArrayList</code>的完整名称应该是：<code>java.util.ArrayList</code></p>
</blockquote>
<p>主要有两种方法可以指定使用的是哪一个<code>ArrayList</code>：</p>
<ol>
<li><p><code>Import</code></p>
<p>在程序源文件最前面放上<code>import</code>述句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;... &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>Type</code></p>
<p>直接在程序代码中打出全名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line">java.util.ArrayList&lt;Dog&gt; list = <span class="keyword">new</span> java.util.ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用参数</span></span><br><span class="line">java.util.ArrayList&lt;Dog&gt; list = <span class="keyword">new</span> java.util.ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型</span></span><br><span class="line"><span class="keyword">public</span> java.util.<span class="function">ArrayList&lt;Dog&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><code>java.lang</code>是个预先被引用的包，因为<code>java.lang</code>是经常会被用到的基础包，所有可以不必指定名称。比如<code>java.lang.String</code>与<code>java.lang.System</code>都不需要<code>import</code>或写全名。</p>
</blockquote>
<h4 id="5-2-关于javax开头的包中x的含义"><a href="#5-2-关于javax开头的包中x的含义" class="headerlink" title="5.2 关于javax开头的包中x的含义"></a>5.2 关于<code>javax</code>开头的包中<code>x</code>的含义</h4><p><code>javax</code>作为开头的包是指标准版的扩展函数库。后来纳入到标准库中后，为了保持程序的兼容性，故而沿用了<code>javax</code>这一命名。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/javaxHistory.PNG" alt="`javax`中`x`的由来"></p>
<h4 id="5-3-如何查阅API"><a href="#5-3-如何查阅API" class="headerlink" title="5.3 如何查阅API"></a>5.3 如何查阅<code>API</code></h4><p>使用函数库必须知道：</p>
<ol>
<li>库中有哪些类</li>
<li>这些类是做什么的</li>
</ol>
<p>主要方法是：</p>
<ol>
<li>查阅参考书</li>
<li>查阅HTML API文档</li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--2 Java内存区域与内存溢出异常</title>
    <url>/2021/05/12/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_2_Java_memory_area.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code><br><a id="more"></a></p>
</blockquote>
<p>在<code>Java</code>虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的<code>delete/free</code>代码，不容易出现内存泄漏和内存溢出问题。</p>
<p>但也因此，如果不了解虚拟机是怎样使用内存的，一旦出现内存泄漏和溢出方面的问题，那排查错误、修正问题将会成为一项异常艰难的工作。</p>
<h3 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1 运行时数据区域"></a>1 运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为<strong>若干个不同的数据区域</strong>。这些区域有各自的用途，以及创建和销毁的时间，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/runtimeDataArea.PNG" alt="Java虚拟机运行时数据区"></p>
<h4 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h4><p><code>程序计数器（Program Counter Register）</code>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。字节码解释器工作时就是通过改变这个计数器的值来<strong>选取下一条需要执行的字节码指令</strong>。</p>
<blockquote>
<p>程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
</blockquote>
<p>Java虚拟机的多线程是通过<strong>线程轮流切换、分配处理器执行时间</strong>的方式来实现的，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</p>
<blockquote>
<p>这类内存区域为“线程<code>私有</code>”的内存</p>
</blockquote>
<p>如果线程正在执行的是一个<code>Java方法</code>，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<code>本地（Native）方法</code>，这个计数器值则应为空（Undefined）。</p>
<blockquote>
<p>此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何<code>OutOfMemoryError情况</code>的区域。</p>
</blockquote>
<h4 id="1-2-Java虚拟机栈"><a href="#1-2-Java虚拟机栈" class="headerlink" title="1.2 Java虚拟机栈"></a>1.2 Java虚拟机栈</h4><p><code>Java虚拟机栈（Java Virtual Machine Stack）</code>描述的是<strong>Java<code>方法</code>执行的线程内存模型</strong>：每个<code>方法</code>被执行的时候，Java虚拟机都会同步创建一个<code>栈帧（Stack Frame）</code>用于存储<em>局部变量表、操作数栈、动态连接、方法出口</em>等信息。</p>
<blockquote>
<p><code>Java虚拟机栈（Java Virtual Machine Stack）</code>也是线程<code>私有</code>的，它的生命周期与线程相同。</p>
</blockquote>
<p>有人把Java内存区域笼统地划分为<code>堆内存（Heap）</code>和<code>栈内存（Stack）</code>。<strong>“栈”通常就是指虚拟机栈</strong>，或者更多的情况下只是指虚拟机栈中<em>局部变量表部分</em>。</p>
<blockquote>
<p>局部变量表中的存储空间以<code>局部变量槽（Slot）</code>来表示，其中64位长度的<code>long</code>和<code>double</code>类型的数据会<em>占用两个变量槽</em>，其余的数据类型只占用一个。</p>
<p><strong>局部变量表所需的内存空间在编译期间完成分配</strong>，一个方法需要在栈帧中分配多大的局部变量空间是<strong>完全确定</strong>的，在方法运行期间不会改变局部变量表的大小(<em>“大小”是指变量槽的数量</em>)</p>
</blockquote>
<p>这个内存区域规定了两类异常状况：</p>
<blockquote>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError异常</code></li>
<li>如果Java虚拟机栈容量可以<em>动态扩展</em>，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError异常</code></li>
</ul>
</blockquote>
<h4 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h4><p><code>本地方法栈（Native Method Stacks）</code>与虚拟机栈所发挥的作用是非常相似的，其<strong>区别</strong>只是：</p>
<blockquote>
<p>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务；</p>
<p>本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
</blockquote>
<p>有的Java虚拟机（譬如<code>Hot-Spot虚拟机</code>）直接把<strong>本地方法栈和虚拟机栈合二为一</strong>。</p>
<blockquote>
<p>本地方法栈规定了<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p>
</blockquote>
<h4 id="1-4-Java堆"><a href="#1-4-Java堆" class="headerlink" title="1.4 Java堆"></a>1.4 Java堆</h4><p><code>Java堆（Java Heap）</code>唯一目的就是<strong>存放对象实例</strong>，Java世界里<em>“几乎”</em>所有的对象实例都在这里分配内存。Java堆是被所有线程<code>共享</code>的一块内存区域，在虚拟机启动时创建，也是虚拟机所管理的内存中<em>最大</em>的一块。</p>
<blockquote>
<p>在《Java虚拟机规范》中对Java堆的描述是：<code>“所有的对象实例以及数组都应当在堆上分配”</code></p>
</blockquote>
<p>Java堆是<strong>垃圾收集器管理的内存区域</strong>，因此它也被称作<code>“GC堆”（Garbage Collected Heap）</code>。如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个<strong>线程私有</strong>的<code>分配缓冲区 （Thread Local Allocation Buffer，TLAB）</code>。</p>
<p>Java堆可以处于<code>物理上不连续</code>的内存空间中，但在逻辑上它应该被视为连续的。</p>
<blockquote>
<p>如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出<code>OutOfMemoryError异常</code>。</p>
</blockquote>
<h4 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h4><p><code>方法区（Method Area）</code>用于存储<strong>已被虚拟机加载</strong>的<em>类型信息、常量、静态变量、即时编译器编译后的代码缓存</em>等数据。与Java堆一样，是各个线程<code>共享</code>的内存区域。</p>
<blockquote>
<p>《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作<code>“非堆”（Non-Heap）</code></p>
</blockquote>
<p>很多人都更愿意把方法区称为<code>“永久代”（Permanent Generation）</code>，或将两者混为一谈。<strong>本质上这两者并不是等价的</strong>，因为仅仅是<strong>使用永久代来实现方法区</strong>而已。</p>
<blockquote>
<ul>
<li>永久代来实现方法区导致了Java应用更容易遇到<code>内存溢出</code>的问题（永久代有<code>-XX：MaxPermSize</code>的上限，即使不设置也有默认大小)；</li>
<li>在JDK 6的时候HotSpot开发团队就有<strong>放弃永久代</strong>，逐步改为<strong>采用本地内存（Native Memory）</strong>来实现方法区的计划了；</li>
<li>JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出；</li>
<li>而到了JDK 8，终于<strong>完全废弃了永久代的概念</strong>，改用与JRockit、J9一样在本地内存中实现的<code>元空间（Meta-space）</code>来代替。</li>
</ul>
</blockquote>
<p>除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择<strong>不实现垃圾收集</strong>。</p>
<blockquote>
<p>这区域的内存回收目标主要是针<strong>对常量池的回收</strong>和<strong>对类型的卸载</strong></p>
<p>如果方法区无法满足新的内存分配需求时，将抛出 <code>OutOfMemoryError异常</code>。</p>
</blockquote>
<h4 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h4><p><code>运行时常量池（Runtime Constant Pool）</code>是<strong>方法区的一部分</strong>。<code>Class文件</code>中有一项信息是<code>常量池表（Constant Pool Table）</code>，用于存放编译期生成的各种<strong>字面量</strong>与<strong>符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<blockquote>
<p>Class文件中还包括类的<em>版本、字段、方法、接口等描述信息</em></p>
</blockquote>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，运行期间也可以将新的常量放入池中。</p>
<blockquote>
<p>当常量池无法再申请到内存时会抛出<code>OutOfMemoryError异常</code>。</p>
</blockquote>
<h4 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7 直接内存"></a>1.7 直接内存</h4><p><code>直接内存（Direct Memory）</code>并不是虚拟机运行时数据区的一部分。</p>
<blockquote>
<p>在<code>JDK 1.4</code>中新加入了<code>NIO（New Input/Output）类</code>，引入了一种基于<code>通道（Channel）</code>与<code>缓冲区 （Buffer）</code>的I/O方式，它可以使用<strong><code>Native函数库</code>直接分配堆外内存</strong>，然后通过一个存储在Java堆里面的<code>DirectByteBuffer</code>对象作为<strong>这块内存的引用</strong>进行操作。</p>
<p>避免了在<code>Java堆</code>和<code>Native堆</code>中来回复制数据。</p>
</blockquote>
<p>本机直接内存的分配不会受到Java堆大小的限制，但是肯定还是会受到本机总内存大小以及处理器寻址空间的限制：</p>
<blockquote>
<p>动态扩展时可能会出现 <code>OutOfMemoryError异常</code>。</p>
</blockquote>
<h3 id="2-HotSpot虚拟机对象探秘"><a href="#2-HotSpot虚拟机对象探秘" class="headerlink" title="2. HotSpot虚拟机对象探秘"></a>2. <code>HotSpot</code>虚拟机对象探秘</h3><h4 id="2-1-对象的创建"><a href="#2-1-对象的创建" class="headerlink" title="2.1 对象的创建"></a>2.1 对象的创建</h4><p>在虚拟机中<code>(普通)对象</code>的创建过程如下：</p>
<blockquote>
<ol>
<li>当Java虚拟机遇到一条<code>字节码new指令</code>时，首先将去检查这个指令的参数是否能在<code>常量池</code>中定位到一个类的<code>符号引用</code>，并且检查这个符号引用代表的类是否已被<strong>加载、解析和初始化</strong>过。如果没有，必须先执行相应的<strong>类加载过程</strong>。</li>
<li>在类加载检查通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。<em>对象所需内存的大小在类加载完成后便可完全确定</em>，为对象分配空间的任务实际上便等同于把一块<u>确定大小</u>的内存块从<code>Java堆</code>中划分出来。<ul>
<li><code>“指针碰撞”（Bump The Pointer）</code>。如果Java堆中内存是<strong>绝对规整</strong>的，所有被<u>使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器</u>。那所分配内存就仅仅是把指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</li>
<li><code>“空闲列表”（Free List）</code>。如果Java堆中的内存是<strong>不规整</strong>的，已被使用的内存和空闲的内存相互交错在一起，<u>虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</u>。</li>
<li>Java堆是否规整<u>由所采用的垃圾收集器是否带有<code>空间压缩整理（Compact）</code>的能力决定</u>。</li>
<li>为了保证对象创建过程<code>线程安全</code>，有两种方法：<ul>
<li>对分配内存空间的动作进行<code>同步处理</code>——实际上虚拟机是采用<code>CAS配上失败重试</code>的方式保证<strong>更新操作的原子性</strong>；</li>
<li><u>把内存分配的动作按照线程划分在不同的空间之中进行</u>，即每个线程在Java堆中<strong>预先分配一小块内存</strong>，称为<code>本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）</code>。线程要分配内存，就在该线程的本地缓冲区中分配，<u>只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定</u>。</li>
</ul>
</li>
</ul>
</li>
<li>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都<strong><code>初始化为零值</code></strong>，如果使用了<code>TLAB</code>，这一项工作也可以提前至<code>TLAB</code>分配时进行。</li>
<li>Java虚拟机对对象进行<strong>必要的设置</strong>，例如<u>对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的<code>GC</code>分代年龄等</u>信息。这些信息存放在对象的<code>对象头（Object Header）</code>之中。</li>
</ol>
</blockquote>
<p>从<code>虚拟机的视角</code>来看，一个新的对象已经产生了。但是从<code>Java程序的视角</code>看来，对象创建才<u>刚刚开始</u>:</p>
<blockquote>
<p><strong>构造函数</strong>，即<code>Class文件</code>中的<code>&lt;init&gt;()</code>方法还没有执行，<u>所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好</u>。</p>
</blockquote>
<h4 id="2-2-对象的内存布局"><a href="#2-2-对象的内存布局" class="headerlink" title="2.2 对象的内存布局"></a>2.2 对象的内存布局</h4><p>在<code>HotSpot虚拟机</code>里，对象在堆内存中的存储布局可以划分为三个部分：<code>对象头（Header）</code>、<code>实例数据（Instance Data）</code>和<code>对齐填充（Padding）</code>。</p>
<h5 id="2-2-1-对象头"><a href="#2-2-1-对象头" class="headerlink" title="2.2.1 对象头"></a>2.2.1 对象头</h5><p>对象头部分包括两类信息：</p>
<ol>
<li>第一类是用于存储<strong>对象自身的<code>运行时数据</code></strong>，如<u>哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</u>等。官方称它为<code>“Mark Word”</code>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/markWord.PNG" alt="HotSpot虚拟机对象头`Mark Word`"></p>
<blockquote>
<p><code>Mark Word</code>被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p>
</blockquote>
<ol>
<li>另外一部分是<strong><code>类型指针</code></strong>，即<u>对象指向它的类型元数据的指针</u>，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</li>
</ol>
<blockquote>
<p>此外，如果对象是一个<code>Java数组</code>，那在对象头中还必须有一块用于<u>记录数组长度</u>的数据。</p>
</blockquote>
<h5 id="2-2-2-实例数据"><a href="#2-2-2-实例数据" class="headerlink" title="2.2.2 实例数据"></a>2.2.2 实例数据</h5><p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面<u>所定义的各种类型的字段内容</u>。</p>
<blockquote>
<p>存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</p>
<ul>
<li>HotSpot虚拟机默认的分配顺序为<code>longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs）</code>，相同宽度的字段总是被分配到一起存放</li>
<li>在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前</li>
</ul>
</blockquote>
<h5 id="2-2-3-对齐填充"><a href="#2-2-3-对齐填充" class="headerlink" title="2.2.3 对齐填充"></a>2.2.3 对齐填充</h5><p>对齐填充<em>不是必然存在</em>的，它仅仅起着<code>占位符</code>的作用。主要由于HotSpot虚拟机的自动内存管理系统要求<u>对象起始地址必须是8字节的整数倍</u>。</p>
<h4 id="2-3-对象的访问定位"><a href="#2-3-对象的访问定位" class="headerlink" title="2.3 对象的访问定位"></a>2.3 对象的访问定位</h4><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。主流的访问方式主要有<code>使用句柄</code>和<code>直接指针</code>两种：</p>
<ol>
<li><code>使用句柄</code>。Java堆中将可能会划分出一块内存来作为<code>句柄池</code>，<code>reference</code>中存储的就是对象的<code>句柄地址</code>，而句柄中包含了<u>对象实例数据与类型数据</u>各自具体的<strong>地址信息</strong>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/handleAccess.PNG" alt="通过句柄访问对象"></p>
<blockquote>
<p>最大好处就是reference中存储的是稳定句柄地址，在对象被移动时<strong>只会改变句柄中的实例数据指针</strong>，而 <code>reference</code>本身不需要被修改。可以理解为只需要移动对象实例数据。</p>
</blockquote>
<ol>
<li><code>直接指针</code>。Java堆中对象的内存布局需要考虑<u>如何放置访问类型数据的相关信息</u>，<code>reference</code>中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/pointerAccess.PNG" alt="通过直接指针访问对象"></p>
<blockquote>
<p>最大的好处就是速度更快，它节省了一次指针定位的时间开销。</p>
</blockquote>
<h3 id="3-OutOfMemoryError异常处理"><a href="#3-OutOfMemoryError异常处理" class="headerlink" title="3. OutOfMemoryError异常处理"></a>3. <code>OutOfMemoryError</code>异常处理</h3><h4 id="3-1-Java堆溢出"><a href="#3-1-Java堆溢出" class="headerlink" title="3.1 Java堆溢出"></a>3.1 Java堆溢出</h4><p>为了捕捉堆溢出，书中实现了如下异常测试程序：</p>
<blockquote>
<p>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证<strong><code>GC Roots</code>到对象之间有可达路径</strong>来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>堆的<code>最小值-Xms</code>参数与<code>最大值-Xmx</code>参数设置为一样即可避免堆自动扩展</li>
<li>参数<code>-XX：+HeapDumpOnOutOf-MemoryError</code>可以让虚拟机在出现内存溢出异常的时候<strong>Dump出当前的内存堆转储快照</strong>以便进行事后分析</li>
</ul>
</blockquote>
<p>运行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/heapOOM.PNG" alt="HeapOOM测试结果"></p>
<p>要解决这个内存区域的异常，常规的处理方法是首先通过内存映像分析工具对Dump出来的堆转储快照进行分析。</p>
<blockquote>
<p>这里使用的是<code>IDEA</code>的插件<code>jprofiler</code>，安装方法参考文章：<a href="https://blog.csdn.net/wytocsdn/article/details/79258247" target="_blank" rel="noopener">Intellij IDEA集成JProfiler性能分析神器</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/heapOOMJprofiler.PNG" alt="HeapOOM Jprofiler结果"></p>
<p>第一步首先应确认内存中<code>导致OOM的对象是</code>否是必要的，也就是要先分清楚到底是出现了<code>内存泄漏（Memory Leak）</code>还是<code>内存溢出（Memory Overflow）</code>。</p>
<ul>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到<code>GC Roots</code>的<code>引用链</code></li>
<li>如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数设置，与机器的内存对比，看看是否还有向上调整的空间。</li>
</ul>
<h4 id="3-2-虚拟机栈和本地方法栈溢出"><a href="#3-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="3.2 虚拟机栈和本地方法栈溢出"></a>3.2 虚拟机栈和本地方法栈溢出</h4><p>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，<code>-Xoss参数</code>（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，<strong>栈容量只能由-<code>Xss参数</code>来设定</strong>。</p>
<p>先将实验范围限制在单线程中操作，尝试下面行为是否能让HotSpot虚拟机产生<code>OutOfMemoryError</code>异常：</p>
<ol>
<li>使用<code>-Xss参数</code>减少栈内存容量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xss128k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaVMStackSOF.PNG" alt="JavaVMStackSOF结果"></p>
<blockquote>
<p>栈容量最小值主要取决于操作系统内存分页大小</p>
</blockquote>
<ol>
<li>定义大量的本地变量，增大此方法帧中本地变量表的长度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> unused1, unused2, unused3, unused4, unused5,</span><br><span class="line">                unused6, unused7, unused8, unused9, unused10,</span><br><span class="line">                unused11, unused12, unused13, unused14, unused15,</span><br><span class="line">                unused16, unused17, unused18, unused19, unused20,</span><br><span class="line">                unused21, unused22, unused23, unused24, unused25,</span><br><span class="line">                unused26, unused27, unused28, unused29, unused30,</span><br><span class="line">                unused31, unused32, unused33, unused34, unused35,</span><br><span class="line">                unused36, unused37, unused38, unused39, unused40,</span><br><span class="line">                unused41, unused42, unused43, unused44, unused45,</span><br><span class="line">                unused46, unused47, unused48, unused49, unused50,</span><br><span class="line">                unused51, unused52, unused53, unused54, unused55,</span><br><span class="line">                unused56, unused57, unused58, unused59, unused60,</span><br><span class="line">                unused61, unused62, unused63, unused64, unused65,</span><br><span class="line">                unused66, unused67, unused68, unused69, unused70,</span><br><span class="line">                unused71, unused72, unused73, unused74, unused75,</span><br><span class="line">                unused76, unused77, unused78, unused79, unused80,</span><br><span class="line">                unused81, unused82, unused83, unused84, unused85,</span><br><span class="line">                unused86, unused87, unused88, unused89, unused90,</span><br><span class="line">                unused91, unused92, unused93, unused94, unused95,</span><br><span class="line">                unused96, unused97, unused98, unused99, unused100;</span><br><span class="line">        stackLength ++;</span><br><span class="line">        test();</span><br><span class="line">        unused1 = unused2 = unused3 = unused4 = unused5 =</span><br><span class="line">        unused6 = unused7 = unused8 = unused9 = unused10 =</span><br><span class="line">        unused11 = unused12 = unused13 = unused14 = unused15 =</span><br><span class="line">        unused16 = unused17 = unused18 = unused19 = unused20 =</span><br><span class="line">        unused21 = unused22 = unused23 = unused24 = unused25 =</span><br><span class="line">        unused26 = unused27 = unused28 = unused29 = unused30 =</span><br><span class="line">        unused31 = unused32 = unused33 = unused34 = unused35 =</span><br><span class="line">        unused36 = unused37 = unused38 = unused39 = unused40 =</span><br><span class="line">        unused41 = unused42 = unused43 = unused44 = unused45 =</span><br><span class="line">        unused46 = unused47 = unused48 = unused49 = unused50 =</span><br><span class="line">        unused51 = unused52 = unused53 = unused54 = unused55 =</span><br><span class="line">        unused56 = unused57 = unused58 = unused59 = unused60 =</span><br><span class="line">        unused61 = unused62 = unused63 = unused64 = unused65 =</span><br><span class="line">        unused66 = unused67 = unused68 = unused69 = unused70 =</span><br><span class="line">        unused71 = unused72 = unused73 = unused74 = unused75 =</span><br><span class="line">        unused76 = unused77 = unused78 = unused79 = unused80 =</span><br><span class="line">        unused81 = unused82 = unused83 = unused84 = unused85 =</span><br><span class="line">        unused86 = unused87 = unused88 = unused89 = unused90 =</span><br><span class="line">        unused91 = unused92 = unused93 = unused94 = unused95 =</span><br><span class="line">        unused96 = unused97 = unused98 = unused99 = unused100 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaVMStackSOF.PNG" alt="JavaVMStackSOF2结果"></p>
<blockquote>
<p>出现<code>StackOverflowError</code>异常时，会有明确错误堆栈可供分析，相对而言比较容易定位到问题所在。</p>
</blockquote>
<h4 id="3-3-方法区和运行时常量池溢出"><a href="#3-3-方法区和运行时常量池溢出" class="headerlink" title="3.3 方法区和运行时常量池溢出"></a>3.3 方法区和运行时常量池溢出</h4><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p><code>String::intern()</code>是一个本地方法，它的作用是：</p>
<ul>
<li>如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；</li>
<li>否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</li>
</ul>
<p>对于<code>JDK 6</code>来运行如下代码，会出现运行时常量池的内存溢出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-XX:PermSize=6M -XX:MaxPermSize=6M</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Set保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在short范围内足以让6MB的PermSize产生OOM了</span></span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里没有安装<code>JDK 6</code>就没测试了，按书中所述，会出现如下异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">	at java.lang.String.intern(Native Method)</span><br><span class="line">	at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java: <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p><code>“PermGen space”</code>说明运行时常量池的确是属于方法区的一部分。使用<code>JDK 7</code>或更高版本的<code>JDK</code>并不会得到相同的结果，因为自<code>JDK 7</code>起，原本<u>存放在永久代的字符串常量池被移至Java堆之中</u>，所以在<code>JDK 7</code>及以上版 本，限制方法区的容量对该测试用例来说是毫无意义的。</p>
<h5 id="字符串常量池的实现方式的影响"><a href="#字符串常量池的实现方式的影响" class="headerlink" title="字符串常量池的实现方式的影响"></a>字符串常量池的实现方式的影响</h5><p>对于字符串常量池的实现引出了对<code>String.intern()</code>这个方法的影响，见如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1);</span><br><span class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>在<code>JDK 6</code>中运行，会得到<strong>两个<code>false</code></strong>。在<code>JDK 6</code>中，<code>intern()</code>方法会<strong>把首次遇到的字符串实例复制到永久代的字符串常量池中存储</strong>，返回的也是<u>永久代里面这个字符串实例</u>的引用，而由<code>StringBuilder</code>创建的字符串对象实例<strong>在Java堆</strong>上，所以必然不可能是同一个引用，结果将返回false。</p>
</li>
<li><p>在<code>JDK 7</code>中运行，会得到一个<code>true</code>和一个<code>false</code>。<code>JDK 7</code>的<code>intern()</code>方法<strong>不需要再拷贝字符串的实例到永久代</strong>，<u>字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可</u>，因此intern()返回的引用和由<code>StringBuilder</code>创建的那个字符串实例就是同一个。</p>
<ul>
<li>对<code>str2</code>比较返回<code>false</code>，这是因为<code>“java”</code>这个字符串在执行<code>StringBuilder.toString()</code>之前就已经出现过了，字符串常量池中已经有它的引用。<code>“java”</code>在加载<code>sun.misc.Version</code>这个类的时候进入常量池</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>方法区的主要职责是用于存放类型的相关信息，如<u>类名、访问修饰符、常量池、字段描述、方法描述</u>等。对于这部分区域的测试，基本的思路是<strong>运行时产生大量的类去填满方法区，直到溢出为止</strong>。作者借助了<code>CGLib</code>直接操作字节码运行时生成了大量的动态类。</p>
<blockquote>
<p>类似这样的代码确实可能会<strong>出现在实际应用</strong>中：当前的很多主流框架，如<code>Spring</code>、<code>Hibernate</code>对类进行增强时，都会使用到<code>CGLib</code>这类字节码技术。</p>
</blockquote>
<p>一个类如果要被垃圾收集器回收，要达成的条件是<strong>比较苛刻</strong>的。在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。</p>
<p><code>JDK 8</code>以后，<code>元空间</code>作为<code>永久代</code>替代者登场。<code>HotSpot</code>还是提供了一 些参数作为元空间的防御措施：</p>
<blockquote>
<ul>
<li><code>-XX：MaxMetaspaceSize</code>：设置元空间最大值；</li>
<li><code>-XX：MetaspaceSize</code>：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整</li>
<li><code>-XX：MinMetaspaceFreeRatio</code>：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。</li>
</ul>
</blockquote>
<h4 id="3-4-本机直接内存溢出"><a href="#3-4-本机直接内存溢出" class="headerlink" title="3.4 本机直接内存溢出"></a>3.4 本机直接内存溢出</h4><p><code>直接内存（Direct Memory）</code>的容量大小可通过<code>-XX：MaxDirectMemorySize</code>参数来指定，如果不去指定，则默认与<code>Java堆最大值</code>（由<code>-Xmx</code>指定）一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通 过反射获取<code>Unsafe</code>实例进行内存分配，虽然使用<code>DirectByteBuffer</code>分配内存也会抛出<code>内存溢出异常</code>，但它抛出异常时并没有真正向操作系统申请分配内存，而是<u>通过计算得知内存无法分配就会在代码里手动抛出溢出异常</u>，真正申请分配内存的方法是<code>Unsafe::allocateMemory()</code>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/DirectMemoryOOM.PNG" alt="DirectMemoryOOM结果"></p>
<p>如果发现内存溢出之后产生的<code>Dump文件</code>很小，而程序中又直接或间接使用了<code>DirectMemory</code>（<strong>典型的间接使用就是<code>NIO</code></strong>），可以考虑重点检查一下直接内存方面的原因。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--3 垃圾收集器与内存分配策略</title>
    <url>/2021/05/17/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_3_Garbage_collector_and_memory_allocation_strategy.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code><br><a id="more"></a></p>
</blockquote>
<h3 id="1-对象”已死”？"><a href="#1-对象”已死”？" class="headerlink" title="1. 对象”已死”？"></a>1. 对象”已死”？</h3><p>垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（<code>“死去”即不可能再被任何途径使用的对象</code>）。</p>
<h4 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1 引用计数算法"></a>1.1 引用计数算法</h4><p>在对象中添加一个<code>引用计数器（Reference Counting）</code>，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；<strong>任何时刻计数器为零的对象就是不可能再被使用的</strong>。</p>
<blockquote>
<ul>
<li>占用了一些额外的内存空间来进行计数</li>
<li>原理简单，判定效率也很高</li>
</ul>
</blockquote>
<p>主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作。</p>
<blockquote>
<p>譬如单纯的引用计数就很难解决对象之间<code>相互循环引用</code>的问题。</p>
<ul>
<li>对象<code>objA</code>和<code>objB</code>都有字段<code>instance</code>；</li>
<li>赋值令 <code>objA.instance=objB</code>及<code>objB.instance=objA</code>，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问；</li>
<li>但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。</li>
</ul>
</blockquote>
<p>打印内存回收日志的参数设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails      //打印GC详细信息</span><br><span class="line">-Xms100M    //堆大小100M</span><br><span class="line">-Xmx200M   //堆最大占用内存</span><br><span class="line">-Xmn10M     //新生代 大小 </span><br><span class="line">-XX:SurvivorRatio=8   //Eden:Survivor1:Survivor2 = 8:1:1</span><br><span class="line">-XX:MaxPermSize30M   //永久代内存大小</span><br><span class="line">-XX:MetaspaceSize=30M  //元空间 初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</span><br><span class="line">-XX:MaxMetaspaceSize=300M //最大空间，默认是没有限制的。</span><br></pre></td></tr></table></figure>
<h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h4><p><code>可达性分析（Reachability Analysis）算法</code>的基本思路是：</p>
<blockquote>
<ul>
<li>通过 一系列称为<code>“GC Roots”</code>的根对象作为<strong>起始节点集</strong>，从这些节点开始，根据引用关系向下搜索；</li>
<li>搜索过程所走过的路径称为<code>“引用链”（Reference Chain）</code>，如果某个对象到<code>GC Roots</code>间没有任何引用链相连， 或者用图论的话来说就是从<code>GC Roots</code>到这个对象不可达时，则证明此对象是不可能再被使用的。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Reachability_Analysis.PNG" alt="可达性分析算法"></p>
<p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是使用了可达性分析算法。固定可作为<code>GC Roots</code>的对象包括以下几种：</p>
<ul>
<li>在<code>虚拟机栈（栈帧中的本地变量表）中引用的对象</code>，譬如各个线程被调用的方法堆栈中使用到的<u>参数、局部变量、临时变量</u>等。</li>
<li>在<strong>方法区</strong>中<code>类静态属性引用的对象</code>，譬如Java类的引用类型静态变量。</li>
<li>在<strong>方法区</strong>中<code>常量引用的对象</code>，譬如字符串常量池（String Table）里的引用。</li>
<li>在<code>本地方法栈中JNI</code>（即通常所说的Native方法）引用的对象。</li>
<li><code>Java虚拟机内部的引用</code>，如基本数据类型对应的Class对象，一些常驻的<strong>异常对象</strong>（比如<code>NullPointExcepiton</code>、<code>OutOfMemoryError</code>）等，还有系统类加载器。</li>
<li>所有被<code>同步锁（synchronized关键字）持有的对象</code>。</li>
<li>反映Java虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI中注册的回调</code>、<code>本地代码缓存</code>等。</li>
</ul>
<p>除了这些<strong>固定</strong>的<code>GC Roots</code>集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象<strong>“临时性”</strong>地加入，共同构成完整<code>GC Roots</code>集合。</p>
<h4 id="1-3-引用的分类"><a href="#1-3-引用的分类" class="headerlink" title="1.3 引用的分类"></a>1.3 引用的分类</h4><p>在<code>JDK 1.2</code>版之后，Java对引用的概念进行了扩充，将引用分为<code>强引用（Strongly Re-ference）</code>、<code>软引用（Soft Reference）</code>、<code>弱引用（Weak Reference）</code>和<code>虚引用（Phantom Reference）</code>4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li><p>强引用是指在程序代码之中普遍存在的引用赋值，即类似<code>“Object obj=new Object()”</code>这种引用关系。</p>
<blockquote>
<p>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。`</p>
</blockquote>
</li>
<li><p>软引用是用来描述一些<strong>还有用，但非必须的对象</strong>。</p>
<blockquote>
<ul>
<li>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</li>
<li>在<code>JDK 1.2</code>版之后提供了<code>SoftReference</code>类来实现软引用。</li>
</ul>
</blockquote>
</li>
<li><p>弱引用也是用来描述那些<strong>非必须对象</strong>，但是它的强度比软引用更弱一些。</p>
<blockquote>
<p>被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
<p>在<code>JDK 1.2</code>版之后提供了<code>WeakReference</code>类来实现弱引用。</p>
</blockquote>
</li>
<li><p>虚引用也称为<code>“幽灵引用”</code>或者<code>“幻影引用”</code>，它是最弱的一种引用关系。</p>
<blockquote>
<p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的<u>只是为了能在这个对象被收集器回收时收到一个系统通知</u>。</p>
<p>在<code>JDK 1.2</code>版之后提供 了<code>PhantomReference</code>类来实现虚引用。</p>
</blockquote>
</li>
</ul>
<h4 id="1-4-对象的死亡宣告"><a href="#1-4-对象的死亡宣告" class="headerlink" title="1.4 对象的死亡宣告"></a>1.4 对象的死亡宣告</h4><p>在可达性分析算法中判定为不可达的对象，至少要经历两次标记过程：</p>
<ol>
<li><p>如果对象在进行可达性分析后发现没有与<code>GC Roots</code>相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是<u>此对象是否有必要执行<code>finalize()</code>方法</u>。</p>
<ul>
<li><p>假如对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为<strong>“没有必要执行”</strong>。</p>
</li>
<li><p>如果这个对象被判定为确<strong>有必要执行<code>finalize()</code>方法</strong>，那么该对象将会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条由虚拟机<strong>自动建立的、低调度优先级</strong>的<code>Finalizer</code>线程去执行它们的<code>finalize()</code> 方法。</p>
<ul>
<li><code>“执行”</code>是<u>指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束</u>。</li>
</ul>
</li>
</ul>
</li>
<li><p>稍后收集器将对<code>F-Queue</code>中的对象进行<u>第二次小规模的标记</u>，如果对象要在<code>finalize()</code>中重新与引用链上的任何一个对象建立关联，那在第二次标记时它将被移出“即将回收”的集合。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此代码演示了两点：</span></span><br><span class="line"><span class="comment">* 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment">* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes, i am still alive :)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/FinalizeEscapeGC.PNG" alt="FinalizeEscapeGC运行结果"></p>
<p>代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败了。这是因为<strong>任何一个对象的finalize()方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p>
<blockquote>
<p><code>finalize()</code>是不推荐使用的语法</p>
</blockquote>
<h4 id="1-5-回收方法区"><a href="#1-5-回收方法区" class="headerlink" title="1.5 回收方法区"></a>1.5 回收方法区</h4><p>方法区的垃圾收集主要回收两部分内容：<code>废弃的常量</code>和<code>不再使用的类型</code>。</p>
<ul>
<li>回收废弃常量与回收 Java堆中的对象非常类似。</li>
<li>判定一个类型是否属于<code>“不再被使用的类”</code>需要同时满足下面三个条件：<ul>
<li><strong>该类所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li><strong>加载该类的类加载器已经被回收</strong>，这个条件则通常是很难达成。</li>
<li><strong>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ul>
<h3 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h3><p>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为<code>“引用计数式垃圾收集”（Reference Counting GC）</code>和<code>“追踪式垃圾收集”（Tracing GC）</code>两大类，这两类也常被称作<code>“直接垃圾收集”</code>和<code>“间接垃圾收集”</code>。</p>
<h4 id="2-1-分代收集理论"><a href="#2-1-分代收集理论" class="headerlink" title="2.1 分代收集理论"></a>2.1 分代收集理论</h4><p><code>“分代收集”（Generational Collection）</code>建立在两个分代假说之上：</p>
<ol>
<li><code>弱分代假说（Weak Generational Hypothesis）</code>：绝大多数对象都是朝生夕灭的。</li>
<li><code>强分代假说（Strong Generational Hypothesis）</code>：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
<p>设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（<strong>年龄即对象熬过垃圾收集过程的次数</strong>）分配到不同的区域之中存储。</p>
<blockquote>
<ul>
<li>如果一个区域中大多数对象都是朝生夕灭，那么把它们集中放在一起，每次回收时只关注如何保留少量存活，就能以较低代价回收到大量的空间；</li>
<li>如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域；</li>
<li>同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</li>
</ul>
</blockquote>
<p>设计者一般至少会把Java堆划分为<code>新生代（Young Generation）</code>和<code>老年代（Old Generation）</code>两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p>
<p>假如要现在进行一次只局限于新生代区域内的收集<code>（Minor GC）</code>，但新生代中的对象是完全有可能被老年代所引用的。需要对分代收集理论添加第三条经验法则：</p>
<ol>
<li><code>跨代引用假说（Intergenerational Reference Hypothesis）</code>：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
<p>依据这条假说，只需在新生代上建立一个全局的数据结构（该结构被称为<code>“记忆集”</code>，<code>Remembered Set</code>），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生<code>Minor GC</code>时，只有包含了跨代引用的小块内存里的对象才会被加入到<code>GC Roots</code>进行扫描。</p>
<blockquote>
<ul>
<li><code>部分收集（Partial GC）</code>：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul>
<li><code>新生代收集（Minor GC/Young GC）</code>：指目标只是新生代的垃圾收集。</li>
<li><code>老年代收集（Major GC/Old GC）</code>：指目标只是老年代的垃圾收集。</li>
<li><code>混合收集（Mixed GC）</code>：指目标是收集整个新生代以及部分老年代的垃圾收集。</li>
</ul>
</li>
<li><code>整堆收集（Full GC）</code>：收集整个Java堆和方法区的垃圾收集。</li>
</ul>
</blockquote>
<h4 id="2-2-标记-清除-Mark-Sweep-算法"><a href="#2-2-标记-清除-Mark-Sweep-算法" class="headerlink" title="2.2 标记-清除(Mark-Sweep)算法"></a>2.2 标记-清除(Mark-Sweep)算法</h4><p>算法分为<code>“标记”</code>和<code>“清除”</code>两个阶段：</p>
<ul>
<li>首先标记出所有需要回收的对象；</li>
<li>在标记完成后，统一回收掉所有被标记的对象；</li>
</ul>
<p>也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p>
<blockquote>
<p>主要缺点:</p>
<ol>
<li><strong>执行效率不稳定</strong>，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li>
<li><strong>内存空间的碎片化问题</strong>，标记、清除之后会产生大量不连续的内存碎片。</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Sweep.PNG" alt="“标记-清除”算法"></p>
<h4 id="2-3-标记-复制-Mark-Copying-算法"><a href="#2-3-标记-复制-Mark-Copying-算法" class="headerlink" title="2.3 标记-复制(Mark-Copying)算法"></a>2.3 标记-复制(Mark-Copying)算法</h4><p>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，标记-复制(Mark-Copying)算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。<u>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</u>。</p>
<blockquote>
<p>缺点：</p>
<ul>
<li>如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销；</li>
<li>这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一 点。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Copying.PNG" alt="“标记-复制”算法"></p>
<p><code>Appel式回收</code>(<code>Andrew Appel</code>提出的一种更优化的<code>半区复制分代策略</code>)的具体做法是：</p>
<ul>
<li>把新生代分为一块较大的<code>Eden空间</code>和两块较小的<code>Survivor空间</code>，每次分配内存只使用<code>Eden</code>和其中一块<code>Survivor</code>。</li>
<li>发生垃圾搜集时，将<code>Eden</code>和<code>Survivor</code>中仍然存活的对象一次性复制到另外一块<code>Survivor</code>空间上，然后直接清理掉<code>Eden</code>和已用过的那块<code>Survivor</code>空间。</li>
</ul>
<p><code>HotSpot虚拟机</code>默认<code>Eden</code>和<code>Survivor</code>的大小比例是<code>8∶1</code>，也即每次新生代中可用内存空间为整个新生代容量的<strong>90%</strong>（<code>Eden</code>的<strong>80%</strong>加上一个<code>Survivor</code>的<strong>10%</strong>）。</p>
<blockquote>
<p><code>Appel式回收</code>还有一个充当罕见情况的<code>“逃生门”</code>的安全设计，当<code>Survivor</code>空间不足以容纳一次<code>Minor GC</code>之后存活的对象时，就需要依赖<strong>其他内存区域（实际上大多就是老年代）</strong>进行<code>分配担保（Handle Promotion）</code>。</p>
</blockquote>
<h4 id="2-4-标记-整理-Mark-Compact-算法"><a href="#2-4-标记-整理-Mark-Compact-算法" class="headerlink" title="2.4 标记-整理(Mark-Compact)算法"></a>2.4 标记-整理(Mark-Compact)算法</h4><p><code>“标记-整理”（Mark-Compact）算法</code>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Compact.PNG" alt="“标记-整理”算法"></p>
<p>是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。</p>
<h3 id="3-HotSpot的算法细节实现"><a href="#3-HotSpot的算法细节实现" class="headerlink" title="3. HotSpot的算法细节实现"></a>3. HotSpot的算法细节实现</h3><h4 id="3-1-根节点枚举"><a href="#3-1-根节点枚举" class="headerlink" title="3.1 根节点枚举"></a>3.1 根节点枚举</h4><p>所有收集器在根节点枚举这一步骤时都是<strong>必须暂停用户线程</strong>的，因此毫无疑问根节点枚举与整理内存碎片一样会面临相似的<code>“Stop The World”</code>的困扰。</p>
<p><code>HotSpot</code>使用一组称为<code>OopMap</code>的数据结构直接得到哪些地方存放着对象引用。（<code>普通对象指针（Ordinary Object Pointer，OOP）</code>）</p>
<blockquote>
<ul>
<li>一旦类加载动作完成的时候，就会把对象内什么偏移量上是什么类型的数据计算出来；</li>
<li>在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。</li>
</ul>
</blockquote>
<p>这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等<code>GC Roots</code>开始查找。</p>
<h4 id="3-2-安全点"><a href="#3-2-安全点" class="headerlink" title="3.2 安全点"></a>3.2 安全点</h4><p><code>HotSpot</code>没有为每条指令都生成<code>OopMap</code>，只是在<strong>“特定的位置”</strong>记录了这些信息，这些位置被称为<code>安全点（Safepoint）</code>。有了安全点的设定，强制要求必须执行到达安全点后才能够暂停下来开始垃圾收集。</p>
<blockquote>
<p>安全点位置的选取基本上是以“<code>是否具有让程序长时间执行的特征</code>”，<code>“长时间执行”</code>的最明显特征就是<strong>指令序列的复用</strong>，例如<u>方法调用、循环跳转、异常跳转</u>等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p>
</blockquote>
<p>如何在垃圾收集发生时让所有线程（这里其实<code>不包括执行JNI调用的线程</code>）都跑到最近的安全点，然后停顿下来。</p>
<blockquote>
<p><code>抢先式中断（Preemptive Suspension）</code>在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。</p>
<p><code>主动式中断（Voluntary Suspension）</code>当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一 个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。</p>
</blockquote>
<p><code>HotSpot</code>使用<code>内存保护陷阱</code>的方式，把轮询操作精简至只有一条汇编指令的程度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x01b6d62d: test %eax,0x160100</span><br></pre></td></tr></table></figure>
<p>当需要暂停用户线程时，虚拟机把<code>0x160100</code>的内存页设置为不可读，那线程执行到<code>test</code>指令时就会产生一个<code>自陷异常信号</code>，然后在预先注册的异常处理器中挂起线程实现等待。</p>
<h4 id="3-3-安全区域"><a href="#3-3-安全区域" class="headerlink" title="3.3 安全区域"></a>3.3 安全区域</h4><p><code>安全区域</code>是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。</p>
<blockquote>
<ul>
<li>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。</li>
<li>当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段）:<ul>
<li>如果完成了，那线程就当作没事发生过，继续执行；</li>
<li>否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="3-4-记忆集与卡表"><a href="#3-4-记忆集与卡表" class="headerlink" title="3.4 记忆集与卡表"></a>3.4 记忆集与卡表</h4><p><code>记忆集（Remembered Set）</code>是一种用于记录<u>从非收集区域指向收集区域的指针集合</u>的抽象数据结构。实现记忆集的一些可供选择（当然也可以选择这个范围以外的）的记录精度：</p>
<ul>
<li><strong>字长精度</strong>：每个记录精确到一个机器字长，该字包含跨代指针。</li>
<li><strong>对象精度</strong>：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li><strong>卡精度</strong>：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>“卡精度”所指的是用一种称为<code>“卡表”（Card Table）</code>的方式去实现记忆集，字节数组<code>CARD_TABLE</code>的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作<code>“卡页”（Card Page）</code>。</p>
<blockquote>
<p>只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为<code>1</code>，称为这个元素变脏（Dirty），没有则标识为<code>0</code>。</p>
</blockquote>
<h4 id="3-5-写屏障"><a href="#3-5-写屏障" class="headerlink" title="3.5  写屏障"></a>3.5  写屏障</h4><p>卡表元素何时变脏?</p>
<blockquote>
<p>有其他分代区域中对象引用了本区域对象时</p>
</blockquote>
<p>如何变脏?</p>
<blockquote>
<p>在<code>HotSpot</code>虚拟机里是通过<code>写屏障（Write Barrier）</code>技术维护卡表状态的。写屏障可以看作在虚拟机层面对<code>“引用类型字段赋值”</code>这个动作的<code>AOP切面</code></p>
<ul>
<li>在引用对象赋值时会产生一个<code>环形（Around）</code>通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。<ul>
<li>在赋值前的部分的写屏障叫作<code>写前屏障（Pre-Write Barrier）</code>；</li>
<li>在赋值后的则叫作<code>写后屏障（Post-Write Barrier）</code>。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>“伪共享”（False Sharing）问题</strong></p>
<blockquote>
<p>现代中央处理器的缓存系统中是以<code>缓存行（Cache Line）</code>为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低。</p>
<p>为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏</p>
</blockquote>
<h4 id="3-6-并发的可达性分析"><a href="#3-6-并发的可达性分析" class="headerlink" title="3.6 并发的可达性分析"></a>3.6 并发的可达性分析</h4><p>可达性分析的停顿时间与Java堆容量直接成正比例关系，把遍历对象图过程中遇到的对象，按照<strong>“是否访问过”</strong>这个条件标记成以下三种颜色，演示并发出现<strong>“对象消失”</strong>问题：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Object_disappeared.PNG" alt="并发出现“对象消失”问题"></p>
<ul>
<li><strong>白色</strong>：表示对象尚未被垃圾收集器访问过。</li>
<li><strong>黑色</strong>：表示对象已经被垃圾收集器访问过，且这个对象的<u>所有引用都已经扫描过</u>。</li>
<li><strong>灰色</strong>：表示对象已经被垃圾收集器访问过，但这个对象上<u>至少存在一个引用还没有被扫描过</u>。</li>
</ul>
<p>当且仅当以下两个条件同时满足时，会产生“对象消失”的问题：</p>
<blockquote>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
</blockquote>
<p>产生了两种解决方案：</p>
<blockquote>
<ul>
<li><p><code>增量更新（Incremental Update）</code>破坏的是第一个条件。当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</p>
</li>
<li><p><code>原始快照（Snapshot At The Beginning，SATB）</code>破坏的是第二个条件。当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p>
</li>
</ul>
</blockquote>
<h3 id="4-经典垃圾收集器"><a href="#4-经典垃圾收集器" class="headerlink" title="4. 经典垃圾收集器"></a>4. 经典垃圾收集器</h3><p>七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Garbage_collector.PNG" alt="HotSpot虚拟机的垃圾收集器"></p>
<h4 id="4-1-新生代收集器"><a href="#4-1-新生代收集器" class="headerlink" title="4.1 新生代收集器"></a>4.1 新生代收集器</h4><h5 id="4-1-1-Serial收集器"><a href="#4-1-1-Serial收集器" class="headerlink" title="4.1.1 Serial收集器"></a>4.1.1 Serial收集器</h5><p><code>Serial收集器</code>是一个单线程工作的收集器，但它的“单线程”的意义是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/serial_collector.PNG" alt="Serial/Serial Old收集器运行示意图"></p>
<blockquote>
<p>它是所有收集器里<code>额外内存消耗（Memory Footprint）</code>最小的，简单而高效</p>
</blockquote>
<h5 id="4-1-2-ParNew收集器"><a href="#4-1-2-ParNew收集器" class="headerlink" title="4.1.2 ParNew收集器"></a>4.1.2 ParNew收集器</h5><p><code>ParNew收集器</code>实质上是<code>Serial收集器</code>的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为都与Serial收集器完全一致。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ParNew_collector.PNG" alt="ParNew/Serial Old收集器运行示意图l Old收集器运行示意图"></p>
<p>在谈论垃圾收集器的上下文语境中，<code>并行和并发</code>可以理解为：</p>
<ul>
<li><code>并行（Parallel）</code>：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态</li>
<li><code>并发（Concurrent）</code>：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。</li>
</ul>
<h5 id="4-1-3-Parallel-Scavenge收集器"><a href="#4-1-3-Parallel-Scavenge收集器" class="headerlink" title="4.1.3 Parallel Scavenge收集器"></a>4.1.3 Parallel Scavenge收集器</h5><p><code>Parallel Scavenge收集器</code>也是一款<code>新生代收集器</code>，它同样是基于<u>标记-复制算法</u>实现的收集器，也是能够并行收集的多线程收集器。Parallel Scavenge收集器的目标则是达到一个可控制的<code>吞吐量（Throughput）</code>，吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值：</p>
<script type="math/tex; mode=display">
吞吐量 = \frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}</script><p>高吞吐量可以最高效率地利用处理器资源，尽快完成程序的运算任务，<em>主要适合在后台运算而不需要太多交互的分析任务</em>。</p>
<blockquote>
<p><code>自适应的调节策略（GC Ergonomics）</code>让虚拟机根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
</blockquote>
<h4 id="4-2-老年代收集器"><a href="#4-2-老年代收集器" class="headerlink" title="4.2 老年代收集器"></a>4.2 老年代收集器</h4><h5 id="4-2-1-Serial-Old收集器"><a href="#4-2-1-Serial-Old收集器" class="headerlink" title="4.2.1 Serial Old收集器"></a>4.2.1 Serial Old收集器</h5><p><code>Serial Old</code>是Serial收集器的老年代版本，它同样是一个单线程收集器，使用<u>标记-整理算法</u>。</p>
<h5 id="4-2-2-Parallel-Old收集器"><a href="#4-2-2-Parallel-Old收集器" class="headerlink" title="4.2.2 Parallel Old收集器"></a>4.2.2 Parallel Old收集器</h5><p><code>Parallel Old</code>是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于<u>标记-整理算法</u>实现。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Parallel_Old_collector.PNG" alt="ParNew/Serial Old收集器运行示意图"></p>
<blockquote>
<p>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p>
</blockquote>
<h5 id="4-2-3-CMS收集器"><a href="#4-2-3-CMS收集器" class="headerlink" title="4.2.3 CMS收集器"></a>4.2.3 CMS收集器</h5><p><code>CMS（Concurrent Mark Sweep）收集器</code>是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于<u>标记-清除算法</u>实现的，它的运作过程分为四个步骤：</p>
<ol>
<li><code>初始标记（CMS initial mark）</code>。只是标记一下<code>GC Roots</code>能<strong>直接</strong>关联到的对象，速度很快；</li>
<li><code>并发标记（CMS concurrent mark）</code>。从<code>GC Roots</code>的<u>直接关联对象</u>开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</li>
<li><code>重新标记（CMS remark）</code>。修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；</li>
<li><code>并发清除（CMS concurrent sweep）</code>。清理删除掉标记阶段判断的已经死亡的对象。</li>
</ol>
<p>初始标记、重新标记这两个步骤仍然需要<code>“Stop The World”</code>。在整个过程中<em>耗时最长</em>的<code>并发标记</code>和<code>并发清除</code>阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说<code>CMS收集器</code>的内存回收过程是与用户线程一起<strong>并发执行</strong>的。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Concurrent_Mark_Sweep.PNG" alt="Concurrent Mark Sweep收集器运行示意图"></p>
<blockquote>
<p>优点：并发收集、低停顿。也称之为<code>“并发低停顿收集器”（Concurrent Low Pause Collector）</code>。</p>
<p>缺点：</p>
<ul>
<li>CMS收集器对<code>处理器资源</code>非常敏感。</li>
<li>由于CMS收集器无法处理<code>“浮动垃圾”（Floating Garbage）</code>，有可能出现<code>“Con-current Mode Failure”</code>失败进而导致另一次完全<code>“Stop The World”</code>的<code>Full GC</code>的产生。<ul>
<li><code>“浮动垃圾”</code>：在CMS的<code>并发标记</code>和<code>并发清理</code>阶段，用户线程运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。</li>
<li><code>“并发失败”（Concurrent Mode Failure）</code>：CMS运行期间预留的内存无法满足程序分配新对象的需要。虚拟机将不得不启动<code>后备预案</code>：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集。</li>
</ul>
</li>
<li>CMS是一款基于“标记-清除”算法实现的收集器，收集结束时会有大量<code>空间碎片</code>产生。</li>
</ul>
</blockquote>
<h4 id="4-3-Garbage-First收集器"><a href="#4-3-Garbage-First收集器" class="headerlink" title="4.3 Garbage First收集器"></a>4.3 Garbage First收集器</h4><p><code>Garbage First（简称G1）收集器</code>开创了收集器<code>面向局部收集</code>的设计思路和<code>基于Region的内存布局</code>形式，也被Oracle官方称为<code>“全功能的垃圾收集器”（Fully-Featured Garbage Collector）</code>。</p>
<blockquote>
<p><code>“停顿时间模型”（Pause Prediction Model）</code>是能够支持指定在一个长度为<strong>M毫秒</strong>的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。</p>
</blockquote>
<p><code>G1</code>面向堆内存任何部分来组成<code>回收集（Collection Set，一般简称CSet）</code>进行回收，衡量标准是<u>哪块内存中存放的垃圾数量最多，回收收益最大</u>。这就是G1收集器的<code>Mixed GC模式</code>。</p>
<h5 id="4-3-1-基于Region的堆内存布局"><a href="#4-3-1-基于Region的堆内存布局" class="headerlink" title="4.3.1 基于Region的堆内存布局"></a>4.3.1 基于Region的堆内存布局</h5><p>G1不再坚持固定大小以及固定数量的分代区域划分，而是<u>把连续的Java堆划分为多个大小相等的<code>独立区域（Region）</code></u>，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理。</p>
<blockquote>
<p>Region中一类特殊的<code>Humongous区域</code>，专门用来存储大对象。只要大小超过了一个 Region容量一半的对象即可判定为大对象。</p>
</blockquote>
<h5 id="4-3-2-面向局部收集"><a href="#4-3-2-面向局部收集" class="headerlink" title="4.3.2 面向局部收集"></a>4.3.2 面向局部收集</h5><p>G1中新生代和老年代不再是固定的了，它们都是一系列区域（<strong>不需要连续</strong>）的<code>动态集合</code>。将Region作为单次回收的最小单元，可以有计划地避免<u>在整个Java堆中进行全区域的垃圾收集</u>。G1收集器跟踪各个Region里面的垃圾堆积的“价值”大小：</p>
<blockquote>
<p>价值即回收所获得的空间大小以及回收所需时间的经验值</p>
</blockquote>
<p>在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region。(“Garbage First”名字的由来)</p>
<h5 id="4-3-3-关键的细节问题"><a href="#4-3-3-关键的细节问题" class="headerlink" title="4.3.3 关键的细节问题"></a>4.3.3 关键的细节问题</h5><ul>
<li><u>将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？</u>使用记忆集避免全堆作为GC Roots扫描。G1的记忆集在存储结构的<u>本质上是一 种哈希表</u>，<code>Key</code>是别的Region的起始地址，<code>Value</code>是一个集合，里面存储的元素是卡表的索引号。</li>
<li><u>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</u>G1 收集器是通过<code>原始快照（SATB）算法</code>保证用户线程改变对象引用关系时，不能打破原本的对象图结构。此外，G1为每一个Region设计了两个名为<code>TAMS（Top at Mark Start）</code>的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li>
<li><u>怎样建立起可靠的停顿预测模型？</u>G1收集器的停顿预测模型是以<code>衰减均值（Decaying Average）</code>为理论基础来实现的。在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。衰减平均值更准确地代表“最近的”平均状态。</li>
</ul>
<h5 id="4-3-4-关键的细节问题"><a href="#4-3-4-关键的细节问题" class="headerlink" title="4.3.4 关键的细节问题"></a>4.3.4 关键的细节问题</h5><p>G1收集器的运作过程大致可划分为以下四个步骤：</p>
<ul>
<li><code>初始标记（Initial Marking）</code>。仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象，并且修改<code>TAMS</code>指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。</li>
<li><code>并发标记（Concurrent Marking）</code>。从<code>GC Root</code>开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。当对象图扫描完成以后，还要重新处理<code>原始快照SATB</code>记录下的在并发时有引用变动的对象。</li>
<li><code>最终标记（Final Marking）</code>。对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的<code>SATB记录</code>。</li>
<li><code>筛选回收（Live Data Counting and Evacuation）</code>。负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。<ul>
<li>这里的操作涉及存活对象的移动，是<strong>必须暂停用户线程</strong>，由多条收集器线程并行完成的。</li>
</ul>
</li>
</ul>
<p>G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/G1_collector.PNG" alt="G1收集器运行示意图"></p>
<blockquote>
<p>从G1开始，最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的<code>内存分配速率 （Allocation Rate）</code>，应用在分配，同时收集器在收集，只要收集的速度能跟得上对象分配的速度，那一切就能运作得很完美。</p>
</blockquote>
<p>优点：</p>
<ul>
<li>可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集</li>
<li>G1<strong>从整体来看是基于“标记-整理”算法</strong>实现的收集器，但<strong>从局部（两个Region之间）上看又是基于“标记-复制”</strong>算法实现，G1运作期间不会产生内存空间碎片。</li>
</ul>
<p>缺点：</p>
<ul>
<li>G1为了垃圾收集产生的内存占用（Footprint）比CMS要高。G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间；</li>
<li>G1程序运行时的额外执行负载（Overload）比CMS要高。G1除了使用写后屏障来进行卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。</li>
</ul>
<h3 id="5-低延迟垃圾收集器"><a href="#5-低延迟垃圾收集器" class="headerlink" title="5. 低延迟垃圾收集器"></a>5. 低延迟垃圾收集器</h3><p>衡量垃圾收集器的三项最重要的指标是：<code>内存占用（Footprint）</code>、<code>吞吐量（Throughput）</code>和<code>延迟 （Latency）</code>。两款目前仍处于实验状态的收集器<code>Shenandoah</code>和<code>ZGC</code>，被官方命名为<code>“低延迟垃圾收集器”（Low-Latency Garbage Collector或者Low-Pause-Time Garbage Collector）</code>。</p>
<h4 id="5-1-Shenandoah收集器"><a href="#5-1-Shenandoah收集器" class="headerlink" title="5.1 Shenandoah收集器"></a>5.1 Shenandoah收集器</h4><p><code>Shenandoah</code>是一款只有<code>OpenJDK</code>才会包含，而<code>OracleJDK</code>里反而不存在的收集器。Shenandoah反而更像是G1的下一代继承者，在管理堆内存方面，它与G1至少有三个明显的不同之处：</p>
<ul>
<li>支持并发的整理算法；</li>
<li>Shenandoah是默认不使用分代收集的；</li>
<li>Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为<code>“连接矩阵”（Connection Matrix）</code>的全局数据结构来记录<em>跨Region的引用关系</em>，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。</li>
</ul>
<p>Shenandoah收集器的工作过程大致可以划分为以下九个阶段：</p>
<ul>
<li><code>初始标记（Initial Marking）</code>。标记与<code>GC Roots</code>直接关联的对象，这个阶段仍是<code>“Stop The World”</code>的。</li>
<li><code>并发标记（Concurrent Marking）</code>。遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的。</li>
<li><code>最终标记（Final Marking）</code>。处理剩余的<code>SATB扫描</code>，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组<code>回收集（Collection Set）</code>。<em>会有一小段短暂的停顿</em>。</li>
<li><code>并发清理（Concurrent Cleanup）</code>。清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为<code>Immediate Garbage Region</code>）。</li>
<li><code>并发回收（Concurrent Evacuation）</code>。Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中，Shenandoah通过读屏障和被称为“<code>Brooks Pointers</code>”的转发指针来解决并发回收阶段遇到的困难。</li>
<li><code>初始引用更新（Initial Update Reference）</code>。把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务。<em>会产生一个非常短暂的停顿</em>。</li>
<li><code>并发引用更新（Concurrent Update Reference）</code>。按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值。<em>与用户线程一起并发的</em>。</li>
<li><code>最终引用更新（Final Update Reference）</code>。修正存在于<code>GC Roots</code>中的引用，这个阶段是Shenandoah的最后一次停顿。</li>
<li><code>并发清理（Concurrent Cleanup）</code>。经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成<code>Immediate Garbage Regions</code>了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</li>
</ul>
<p>三个最重要的并发阶段<strong>（并发标记、并发回收、并发引用更新）</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Shenandoah.PNG" alt="Shenandoah收集器的工作过程"></p>
<p>黄色的区域代表的是<em>被选入回收集的Region</em>，绿色部分就代表<em>还存活的对象</em>，蓝色就是<em>用户线程可以用来分配对象的内存Region</em>。</p>
<p><code>Brooks Pointer</code>。<code>Brooks</code>提出了使用<code>转发指针</code>（<code>Forwarding Pointer</code>，也常被称为<code>Indirection Pointer</code>）来实现对象移动与用户程序并发的一种解决方案。<code>Brooks</code>在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Brooks_Pointers.PNG" alt="Brooks Pointers示意图"></p>
<p>转发指针加入后带来的收益是当对象拥有了一份新的副本时，只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Brooks_Pointers2.PNG" alt="Brooks Pointers原理"></p>
<p><strong>Brooks转发指针的多线程竞争问题</strong>：</p>
<ul>
<li>收集器线程与用户线程发生的只是并发读取，那无论读到旧对象还是新对象上的字段，返回的结果都应该是一样的；</li>
<li>如果发生的是并发写入，就一定必须保证<code>写操作</code>只能发生在新复制的对象上。</li>
</ul>
<p>Shenandoah收集器是通过<code>比较并交换（Compare And Swap，CAS）操作</code>来保证并发时对象的访问正确性的。</p>
<h4 id="5-2-ZGC收集器"><a href="#5-2-ZGC收集器" class="headerlink" title="5.2 ZGC收集器"></a>5.2 ZGC收集器</h4><p><code>ZGC（Z Garbage Collector）</code>是一款在 <code>JDK 11</code>中新加入的具有实验性质的低延迟垃圾收集器。ZGC和Shenandoah的目标是高度相似的，都希望<u>在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</u>。</p>
<h5 id="5-2-1-ZGC的内存布局"><a href="#5-2-1-ZGC的内存布局" class="headerlink" title="5.2.1 ZGC的内存布局"></a>5.2.1 ZGC的内存布局</h5><p>ZGC也采用基于Region的堆内存布局（在一些官方资料中将它称为<code>Page</code>或者<code>ZPage</code>），ZGC的Region具有<strong>动态性</strong>——<u>动态创建和销毁，以及动态的区域容量大小</u>。ZGC的 Region可以有大、中、小三类容量：</p>
<ul>
<li><code>小型Region（Small Region）</code>：容量固定为<code>2MB</code>，用于放置<u>小于</u><code>256KB</code>的小对象。</li>
<li><code>中型Region（Medium Region）</code>：容量固定为<code>32MB</code>，用于放置<u>大于等于</u><code>256KB</code>但<u>小于</u><code>4MB</code>的对象。</li>
<li><code>大型Region（Large Region）</code>：容量不固定，可以动态变化，但必须为<code>2MB</code>的<strong>整数倍</strong>，用于放置<code>4MB</code>或以上的大对象。每个大型Region中只会存放一个大对象，大型Region在ZGC的实现中<strong>不会被重分配</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ZGC_memory.PNG" alt="ZGC的堆内存布局"></p>
<h5 id="5-2-2-ZGC的并发整理算法"><a href="#5-2-2-ZGC的并发整理算法" class="headerlink" title="5.2.2 ZGC的并发整理算法"></a>5.2.2 ZGC的并发整理算法</h5><p>ZGC收集器采用的<code>染色指针技术</code>（<code>Colored Pointer</code>，其他类似的技术中可能将它称为<code>Tag Pointer</code>或者<code>Version Pointer</code>）。染色指针直接把标记信息记在引用对象的指针上。</p>
<p>在64位系统中，理论可以访问的内存高达<code>16EB</code>（<code>2的64次幂</code>）字节。基于需求 、性能和成本的考虑，在<code>AMD64</code>架构中只支持到<code>52</code>位（<code>4PB</code>）的<u>地址总线</u>和<code>48</code>位（<code>256TB</code>）的<u>虚拟地址空间</u>。</p>
<blockquote>
<p>操作系统也还会施加自己的约束，64位的<code>Linux</code>则分别支持<code>47</code>位（<code>128TB</code>）的进程虚拟地址空间和<code>46</code>位（<code>64TB</code>）的物理地址空间，64位的<code>Windows</code>系统甚至只支持<code>44</code>位（<code>16TB</code>）的物理地址空间。</p>
</blockquote>
<p>Linux下64位指针的高18位不能用来寻址，ZGC的染色指针技术利用这剩下的46位指针宽度，将其<code>高4位</code>提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的<strong>三色标记状态</strong>、<strong>是否进入了重分配集</strong>（即被移动过）、<strong>是否只能通过finalize()方法才能被访问到</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Colored_Pointer.PNG" alt="染色指针"></p>
<blockquote>
<p>这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致ZGC能够管理的内存不可以超过<code>4TB</code></p>
</blockquote>
<p>染色指针的三大优势：</p>
<ul>
<li>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</li>
<li>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。</li>
<li>染色指针可以作为一种<code>可扩展</code>的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li>
</ul>
<h5 id="5-2-3-虚拟内存映射技术"><a href="#5-2-3-虚拟内存映射技术" class="headerlink" title="5.2.3 虚拟内存映射技术"></a>5.2.3 虚拟内存映射技术</h5><p>处理器会使用<code>分页管理机制</code>把线性地址空间和物理地址空间分别划分为大小相同的块，这样的内存块被称为<code>“页”（Page）</code>。通过在线性虚拟空间的页与物理地址空间的页之间建立的<code>映射表</code>，分页管理机制会进行线性地址到物理地址空间的映射，完成线性地址到物理地址的转换。</p>
<p><code>Linux/x86-64</code>平台上的ZGC使用了<code>多重映射（Multi-Mapping）</code>将<u>多个不同的虚拟内存地址映射到同一个物理内存地址上</u>，这是一种<strong>多对一映射</strong>，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。把染色指针中的标志位看作是<code>地址的分段符</code>，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Multi_Mapping.PNG" alt="多重映射下的寻址"></p>
<h5 id="5-2-4-ZGC的运作过程"><a href="#5-2-4-ZGC的运作过程" class="headerlink" title="5.2.4 ZGC的运作过程"></a>5.2.4 ZGC的运作过程</h5><p>ZGC的运作过程大致可划分为以下四个大的阶段。全部四个阶段<strong><u>都是可以并发执行</u></strong>的，仅是两个阶段中间会存在短暂的停顿小阶段，如初始化<code>GC Root</code>直接关联对象的<code>Mark Start</code>。</p>
<ul>
<li><code>并发标记（Concurrent Mark）</code>：并发标记是<strong>遍历对象图做可达性分析的阶段</strong>，前后也要经过初始标记、最终标记的短暂停顿。ZGC 的标记是在指针上进行的，标记阶段会更新染色指针中的<code>Marked0</code>、<code>Marked1</code>标志位。</li>
<li><code>并发预备重分配（Concurrent Prepare for Relocate）</code>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成<code>重分配集（Relocation Set）</code>。ZGC每次回收都会<strong>扫描所有的Region</strong>，用范围更大的扫描成本换取<u>省去G1中记忆集的维护成本</u>。</li>
<li><code>并发重分配（Concurrent Relocate）</code>：把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<code>转发表（Forward Table）</code>，<u>记录从旧对象到新对象的转向关系</u>。<ul>
<li>指针的<code>“自愈”（Self-Healing）</code>能力：ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被<code>预置的内存屏障</code>所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象。这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次。</li>
</ul>
</li>
<li><code>并发重映射（Concurrent Remap）</code>：重映射所做的就是<u>修正整个堆中指向重分配集中旧对象的所有引用</u>，但是ZGC重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。ZGC把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成。</li>
</ul>
<h5 id="5-2-5-“NUMA-Aware”的内存分配"><a href="#5-2-5-“NUMA-Aware”的内存分配" class="headerlink" title="5.2.5 “NUMA-Aware”的内存分配"></a>5.2.5 “NUMA-Aware”的内存分配</h5><p>ZGC支持<code>“NUMA-Aware”的内存分配</code>。<code>NUMA</code>（<code>Non-Uniform Memory Access</code>，<strong>非统一内存访问架构</strong>）是一种为多处理器或者多核处理器的计算机所设计的内存架构。在<code>NUMA</code>架构下，ZGC收集器会优先尝试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问。</p>
<h3 id="6-选择合适的垃圾收集器"><a href="#6-选择合适的垃圾收集器" class="headerlink" title="6. 选择合适的垃圾收集器"></a>6. 选择合适的垃圾收集器</h3><h4 id="6-1-Epsilon收集器"><a href="#6-1-Epsilon收集器" class="headerlink" title="6.1 Epsilon收集器"></a>6.1 Epsilon收集器</h4><p><code>Epsilon</code>这是一款以<u>不能够进行垃圾收集</u>为“卖点”的垃圾收集器。</p>
<blockquote>
<p>Epsilon收集器由<code>RedHat</code>公司在<code>JEP 318</code>中提出，在此提案里<code>Epsilon</code>被形容成一个<code>无操作的收集器（A No-Op Garbage Collector）</code>。</p>
</blockquote>
<p>一个垃圾收集器除了垃圾收集这个本职工作之外，它还要负责<u>堆的管理与布局</u>、<u>对象的分配</u>、<u>与解释器的协作</u>、<u>与编译器的协作</u>、<u>与监控子系统协作</u>等职责。Epsilon是垃圾收集器的统一接口，用于需要剥离垃圾收集器影响的性能测试和压力测试。</p>
<p>在实际生产环境中，不能进行垃圾收集的Epsilon也用于应对<code>短时间、小规模</code>的服务形式，只要Java虚拟机<u>能正确分配内存，在堆耗尽之前就会退出</u>，那显然运行负载极小、没有任何回收行为的Epsilon便是很恰当的选择。</p>
<h4 id="6-2-收集器的权衡"><a href="#6-2-收集器的权衡" class="headerlink" title="6.2 收集器的权衡"></a>6.2 收集器的权衡</h4><p>选择一款适合自己应用的收集器主要受以下三 个因素影响：</p>
<ul>
<li><code>应用程序的主要关注点是什么？</code><ul>
<li>如果是数据分析、科学计算类的任务，目标是能尽快算出结果， 那吞吐量就是主要关注点；</li>
<li>如果是<code>SLA（（Service Level Agreements））</code>应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点；</li>
<li>而如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的。</li>
</ul>
</li>
<li><code>运行应用的基础设施如何？</code><ul>
<li>譬如硬件规格，要涉及的系统架构；</li>
<li>处理器的数量多少，分配内存的大小；</li>
<li>选择的操作系统。</li>
</ul>
</li>
<li>使用JDK的发行商是什么？版本号是多少？是ZingJDK/Zulu、OracleJDK、Open-JDK、OpenJ9抑或是其他公司的发行版？该JDK对应了《Java虚拟机规范》的哪个版本？</li>
</ul>
<p>实战中切不可纸上谈兵，<strong>根据系统实际情况去测试才是选择收集器的最终依据</strong>。</p>
<h4 id="6-3-虚拟机及垃圾收集器日志"><a href="#6-3-虚拟机及垃圾收集器日志" class="headerlink" title="6.3 虚拟机及垃圾收集器日志"></a>6.3 虚拟机及垃圾收集器日志</h4><p><code>JDK 9</code>后，<code>HotSpot</code>所有功能的日志都收归到了<code>“-Xlog”</code>参数上，这个参数的能力也相应被极大拓展：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xlog[:[selector][:[output][:[decorators][:output-options]]]]</span><br></pre></td></tr></table></figure>
<p>最关键的参数是<code>选择器（Selector）</code>，它由<code>标签（Tag）</code>和<code>日志级别（Level）</code>共同组成。</p>
<p>日志级别从低到高，共有<code>Trace，Debug，Info，Warning，Error，Off</code>六种级别，默认级别为<code>Info</code>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Log_parameter.PNG" alt="JDK 9前后日志参数变化"></p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Log_parameter2.PNG" alt="JDK 9前后日志参数变化(续)"></p>
<h4 id="6-4-垃圾收集器参数总结"><a href="#6-4-垃圾收集器参数总结" class="headerlink" title="6.4 垃圾收集器参数总结"></a>6.4 垃圾收集器参数总结</h4><p>具体可以查看书籍，主要还是用到的时候查一下就行。</p>
<h3 id="7-内存分配与回收策略"><a href="#7-内存分配与回收策略" class="headerlink" title="7. 内存分配与回收策略"></a>7. 内存分配与回收策略</h3><p>Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：<u><strong>自动给对象分配内存</strong></u>以及<u><strong>自动回收分配给对象的内存</strong></u>。对象的内存分配，从概念上讲，应该都是在堆上分配（而实际上也有可能经过<code>即时编译</code>后被拆散为标量类型并间接地在栈上分配）。</p>
<h4 id="7-1-对象优先在Eden分配"><a href="#7-1-对象优先在Eden分配" class="headerlink" title="7.1 对象优先在Eden分配"></a>7.1 对象优先在Eden分配</h4><p>对象在新生代<code>Eden区</code>中分配。当<code>Eden区</code>没有足够空间进行分配时，虚拟机将发起 一次<code>Minor GC</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">	allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">	allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">	allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">	allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">// 出现一次Minor GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>testAllocation()</code>中分配<code>allocation4</code>对象的语句时会发生一次<code>Minor GC</code>，产生这次垃圾收集的原因是为<code>allocation4</code>分配内存时，发现 <code>Eden</code>已经被占用了<code>6MB</code>，剩余空间已不足以分配<code>allocation4</code>所需的<code>4MB</code>内存，因此发生<code>Minor GC</code>。</p>
<p>垃圾收集期间虚拟机又发现已有的三个<code>2MB</code>大小的对象全部无法放入<code>Survivor</code>空间（<strong>Survivor空间只有 1MB大小</strong>），所以只好通过分配担保机制提前转移到老年代去。</p>
<p>收集结束后，<code>4MB</code>的<code>allocation4</code>对象顺利分配在<code>Eden</code>中。因此程序执行完的结果是<code>Eden</code>占用 <code>4MB</code>（被<code>allocation4</code>占用），<code>Survivor</code>空闲，老年代被占用<code>6MB</code>（被<code>allocation1、2、3</code>占用）。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testAllocation.PNG" alt="testAllocation运行结果"></p>
<h4 id="7-2-大对象直接进入老年代"><a href="#7-2-大对象直接进入老年代" class="headerlink" title="7.2 大对象直接进入老年代"></a>7.2 大对象直接进入老年代</h4><p>最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。</p>
<blockquote>
<p>在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">* -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] allocation;</span><br><span class="line">	allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">//直接分配在老年代中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Eden空间几乎没有被使用，而老年代的<code>10MB</code>空间被使用了40%，也就是<code>4MB</code>的allocation对象<strong>直接就分配在老年代中</strong></p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testPretenureSizeThreshold.PNG" alt="testPretenureSizeThreshold运行结果"></p>
<h4 id="7-3-长期存活的对象将进入老年代"><a href="#7-3-长期存活的对象将进入老年代" class="headerlink" title="7.3 长期存活的对象将进入老年代"></a>7.3 长期存活的对象将进入老年代</h4><p>虚拟机给每个对象定义了一个<code>对象年龄（Age）计数器</code>，存储在对象头中。</p>
<p>对象通常在<code>Eden区</code>里诞生，如果经过第一次 <code>Minor GC</code>后仍然存活，并且能被<code>Survivor</code>容纳的话，该对象会被移动到<code>Survivor</code>空间中，并且将其对象年龄设为<code>1岁</code>。对象在<code>Survivor</code>区中每熬过一次<code>Minor GC</code>，年龄就增加<code>1岁</code>，当它的年龄增加到一定程度（默认为15），就会<strong>被晋升到老年代中</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment">* -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">	allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>]; <span class="comment">// 什么时候进入老年代决定于XX:MaxTenuringThreshold设置</span></span><br><span class="line">	allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">	allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">	allocation3 = <span class="keyword">null</span>;</span><br><span class="line">	allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当<code>-XX：MaxTenuringThreshold=1</code>时，<code>allocation1</code>对象在第二次<code>GC</code>发生时进入老年代， 新生代已使用的内存在垃圾收集以后非常干净地变成<code>0KB</code>。</li>
<li>当<code>-XX：MaxTenuringThreshold=15</code>时， 第二次<code>GC</code>发生后，<code>allocation1</code>对象则还留在新生代<code>Survivor</code>空间，这时候新生代仍然有<code>404KB</code>被占用。</li>
</ul>
<h4 id="7-4-动态对象年龄判定"><a href="#7-4-动态对象年龄判定" class="headerlink" title="7.4 动态对象年龄判定"></a>7.4 动态对象年龄判定</h4><p>如果在<code>Survivor</code>空间中相同年龄所有对象大小的总和大于<code>Survivor</code>空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p>
<h4 id="7-5-空间分配担保"><a href="#7-5-空间分配担保" class="headerlink" title="7.5 空间分配担保"></a>7.5 空间分配担保</h4><p>在发生<code>Minor GC</code>之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间：</p>
<ul>
<li>如果这个条件成立，那这一次<code>Minor GC</code>可以确保是安全的；</li>
<li>如果不成立，会查看是否允许担保失败（Handle Promotion Failure）：<ul>
<li>如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次<code>Minor GC</code>，尽管这次<code>Minor GC</code>是有风险的；</li>
<li>如果小于，或设置不允许冒险，那这时就要改为进行一次<code>Full GC</code>。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--1 走近Java</title>
    <url>/2021/04/23/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_1_Approaching_Java.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><code>世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。</code><br><a id="more"></a></p>
</blockquote>
<h4 id="1-Java技术体系"><a href="#1-Java技术体系" class="headerlink" title="1. Java技术体系"></a>1. Java技术体系</h4><p><code>JCP(Java Community Process)</code>所定义的Java技术体系包括了以下几个组成部分：</p>
<ul>
<li>Java程序设计语言</li>
<li>各种硬件平台上的Java虚拟机实现</li>
<li>Class文件格式</li>
<li>Java类库API</li>
<li>来自商业机构和开源社区的第三方Java类库</li>
</ul>
<p><code>JDK(Java Development Kit)</code>是用于支持Java程序开发的最小环境，主要分为三部分：</p>
<ul>
<li>Java程序设计语言</li>
<li>Java虚拟机</li>
<li>Java类库</li>
</ul>
<p><code>JRE(Java Runtime Environment)</code>是支持Java程序运行的标准环境，主要包括：</p>
<ul>
<li>Java SE API子集</li>
<li>Java虚拟机</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Java_technology_system.PNG" alt="Java技术体系"></p>
<p>按照技术关注的重点业务来划分，可以分为以下四条主要的产品线：</p>
<ul>
<li><strong>Java Card</strong>：支持Java小程序（Applets）运行在<strong><code>小内存设备（如智能卡）</code></strong>上的平台。</li>
<li><strong>Java ME（Micro Edition）</strong>：支持Java程序运行在<strong><code>移动终端（手机、PDA）</code></strong>上的平台，对Java API 有所精简，并加入了移动终端的针对性支持，这条产品线在JDK 6以前被称为<code>J2ME</code>。</li>
<li><strong>Java SE（Standard Edition）</strong>：支持面向<strong><code>桌面级应用（如Windows下的应用程序）</code></strong>的Java平台，提 供了完整的Java核心API，这条产品线在JDK 6以前被称为<code>J2SE</code>。</li>
<li><strong>Java EE（Enterprise Edition）</strong>：支持<strong><code>使用多层架构的企业应用（如ERP、MIS、CRM应用）</code></strong>的 Java平台，除了提供Java SE API外，还对其做了大量有针对性的扩充，并提供了相关的部署支持， 这条产品线在JDK 6以前被称为<code>J2EE</code>；在JDK 10以后被Oracle放弃，捐献给Eclipse基金会管理，此后被 称为<code>Jakarta EE</code>。(PS:扩展一般以<code>javax.*</code>作为包名，而以<code>java.*</code>为包名的包都是Java SE API的核心包。一部分曾经是扩展包的API后来进入了核心包中，因此核心包中也包含了不少<code>javax.*</code>开头的包名)</li>
</ul>
<h4 id="2-Java虚拟机家族"><a href="#2-Java虚拟机家族" class="headerlink" title="2. Java虚拟机家族"></a>2. Java虚拟机家族</h4><h5 id="2-1-虚拟机始祖：Sun-Classic-Exact-VM"><a href="#2-1-虚拟机始祖：Sun-Classic-Exact-VM" class="headerlink" title="2.1 虚拟机始祖：Sun Classic/Exact VM"></a>2.1 虚拟机始祖：Sun Classic/Exact VM</h5><p><code>Classic VM</code>只能使用<strong>纯解释器方式</strong>来执行Java代码，如果要使用<strong>即时编译器</strong>就必须进行外挂，但是假如外挂了即时编译器的话，即时编译器就会完全接管虚拟机的执行系统，解释器便不能再工作了。由于解释器和编译器不能配合工作，这就意味着<code>如果要使用编译执行，编译器就不得不对每一个方法、每一行代码都进行编译，而无论它们执行的频率是否具有编译的价值</code>。</p>
<p><code>Exact VM</code>因它使用<code>准确式内存管理</code>（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management）而得名。准确式内存管理是指<code>虚拟机可以知道内存中某个位置的数据具体是什么类型</code>。已经具备现代高性能虚拟机雏形，如热点探测、两级即时编译器、编译器与解释器混合工作模式等。</p>
<h5 id="2-2-武林盟主：HotSpot-VM"><a href="#2-2-武林盟主：HotSpot-VM" class="headerlink" title="2.2 武林盟主：HotSpot VM"></a>2.2 武林盟主：HotSpot VM</h5><p><code>HotSpot VM</code>是Sun/OracleJDK和OpenJDK中的默认Java虚拟机，也是目前<em>使用范围最广</em>的Java虚拟机。</p>
<blockquote>
<p>它是由一家名为<code>“Longview Technologies”</code>的小公司设计；甚至这个虚拟机最初<em>并非是为Java语言而研发的</em>，它来源于<code>Strongtalk虚拟机</code>，而这款虚拟机中相当多的技术又是来源于一款为<em>支持Self语言</em>实现“达到C语言50%以上的执行效率”的目标而设计的Self虚拟机， 最终甚至可以追溯到20世纪80年代中期开发的<code>Berkeley Smalltalk</code>上。</p>
</blockquote>
<p>它名称中的HotSpot指的就是它的<code>热点代码探测技术</code>。</p>
<blockquote>
<p>HotSpot虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器<strong>以方法为单位进行编译</strong>。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发<code>标准即时编译和栈上替换编译（On-Stack Replacement，OSR）行为</code>。</p>
</blockquote>
<h5 id="2-3-小家碧玉：Mobile-Embedded-VM"><a href="#2-3-小家碧玉：Mobile-Embedded-VM" class="headerlink" title="2.3 小家碧玉：Mobile/Embedded VM"></a>2.3 小家碧玉：Mobile/Embedded VM</h5><p>面对移动和嵌入式市场，在Java ME这条产品线上的虚拟机名为CDC-HI（C Virtual Machine， CVM）和CLDC-HI（Monty VM）。</p>
<blockquote>
<p>CDC/CLDC全称是<code>Connected（Limited）Device Configuration</code>，HI则是<code>HotSpot Implementation</code>的缩写，但它们并不是由HotSpot直接裁剪而来，只是借鉴过其中一些技术，并没有血缘关系，充其量能叫有所渊源。</p>
</blockquote>
<h5 id="2-4-天下第二：BEA-JRockit-IBM-J9-VM"><a href="#2-4-天下第二：BEA-JRockit-IBM-J9-VM" class="headerlink" title="2.4 天下第二：BEA JRockit/IBM J9 VM"></a>2.4 天下第二：BEA JRockit/IBM J9 VM</h5><p>BEA System公司的<code>JRockit</code>与 IBM公司的<code>IBM J9</code>曾经与HotSpot并称<strong>“三大商业Java虚拟机”</strong>。</p>
<p>JRockit虚拟机曾经号称是“世界上速度最快的Java虚拟机”，BEA将其发展为一款<strong>专门为服务器硬件和服务端应用场景高度优化的虚拟机</strong>，由于专注于服务端应用，它可以不太关注于程序启动速度，因此JRockit内部<em>不包含解释器实现</em>，全部代码都靠<code>即时编译器编译后执行</code>。JRockit的<strong>垃圾收集器</strong>和<strong>Java Mission Control故障处理套件</strong>等部分的实现，在当时众多的Java虚拟机中也处于领先水平。</p>
<p>IBM J9虚拟机机最初是由IBM Ottawa实验室的一个<code>SmallTalk虚拟机</code>项目扩展而来。IBM J9虚拟机的市场定位与HotSpot比较接近，它是一款在<em>设计上全面考虑服务端、桌面应用，再到嵌入式的多用途虚拟机</em>。</p>
<blockquote>
<p>IBM J9虚拟机的<code>职责分离与模块化</code>做得比HotSpot更优秀，由J9 虚拟机中抽象封装出来的核心组件库（包括垃圾收集器、即时编译器、诊断监控子系统等）就单独构成了IBM OMR项目</p>
</blockquote>
<h5 id="2-5-软硬合璧：BEA-Liquid-VM-Azul-VM"><a href="#2-5-软硬合璧：BEA-Liquid-VM-Azul-VM" class="headerlink" title="2.5 软硬合璧：BEA Liquid VM/Azul VM"></a>2.5 软硬合璧：BEA Liquid VM/Azul VM</h5><p>一类<strong>与特定硬件平台绑定、软硬件配合工作的专有虚拟机</strong>，往往能够实现更高的执行性能，或提供某些特殊的功能特性。</p>
<blockquote>
<p>Liquid VM也被称为JRockit VE(Virtual Edition，VE)，BEA公司开发的可以直接运行在自家 Hypervisor系统上的JRockit虚拟机的虚拟化版本。Liquid VM不需要操作系统的支持，或者说<strong>它自己本身实现了一个专用操作系统的必要功能</strong>。</p>
<p>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的<strong>专有硬件Vega系统</strong>上的Java虚拟机。</p>
<p>Zing虚拟机(Azul Systems公司研发)是一个从HotSpot某旧版代码分支基础上独立出来重新开发的高性能Java虚拟机。在要求低延迟、快速预热等场景中，Zing VM都要比HotSpot表现得更好。Zing的PGC、 C4收集器可以轻易支持TB级别的Java堆内存，而且保证暂停时间仍然可以维持在不超过10毫秒的范围里。</p>
</blockquote>
<h5 id="2-6-挑战者：Apache-Harmony-Google-Android-Dalvik-VM"><a href="#2-6-挑战者：Apache-Harmony-Google-Android-Dalvik-VM" class="headerlink" title="2.6 挑战者：Apache Harmony/Google Android Dalvik VM"></a>2.6 挑战者：Apache Harmony/Google Android Dalvik VM</h5><p>Harmony虚拟机（准确地说是Harmony里的DRLVM）和Dalvik虚拟机<code>只能称作“虚拟 机”，而不能称作“Java虚拟机”</code>。</p>
<h5 id="2-7-没有成功，但并非失败：Microsoft-JVM及其他"><a href="#2-7-没有成功，但并非失败：Microsoft-JVM及其他" class="headerlink" title="2.7 没有成功，但并非失败：Microsoft JVM及其他"></a>2.7 没有成功，但并非失败：Microsoft JVM及其他</h5><p>微软为了在Internet Explorer 3浏览器中支持Java Applets应用而开发了自己的Java虚拟机，</p>
<h5 id="2-8-百家争鸣"><a href="#2-8-百家争鸣" class="headerlink" title="2.8 百家争鸣"></a>2.8 百家争鸣</h5><p>一些Java虚拟机是单纯为了用于生产，甚至在设计之初就仅仅是用于研究、验证某种技术和观点，又或者是作为一些规范的标准实现：</p>
<blockquote>
<ul>
<li>KVM。KVM中的K是“Kilobyte”的意思，它强调简单、轻量、高度可移植，但是运行速度比较慢。主要用于手机平台。</li>
<li>Java Card VM。JCVM必须精简到能放入智能卡、SIM卡、银行信用卡、借记卡内。</li>
<li>Squawk VM。运行于Sun SPOT（Sun Small Programmable Object Tech-nology，一种手持的Wi-Fi设备），也曾经运用于Java Card。</li>
<li>JavaInJava。试图以Java语言来实现Java语言本身的运行环境，既所谓的“元循环”（Meta-Circular，是指使用语言自身来实现其运行环境）虚拟机。</li>
<li>Maxine VM。也是一个几乎全部以Java代码实现（只有用于启动 Java虚拟机的加载器使用C语言编写）的元循环Java虚拟机。</li>
<li>Jikes RVM。是IBM开发的专门用来研究Java虚拟机实现技术的项目，也是一个元循环虚拟机。</li>
<li>IKVM.NET。基于微软.NET框架实现的Java虚拟机，并借助Mono获得一定的跨平台能力。</li>
</ul>
</blockquote>
<h4 id="3-实战：自己编译JDK"><a href="#3-实战：自己编译JDK" class="headerlink" title="3. 实战：自己编译JDK"></a>3. 实战：自己编译JDK</h4><h5 id="3-1-OpenJDK和OracleJDK"><a href="#3-1-OpenJDK和OracleJDK" class="headerlink" title="3.1 OpenJDK和OracleJDK"></a>3.1 OpenJDK和OracleJDK</h5><p>OpenJDK和 OracleJDK在程序上是非常接近的，两者共用了绝大部分相同的代码。在JDK 11以前，OracleJDK中还会存在一些OpenJDK没有的、闭源的功能，即OracleJDK 的“商业特性”。许多功能在JDK 11时全部开源到了OpenJDK中。到了这个阶段，已经可以认为OpenJDK与OracleJDK代码实质上已达到完全一致的程度。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OpenJDK_and_OracleJDK.PNG" alt="OpenJDK和 OracleJDK的关系"></p>
<p>OpenJDK内部不同版本之间的关系，按照开发习惯，新的功能或Bug修复通常是在最新分支上进行的，当功能或修复在最新分支上稳定之后会同步到其他老版本的维护分支上。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Relationship_between_OpenJDK_versions.PNG" alt="OpenJDK版本之间的关系"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--10. Regular Expression Matching</title>
    <url>/2019/04/07/LeetCode--10-Regular-Expression-Matching.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an input string (s) and a pattern (p), implement regular expression matching with support for <strong>‘.’</strong> and <strong>‘*’</strong>.<br><a id="more"></a></p>
<ul>
<li>‘.’ Matches any single character.</li>
<li>‘*’ Matches zero or more of the preceding element.</li>
</ul>
<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<ul>
<li>s could be empty and contains only lowercase letters a-z.</li>
<li>p could be empty and contains only lowercase letters a-z, and characters like . or *.</li>
</ul>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input:<br>s = “aa”<br>p = “a*“<br>Output: true<br>Explanation: ‘*‘ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input:<br>s = “ab”<br>p = “.*“<br>Output: true<br>Explanation: “.*“ means “zero or more (*) of any character (.)”.</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input:<br>s = “aab”<br>p = “c*a*b”<br>Output: true<br>Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”.</p>
</blockquote>
<p><strong>Example 5:</strong></p>
<blockquote>
<p>Input:<br>s = “mississippi”<br>p = “mis*is*p*.”<br>Output: false</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题主要是看了题目的题解后才解出来的，这里就主要对这道题总结一下。一种直观的方法是<br>使用递归求解，我们发现在进行匹配时有如下考虑：</p>
<blockquote>
<ol>
<li>如果没有”*“，那么我们可以简单的从左到右逐个字符比较，判断是否匹配；</li>
<li>如果有”*“，我们需要检查各种可能的情况，观察是否存在一种匹配的扩展方式。</li>
</ol>
</blockquote>
<p>所以可以看出递归是一种简单直观的实现方式。如果存在”*“，那么它必定出现在一个字符后面。我们要么忽略这段表达式(即假设它重复0次)，要么从字符串S中后移一位(即假设它重复至少1次)。在匹配完所有情况后，若有匹配成功的情况，那么就匹配成功了。</p>
<p>这种方法尽管简单，但是效率不高。一种优化的解法是，我们将中间结果保存起来，不使用递归。这样可以省略大量的计算。这种方法也就是DP算法，定义DP[i][j]如下：若S[0:i]与P[0:j]匹配，那么DP[i][j]值为真；否者，值为假。</p>
<blockquote>
<ol>
<li>dp[i][j] = dp[i - 1][j - 1], if p[j - 1] != ‘*’ &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’);</li>
<li>dp[i][j] = dp[i][j - 2], if p[j - 1] == ‘*’ 且表达式重复0次;</li>
<li>dp[i][j] = dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == ‘.’), if p[j - 1] == ‘*’ 且表达式重复至少1次.</li>
</ol>
</blockquote>
<p><strong>参考文献：</strong><a href="https://leetcode.com/problems/regular-expression-matching/discuss/5684/9-lines-16ms-c-dp-solutions-with-explanations" target="_blank" rel="noopener" title="C++ O(n)-space DP">C++ O(n)-space DP</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.empty()) <span class="keyword">return</span> s.empty();</span><br><span class="line">        <span class="keyword">bool</span> first_match = (!s.empty() &amp;&amp; (p[<span class="number">0</span>] == s[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p.length() &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p.substr(<span class="number">2</span>)) || (first_match &amp;&amp; isMatch(s.substr(<span class="number">1</span>),p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; isMatch(s.substr(<span class="number">1</span>),p.substr(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="DP算法"><a href="#DP算法" class="headerlink" title="DP算法"></a>DP算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length(),plen=p.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(slen+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(plen+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= slen; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">'*'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-2</span>] || (i &amp;&amp; dp[i<span class="number">-1</span>][j] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">'.'</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = i &amp;&amp; dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">'.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法三-Bottom-Up-Variation"><a href="#解法三-Bottom-Up-Variation" class="headerlink" title="解法三 (Bottom-Up Variation)"></a>解法三 (Bottom-Up Variation)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.length()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(p.length()+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        dp[s.length()][p.length()] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length();i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = p.length()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> first_match = (i&lt; s.length() &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'.'</span>));</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span> &lt; p.length() &amp;&amp; p[j+<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">2</span>] || first_match &amp;&amp; dp[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = first_match &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--9 构造器与垃圾收集器</title>
    <url>/2021/05/13/JavaLearning_Head_First_Java_9_constructors_and_garbage_collection.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>对象有生死。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-栈与堆"><a href="#1-栈与堆" class="headerlink" title="1. 栈与堆"></a>1. 栈与堆</h3><p><code>Java</code>中主要在意两种内存区域：对象的生存空间<code>堆(heap)</code>与方法调用及变量的生存空间<code>栈(stack)</code>。<code>Java</code>虚拟机启动时，会从底层操作系统取得一块内存，用于执行Java程序。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/stackHeap.PNG" alt="栈与堆"></p>
<p>几乎所有对象都存活于可垃圾回收的堆上，而变量根据它的类型判断存在于那一个内存区域。实例变量存在于堆中，而局部变量(也叫区域变量)存在于栈上，所以也叫栈变量。</p>
<blockquote>
<ul>
<li><code>实例变量</code>被声明在类中方法之外，代表每个独理对象的“字段”，存在于所属对象中。</li>
<li><code>局部变量</code>和<code>方法</code>被声明在方法中，是<code>暂时</code>的，生命周期只限于方法被放置于栈上这段时间(即方法调用到执行完毕)</li>
</ul>
</blockquote>
<h4 id="1-1-局部变量"><a href="#1-1-局部变量" class="headerlink" title="1.1 局部变量"></a>1.1 局部变量</h4><p>调用一个方法时，该方法会放在调用栈的栈顶。实际上放到栈顶的时<code>栈帧(stack frame)</code>，带有方法的状态，程序计数器及所有的局部变量值。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/twoMthodsStack.PNG" alt="放了两个方法的栈"></p>
<p>比如<code>foo()</code>调用了<code>bar()</code>，则<code>bar()</code>方法会放置在<code>foo()</code>上面。</p>
<h4 id="1-2-对象局部变量"><a href="#1-2-对象局部变量" class="headerlink" title="1.2 对象局部变量"></a>1.2 对象局部变量</h4><p>非<code>primitive</code>的变量只是保存对象的引用，对象放于堆上，而局部变量本身放于栈上。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/objectLocalVariable.PNG" alt="对象局部变量"></p>
<h4 id="1-3-实例变量"><a href="#1-3-实例变量" class="headerlink" title="1.3 实例变量"></a>1.3 实例变量</h4><p>实例变量存在于对象所属的堆空间上。</p>
<ul>
<li>如果实例变量全是<code>primitive</code>主数据类型，<code>Java</code>会根据其类型的大小为该实例变量留下空间</li>
<li>如果实例变量是一个对象，会留下对象引用所用到的空间，而不是对象本身。</li>
</ul>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><h4 id="2-1-创建对象"><a href="#2-1-创建对象" class="headerlink" title="2.1 创建对象"></a>2.1 创建对象</h4><p>声明对象和赋值的3个步骤：<code>声明引用变量</code>、<code>创建对象</code>、<code>连接对象和引用</code>。第二步<code>创建对象</code>看起来好像在调用类名的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duck myDuck = <span class="keyword">new</span> Duck();</span><br></pre></td></tr></table></figure>
<p>实际上调用的是<code>Duck</code>的构造函数。</p>
<blockquote>
<p>构造函数并不是方法，它带有<code>new</code>的时候会执行的程序代码，在初始化对象时执行。调用构造函数唯一的方法是通过<code>new</code>新建一个类对象。</p>
</blockquote>
<p>未写构造函数时，编译器会有一个默认构造函数。下面是一个默认构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>构造函数没有返回类型，名字必须与类名相同。</p>
</li>
<li><p>可以有与类同名的方法而不会变成构造函数。</p>
</li>
<li>构造函数不会被继承。</li>
</ul>
</blockquote>
<p>构造函数的一个关键特征是，在对象与引用连接前就执行，可以对对象进行预处理。大部分人使用构造函数来初始化对象的状态，也就是给对象的实例变量赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> size;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">(<span class="keyword">int</span> duckSize)</span> </span>&#123; <span class="comment">// 构造函数加上参数</span></span><br><span class="line">     	System.out.println(“Quack”);</span><br><span class="line">    	size = duckSize;</span><br><span class="line">     	System.out.println(“size is “ + size);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseADuck</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Duck d = <span class="keyword">new</span> Duck(<span class="number">42</span>); <span class="comment">// 传值初始化类对象</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最好要有不需要参数的构造函数，来对应参数无法确定的默认情况。</p>
</blockquote>
<p>只有在完全没定义构造函数时，编译器才会帮忙编写默认构造函数。如果已经写了一个有参数的构造函数，编译器并不会增加无参数的构造函数，需要<code>手动编写</code>。</p>
<blockquote>
<p>构造函数可以是<code>公有</code>、<code>私有</code>或<code>不指定</code>的。</p>
</blockquote>
<h4 id="2-2-父类及继承与构造函数的关系"><a href="#2-2-父类及继承与构造函数的关系" class="headerlink" title="2.2 父类及继承与构造函数的关系"></a>2.2 父类及继承与构造函数的关系</h4><p>在创建新对象时，所有继承下来的构造函数都会执行。即每个父类的构造函数都会在子类对象创建时期执行。</p>
<blockquote>
<p>抽象类也有构造函数，只是无法对其执行<code>new</code>操作，他的构造函数会在子类创建实例时执行。</p>
</blockquote>
<p>如果<code>Hippo</code>对象继承<code>Animal</code>，<code>Animal</code>继承了<code>Object</code>，那么创建对象的过程被称为一个<code>&quot;构造函数链(Constructor Chaining)&quot;</code>。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/ConstructorChaining.PNG" alt="Hippo类构造函数调用"></p>
<blockquote>
<p>调用父类构造函数唯一的方法时调用<code>super()</code>。</p>
</blockquote>
<p>如果没有显式调用<code>super()</code>，编译器会自动加上<code>super()</code>的调用。且编译器自动加入的一定是<strong>没有参数的构造函数</strong>。</p>
<blockquote>
<p><code>super()</code>的调用必须是构造函数的第一个语句</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boop</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>();</span><br><span class="line">     size = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过要求父类的构造函数必须有名字，可以使得子类可以继承父类的<code>get</code>方法来访问私有的实例变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String theName)</span> </span>&#123;</span><br><span class="line">        name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hippo</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hippo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeHippo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hippo h = <span class="keyword">new</span> Hippo(<span class="string">"Buffy"</span>);</span><br><span class="line">        System.out.println(h.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类没有无参构造函数时，子类必须显式调用父类的构造函数，不然编译无法通过。</p>
<p>也可以在同一个类中调用另外的构造函数。比如多个构造函数有相同的工作部分，可以把这部分代码放在一个构造函数中，然后由其他构造函数调用。</p>
<blockquote>
<p>使用<code>this()</code>来从某个构造函数调用同一个类的另外一个构造函数。</p>
<p><code>this()</code>只能在构造函数中，且也必须时第一行语句。所以<code>super()</code>和<code>this()</code>不能在一个构造函数中同时调用。</p>
</blockquote>
<h4 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3 垃圾收集器"></a>3 垃圾收集器</h4><h4 id="3-1-对象的生命周期"><a href="#3-1-对象的生命周期" class="headerlink" title="3.1 对象的生命周期"></a>3.1 对象的生命周期</h4><p>对象的生命周期取决于引用到它的”引用”，引用变量的声明周期又看它是局部变量还是实例变量。</p>
<blockquote>
<ul>
<li>局部变量只会存活在声明该变量的方法中</li>
<li>实例变量的寿命与对象相同。</li>
</ul>
</blockquote>
<p><strong>“life”与”scope”的差别</strong></p>
<ul>
<li><strong>life</strong>。只要变量的堆栈块还存在于堆栈上，局部变量就算存活。</li>
<li><strong>scope</strong>。局部变量的范围只限于声明它的方法之内。当此方法调用其他方法时，该变量依旧存活，但不在目前执行范围内。</li>
</ul>
<p>如果对象的唯一引用解散，那么对象就会从堆中被抛弃，变成可回收的。</p>
<blockquote>
<p>若没有引用指向该对象，对象无法被获取，<code>垃圾收集器(GC)</code>会自动回收内存空间。</p>
</blockquote>
<p>有三种方法可以释放对象的引用：</p>
<ol>
<li><p>引用永久性的离开它的范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Life z = <span class="keyword">new</span> Life();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用被赋值到其他对象上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Life z = <span class="keyword">new</span> Life();</span><br><span class="line">z = <span class="keyword">new</span> Life();</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接将引用设定为<code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Life z = <span class="keyword">new</span> Life();</span><br><span class="line">z = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--1. Two Sum</title>
    <url>/2019/03/28/LeetCode--1-Two-Sum.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.<br><a id="more"></a><br>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the same element twice.</p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>给定一个数组，和一个目标数target，要求数组中，和为target的两个数的下标。<br>想到的方法是暴力求法，即直接逐个遍历数组，找出满足要求的两个数。尽管这种方法能成功AC,但显然效率不高，这种方法比较耗时。需要寻找更加优化的算法。<br>查阅资料和题解思路得知，更加优化的方法是使用哈希表，这是一种通过以空间换取速度的方式，我们可以将查找时间从 O(n)降低到 O(1)。主要有以下两种：</p>
<blockquote>
<p>1.两遍哈希表<br>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。</p>
<p>2.一遍哈希表<br>更优化的方法是，我们可以一次完成计算。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
</blockquote>
<p>这里将这两种方法都实现了一遍。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li><p>解法1 暴力求法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indices;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            indices.push_back(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==target-nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    indices.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> indices;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            indices.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2 两遍哈希表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  indices;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.count(complement) &amp;&amp; hash[complement] != i)</span><br><span class="line">            &#123;</span><br><span class="line">                indices.push_back(i);</span><br><span class="line">                indices.push_back(hash[complement]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一遍哈希表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  indices;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.count(complement))</span><br><span class="line">            &#123;</span><br><span class="line">                indices.push_back(i);</span><br><span class="line">                indices.push_back(hash[complement]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>更新：map与unordered_map区别<br>原文：<a href="https://blog.csdn.net/BillCYJ/article/details/78985895" target="_blank" rel="noopener">https://blog.csdn.net/BillCYJ/article/details/78985895</a><br><strong>1.内部实现机理不同</strong><br><strong>map</strong>： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。</p>
<p><strong>unordered_map</strong>: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p>
<p><strong>2.优缺点以及适用处</strong><br><strong>map：</strong><br>优点：</p>
<ol>
<li>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</li>
<li>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</li>
</ol>
<p>缺点：<br>空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间</p>
<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>
<p><strong>unordered_map：</strong><br>优点： 因为内部实现了哈希表，因此其查找速度非常的快</p>
<p>缺点： 哈希表的建立比较耗费时间</p>
<p>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<p><strong>总结：</strong></p>
<ol>
<li>内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。</li>
<li>但是unordered_map执行效率要比map高很多</li>
<li>对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--11. Container With Most Water</title>
    <url>/2019/04/03/LeetCode--11-Container-With-Most-Water.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given n non-negative integers <strong>a1, a2, …, an</strong> , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br><a id="more"></a></p>
</blockquote>
<p><strong>Note:</strong> You may not slant the container and n is at least 2.</p>
<p><img src="https://i.niupic.com/images/2019/04/03/5Ujc.jpg" alt=""><br>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example :</strong></p>
<blockquote>
<p>Input: [1,8,6,2,5,4,8,3,7]<br>Output: 49</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>首先想到的是暴力解法，直接遍历所有可能的二元组，最终可以找到满足题目要求的最大值。但是题目对时间有要求，这种时间复杂度O(n^2)的方法超时了。所以需要使用更优的方法，一种优化的方法思路如下：</p>
<blockquote>
<p>使用两个变量，一个表示底的开始，一个表示底的终点。一开始底的起点是数组第一位，终点是数组最后一位。这样去计算两者之间围成的区域，如果比当前记录的最大区域大，则将之记为最大区域值。之后，将两边中较短的一边向中间移动一个单位，再次计算区域大小，重复刚才的后续过程。<br>这里的难点是为什么移动的是两边中较小的一条呢？因为这条是这个区域增加的“短板“。移动较短的一边，也许会遇到一条更大的边，这样的话这种增加有可能抵消了底边的变短，甚至可能使得区域面积变得更大。相反的，如果移动的是较大的一边，最好的情况是遇到一条比较短边还要长的边，但是因为“木桶效应“，整个区域大小还是取决于较短的边，所以移动较长的一边是不可能得到更好的结果的。</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArea = min(height[i],height[j])*j;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            maxArea = max(maxArea,min(height[i],height[j])*(j-i));</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;height[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--12. Integer to Roman</title>
    <url>/2019/04/03/LeetCode--12-Integer-to-Roman.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<ul>
<li>I can be placed before V (5) and X (10) to make 4 and 9. </li>
<li>X can be placed before L (50) and C (100) to make 40 and 90. </li>
<li>C can be placed before D (500) and M (1000) to make 400 and 900.</li>
</ul>
<p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: 3<br>Output: “III”</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: 4<br>Output: “IV”</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: 9<br>Output: “IX”</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input: 58<br>Output: “LVIII”<br>Explanation: L = 50, V = 5, III = 3.</p>
</blockquote>
<p><strong>Example 5:</strong></p>
<blockquote>
<p>Input: 1994<br>Output: “MCMXCIV”<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目描述很长，但意思很简单，就是将普通的阿拉伯数字转换为罗马数字。罗马数字有自己的表示规则，所以需要进行一定处理。其实处理方法很简单：</p>
<blockquote>
<p>每次找到数字中包含的最大罗马数字，然后减去这个数，并把该罗马数加入表示数的字符串中。不断重复这个过程，直到数字为0停止，输出结果。</p>
</blockquote>
<p>最开始实现时，写了一长串的if-else语句，尽管能够成功解决。但是代码不够简洁，需要想办法使代码美观规范。可以将这些罗马数字和其对应的阿拉伯数字从大到小存放到数组或者map中，之后直接从大到小遍历这个数组即可，可以省去大部分if-else语句，且结构更加清晰。</p>
<p>评论区有另一种解法，直接把0~10,10~100,100~1000,1000~3999范围类，罗马数的可能表示直接列出来放到一个数字中，然后直接按位查表，O(1)的时间复杂度。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= val[i]) &#123;</span><br><span class="line">                num -= val[i];</span><br><span class="line">                res += str[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> THOUS[];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> HUNDS[];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> TENS[];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> ONES[];</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        result += THOUS[(<span class="keyword">int</span>)(num/<span class="number">1000</span>)%<span class="number">10</span>];</span><br><span class="line">        result += HUNDS[(<span class="keyword">int</span>)(num/<span class="number">100</span>)%<span class="number">10</span>];</span><br><span class="line">        result += TENS[(<span class="keyword">int</span>)(num/<span class="number">10</span>)%<span class="number">10</span>];</span><br><span class="line">        result += ONES[num%<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::THOUS[]	= &#123;<span class="string">""</span>,<span class="string">"M"</span>,<span class="string">"MM"</span>,<span class="string">"MMM"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::HUNDS[]	= &#123;<span class="string">""</span>,<span class="string">"C"</span>,<span class="string">"CC"</span>,<span class="string">"CCC"</span>,<span class="string">"CD"</span>,<span class="string">"D"</span>,<span class="string">"DC"</span>,<span class="string">"DCC"</span>,<span class="string">"DCCC"</span>,<span class="string">"CM"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::TENS[]	= &#123;<span class="string">""</span>,<span class="string">"X"</span>,<span class="string">"XX"</span>,<span class="string">"XXX"</span>,<span class="string">"XL"</span>,<span class="string">"L"</span>,<span class="string">"LX"</span>,<span class="string">"LXX"</span>,<span class="string">"LXXX"</span>,<span class="string">"XC"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::ONES[]	= &#123;<span class="string">""</span>,<span class="string">"I"</span>,<span class="string">"II"</span>,<span class="string">"III"</span>,<span class="string">"IV"</span>,<span class="string">"V"</span>,<span class="string">"VI"</span>,<span class="string">"VII"</span>,<span class="string">"VIII"</span>,<span class="string">"IX"</span>&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--8 接口与抽象类</title>
    <url>/2021/05/13/JavaLearning_Head_First_Java_8_interfaces_and_abstract_classes.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>继承只是个开始。<br><a id="more"></a></p>
</blockquote>
<h3 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1. 抽象类"></a>1. 抽象类</h3><h4 id="1-1-抽象类"><a href="#1-1-抽象类" class="headerlink" title="1.1 抽象类"></a>1.1 抽象类</h4><p>有些类不应该被初始化。比如如果尝试创建一个<code>Animal</code>对象，很难定义该对象或者说该对象并没有意义(没有一种叫做<code>Animal</code>的动物)。而又需要<code>Animal</code>类来继承和产生多态，需要<strong>限制只有它的子类才能被初始化</strong>。</p>
<p>通过标记类为<code>抽象类</code>，可以告诉编译器这个类不能创建任何类型实例。记让这个类不能被<code>&quot;nwe&quot;</code>出来。设计抽象类只需要在类前加入关键词<code>abstract</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Canie</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roam</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是可以用这种抽象类作为引用类型给多态使用。不是<code>抽象(abstract)</code>的类就被称为<code>具体(concrete)</code>类</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/abstractConcrete.PNG" alt="抽象与具体"></p>
<h4 id="1-2-抽象方法"><a href="#1-2-抽象方法" class="headerlink" title="1.2 抽象方法"></a>1.2 抽象方法</h4><p>方法也可以被标及为<code>abstract</code>。抽象类代表此类必须要被<code>extend</code>，抽象方法代表此方法必须要被覆盖。</p>
<blockquote>
<p><strong>抽象的方法没有实体</strong></p>
</blockquote>
<p>比如一个抽象的方法可以写作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果声明了一个抽象方法，那么这个类也必须被标记为抽象类。</p>
<blockquote>
<p>即<strong>非抽象类不能拥有抽象方法</strong></p>
</blockquote>
<p>抽象方法的意义是<u>就算无法实现出方法的内容，但还是可以定义出一组子类共同的协议</u>。由于抽象方法没有内容，只是为了标记出多态而存在，所以<strong>继承树下的第一个具体类必须要实现出所有的抽象方法</strong>。</p>
<p>一个抽象类继承另一个抽象类，不需要实现其抽象方法。但抽象类可以同时带有抽象和非抽象方法，所以如果有需要，也可以对抽象方法进行实现。</p>
<h4 id="1-3-多态范例"><a href="#1-3-多态范例" class="headerlink" title="1.3 多态范例"></a>1.3 多态范例</h4><p>如果要一个可以保持Dog对象的list，可以写一个专用的list类。但如果Cat也要用同样的方法，如果重新编写一个类似的类过于麻烦。可以利用多态的特点，编写一个<code>AnimalList</code>类来处理<code>Animal</code>的所有子类。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/animalList.PNG" alt="Animal List"></p>
<p>进一步，可以设计处理<code>Animal</code>之上的类，得到更通用、更抽象的类。</p>
<blockquote>
<p>Java中所有类都是从<code>Object</code>这个类继承出来的。<code>Object</code>是所有类的源头，即所有类的父类。</p>
</blockquote>
<p>没有直接继承过其他类的类会隐含地继承<code>Object</code>类。这样一个终极类(<code>ultra-super-megaclass</code>)需要带有一些每个对象都需要的行为。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/ultra-super-megaclass-Object.PNG" alt="终极类`Object`"></p>
<p><code>Object</code>不是一个正式的<code>Java</code>抽象类，也就是说可以创建<code>Object</code>对象。</p>
<blockquote>
<p><code>Object</code>对象的意义主要在于，有时需要一个<u>通用的、轻量化的</u>对象。比如在线程同步中。</p>
</blockquote>
<p><code>Object</code>类的主要目的是：</p>
<ul>
<li>作为多态让方法可以应付多种类型的机制；</li>
<li>提供Java在执行期间对任何对象都需要实现的程序代码。</li>
</ul>
<p>而如果使用<code>Object</code>类型的多态引用会带来一些问题：</p>
<ul>
<li>以<code>Object</code>类型作为引用时，<code>Java</code>会把它当作<code>Object</code>类型的实例，这代表只能调用由<code>Object</code>声明的方法。</li>
<li>任何重<code>ArrayList&lt;Object&gt;</code>取出的东西都会被当作<code>Object</code>类型的引用，也就导致无法复制给原来的类型。</li>
</ul>
<blockquote>
<p>编译器是<u>根据引用类型来判断有那些method可以调用，而不是<code>Object</code>的确实类型</u>。</p>
</blockquote>
<p>对象会带有从父类继承的所有东西。所以无论这个对象实际类型，它也是一个<code>Object</code>实例。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/snowboardObject.PNG" alt="内部`Object`"></p>
<p>但也有办法可以让<code>Object</code>引用恢复成原来的类，那就是使用<code>类型转化</code>。如果确定对象类型，可以直接转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dog d = (Dog) o;</span><br></pre></td></tr></table></figure>
<p>如果无法确定类型，可以使用<code>instanceof</code>来检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">	Dog d = (Dog) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h3><h4 id="2-1-接口"><a href="#2-1-接口" class="headerlink" title="2.1 接口"></a>2.1 接口</h4><p>如果想要修改<code>合约</code>，比如为Dog类加入Pet的方法，而又不影响其他非Pet类的使用，就需要<code>接口</code>。先看看没有<code>接口</code>会遇到的问题，可以用如下方式加入<code>Pet</code>方法进行修改：</p>
<ol>
<li>把<code>Pet</code>方法加入到<code>Animal</code>类中。<ul>
<li><code>优点</code>：所有子类马上继承<code>Pet</code>方法，无需改变子类程序代码。</li>
<li><code>缺点</code>：<code>非Pet</code>类也会继承到<code>Pet</code>方法</li>
</ul>
</li>
<li>把<code>Pet</code>方法加入到<code>Animal</code>类中，但把其设定为抽象的。<ul>
<li><code>优点</code>：<code>非Pet</code>类覆盖方法时，作出合理动作。</li>
<li><code>缺点</code>：所有子类都需要实现<code>Pet</code>方法，耗时。</li>
</ul>
</li>
<li>把方法添加到需要的子类中。<ul>
<li><code>优点</code>：<code>非Pet</code>类无需实现，更灵活。</li>
<li><code>缺点</code>：失去合约保证，且多态无法其作用。</li>
</ul>
</li>
</ol>
<p>真正需要的是：<code>Pet</code>方法只需要在宠物上实现；所有宠物类都有相同的方法定义；可以运用到多态。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/twoSuperClassesAtTop.PNG" alt="继承多个上次父类"></p>
<p>图中的<code>多重继承</code>会有被称为<code>”致命方块”（Deadly Diamond of Death）</code>的问题，而且Java也并不支持这种方式。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/DeadlyDiamondofDeath.PNG" alt="”致命方块”（Deadly Diamond of Death）"></p>
<p>·同名的实例变量和函数会导致冲突，带来更复杂的问题。</p>
<p>Java里使用<code>接口(interface)</code>来解决这一问题，接口把全部方法设为抽象的，所有子类都需要实现其方法。接口定义如下，使用<code>interface</code>代替<code>class</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pet</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>接口实现如下，使用关键字<code>implements</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Canine</span> <span class="keyword">implements</span> <span class="title">Pet</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实现某接口的类<code>必须实现它所有的方法</code>，因为这些方法都是<code>public</code>与<code>abstract</code>的。</p>
</blockquote>
<p>接口主要为<code>多态</code>服务，以接口取代具体的子类或抽象父类作为参数或返回值，<code>可以传入任何有实现该接口的东西</code>。此外，使用接口可以继承超过一个以上的来源。</p>
<blockquote>
<p>不同继承树的类也可以实现相同的接口</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceTreeInterface.PNG" alt="继承树中的接口"></p>
<p>用接口作为多态类型时，对象可以来自任何地方。唯一的条件是<strong>该对象必须是来自有实现此接口的类</strong>。类可以实现多个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Pet</span>, <span class="title">Saveable</span>, <span class="title">Paintable</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>可以把接口理解为<strong>类可以扮演的角色</strong>。</p>
<h4 id="2-2-Super的使用"><a href="#2-2-Super的使用" class="headerlink" title="2.2 Super的使用"></a>2.2 <code>Super</code>的使用</h4><p>如果子类不打算完全覆盖某个父类方法，又需要加入额外动作，可以使用<code>super</code>关键词来调用父类方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">runReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	<span class="comment">// set-up report </span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">printReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">// generic printing</span></span><br><span class="line"> 	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuzzwordsReport</span> <span class="keyword">extends</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">runReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.runReport();  <span class="comment">//调用父类方法</span></span><br><span class="line">		buzzwordCompliance();</span><br><span class="line">		printReport();</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">buzzwordCompliance</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/superClass.PNG" alt="superClass"></p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--13. Roman to Integer</title>
    <url>/2019/04/07/LeetCode--13-Roman-to-Integer.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br><a id="more"></a></p>
</blockquote>
<p>剩余部分略，描述与它前一道题<a href="http://wuyunjie.top/2019/04/03/LeetCode-12-Integer-to-Roman/" title="12. Integer to Roman">12. Integer to Roman</a>大致相同</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: “III”<br>Output: 3</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: “IV”<br>Output: 4</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: “IX”<br>Output: 9</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input: “LVIII”<br>Output: 58<br>Explanation: L = 50, V= 5, III = 3.</p>
</blockquote>
<p><strong>Example 5:</strong></p>
<blockquote>
<p>Input: “MCMXCIV”<br>Output: 1994<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题与它前一道题恰好相反，是从罗马数变成阿拉伯数字。细心观察可以发现，罗马数字一般都是大的数字在前面，如果存在某个较小的数字在某个较大的数字前——比如”IV”，那么他们表示的是一个数字4，即 V - I 。</p>
<p>利用这种特性，一开始思考，是否可以设置一个优先级，来判断某个数字应该比另一个优先出现。转念一想，他们的大小就已经代表优先级了，那么处理起来就很简单了：</p>
<blockquote>
<ol>
<li>若一个数比它下一个数优先级高，加入该数的值；</li>
<li>若一个数比它下一个数优先级低，减去该数的值。</li>
</ol>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; roToInt = &#123;</span><br><span class="line">            &#123;<span class="string">'I'</span>,<span class="number">1</span>&#125;, &#123;<span class="string">'V'</span>,<span class="number">5</span>&#125;, &#123;<span class="string">'X'</span>,<span class="number">10</span>&#125;, </span><br><span class="line">            &#123;<span class="string">'L'</span>,<span class="number">50</span>&#125;,&#123;<span class="string">'C'</span>,<span class="number">100</span>&#125;,&#123;<span class="string">'D'</span>,<span class="number">500</span>&#125;,&#123;<span class="string">'M'</span>,<span class="number">1000</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// int roToInt[256] = &#123;0&#125;;</span></span><br><span class="line">        <span class="comment">// roToInt['I']=1;roToInt['V']=5;roToInt['X']=10;</span></span><br><span class="line">        <span class="comment">// roToInt['L']=50;roToInt['C']=100;roToInt['D']=500;roToInt['M']=1000;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(roToInt[s[i]]&lt;roToInt[s[i+<span class="number">1</span>]])</span><br><span class="line">            &#123;</span><br><span class="line">                result-=roToInt[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result+=roToInt[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--15. 3Sum</title>
    <url>/2019/04/07/LeetCode--15-3Sum.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array <strong>nums</strong> of n integers, are there elements a, b, c in <strong>nums</strong> such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br><a id="more"></a></p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>The solution set must not contain duplicate triplets.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given array nums = [-1, 0, 1, 2, -1, -4],</p>
<p>A solution set is:<br>[<br> [-1, 0, 1],<br> [-1, -1, 2]<br>]</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这个题和第一题Two Sum有些类似，但是要比那道题复杂一些。它的结果不止一个，而且返回的结果里不能有重复的解，由于用向量保存解，可能同一个解有不同的排列方式，去重的话会很麻烦。需要想一种算法，在计算结果的同时，跳过重复解。所以这道题应该不是考察Two Sum的解法。</p>
<p>分析一下这道题的特点，要我们找出三个数且和为0，那么除了三个数全是0的情况之外，肯定会有负数和正数。我们可以先固定一个数a，然后去找另外两个数b和c，我们只要找到两个数且和(b+c)为第一个数a的相反数就行了。在寻找这两个数组合的过程中，我们肯定不希望遍历所有两个数的组合。最先想到的就是，对原数组先进行一个排序，然后遍历这个排序后的数组，寻找合适的解。主要过程大致如下：</p>
<blockquote>
<ol>
<li>设置low, high，分别从左边和右边向中间遍历数组:如果找到了 a+b+c=0，把结果放入答案集内;若a+b+c &lt; 0，则(b+c)过小，增大low；若a+b+c &gt; 0，则(b+c)过大，减小high</li>
<li>在遍历过程中，若两个数相同，在数组中一定是相邻的，可以跳过这些相同的数。</li>
<li>我们也可以先做个剪枝优化，就是当遍历到正数a的时候就break，因为我们的数组现在是有序的了，如果第一个要数a就是正数了，那么后面的数字b,c就都是正数，就永远不会出现和为0的情况了。</li>
</ol>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">2</span> || nums.front()&gt;<span class="number">0</span> || nums.back() &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>,high = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[low] + nums[high];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tuple = &#123;nums[i], nums[low], nums[high]&#125;;</span><br><span class="line">                    res.push_back(tuple);</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] == nums[++low] );</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] == nums[--high] );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) high--;</span><br><span class="line">                <span class="keyword">else</span> low++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--14. Longest Common Prefix</title>
    <url>/2019/04/07/LeetCode--14-Longest-Common-Prefix.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Write a function to find the longest common prefix string amongst an array of strings.<br><a id="more"></a><br>If there is no common prefix, return an empty string “”.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: [“flower”,”flow”,”flight”]<br>Output: “fl”</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: [“dog”,”racecar”,”car”]<br>Output: “”<br>Explanation: There is no common prefix among the input strings.</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>All given inputs are in lowercase letters <strong>a-z</strong>.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目很简单，求一组字符串的最长公共前缀。因为是公共前缀，所以必定所有字符串都包含这个前缀。想法是用一个字符串LCP保存已经比较过的字符串的公共前缀，然后逐个遍历修正这个公共前缀，最终就可以得到结果。</p>
<p>看了题解后，发现这种方法叫做水平扫描法，除了这种方法外，还有许多其他方法可以求解。</p>
<p>算法二： 垂直扫描法</p>
<blockquote>
<p>若数组末尾有一个非常短的字符串，使用水平扫描法依旧会进行S次比较，可以对其进行优化。即从前往后扫描字符串每一列，先判断每个字符串相同列上字符是否相同。</p>
</blockquote>
<p>算法三： 分治</p>
<blockquote>
<p>使用分治的技巧，将原问题 LCP(Si…Sj) 分成两个子问题 LCP(Si…Smid) 与 LCP(Smid+1…Sj)，其中mid = (i+j)/2.用子问题的解 lcpLeft 与 lcpRight 构造原问题的解 LCP(Si…Sj)。</p>
</blockquote>
<p><img src="https://leetcode-cn.com/media/original_images/14_lcp_diviso_et_lmpera.png" alt=""></p>
<p>算法四：</p>
<blockquote>
<p>还有一种解法，这种方法给输入字符串数组排了个序。按字母顺序排序的话，那么有共同字母多的两个字符串会被排到一起，而跟大家相同的字母越少的字符串会被挤到首尾两端，那么如果有共同前缀的话，一定会出现在首尾两端的字符串中，所以我们只需要找首尾字母串的共同前缀即可。<br>比如例子1排序后为 [“flight”, “flow”, “flower”]，例子2排序后为 [“car”, “dog”, “racecar”]，虽然例子2没有共同前缀，但也可以认为共同前缀是空串，且出现在首尾两端的字符串中。由于是按字母顺序排的，而不是按长度，所以首尾字母的长度关系不知道，为了防止溢出错误，我们只遍历而这种较短的那个的长度，找出共同前缀返回即可。</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="水平扫描"><a href="#水平扫描" class="headerlink" title="水平扫描"></a>水平扫描</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> lcp = strs[<span class="number">0</span>]; <span class="comment">//初始化公共前缀</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逐个遍历，不断修正</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; strs.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j &lt; lcp.length() &amp;&amp; j &lt; strs[i].length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lcp[j] != strs[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            lcp = lcp.substr(<span class="number">0</span>,j);</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="垂直扫描"><a href="#垂直扫描" class="headerlink" title="垂直扫描"></a>垂直扫描</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> lcp = strs[<span class="number">0</span>]; <span class="comment">//初始化公共前缀</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逐个遍历，不断修正</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lcp.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; strs.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == strs[j].size() || strs[j][i] != lcp[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> lcp.substr(<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">commomPredix</span><span class="params">(<span class="built_in">string</span> left, <span class="built_in">string</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; left.length() &amp;&amp; i &lt; right.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left[i] != right[i]) <span class="keyword">return</span> left.substr(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.substr(<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LCP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">string</span> leftLCP = LCP(strs, l, mid);</span><br><span class="line">            <span class="built_in">string</span> rightLCP = LCP(strs, mid+<span class="number">1</span>, r);</span><br><span class="line">            <span class="keyword">return</span> commomPredix(leftLCP,rightLCP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> LCP(strs, <span class="number">0</span>, strs.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="算法四"><a href="#算法四" class="headerlink" title="算法四"></a>算法四</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        sort(strs.begin(), strs.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = min(strs[<span class="number">0</span>].size(), strs.back().size());</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; strs[<span class="number">0</span>][i] == strs.back()[i]) ++i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--17. Letter Combinations of a Phone Number</title>
    <url>/2019/04/10/LeetCode--17-Letter-Combinations-of-a-Phone-Number.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.<br><a id="more"></a><br>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p>
<p><strong>Example :</strong></p>
<blockquote>
<p>Input: “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目让模拟手机9键的键盘，给定一个数字字符串(代表按键顺序)，给出可能的所有字母组合。简单理解，就是求每个数字所代表的字符集合的笛卡尔积，找出所有可能的情况。</p>
<p>想法是先在一个vector数组内放入一个空字符””。之后扫描字符串，每次识别到一个数字，就将这个数字所对应的字符分别与vector数组内的字符串连接加入数组，然后删去连接前的旧字符串，继续下一次扫描。当扫描完数字字符串时，就可以成功得到结果了。除此之外还有其他方法：</p>
<blockquote>
<p><strong>回溯法(Backtracking)</strong><br>回溯法是寻找所有可能的候选结果的一种算法。定义一个回溯函数<code>backtrack(combination, next_digits)</code>，生成结果并逐个字符检查。</p>
<ul>
<li>若已经没有digits需要继续处理，说明结果已经成功生成，存入结果集。</li>
<li>如果仍然有还未检查的digits字符，继续处理该字符：<ul>
<li>将该字符代表的字母加入当前生成的结果 <code>combination = combination + letter</code></li>
<li>继续处理剩余的字符：<code>backtrack(combination + letter, next_digits[1:])</code></li>
</ul>
</li>
</ul>
</blockquote>
<p><a href="https://imgchr.com/i/AT0u8J" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/10/AT0u8J.png" alt="AT0u8J.png"></a></p>
<blockquote>
<p>这是一种递归迭代的方法。方法思想差不多，只是这种方法用递归实现。</p>
<p>其中还可以继续优化的是，可以不使用unordered_map，直接用一个一维string数组来存储mapping数组。</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; mapping = &#123;</span><br><span class="line">        &#123;<span class="string">'1'</span>,<span class="string">""</span>&#125;, &#123;<span class="string">'2'</span>,<span class="string">"abc"</span>&#125;,&#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,&#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;, &#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,&#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(<span class="number">1</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; digits.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res_length = res.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mapping[digits[i]].length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; res_length;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(res[k]+mapping[digits[i]][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.erase(res.begin(),res.begin()+res_length);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; mapping = &#123;</span><br><span class="line">        &#123;<span class="string">'1'</span>,<span class="string">""</span>&#125;, &#123;<span class="string">'2'</span>,<span class="string">"abc"</span>&#125;,&#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,&#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;, &#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,&#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">string</span> combination, <span class="built_in">string</span> digits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(combination);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> letters = mapping[digits[<span class="number">0</span>]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;letters.length();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                backtrack(combination+letters[i], digits.substr(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() != <span class="number">0</span>) </span><br><span class="line">            backtrack(<span class="string">""</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法三-不使用unordered-map"><a href="#方法三-不使用unordered-map" class="headerlink" title="方法三(不使用unordered_map)"></a>方法三(不使用unordered_map)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> mapping[<span class="number">10</span>] = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(<span class="number">1</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; digits.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res_length = res.size();</span><br><span class="line">            <span class="built_in">string</span> letters = mapping[digits[i]-<span class="string">'0'</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; letters.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; res_length;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(res[k]+letters[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.erase(res.begin(),res.begin()+res_length);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--18. 4Sum</title>
    <url>/2019/04/10/LeetCode--18-4Sum.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array <code>nums</code> of n integers and an integer <code>target</code>, are there elements a, b, c, and d in <code>nums</code> such that a + b + c + d = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.<br><a id="more"></a></p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>The solution set must not contain duplicate quadruplets.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</p>
<p>A solution set is:<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题和前面几道关于数字之和的题应该是同一个系列(<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%941-Two-Sum/" title="Two Sum">Two Sum</a>，<a href="http://wuyunjie.top/2019/04/07/LeetCode-15-3Sum/" title="3Sum">3Sum</a>，<a href="http://wuyunjie.top/2019/04/09/LeetCode-16-3Sum-Closest/" title="3Sum Closest">3Sum Closest</a>)。尽管难度有所提升，但是解题的思想和算法实际上都一致，其实也就是多了层循环。比如四个数a,b,c,d，我们可以先固定数a，然后寻找b,c,d，这就转换成了三数和的问题。</p>
<p>现在遇到了许多类似的问题，而且可以看出他们的解决方法具有一定规律，可以进行拓展。那么是不是可以找到一种泛化的方法计算KSUM，使得我们以后遇到5sum, 6sum…等等类似的问题时，不必再去重写这些算法，只用一个泛化的算法就可以搞定这一些。翻看评论区后，发现已经有人实现了这样的算法，主要是通过递归DFS实现的。每次先固定一个数，然后递归找到K-1SUM的结果。依次类推，直到找到2SUM返回最终结果，开始回溯。代码实现如下。</p>
<p>参考文献：<br><a href="https://leetcode.com/problems/4sum/discuss/8641/12ms-KSum-c%2B%2B-code" target="_blank" rel="noopener" title="12ms KSum, c++ code">[1] 12ms KSum, c++ code</a><br><a href="https://leetcode.com/problems/4sum/discuss/163559/C%2B%2B-solution-for-all-Ksum-question" target="_blank" rel="noopener" title="[1] C++ solution for all Ksum question">[2] C++ solution for all Ksum question</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="4SUM"><a href="#4SUM" class="headerlink" title="4SUM"></a>4SUM</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">3</span> || (nums.front() &gt; target &amp;&amp; nums.front() &gt; <span class="number">0</span>) || (nums.back() &lt; target &amp;&amp; nums.back() &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[n<span class="number">-3</span>]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>]&lt;target) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> tmp_target = target - nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n <span class="number">-2</span>  ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[j+<span class="number">1</span>]+nums[j+<span class="number">2</span>]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>]&lt;target) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> low = j+<span class="number">1</span>,high = n<span class="number">-1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>( low &lt; high)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[j] + nums[low] + nums[high];</span><br><span class="line">                    <span class="keyword">if</span>(sum == tmp_target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tuple = &#123;nums[i], nums[j], nums[low], nums[high]&#125;;</span><br><span class="line">                        res.push_back(tuple);</span><br><span class="line">                        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] == nums[++low] );</span><br><span class="line">                        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] == nums[--high] );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; tmp_target) high--;</span><br><span class="line">                    <span class="keyword">else</span> low++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="KSUM"><a href="#KSUM" class="headerlink" title="KSUM"></a>KSUM</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Valid for K &gt;= 2</span></span><br><span class="line">    <span class="comment">// k表示求ksum,nums是目标数组,l,r分别是左右游标</span></span><br><span class="line">    <span class="comment">// target是当前目标数, retVal是最终结果, cur是当前阶段的中间结果</span></span><br><span class="line">    <span class="comment">// ci表示当前是正在求第ci个数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">KSum</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; retVal, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="keyword">int</span> ci )</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mn, mx; <span class="comment">//mn表示当前最小的数，mx表示当前最大的数</span></span><br><span class="line">        <span class="keyword">int</span> km1 = k - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( r-l+<span class="number">1</span> &lt; k ) <span class="keyword">return</span>; <span class="comment">//若剩余的数比K小，已经无法找到结果，结束递归</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ( l &lt; r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新当前最小数和最大数</span></span><br><span class="line">            mn = nums[l];</span><br><span class="line">            mx = nums[r];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 若mn + (k-1)*mx &lt; target，mn太小，l右移</span></span><br><span class="line">            <span class="keyword">if</span> ( ( mn + km1*mx ) &lt; target ) l++;</span><br><span class="line">            <span class="comment">// 若(k-1)*mn + mx &gt; target，mx太大，r左移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( ( km1*mn + mx ) &gt; target ) r--;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// K=2,直接求出最终结果，其中包括去重操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( k == <span class="number">2</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                cur[ci] = mn;</span><br><span class="line">                cur[ci+<span class="number">1</span>] = mx;</span><br><span class="line">                retVal.push_back( cur );</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">while</span> ( ( l &lt; r ) &amp;&amp; ( nums[l] == mn ) ) l++;</span><br><span class="line">                r--;</span><br><span class="line">                <span class="keyword">while</span> ( ( l &lt; r ) &amp;&amp; ( nums[r] == mx ) ) r--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否者，递归转化为k-1 Sum的问题，递归求解</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur[ci] = mn; <span class="comment">//记录下当前可能的第ci个数</span></span><br><span class="line">                <span class="comment">//递归求解k-1 Sum</span></span><br><span class="line">                KSum( km1, nums, ++l, r, target - mn, retVal, cur, ci+<span class="number">1</span> );</span><br><span class="line">                <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">while</span> ( ( l &lt; r ) &amp;&amp; ( nums[l] == nums[l<span class="number">-1</span>] ) ) l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; RetVal;</span><br><span class="line">        <span class="comment">//初始化中间结果向量</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序，用于后面去重</span></span><br><span class="line">        sort( nums.begin(), nums.end() );</span><br><span class="line">        </span><br><span class="line">        KSum( <span class="number">4</span>, nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>, target, RetVal, cur, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RetVal;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--2. Add Two Numbers</title>
    <url>/2019/03/28/LeetCode--2-Add-Two-Numbers.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br><a id="more"></a><br>You may assume the two numbers do not contain any leading zero, except the number 0 itself. </p>
</blockquote>
<p><strong>Example:</strong></p>
<blockquote>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目意思即，两个数是用链表按逆序存储的，现在要求两个数的和。实现算法思想即，模拟一个加法器，按位(这里即每一个链表结点)相加，需要设置一个进位标志位。这里只需要注意几种特殊情况即可：<br>1.两个数不一样长时，需要额外处理；<br>2.如果最终计算结果超过两个数的长度时，需要多增加一位。<br>在实现过程中，用一个新的链表来存储计算结果。<br>在查看讨论区后，发现算法思路大致相同，但是别人的代码更加精简，可以从中借鉴代码的一些简化方法和思想</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li>解法1</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> CF=<span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>; <span class="comment">//每位计算的中间结果</span></span><br><span class="line">        ListNode* result=<span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//新链表存储结果，头结点</span></span><br><span class="line">        ListNode* present=result; <span class="comment">//结果链表当前节点</span></span><br><span class="line">        <span class="comment">//两个数都有节点还未计算是，循环按位计算</span></span><br><span class="line">		<span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//加法结果</span></span><br><span class="line">            tmp=(l1-&gt;val+l2-&gt;val+CF)%<span class="number">10</span>;</span><br><span class="line">            present-&gt;val=tmp;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//进位</span></span><br><span class="line">            CF=(l1-&gt;val+l2-&gt;val+CF)/<span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//链表指针后移</span></span><br><span class="line">			l1=l1-&gt;next;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//如果其中一个数已经加完，不再new新节点</span></span><br><span class="line">            <span class="keyword">if</span>(l1&amp;&amp;l2)</span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                present=present-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//若其中一个数未加完，即比另外一个数要长，需要结合进位进一步处理</span></span><br><span class="line">		<span class="comment">//两个数的处理方式相同</span></span><br><span class="line">        <span class="keyword">while</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//有进位，需要加上进位继续处理</span></span><br><span class="line">            <span class="keyword">if</span>(CF==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                present=present-&gt;next;</span><br><span class="line"></span><br><span class="line">                tmp=(l1-&gt;val+CF)%<span class="number">10</span>;</span><br><span class="line">                present-&gt;val=tmp;</span><br><span class="line"></span><br><span class="line">                CF=(l1-&gt;val+CF)/<span class="number">10</span>;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//若已经没进位，计算结果后面的数与该数剩下的数相同</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=l1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(CF==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                present=present-&gt;next;</span><br><span class="line"></span><br><span class="line">                tmp=(l2-&gt;val+CF)%<span class="number">10</span>;</span><br><span class="line">                present-&gt;val=tmp;</span><br><span class="line"></span><br><span class="line">                CF=(l2-&gt;val+CF)/<span class="number">10</span>;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=l2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果两个数都加完了，还有进位，那么new一个新节点，保存该进位</span></span><br><span class="line">        <span class="keyword">if</span>(CF==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>精简的解法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode preHead(0), *p = &amp;preHead;</span><br><span class="line">        <span class="keyword">int</span> extra = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || extra) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + extra;</span><br><span class="line">            extra = sum / <span class="number">10</span>;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--16. 3Sum Closest</title>
    <url>/2019/04/09/LeetCode--16-3Sum-Closest.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array <strong>nums</strong> of n integers and an integer <strong>target</strong>, find three integers in <strong>nums</strong> such that the sum is closest to <strong>target</strong>. Return the sum of the three integers. You may assume that each input would have exactly one solution.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given array nums = [-1, 2, 1, -4], and target = 1.</p>
<p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这个题和它的前一道题<a href="http://wuyunjie.top/2019/04/07/LeetCode-15-3Sum/" title="15. 3Sum">15. 3Sum</a>很像，前一道题可以看做本题在target = 0时的特殊情况。但这道题进行了一定的改写和简化：</p>
<blockquote>
<ol>
<li>存在且仅存在一个解，所以我们可以在找到一个最优解后立即停止;</li>
<li>要寻找的是最接近target的三数和。也就是说可能会没有等于target的情况，比如题目的例子就是如此；另一方面只需要返回这三个数的和，不需要记录这三个数，所以对结果的记录和判断简化了。</li>
</ol>
</blockquote>
<p>我们只需要在15题的算法的基础上进行一定的修改就可以得到这道题的结果了。我们可以用同样的方法，先对数组进行排序，固定一个数a，然后去找另外两个数b和c的组合：</p>
<ol>
<li>如果我们只要找到两个数且和(b+c)为(target - a)，那么找到了最接近的三数和即target;</li>
<li>否者我们记录下当前数以及与target的距离(定义为|target-(a+b+c)|)，继续遍历数组找下一个更相近的三数和。</li>
</ol>
<p>同样的，在寻找过程中，我们可以跳过那些重复的组合，并且进行合适的剪枝进行优化。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> closesetDistance = <span class="built_in">abs</span>(nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[nums.size()<span class="number">-1</span>] - target);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>,high = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[low] + nums[high];</span><br><span class="line">                <span class="keyword">if</span>(sum == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(sum-target &lt; closesetDistance)</span><br><span class="line">                    &#123;</span><br><span class="line">                        closesetDistance = sum-target;</span><br><span class="line">                        res = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] == nums[--high]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target-sum &lt; closesetDistance)</span><br><span class="line">                    &#123;</span><br><span class="line">                        closesetDistance = target-sum;</span><br><span class="line">                        res = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] == nums[++low]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--20. Valid Parentheses</title>
    <url>/2019/04/14/LeetCode--20-Valid-Parentheses.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.<br><a id="more"></a><br>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: “()”<br>Output: true</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: “()[]{}”<br>Output: true</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: “(]”<br>Output: false</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input: “([)]”<br>Output: false</p>
</blockquote>
<p><strong>Example 5:</strong></p>
<blockquote>
<p>Input: “{[]}”<br>Output: true</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题很经典，也就是让我们判断给定的括号字符串是不是合法的，考察的应该是栈的运用。通过栈就可以很容易的解决问题，遍历字符串：</p>
<blockquote>
<ol>
<li>若遍历到是左括号<code>&#39;(&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;[&#39;</code>，将其推入栈中；</li>
<li>若遇到的是右括号，在栈顶找是否有匹配的左括号：若匹配成功，将栈顶弹出，继续遍历；若匹配失败，代表括号不合法，返回false.</li>
<li>遍历完字符串后，检查栈是否为空，若不空，代表不合法。</li>
</ol>
</blockquote>
<p>评论区有一种不使用stack的解法，它是直接在原字符串上模拟一个栈，保证只有左括号在栈内。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="使用stack"><a href="#使用stack" class="headerlink" title="使用stack"></a>使用stack</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; brackets;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'('</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        brackets.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">                    <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'&#123;'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        brackets.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">                    <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'['</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        brackets.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    brackets.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(brackets.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不使用stack"><a href="#不使用stack" class="headerlink" title="不使用stack"></a>不使用stack</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(top&lt;<span class="number">0</span> || !isMatch(s[top], s[i]))&#123;</span><br><span class="line">                ++top;</span><br><span class="line">                s[top] = s[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                --top;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">'('</span> &amp;&amp; c2 == <span class="string">')'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">'['</span> &amp;&amp; c2 == <span class="string">']'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">'&#123;'</span> &amp;&amp; c2 == <span class="string">'&#125;'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--21. Merge Two Sorted Lists</title>
    <url>/2019/04/14/LeetCode--21-Merge-Two-Sorted-Lists.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.<br><a id="more"></a><br>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>要求合并两个有序链表，新链表是由两个链表结点拼接得到，考察的是对链表的操作。思想是，每次从两个链表上取下一个结点，比较值的大小，较小的结点拼接到新链表后，较大的结点继续进行下一次比较。</p>
<p>这里需要注意的是链表边界的处理，比如对链表头结点的处理方式。可以先单独处理两个链表头结点，确定下新链表的头结点后，再继续继续下面的处理。也可以重新定义一个新的头结点，把链表结点都当做普通结点处理。最后可能有一个链表还有剩余的结点，直接将这些结点拼接到新链表末尾即可。</p>
<p>还可以使用递归的方式求解，但是递归的缺点是，若链表过长，可能会溢出。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> || l2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1 == <span class="literal">NULL</span>? l2 : l1;</span><br><span class="line">        </span><br><span class="line">        ListNode* resHead = l1-&gt;val &lt; l2-&gt;val?l1 : l2;</span><br><span class="line">        ListNode* cur = resHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val) l1=l1-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> l2=l2-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;next = l1==<span class="literal">NULL</span>?l2:l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> resHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义新的头结点dummy"><a href="#定义新的头结点dummy" class="headerlink" title="定义新的头结点dummy"></a>定义新的头结点dummy</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> || l2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1 == <span class="literal">NULL</span>? l2 : l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l2-&gt;next, l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--19. Remove Nth Node From End of List</title>
    <url>/2019/04/11/LeetCode--19-Remove-Nth-Node-From-End-of-List.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a linked list, remove the n-th node from the end of list and return its head.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<p>Given n will always be valid.</p>
</blockquote>
<p><strong>Follow up :</strong></p>
<blockquote>
<p>Could you do this in one pass?</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目要求我们找到并删除链表的倒数第n个数。由于链表不支持随机访问，并且链表长度也不容易求，所以题目看似会很麻烦。但是以前经常会碰到这样的问题，比如求链表中间位置的数等等，对这类题目有过一定了解。其实很简单，只需要用两个指针就可实现一次扫描得到结果。</p>
<blockquote>
<p>首先第一个指针end先前进n，到达第n个结点后，第二个结点pre开始前进遍历；<br>两个指针end和pre同步前进，他们之间的距离是n，当end到达链表尾部时，pre指向的就是倒数第n个结点。<br>此时我们可以继续操作，进行要求的插入，删除等等。</p>
</blockquote>
<p>在寻找链表中点时，可以使用同样的方法。使用两个指针end,mid，两个指针同时前进，但此时，mid每前进一步，end会前进两步。那么当end到达终点时，mid恰好走过一半的结点，也就找到了链表的中点。</p>
<p>当然还有一种暴力解法，就是先计算出链表的长度L，然后找到第(L-n)个结点，把第 (L−n) 个结点的 next 指针重新链接至第 (L−n+2) 个结点。同样可以完成该算法。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *end = head;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) end = end-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(end == <span class="literal">NULL</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(end-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            end = end-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *count = head;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L++;</span><br><span class="line">            count=count-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> Lmn = L - n;</span><br><span class="line">        <span class="keyword">if</span>(Lmn == <span class="number">0</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Lmn<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode *temp = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--24. Swap Nodes in Pairs</title>
    <url>/2019/04/16/LeetCode--24-Swap-Nodes-in-Pairs.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.<br><a id="more"></a><br>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>要求交换链表中相邻两个结点的位置，并且要求不能修改结点的值，也就是只能将结点整个交换过去。我的思路很简单，从链表上依次“摘下”两个结点，交换其位置后再将得到的结果拼接回链表，题目并不难，主要是对链表的操作。可以按下面的图来表示(图参考自<a href="https://leetcode.com/problems/swap-nodes-in-pairs/discuss/11183/C%2B%2B-solution-with-graph-explanation." target="_blank" rel="noopener" title="C++ solution with graph explanation.">C++ solution with graph explanation.</a>)<br>/*</p>
<pre><code>   node1 = pre-&gt;next;node2 = node1-&gt;next
   #----&gt;@----&gt;@----&gt;@----&gt;@----&gt;@----&gt;@
               ^     ^     ^
               pre   node1 node2

  1. pre-&gt;next = node2
                __________
               /          \
   #----&gt;@----&gt;@     @----&gt;@----&gt;@----&gt;@
               ^     ^     ^
               pre   node1 node2

  2. node1-&gt;next = node2-&gt;next
                __________
               /          \
   #----&gt;@----&gt;@     @     @----&gt;@----&gt;@
                      \_________/
               ^     ^     ^
               pre   node1 node2

  3. node2-&gt;next = node1
               __________
              /          \
  #----&gt;@----&gt;@     @&lt;----@     @----&gt;@
                     \_________/
              ^     ^     ^
              pre   node1 node2

  4. pre = node1;
               __________
              /          \
  #----&gt;@----&gt;@     @&lt;----@     @----&gt;@
                     \_________/
                    ^
                    pre
</code></pre><p> */</p>
<p>同样的思想也可以用递归来实现</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode *pre = &amp;dummy;</span><br><span class="line">        ListNode *node1,*node2;</span><br><span class="line">        <span class="keyword">while</span>(pre)</span><br><span class="line">        &#123;</span><br><span class="line">            node1 = pre-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(node1&amp;&amp;node1-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                node2 = node1-&gt;next;</span><br><span class="line">                pre-&gt;next = node2;</span><br><span class="line">                node1-&gt;next = node2-&gt;next;</span><br><span class="line">                node2-&gt;next = node1;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !(head-&gt;next))</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *res = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(res-&gt;next);</span><br><span class="line">        res-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--25. Reverse Nodes in k-Group</title>
    <url>/2019/04/16/LeetCode--25-Reverse-Nodes-in-k-Group.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.<br><a id="more"></a><br>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
</blockquote>
<p><strong>Note :</strong></p>
<ul>
<li>Only constant extra memory is allowed.</li>
<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>
</ul>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题又是对上一题的推广，leetcode这种由简入难的题挺多的。这次是要求对链表的K个结点反转，这里的K可以是任意的。我们可以依旧按照上一题的那种方式，将链表分为若干段：每次从链表上“摘下”k个结点的链表，把这个链表进行反转后，再放回原来的位置。对于链表的反转操作，我们可以利用构建链表时用的头插法来进行。这里在解决时碰到几个问题：</p>
<blockquote>
<ol>
<li>若剩下链表长度不够K时，我们不需要对这段链表进行反转，所以我们需要提前计算出链表的长度</li>
<li>需要记录下反转后的最后一个结点，用于在放回原链表时，可以和下一段连接起来。</li>
</ol>
</blockquote>
<p>还有一种方法，实现如下，这种方法思想上大致相同，这种方法不用单独计算链表长度，而是边计算长度边处理链表，每当数到k个结点时就反转一次。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.next = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* count = head;</span><br><span class="line">        <span class="keyword">int</span> Len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count)</span><br><span class="line">        &#123;</span><br><span class="line">            count=count-&gt;next;</span><br><span class="line">            Len++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* pre = &amp;dummy;</span><br><span class="line">        ListNode* last = head;</span><br><span class="line">        ListNode* temp = last;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        <span class="keyword">while</span>(Len &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//下一个待取的结点</span></span><br><span class="line">                next = temp-&gt;next;</span><br><span class="line">                <span class="comment">//插入头部</span></span><br><span class="line">                temp-&gt;next = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = temp;</span><br><span class="line">                temp = next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = last;last=next;</span><br><span class="line">            Len-=k;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = last;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *pre = dummy, *cur = head;</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; cur; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % k == <span class="number">0</span>) &#123;</span><br><span class="line">                pre = reverseOneGroup(pre, cur-&gt;next);</span><br><span class="line">                cur = pre-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseOneGroup</span><span class="params">(ListNode* pre, ListNode* next)</span> </span>&#123;</span><br><span class="line">        ListNode *last = pre-&gt;next, *cur = last-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur != next) &#123;</span><br><span class="line">            last-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            cur = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--26. Remove Duplicates from Sorted Array</title>
    <url>/2019/04/17/LeetCode--26-Remove-Duplicates-from-Sorted-Array.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a sorted array nums, remove the duplicates <strong>in-place</strong> such that each element appear only once and return the new length.<br><a id="more"></a><br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Given nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p>
<p>It doesn’t matter what you leave beyond the returned length.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Given nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</p>
<p>It doesn’t matter what values are set beyond the returned length.</p>
</blockquote>
<p><strong>Clarification :</strong></p>
<blockquote>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题要求去除数字中的冗余项，而且只能使用O(1)的空间复杂度。看题目说明得知，我们返回的是处理后数组的长度，我们只需要保证数组前面有效部分的值，至于超出有效部分的值我们无需关心。</p>
<p>那么就可以很好处理，我们继续下当前最后一个有效位的位置，等到下一次遇到不重复的数时，将该数字移动到下一个有效位，然后更新有效位继续扫描数组。当完成一遍扫描后，所有不重复的值都移动到了数组的前端有效部分。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[last<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[last] = nums[i];</span><br><span class="line">                last++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--28. Implement strStr()</title>
    <url>/2019/04/17/LeetCode--28-Implement-strStr.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Implement strStr().<br><a id="more"></a><br>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: haystack = “hello”, needle = “ll”<br>Output: 2</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: haystack = “aaaaa”, needle = “bba”<br>Output: -1</p>
</blockquote>
<p><strong>Clarification :</strong></p>
<blockquote>
<p>What should we return when needle is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这个题要求实现strStr()函数。实际上就是个字符串匹配过程，要求从haystack中寻找子串needle，若找到，返回子串开始位置；否知返回-1.</p>
<p>想到的有两种解法，一种是直接暴力求解，另一种是用KMP算法。</p>
<p>首先实现了暴力求解的算法。将haystack所有与needle一样长的子串进行比较，若成功找到，就返回当前子串其实位置；若最终未找到，返回-1.这种方法实现后，发现效果还算不错，没有想象的那么差。</p>
<p>之后实现了KMP算法，KMP算法可以利用next数组加速匹配过程。</p>
<blockquote>
<p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p>
<ul>
<li>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</li>
<li>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值.</li>
</ul>
</blockquote>
<p>这里重点是构造next数组，next数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next[j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀。</p>
<p>参考文献：<br>[1] <a href="https://www.cnblogs.com/yjiyjige/p/3263858.html" target="_blank" rel="noopener">（原创）详解KMP算法</a><br>[2] <a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" target="_blank" rel="noopener">很详尽KMP算法</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="暴力算法1"><a href="#暴力算法1" class="headerlink" title="暴力算法1"></a>暴力算法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.size(), n = needle.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m - n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="暴力算法2"><a href="#暴力算法2" class="headerlink" title="暴力算法2"></a>暴力算法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.size(), n = needle.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m - n; i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> substr = haystack.substr(i, n);</span><br><span class="line">            <span class="keyword">if</span> (substr == needle) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_KMP_Next(<span class="built_in">string</span> s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(s.length());</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>, k=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; s.length()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">-1</span> || s[j] == s[k])</span><br><span class="line">            &#123;</span><br><span class="line">                next[++j] = ++k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.length(), n = needle.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = get_KMP_Next(needle);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || haystack[i] == needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j == needle.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--27. Remove Element</title>
    <url>/2019/04/17/LeetCode--27-Remove-Element.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array <strong>nums</strong> and a value <strong>val</strong>, remove all instances of that value in-place and return the new length.<br><a id="more"></a><br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Given nums = [3,2,2,3], val = 3,</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p>It doesn’t matter what you leave beyond the returned length.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Given nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<p>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</p>
<p>Note that the order of those five elements can be arbitrary.</p>
<p>It doesn’t matter what values are set beyond the returned length.</p>
</blockquote>
<p><strong>Clarification :</strong></p>
<blockquote>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题与上一题类似，不够这次要求删除数组中指定的值。思想还是一样的：</p>
<blockquote>
<p>设置一个有效位last，遍历数组，遇到不等于val的值，就将它移动到last+1，然后更新last<br>当遍历完数组后，不等于val的值就都移动到了数组前端有效部分。</p>
</blockquote>
<p>但是这样会移动大量的元素，考虑是不是可以只移动值等于val的元素，由于数组的顺序可以改变，那么我们可以:</p>
<blockquote>
<p>将等于val的元素与最后一个值不等于val的元素交换</p>
</blockquote>
<p>这样当遍历完成后，所有等于val的值都被移动到了数组末尾无效部分。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=val)    nums[last++]=nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解2"><a href="#解2" class="headerlink" title="解2"></a>解2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, end=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = nums[end--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--22. Generate Parentheses</title>
    <url>/2019/04/14/LeetCode--22-Generate-Parentheses.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.<br><a id="more"></a><br>For example, given n = 3, a solution set is:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &quot;((()))&quot;,</span><br><span class="line">    &quot;(()())&quot;,</span><br><span class="line">    &quot;(())()&quot;,</span><br><span class="line">    &quot;()(())&quot;,</span><br><span class="line">    &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>以前做过类似的题，也就是求一组数字可以通过栈得到的所有合法排序。当时的做法是，先求出所有可能的排序，然后判断每一种排序的合法性。获取全排序可以通过函数next_permutation()做到：</p>
<blockquote>
<p>C++ STL中提供了std::next_permutation与std::prev_permutation可以获取数字或者是字符的全排列，其中std::next_permutation提供升序、std::prev_permutation提供降序。</p>
</blockquote>
<p>所以结合前面有一题判断括号是否有效。最开始的想法是将括号全排序后，找到有效的括号排列，放入结果集。遍历完所有可能后，就可以找到最终的结果了。</p>
<p>但是这种方法效率很低。另一种方法是，使用递归回溯，每次生成合法的括号序列加入结果集中，这种方法避免了生成无效排序。</p>
<blockquote>
<p>长度为 n 的序列就是 ‘(‘ 加上所有长度为 n-1 的序列，以及 ‘)’ 加上所有长度为 n-1 的序列。只有在保证序列仍然保持有效时才添加 ‘(‘ or ‘)’，我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号。</p>
</blockquote>
<p>还有一种方法，LeetCode上称之为Closure number，但感觉很像分治。我们可以把一个合法的括号字符串看做一个闭包，它必然起于左括号止于右括号，且每个合法括号串都可以从某个位置分为两个同样合法的括号串（包括空串），因此对于给定的n所可能构造的所有括号串都可以一步步划分为两个子闭包并解构（去掉头尾的一对左右括号）直到最小闭包——空串为止。基于以上分析，我们就可以从空串开始逆向一步步对两个子闭包之一构造新的闭包（在头尾各添加一个左/右括号）然后合并。这种方法还不是特别懂，只是跟着算法用c++重写了一遍。</p>
<p>参考文献：<br>[1] <a href="https://www.cnblogs.com/aiguona/p/7304945.html" target="_blank" rel="noopener" title="C++ STL 全排列函数详解">C++ STL 全排列函数详解</a><br>[2] <a href="https://blog.csdn.net/weixin_34216107/article/details/86906251" target="_blank" rel="noopener" title="LeetCode Record C++">LeetCode Record C++</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="全排序后筛选"><a href="#全排序后筛选" class="headerlink" title="全排序后筛选"></a>全排序后筛选</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; brackets;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    brackets.pop();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> brackets.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(brackets.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> parentheses = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) parentheses+=<span class="string">"()"</span>;</span><br><span class="line">        </span><br><span class="line">        sort(parentheses.begin(), parentheses.end());</span><br><span class="line">        result.push_back(parentheses);</span><br><span class="line">        <span class="keyword">while</span>(next_permutation(parentheses.begin(), parentheses.end()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(parentheses)) result.push_back(parentheses);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result, <span class="built_in">string</span> cur, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.length() == max*<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(open &lt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrack(result, cur+<span class="string">"("</span>, open+<span class="number">1</span>, close, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(close &lt; open)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrack(result, cur+<span class="string">")"</span>, open, close+<span class="number">1</span>, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        backtrack(result, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="闭包数"><a href="#闭包数" class="headerlink" title="闭包数"></a>闭包数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> left:generateParenthesis(c))</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> right:generateParenthesis(n<span class="number">-1</span>-c))</span><br><span class="line">                        result.push_back(<span class="string">"("</span>+left+<span class="string">")"</span>+right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--3. Longest Substring Without Repeating Characters</title>
    <url>/2019/03/28/LeetCode--3-Longest-Substring-Without-Repeating-Characters.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3. </p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>Input: “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</p>
</blockquote>
<p><strong>Example3:</strong></p>
<blockquote>
<p>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3. </p>
<ul>
<li>Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</li>
</ul>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目要求的是，最长不含重复元素的字串。<br>最开始的想法是，用一个向量数组，存储以每一个位置为终点，包含该位置字符在内的最长不含重复元素的字串的长度，相当于一个dp的算法。数组更新方式是：用一个二重循环，外循环是从第一个字符到最后一个字符一次遍历；内循环用于判断，以该位置字符为终点，可以得到的最长不重复字串有多长。该算法成功解决了问题。<br>后来继续分析程序，发现可以不使用向量数组，因为数组内的每一个元素的值只需要访问一次，直接用一个变量保存即可。用此方法改进后，速度和空间都得到了优化。</p>
<blockquote>
<p>讨论区有另外一种更优化的解法，代码中用vector生成256个-1，用来存储每个字符上一次出现的下标。代码比较抽象，理解如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v(<span class="number">256</span>,<span class="number">-1</span>); <span class="comment">//构造字符串的容器。初始化为-1，意思是暂时不存在这个字符。</span></span><br><span class="line">start=<span class="number">-1</span>; <span class="comment">//start用来记录子串开始的位置，初始化为-1，表示没有开始构造子字符串。</span></span><br><span class="line"><span class="keyword">if</span>(v[s[i]]&gt;start)<span class="comment">//已经在该字符出现之前出现过相同的字符了，那么就将start也就是开始位置标记为上次该字符的出现位置。</span></span><br><span class="line">	start=v[s[i]]; </span><br><span class="line">v[s[i]]=i; <span class="comment">//更新字符在容器中对应的下标</span></span><br><span class="line">ans=max(ans,i-start); <span class="comment">//i-start的意思是，当前for循环的i（也就是子字符串的结束字符）减去子字符串结束的字符的下标位置，结果就是子字符串的长度。</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li>解法1(使用了向量数组)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="comment">//空字符串，直接返回0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>; <span class="comment">//非空字符串，最短为1</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; longestsub; <span class="comment">//每个位置的最长不重复字串长度</span></span><br><span class="line">        longestsub.push_back(<span class="number">1</span>); <span class="comment">//初始化第一个位置</span></span><br><span class="line">		<span class="comment">//遍历每一个位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            longestsub.push_back(<span class="number">1</span>);</span><br><span class="line">			<span class="comment">//从上一个位置的最长不重复字串为起点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-longestsub[i<span class="number">-1</span>];j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">//没有重复，继续计算</span></span><br><span class="line">                <span class="keyword">if</span>(s[j]!=s[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    longestsub[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//有重复，从1开始重新计数</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    longestsub[i]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//记录最长长度</span></span><br><span class="line">            <span class="keyword">if</span>(longestsub[i]&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                max=longestsub[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>不使用数组</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> Longest=<span class="number">1</span>,Last=<span class="number">1</span>;<span class="comment">//记录最长长度和上一字符的最长不重复字串长度</span></span><br><span class="line">        <span class="comment">//vector&lt;int&gt; longestsub;</span></span><br><span class="line">        <span class="comment">//longestsub.push_back(1);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//longestsub.push_back(1);</span></span><br><span class="line">            <span class="keyword">int</span> present=<span class="number">1</span>;<span class="comment">//计算当前位置最长不重复字串长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-Last;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j]!=s[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    present++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    present=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Longest=max(Longest,present);</span><br><span class="line">            Last=present;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.解法3</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict[s[i]] &gt; start)</span><br><span class="line">                start = dict[s[i]];</span><br><span class="line">            dict[s[i]] = i;</span><br><span class="line">            maxLen = max(maxLen, i - start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--31. Next Permutation</title>
    <url>/2019/04/22/LeetCode--31-Next-Permutation.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.<br><a id="more"></a><br>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
</blockquote>
<pre><code>1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</code></pre><h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>前不久好像刚在一道题用过这个函数，现在就遇到实现这个函数了。对于全排列的具体实行过程不是很熟悉，没有什么思路。在查看题解后，发现对于这个问题，14世纪就有人已经提出了简单的解法——<a href="https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order" target="_blank" rel="noopener" title="Generation in lexicographic order">Generation in lexicographic order</a>，算法思路如下：</p>
<blockquote>
<ol>
<li>从右到左，找到第一对连续的数a[i]和a[i-1]，使得满足a[i] &gt; a[i-1];这样a[i]右边的序列就是一个降序的排列（这个序列理论上没有下一个排列，题目中让这种情况的下一个变成了第一个）。如果这一步没有找到上述连续数对，直接将数列反转即可得到最终结果。</li>
<li>从 a[i] 开始的降序排序中找到刚好大于a[i-1]的数 a[k]，将两个数进行交换。</li>
<li>将降序的数列a[i:]反转，得到下一个排列。</li>
</ol>
</blockquote>
<p><a href="https://imgchr.com/i/EkLSDe" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/22/EkLSDe.gif" alt="EkLSDe.gif"></a></p>
<p>讨论区有一种调用库实现上述算法的代码。代码很短，从里面学到了一些STL的函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = is_sorted_until(nums.rbegin(), nums.rend());</span><br><span class="line">    <span class="keyword">if</span> (i != nums.rend())</span><br><span class="line">        swap(*i, *upper_bound(nums.rbegin(), i, *i));</span><br><span class="line">    reverse(nums.rbegin(), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>is_sorted_until(), 它返回序列中“失序”的元素。 如果整个序列被排序（根据谓词），那么它将返回最后一个。</p>
<p>rbegin 和 rend, 反向迭代器, 分别返回指向容器尾元素和首元素前一位置的反向迭代器。</p>
<p>upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的<strong>地址</strong>，不存在则返回end。lower_bound( begin,end,num)类似，不过它找的是第一个小于等于num的数。</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), i, k;</span><br><span class="line">        <span class="keyword">for</span>(i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reverse(nums.begin(), nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(k = n - <span class="number">1</span>; k &gt; i; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            swap(nums[i<span class="number">-1</span>], nums[k]);</span><br><span class="line">            reverse(nums.begin() + i, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = is_sorted_until(nums.rbegin(), nums.rend());</span><br><span class="line">    <span class="keyword">if</span> (i != nums.rend())</span><br><span class="line">        swap(*i, *upper_bound(nums.rbegin(), i, *i));</span><br><span class="line">    reverse(nums.rbegin(), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--23. Merge k Sorted Lists</title>
    <url>/2019/04/16/LeetCode--23-Merge-k-Sorted-Lists.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example :</strong></p>
<blockquote>
<p>Input:<br>[<br> 1-&gt;4-&gt;5,<br> 1-&gt;3-&gt;4,<br> 2-&gt;6<br>]<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>前面有一题是合并两个有序的链表，这道题就相当于进一步泛化。</p>
<p>考虑到我们已经有了合并两个链表的方法，那么我们就可以把这个问题分解。每次把链表数组中的两个链表合并，直到只剩下一个链表为之。这时这个剩下的链表就是我们需要的结果。实现后的确解决了问题，但是效率不高。</p>
<p>进一步思考，既然合并链表的过程都是类似的，那么是不是可以用分治来做，将合并K个链表分解为合并两个子问题的结果——合并K/2个链表。这样逐步分解下去，可以划分为许多更容易解决的子问题。结合递归实现后，效率得到了极大提升，分治算法的思想果然厉害。细想起来，归并排序的思想似乎也是这样。</p>
<p>在题解中发现还有一种有意思的解法，使用priority_queue求解。由priority_queue的特性，我们可以设置在队列头部总是一个值最小的结点，那么我们就可以把所有链表第一个结点输入这个队列中。每次从队列得到最小的结点放入新链表，将该节点对应链表的下一个结点放入队列。这个重复不断进行，最终可以得到一个新的有序链表。这时候的priority_queue其实相当于一个小顶堆。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="逐一合并"><a href="#逐一合并" class="headerlink" title="逐一合并"></a>逐一合并</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode* newList = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(lists.size() &gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists.size() == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                newList = lists.back();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* list1 = lists.back();</span><br><span class="line">                lists.pop_back();</span><br><span class="line">                ListNode* list2 = lists.back();</span><br><span class="line">                lists.pop_back();</span><br><span class="line">                newList = mergeTwoLists(list1,list2);</span><br><span class="line">                lists.push_back(newList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKL</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end - begin == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(lists[begin],lists[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(end == begin) <span class="keyword">return</span> lists[begin];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(end &lt; begin) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (begin+end)/<span class="number">2</span>;</span><br><span class="line">            ListNode* list1 = mergeKL(lists, begin, mid);</span><br><span class="line">            ListNode* list2 = mergeKL(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(list1, list2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeKL(lists, <span class="number">0</span>, lists.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="priority-queue解法"><a href="#priority-queue解法" class="headerlink" title="priority_queue解法"></a>priority_queue解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp=[](ListNode* a, ListNode* b) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;ListNode*,<span class="built_in">vector</span>&lt;ListNode*&gt;,<span class="keyword">decltype</span>(cmp)&gt; pq(cmp);</span><br><span class="line">        ListNode dummy(0),*p=&amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (ListNode *node:lists) <span class="keyword">if</span> (node) pq.push(node);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.top()-&gt;next) pq.push(pq.top()-&gt;next);</span><br><span class="line">            p-&gt;next=pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--29. Divide Two Integers</title>
    <url>/2019/04/22/LeetCode--29-Divide-Two-Integers.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.<br><a id="more"></a><br>Return the quotient after dividing <strong>dividend</strong> by <strong>divisor</strong>.</p>
<p>The integer division should truncate toward zero.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: dividend = 10, divisor = 3<br>Output: 3</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: dividend = 7, divisor = -3<br>Output: -2</p>
</blockquote>
<p><strong>Note :</strong></p>
<blockquote>
<ul>
<li>Both dividend and divisor will be 32-bit signed integers.</li>
<li>The divisor will never be 0.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.</li>
</ul>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目要求实现除法，并且不能使用乘法、除法和模这些操作。这就意味着我们只能使用加减或者位运算，来实现除法的过程。</p>
<p>第一种思路是，用被除数减去除数，知道被除数小于除数时，返回减法进行的次数。</p>
<p>这需要先对输入的两个数进行处理，若除数或被除数是负数，不能直接进行减法，需要先取他们的绝对值。但这是会出现越界的情况，如-2^31的绝对值就越界了，int不能存储。但是题目要求的是只能用32-bit的环境，所以不能用long来解决了，这里想到的是使用unsigned int来保存绝对值结果。这时又碰到了另一个问题，abs()函数也无法处理越界的数，即求abs(-2^31)时会报错，解决方法是使用labs()函数，或者重写一个abs()，可以实现需要的_abs()如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> temp = value;</span><br><span class="line">    <span class="keyword">return</span> (temp &gt; <span class="number">0x80000000</span>) ? -value : temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除此之外，还需要单独判断一种结果溢出的情况，也就是<code>dividend = -2^31，divisor = -1</code> 的情况，这时直接输出INT_MAX即可。</p>
<p>这种方法效率太低，最后超时了。在这种方法基础上可以进行优化。可以加入位运算，如果被除数大于除数，找到小于被除数的，且是除数2^n的最大的数，被除数减去该数，结果加上n后，重复上述操作，直到被除数小于除数为止。这里寻找这个符合条件的数时，就可以运用位运算。</p>
<p>还有一种比较有意思的解法，就是运用对数求解。首先分别求出被除数和除数的对数，算出它们的差后，将其作为指数，求 e 的指数结果。公式如下：<br>    a/b = e^(log(a) - log(b))<br>但是计算对数时，应该使用了除法/，所以可能违反了条件。</p>
<p>参考：<br><a href="https://blog.csdn.net/zephyr_be_brave/article/details/8722397" target="_blank" rel="noopener" title="C++自己实现abs">C++自己实现abs</a><br><a href="https://leetcode.com/problems/divide-two-integers/discuss/13407/C%2B%2B-bit-manipulations" target="_blank" rel="noopener" title="C++ bit manipulations">C++ bit manipulations</a><br><a href="https://leetcode.com/problems/divide-two-integers/discuss/13460/6-line-solution-C%2B%2B" target="_blank" rel="noopener" title="6 line solution C++">6 line solution C++</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="只用加减法（超时）"><a href="#只用加减法（超时）" class="headerlink" title="只用加减法（超时）"></a>只用加减法（超时）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divd = __abs(dividend);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divr = __abs(divisor);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(divd &gt;= divr)</span><br><span class="line">        &#123;</span><br><span class="line">            divd -= divr;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> copyed_value = value;</span><br><span class="line">        <span class="keyword">return</span> (copyed_value &gt; <span class="number">0x80000000</span>) ? -value : copyed_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="加入位运算"><a href="#加入位运算" class="headerlink" title="加入位运算"></a>加入位运算</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divd = __abs(dividend);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divr = __abs(divisor);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(divd &gt;= divr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> temp = divr; <span class="keyword">unsigned</span> m = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>((temp &lt;&lt; <span class="number">1</span>) &lt;= divd &amp;&amp; temp != <span class="number">2147483648</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            divd -= temp;</span><br><span class="line">            result += m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> copyed_value = value;</span><br><span class="line">        <span class="keyword">return</span> (copyed_value &gt; <span class="number">0x80000000</span>) ? -value : copyed_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="对数求解"><a href="#对数求解" class="headerlink" title="对数求解"></a>对数求解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divd = __abs(dividend);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divr = __abs(divisor);</span><br><span class="line">        </span><br><span class="line">        result = <span class="built_in">exp</span>(<span class="built_in">log</span>(divd)-<span class="built_in">log</span>(divr));</span><br><span class="line">        <span class="keyword">return</span> sign * result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> copyed_value = value;</span><br><span class="line">        <span class="keyword">return</span> (copyed_value &gt; <span class="number">0x80000000</span>) ? -value : copyed_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--30. Substring with Concatenation of All Words</title>
    <url>/2019/04/22/LeetCode--30-Substring-with-Concatenation-of-All-Words.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in <strong>s</strong> that is a concatenation of each word in <strong>words</strong> exactly once and without any intervening characters.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input:<br>&nbsp;&nbsp;&nbsp;&nbsp; s = “barfoothefoobarman”,<br>&nbsp;&nbsp;&nbsp;&nbsp; words = [“foo”,”bar”]<br>Output: [0,9]<br>Explanation: Substrings starting at index 0 and 9 are “barfoor” and “foobar” respectively.<br>The output order does not matter, returning [9,0] is fine too.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input:<br>&nbsp;&nbsp;&nbsp;&nbsp; s = “wordgoodgoodgoodbestword”,<br>&nbsp;&nbsp;&nbsp;&nbsp; words = [“word”,”good”,”best”,”word”]<br>Output: []</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题让我们求串联所有单词的子串，就是说给定一个长字符串，再给定几个长度相同的单词，让从长字符串中找出串联给定所有单词的子串的起始位置。</p>
<p>最开始以为单词不重复，所以最初的想法是。用一个map来记录每次单词上一次出现的位置，以及用indexStart记录当前子串开始位置。之后不断检查，若检测到单词不在words内或者单词上次出现在indexStart之后即重复了，就重新进行下一次检查。但是words内单词是可以重复的，所以这种方法行不通，需要记录单词出现的次数。</p>
<p>所以要用到两个map，第一个map内存入words内每个单词可以出现的次数，第二个map存储当前扫描的子串内，单词已经出现的次数。从头开始扫描字符串，每次得到一个单词，看其是否在word内以及出现次数是否在要求范围内，如果不满足，则进行下一次扫描。如果正好匹配完给定单词集里所有的单词，则把开始地址存入结果中。</p>
<p>算法可以继续优化，我们不必每次都从头开始判断每个单词。可以设置一个单词组成字符串大小的滑动窗口。</p>
<blockquote>
<p>若当前判断的单词超过限制的出现次数时导致匹配失败，将窗口后移到该子串中该单词第一个出现的位置之后；<br>若当前判断的单词不在words中导致匹配失败，将窗口完全移动到该单词之后。<br>若判断到窗口最后的位置且匹配成功，记录下当前窗口的开始位置，将窗口后移一个单词长度，继续下一次判断。</p>
</blockquote>
<p>我们同时也可以减少到只使用一个map，map记录单词可以出现的次数，没出现一次就减一。在窗口移动时，我们可以同时恢复现场。这种使用滑动窗口的方法，省去了大量重复的或者不必要的判断，所以算法性能得到极大提升。</p>
<p>查看评论区发现还有一种解法，这种解法思想很巧妙，有些复杂也不是特别懂，在这写下大致思想：</p>
<blockquote>
<ol>
<li>定义一个hash函数，将每个单词映射到一个唯一的值上</li>
<li>用定义好的hash函数，计算出words总的hash值words_hashsum</li>
<li>还是使用一个窗口，先计算第一个窗口内对应字符串的hashsum,与words的hash_sum比较，若相等则把窗口开始位置记录下来。</li>
<li>窗口后移一个位置，继续计算其hashsum进行判断。</li>
</ol>
</blockquote>
<p>这种方法尽管最后能求解ac，但感觉可能存在问题，比如两个单词 a, c的hash值分别为1 3, b的hash值为2, 那么可能(a,c)的组合和(b,b)的组合hashsum相等，所以是有可能会出错的。</p>
<p>参考：<br><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/13791/" target="_blank" rel="noopener">My 24ms C++ solution (O(N) time, using an unordered_map)</a><br><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/192123/" target="_blank" rel="noopener">O(n) C++ solution, 8ms, beats 100%</a><br><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/13700/" target="_blank" rel="noopener">My AC c++ code, O(n) complexity, 26ms</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="两个哈希表"><a href="#两个哈希表" class="headerlink" title="两个哈希表"></a>两个哈希表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordfound,counts;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.empty() || words.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> wordsize = words.size(), wordlen = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> slen = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words) counts[word]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= slen - wordsize * wordlen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; wordsize; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> temp = s.substr(i + j*wordlen, wordlen);</span><br><span class="line">                <span class="keyword">if</span>(counts[temp] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                wordfound[temp]++;</span><br><span class="line">                <span class="keyword">if</span>(wordfound[temp] &gt; counts[temp]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == wordsize) res.push_back(i);</span><br><span class="line">            wordfound.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="滑动窗口的方法"><a href="#滑动窗口的方法" class="headerlink" title="滑动窗口的方法"></a>滑动窗口的方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; counts;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.empty() || words.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> wordsize = words.size(), wordlen = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> slen = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(slen &lt; wordsize * wordlen) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start, cur, founded;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words) counts[word]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordlen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            start = cur = i;</span><br><span class="line">            founded = wordsize;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(start &lt;= slen - wordsize * wordlen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//单词不在words内,整个窗口后移到后一个单词</span></span><br><span class="line">                <span class="keyword">if</span>(counts.count(s.substr(cur,wordlen)) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    founded = wordsize;</span><br><span class="line">                    <span class="keyword">for</span>(;start != cur; start += wordlen)</span><br><span class="line">                        counts[s.substr(start,wordlen)]++;</span><br><span class="line">                    start += wordlen;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(counts[s.substr(cur,wordlen)] == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//单词出现次数超过限制,窗口移动到该单词第一次出现的下一个位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(;s.substr(start,wordlen) != s.substr(cur,wordlen);start += wordlen)</span><br><span class="line">                    &#123;</span><br><span class="line">                        counts[s.substr(start,wordlen)]++;</span><br><span class="line">                        founded++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    start += wordlen;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    counts[s.substr(cur,wordlen)]--;</span><br><span class="line">                    <span class="keyword">if</span>(--founded == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(start);</span><br><span class="line">                        counts[s.substr(start,wordlen)]++;</span><br><span class="line">                        start += wordlen;</span><br><span class="line">                        founded++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += wordlen;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(;start&lt;cur;start+=wordlen)</span><br><span class="line">                counts[s.substr(start,wordlen)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; retVal;</span><br><span class="line">        <span class="keyword">if</span> (words.size()&lt;<span class="number">1</span> || s.size()&lt;<span class="number">1</span>) <span class="keyword">return</span> retVal;</span><br><span class="line">        <span class="comment">// Hash all the words seperately then add them together to get a magic number</span></span><br><span class="line">        <span class="built_in">std</span>::hash&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; hash_fn;</span><br><span class="line">        <span class="keyword">size_t</span> magicNumber = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.size(); i++) &#123;</span><br><span class="line">            magicNumber += hash_fn(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> wordLength = words[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// Concatenated substring will be a given length</span></span><br><span class="line">        <span class="keyword">int</span> minimumSize = words.size()*wordLength;</span><br><span class="line">        <span class="comment">// We do a sliding window calculation for each 'offset' a pattern might have</span></span><br><span class="line">        <span class="comment">// This is faster than re-hashing the entire window because we can just drop the least recently hashed value</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> startOffset=<span class="number">0</span>; startOffset&lt;wordLength; startOffset++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">size_t</span> hashSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> minimum = <span class="number">0L</span>L-minimumSize-startOffset+s.size();</span><br><span class="line">            <span class="comment">// This means that the requested offset does not leave us with enough characters in the string!</span></span><br><span class="line">            <span class="keyword">if</span> (minimum &lt; <span class="number">0</span>) <span class="keyword">return</span> retVal;</span><br><span class="line">            <span class="keyword">for</span> (i=s.size()-startOffset-wordLength; i&gt;=minimum; i-=wordLength) &#123;</span><br><span class="line">                hashSum+=hash_fn(s.substr(i,wordLength));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hashSum==magicNumber) retVal.push_back(i+wordLength);</span><br><span class="line">            <span class="keyword">for</span> (;i&gt;=<span class="number">0</span>; i-=wordLength) &#123;</span><br><span class="line">                hashSum-=hash_fn(s.substr(i+minimumSize,wordLength));</span><br><span class="line">                hashSum+=hash_fn(s.substr(i,wordLength));</span><br><span class="line">                <span class="keyword">if</span> (hashSum==magicNumber) retVal.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--34. Find First and Last Position of Element in Sorted Array</title>
    <url>/2019/04/23/LeetCode--34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given <strong>target</strong> value.<br><a id="more"></a><br>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: nums = [5,7,7,8,8,10], target = 8<br>Output: [3,4]</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: nums = [5,7,7,8,8,10], target = 6<br>Output: [-1,-1]</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>依旧是以O(log n)复杂度查找一个数。这道题给出的数组是有序的而且可以有重复元素，要求给出target出现的范围。</p>
<p>因为数组完全有序，所以思路依旧是使用二分查找。首先用二分查找，查找一个等于target的元素的位置，然后从该位置开始左右拓展，从而找到target出现的范围。若没有找到该数，直接返回<code>{-1, -1}</code>即可。可以看出，算法思路很简单。</p>
<p>但是这可能不是严格意义上的O(logn)的算法，因为在最坏的情况下会变成O(n)，比如当数组里的数全是目标值的话，从中间向两边找边界就会一直遍历完整个数组。一种真正意义上的O(logn)的算法是，使用两次二分查找法，第一次找到左边界，第二次调用找到右边界即可。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[low] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> start = low, end = low;</span><br><span class="line">            <span class="keyword">while</span>(start &gt; <span class="number">0</span> &amp;&amp; nums[start<span class="number">-1</span>] == nums[start]) start--;</span><br><span class="line">            <span class="keyword">while</span>(end &lt; nums.size()<span class="number">-1</span> &amp;&amp; nums[end+<span class="number">1</span>] == nums[end]) end++;</span><br><span class="line">            <span class="keyword">return</span> &#123;start,end&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="两遍二分查找"><a href="#两遍二分查找" class="headerlink" title="两遍二分查找"></a>两遍二分查找</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(high &lt; <span class="number">0</span> || nums[high] != target) <span class="keyword">return</span> res;</span><br><span class="line">        res[<span class="number">0</span>] = high;high = nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>] = high - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--33. Search in Rotated Sorted Array</title>
    <url>/2019/04/23/LeetCode--33-Search-in-Rotated-Sorted-Array.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br><a id="more"></a><br>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: nums = [4,5,6,7,0,1,2], target = 0<br>Output: 4</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: nums = [4,5,6,7,0,1,2], target = 3<br>Output: -1</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>看见要求算法复杂度O(log n)，并且数组有序（轮转有序），最先想到的是，用二分查找。</p>
<p>但是二分法需要进行修改，不能直接使用。第一中方法是，对二分查早进行改进，使它符合这道题：</p>
<blockquote>
<p>二分搜索法的关键在于获得了中间数后，判断下面要搜索左半段还是右半段，我们可以观察到一种规律，如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了。</p>
</blockquote>
<p>另一种方法是，我们还是使用原来的二分查找算法。不过我们需要先找到数组轮转的位置。如对于数组 <code>[4,5,6,7,0,1,2]</code>，可以找到轮转pivot是7，下标是3。根据pivot，可以把数组分为真正有序的两部分，判断target可能出现在哪部分，再继续用原来的二分查找就可以得到结果了。这里寻找pivot也可以用二分查找实现，复杂度依旧是O(log n)。</p>
<p>可以用异或来编写判断语句使代码更精简，代码如下。</p>
<p>参考：<br><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14419/" target="_blank" rel="noopener">Pretty short C++/Java/Ruby/Python</a><br><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14435/Clever-idea-making-it-simple" target="_blank" rel="noopener">Clever idea making it simple</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="修改后的二分查找"><a href="#修改后的二分查找" class="headerlink" title="修改后的二分查找"></a>修改后的二分查找</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="寻找pivot"><a href="#寻找pivot" class="headerlink" title="寻找pivot"></a>寻找pivot</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPivot</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])</span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low == high &amp;&amp; nums[low] == target) <span class="keyword">return</span> low;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = findPivot(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target &lt;= nums[pivot] &amp;&amp; target &gt;= nums[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(nums, <span class="number">0</span>, pivot, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(nums, pivot+<span class="number">1</span>, nums.size()<span class="number">-1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用异或"><a href="#使用异或" class="headerlink" title="使用异或"></a>使用异或</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="keyword">int</span>(nums.size()) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((nums[<span class="number">0</span>] &gt; target) ^ (nums[<span class="number">0</span>] &gt; nums[mid]) ^ (target &gt; nums[mid]))</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hi = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo == hi &amp;&amp; nums[lo] == target ? lo : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--32. Longest Valid Parentheses</title>
    <url>/2019/04/23/LeetCode--32-Longest-Valid-Parentheses.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: “(()”<br>Output: 2<br>Explanation: The longest valid parentheses substring is “()”</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: “)()())”<br>Output: 4<br>Explanation: The longest valid parentheses substring is “()()”</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>给定了一个括号的字符串，求最长有效子串的长度。</p>
<p>首先就是暴力解法，逐个字符遍历字符串，判断从当前字符开始的最大有效括号长度，若大于已经找到的最大有效长度，则更新最大有效长度。遍历完成后，也就找到了最长有效长度。这种方法思路简单而且没有超时，但是效率很低。</p>
<p>主要是因为整个过程会有许多重复的判断。这个问题可以用动态规划来求解：定义一个数组dp，保存以字符串中第i个字符为结尾的最长有效子串的长度。由于有效字符串是以 ‘)’ 结束的，所以 ‘(‘ 必定不构成有效子串。所以我们将dp初始化为全0，当遇到 ‘)’ 时才更新dp数组，更新规则如下：</p>
<blockquote>
<ol>
<li>若s[i] == ‘)’ 且 s[i-1] == ‘(‘，即形如“……()”，更新dp[i] = dp[i - 2] + 2</li>
<li>若s[i] == ‘)’ 且 s[i-1] == ‘)’，即形如”……))”，此时若s[i - dp[i-1] - 1] == ‘(‘，更新dp[i] = dp[i - 1] + dp[i - dp[i-1] - 2] + 2</li>
</ol>
</blockquote>
<p>每次更新dp后，判断当前更新后的值是否比已经找到的最长有效长度大，若是则更新最长有效长度。当dp更新完成后，也就找到了最长有效长度。这种方法只需要扫描一遍字符串，避免了重复的判断。</p>
<p>除了这两种方法外，还有两种算法：</p>
<blockquote>
<ol>
<li><p>使用栈<br>初始化一个栈，先在栈中存入-1。之后遍历给定的字符串，判断当前扫描的字符串是不是有效的，同时更新最长有效长度。<br> 1) 若遇到 ‘(‘，将其下标推入栈内<br> 2) 若遇到 ‘)’，从栈顶弹出一个元素后，用当前元素下标减去剩下栈顶的元素，得到一个当前元素的有效子串长度。若从栈顶弹出元素后，栈空，就将当前元素的下标放入栈内继续遍历。<br>遍历完字符串后，找到最长有效长度。</p>
</li>
<li><p>不使用额外空间<br>用两个计数器 left 和 right ，记录当前遇到的有效左括号数和右括号数。分两遍扫描字符串：<br> 1) 先从左向右扫描，遇到 “(“ 就增加left，遇到 ‘)’ 就增加right，当left和right相等时，得到一个有效子串，计算该有效子串长度并更新最长有效长度。若right大于left，将left和right都置0，继续扫描。<br> 2) 用相同的步骤，从右向左再扫描一编。</p>
</li>
</ol>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur = <span class="number">0</span>; cur &lt; s.length(); cur++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> open = <span class="number">0</span>, close = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=cur; i&lt;s.length(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    open++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ++close;</span><br><span class="line">                    <span class="keyword">if</span>(close == open)</span><br><span class="line">                        longest = max(longest, i-cur+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(close &gt; open)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(longest &gt;= (s.length() - cur))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="DP算法"><a href="#DP算法" class="headerlink" title="DP算法"></a>DP算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.length(), <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = i<span class="number">-2</span> &gt;= <span class="number">0</span> ? dp[i<span class="number">-2</span>]+<span class="number">2</span> : <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i - dp[i<span class="number">-1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i - dp[i<span class="number">-1</span>] - <span class="number">1</span>] == <span class="string">'('</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>] + <span class="number">2</span> + ((i-dp[i<span class="number">-1</span>]<span class="number">-2</span> &gt;= <span class="number">0</span>)?dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]:<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                longest = max(dp[i], longest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">stack</span>.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> curlen = i - <span class="built_in">stack</span>.top();</span><br><span class="line">                    longest = max(longest, curlen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不使用额外空间，两遍扫描"><a href="#不使用额外空间，两遍扫描" class="headerlink" title="不使用额外空间，两遍扫描"></a>不使用额外空间，两遍扫描</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>, close = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>) open++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++close;</span><br><span class="line">                <span class="keyword">if</span>(close == open)</span><br><span class="line">                    longest = max(longest, <span class="number">2</span>* open);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(close &gt; open)</span><br><span class="line">                &#123;</span><br><span class="line">                    open = close = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        open = close = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (<span class="keyword">int</span>)s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) close++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++open;</span><br><span class="line">                <span class="keyword">if</span>(close == open)</span><br><span class="line">                    longest = max(longest, <span class="number">2</span>* open);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(open &gt; close)</span><br><span class="line">                &#123;</span><br><span class="line">                    open = close = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--35. Search Insert Position</title>
    <url>/2019/04/24/LeetCode--35-Search-Insert-Position.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br><a id="more"></a><br>You may assume no duplicates in the array.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: [1,3,5,6], 5<br>Output: 2</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: [1,3,5,6], 2<br>Output: 1</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: [1,3,5,6], 7<br>Output: 4</p>
</blockquote>
<p><strong>Example 4:</strong></p>
<blockquote>
<p>Input: [1,3,5,6], 0<br>Output: 0</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>显然，这道题还是可以使用二分查找求解。使用二分搜索查找target，若找到了，直接返回找到的下标。若target不存在，二分搜索结束后，low所指向的位置就是target插入的位置。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--37. Sudoku Solver</title>
    <url>/2019/04/25/LeetCode--37-Sudoku-Solver.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Write a program to solve a Sudoku puzzle by filling the empty cells.<br><a id="more"></a><br>A sudoku solution must satisfy <strong>all of the following rules:</strong></p>
<ol>
<li>Each row must contain the digits 1-9 without repetition. </li>
<li>Each column must contain the digits 1-9 without repetition. </li>
<li>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li>
</ol>
<p>Empty cells are indicated by the character <code>&#39;.&#39;</code>.</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="A sudoku puzzle..." title="A sudoku puzzle..."></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="...and its solution numbers marked in red." title="...and its solution numbers marked in red."></p>
<p><strong>Note :</strong></p>
<ul>
<li>The given board contain only digits <code>1-9</code> and the character <code>&#39;.&#39;</code>.</li>
<li>You may assume that the given Sudoku puzzle will have a single unique solution.</li>
<li>The given board size is always <code>9x9</code>.</li>
</ul>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>还是遇到这道题了，解数独。有了上一道题的经验，对于解数独的问题也不是毫无头绪了。</p>
<p>既然我们已经有了判断当前棋盘是否符合数独规则的算法，那么一种直观的方法就是利用递归回溯法，将所有可能的合法数字都尝试一遍，判断哪种方法最终可以将整个棋盘填满并且符合数独的规则。尽管思路是有了，但是实现起来还是有点磕磕碰碰，对于递归回溯的使用还是不熟悉呀。实现后不出所料，性能不够好，耗时太多了，暴力解法的缺点就是思路简单，但一般复杂度不会太好。</p>
<p>对这个方法的一种优化是，每次填入一个数的时候，不必要对整个棋盘都判断一遍是不是有效的，只需要判断加入的这个数有没有违反规则。若每次加入的数都没有违反规则，那么到最后填满整个棋盘的数，所有的数也就都是有效的。这样就省去大量重复的比较时间，使得效率得到了提升。</p>
<p>除此之外还有一些比较高深复杂的解法，暂时还没看懂，后面补充。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        solveSudo(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solveSudo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">9</span>) <span class="keyword">return</span> solveSudo(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; ++k) </span><br><span class="line">            &#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>)(k + <span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span> (isValidSudoku(board)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (solveSudo(board, i, j + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> solveSudo(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; col(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; block(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; row(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = <span class="number">1</span> &lt;&lt; (board[i][j] - <span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">if</span> (row[i] &amp; idx || col[j] &amp; idx || block[i/<span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>] &amp; idx)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    </span><br><span class="line">                    row[i] |= idx;</span><br><span class="line">                    col[j] |= idx;</span><br><span class="line">                    block[i/<span class="number">3</span> * <span class="number">3</span> + j/<span class="number">3</span>] |= idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        solveSudo(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solveSudo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">9</span>) <span class="keyword">return</span> solveSudo(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; ++k) </span><br><span class="line">            &#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>)(k + <span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span> (isValidSudoku(board, i, j)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (solveSudo(board, i, j + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> solveSudo(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; ++col) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (col != j &amp;&amp; board[i][j] == board[i][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; ++row) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (row != i &amp;&amp; board[i][j] == board[row][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = i / <span class="number">3</span> * <span class="number">3</span>; row &lt; i / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; ++row) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = j / <span class="number">3</span> * <span class="number">3</span>; col &lt; j / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; ++col) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((row != i || col != j) &amp;&amp; board[i][j] == board[row][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--4. Median of Two Sorted Arrays</title>
    <url>/2019/03/31/LeetCode--4-Median-of-Two-Sorted-Arrays.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.<br><a id="more"></a><br>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>The median is 2.0</p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>The median is (2 + 3)/2 = 2.5</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>最先想到的方法是，既然两个数组是有序的，可以直接归并两个数组，之后可以直接找到中位数。但题目对时间有要求，这种方法的时间复杂度是O(m+n)，比要求的O(log(m+n))显然要大，所以不能用这种暴力的方法。</p>
<p>仔细分析问题，既然两个数组都是有序的，那么可以不必将数组归并，可以直接挨个比较两个数组，找到中间的那两个数(数组为奇数长度下，找中间一个数)，就可以停止下来，不必继续比较后面的值，可以节省大量时间。事实证明这种方法可行，速度也够快。</p>
<p><strong>二分求解</strong><br>题目解析给出了另外一种方法，即基于二分搜索的方法。大致思想如下</p>
<blockquote>
<p>将数组A,B分别分成两部分，将 left_A 和 left_B 放入一个集合，并将 right_A 和 right_B 放入另一个集合。 再把这两个新的集合分别命名为 left_part 和 right_part：</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">left_part</th>
<th style="text-align:center">right_part</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A[0], A[1], …, A[i-1]</td>
<td style="text-align:center">A[i], A[i+1], …, A[m-1]</td>
</tr>
<tr>
<td style="text-align:center">B[0], B[1], …, B[j-1]</td>
<td style="text-align:center">B[j], B[j+1], …, B[n-1]</td>
</tr>
</tbody>
</table>
</div>
<p>如果我们可以确认：</p>
<blockquote>
<ol>
<li>len(left_part) = len(right_part)</li>
<li>max(left_part) ≤ min(right_part)</li>
</ol>
</blockquote>
<p>那么，我们已经将 {A,B} 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。这时可以很容易求出<strong>median</strong>:</p>
<blockquote>
<p>median= (max(left_part) + min(right_part)) / 2</p>
</blockquote>
<p>要确保这两个条件，我们只需要保证：</p>
<blockquote>
<ol>
<li>i + j = m − i + n − j（或：m - i + n - j + 1） 如果 n ≥ m，只需要使 i = 0 ~ m, j = (m + n + 1) / 2 - i</li>
<li>B[j−1] ≤ A[i] 以及 A[i−1] ≤ B[j]</li>
</ol>
</blockquote>
<p>接下来，按照以下步骤进行二叉树搜索，找到合适的i：</p>
<blockquote>
<ol>
<li>设 imin = 0，imax = m, 然后开始在 [imin,imax] 中进行搜索。</li>
<li>令i = (imin+imax)/2, j = (m+n+1)/2-i</li>
<li>现在有len(left_part)=len(right_part)。会遇到三种情况：<ul>
<li>B[j−1] ≤ A[i] 且 A[i−1] ≤ B[j]：这意味着我们找到了目标对象 i，所以可以停止搜索。</li>
<li>B[j−1] &gt; A[i]：这意味着 A[i] 太小，我们必须增大 i 以使 B[j−1] ≤ A[i]。也就是说，我们必须将搜索范围调整为[i+1,imax]。因此，设 imin=i+1，并转到步骤 2。</li>
<li>A[i−1] &gt; B[j]：这意味着 A[i−1] 太大，我们必须减小 i 以使 A[i−1] ≤ B[j]。也就是说，我们必须将搜索范围调整为[imin,i−1]。因此，设 imax=i−1，并转到步骤 2。</li>
</ul>
</li>
</ol>
</blockquote>
<p>当找到目标对象 i 时，中位数为：</p>
<blockquote>
<ul>
<li>max(A[i−1],B[j−1]),  当 m+n 为奇数时</li>
<li>(max(A[i−1],B[j−1])+min(A[i],B[j]))/2,  当 m+n 为偶数时</li>
</ul>
</blockquote>
<p>接下来只需要对一些边界条件进行处理就可以了，这种方法实现了O(log(m+n))的复杂度</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-解法1"><a href="#1-解法1" class="headerlink" title="1.解法1"></a>1.解法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//只有单个数组有值的情况，只需要处理单个数组</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findSingleArrayMedian</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> isOdd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isOdd) <span class="keyword">return</span> nums[nums.size()/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[nums.size()/<span class="number">2</span><span class="number">-1</span>] + nums[nums.size()/<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//vector&lt;int&gt; nums;</span></span><br><span class="line">        <span class="keyword">int</span> totalLen=nums1.size() + nums2.size();</span><br><span class="line">        <span class="keyword">int</span> isOdd = (totalLen&amp;<span class="number">1</span>); <span class="comment">//判断数组长度奇偶性</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(totalLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums1.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findSingleArrayMedian(nums2,isOdd);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums2.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findSingleArrayMedian(nums1,isOdd);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> last1=<span class="number">0</span>,last2=<span class="number">0</span>; <span class="comment">//记录最后两个值</span></span><br><span class="line">        <span class="keyword">int</span> index1=<span class="number">0</span>,index2=<span class="number">0</span>; <span class="comment">//记录两个数组当前的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=totalLen/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数组1已经没有值时</span></span><br><span class="line">            <span class="keyword">if</span>(index1 == nums1.size())</span><br><span class="line">            &#123;</span><br><span class="line">                last1=last2;</span><br><span class="line">                last2=nums2[index2];</span><br><span class="line">                <span class="comment">//nums.push_back(nums2[index2]);</span></span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数组2已经没有值时</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index2 == nums2.size())</span><br><span class="line">            &#123;</span><br><span class="line">                last1=last2;</span><br><span class="line">                last2=nums1[index1];</span><br><span class="line">                <span class="comment">//nums.push_back(nums1[index1]);</span></span><br><span class="line">                index1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[index1]&lt;nums2[index2])</span><br><span class="line">                &#123;</span><br><span class="line">                    last1=last2;</span><br><span class="line">                    last2=nums1[index1];</span><br><span class="line">                    <span class="comment">//nums.push_back(nums1[index1]);</span></span><br><span class="line">                    index1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    last1=last2;</span><br><span class="line">                    last2=nums2[index2];</span><br><span class="line">                    <span class="comment">//nums.push_back(nums2[index2]);</span></span><br><span class="line">                    index2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(isOdd) <span class="keyword">return</span> last2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (last1+last2) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-解法2（二分法）"><a href="#2-解法2（二分法）" class="headerlink" title="2.解法2（二分法）"></a>2.解法2（二分法）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = nums2.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//确保数组1长度不大于数组2小</span></span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp=nums1;nums1=nums2;nums2=tmp;</span><br><span class="line">            <span class="keyword">int</span> temp = len1;len1=len2;len2=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> iMin=<span class="number">0</span>,iMax=len1,halfLen=(len1+len2+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(iMin&lt;=iMax)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i=(iMin+iMax)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j=halfLen-i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//i过小</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;iMax &amp;&amp; nums2[j<span class="number">-1</span>]&gt;nums1[i])</span><br><span class="line">            &#123; </span><br><span class="line">                iMin=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i过大</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;iMin &amp;&amp; nums1[i<span class="number">-1</span>]&gt;nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                iMax=i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//成功找到i</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> maxLeft=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) maxLeft=nums2[j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) maxLeft=nums1[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> maxLeft=max(nums1[i<span class="number">-1</span>],nums2[j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>((len1+len2)%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> maxLeft;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> minRight=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==len1) minRight = nums2[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==len2) minRight = nums1[i];</span><br><span class="line">                <span class="keyword">else</span> minRight=min(nums1[i],nums2[j]);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--6. ZigZag Conversion</title>
    <url>/2019/04/01/LeetCode--6-ZigZag-Conversion.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><br>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code><br>Write the code that will take a string and make this conversion given a number of rows:<br><code>string convert(string s, int numRows);</code></p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: s = “PAYPALISHIRING”, numRows = 3<br>Output: “PAHNAPLSIIGYIR”</p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: s = “PAYPALISHIRING”, numRows = 4<br>Output: “PINALSIGYAHRPI”<br>Explanation:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题可以直接通过找规律实现。找到每行 Z 字形图案字符在原字符串中对于的位置即可，然后逐行访问。规律如下：</p>
<blockquote>
<p>对于所有整数”k”,</p>
<ol>
<li>第0行中的字符位于原字符串 k*(2⋅numRows−2) 处;</li>
<li>第(numRows−1)行中的字符位于原字符串 k*(2⋅numRows−2)+numRows−1 处;</li>
<li>其他行中字符位于原字符串 k*(2⋅numRows−2)+i 以及 (k+1)*(2⋅numRows−2)−i处；</li>
</ol>
</blockquote>
<p>找到规律后，就很容易实现了。</p>
<p>另外一种方法是，通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。所以可以分别构建每行的字符串，最后再将这些字符串连接起来即可，算法如下</p>
<blockquote>
<ol>
<li>使用 min(numRows,len(s)) 个列表来表示 Z 字形图案中的非空行。</li>
<li>从左到右迭代 s，将每个字符添加到合适的行。</li>
<li>合并所有行</li>
</ol>
</blockquote>
<p>但是这种方法效率要低一些。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-找规律的方法"><a href="#1-找规律的方法" class="headerlink" title="1. 找规律的方法"></a>1. 找规律的方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一行，无需处理直接输出</span></span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> cvStr;</span><br><span class="line">        <span class="keyword">int</span> step=numRows*<span class="number">2</span><span class="number">-2</span>;<span class="comment">//每次前进的步伐</span></span><br><span class="line">        <span class="comment">//逐行生成每行的序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;s.length();j+=step)</span><br><span class="line">            &#123;</span><br><span class="line">                cvStr+=s[j+i];</span><br><span class="line">                <span class="comment">//若是内部行，需要加上((k+1)(2⋅numRows−2)−i)处的字符</span></span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;i!=numRows<span class="number">-1</span>&amp;&amp;j+step-i&lt;s.length())</span><br><span class="line">                &#123;</span><br><span class="line">                    cvStr+=s[j+step-i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cvStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-逐行构造的方法"><a href="#2-逐行构造的方法" class="headerlink" title="2. 逐行构造的方法"></a>2. 逐行构造的方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一行，无需处理直接输出</span></span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = min(numRows,<span class="keyword">int</span>(s.length()));</span><br><span class="line">        <span class="built_in">string</span> cvStr; <span class="comment">//结果字符串</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; rows(len); <span class="comment">//每行字符串</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> curRow=<span class="number">0</span>; <span class="comment">//当前行</span></span><br><span class="line">        <span class="keyword">bool</span> curDirect=<span class="literal">false</span>; <span class="comment">//当前方向</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逐个字符串构建每行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            rows[curRow]+=s[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//边界时，确定当前方向</span></span><br><span class="line">            <span class="keyword">if</span>(curRow==<span class="number">0</span> || curRow == numRows<span class="number">-1</span>) curDirect=!curDirect;</span><br><span class="line">            </span><br><span class="line">            curRow+=curDirect?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//合成字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> row : rows) cvStr+=row;</span><br><span class="line">        <span class="keyword">return</span> cvStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--5. Longest Palindromic Substring</title>
    <url>/2019/03/28/LeetCode--5-Longest-Palindromic-Substring.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.</p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>Input: “cbbd”<br>Output: “bb”</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>最开始想到的当然还是暴力算法，想法是先用暴力算法把题目做出来理解题目，然后尝试着对实现的算法进行改进，或者再想想有没有其他思路。最开始的想法是</p>
<blockquote>
<p>设置两个游标i、j，i从前往后遍历字符串，j从后往前遍历字符串；先将i固定住，然后j从后往前遍历，依次判断从当前j到i的字符串是不是一个回文，其长度是不是最大，若满足条件，就将该字符串的位置信息记录下来，遍历完后最终输出即可。</p>
</blockquote>
<p>显然这个方法的效果不会太好，选择尝试对其进行优化。想要的优化思路如下</p>
<blockquote>
<p>若当前要判断的子串比已经找到的最长回文子串要短，那么该子串以及比它短的子串都没必要在判断了，可以通过跳过这些不必要的比较过程节省大量时间</p>
</blockquote>
<p>修改过后，时间上果然有了很大提升，但结果告诉我显然这种方法还是不好，肯定存在更优化的方法。仔细分析后发现，其实这种方法就相当于将字符串反转后找最大公共子串，它存在一些问题：</p>
<blockquote>
<p>这种方法是从两端往内部收缩的算法，如果一个字符串恰好只是最内部的一部分不是子串，那么两端的整个判断过程都是无意义的，而且很费时。我们需要能够更早发现这不是一个回文。若我们把判断过程换一个方向就可以做到，即收缩改为扩展。由内而外的判断子串是不是回文，可以在不是回文的地方及时停止，并且保证之前判断的子串的确是回文，不是无意义的判断。</p>
</blockquote>
<p>实现后发现，这种扩展的算法效率比最开始的算法效率要好太多了，因为避免了许多无意义的计算过程。总结起来就是，有时候换一个方向想问题，可以得到更加优化的结果。<br>查看解题的文档后发现还有以下几种比较巧妙的方式：</p>
<blockquote>
<p>1.最长公共子串暴力算法<br>反转 S，使之变成 S’。找到 S 和 S’之间最长的公共子串,每当我们找到最长的公共子串的候选项时，都需要检查子串的索引是否与反向子串的原始索引相同。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。我所用到的第一种方法思路根这种方法一致。</p>
<p>2.动态规划<br>考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，”ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。可以给出P(i,j)的定义如下</p>
<ul>
<li>P(i,j) = true,  如果子串Si,…,Sj是回文子串</li>
<li>P(i,j) = false, 其他情况</li>
</ul>
<p>因此P(i,j)更新公式如下：</p>
<ul>
<li>P(i,j) = (P(i+1,j−1) and Si == Sj)</li>
</ul>
<p>这是一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推</p>
<p>3.Manacher 算法<br>也叫“马拉松”算法，这个算法可以将时间复杂度提升为<strong>O(n)</strong>。</p>
<ol>
<li><p>首先对字符串进行预处理，处理原因是防止偶数问题。比如，有一个偶回文<strong>abba</strong>和一个奇回文<strong>opxpo</strong>，转换为<strong>#a#b#b#a#</strong>和<strong>#o#p#x#p#o#</strong>，长度都转换成了奇数。</p>
</li>
<li><p>定义一个辅助数组p[]，其中p[i]表示以 <strong>i</strong> 为中心的最长回文的半径</p>
</li>
<li><p>接下来的重点就是求解 p 数组。参考下图<br><img src="https://image-static.segmentfault.com/105/998/1059982876-58b966b759200" alt=""><br>设置两个变量，mx 和 id。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么：<br><code>if (i &lt; mx) p[i]=min(p[2 * id - i], mx - i);</code><br><strong>(2 * id - i)</strong>为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快更新数组。</p>
</li>
</ol>
</blockquote>
<p>参考文献：<a href="https://subetter.com/algorithm/manacher-algorithm.html" target="_blank" rel="noopener">https://subetter.com/algorithm/manacher-algorithm.html</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="1-改进的收缩算法-最长字符串匹配"><a href="#1-改进的收缩算法-最长字符串匹配" class="headerlink" title="1. 改进的收缩算法(最长字符串匹配)"></a>1. 改进的收缩算法(最长字符串匹配)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> begin=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> LongestLength=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=s.length()<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> forward=i;</span><br><span class="line">                <span class="keyword">int</span> backward=j;</span><br><span class="line">                <span class="keyword">while</span>(s[forward]==s[backward]&amp;&amp;forward&lt;backward)</span><br><span class="line">                &#123;</span><br><span class="line">                    forward++;</span><br><span class="line">                    backward--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(forward&gt;=backward)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(LongestLength&lt;(j-i+<span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        begin=i;</span><br><span class="line">                        LongestLength=(j-i+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(LongestLength&gt;=(j-i+<span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(LongestLength&gt;=(s.length()-i+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> s.substr(begin, LongestLength); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-扩展算法"><a href="#2-扩展算法" class="headerlink" title="2. 扩展算法"></a>2. 扩展算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> r_ptr = i; </span><br><span class="line">        <span class="keyword">int</span> l_ptr = i;</span><br><span class="line">        <span class="comment">//找到回文中心</span></span><br><span class="line">        <span class="keyword">while</span>(r_ptr &lt; s.size()<span class="number">-1</span> &amp;&amp; s[r_ptr] == s[r_ptr + <span class="number">1</span>]) r_ptr++;</span><br><span class="line">        i = r_ptr+<span class="number">1</span>;<span class="comment">//记录下次启示位置，防止重复计算</span></span><br><span class="line">        <span class="comment">//从中心开始扩展</span></span><br><span class="line">        <span class="keyword">while</span>(r_ptr &lt; s.size()<span class="number">-1</span> &amp;&amp; l_ptr &gt; <span class="number">0</span> &amp;&amp; s[r_ptr + <span class="number">1</span>] == s[l_ptr - <span class="number">1</span>]) &#123;</span><br><span class="line">            r_ptr++;</span><br><span class="line">            l_ptr--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新最长回文子串信息</span></span><br><span class="line">        <span class="keyword">int</span> new_len = r_ptr - l_ptr + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(new_len &gt; max_len) &#123;</span><br><span class="line">            start_idx = l_ptr;</span><br><span class="line">            max_len = new_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(start_idx, max_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-动态规划算法"><a href="#3-动态规划算法" class="headerlink" title="3. 动态规划算法"></a>3. 动态规划算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> LongestLength = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(len,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dist = <span class="number">1</span>;dist &lt; len - i;dist++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = dist + i;</span><br><span class="line">                dp[i][j] = (dist == <span class="number">1</span>)? s[i] == s[j] : s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; LongestLength)</span><br><span class="line">                &#123;</span><br><span class="line">                    LongestLength = j-i+<span class="number">1</span>;</span><br><span class="line">                    begin=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substr(begin, LongestLength); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-Manacher算法"><a href="#4-Manacher算法" class="headerlink" title="4. Manacher算法"></a>4. Manacher算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字符串预处理，插入 '#'</span></span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">"$#"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            t += s[i];</span><br><span class="line">            t += <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理t</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(t.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, resLen = <span class="number">0</span>, resCenter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.size(); ++i) &#123;</span><br><span class="line">            p[i] = i &lt; mx ? min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++p[i]; <span class="comment">//// 不需边界判断，因为左有'$',右有'\0'</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//希望 mx 尽可能的远</span></span><br><span class="line">            <span class="keyword">if</span> (mx &lt; i + p[i]) &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</span><br><span class="line">                resLen = p[i];</span><br><span class="line">                resCenter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr((resCenter - resLen) / <span class="number">2</span>, resLen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--771. Jewels and Stones</title>
    <url>/2019/03/28/LeetCode--771-Jewels-and-Stones.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>You’re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.<br><a id="more"></a><br>The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: J = “aA”, S = “aAAbbbb”<br>Output: 3</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: J = “z”, S = “ZZ”<br>Output: 0</p>
</blockquote>
<p><strong>Note:</strong></p>
<blockquote>
<ul>
<li>S and J will consist of letters and have length at most 50.</li>
<li>The characters in J are distinct.</li>
</ul>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>1.这是一道很简单的题，只需要逐个判断字符串 <strong>S</strong> 中的每个字符,是否在字符串 <strong>J</strong> 中出现过。设置一个计数器count，每次判断后更新该计数器，带遍历完整个字符串，即可得出最终结果。比较字符串的过程中，应用了string库里的find()函数。<br>2.在看别人提交的解法中，看见了另外一种比较有趣的方法，建立了一个与字符ASCII码大小相同的数组，每次判断字符是否存在，只需直接在数组内查看该字符ASCII码对应的位置是否为1，这是一种空间换时间的方法。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li>解法1 </li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(J.find(S[i]) != J.npos)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>解法2</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> exist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; J.length();i++) &#123;</span><br><span class="line">            exist[J.at(i)] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exist[S.at(i)]) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--7. Reverse Integer</title>
    <url>/2019/03/28/LeetCode--7-Reverse-Integer.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Given a 32-bit signed integer, reverse digits of an integer..<br><a id="more"></a></p>
</blockquote>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: 123<br>Output: 321</p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>Input: -123<br>Output: -321</p>
</blockquote>
<p><strong>Example3:</strong></p>
<blockquote>
<p>Input: 120<br>Output: 21</p>
</blockquote>
<p><strong>Note:</strong></p>
<blockquote>
<p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>问题很简单，即将一个int型整数逆序。这里需要注意的是，int的表示范围是[−2^31,  2^31 − 1]，所以若逆序后的数在这个范围之外，即溢出的时候，直接输出0。<br>我的想法是，用一个更大的类型，即<strong>long</strong>来存储转化结果，然后判断结果在不在int的表示范围内，对计算结果进行处理。对比评论区，发现思路大致相同，这貌似就是最优的方法，还以为又会有啥逻辑上的转换。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> MAX=<span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">long</span> MIN=<span class="number">-2147483648</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result=result*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(result&gt;MAX||result&lt;MIN)</span><br><span class="line">        &#123;</span><br><span class="line">            result=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>据说出题人想考的是溢出判断，不能用long，只用Int的实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> MAX=<span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">long</span> MIN=<span class="number">-2147483648</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(result&gt;MAX/<span class="number">10</span>||result&lt;MIN/<span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            result=result*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>也就是计算结果的时候，先判断这次计算会不会溢出，溢出就直接返回0</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--36. Valid Sudoku</title>
    <url>/2019/04/24/LeetCode--36-Valid-Sudoku.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated <strong>according to the following</strong> .<br><a id="more"></a><br><strong>rules :</strong></p>
<ol>
<li>Each row must contain the digits 1-9 without repetition. </li>
<li>Each column must contain the digits 1-9 without repetition. </li>
<li>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li>
</ol>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="A partially filled sudoku which is valid." title="A partially filled sudoku which is valid."></p>
<blockquote>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>&#39;.&#39;</code>.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input:<br>[<br>&nbsp;&nbsp;[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>&nbsp;&nbsp;[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>&nbsp;&nbsp;[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>&nbsp;&nbsp;[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>&nbsp;&nbsp;[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>&nbsp;&nbsp;[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>&nbsp;&nbsp;[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>&nbsp;&nbsp;[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>&nbsp;&nbsp;[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>Output: true</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input:<br>[<br>&nbsp;&nbsp;[“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>&nbsp;&nbsp;[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>&nbsp;&nbsp;[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>&nbsp;&nbsp;[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>&nbsp;&nbsp;[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>&nbsp;&nbsp;[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>&nbsp;&nbsp;[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>&nbsp;&nbsp;[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>&nbsp;&nbsp;[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>Output: false<br>Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8’s in the top left 3x3 sub-box, it is invalid.</p>
</blockquote>
<p><strong>Note :</strong></p>
<ul>
<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>
<li>Only the filled cells need to be validated according to the mentioned rules.</li>
<li>The given board contain only digits 1-9 and the character <code>&#39;.&#39;</code>.</li>
<li>The given board size is always <code>9x9</code>.</li>
</ul>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>咋一看以为是解数独，会很复杂。读完题目后，发现只要求判断当前的棋盘上的数字是不是有效的，不需要考虑最终这个数独是不是可以解。所以相当于只需要判断当前这个已经存在的棋盘是否满足数独规则的要求。</p>
<p>数独的规则要求，每行，每列，以及每个<code>3x3</code>的子棋盘上，是否包括<code>1-9</code>这9个数字且不重复。现在考虑，肯定是需要把整个棋盘扫描一遍的，那么我们可以设置三个状态数组，来分别记录下以及扫描过的 <code>行/列/子棋盘</code> 中已经出现过的数，如果扫描到某 <code>行/列/子棋盘</code> 中有重复的元素前面已经出现过，直接返回false；若直到扫描结束，也为发现重复元素，说明棋盘有效，返回true。但是由于要记录每 <code>行/列/子棋盘</code> 的状态，需要声明三个较大的数组，所以对空间的消耗较高，应该还有更优化的解法。</p>
<p>评论区解题的大致思路都差不多，区别主要再求如何存储状态数组。有一种很优化的方法是利用位操作实现的，这种方法只使用一个short就存储了一行的状态，节省了很多空间，效率也得到了提升。</p>
<blockquote>
<ol>
<li>每行的状态初始化为0；</li>
<li>遇到一个数字num，就将1左移num位与状态数进行与操作，若结果不为0，说明有重复，返回false；否则，无重复，更新状态，即两数进行或操作。</li>
</ol>
</blockquote>
<p>参考：<br><a href="https://leetcode.com/problems/valid-sudoku/discuss/15452" target="_blank" rel="noopener">C++ very simple and easy understand. using bit operation</a><br><a href="https://leetcode.com/problems/valid-sudoku/discuss/15705/" target="_blank" rel="noopener">My C++ code (O(n2) time and space)</a></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; rows(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; columns(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; sub_box(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> sub_box_index = (i/<span class="number">3</span>)*<span class="number">3</span> + (j/<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">int</span> num = board[i][j] - <span class="string">'1'</span>;</span><br><span class="line">                <span class="keyword">if</span>(rows[i][num] || columns[j][num] || sub_box[sub_box_index][num])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                rows[i][num] = columns[j][num] = sub_box[sub_box_index][num] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="利用位操作"><a href="#利用位操作" class="headerlink" title="利用位操作"></a>利用位操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; col(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; block(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; row(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = <span class="number">1</span> &lt;&lt; (board[i][j] - <span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">if</span> (row[i] &amp; idx || col[j] &amp; idx || block[i/<span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>] &amp; idx)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    </span><br><span class="line">                    row[i] |= idx;</span><br><span class="line">                    col[j] |= idx;</span><br><span class="line">                    block[i/<span class="number">3</span> * <span class="number">3</span> + j/<span class="number">3</span>] |= idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> existNum[<span class="number">10</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!=<span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(existNum[i][board[i][j] - <span class="string">'0'</span>] &amp; <span class="number">0x1</span>)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// check if the i-row already has such number, LSB</span></span><br><span class="line">                    <span class="keyword">if</span>(existNum[j][board[i][j] - <span class="string">'0'</span>] &amp; <span class="number">0x2</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// check if the j-col already has such number, 2-LSB</span></span><br><span class="line">                    <span class="keyword">if</span>(existNum[(i/<span class="number">3</span>) *<span class="number">3</span> + j/<span class="number">3</span>][board[i][j] - <span class="string">'0'</span>] &amp; <span class="number">0x4</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// check if the k-subblock already has such number, 3-LSB</span></span><br><span class="line">                    existNum[i][board[i][j] - <span class="string">'0'</span>] ^=<span class="number">0x1</span>;</span><br><span class="line">                    existNum[j][board[i][j] - <span class="string">'0'</span>] ^=<span class="number">0x2</span>;</span><br><span class="line">                    existNum[(i/<span class="number">3</span>) *<span class="number">3</span> + j/<span class="number">3</span>][board[i][j] - <span class="string">'0'</span>] ^=<span class="number">0x4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--8. String to Integer (atoi)</title>
    <url>/2019/03/31/LeetCode--8-String-to-Integer-atoi.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Implement <strong>atoi</strong> which converts a string to an integer.<br><a id="more"></a><br>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>Only the space character ‘ ‘ is considered as whitespace character.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</li>
</ul>
<p><strong>Example1:</strong></p>
<blockquote>
<p>Input: “42”<br>Output: 42</p>
</blockquote>
<p><strong>Example2:</strong></p>
<blockquote>
<p>Input: “   -42”<br>Output: -42<br>Explanation: The first non-whitespace character is ‘-‘, which is the minus sign.Then take as many numerical digits as possible, which gets 42.</p>
</blockquote>
<p><strong>Example3:</strong></p>
<blockquote>
<p>Input: “4193 with words”<br>Output: 4193<br>Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit.</p>
</blockquote>
<p><strong>Example4:</strong></p>
<blockquote>
<p>Input: “words and 987”<br>Output: 0<br>Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.</p>
</blockquote>
<p><strong>Example5:</strong></p>
<blockquote>
<p>Input: “-91283472332”<br>Output: -2147483648<br>Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目大致意思是：将一个字符串转换成一个数，这个字符串有很多种情况需要考虑：</p>
<ol>
<li>忽略字符串头部的空白(只把” “当做空白)</li>
<li>数字可能带正负号</li>
<li>若数字超过INT表示范围，则若上溢，返回INT最大值；若下溢，返回INT最小值</li>
<li>如果除1,2情况外，第一个字符不是数字，视为无效值，返回0</li>
<li>如果数字后出现非数字，则截断，不考虑后面的字符。</li>
</ol>
<p>所以，只需要将这些情况考虑进来，把字符串进行直接处理即可。判断溢出时，可以用long来保存结果，最后再判断值是否溢出；也可以直接计算过程中对INT进行判断。这里用的后一种方法。这道题在判断溢出时，思路类似于[7.Reverse Integer]这道题。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,sign=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//去空格</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;str[i]==<span class="string">' '</span>;i++);</span><br><span class="line">        <span class="comment">//取符号</span></span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sign=<span class="number">1</span>;i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">'+'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="number">0</span>&amp;&amp;(INT_MAX-(str[i]-<span class="string">'0'</span>))/<span class="number">10</span>&lt;result) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="number">1</span>&amp;&amp;(INT_MAX-(str[i]-<span class="string">'0'</span>))/<span class="number">10</span>&lt;result) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            </span><br><span class="line">            result=result*<span class="number">10</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sign) result=-result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--9. Palindrome Number</title>
    <url>/2019/04/02/LeetCode--9-Palindrome-Number.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: 121<br>Output: true</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: -121<br>Output: false<br>Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: 10<br>Output: false<br>Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目让判断一个数整数是不是一个回文，其中定义所有负数都不是回文。解题想法是</p>
<blockquote>
<ol>
<li>首先判断这个数是不是负数，或者是不是0~9的数(只有一位肯定是回文)。</li>
<li>然后将数字转化为一个字符串，从中心开始向两边扩展判断是不是回文。</li>
</ol>
</blockquote>
<p>这里判断回文的思路和前面做到的一道题很类似，但是这个题要更简单一点。后来才发现题目要求里面有，<strong>不能使用把数转化为字符串</strong>。<br>前面有道题是可以把一个数反转，那么可以直接把数反转后，看看两个数是否相等即可判断。但是把数反转后有可能导致数字大于int表示范围，还需要额外处理溢出的情况。一种优化的方法是，可以<strong>只反转int数字的一半</strong>，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。例如，输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 1221 是回文。这里还需要对一些特殊情况进行处理，比如数字是奇数长，或者10^n时，需要额外判断。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><h4 id="转化为字符串的解法"><a href="#转化为字符串的解法" class="headerlink" title="转化为字符串的解法"></a>转化为字符串的解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToStr</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = (x%<span class="number">10</span>)+<span class="string">'0'</span>;</span><br><span class="line">            res = tmp + res;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;<span class="number">10</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> num = intToStr(x);</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">if</span>(num.length()%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i=num.length()/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            j=num.length()/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i=num.length()/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            j=num.length()/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;=num.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=num[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i--;j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不转化解法"><a href="#不转化解法" class="headerlink" title="不转化解法"></a>不转化解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span> || (x!=<span class="number">0</span> &amp;&amp; x%<span class="number">10</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; revertedNumber)</span><br><span class="line">        &#123;</span><br><span class="line">            revertedNumber = revertedNumber*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x==(revertedNumber/<span class="number">10</span>) || x==revertedNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--929. Unique Email Addresses</title>
    <url>/2019/03/28/LeetCode--929-Unique-Email-Addresses.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Every email consists of a local name and a domain name, separated by the @ sign.</p>
<p>For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name.<br><a id="more"></a><br>Besides lowercase letters, these emails may contain ‘.’s or ‘+’s.</p>
<p>If you add periods (‘.’) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, “alice.z@leetcode.com” and “alicez@leetcode.com” forward to the same email address.  (Note that this rule does not apply for domain names.)</p>
<p>If you add a plus (‘+’) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.)</p>
<p>It is possible to use both of these rules at the same time.</p>
<p>Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails? </p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: <code>{&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;}</code><br>Output: <strong>2</strong></p>
</blockquote>
<p>Explanation: “testemail@leetcode.com” and “testemail@lee.tcode.com” actually receive mails</p>
<p><strong>Note:</strong></p>
<ul>
<li>1 &lt;= emails[i].length &lt;= 100</li>
<li>1 &lt;= emails.length &lt;= 100</li>
<li>Each emails[i] contains exactly one ‘@’ character.</li>
</ul>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>题目的意思是，邮箱作为一个字符串，在字符”@”前面的部分：</p>
<blockquote>
<p>1.若出现字符’.’，则可以去掉该’.’;<br>2.若出现’+’，则从’+’到’@’的字符串都可去掉。</p>
</blockquote>
<p>根据这样的规则，判断总共有多少个不同的邮箱。思路很明确，只需要将每一个邮箱转换为其最简单的形式，然后去除其中重复的字符串，计算最终剩下的字符串个数即可。<br>首先联想到的是在每次处理完字符串后，将处理过的字符串放入一个set中，由于set内不含重复元素，所以自然就可以去重。但是vector有没有什么直接去重的方法呢？查阅资料后发现还真有，在vector类型中，有一种去重的方法是：先在vector内对向量进行排序，然后用erase加unique函数即可实现去除重复元素。</p>
<blockquote>
<ul>
<li>unique函数是一个去重函数，去除相邻中的重复元素（只留一个）。其中，最关键的是：并不是把重复的元素删除，而是全部放倒数组的后面。</li>
<li>由于unique只是去除（相邻）的重复元素，因此，为了去除重复的元素，应该，首先对数组Vector进行排序，这样保证重复元素在相邻的位置。</li>
<li>unique函数，返回的是去重后的尾地址。因此对于一个内容为{2, 2, 5, 5, 6}的vector，执行unique函数以后，vector大小并没有改变，只不过顺序变成了{2, 5, 6, 2, 5}，并且函数的返回值为:3。此时需要删除重复元素，只需要将后面的数据全部删除即可。</li>
</ul>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numUniqueEmails</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; emails)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator email=emails.begin();email&lt;emails.end();email++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(*email).find(<span class="string">'@'</span>);i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((*email)[i]==<span class="string">'.'</span>)  (*email).erase(i,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((*email)[i]==<span class="string">'+'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    (*email).erase(i,(*email).find(<span class="string">'@'</span>)-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(emails.begin(),emails.end());</span><br><span class="line">        emails.erase(unique(emails.begin(), emails.end()), emails.end());</span><br><span class="line">        <span class="keyword">return</span> emails.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>My new Post</title>
    <url>/2017/09/21/My-new-Post.html</url>
    <content><![CDATA[<blockquote>
<p>a test</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>MIT 6.NULL(一) Course overview + the shell</title>
    <url>/2020/05/27/MIT-6-NULL-one-Course-overview-plus-the-shell.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://missing-semester-cn.github.io/2020/course-shell/" target="_blank" rel="noopener">第一章</a>主要介绍课程概览，shell的一些基础知识。<br><a id="more"></a><br>课程分为11个时长一小时的讲座，每次围绕一个特定主题。第一次课程主要介绍了shell的使用，这是计算机的一个对外接口，这次课程介绍的许多工具都要通过shell来操作。</p>
<h3 id="主题-1-The-Shell"><a href="#主题-1-The-Shell" class="headerlink" title="主题 1: The Shell"></a>主题 1: The Shell</h3><h4 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h4><p>图形界面等交互式接口会限制我们对计算机的操作，比如无法在GUI上点击一个不存在的按钮。所以需要用到最根本的文字接口：<strong>Shell</strong>。大部分<strong>Shell</strong>的核心功能都是：<code>它允许你执行程序，输入并获取某种半结构化都输出。</code>课程中使用<code>Bourne Again SHell</code>, 简称 <code>“bash”</code>。</p>
<h4 id="shell使用"><a href="#shell使用" class="headerlink" title="shell使用"></a>shell使用</h4><p>这里我通过虚拟机安装的ubuntu系统完成课程中的各个实验。首先打开终端，有提示符</p>
<blockquote>
<p><code>wuyunjie@ubuntu:~$</code> </p>
</blockquote>
<p>这是shell最主要的文本接口。它告诉你，当前登陆用户是<code>wuyunjie</code>，主机名是 <code>missing</code> 并且当前的工作目录（”current working directory”）或者说当前所在的位置是<code>~</code> (表示 “home”)。 <code>$</code>符号表示您现在的身份不是<code>root</code>用户。可以在其中输入 <em>命令</em> ，命令最终会被shell解析。课程用到的例子如下：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_introduction.png" alt="Shell Introduction"></p>
<p>首先执行了 <code>date</code> 程序，打印出当前的日前和时间。然后，shell等待输入其他命令。</p>
<p>可以在执行命令的同时向程序传递 <code>参数</code>，比如<code>echo hello</code>中，<code>hello</code>是指定输入给<code>echo</code>程序的参数。shell基于<strong>空格</strong>分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），要么用使用单引号，双引号将<code>包含空格的参数</code>包裹起来，要么使用转义符号<code>\</code>进行处理(My\ Photos)。</p>
<p>shell其实也是一个编程环境，它具备<code>变量、条件、循环和函数</code>。当在shell中执行命令时，实际上是在<code>执行一段shell可以解释执行的简短代码</code>。如果要求shell执行某个指令，但是该指令并不是shell所了解的编程关键字，那么它会去查询 <em>环境变量</em> <code>$PATH</code>，它会列出当shell接到某条指令时，进行程序搜索的路径。要确定某个程序名代表的是哪个具体的程序(程序的路径)，可以使用 <code>which</code> 命令。</p>
<h4 id="shell中的路径"><a href="#shell中的路径" class="headerlink" title="shell中的路径"></a>shell中的路径</h4><p>shell中的路径是一组<em>被分割的目录</em>，在 Linux 和 macOS 上使用 <code>/</code> 分割，而在Windows上是 <code>\</code> 。路径 <code>/</code> 代表的是系统的根目录，在Windows上每个盘都有一个根目录（例如： C:\）。</p>
<p>Linux文件系统中如果某个路径以 <code>/</code> 开头，那么它是一个 <em>绝对路径</em>，其他的都术语 <em>相对路径</em>。相对路径是指相对于<em>当前工作目录</em>的路径，当前工作目录可以使用 <code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code> 命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录。</p>
<p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令。大多数的命令接受<em>标记和选项</em>，它们以 <code>-</code> 开头。通常，在执行程序时使用 <code>-h</code> 或 <code>--help</code> 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_path.png" alt="Shell Path"></p>
<p><code>ls -l</code>命令可以打印出更加详细地列出目录下文件或文件夹的信息。</p>
<ol>
<li>首先，本行第一个字符 <code>d</code> 表示是一个目录。</li>
<li>然后接下来的九个字符，每三个字符 (<code>rwx</code>).构成一组。它们分别代表了<code>文件所有者</code>，<code>用户组</code>以及<code>其他所有人</code>具有的权限。其中 <code>-</code> 表示该用户不具备相应的权限，<code>w</code>表示”<em>可修改</em>“，<code>x</code>表示“<em>可执行</em>”，<code>r</code>表示”<code>可读</code>“。</li>
</ol>
<p>还有一些比较常用的命令：<code>mv</code> （用于重命名或移动文件）、 <code>cp</code> (拷贝文件)以及 <code>mkdir</code> (新建文件夹)。可以使用 <code>man</code> 查阅某条命令的文档（用户手册），比如<code>man ls</code>。</p>
<h4 id="“流”和”管道”"><a href="#“流”和”管道”" class="headerlink" title="“流”和”管道”"></a>“流”和”管道”</h4><h5 id="流"><a href="#流" class="headerlink" title="流"></a>流</h5><p>在shell中，程序有两个主要的“流”：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ol>
<li>当程序尝试读取信息时，它们会从输入流中进行读取；</li>
<li>当程序打印信息时，它们会将信息输出到输出流中。<br>通常，一个程序的输入输出流都是终端。我们也可以重定向这些流！</li>
</ol>
<p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件。还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_stream.png" alt="Shell Stream"></p>
<h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>使用管道（ <em>pipes</em>），能够更好的利用文件重定向。<code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_pipe.png" alt="Shell Pipe"></p>
<p>可以发现 <code>&gt;</code> 会将之后的单词视为文件名导致，是文件上的重定向。而 <code>|</code> 可以是不同程序之间的重定向。之前总感觉这个地方很混乱，也没仔细深究，现在也算补了一个坑。</p>
<h4 id="功能全面又强大的工具"><a href="#功能全面又强大的工具" class="headerlink" title="功能全面又强大的工具"></a>功能全面又强大的工具</h4><p>对于大多数的类Unix系统，<code>根用户</code>（<code>root</code>用户）是非常特殊的。根用户<strong>几乎不受任何限制</strong>，他可以创建、读取、更新和删除系统中的任何文件。当遇到<code>拒绝访问（permission denied）</code>的错误时，通常是因为必须是根用户才能操作。</p>
<blockquote>
<p>通常在我们并不会以根用户的身份直接登陆系统，因为这样可能会因为某些错误的操作而破坏系统。取而代之的是我们会在需要的时候使用 <code>sudo</code> 命令。顾名思义，它的作用是可以以 <code>su</code>（<code>super user</code> 或 <code>root</code>的简写）的身份 <strong>do</strong> 一些事情。 </p>
</blockquote>
<p>比如有一件事情是必须作为根用户才能做的，那就是<strong>Linux</strong>下向 <code>sysfs</code> 文件写入内容。系统被挂在在 <code>/sys</code> 下，<code>sysfs</code> 文件则暴露了一些内核（kernel）参数。 因此不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。</p>
<p>课程里那个改屏幕亮度的例子没实现，不知道是不是由于虚拟机配置的关系，这里直接把他的内容摘过来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo find -L /sys/class/backlight -maxdepth 2 -name <span class="string">'*brightness*'</span></span></span><br><span class="line">/sys/class/backlight/thinkpad_screen/brightness</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /sys/class/backlight/thinkpad_screen</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo <span class="built_in">echo</span> 3 &gt; brightness</span></span><br><span class="line">An error occurred while redirecting file 'brightness'</span><br><span class="line">open: Permission denied</span><br></pre></td></tr></table></figure>
<p>尽管用了<code>sudo</code>，但仍然报错了。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过shell执行的，而不是被各个程序单独执行。 <code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， shell在设置 <code>sudo echo</code> 前尝试打开 <code>brightness</code> 文件并写入，但是系统拒绝了shell的操作因为此时shell不是根用户。可以将上述操作修改为 <code>echo 3 | sudo tee brightness</code>，打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。</p>
<h3 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h3><ol>
<li>前面1-7还好，是对shell的一个熟悉。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_exercise.png" alt="Shell exercise1"></p>
<p>主要简单了解了一下<code>shebang</code>，即在脚本开头由字符数字符号和感叹号（<code>＃!</code>）组成的字符序列。当使用带有<code>Shebang</code>的文本文件时，程序加载机制会将文件的其余行解析为解释器指令。加载程序执行指定的解释程序，将尝试运行脚本时最初使用的路径作为参数传递给它，以便程序可以将文件用作输入数据。</p>
<p><code>shebang</code> 解释器指令的形式如下：</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!interpreter [optional-arg]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>interpreter</code>是解释器的绝对路径，<code>optional-arg</code>是表示单个参数的字符串，可选。</p>
<ol>
<li>8题需要查到<em>最后更改日期信息</em>，并且将其写入文件，这里主要就是如何找到<code>last-modified</code>这一行。刚开始使用<code>find</code>，但它适用于查找文件，查找文本更多用的<code>grep</code>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_exercise2.png" alt="Shell exercise2"></p>
]]></content>
      <categories>
        <category>MIT课程</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>MIT</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.NULL: The Missing Semester of Your CS Education 学习</title>
    <url>/2020/05/27/MIT-6-NULL-The-Missing-Semester-of-Your-CS-Education-Learning.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近开始学习一下<code>MIT</code>的一门课程：<a href="https://missing.csail.mit.edu/" target="_blank" rel="noopener">6.NULL: The Missing Semester of Your CS Education</a>。主要是讲了一些Linux上常用的工具。在这个系列课程中，<code>讲授命令行、强大的文本编辑器的使用、使用版本控制系统提供的多种特性等等</code>。<br><a id="more"></a><br>最初是在知乎上一篇博客<a href="https://zhuanlan.zhihu.com/p/139361685" target="_blank" rel="noopener">6.NULL：恨不相逢“未嫁时”</a>上看见的，确实有许多Linux的工具在编程时可以让起到事半功倍的效果，刚好MIT有这样一门课程可以统一的学习了解一下。写这系列博客，一方面做一个学习笔记，另一方面也督促一下我的学习进度，实在太懒了，又有一些乱七八糟的事情，就慢慢开始学习吧。</p>
<h3 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h3><p>课程内容并不算多，看课程日常表总共有十一章，每天一章。借用知乎博客上的介绍，这门课程内容主要涉及了<code>一些好用（能大大提高生产力）的工具，如terminal、编辑器editor、tmux、profiler、数据处理工具(如awk, sed, grep, perl）等等</code>，都是一些很实用的工具，经常会被用到。课程上主要是告诉你这些工具是做什么的、能实现什么样的事情，并给了一些简单的使用示例，而如果你想要去深入地了解这些工具，课程的notes则提供了一些资料供你阅读。而且这是一门需要结合实际操作的课程，因为都是工具嘛，不用的话也就没啥用了。好了，开始了！！</p>
<h3 id="笔记索引"><a href="#笔记索引" class="headerlink" title="笔记索引"></a>笔记索引</h3><p>下面是学习过程中，每次课程的一些笔记和实战演练，不过其实官网上的介绍已经有许多了。</p>
<blockquote>
<ol>
<li><a href="../../../2020/05/27/MIT-6-NULL-one-Course-overview-plus-the-shell.html">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
<li><a href=".">MIT 6.NULL(一) Course overview + the shell</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>MIT课程</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>MIT</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark学习-Spark程序基本运行流程</title>
    <url>/2019/11/16/Spark-learning-record--program-running-process.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>刚好最近学习大数据需要运行简单的Spark算法，就顺便记录一下Spark程序基本上是怎么运行的，这里就不涉及那些理论或者API的用法了。只是说怎么把程序跑起来<br><a id="more"></a></p>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><p>以做的线性回归算法为例(只做了线性回归<code>-_-||</code>)，主要步骤如下：</p>
<blockquote>
<ol>
<li><p>编写 Spark 程序，这里涉及到一些 Spark 语法，暂时没看懂，以后系统学习的时候再慢慢深入</p>
</li>
<li><p>将实验数据传到 HDFS 上，配置的 Spark 基于 Hadoop 的 HDFS 运行，所以 Spark 直接访问的是 HDFS 上的数据，不能访问到本地。</p>
</li>
<li><p>将程序(调用<code>pyspark</code>的<code>.py</code>代码)提交到集群执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">spark-submit --master spark://host:port program.py</span><br></pre></td></tr></table></figure>
<p>查阅资料 Spark 还有多种运行模式，以后好好学一学(拖延症，不知道啥时候能开始学了)<br>HDFS 的主要操作有以下： </p>
</li>
</ol>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">hdfs dfs -help</td>
<td style="text-align:left">--查看hdfs帮助</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -ls folder</td>
<td style="text-align:left">--查看目录文件</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -put sourcepath savepath</td>
<td style="text-align:left">--hdfs上传文件，-f 覆盖已有文件；-p 保留原文件属性</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -get sourcepath savepath</td>
<td style="text-align:left">--hdfs下载文件</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -mkdir -p /output/dirname</td>
<td style="text-align:left">--创建多级目录</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -touchz /input/filename</td>
<td style="text-align:left">--创建文件filename</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -cat /input/filename</td>
<td style="text-align:left">--查看文件filename内容</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -du -s /input</td>
<td style="text-align:left">--查看所有文件大小和字节大小</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -cp /sourcefile /targetfile</td>
<td style="text-align:left">--复制文件</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -rm -R /directory</td>
<td style="text-align:left">--删除文件夹，-R循环删除文件夹里面的文件</td>
</tr>
<tr>
<td style="text-align:left">hdfs dfs -mv /user/root/.Trash/Current/filename /filename</td>
<td style="text-align:left">--找回删除文件</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>这是一些较为常用的命令，具体其它指令可以查看<code>hdfs dfs -help</code>可以发现和<code>Linux</code>下文件系统的指令很相似，大部分指令的功能基本相同，只是增加了一些有分布式系统特性的指令，比如<code>-put</code>等。</p>
</blockquote>
<p>参考：</p>
<blockquote>
<ul>
<li><a href="https://www.cnblogs.com/zengming/p/10306706.html" target="_blank" rel="noopener">常用HDFS操作命令</a></li>
<li><a href="https://www.cnblogs.com/qiuhong10/p/8476635.html" target="_blank" rel="noopener">Spark多种运行模式</a></li>
<li><a href="https://blog.csdn.net/roguesir/article/details/83317059" target="_blank" rel="noopener">【PySpark学习笔记三】spark-submit命令详解</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text3 删除 Markdown Editing 插件后启动报错</title>
    <url>/2019/11/16/Sublime-Text3-removes-the-Markdown-Editing-plugin-leads-to-an-error.html</url>
    <content><![CDATA[<h3 id="Sublime-Text3启动报错"><a href="#Sublime-Text3启动报错" class="headerlink" title="Sublime Text3启动报错"></a>Sublime Text3启动报错</h3><p><code>Sublime Text3</code> 之前装了 <code>Markdown Editing</code> 插件，由于嫌弃界面太难看把他卸载了，之后再次打开<code>.md</code>格式的文件，一直报下面这个错误。<br><a id="more"></a><br><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>Error loading colour scheme Packages/MarkdownEditing/MarkdownEditor.tmTheme: Error parsing plist xml: Failed to open file In file "Packages/MarkdownEditing/MarkdownEditor.tmTheme"</span><br></pre></td></tr></table></figure></p>
<p>查阅网上有方法说<code>set syntax:html</code> 可以解决，但这好像不能根本解决问题，依旧会弹出报错弹窗。后面找到文件夹<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Usersname\AppData\Roaming\Sublime Text 3\Packages\User</span><br></pre></td></tr></table></figure><br>发现存在卸载残留文件，即 <code>Markdown Editing</code> 的配置文件，将其删除后文集解决，<code>Sublime Text3</code>正常工作。类似的还有一个<code>Error trying to parse settings</code>的报错，也是配置文件的原因，找到报错显示的对应配置文件修改一下就解决了。</p>
]]></content>
      <categories>
        <category>Sublime Text3</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>Sublime Text3</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/09/20/Hello-World.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Hexo</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>pip/conda install 由于目标计算机积极拒绝，无法连接</title>
    <url>/2019/11/23/Pip-conda-install-unable-to-connect-bug.html</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>之前遇到一个困扰已久的问题, 使用 <code>conda/pip install</code> 安装库时一直显示代理有问题, <code>由于目标计算机积极拒绝，无法连接</code>。<a id="more"></a><br>一开始一直以为是我的代理设置出现了问题，改了很多次系统代理设置，但一直没有效果。而且这个问题也使得我的谷歌浏览器无法实现科学上网。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>最后终于通过修改注册表解决了这个问题，主要操作如下：</p>
<blockquote>
<ol>
<li>通过<code>Win+R</code>快捷键，输入<code>regedit</code>，打开注册表编辑器</li>
<li>找到<code>HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Internet Settings</code></li>
<li>将以 <strong>Proxy</strong> 开头的条目都删除</li>
</ol>
</blockquote>
<p>之后一切就都回复正常了。这个改注册表的方法还挺万用的，有时候会出现无法连上网但是无法访问百度的问题，也可通过删除<code>HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Internet Settings/Connections</code>下的相关条目来解决。</p>
<p>应该是由于科学上网后系统代理出现啥Bug，通过删除注册表可以实现初始化吧。</p>
<h3 id="查看文献"><a href="#查看文献" class="headerlink" title="查看文献"></a>查看文献</h3><blockquote>
<ul>
<li><a href="https://blog.csdn.net/lezeqe/article/details/94913345" target="_blank" rel="noopener">解决：pip install 由于目标计算机积极拒绝，无法连接</a></li>
<li><a href="https://blog.csdn.net/weixin_43323092/article/details/82962023" target="_blank" rel="noopener">解决系统代理被篡改/pip提示“目标计算机积极拒绝，无法连接”的方法</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--709. To Lower Case</title>
    <url>/2019/03/28/LeetCode--709-To-Lower-Case.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><blockquote>
<p>Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.<br><a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>Input: “Hello”<br>Output: “hello”</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>Input: “here”<br>Output: “here”</p>
</blockquote>
<p><strong>Example 3:</strong></p>
<blockquote>
<p>Input: “LOVELY”<br>Output: “lovely”</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题主要用来熟悉下transform(STL transform)函数</p>
<blockquote>
<p>transform() 可以将函数应用到序列的元素上，并将这个函数返回的值保存到另一个序列中，它返回的迭代器指向输出序列所保存的最后一个元素的下一个位置。调用方法如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryOperator</span> &gt; </span></span><br><span class="line"><span class="class">	<span class="title">OutputIterator</span> <span class="title">transform</span> ( <span class="title">InputIterator</span> <span class="title">first1</span>,  // 源容器的起始地址 </span></span><br><span class="line"><span class="class">							  <span class="title">InputIterator</span> <span class="title">last1</span>,    // 源容器的终止地址 </span></span><br><span class="line"><span class="class">							  <span class="title">OutputIterator</span> <span class="title">result</span>,  // 目标容器的起始地址 </span></span><br><span class="line"><span class="class">							  <span class="title">UnaryOperator</span> <span class="title">op</span> );</span>     <span class="comment">// 函数指针 </span></span><br><span class="line"><span class="comment">// typedef 目标容器元素类型 (*UnaryOperator)(源容器元素类型); </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">BinaryOperator</span> &gt; </span></span><br><span class="line"><span class="class">	<span class="title">OutputIterator</span> <span class="title">transform</span> ( <span class="title">InputIterator1</span> <span class="title">first1</span>,     // 源容器1的起始地址 </span></span><br><span class="line"><span class="class">							  <span class="title">InputIterator1</span> <span class="title">last1</span>,       // 源容器1的终止地址 </span></span><br><span class="line"><span class="class">							  <span class="title">InputIterator2</span> <span class="title">first2</span>,      // 源容器2的起始地址，元素个数与1相同 </span></span><br><span class="line"><span class="class">							  <span class="title">OutputIterator</span> <span class="title">result</span>,      // 目标容器的起始地址，元素个数与1相同 </span></span><br><span class="line"><span class="class">							  <span class="title">BinaryOperator</span> <span class="title">binary_op</span> );</span> <span class="comment">// 函数指针 </span></span><br><span class="line"><span class="comment">// typedef 目标容器元素类型 (*BinaryOperator)(源容器1元素类型，源容器2元素类型);</span></span><br></pre></td></tr></table></figure>
<p>所以transform结合大小写转换函数tolower，只需要一行即可完成任务</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toLowerCase</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        transform(str.begin(),str.end(),str.begin(),::<span class="built_in">tolower</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo学习记录--基本操作</title>
    <url>/2019/11/11/hexo-learning-record--basic-operation.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>终于决定重新开始写博客了。这次一定得坚持下来，写写学习进度，定期自我总结。太久没写博客了，基本操作又给忘了，这次就索性先从怎么写博客开始，把基本指令都记录下来，省得下次半途而废回来的时候又全忘了到处查。</p>
</blockquote>
<a id="more"></a>
<h3 id="Hexo写博客的基本操作"><a href="#Hexo写博客的基本操作" class="headerlink" title="Hexo写博客的基本操作"></a>Hexo写博客的基本操作</h3><h4 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h4><blockquote>
<p>最重要的就是写文章部分了，首先了解如何新建一篇文章。Hexo博客建立开始，就自带一篇 <a href="http://wuyunjie.top/2017/09/20/hello-world/">Hello World</a> 简易教程。新建文章主要用下面这条命令：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里可以指定文章的布局(layout)，默认为 <code>post</code>。这样所有的文章都会以<code>md</code>形式在<code>source</code>文件夹下的<code>_post</code>文件夹中被创建，之后我们就可以愉快的编辑文章了，这是一个<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">markdown的学习文档</a>。</p>
</blockquote>
<h4 id="添加分类页"><a href="#添加分类页" class="headerlink" title="添加分类页"></a>添加分类页</h4><blockquote>
<p>新建一个分类页面，命名为 <code>categories</code>。命令如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page [categories]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以将 <code>categories</code> 改为自己需要的新页面，会在 <code>source</code> 文件夹下新建一个对应名为<code>categories</code>的文件夹。然后编辑主题的 <code>_config.yml</code>，即<code>themes/next</code>下的配置文件，区别于网站根目录下的配置文件，将 <code>menu</code> 中的 <code>categories: /categories || th</code> 注释去掉，在菜单中添加链接。</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure>
<h4 id="文章分类归档"><a href="#文章分类归档" class="headerlink" title="文章分类归档"></a>文章分类归档</h4><blockquote>
<p>当然也可以个文章进行分类归档，在编辑文章时，为文章添加 <code>tags</code> 和 <code>categories</code>即可。<br><figure class="highlight mkdown"><table><tr><td class="code"><pre><span class="line">title: a title</span><br><span class="line">date: a date</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">    - </span>tag1</span><br><span class="line"><span class="bullet">    - </span>tag2</span><br><span class="line"><span class="bullet">    - </span>tag3</span><br><span class="line">categories: a category</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a>编辑工具</h4><blockquote>
<p>为了方便，感觉又两个在线编辑<code>markdown</code>文档的工具挺好用的。</p>
<blockquote>
<ol>
<li><a href="http://markdown.xiaoshujiang.com/" target="_blank" rel="noopener">小书匠</a></li>
<li><a href="https://www.mdeditor.com/" target="_blank" rel="noopener">MdEditor</a></li>
</ol>
</blockquote>
<p>当然也可以配置离线工具，但是不太熟。我配了个<code>sublime</code>的，感觉不好看，也不怎么好用。</p>
</blockquote>
<h3 id="生成和部署"><a href="#生成和部署" class="headerlink" title="生成和部署"></a>生成和部署</h3><blockquote>
<p>当编辑完一个博客页面后，我们需要生成静态页面。可以用如下指令。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g #生成</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们不需要急于将页面提交到<code>github</code>，可以先在本地预览效果进行调整，等到达到满意后，再部署到<code>github</code>。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s #启动服务, 通过 `localhost:4000`访问本地页面</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一切准备就绪后，就可以提交了。然后通过自己的域名就可以成功访问博客。不过这一步可能会存在延迟，不会立即看到效果。应该是由于缓存的关系。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d #上传部署到github</span><br></pre></td></tr></table></figure>
<h3 id="常用命令和缩写"><a href="#常用命令和缩写" class="headerlink" title="常用命令和缩写"></a>常用命令和缩写</h3><blockquote>
<p>常用命令有以下几个</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new "postName" #新建文章</span><br><span class="line">hexo new page "pageName" #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一些缩写形式</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>
<blockquote>
<p>至此我们可以开始愉快的玩耍了。</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p>[1] <a href="https://www.jianshu.com/p/1bcad7700c46" target="_blank" rel="noopener">使用hexo搭建github博客</a><br>[2] <a href="https://www.cnblogs.com/fengzheng/p/8031518.html" target="_blank" rel="noopener">Hexo + github 打造个人博客</a><br>[3] <a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">使用hexo+github搭建免费个人博客详细教程</a><br>[4] <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo 指令</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Hexo</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-2-替换空格</title>
    <url>/2021/04/20/JZ2-replace-spaces.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成<code>&quot;%20&quot;</code>。例如，当字符串为<code>We Are Happy</code>，则经过替换之后的字符串为<code>We%20Are%20Happy</code>。<br><a id="more"></a></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:   “We Are Happy”<br>返回值: “We%20Are%20Happy”</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题挺简单的，就是逐个判断String数组的字符，然后基于拼接构建出要求的字符串。也有方法直接调用内置的替换函数，不知道为何难度为<strong>较难</strong>，可能还有特殊的优化解。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li><p>解法1 暴力求法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">                result += <span class="string">"%20"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2 调用 <code>String.replaceAll()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">   <span class="keyword">return</span> s.replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法3 调用 <code>Spring.split()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        String[] strs = s.split(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">" "</span>.equals(str))</span><br><span class="line">                sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            sb.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol>
<li>String、StringBuffer和StringBuilder</li>
</ol>
<ul>
<li>String<br><code>String</code>类是<strong>不可变</strong>类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。通过一个字符串对象a的内存存储空间图对String类的不可变性理解。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ2/String.png" alt="`String`类不可变"></p>
<p>再次给a赋值时，并不是对原来堆中实例对象进行重新赋值，而是生成一个新的实例对象，并且指向“456”这个字符串，a则指向最新生成的实例对象，<em>之前的实例对象仍然存在，如果没有被再次引用，则会被垃圾回收</em>。</p>
<ul>
<li>StringBuffer<br><code>StringBuffer</code>对象则代表一个字符序列<strong>可变</strong>的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的<code>append()</code>、<code>insert()</code>、<code>reverse()</code>、<code>setCharAt()</code>、<code>setLength()</code>等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的<code>toString()</code>方法将其转换为一个String对象。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ2/StringBuffer.png" alt="`StringBuffer`类"></p>
<p>字符串连接的情况，方便和直接的方式是通过”+”符号来实现，但是这种方式达到目的的效率比较低，且<em>每执行一次都会创建一个String对象</em>，<strong>即耗时，又浪费空间</strong>。使用StringBuilder类就可以避免这种问题的发生</p>
<ul>
<li>StringBuilder<br><code>StringBuilder</code>类也代表<strong>可变</strong>字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：<strong>StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高</strong>。StringBuffer类中的方法都添加了<code>synchronized</code>关键字，也就是给这个方法添加了一个锁，用来保证线程安全。</li>
</ul>
<p><strong>Java9改进了字符串</strong>（包括String、StringBuffer、StringBuilder）的实现。在Java9以前字符串采用<code>char[]</code>数组来保存字符，因此字符串的每个字符占<code>2</code>字节；而Java9的字符串采用<code>byte[]</code>数组再加一个<code>encoding-flag</code>字段来保存字符，因此字符串的每个字符只占<code>1</code>字节。所以Java9的字符串更加节省空间，字符串的功能方法也没有受到影响。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://blog.csdn.net/csxypr/article/details/92378336" target="_blank" rel="noopener">String、StringBuffer和StringBuilder的区别</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-1-二维数组中的查找</title>
    <url>/2021/04/02/JZ1-Lookup-in-a-two-dimensional-array.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><a id="more"></a></p>
<blockquote>
<p>[<br>  [1,2,8,9],<br>  [2,4,9,12],<br>  [4,7,10,13],<br>  [6,8,11,15]<br>]</p>
</blockquote>
<p>给定 target = 7，返回 true。<br>给定 target = 3，返回 false。</p>
<p><strong>示例1:</strong></p>
<blockquote>
<p>输入:   7, [[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]<br>返回值: true<br>说明:   存在7，返回true</p>
</blockquote>
<p><strong>示例2:</strong></p>
<blockquote>
<p>输入:   3, [[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]<br>返回值: false<br>说明:   不存在3，返回false</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题考察的应该是二维数组上的二分查找，因为数组是按从顺序排列的，所有很容易想到将一维数组的思想扩展到二维数组上。但这种思想似乎并不可行，在实现过程中遇到了难度。</p>
<h4 id="方法1-暴力求解"><a href="#方法1-暴力求解" class="headerlink" title="方法1: 暴力求解"></a>方法1: 暴力求解</h4><p>暴力求解法思路很直接，直接将数组中所有数据都遍历一遍，自然可以判断<code>target</code>是否存在于数组中。但该方法复杂度为<code>O(n^2)</code>，即最坏情况下所有元素都需要访问一次。</p>
<h4 id="方法2-二分查找"><a href="#方法2-二分查找" class="headerlink" title="方法2: 二分查找"></a>方法2: 二分查找</h4><p>暴力求解方法未用到数组有序这一信息，针对数组有序自然想到二分查找的方法。这里基于题解[1]复习一下二分查找的思想。假设目标tar在arr[1]处，那么二分过程就是：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ1/Binary_Search.png" alt="Binary Search"></p>
<blockquote>
<p>1）设初始值：定义一个二分的开始下标为l，结束下标为r;<br>2）二分一半，中间位置为 <code>mid = l + （（r - l) &gt;&gt; 1)</code>(val&gt;&gt;1表示<code>val</code>右移一位相当于<code>val／2</code>)，相当于 <code>l+(r-l)/2</code>，这样的写法是<strong>防止溢出</strong>。如果写成 <code>mid = （l+r)/2;</code> l+r可能会溢出;<br>3) 如果 <code>tar == arr[mid]</code>，说明找到tar;<br>4）如果 <code>tar &gt; arr[mid]</code>, 说明tar在区间 <code>[mid+1, r]</code> 中，<code>l = mid + 1</code>;<br>5）如果 <code>tar &lt; arr[mid]</code>, 说明tar在区间 <code>[l, mid-1]</code> 中, <code>r = mid - 1</code>;</p>
</blockquote>
<p>最初的思想是依样在右上角开始，实现二分查找，思路稍微接近正确的求解，但二分后仍然存在问题，实现上不简洁。如果从左上位置开始二分，每次二分之后，难以确定下一次二分的走向，整个二维数组上顺序被打乱。最开始我的思路是按行从大到小二分，按列从小到大二分，每次将范围固定到某一个片段区域，但实际实现时逻辑不够清晰，代码越写越乱。当然可能仍然是可以按这样的思想实现的，只是我太菜了写不出来。</p>
<p>按照最终答案的思想，也是将二分值固定到右上或者左下的元素上，实现从两个方向不断缩小值所在的范围，这种思想实现上比我之前想的简洁太多了。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ1/Binary_Search_BinArr.png" alt="Binary Search"></p>
<blockquote>
<p>1）设初始值为右上角元素;<br>2）二分一半，中间位置为 <code>mid = l + （（r - l) &gt;&gt; 1)</code>(val&gt;&gt;1表示<code>val</code>右移一位相当于<code>val／2</code>)，相当于 <code>l+(r-l)/2</code>，这样的写法是<strong>防止溢出</strong>。如果写成 <code>mid = （l+r)/2;</code> l+r可能会溢出;<br>3) 如果 <code>val == target</code>, 直接返回;<br>4）如果 <code>tar &gt; val</code>, 说明 <code>target</code> 在更大的位置，val左边的元素显然都是 <code>&lt; val &lt; tar</code>，说明第 0 行都是无效的，所以val下移到arr[1][5];<br>5）如果 <code>tar &lt; val</code>, 说明 <code>target</code> 在更小的位置，val下边的元素显然都是 <code>&gt; val &gt; tar</code>，说明第 5 列都是无效的，所以val左移到arr[0][4];</p>
</blockquote>
<p>时间复杂度：<code>O(m+n)</code> ，其中m为行数，n为列数，最坏情况下，需要遍历m+n次。</p>
<h4 id="方法3-双折半查找法"><a href="#方法3-双折半查找法" class="headerlink" title="方法3: 双折半查找法"></a>方法3: 双折半查找法</h4><p>参考自题解[2]，该思路与我最开始的思路很相似，看了之后发现还是可以实现的，果然是我太菜了。最坏情况下时间复杂度为<code>O(M * logN)</code></p>
<blockquote>
<p>1）在二维数组分为上下左右四个边界top，bottom，left，right;<br>2）对上边界<code>top</code>进行折半查找，假设终止点为 <code>E</code>，则可以将二维数组位于终止点<code>E</code>右边的矩形<code>Rr</code>排除，因为终止点<code>E</code>小于其右边相邻的元素<code>E+1</code>，而<code>E+1</code>是右边矩形Rr的最小元素(左上元素);<br>3) 对下边界<code>bottom</code>折半，可以排除二维数组位于终止点<code>E</code>左边的矩形<code>Rl</code>排除;<br>4）对左边界<code>left</code>折半，可以排除二维数组位于终止点<code>E</code>下边的矩形<code>Rb</code>排除;<br>5）对右边界<code>right</code>折半，可以排除二维数组位于终止点<code>E</code>上边的矩形<code>Rt</code>排除;<br>6) 对由新边界组成的矩形重复以上操作，直到范围缩小为只有一个元素</p>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li><p>解法1 暴力求法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] vec: array)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: vec)&#123;</span><br><span class="line">                <span class="keyword">if</span> (num == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法2 两遍哈希表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt; array.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target == array[row][col])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[row][col])&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法3 双折半查找法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, bottom = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sLeft = <span class="number">0</span>, sRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sTop = <span class="number">0</span>, sBottom = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt; right || top &lt; bottom)&#123;</span><br><span class="line">            <span class="comment">// 在上边界查找，缩小右边界</span></span><br><span class="line">            sLeft = left; sRight = right;</span><br><span class="line">            <span class="keyword">while</span> (sLeft &lt;= sRight) &#123;</span><br><span class="line">                mid = (sLeft + sRight) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[top][mid] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[top][mid] &lt; target)</span><br><span class="line">                    sLeft = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sRight = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; right) right = mid;</span><br><span class="line">            top++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在下边界查找，缩小左边界</span></span><br><span class="line">            sLeft = left; sRight = right;</span><br><span class="line">            <span class="keyword">while</span> (sLeft &lt;= sRight) &#123;</span><br><span class="line">                mid = (sLeft + sRight) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[bottom][mid] == target) </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[bottom][mid] &lt; target) </span><br><span class="line">                    sLeft = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    sRight = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; mid) left = mid; <span class="comment">//利用终止点缩小左边界</span></span><br><span class="line">            bottom--;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对左边界进行折半，可以缩小下边界</span></span><br><span class="line">            sTop = top; sBottom = bottom;</span><br><span class="line">            <span class="keyword">while</span> (sTop &lt;= sBottom) &#123;</span><br><span class="line">                mid = (sTop + sBottom) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[mid][left] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[mid][left] &lt; target)</span><br><span class="line">                    sTop = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sBottom = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; bottom) bottom = mid; <span class="comment">//利用终止点缩小下边界</span></span><br><span class="line">            left++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对右边界进行折半，可以缩小上边界</span></span><br><span class="line">            sTop = top; sBottom = bottom;</span><br><span class="line">            <span class="keyword">while</span> (sTop &lt;= sBottom) &#123;</span><br><span class="line">                mid = (sTop + sBottom) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[mid][right] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[mid][right] &lt; target)</span><br><span class="line">                    sTop = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sBottom = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top&lt;mid) top = mid; <span class="comment">//利用终止点缩小上边界</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (top &lt; array.length &amp;&amp; left &lt; array[<span class="number">0</span>].length &amp;&amp; array[top][left] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol>
<li>For-Each循环<br><code>For-Each</code>语句(也叫增强型的for循环)是<code>java5</code>的新特征之一，在遍历数组、集合方面，<code>foreach</code>为开发人员提供了极大的方便。但是<code>foreach</code>语句并不能完全取代<code>for</code>语句，任何的<code>foreach</code>语句都可以改写为<code>for</code>语句。值得注意的是，<code>foreach</code>并不是一个关键字，语法如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(type element: array)&#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其缺点是丢掉了索引信息，foreach只能挨个遍历数组或者集合一遍。但在可以使用foreach的地方，其简化了编程，<em>提高了代码的可读性和安全性（不用怕数组越界）</em>。foreach一般结合泛型使用。</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://blog.nowcoder.net/n/f146364d1331407080adbbb5a062e067" target="_blank" rel="noopener">二维数组中的查找</a><br>[2] <a href="https://blog.nowcoder.net/n/d332492753844d18aa4edc484e3c1318" target="_blank" rel="noopener">《剑指Offer》二维数组中的查找</a><br>[3] <a href="https://blog.csdn.net/qq_32671287/article/details/79420736" target="_blank" rel="noopener">java中foreach循环</a><br>[4] <a href="https://www.cnblogs.com/mengdd/archive/2013/01/21/2870019.html" target="_blank" rel="noopener">Java 增强型的for循环 for each</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy爬虫-基础使用</title>
    <url>/2019/11/16/scrapy-crawler--basic-use.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近大数据课需要用到爬虫爬数据，发现<code>scrapy</code>这个爬虫库还蛮好用的，记录一下它的基本用法。<br><a id="more"></a></p>
<h3 id="scrapy框架"><a href="#scrapy框架" class="headerlink" title="scrapy框架"></a><code>scrapy</code>框架</h3><p>如下是<code>scrapy</code>架构图，绿色箭头表示组件及在系统中发生的数据流。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/scrapy_architecture.png" alt="scrapy architecture"></p>
<blockquote>
<ul>
<li><strong>Scrapy Engine</strong> 控制数据流在组件中的流动，并在相应动作发生时触发事件</li>
<li><strong>调度器(Scheduler)</strong> 从引擎接受request并将他们入队，以便之后引擎请求他们时提供给引擎</li>
<li><strong>下载器(Downloader)</strong> 负责获取页面数据并提供给引擎，而后提供给spider</li>
<li><strong>Spiders</strong> 用户编写用于分析response并提取item(即获取到的item)或额外跟进的URL的类</li>
<li><strong>Item Pipeline</strong> Item Pipeline负责处理被spider提取出来的item，清理、 验证及持久化等</li>
<li><strong>下载器中间件(Downloader middlewares)</strong> 可以自定义扩展下载功能的组件(比如将滑动条拉到底部)</li>
</ul>
</blockquote>
<p>具体可以参考官网<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/architecture.html" target="_blank" rel="noopener">架构概览</a></p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>可以通过<code>scrapy</code>命令直接生成一个框架模板，主要有以下命令：</p>
<blockquote>
<ul>
<li>创建项目：scrapy startproject xxx</li>
<li>创建爬虫：scrapy genspider xxx（爬虫名） xxx.com （爬取域）</li>
<li>生成文件：scrapy crawl xxx -o xxx.type (生成 <code>type</code> 类型的文件)</li>
<li>运行爬虫：scrapy crawl XXX</li>
<li>列出所有爬虫：scrapy list</li>
<li>获得配置信息：scrapy settings [options]</li>
</ul>
</blockquote>
<p>如下是生成的一个爬虫项目的目录信息：</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/scrapy_folder.png" alt="project folder"></p>
<p>简单的爬虫主要需要修改的就是 <code>items.py</code> 和 <code>example.py</code> 文件。其它比较高端的功能暂时也没用上：</p>
<blockquote>
<p><code>items.py</code> 创建容器的地方，爬取的信息分别放到不同容器里。item是保存爬取数据的容器，使用的方法和字典差不多, 将需要提取的信息在这里定义以下就可以了<br><code>example.py</code> 爬虫文件。负责解析start_url下载的Response 对象，根据item提取数据; 如果有新的url则加入爬取队列，负责进一步处理，URL的Request 对象</p>
</blockquote>
<h3 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h3><p>我这里主要是用的 <code>Xpath</code> 来解析文件, 语法还是比较简单的, 而且容易使用, 可以在 <code>chrome</code> 内使用插件 <code>XPath Helper</code> 来在网页内调试。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/xpath.png" alt="Xpath"></p>
<p>但是有时候 <code>XPath Helper</code> 的解析语句在 <code>scrapy</code> 得到的结果不太兼容, 可以用 <code>scrapy</code> 命令行进一步调试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy shell &lt;url&gt;</span><br></pre></td></tr></table></figure><br>两者结合起来, 基本上就可以写出合理的爬虫解析语句了。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/scrapy_shell.png" alt="scrapy shell"></p>
<p>xpath具体语法可以参考<a href="https://www.w3school.com.cn/xpath/index.asp" target="_blank" rel="noopener">XPath 教程</a>, 基本上跟着调试调试就懂了。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/7dee0837b3d2" target="_blank" rel="noopener">scrapy学习</a></li>
<li><a href="https://www.jianshu.com/p/cecb29c04cd2" target="_blank" rel="noopener">爬虫框架Scrapy个人总结（详细）熟悉</a></li>
<li><a href="https://www.jianshu.com/p/6bc5a4641629" target="_blank" rel="noopener">爬虫框架Scrapy的安装与基本使用</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-4-重建二叉树</title>
    <url>/2021/04/26/JZ4-rebuild-binaryTree.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><a id="more"></a></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:   [1,2,3,4,5,6,7],[3,2,4,1,6,5,7]<br>返回值: {1,2,5,3,4,6,7}</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>考察二叉树很经典的题，需要理解前序遍历、中序遍历的方法，然后据此重建二叉树。</p>
<h4 id="二叉树的遍历方法"><a href="#二叉树的遍历方法" class="headerlink" title="二叉树的遍历方法"></a>二叉树的遍历方法</h4><blockquote>
<ol>
<li>前序遍历：根左右</li>
<li>中序遍历：左根右</li>
<li>后序遍历：左右根</li>
</ol>
</blockquote>
<p>一般使用递归方法实现遍历，在遍历过程中每个子树都可当作一颗新树递归处理。此外也可以利用栈实现非递归的遍历方法。</p>
<h4 id="方法1-递归方法"><a href="#方法1-递归方法" class="headerlink" title="方法1: 递归方法"></a>方法1: 递归方法</h4><p>对于任意一棵树，前序遍历的形式总是：</p>
<blockquote>
<p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</p>
</blockquote>
<p>中序遍历的形式总是：</p>
<blockquote>
<p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p>
</blockquote>
<p>所以在中序遍历中定位到根节点，就可以得到左子树和右子树的节点及节点数目。由此可以进一步在前序遍历结果中，分别得到左右子树。依次类推可以递归构造出子树的左右子树，知道最终左右子树都只剩一个节点，得到一颗完整的树。</p>
<blockquote>
<ol>
<li><p>在中序遍历中对根节点进行定位时，一种简单的方法是<strong>直接扫描整个中序遍历的结果并找出根节点</strong>，但这样做的时间复杂度较高。</p>
</li>
<li><p>考虑使用<code>哈希表</code>来快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，对中序遍历列表进行一遍扫描，构造出这个哈希映射。在此后构造二叉树的过程中，只需要 <code>O(1)</code> 的时间对根节点进行定位。</p>
</li>
</ol>
</blockquote>
<h4 id="方法2-非递归-迭代-方法"><a href="#方法2-非递归-迭代-方法" class="headerlink" title="方法2: 非递归(迭代)方法"></a>方法2: 非递归(迭代)方法</h4><p>根据前序遍历原理，对于前序遍历中的任意两个连续节点 <em>u</em> 和 <em>v</em>，只有两种可能的关系：</p>
<blockquote>
<ul>
<li><em>v</em> 是 <em>u</em> 的左儿子。因为在遍历到 <em>u</em> 之后，下一个遍历的节点就是 <em>u</em> 的左儿子，即 <em>v</em>；</li>
<li><em>u</em> 没有左儿子，并且 <em>v</em> 是 <em>u</em> 的某个祖先节点（或者 <em>u</em> 本身）的右儿子。<ul>
<li>如果 <em>u</em> 没有左儿子，那么下一个遍历的节点就是 <em>u</em> 的右儿子。</li>
<li>如果 <em>u</em> 没有右儿子，就会向上回溯，直到遇到第一个有右儿子（且 <em>u</em> 不在它的右儿子的子树中）的节点 <em>a</em>，那么 <em>v</em> 就是 <em>a</em> 的右儿子。</li>
</ul>
</li>
</ul>
</blockquote>
<p>用一个<code>栈 stack</code> 来维护<code>「当前节点的所有还没有考虑过右儿子的祖先节点」</code>，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，用一个<code>指针 index</code> 指向<strong>中序遍历</strong>的某个位置，初始值为 <code>0</code>。<code>index</code> 对应的节点是<code>「当前节点不断往左走达到的最终节点」</code>，这也是符合中序遍历。算法流程如下：</p>
<blockquote>
<ol>
<li><p>用一个<code>栈</code>和一个<code>指针</code>辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p>
</li>
<li><p>依次枚举前序遍历中除了第一个节点以外的每个节点。</p>
<ul>
<li>如果 <code>index</code> 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 <code>index</code>，并将当前节点作为最后一个弹出的节点的右儿子；</li>
<li>如果 <code>index</code> 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</li>
</ul>
</li>
<li>无论是哪一种情况，最后都将当前的节点入栈。</li>
</ol>
</blockquote>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li><p>解法1  递归方法(<strong>直接扫描</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> [] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startPre &gt; endPre) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == pre[startPre])&#123;</span><br><span class="line">                root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + i - startIn, in, startIn, startIn + i - <span class="number">1</span>);</span><br><span class="line">                root.right = reConstructBinaryTree(pre, startPre + i - startIn + <span class="number">1</span>, endPre, in, i + <span class="number">1</span>, endIn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法1  递归方法(<strong>哈希表</strong>)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            indexMap.put(in[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> [] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startPre &gt; endPre) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> inRoot = indexMap.get(pre[startPre]);</span><br><span class="line">        root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + inRoot - startIn, in, startIn, startIn + inRoot - <span class="number">1</span>);</span><br><span class="line">        root.right = reConstructBinaryTree(pre, startPre + inRoot - startIn + <span class="number">1</span>, endPre, in, inRoot + <span class="number">1</span>, endIn);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>解法2 迭代法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span> || pre.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> preVal = pre[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="comment">// 左子树</span></span><br><span class="line">            <span class="keyword">if</span> (node.val != in[inIndex]) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(preVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右子树</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == in[inIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(preVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol>
<li><p>思考：如果给你中序遍历序列和后序遍历序列<br>思路类似于中序遍历和前序遍历的情况，只是在从后续遍历找根节点时，从后序遍历数组末端元素开始。后序遍历的形式总是：</p>
<blockquote>
<p>[  [左子树的前序遍历结果], [右子树的前序遍历结果] ,根节点]</p>
</blockquote>
<p>伪代码表示为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设元素在数组v中，并且尾结点的下标为 root_index, first &lt; root_index &lt; last,</span></span><br><span class="line">TreeNode* build(<span class="keyword">int</span> first, <span class="keyword">int</span> last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt; last) <span class="keyword">return</span> nullptr;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(v[root_index]);</span><br><span class="line">    root-&gt;left = build(first, root_index - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = build(root_index + <span class="number">1</span>, last);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，这里中序遍历起到很重要的作用，基于中序遍历可以分隔开左右子树。而仅仅给定前序遍历和后序遍历时，是无法得到唯一子树的。比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">树1：</span><br><span class="line">        3</span><br><span class="line">       /</span><br><span class="line">      9</span><br><span class="line">     /</span><br><span class="line">    8</span><br><span class="line">   / </span><br><span class="line">  5</span><br><span class="line"> /</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">树2：</span><br><span class="line">        3</span><br><span class="line">         \</span><br><span class="line">          9</span><br><span class="line">           \</span><br><span class="line">            8</span><br><span class="line">             \</span><br><span class="line">              5</span><br><span class="line">               \</span><br><span class="line">                4</span><br></pre></td></tr></table></figure>
<p>以上这两棵特殊的树，其前序遍历，后续遍历结果都是：[3, 9, 8, 5, 4]，[4, 5, 8, 9, 3]。难以构造出唯一的树。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">力扣官方题解——重建二叉树</a></p>
</blockquote>
</li>
</ol>
<p>[2] <a href="https://blog.nowcoder.net/n/c56eeb5b1845432a903db1c3c0cbc80a" target="_blank" rel="noopener">[编程题]重建二叉树</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 GitHub 下载单个文件夹</title>
    <url>/2019/11/16/githun-download-single-folder.html</url>
    <content><![CDATA[<p>在<code>GitHub</code>上浏览开源项目时或者在查看自己的仓库时，<a id="more"></a>我们可能只需要其中单独几个文件夹下的内容，而不需要整个仓库。但一般<code>GitHub</code>只能克隆整个仓库。可以通过一个在线网站<code>DownGit</code>自动打包下载对应文件夹：</p>
<blockquote>
<p><a href="https://www.itsvse.com/downgit/#/home" target="_blank" rel="noopener">DownGit</a></p>
</blockquote>
<p>只需要找到仓库中对应文件夹的url，输入之后，点击 download 自动打包下载。<br><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/DownGit.PNG" alt="DownGit"></p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>第一周LeetCode</title>
    <url>/2019/03/28/first-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第一周LeetCode刷题记录"><a href="#第一周LeetCode刷题记录" class="headerlink" title="第一周LeetCode刷题记录"></a>第一周LeetCode刷题记录</h2><a id="more"></a>
<p>1.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%941-Two-Sum/" title="LeetCode——1. Two Sum">LeetCode——1. Two Sum</a><br>2.<a href="http://wuyunjie.top/2019/03/28/LeLeetCode%E2%80%94%E2%80%942-Add-Two-Numbers/" title="LeetCode——2. Add Two Numbers">LeetCode——2. Add Two Numbers</a><br>3.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%943-Longest-Substring-Without-Repeating-Characters/" title="LeetCode——3. Longest Substring Without Repeating Characters">LeetCode——3. Longest Substring Without Repeating Characters</a><br>4.<a href="http://wuyunjie.top/2019/03/28/LeLeetCode%E2%80%94%E2%80%947-Reverse-Integer/" title="LeetCode——7. Reverse Integer">LeetCode——7. Reverse Integer</a><br>5.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94709-To-Lower-Case/" title="LeetCode——709. To Lower Case">LeetCode——709. To Lower Case</a><br>6.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94771-Jewels-and-Stones/" title="LeetCode——771. Jewels and Stones">LeetCode——771. Jewels and Stones</a><br>7.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94929-Unique-Email-Addresses/" title="LeetCode——929. Unique Email Addresses">LeetCode——929. Unique Email Addresses</a></p>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>第三周LeetCode</title>
    <url>/2019/04/11/third-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第三周LeetCode刷题记录"><a href="#第三周LeetCode刷题记录" class="headerlink" title="第三周LeetCode刷题记录"></a>第三周LeetCode刷题记录</h2><a id="more"></a>
<ol>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-10-Regular-Expression-Matching/" title="LeetCode--10. Regular Expression Matching">LeetCode—10. Regular Expression Matching</a></li>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-13-Roman-to-Integer/" title="LeetCode--13. Roman to Integer">LeetCode—13. Roman to Integer</a></li>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-14-Longest-Common-Prefix/" title="LeetCode--14. Longest Common Prefix">LeetCode—14. Longest Common Prefix</a></li>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-15-3Sum/" title="LeetCode--15. 3Sum">LeetCode—15. 3Sum</a></li>
<li><a href="http://wuyunjie.top/2019/04/09/LeetCode-16-3Sum-Closest/" title="LeetCode--16. 3Sum Closest">LeetCode—16. 3Sum Closest</a></li>
<li><a href="http://wuyunjie.top/2019/04/10/LeetCode-17-Letter-Combinations-of-a-Phone-Number/" title="LeetCode--17. Letter Combinations of a Phone Number">LeetCode—17. Letter Combinations of a Phone Number</a></li>
<li><a href="http://wuyunjie.top/2019/04/10/LeetCode-18-4Sum/" title="LeetCode--18. 4Sum">LeetCode—18. 4Sum</a></li>
<li><a href="http://wuyunjie.top/2019/04/11/LeetCode-19-Remove-Nth-Node-From-End-of-List/" title="LeetCode--19. Remove Nth Node From End of List">LeetCode—19. Remove Nth Node From End of List</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>第二周LeetCode</title>
    <url>/2019/04/03/second-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第二周LeetCode刷题记录"><a href="#第二周LeetCode刷题记录" class="headerlink" title="第二周LeetCode刷题记录"></a>第二周LeetCode刷题记录</h2><a id="more"></a>
<ol>
<li><a href="http://wuyunjie.top/2019/03/31/LeetCode-4-Median-of-Two-Sorted-Arrays/" title="LeetCode--4. Median of Two Sorted Arrays">LeetCode—4. Median of Two Sorted Arrays</a></li>
<li><a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%945-Longest-Palindromic-Substring/" title="LeetCode——5. Longest Palindromic Substring">LeetCode—5. Longest Palindromic Substring</a></li>
<li><a href="http://wuyunjie.top/2019/04/01/LeetCode%E2%80%94%E2%80%946-ZigZag-Conversion/" title="LeetCode——6. ZigZag Conversion">LeetCode—6. ZigZag Conversion</a></li>
<li><a href="http://wuyunjie.top/2019/03/31/LeetCode-8-String-to-Integer-atoi/" title="LeetCode--8. String to Integer (atoi)">LeetCode—8. String to Integer (atoi)</a></li>
<li><a href="http://wuyunjie.top/2019/04/02/LeetCode-9-Palindrome-Number/" title="LeetCode--9. Palindrome Number">LeetCode—9. Palindrome Number</a></li>
<li><a href="http://wuyunjie.top/2019/04/03/LeetCode-11-Container-With-Most-Water/" title="LeetCode--11. Container With Most Water">LeetCode—11. Container With Most Water</a></li>
<li><a href="http://wuyunjie.top/2019/04/03/LeetCode-12-Integer-to-Roman/" title="LeetCode--12. Integer to Roman">LeetCode—12. Integer to Roman</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>《最近怎么样?》</title>
    <url>/2021/04/12/how-are-things.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="密码" />
    <label for="hbePass">密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="c3e0de82f472701900a54ddf79f15a12a8eb35ba7261ef7c9443dcf5638698f0">1078a00ac6efef4a296ae3dbff2cdbb335c5d38c1443e44f749fa23b2d07f66b0625b6f6c3de706fb45603268858acc1d40aa0989add4f3f58583c81942779f2ed847b63fb8d535791837982cba872a080bc37df73cc34a6269a603231f803229967502b0e7f3c31078db1a47a2d39b8e95c4948905fccfba01a2666d31b0db50c2ef8810b556aabbfd7118164b581df1929e3161f6d8a169d12cff7310298894688a08098a0086d602523e41bc81135ab8f3f85bf9074bbb186c18c318197e2b9a7db7c2dc5f26ec0fc642f580cb8ef338827f4de3244a7356f95bd8938aa4a8fd2345bdbfd2f69be28c309fbfc8a336c86050e21c03fe95d25b8cd9887ef8b8c6765dfdd39c5c145304e6889119fbd11575bc23bd562a85c5d89e74d4209650941369db32d35ac3785b911860525def80324ee09e8e439bae24582e261ee974da7e4a00cc428dd190160139451f25fbc0a8cf15b98c7a021154742f338c1b47a6f2bd707046ca056f17bc09c2ffa7589bda127d542cc25b282d8a9cec41a47360f556f486383386b484ed6231ec64c38083e55000757b24292bf9f5ae5a501072ec762dd99e4ce41f118737b341d2a1a1629e1c0f99206f2fdd2f21c80b47c841aa91a6b600736a3181caebfcca9914df64a136aefba460be79546c02e066941a774cd1b83d99e027b60e137f915cbaaf47562a385f28995313b975c988078d42b0bf4a74fe7baf0c0fa1e7c0c345e8d635dfa207034927324a6c69159cf7ee277a2cca25ecf9065a5be8a157d80488e787eefa925766bcf6d2c08ee65f48e0feee0fe2425bdfdba8eb4f2149005781a0b8d2c7f0afa5f5bba0c32dd6e93aced9ed9714741337b1a5afb09b42cea450e412112a48662fd25b1dfdcf29d8c62faf56053236cf4f6828b24204aece7e63cddbf6af4cb4abff7b59d907b40281821822ad7a370b4e951877885fe74fd70e29d09f38caab63cde1492b2c7f82ca0fe5f931968eaf700250f71d6f33d14656037bcac118c72de6cc87d7e4eb13172cfa44ed7ead29d465f27e138879b711527f3deea2c62cb7c7f7e448b99b50decc84a88941b33a079b182d48a8d0ad98d074fe0dee9720ff0490b3c908a9d0ae6cd3bc738459c66d8dfa87df8f408c96426602f4758b552ca99d284f11da8a7b45f4b861d3559081a9a5d85af7dbd4b4c032e17a88ae33954ac94fe6186be488bbbe3a19fc649525180ffa5e638751b259ccd694e977061e1cf843f963dcd18330944e92bd1503f61e9a2c92f708f5429a4983068151c3ed534f38d5c5fe16f287734d32141ca934f3db6673acf2656faa67f9da0c5e44c2758ec8ee96948a3ebf267ae74160d4388a9ff922b6ff9bc84df7cbffebf00561c3bd21f80389e655c388c8fd8c130eae76e668c2ea9c10bcb5806566a5198232cc76184198b92f565107be7d83194121d00fa179be23ad539f5350d332d45de652ef6d45cb29c7eb8fb93edbcc72d569d01d6df481a69699ccb5d051d8b3e462486dd23f8bc8240286d1a640dca69c48b418a2e76719139829cfd9cbf726fa224f0effb176afc957ef54512556a111566e941ff862eabcca6ab436737fb4f77f8c28f40b942b9f16581be8f393543f8c89c5352bd4b0cc8c0e2f20d4bf6beeb2a9a957607a60c284aa6566f793424dd7969a81b6298363ce40be60eb772892eebe9271af77668c0b938f631dad869d8653e017bead558a0eb72f01cddbfffc7de2df5bb009c3bc83f65c3a05523198bb772838b46258cb1dafd26fc775435d702bb240371076a60a086eb362e6199d5580e79a7e51b91d56d76e5994a599d8717dab3dc0f721ae3061644ee6a3fe95eef3765f3b4440c3f7d9a6762bdab772eceb0048ad557027a12e24ab5f7d495b09ae4097a8780961845829ad781feb95fb2bbf671453c316c0e664a5d03b66a2fc1579724fe03127f7e4e4144a800a3c7f7549e5bafa3fb13034e6795dfbfc61db00f973effbc615ad3711839cd1dd83f496f0efea28d0dbd74b51dcf5bc061352fe1854be6346f6989836c82f9d2640cefd6153b92fe7347360e4f59e78f8cf9a8c84dbd344b4a174c74d3e4fb237d43721d5f41a907b7a18869f0b79f92b3d93f9373b55e06628f413101a12fdc1498c06f6217985d86947ecd8f96831b516bd9c8fb329713511fdb899f43d82de80495385ebc6a9a40ec4344239f6cf54d9ecf75315b751c559a33bad4bc2806e52825d239018f93bfe69daa8ecf1f78e90bbbcf15dff143a69f77f6fa2a1b90cd734b9644aaa08d01285548837049f64830895c1d8f14e1d794b93631480adce4aea0ac5415d6b3ee6255930f2e53c4c0d8edb1daf7480c6edf028cea27d39b78a7517cee0ec02876b8956be565a5acbccb0bacdfe052f6ca9f0619ac9c547b545846728e20d110e63d6ad147df21287cf8e24910a4c954c18e8e2a6027ee0eb86298a20e0094146d5ee4f45a5ca219f8d2e3e3ca5ee5775e3d29209b5664a16a43a44db3c82ddfae20654d9d0920a57196f9dc0d655b2c4f03975a26dcb7b8c0d0a34da0175bdce0e8992e27cec6b7fe9f91bfc7527b91f587bd85bdd2e917c1596286d05a18212155471be5d27b3bbf4d3bb987af8cd400c4764cbb80adb4406e79921fda76f85d91dd390f3dbd8d26a6005b432491e3eb3f5483226a0d7ee4308ab50dfcef3fe7207fd3d097b9e12abd9c573e7c04191ed0a1813083480d56fd6d80f8cc3f7cdc9c29dc442f7679e5947a56c9341f433c2fc9edc031fc93013e322c0d329c54e18250b569fa09ac496644e5e1f44d75f166e72fdcff6e745b27f39554aa1557899dfd380cb545aee7d514b6a5b324ae0c4143f2a1c619855eec7816b268f79c9d2f36348f90494f1b38bb9ffcb502a2a7ec96d5b2f7f6b961890ae3b49e8e7803f77515c34cfdeddb8f6c6590c3e972dc6dcc3a34db40c2274bfe25ca7911c30697a4f422a4d749f3adc24f55daeb39573f5b84310a3576dc4b704f9769dcb902024c41dd19063dd4f3bd17eced0a389bcbf761c5377fd597cbe3a90d4a684196eeb37db9574ced719a914d17588148adc45d746905fb8d49eb63416a1630f96b86a12da9ea34fda63e45cbb77231b6152e49c7b70f655824b62f17f2ae7ebd5dfeb6927ba96ca5cd5c9f453e758fb5c8f712dbb669e305b73f22d1de4f00746d7daec9b8faf49eb2581cd5f42020ccb1f4afce8c0a1eb1beec43e710edd4a71bbcd8c354499a4b73164910a869e07f27b72522fdd94bd6343cfec6089ac390f4f3f4ec4e4c474447b95cd1510f3f8783fcf0ff6468f098370e2084d1eed8de8cd23c6ff0d2f3956d08583738f965c92db0b144b3401c00cec2ac4fdbe2c12e4664ef4701e4428ce3cc4584ebf6e77bf2534da8dc705c983270c4d549ca278ad99cb916261b015b38f1368cadd1c8ac5708f89bd48fe855cca83cf256d19b98a4ad0febd7cee9174ae953c806a1ab638b1dc7e5e35e9959059d7b371433bc0e4f5bc7cc787a947caa78cad72157c4aa8f554a9cf95d5f32a9dc3bc89b56841959522fdb98a492f45fa91b28a96e60db8a08df5388d23712d878d7f1ca91869db70fec74d3aae50fc30ddf85d583bd2412bc3f0adce6f36d26015c35ff2237c7b8e5bea1e8a7f98d274919a3819e7fcda2d73143a5c9c7961036c88d62933b45294441bb4a910fc8ea7486b9d7b0f742222c5cf8b146ea49ea86a2e13a379129530de7f51648a42dcacbdd014faf2129bb7ec437cedeb13816e72d5509a823bdfcbcf3b2bda8ee571b63a4cdf6ba8673f5f89d7b55e476a49e7e23890e115f84f17fb1488415f03263e9d0e48122aeec7a8853d52971e01aecedb1ff4f0fa345abdad82f4e84fafa364961cc64217bf0b9ff8cd915a6447d9bc50f08ccc4ca583a177c0659089c3710bf634078664597bb804e4c064a8b6b94b917987b14ab404ba888867b6dce0a0151c905924800c5527687248ecac72f1a55665371deb15db9b25f0f2987d8bcb8067fed6dbef0dabcc78121c57c074dc99cdc64edad37f5322ace88f4b11af0a06869c9a655e045a089fa5aedf97f130023b895e7f7f19fa4d3f6aca638b93d45dbd53f2f4e180c9db045dd544e16909d5972dc11e70c59512a7f004c6f36921317cbd83144407c16e11dc1bcfe8de8aca600310921212a507ad47625acfc6e68614cfb4b7ddc4cdd374c2043f0bbb9a840489d2b32e930c2e43fadac3f645bf763a2721a4ae0c3d67fac73e309177de79bebb2ef2018d6fd11d687c501044e019065fbae3845e00b19d55709b7222fee7d38e1385b84ba77407ffe7b737c9c58e8d99069a586db0347807ae6668f1ff9e89ee706422d3c63280039e3fe6344ad79945dbe570d4e9adb668989fee7794da331f3ad8cad6945e8f88cac86ce1074d336eaff8ffa9c9e42cab20de5a7697673f0ad45fa234e5adc7c5b6892ae33bb8319b546497f174d5c642b549466465c9d37a531a8c0d97e9a2de8a55481d955f0c12d89c22e4ddb1a868ad6aadab9b091ffb0e911e60bef5b518225161ed55224829f83561ff1d64b7ffbbcdf01cc37ebdafd855f124be0a9ca9142640b68cf85f839bc7ffb0dd78a390cc24db86acb409d299a88116a85d382c17f6259d9df08a8c5b7a58ff15d8ea1fd4a7e4e92c893de6b85b932efbfbfe172d336f5282d9f9574421719c1fa3fa9baadbede97e254a64cb41e66cee7c5b2c6e1e8c32e63b42a68b449dba8d34feff2e872f6f79c9b82b007a0ca1b847a7ae26e18f395f1b7ca2055a7e6e76dc71f07c56ab1b1cfb01daf28c2a337cf45a149678e0241da1e409564e2da52d47bc7f9340edef7c04da56f115e543c03781a68d9e82e4b38dfd78d966a1d040e9a69c64976906cb418b820694290d755283852b33274db6032c0d1ed65886329ecf7df9017dd96a8f4f6ed23f1b9872824567ea70f006874353a0ddfb6800049700ea074369722b51e4b55a3a6e0a6c32e0d41a134dee6f7539affa0e5fc4885546e3d2e42c50b40261585af58aceb490339fb16fd014dbb7d80e4f3bf83d3049ead29681521cf0cf2405186065e70f9dd5ae28bd0127bbd3305c86d45a57d18eb824405f266d6b81b3518deae9a4572d3c3fa68b592776216ad2efc2851cdc5ddf097cdb370116a3c443eeb195511a2ffb2900fa031f7de708d2b54b8eda2333beed130c5087234072bd9a095d50d6527125e9fcc283c3ee5682f53ce527ef597894bed7b5fdedcfa3f57ba54904203b1cc01fc8295514bba8f75f41bfdc54d0d785615321d4e18e9e5176e154ebdd4db1efd13239488cacd3988d7fbe0367b23661743c91d6299af62357d55d1ab141d3d3a662a1d55abc95c7bd6ab3221168dadc24a4bf1f5e010d22ca177f580a13909e563952d9e8a1eb5e01341aef03e327aa17c9263ab1b04684da2acd85815444fefd5d01ac1b23180c86b35c8b3e99e9c350f1780ea00c431362c9f2342cb75baf63855c6167083f4474d3bf09d526bf419f919790d301ece038dfefcf76c5769a25c3d81e81844771580cb8afacbe876f5bfce786c3ef5cc654571b1d32323e04aebccf441a2faee6e2d7475f15ce954bf1740f708ab9cf231dfab61194bf37f22a2c62dd9555f9791ba3227ce3809123eb28e9fb49e391e548a069f7b5934e060c1f08339003ad9e26c53d03d308eea521adeb2ad965a713a2fc57b2bdcacdc92dd5a0b6c874bd4b9443edaa4d7a00efb8a1fbee089fe9c5a41f62e105b04b3835c200348a0dc4ddebb2f0e599ca3e39446484d3c55cfa41081200c32ca76de9117c806b470e30279603ce3f2df0aa01c7377ec9e2877f6e9737802eb446883a2ecf914264fcbbbee20cf2dbd20a9ab02ced73f364688b8a069f2b1dc0e09ecdf1f85b1ccab00039f38d65070322525e60e470fbdc37c222b24a128f61ff8f08419e772cc02ce4cd94717bc0ccc478d7b8fcb2ed4b4a79e387d1a821970919725cb53df400863f6b5a2aa9a6c1850f0854d96e4508cd38b897ed83e7643a85e836ba6db6cafecd18ddc85370b88905b86a40e3dd24ae6c79795634c8c45fc1309b0ac95dc71f68af0719e06eb2f0ec1aa3953061b2053cb492439752733e37c1c0fb435b97266748cdfede8c6eb7eaf8444aa7c6d1f912a26605d82c955e299faa0b8367fada1306768cd8c282350c1f959dbf9fc54be0ab29b5dbaa157cace6540d852d87f0b4fc98d9e277cf9aadcd227e114a1462169e29f6227f24292990ab57199560dd67f53f15d50506562fa712799e7c968127c17c6cc4a12f5a9ea626f2ea7fb10c7178da530227ff568609294618679774fa7335fab469744f5a310f8cc2e3878b8b4fd4946546e873193ad34af2e9e1d8ecef26b5e237fdb587e063e9f4f7fa2d379420621ca7fe7eb9e0cb52fab7eb77b995b2487d640e246d46575356cbd11440be76b41a2ad24da903fd546559f62ff3d3a86ce08ec8449abc71d83f242dc41e26783094a9e773adcba9a636f1aa972253921ff4483b5cef47ad51ac70947acae3fd24bf3098298f21cef34a0fb59c09f4644e9e3499041f97b4c7a0c50df42e6c3d308767bc0dad44eb5e7a6d7b266e75f8e64998dcb7c0ac4613cd40bec60c110501cc34027c6317f67ade6f7e71e8d4a333e9b93ac30c5ffdf61646f41f3a374bd022f0206066e623bdf89fb055e7e9859ca7f41f7e7e4b5b401f8d2771b9f8197b91d945958e63b936b098794a5c2326c7bca7909ca124f21870e4e196b41da30aaa0cd620c679ae7e9a3f8b2da4cfc287dde3812dd8898a4b47b8e58fb3475b7242e4e80e7d58fb15d48771a36aed43d20c6d8642ffb1a89b96243d289c0e45d6a188ff0938f8f15bc0fcdd7486a585da8108357e66fd23b54c1cc1a2d200f0a1749e1eabf03afc9865f2987a8a916d1bb682a064842061cd817134714b65677ef020f21baa0b32365efc6a9ae1597f801263c64a462560a7e6661c69a3ed3661770ed187f7ca03ad03b84eba364763139d2773e02533ae65eca203a8f4c853edd04c98a927f170712bfe561694c618e1be31a0bc592d1d63f013f8a0f5a075f74856b23c28d53d3233b878332a5de9d55e33c6c10f0aa74ade2bca1cb9ec38ea8449bd0d545cedaa8054a38cf1b221f27c369e70d2737454b6076cb4e3e5903371f3a195a77990caf71b975be32f1aa4a8fdd4e4941557ed5aac2e6206d866fe4ce6efd3e79f3b33485898a907034f7dbfa6070ed96e5d5d4728f5279e63d6bbeb5995eeb57fe76f2bb5307195c7cbe2e6ba3af21d72179eee566931d1283b823f19e6f756b999858031d4a7d4e98bb9585886b07a52dd9b0b81e91546a925fa4d1cbef8696f7ea3e4d03be4a2fd7848380a4c57c863161772544607d8930914cd7df5df1b0db3913641f520ceee90d47fe60a1026ff7237a246bd93e9adc10b481aefa0f118eee012c1434ea6cd2b186fb7011b20a9fe93a33630bc002398c960cea9bf767d2be9fcc6c336210478850cc8894e988d24f70a944c31a601e58164dbc951c892bd572b10acf7c8fdbf2b940d473356b83a6baa2bd013d4a0c4cfd4ef4488ecaab7ee106ffcec74bc91493b2a9d20589d7c1ef51f3e2c30e04b1efca21a4e35953a0a6932068db9a167e072d092490c624e95871a21b1b0c948ffce51228d4198c54029313493063afdc24fa7f32232de91dc95cb5182f48be4066f27de4911371def66f7af3576f088131880541dee441c581c801b949b0dfdfa6d9f50a4e3a7acbc1d37ad5eea9adefc11a98e10c695a7fa854a443ec5d894473027b6dede3569efdbba637e2aca5ca8900891b42e32549dd8f31e4f3d07dea323ffe9726ccd3c87833759935a06437dfe278b54e4dd9d352cb3cd68ee7c7a947178dfde434d36be4aa58231503b6e19682d0999d0a420211efb25b9b318be1e0952285675e059d6b8e49dc6b87ff820c6f445b44ba3110015e9c5eedab9661fd58b0718df3aa74be04af0df185afe7544fc8050cf24dea1e5977ef21051897a9b5b1415c4b0dd048b6f60dd770061b75d8b20938632ca3625c4c7a3fc1e51660e6d5067197d7a10a325ec493c22ee221020160332e91d591f339bf81e15b8fc8f3a3c3c28e11ab01f73e07b6a2587be97b821af5ed96169e6b6a7aa6f96afea8de50e40b4cd677bd3ffc5bd6074dd88a1481e5f19f236af4db45b9b65c0fee88ecb3d30f70a7b4dff9a51704149f1ee5ac5271a28029535bcd9740c23e34e385ecd48195abb403ffc483d78fe2412ea2265737cb4bdf210d0afcea047b80054ab14dfccc988bd5bde9d843b3bbfd9d39ea3d7549e4939e6114deb4d537d075a27a0b24615d301d280986500c86f1b464c5ecdc35f875bd01d15c3f04583b75ba330f0b79d2c04856fd0809fe3b9b798a86af43a8962622b69f49a9b59a5f29ac4c61f6eb57597880f7950f83aa8111d4e96fab1da2a7f2ab45a5d991d32ba400e220bbbdb15fec06eb2d127b40f0c4ffb1a1c08ab45dddbd2f5a3b6450dcfcb05d4774b2bda7736edb27040bc0fcba72d060b78f25e02ee3f7ad18b9d90af0354137acde27f638f08e04e5b8243ba38dc7bc800a3e349bb6ac4eac5c37d0b72e019ba903bbd3c55573b660107347d58814b907e857ffad2daf3d0d6f10ec2efaffbb81a959fd14d2d8adf40e752c84a32f5915581fce10b2b3bcee2d47a4d140cb955036bf59967caa4d4dceec38a853e95b65a126ecb72c4d65d8fda71980996c42c9caf9bb6029b6499ff63eaedcd602769a3c26e96d9dbe8502594ff8c733a2ada2a5b4452ab4d2a169c9fcd9b402f393639ecc2b1631eac150e69a10e218b4207d0713c6f196f42834252e42f9ce8297a99ed0397de1e7e500b4e49d16b808054b427c5db46706ffb2c172af0aea52b8829f25d240ede1744b8f75ad736194d53af0a7f78a573a873b2f6bfe117e100cd17d5ef061ac6f2892e3669d50e6141d2cdae03f7bce65a9c8252c5c5f05684c37d2d4637d66547951b0ce455f9bf6b1b9f050b96785a3796005ee6eb8601a0621d3be9bb9f50291b5cb7b3d3689d56d4f7e41437e2b1d254b7cc8b7524fd77f8d10deaed39d1d208e5a6eb1f3efad95f00096581a55e3c41a87085bddd22df69082cc52606b1bb7c1c80aaf1d04773fa14321e8d6e3f9e892dc57095003601aa6fae149ed3851d3cba44b526a465cf8f9a24a5a8b91f0057a450085426e9dd55e6d9887eba0f91dc477368b229a31166b76d1f5a8dc48a632f71aaa44f2a2b5e007888428bbdf6c50ed0ac00659d41930cc3097068b0429f38951ef8445a44d3dc34b1ecb2aa09a01fad0d7873a9ebd69ef8f336257e15647226e74e043e8bcb44fe6c1388a5e94fa86af7f6665728bdd16d6d9e7f31a6de61b3a2edd547a3d237116f72b1c84ffbe888659ba9adb23f362275d11d5719f5c32c95e2d0bcf02ffd3743b50d91ee87314001870f9ffaee56fc12ee582e6337eaa1edc35ff221e4289fb3d15675b9529064757a7a2b14d3d29940af76c03c94cf2b4ead1415c10863e2a896cdbfd33498fa3e6016672ad85a1b81b9b381013bccfa140c7bb5c5b709a2e78d2c20c471c8a9c22d9ae8625316d3d37b3b4e93057ae694f4d5dd018d21842a25a00e1abb9f65988f4af6dc3f0883f4237ccf8a53d4d83c3ccf9ad89c7b61f4a74303d0e1935981ff9d1adb3df35e30e1e40b425a64f00ec026e10d54e56dbac00bd6dc0f9be0beaf9b3aeb6d27d9af4fa4d3dd4ae6d7604b3d24d7fb534aee29f4d724840057ce2a3834b87e3dbd4e77f55fb7210ab6023a4d2bf88922cf051f8b291c3f7210a6fdaefc45f73e22df110747fd2ac2ae596594dc99db83563a2b9261d2b03238ded5b1b5e764312532d774a831d787758c5ae446ccbf6753769f43e3d1a4c9a4889a1e84c2e6ca19275a4270f52625af7e03120dbf1c5da62e4da5845660e08767716cc4ef906f8862fb2aa5ac613ce66ca1ba7a6ea9937b7861dbc4fa817eb72644318e89cef6d27b2b976138e0c2df6b3759bba4340ba1c55df6caac13af72b926b7f317ccbe0289dd11104487bc96c9821341630a29d0034707626517afbc221eeaa0fd2c16a4b92270bebe61f65cbb0ed4cbb2b1d8c1e904cd93cb27d6c540627580474a4528d76f09bb6bdfacccd976288ba3268ca6bc7574fe45939b83bdba9a5a1b0292f2aa959a10e5be5160726d7e8721e82162cee431225027ba9b5135d661e838b5302f39ab6d16238f4881523bc6bd4600e76d246b97d6f34d8a72cdbe6b97407dcf2b21139423ecaa0e71562e5231ca01c2e80cd7339b43c1ed33d36a5bf5180ceeb61bb930eba21afb92298309590ede465f8d1d462321e23a1b8f24b65d5c9fdaebb64d5697e48d61b03f25492aeccbf5c43b3eb51eebd56b602c6951d0045d0092786255bffdee0342ed5df08c34d3e2f19b5393038b1f76bf71249eb51560f9b694f3797858e0847ad62df4e0dc7de811a09e10a441a7a5d4eec206bc7721006c77f18eb69f918823bcde323ca89e743cfa4aea0fd7b5fde8cd44f6256b656be52659f11d67ecc459be85017c46b69f0bdcdc2dfa618743c63dbf0c25286e4bf9524913064e48a0fed16bcb4c8e648f2ba0f1cf198d00b44d8f96e57b5846f55262384984984946c4fbd85c8738dea5292fa45615f6792a0468a6b17b1d6a2009c0bec6d1a64c3a7032fe8ef8ca95bb1a047b7cdb1fcc659e61c56a729f1ece8f42262fa596dad005ebca7485e80036a2e047eeed2f2da53b2021a6ad14104da89c60921bc093c8d90cad34b9283393bdf50f994daa71082925cb0773f5c0e36aa8c73fad8b99f8298dcf72721dbe59ae326a3aca1f40585f81f143d999a56dbc87f0e5c52347fba98127e637bdcdee3b037044f2ed901c16f2186989a786960750b2ef351ab05ea39cd46d686c474bada3bb964bcaa2ae406552d9f0bb02316e149a6f1f90006db6db341c9b93193129503d9413d0fb9607101e3abd550b3119603de247c8e8fa13e55c1edcd2c0adbb976440d2bcbc861fca200bd295021fe720ca79c666f9980a21a14cfce37f5e7e328453e98eb22980b60219cb5ee38ec933d9990441262616143039fe1c76d9d0c2461bc79d3efabfa1d049f8e5e8982a4d4afbf1d302af95c312ed98e6c2f39f6be9cd94f9399102d5816b16ee3275541a7707b61ed3f25dea1dec24e7a683254845bc9d1c1c07d34ceeb34942b101a039432a4e0e6cdfe7fc3eee427e8a9a46a43901d09972ce1dc4a72f405076cd42d98a0c912b7fde24c35164bc4a7a148f83da495dd1daf0c8c55a66562f78fe6cffee0a0fc783e9c8fd030b30e6a8870a67d302a743a46918bfa50bec72eb36bd35c495156b1274142f928c99c2268164e02525667f4a5d9a360f6b00e52fee28127ab02590ea7bbe1bf7f92fb3a421f8c6de4564d59aec4ced8be32b0b3f8907f46a946d7556802a18bbbbd6f0699893a2c67b464cb39356c503c43dc8ce3daec9684213a02d620f0b59fa1994c238190186261535d0f6221a76752f9c3b2aea9b5a88ae587286c0551fa5a40173d0ab90aa60cc021dbce2a83bfeb3ed1b106077b1a9c2139c4b0d939d373bb63b233fece3fc2c7283301323ad0d3799dd72cb72391e6cd61ea7545f46045de4cdfca6bec8f36b3a2cdaa2e0a714b616341e85c5db01694e98a231a4a9cffdae3e20cb4bd54f0f2d9ef06a137af7ebd9ad4a9d834bb7b83f0dd7513cbdaba7ce946374be3c3cf276c4e767d931a97fd50f8e368ce2221f960b2b74b9a181bafdb2c51a2fe1474ecec24e59c93ac4e64ddd5c609cb38cf185381fde5285234d92e5cb65425bc413f0ef9a37f7135799dc49c8f094e82983676700636a2ba50e047ee012228ed7b049813c78f98ec0ebefda1d5502458c815571ecb34210c62fa8bdf1edb6ed2970215e60b0a80da1f5733ca3629242b11091d82dd2f52dfeb4fdf094fc4a8c9d1fa482e313542e3fd173e5cac052604058e8844d71927d4cd8a408337c2328fe47478e81af38fa393ab0c3597288e2bdb31e5f415d14da02d1d1fa5dbf3cad2644791f1ed8d29153a6f03e07cfa4487deb785afc596c05bffe037e2c66a4f144ceb8b44b1d2cc7b6775b39e420722420a4f79459c2bf9d4cfec39106520db04a161a367799681ef3362c4a90ab6c55f65571abc5507ef6ed594680a07841c54023bc74c40427476930552d000dbb7647bb615daa2eae5e29cb99f503db8b3b38b648593113e753610347671553075e126b19dc29b20005e4660c63bba9c717cbd9d7eeb6cb19e22a6e8de29b07af8b6a764449ea390d375a198e1587ccbfbf5a465bb2df058d095f1d380a2300771636c9b327ab0a695067ab45bf35bc5af4fb52ad3d4afa4d24555cfe1eca2dc1f837558ff66f2ef4a3110e661013f6f27f0330e6cacc281a4d9ce873f0b63883144bec75f4be61da6e017c6cb93fe66f629acd4fd2f8921541faba05e83935e2880d5f7126a2601c2010330f68fe75e5bf31177aaf5e27b10c00809a08606f0568e28d46e047ef68f7c469d4b1ccd0899a3de23d6bab94505fac91d18955357cfaba16925f4df78c05ff5838b47372be294c4ff146923b71d5335aa4ab7b893f303a233a2137196889e61882501975183143a8bfd7e90ff327365cfa87aeef37fb630600a21398000471f7040c64700a9bcdac4951485fb7b36f5a32621cf6d58b58854d9ad430ae99b1ac1119f1130141327b74bb0dc7481085a474568715d3f2bf3a8968245ea79ef2a2d42009127c0189b268461b302af9b9a930aa5f7364fc6c36a43527c12a0bb6a8bc6bb7441ba0b7e68592b57d353bd99c34ab92bd2c0befa83e7d5f81921c81a93087f7df003b290cfbe23393416705a0b3db6eee9507ec8f3c2e378a724f49ff4ff374958827daffdc8e0f576d0555ec2fc4d74bba3ac5d97747ea771c8e882b08aeeb71a0d88dbb4a48332acef25077c58bea059b987324c18d0e7362fbfb476400c56d5b4c51b4d8890ac8a7dfcb7f6710d39b82a236e3c37a04740f98c8355537b22c276bab7ba9dc4342a2807ed4714017504f58fd86aa5083258aa5269304f780be3f9e004b4e83d69d91120ef09ea216654ecb3c29b5b1d4dc219d9394fad27a749303f4f2aadf2638f47b8bab62abcfd459c6ce89ebcbbbf4cb4f56b54bc66b615494f20346ee0f3e91920b0f6fa377fdbd166b4f0319dbc3e8f2b6ca3032cb5f5494c9713d93f398bd1467043c62debe0ad6e17fe2ee738d2c147d4e4a0d8bd9f19ba9856397bf79ed9fcdaba81d66cfc10bf23f718c07f541540861d317c5816fddcb14415ed256c32af746dbcff1f44706d80fad4eb1b0b88d5d5f827bd6af4ae34df0d513bc538aef9db3889c0ad4aac6dd44f5c3806377772f7c40ecb4ecc2e719e1f6e0f4b0f1c500f51f5c0b41c4672e16875490cb3d53e779c8c2651d177f0e620e7d2727c24e3fe5fa873398eae889a2970984ae6426af7c187d90731ede601af1999560eca2edc70a58200b6c16d6686ddd910867b01182431a6ad5e82cdc7a216dce5d8d6b54a3d73ede582906a2d709fbc9652eb5fd3481e07e221f55f8b3b37f592418839f20e8b27c5ddb6e3941df108167f9416938b3e72dddc5c3f444d0feddd2538365ea3646da8a7b67d918e1041f6b93e85cfa4f8a2c4ae4cd5d663e04f447b4e792e6ced5f1f2d0fed39c5c924203b221dcf357816a846ee8a376abfd1d68f9d5071f11d93fa36bbd29f73368cbff07c084fec17bf102c966ce8efafa013be034be08b8bcb49c94cc7119b3c9debfae228011ee1c23c1e434243b8ae2141703c4931798caa524c89edd12dcd349eecbebef80e748852c9de09e778e45b70969054179db8313575478faa0e862f584aeed9fb3981ede8cfe4f33fa1e523d08da0d215210331275fad00598c7c33ee77fb7a5706ec7911de5ca4583790bee1840036294e70ea843fc9b79076ac8ca5ba1443dd87c35deaf7d1571b2d35249b4b8b73c9dff1f80159df7febe5461fbb16663bae8ad2a1d4dfeab137c8791383fb63424af0084d02f5d1b3b1e7f2fc66dad1d9e2161bf9ebbe5422d2c4876bda0c214249d448e5f4b5bd5976b53813b6a2ce9613bcc25d32e3f1d5bba118cca9b0f9165a6643214f91913d91d78105e9b4e3a7b9b435bbd4e06f393248ec08d595907ea3a6f2de5e8841d96a2a60829bb720efbf46223630d13418c9d16a685c9d52b1a70e41052e10f5445ce48c8a4aef4a5893dc2e0b9a684bb6647896e4a73aec1b56e9edeee85ef1418495c9f2a5ebbcc00d02cf7334ef134d4645287077495227cfb2945a014f5bc4e938f0dbe1c0e74305d47cc81b413679ad72ce4296e35c527c90c4a7fe317cd17625107047c38e2abff5cb1be45839727ff9e6a0195b0b90859005b2644135db4f25cc2112c4a238f4352c2377356dcb5fc454f3832a960d7afbf0251959a7e1cb4f01aec5d90dc69faecb355cbf41acf674f1757b331c0e31e48ee417ab84057e7bbff59b1782b3e7c211cbe97312779fa1d25a4879566eb26a1e7e97f08e29d050347ae05ac485f1ccb5dde688eb1b075baa466f57cd3bd4ffa73bbec0d1a50d8e3d37281e56dd57762a836a57e82faf5bbe38b10e6b1d7ee076291858eefdf3889dbf55267e35165084afccbd09e0c9ac290b72b0fbbf27a40b59e58660509f8077f33f7fc1c5603e31cca3b98dd7064cb465bebf92bbb963ac5feb790ca43255d8d5910d6f7cfe3aa92f9eaf007deac95cd2cd9ae5c2f16ae0abcbc6f1e11347a25446b9ff63639f798c62c76cd23f627f8b010a7df77a866c20f1cfe77a0ec97bcf840a9d447682e50de65b9d438d6b69abeddedbc5a0be7cf56a8d51f9618ba0ffc9bbf9cee8376b1c33bb0b83543525e1bc68547d32327e97474606353a8d6fd4b1451665c04e6416d5d5646392b463bf24492c37fe919c9d583e12309d5c198e0c69650d39078ec209c372952a925033ef556ba8a60485b83e21cff450a5dfcef737e5118e748371be3b9003ffe4cc56b9ba9f0e898536b11c417e45a41b5066f63d6c1b31899e0985c5b85c6566335f8adf194808dbb1abdef866b6087345f81fc0b6d41b45ce45d724ac0e8d3892ae9dc5283d157ecd897a28b14041939da671f1d2abbf74ab2e4283fe95d1c44d3fb51425288c32140dea459f8225aaf435c1e86b23cb13a4c8f5ace35566804bf90c02cfe2ff530cfdb84b670178d9be867af2986175ba120ee58fde6146901dbb0e20b1372d9ee16028d918a0ca25c51fe41b7894a1d2f96a267a0c90ac21970a59b85c17a2bcbcbc230cd2406ea91e3d0657ffb18df1e20503f40e24938f9e9a870acfd1925895aaa6cf8d8fc82b9f5a346ba2d8b8187b5b950a24c5fbd0eba1eac20bc2279ac8994b024e5f7b330d9b7311b9bcde8374001a9fe311bb5e1d335cd8ffab613ff20ad262c369ebfdd48caf7754d11b2aaa8087acdd597f5ac731d7deaa447214538f622504bc54692c75a5ecfd2763c7e40caf551a777161b31aeb43e1b93d125ace81c4cbc40c6e0fa8a6377d9993ca1092dca15ad6c8a30f6324e26ea6cee5506a60e9b9ed8fd1765f4123302f21be605ae5138c96a89b2c61ea31983c4a7b01945108e647cc0b1f43142b09adcd6e9599289434b73d554316d91286c72107578543e6f74351f97fdd2103b2611e1477d442fc7368a046f52a519285e2796011ecd84a433e4eaab147df1843e30df20ce5f77cd04349b4b6d3946e3f8a7465fff1965ddaa8fb07752edebaaeb8e1e4605bdbcf9665def535fdd5ade1a0261d144052694c411f7e208f6383a511d30f821849ca0a9a23c88309fa2576093d161fa245dc074db5f29ff9c62a9754e71e8caeeae56a5bff4e12328b46bea9d59061e2de18979f71562d2d8f104658bf3ddc3ff819a869d2a42eadf2bd25a1e71a6c206c3c30363df2775c38af105267a952c62993cc8760f95fccff710f2c3fb172817e735f8c00da8fa5cf872ca5a7a7a34a879a14b1839fdaf03f801a8c40d18e10993eecfca6e055fe1306db117423d24c1cc421424eac59332a73ebcdb25c72cd77975fa8c060c676fa50f0fdd0503473efb4af253160e1fc7a12e12870b3b1e1ef15137ff0bf6708f84df4c62aec02b238d69d9c6080b2c4d9d6da9c4de40c58df842c86cf8b0c1a42349d90545d504ca5cfe2a4832c37d800efe597a66d8579bbbbd9f83b8b16d8c56b826b88323bcb3956c059d2d1962e63cb522fa6005628fc41c43277aae38fe02df53c22b6ef38515105523d54804ea1580f5287d18d1dc146dc40c356fdaae651790f340762cc3c0dbe5528e63c4368544cac8f0a77ec75e092f87d54b36a509237a8b7764f7d7462e725c9fbc2342984132d013cd72dc815ca53b40535669d9e3e50d5c9bdfb1ec474bd32c0379a69c288e4e214f74aa73411220974da79625b51d782df8c2e38b44cf042c443870eece38e4b8ec976b98cf51b95103e324dec09130c473cecff1783901dc454676a73ef332f5ab1b49f2a087035307824b09cac7dc535725e7ae5211cf9e5ae02441290f78606761ae8893d55b3f0d17d0a6a779788476e803c63420fbe974ed715c3bac50a00204708cfc971f27ca7c7969560685e894423295feafdba82597feb990509534dd995fa8cfff2ebb28570d95ddc454cfd37a92be83e467c93c02a8ba7a5b8c08fdfff9d743758678b9fbebc5f8954cf532342a326bd906bc522fb25b40d5ea761cf09fe2bfd1a17df7ff6996a396c298487e15d93c5f6c2304a293ebf83d2f5a5e3cb45aee093e61160d00cd8aa7107f8bbe0ff716956d1c301c7b86f9b84388445755c9620e5b07aff164092dbf9c6926cf9e2bde8af51e9826d1057f6c28dc6297b664a969925245c3009b5149a976bbdd0ef1b69a745d8af7cf0790ea6f1f7e2c458ba5393f0a7a2330fc007b9bbca8adc37efa9bc02153311d0b7c9347644c34b113bbd25a9740440707a8e607dd43bc8a7c501f40053374a62d1e35cc68e4ef4a6f51ff6530f53fea79ed828fc96af3b0668cf87ed9151acb9d7b7170d59ae12ba774888e3493ec6a39615a4db3000332dc564bea904ed963a976a8ffc7acf2cb49d9882a424c283d0f5e3069e511ccee27847d722272f0cf686e645f0fe931a6cba505dacd8d96fc47caafcc177f4760828cb2c46dd7c1bb4c409d77501d6c8ce8803008aac484f5359f936c204e7df7be9fc44af493bf0d2f449bd1316191a2fd31a3db608d788b1367fce828e5e64cc8306347b8cee456ced9b0b5568e81b6d4b8349e577b7435ddb78ef3dcb72b553c6e56cfa39c4dc87456c90a4335eaea10e0bb2fbd323ea2d09527af18dd64e6ced2fb5f2d77c7c57fb244f9602ab103023bae33d8e8f6a5e8f5d347de67722be0825ec7156777f6c73db43b0f3e43b4e814ad8c82cd0346581f01d7a6434f4edb204e820ebab56dcc439a6a33a9a19861ca4f885d2f4c0463b6d69bd186e6bf1317b2d61d013b5392099a0937239fc3991564642503907436ca32c430d69a93cb86a38dd071e3592ff55dd6d5d302265be44debac01debefc2ccd569957d80fa0b0864ccb2a29841d1db981f54d527fdd64442facf39e98b276c380aa6f65048fd1aca935233aed0587c37523e706880922bd93dbfa3c94ebae91ad2d8fcd86bd68fe8b70bff2f71d5ddcaaee5f0a5ff6d911edae92a76cb2a7022ec9c8246346c46ccbe63e819d1b4a4bbff8d9ce997e32286a9a559362c5acc323262c6896a0f25509610f0dd8975b2c00ea389362ebda8a09bca7dd0aeca411a21311146399d7a72fd97b055beaaea3bc68863062dd7e4ae405ba62c4b4f892066f67a9a1a1997dfdc5ca6b9dcc8d2fa774522c40d3cfe90478c998813f598c1cf6f905e95bb9f07c032f224441b361af4ae1670a88b82d10dcc7074df1736cc43dff4575a0cf0c0bcfcf2fdd424343a6431a6b94212c595367b7bbdb3acd13d9de2aa75aa06baab8581b45d7d6418677977a54c998c782080a15cd59c97585494187121a0d35c2d4fdc78f882a2e5bd0d17d9c9d9f12a4c08c1e7018b274717e06833c68cd682a7b1e4576e359dedb3be4cff35a6936ef867db0c4f9332204d0c25e92088d2e2e986127f183f39d112ec541441c4b84db5baf9b19a8582754a3053667b73d2274dddefae84074a3229df5fcfb78ace82f6cf19991b5b37a8f5f0ef117fa4e08e2cae823ca2363f5434cdf285eb69db4c8656beffc75e8c9ddd2ed393dc1b0e7236cf36a2bf650fc89f8da7ab5c4933eba784d3ef0e9b7eaa54bcc91e61a5d6451cb83ba5fead0900d97b8a7b58d16edab50836b665203efe5473d7e99d54489c7d772e006efdb0c0e19d813905ac2b646ff3d52557c2cc2f772f415e8875742a01ecbaca1a6a497550bd7c9235d6d71ac2a773365896e5f4a7c40b5e03c8f28a4708eb56068f0deaad26dac6d4004d99e3fb62215f4d604b729e2bd7f7c81223786da0e93f37bc9b551e90df5b0fe352bff7a63747f28fbc1096b697ad53f46fde1ef80ddb7cdfe98326303780a45150819d2f7e9e5c8b48f45cd45cde02dc2c6d3a8cc93bbd14727d7b671c2ed6d8618df6051906c3c28190095de2e42cc4f7a26bf235892dcfdee663765a342911091706690ead81b03dff66633ab37ca5fb696ab4aba8cc9ae0ae74a5b03b69a2672a97fbc249d7b03151d919907b4056592c7a83bff6559ebe0105ea6f3cee9ac6bc32dae56d5b93311abd829efae71234749b0e122c7432cf3c2468ba9bd986e67f9e364e4de87072f2a251753a7c2d7eea2a7362ba94a8f157d563dfa3af710aa40c350f4d925db2a20bb5a26fe645f1d4570efb0137d23d09d38a9b1c9735647c83f9c27a804414fef684e9dcf07ef072a7bed272ea43642708c671e5adc5d93b12424b0ca5741733199cc93e486729cc70821d9952a905ad718d95177144494cdb08ff66e9231bad3baedeb98b87ced2863efeff031accbd023256a14e149e4ac3728883c3f5545c9416182f780a1ee120b09e8c9f7636ae84a024ecc55f1308d88c2b39d2306f2f5f491e51b529d58c3986bd20942ec82023b7b0c1744d6aa0c76abf416ef7f4e12f3dd6a18be843f3213b82dc27339557c249e1b4011dd9e69297a3773c97f5efd863bcfb77af3c109d886917fff58530a1b8cf252f05a2e315439356c51d445252922c052926e8c36fc732a26ff658c19ad650f370a67c748bb941842211e5225e81e828202b8361288106c3e08e685c77434118793f32827e58d249eec073980977fbf1828e6dfa6c34f460f998e598beb89554a9a24e0235fee11738c5fc2c220b9f4f84e1f7c117a7cd7b4657cd9facbdc2a48c021ea8d0df865a6344afb6ad3fa398231d2847b38a9385ca3de173694d35136eda81344f4826668bea53e79e22f920d3483ece459a88f0df41dba7bc23d19b71b7f9eb9c434532ea535b465b0e4a4fe855bf387d7938afe2826b71245807104142919be1c35f0b9fef113cee5c49b6fd15ac4a0b5b35787099473b0e2d628873082aac1fea5be76219bcff44dcbb5328e0f8bd3d7f83c9caf0117f9309b556440be726fc6038aa05be242d52a6809c523db68b8f5977dc056593b94d0b3662741f677f02c41e9c5ad63ed0102eee996a507a17b8597773c0f1afcee19a1eff5cf233552f14ff1746878f181027bd5841f3b5fb899708fbcd9ef72f5cf42032fb5f4f1501a071205d93960c33d892194d4aab813d526181b47961cf093d0cebe8fe67ffb7e489b302873b9cd26b7685293875080314a40dee12df383e49151aef3017373f2f71d74caa9b64b71bb0cbe61de51899a377231f9f435a03eb0b68fca35cabd2f830bc60440063ec120a0be6302e1cfdbe3190053453b712a8b2d1dfab9ed2bc2e515c47ee484f8f9cdd8e9cfd7e8417d87e1e68dd8d09816841cfbafdb003323dbf2b0721af4e2d819f1587f682d581cb2a1ddbd2038ed1cc5f3a6b54c97de497e89d3a45052da71ea129c4928474463ac480273efb0816d26dad5c698dc6ba6ff1e1f7ea1248fda3f748218bbbbf8ffb77f045ab332bf69aee2d6fcac6a591b4c8895272bee7fdb37da4406658d9315ee0e5439f840aafc15547cd68b58be561bab7d241d210edeae2b30b9ccd6fbd6009cd4b3cc2587f4658b14623da7fa924580de3b7433d4f3b7b249b2f69800d9cf6b464b92ff0d3cd24e597a1f1e3f89124a49e4d2c4df60f1075b9fe49bca413e472c1dfc78716e9e31f1054c19f3b39b8c0e4c30370238fc35304d427b1c554791d55dd568ce940c7d2cab5c85f87c09df7c95198862e34637e30abb99f31cc1ae214b40850a648fda35f2ccfec8049d8856c6362941203a2f2f618c10c46b37401f1f864276de463e58e99d8c7c732528a400f240e7fd9a73fe84050c149d1701dbc003925cd1c33cd5fc701df3f46f0205bb3a4a641a3089dc832271629081a9ee58a9efe168a6994364a2c664bde0a423eb1df281eaa0f3ea26773709d04d148c45ba5064d1bdeff1e82eed64501fec4e0c35c4cbc8faaa8dd7af4ac5eb9e67477cce691d33c77847a693a378de7934195137b0c5283750429fffe159d655fe6fe0ac641a4197e17c63c53c5a8cd1ffd186d44c3bc05dbe16832eedbb1731c4ef0ae2c3661f5f8b32f2e3c4ff97d98104a0401ab938cbbb16e33706a59f0297a09e9dfe2c1c1be45613d970b3d7dc731860f21a0d5cb0b7bc906870b443eb1546def73c3fe8ce6e0a09d8543770e524e3eeaaae8334428fbe483ca48e056c64172f96a42fbf3c07f8442eaee0e160a797dd8d0dd569faf042a1a8e172898ac3f30c6d2bae555c6bc43b4ee37f648d3985739050aafe25f4a456edcdf6ae0a3791fa084d23ea9faa8e3c9bcf1ed076a245c7cd69b05f1f97279aa097e534144e98964c262c65ea3c1cbeaa0dea884878d0770a5b5117ba41415b02eccb48b0b9b40ca196cd933913ed65cf778454ea80fec9b56091acc7fd03315079064646403d12751efbdb122983e8fa2bbc03b7beb4b7ef404f7e0f9c257558dd9254ad99067922f3898b0f44338bc776622f432ecc58813072a73a4f0caab81657b736ec15d6c0c93ac56889194374a94615090271ad0c87ae5d7b9f2c911e195071a09cddf08fa13ebc6dfee32158b8940305c138abd092e288e57002d241a48ec1977a449951c2e8fdc08417bf6d038a201fa284fc65323d985daa67ee81fac8849d76d2af2203d476a4a6c551c8ed870982518e4d7643a1171ac1a206e0855a8ed3d947b420c5fc9ff7723044215607ff23310982e1fb145ad72abad67c2c78ea11fdabffc9704dfee1427faac3dd8d559714976776c988163f485a69dd4cf5f4631cecb06ca53abf116955ea2140f3e8a6041cb6177315dcd5153c0bec772f2a6edd3e8848eced8ba164dcbb6dbff1acc86ebf15af97da7b9012450e0c03e904dab6d8baec5f8ae218350ae6822f465e60f30c3fd0e65b4f54e5ae7790b961b1d7b7c260c5253038d25145db1adf113ef35cf6f84331537905a037aa09ee3a7674825801e6c31ba7612f31ea4a13b9975c0dd27f61c5b05c5f7e34cfde42acb91c2a19b6e21a68ff7b5971d2465bc2c230ce5fa0b3d28d18c5b12a5e5d72ed44da96c8f27d3bf323c8bddccc74cc2fdab7047803d808f22524192d0bd6ed9012e95a84a6d804465db39e6709a776c5a0f23463fb25f6ac1c79f191bb7708cf1d88ab62f077144ba8f1ca848e3a5c715f94f3b2583f3c17448896c408f17a1db55c62c84802c783eb6d1817a11843e5b8f91202f71adf7cadabdfd38aff5e93030f1e2d3706c78d38c3b0b74f2f689285098ab6b18494a7a94d726c6e5d1dc06052ebcca54292a2520417aa0cac2887032c543778bb9d3941032f36be6d0e5b219d87e6134c071c8a161d6de4bbd2cfe768160a11081a730f7836f6b36852ef653e75baaf5b12d28c5487b3b956172656aebbe8ed9a85293197221252073d047c7c88b412f8af5620a4d4338b4ecbe3ab52233725eec456a130006143992f0f6e2efc1d7c9b3d516fe6311d64d1735919488c6342dd56cb47447d9a697b52989ba681664b17ebe05732959a4a08809ef4566c5e80358e74ea4de10e66285c3bb184ed249e8e8f1b44f02ed9c642385dbfc235db99e1811a74d1eb8674f00ba3c81da91ff0540fb9b3657708c944b63da3a45ec3934083de7626543fee763e879c12e8b71a6b0c70eae57ce5ade3b8869a662358e97a9ef2b16209dd1afa3ddf50f42b062e665b495b71c02472b29d3b627a4525c4c80545e1085eacb3aef15d9fb704b321f37ec18665e10e1a2bb2568528b767cf8f3505d68e67caab75425f31b404f9be8ccd259d7730ae821d3704f11607867d24b4d6c35b994491fc05f8dc2a2338036782bdf08d9967e4d8f8f7ce3b6d0beb34a8a2d0a7b70da7edc30ff570a46aac834f2357aca14d20871d09abed20fc0912cebec18d727a1d5ba78e548b67f175b508d4200980ebf84da05e7684a10257a78247be7c8bde02826b20144a4159ac66cfd6e6f9d8f6028385219e2a00f746b9c9750fed384e837610a13b671ed57c4b3d4fa7930543978b6fb3590937727494746f1f76fff30d6d421e9a8f7b47c6cb529cb373e4d829f85ab74420390c7288f4f15d3690e27f31c6e64ed28f8250b0b64dd5da4bf7a4aaa54fa33c07777dbe72c7494afa951b2d17307c93e69af1e34501844c9f00bc9e0f898712d9c04120e391590d3d1a5a94277071b20c45eecadaad2acef34ab2d17cc4aff81c3b04631a30ce504acea1c92fb97da8d217f05593d47019ba0459971fac1458335429c6ce38e9437962bdbb3466758aef9666068efdb904cfb6d9bd5d06be7733ee1a04b209cecb182fece54ff13280f20ed43020850299365a186a00dcd76f94ef89d3ff402d7daefcf006eee2bc3917ea147487ca768011142ef417df341fcb9cca6b4afd210001108feba041b546f11b94e0cffb4903e8515b472c7181ac4d10c52a2a6049a0132a826b57442e2aa7e14d325f673efe4eb0b09c74e7eb09690e1251fe8f4ff369bff38c9b44f6a68b4f754611b97fc451a34a9e22fe50bbe3007a300fbffc19f0db17b37c15890990de48b4459b8267437afad2ec1953dae0a572cf0eb4c9a5d49c108b03fd9af2d11644663e2c043789c7085e04310bdc932401c4191129b8d55e4b07185e822fbcb024c52c7253e5b083be71bbe904723b9bba0ef29460c324bdecff340380cd563f17b4fc2f4506fe79d989c4d148d170cf5f30dfbaaf617d33e4728517c98d44cb70a3d99b2ca61e754f324c63b1cbcb3be099d14388af4b3238f6d5077225cf91633547f5cca959f0ffcd5080d6df627e456b15dee4ad6d39812a7df42da6d3512c839f251d134eddbf40e18f4b3adf6230ed2ef1ec9f3d3c511c2261b6c7d86115ef070e67101272c2411df232103943e0a39344b81367700d0dc126368a9e62dab843bccbcbf0afc2a38e0060995da4532721a171b7bc493155b22f1a12a2791828d5a2a8bf909557c2a1f7536602629a1f0f6fc4a4e3fbfb36524f83c65edcc429c254129f92036640917e20dba7967022c66a6397f8cd7be1ac79df0a59563d88236dad61f09f43196e236cc8893a6e70b8151136455ebfe57ef6b84987a8b3bf973011ed9257a51518ef95a00ccb583506d6043d39712dd7bf32b4d5b00f9bbb4629cfe3d7049dbf5a7301e2500ae85fa2d97542e3d48750f012e30b482a37e272c3c5420011fc52b70457ebda45371f7e3ecb4a6646306718407368e48566f9efa8717f80750804877bd810ae9b54a467c9a259dfc5af44ebe31ef40b99edf0380d09c99be1b2fb5a326a990a6d7f3121a1e79da236658990ec94c134c526889afb2af3de0edf1749d62df044287863f1e81e31b879e185a84374a15058ade7f234bc4c344d04c50841edf6fcb143ead29154b2b13eb45cde01ffafa05c5be47d5025d124990ee4cf1d24f9e72993428b1f2930100aa0788780c8ffadd1f193d7fa9706fbdd3bd1e292de8493c8cc54724becad1fb13e9cdf0000e09c0c3996122cb5edc0a3326a237e0f6ab176c878ecfdaa4e1d74eee54bcbc357ba4afe6299f69f268c31e5fc8d949cf73a9bfc2cb3bc3cc53f6c80a6bf80664f87c40b7ea0ad13d1e3cdd38848f2036c86384d5a60547e626fa7e5604f7035cb91ff1e81d7bebecfec71282cd6b957992082fcc7e73117ccd17b211f5a579cd4668600314a73f2d3d4e3b5b7db1f0606e9f2eaa235a75855e59037d64509645cff14a6c8d16d86922125c2b189fe7b9820c6a2b364878f0c1a02b629f53d139a4755b6c2bdc7ba782c461db9c88770a3caebe30152c4318a98ee371afa93c81936cf4b330465ef192a361185e01a925a105544362c3d31d12f96041c7b3d464220731780b18c4aee0b64c984b7b6c308c43bc16d18ebe0caabe6b94d8254e27f80be62654800e77aac42d42c3e1008dcc6891aa13e40af4179279a4f90d1c005b579db226e84567b94ea81e17844541ea9239f1f2a6f183098a432eb95956e1d688b55a7a809486ad34c9be58c3e7151831e466b4cb7cbd64f5d7e246a8ac7ee7869ea853adcac0b163da7bfbaeb32ce026a2ddd670efbe4060ddad00915736ac1dd3a0daa657cae33ba4eeed6e4cd83027d67eca9d454ba607c0a259f5719935481a0f880e123145c5ff03aeb108b3f702925816d0fe631a196fe29bd3313aa6d9e9b852b5fa232dd08f2afe4321b44d929f9ae52c42c515b6e40cbb649aa176becec55a61b3d7c00d2a4ba15583c94807cd09ccf6c256c53c84f67955aae06dcfca746ed093943ba7adb4126644acdec64e77fbaf2fdb09236520d2d8033a51221120d4220baf42bbba0b6376790e14f6cb6ef5d3d5d3625e1791d241bf130d40ad50e461e01df31ecafaf1a1e0c310f7d2fad582eee691bec5eb562837006a1ced9e0f6ee348dc9487301107744ff0e114a4469625aa493b4f9115703faf20262f5ebdad38d887ad8b9b7dcbdd0d76604ea12535c71fc59fe9898bb837efce2c631a89e4e03efe6a069e94bb47bd948821086549ee9aa72fe7adab340ebb60c4c7881c249f846ac23ef6ba9444c9193bfcbdbcf5da4ba011bf20a02ad0d982e4d44519b6732b599a94906b27eed3c68b1344315c206796a1e8ae031bf3416c9c8c8725f720c1fa83c478cf6a413e9ca9556e035634e3ba18a06736ea616a9db834e58e1120e41ce92416bc0f1879e26c1f62484072479dd7a711a465d5bd420af005be04da1a409dbeac6ec5b2d0915066c710b3d076cb34e2fda0cf05ee730f856feb86408fa87a55b36989501bd11cba40b6039c86aca957f6a97e131763296fd061d2dacd26ab57adb4c1253ddc1a548188d8716966adef9abb23166b107ab37836fec4ab6fa01a2ea3b000c16c6dc7e254a847098fd592432f4441fcbd5c9f0ac59d3a1cc75e5ca37126aabd89f144ed5a2923c9adb1f03a9bc45be3b453a46082233cce498be6a83e5cfd21cc641ed69608dfb3fac0a4e7f4148b9d17d91707abc457ff7592218b108c7c579146c1f93cd5baeed3fd56d0dad31d19c0ed73f21155207153f9e2093d282be80b6b390a1033a01f1456e8b1323f39b1af375827177960d05ef5e7d82b7b3e73f96c140d8899c02a8fc9629f642b4568e8d6cf5fa6f92d1dad47bf35f63f8566159bb203c24e62396f399e5194c145f916eea1876d20f06a40446af7229fc32b49fdca6e7f4186ff5fc078c7cd2333b0957f70c9e8a0b5a4cff57b5d87bdbe28b4fd27b6d4fc7870ef93519c94fc765579191741e532b3391597742a2e78bd268d8516ac0c4da09fd09ef3ab10a76525df3f3c7bb84c1613ae53cd5beb27608a05f8384edee6a87893cd9f22cc50eff048f4d8928da3e511f3cfe79729f311504616e09fcb6c1512dd4f9d7c089dc9f2ff31a8bb7f802e1a485cd30285770dc4050f0b56208d4a50700307dae941c17d3cec7b7998b11e7bb12f6669215a114366bb786b6085ba6b37d526eaf5ad36ae9555b8194d07bb25b6ea48ca2bb85e57fd9dcc90b2f8fac07d6deb4f5a30ae0f7014c116010cf87aaff332cd9620aa6ad2f3bc2d40e7ad11a5a2efc72aa23c744e0de121d5451982153230c794d2280242ee3c70fd4e4c53c52ef994063204be94655ff25dad8f2ec20c78cd665443187d8ffed2ce42b29e116eca572f13ff80b98c97b74088ded756b17edc4e11251ece0dc392c0084e2f7d0f28a7bccedd561fed6d59029f963b46310903f25399cd4e6dfc79e72ff955707adbfe780b6d48418f57bae624d3f89c8cae6525c2f79eb11ac12c73b8c333990e514480a0d76826e20737e2134743aa0c7ed74605d08f17ead23b486d86761e879bb795eabb5eefef62d098c76dc778105bb15643870cbf6342810fdd31a7b283b7d4caeb4589f5bbc10b864a2a51e18f8a251b59c7e09321a1db29e0c9b42b41105c4fe9f2efdcc83f31afb7cfb80f79ef4da409b43b51dbadeb66e9d1621a15464f3d572e9b9c570c1c3f0e6a2b1c18a08d3bc814b775d22ae16ecdce0c458a3b5b54aa5a1c55ebae34435908e614adfd3c6e926ede77ca242a70b3e80266a7b3690eaa5476d521432fc050f4aa66b203ae02c45a7da2bdde6e335a9ae1144272764ce464d5faa716c848d6ca32d879c1651b735534434c46743374d4f3979a00d82675fd68f750dd113a33895ee43414cc012dcb9960785deb562dbb319a46bba3b318b749e1ead2cf970a2812779ec3852b453418b8d6aa2ad3a507c5996eaba5e1a4ad0832b8926726d0494c09184269a37efd91c21e2c1b0cc3989cb3c0f12bd4ec1833ebde5a7ed7dc91e6cd6cc3e48474d87afc109e38e5b749d6cd3969297518e5899ae8fd10248c288a15759f031d64d2b37517c1e64a183e213b9310b6a20e35f8ba9dc9c8f4e8300173f92d7af6e0fe4afda73d1268bd9e92ac02536cb1966b9eed3f27629b308864dc7884bbaa947d1e7b849e0257204b5180bcee7a7633c6f62fab6703d023b09716e509c2fccbf4c96014922b2d7f65fa079b793fcb4f3e57fbabceff6a1dbc0d5ba944e74dc439b9250c8b4bc079e60dd61aafbdc8536c58188ee50a205ae82db15f3d2c2e3f40d892da3023f6bfd0c593710d2166525092a858fe425b4f6770b3c924becf0e2b89c424eeeec6692776d35fe40a0f0bcb61f9fae8839921f4609e46a1863ab77f61f9c34febec4450a4bb4bba39183ad5dad78492a67a6e43e559ea176ba1fa46614dcf37700123cd7a36b96ef1b4f58985339fd3f097daaabcef997b14d19a7a00d363763af970d690e4e112ab6d1022111a150b08bbaa181c116a889fb60b3968f818501e7811380775c959372721b438fa28eea4308f583dd7baf5f196d846f2a6023c257f1ad055a8e844898068795908654aee104549d0dad346b873aaa323d73e52c7a185923d0c1b00a0b8fc67a623c66a1ff1983c7ae44876ba08f593d7eefb09c42cbb099511c039dc53143bcd68a91bcd5e17afbdf81a5c55dfd4a8b1ec30083144d5f1eab68bfa9de983d3241bd8703836fd6e63428bff021cdffc50dd662666d106e96fcf7047b00c18dbc2a47fbd3316f1ca63a427e96bbec7c12483bd0b6e701898ec804e8d33e468dbd6896f0398cd46166ef7404cd28d385eb78f616d43b99f82b3d3c6a60b4b5f05e0ccff1ccada39911dd2f372eeb3db34d5b8d58b3545a9432a0370681c2fcc038ac522f3d5a9e1824b445d1d37f5636ec864102880b1fa140e3aef8fb775d888de8b73318575ac12472a6a4854627fe1ff152f0b411a09281d51b5404a58fb1840cd33c1efbc052d7ebaa97283150a8b2db8f9679e15de65891b8d7448c9ccf98722e0516ab2aaf445ca79590f04a118aa3ac825ab4469c8e27964101040536b1e5b8c938d9f6521f82d2f802946f858fe713a53bdc3a53c52f6185c870f5c7f03c64c38786a5a26dfc5dc26265bce967b3466d50e65246752738b385251ad332f34ffb7103776eb05cc7a3ba3eff2c9845316d9f629ee37373501f8a1dfb86f75ab3bb9ba978bd8dc7c9f352362216ed0df4651604d67261e9bf68d17b2da4f7f41a90867314b7cf90f77d1ffc177e8b2b9907d884adad1165e5a016fddfbae82cd5f1e98dec3f464b0900577d1568df602a821b68f53269c0743c5aeb0e1c55ab284b54aa65b3a8856d6836b287da3f2045ab806799ccde06329124678c1e960698f67ff06de3ec89b7e696f6ded2c37dc438c9ecc70ed45d7deec0e7cb2c93628c1604a89919cdb2d3729005b0c849eb7f2640ee5fbb1258140ce1ecacbbd905b2ff73dcaa62a0b7ff70a06f8bd60e6ab4886b726065345ea794a848686032647e79ca8dea4f6b0328997b89ed16f8d289e1e35ea9029ca174e8f3e3d1cc9ebdd319f703ecbec87abebebe97ff50309d806ae4264d9ccb6acfdd0f79debf470340adbfb79aa7b044911274d84bd8b2967ad9cb077c24fe08032452f8f52f8d119d088bb3297026645c78c1edd0453915b96d951e6cebeb3f4b77724c943d3b6ef75ab95a10962bdbc63bc5857d23981398e890d6649d390ab83b8e07f6c3bb121df22de291f97fb273160b31b60024506117e1ee45a827c3470674f55e96b27ec87356188e36b558b6a1307b6b0d4b7bf4553af0935b9b07897edfc61206067b3531a44e92d619fd8176c047f4ed60d18f95c66dbcdb27be22e7fdc54a09d6f71a627957653147c23b0cc48ff38c1c0000a4899489983d5bd0512b4f74d430d094ce29e46f6ad2c5759462327b1bb81225985fd00742beed0ab9b5c3e5763ea279f076d212f5737788f036352f0af1e6562f8b4ef93a5e12a2b26295eb1db4b373883e83c39bd16d76a1e71d83522e135411b1e369cda8d630e85078165837760b09359421f622d4285b30eed20b450b962fd7c90116e02f273ac4f1109f92750a9efb0c0ca305621cab97528ec900cb104b44e17bbb511640fe68ff392b36da05cf758a54eef9c221eb6e1b7e709825d6e9ad630760e50ae260a91a2eb4b20f431a042f5f567322d35dceb16747ac40218502f7371c68554eae3c904216c7d2aafc2ca6a3db9d4329d318a73ef51c8f8fbe4a8dc24f255fb8206c831e4ec7722e0621add69eebf49012369012eed2a5b0331b3f188a1170034c2be6a19eb2ea729696a87a8036aeaed41c70b97757785fc4ee934a929e5f090abe58a0c0a83a5b9634ec4de9a4aab1b6f8bb5069746ad70e91766a1f95b6b9b5226092686cd01b99f4c24869ccc6c1d4bf5dd653d8947d0cfff5969aba292d43d94105e8ff3ab199d9604751e977f86f65c8ecd2711a9804a82128756f8107abc7bbe4473583110d96a5ff595fba1eced33b8a8f59482ff9d4920cf6a772d3a90d2f5ab032272df35f1ba807da11b7de201b852070e9db9f1bce1aac8988596ac0c0e195822e1367899b3b746308134d8e6660d466acf01a1fc74fada88d0e6deb99427bea3b8e4413b70fccaa9c3cffa329c144ed533c50c0873a04dfb930ab0de9cc397e76c7f07501098d4554a3b2ead69e168f9e9edbe9619d584636e17e9f4fcf5dd7f8c60d12c5ae3483a5f4d55244b8894143a2abd414340def1b79d4ae2dea955367d007a16fa1521b8929b8bbcdeefaec8d38116ccc5f256d16f234fdbf4abcd4e2d5e0f78a51486e826534b5e224421ca0c516b9ce40685f381e862faedea62b3abfa57563543073908116da1f8ca3c09d79c2a8a6562ee84287c1865e697221cfeb4bd101a26fcf555fcdb17b0aab04de0800354ef68d3ef27c9c8da564da1ac607cdd0c2bbf51b13d90055de3852fc052c0d71161139541071bff0ece995f32507a5914375d2134efc62ee715ee833cc0420e7afd8907fd8ea45d636c9d62bf5cb9a5a803e25fe64464af6e4d84d822cbe48c65fcca4a120a5563635ebfa50336abc9f76f06c910dce389ec05922465b5e674b6c9bea19a755e285d01272f97006875f6a0b29940a576523f5e9361d97aa89345e46b211a7494097253b39ca0f9fd58ccd72f845dbcf270670e0c70f1ecc587f4e961b5c908a99334a1df7e199d748f11928566ff99562a6e99956ee3c488310cadccd8276fe9930c40033969b89fbc25c17269176d4c8cdec265238356b5ff525f6eff655f2ea6cb3ca08cb37994a4f516a8ab8a8c632ecb6eb4c1b22aaa8b9cb4f6d7330f35fc7fb3df0eef7df952565765e8ecc868943aa2bb6dfa4835418342a79600e7fa110121889792b30aa8cb7f0f390d81469732e7431b1c1a67eddbcfcb040549ba11cff02a4a79b5fe86e6b2cd957066287f1c4eaa72b0fb58c47a8c0de849d9dc1299b04717de430005354c6594582ebb3d7c405a335e09d2f8bd48c9ecc25424889dff82d3a67391714cf90fee68aab7c46179d8c79bb111f86c9d3cad3a2ca340c8d63b55e0f041fff5588ae76ce84baee2c7f2a4f624c2e3199611be5c911ddfcc0764fc01be47a556350827b45ae1c68f1bae6e661eb5522ac9a3c8ebc57f15ec2816d3dce11bf24d99d2509e20d044b5774bca5234309ea63e328e5c1bcc7fac6e5540ded460176150df4f6aa795f586662e563192ee7806d50c26db369375366928d59f410efe4743a1440fdbfdab4270850e46f98196e4ab3ae1bdf61fae43f7bef08b58fedbed3916b2b12a248497dde2e554a1c5ed01447fc98feb2e22567881dfbbeeee9d79b2e3a9964ea83d41b0756bb8c7ac4c3652f7a4955a346eb5901b32783559575fb17f315fc7c8eaf798a6576b2f387acea0b27f626f9cbc1b73fff6c53ce783a34a8f05bf0954598cea21e9b28138f1c174a40c1189ac3a86ac8afab0347832e758e86669ae7620cd753f93e1a256c2f8a2e5613fccd02f12e13a049045b1faffb8049c15f7a38394e10377714bea194e0c27d16ea0e1c91abb91298fd0de20305e4fdabc17eb014d97941b5f8b80be606dc1e6cc04b17d7575d457bf24371c41783a9e16e995159aa3c9068fc460a06b13c49e336a2ad3183e7b82161a23af89dedb0a4f557384f83bab0f7e937a2f82a076704133b39d76fdf0960778d31bc062565edee9a11725f742acc1eda95a981937911ce49ee1a2942a12a2ef97ef652f4d2d2ba490a12eb45901dff2a31287cc40501fa4a32e7631ea0fdcb3c40f7b2b66f03dcb4f99175c1447349cc16fea70ec66758315c557a98343d81184079b1493b9aef3396cc06d4849bf8cfbeca74427e21684f54afe05589e8abfc30ba9681d232704636b851f5eecc918bebc0850174abd52cd5f4d4a93221cbf91012f005b92a1027e0d84a0f7951312c2a3732b74ae1150733a0ddbbcc4989bd5b8ea621b0cc759c73b396ea1facfce25f4d806534150b190d7f97e73fda897ad28876f47461f1246c183eccd5d08f71a2b1718bcb56fa733bee56d8236a214c2d1a3d3cd856cfd10f8abedb3372a244b9b7a039f17d11fc46523eb5994c9a4efedc75323d4a254552330304364dd3b91e46000d1536a40627f46ce037311eb6afb21e8dfe8a9d7f396be846fe71e0f00c824926adbc4d01a85a70db6a5116e7b9ae5730bd11891c33b91a4934e0e8c7e90b24c0c66370fd9e41b8001c776e95142238b68b7f046d537de0380b09dfa65817ea95f22f53bf0212c17cece98286ef5777bdbf5236582dc33d6bc1371018cd77dace0068514400f8e4b5bf7b7b1fe9d33c31950fd04a6974472d3d345d6fe02c027d131a1fb4826ec83063b81b4cad278f0ab601f287e1daf5ffc2816ddbbdb60ad12180f4636863566377ab0f418ffb3e5d9a5a03029ba136bcc6752eccdd206b738a3811ea8eda57642283280cf91995ae57865a3efdf400dc129f7ca2721271b3da22ce34a1d0de4b321ec15d7ae1a0e469b5f057fd07eda19f95ed82a3b25c3c1a6c6c1613041f66a86ce63e750513c1505246febdf6220bb54119828b0c8bdb1054e9822886347554d484e96c40a0008b170cce58d585fa233128260c818e7a56faeec2f1a2923b9812db5d9c39c675c9d88dd98277b783a51c3402c3738886fca92ab41c50d947c214ed504fee0c209465466a6d836b3beeef0f8979bc16109f3c7cbb90fecd5c4628f40f399f041cd362630c2e59cf5806b1dc33cdd2844052ce50553a646495ed4cc2e74421722654e82d2ece9270589cb164007bbcf240fdb0301c3f63b7544a976dfd2050511cef71b4573b019206f9e5e5b30ac5043505e2a2d55cb32fe746e4e8c8347ab4b6fb8cd7089cd4f744cb42028ff0fd6dc95afe6bb2121de3fe4bf7d7cf981aec36d0fbfda31b87c48c145504273a0671d8824667bb6c42c5d4ff83e2fb10fd3bfc68cee746649379207525ed9c96c72a68a6ebb700836d755ba741c8e146094c098d0c4bb90ef5f8d3eca659df6f0c5c1468fcf0ae15906e468fcc9fb7a177bed27e7c477b30cec7533984f7cc163b22a73ad91f99513764e72df943c8e86d61fae3e5384101f8c6053a9c13962a08dd23e24b05dd20120d05029432b079cf555102a68dd178a6c3ce2adc747b9793ec0b8763b3125fe7b2e2ec3c632136028c1e0514b64fba078ac59a1daefe1f2c33c0c1b130b238cb6fb75596c64ed63f1cc00629b148c6c3e5aadb3d2093a36d6f2040cd7b2df8417010e5d92a60dbbff56caf9a43d339a6aecfbe0267c0e3a2bd4c744004688fd0bd628715642ca47cb7a50c6b8390f9468365d966da68c4397b8ec2388bf8a87ea50297763f587c2a00f03a095f011dde62e939a457e975021e05db111170aacb4b3911340ef5d3f2b21e338a72f8d7292c3c08ee0846e6abb07faeb5ad1d6e5f66739ddcc74f9c34a253bb99ecd3288f80881ad726484a31c4233121d9e4ac380772f69a9701a1ab2dbd721227882325ff33aa6503397da55f9d9e89835c3111748f308cb600c0549aa30022d7679e1a02fbe75ca5c2d359565b643c99d0acca76c4ac90938993ada97658b1c2ce93836e077ec5526dd074d6cc1aea098640aa01e62ef2760c8f6b77e6d49211ce624302100cd64df14ed8559b7dcc42ebcf2b7ee5ba3deb90a45ae5fc8ebb0e49688fb0770ca6706133bc340eb0dd1c7da4c1e98d0ad4a309200f059779eca1030369a9cf2478d5d9d9a76deccdbb5301491b517f2ccc6c197ee72b2c5657fa77b3013746be7ea1c458ed9336fc13685dbe2eda317ecf292ae3de06fd0742f1a3c07f6658abb1e7019e33054bead3d392cca658b275082835b57ece2770710b7f216e1d979cf3458714a5487b75dedbdf883253b1a9a70ce9fb691575ca7a9ac5d8199ba07b8eff6361405fd9366f29c603bea007fe46f46d4305f4b4f8445802213f7e3d5282b24144f1b5c4cb2e7ff28c38727858d9c63647ba85a5db8cfbbd8b404162f33e1c22e4bc838dd8e37b5cb39e1bf0cd59d9c5e6e2283235e44479c9ad27f11ec9c822cb8523034b3320193d4145e353ee9ee8e28d9d05f67cf82df0094a590ad813ae802c489f2efa76e394cbe7250882eca17039c5c1176ab00f330fa7fae0adc96008bfc083280de5d7599d04137cd2d4027adf3e4e414d3d1ae4b90931f855cc98ba9d7a6b4d058cc43f6915fa905ab04220d707500aa20052d689153e31369bcbf599bc48792fa7cea4400aed3022a5853512b1c09817c838b2e408c3ae43e5bcd29bbdca8e53e27434451bb95e2bbf0d77d16482f3c08d3b775eef8c4fbfbccebe1cd203fd44b7423b7f66bc2f6a046046e0ceda7927b162132b8a0f9ff2e06c82bcb526a18df06d9f364000a5c6fccc09591b1bd22c0f358c218d7f8527e00e1b8fc6d34293aa70a18e169810ccb2ee00e893e6226cab05261afe5436d31320d9470a192d194bea0c48c60d07d951c710dc3505005833b9e9189655db7dd3bf9ee664ca506970765a1aafd88d6c996e54871eb994ab3313c526114b7ed0017f442c8b6184802455321b3a914c7e03aa84abfddcc1668570b6a8cc3b66330dfae2462abc892bcf6247c54e12543e6f7a06ac7d14cfc5371388bf51e392c6fb5599320ba737d04a75d1e7ef46371e610a6b275bec9efc45866828c624d88f0ae3cb3655800540384f8cd679ab38a58af37942bdd386ffca719f2d5dcdc64f716594f8c485d09dab4135ffde49fbb62121483dc0cb94393ffd488d4063668b60cda37cfdb1f59bdb572d1017665f1aaff60b26c6a9eba70f55390d49c943519ca45114f34c745aa31b2153f0776b777d30d5d60a4338cfdbb690d438611f07f49ff0ca8366ad881541124de7c5a18adbf1d2aefa5c597f87738fe4183e4c85d8f430aa63c9ef8f60746aa241a875dc429496d0d674739cf10a5be07639b9706c57ef8f2c5fcc1e640490cfe2bc26896d5be2426fa3158277dcee2e98550357101d51fd51f9f1895fdc6409c503a79aa45a123ac714aa09b4863f12976bdb632f6f1b0aea36433d7c42e0dfe4028619695f327db05cd6ff3007338a086c67a83ad3956b956abb7aa1bc1512a6a935c8dc857add822dfa5b3522cd3e06fa377b754f264bdae7c42db1b8900b467860c6e51731f8392056e7f1db8bf65a950850678683811221ac01057c65d69c9e9baec411ed775fb80c0b023d5902eaf89111439cc04f74e7f1670b7ee13131a50bb99d2785aad9fa9e8988747d46289675bbec4d98a74d99e7caa650a5409dce923fbe39d6e2e4f76d09489b5e8c778f791d87db99b8e4f3bdd873b24c2ac3d12d7e3629bd9c649d2b1f5ed686efa450cc2e73319b6aec5828f6b1a20d6ea7d46ed4ca21bbb775b66241608227d3c3b970d25b78f978fb883be0838a33a218f7a6d8fe8c66ca2f9eb4cdfbf7b96b020975329f6e854a32eda96c8785a373d779226b614a00bd3474d06421fea026c4e6d4936ef9ac8e38d96b1f19ef339e06ffa2b2334c2325e2859bc84c379773cd79dfd807782a6db576a61c81036150a5bcb49b139c14a4b280db925bb21729444c2c2657c808ce95a0d80242abfbe05d302fc9f6f493cb5502c777b0328a0877f2f78877f3f0c30e88422dd999fe790eeb20b5009580a4b306c918a24d852f61647350355143e000d48ef8380f038442a907fab61759d400eb2add92324728d88777a990e92683256f24b2ff11aacf81526c45e98965486f45d9d55bac48e92818dbed9c587cae1785c0ba7c49bde23311f5a3b1a12521605f09a9fe4c9bf1d36766160034668b45bf5739c68f729f04c07ba32cb741fdd2717ccace5c4cd52a78d42cfd7f049e853599ea56c8303ca4137a98df66eb280279a0d5cf8c20be77969ca882803ea6b7c109fd47dfb525480c8176045b7b7492a21612cf26f5f726f601e25fdf23815ca4b12edfd42a9cd73a013b3bc9beaa82867374055b5047e545eac85241506d305bac9926a075bb844645e9611df4181b5096bd77d95b6617457c19c6069a7a12df48b552a400072bad8b41aafe11fb9ee0dc69884b02325332381d3c431c214dbb4a9c1684c18f03589dd457830bfe62c2d97347c2eb24587e108bc655b340bab9fd7a57b35b15f9d97babc32825f397b42a396878d2d5a0a7cfe6dae5363696b7bfb8afff3cf41d63e41b4daedd5565485ecab6d95fb0ff02744b6e658e49fd69b0a783c7d534579f10f2e4ad23919e3d071aad94fb3604fd8e8f39515c396a5ab09f4eb56588162dbd316d2d9159452daa91df55788678d7b3a2c3c07864953dd3119e1e8a59f832e4072bdfa24ab84f0b742afad318e9eb5b3084223c10523252f3d774fb0534e243bb670964234bd17de8e7c7371f91f9abd1c87c021d1d8b668b0c135cabd9ce2fac68186184740854f7ac556400314e5313dd5fa9fea03b496a617fa10ed83f506ab8af53829f0363617fcc32a2221f8d7477e44b86ba022fc0243736f2da49a7e2db94b642f85d8816d016ef761ba406ae210d2426ce9e2feb5590814870ebe32ce4832b654c8ff782e42f0c76cdb66f49e62d026bb1b7e0f9d44bb6e794ebe7048afed06481765432c54cdbfa50b3c2c26c73840b977b0902bf9521cce2f17615708683c772471a47bb1417e57809f886f2df2fdecd2dbf250b4db71d3cdc7baf794497ea07b9947a492098e96861a2d29c31601a411379780c416991d4bd498ad45186eaa6fdf7fa618d0e8e79558f0eb6ce288f5b1005984819be25a938cef4d8906136ad32ae64f8f4d7c624cb2fd229a51181c99ed24f5d706a51cc73a398849239969fec2e7e98b87de7b904848bcdace43db7b5badcabc02fcdfdad4301d740056eace3b00e1a47888c493886e949cf58e7a2dd8a3b63d00349cf3bf7ab927699c17053273b5fbf3b3e04e40739bc79a09b669f3ac25bd550f5ab6814b8506e31efcdc5a02e3026a4cbdb60798419f7c030328acaeba56cc207ec1c7aaf6760f7d2300042ba9d9b36041925755a5d22f3480e6d21642ebdfb99f28628cff4d6f6ef1508703bc3b0cea0c69aa74e1bab3084c7f65235d0369666a71bc2c6fb8a4453a9ed2523fa313b19c81a3c78b242073c56cc5be722dca0cb311ed8de97fd8f05282d85cc6b284ff6855c85cca272b39df8e0dba46bbd222e7e7b6bf35eec79cc8fcaa2efc6c169c72872f62da4e639d3822cbe10555000590d6ebece9d62c6ee3507cc160d6d0177fe732b106a3b797ea5c5f519584939749d99ffc89d44d9cdeae4fe9e1659fbb2e5556a1dfefd9c227d62b2191344f2905d5db876619a2b5320fa7210422930b82d2eabf9bbe89201a7f0279cf63da0eee86ea39317027c0ea226a0accfd623da65070a6ea8ee8279d872a5252cf66add68e3e1faa538191aa51fada4f5f500326403315e7469fdcb37b31c18d52ed64762938308804246f296ad6cdddd1ce2192ffd6101e98468855a460ae9099295850ec457f7aea5b07c76d8e51502b93527c387488334ffa69e9b5d564f308b2c04eedd6b083cc3565a828b745b5b8bea16622c73b156ae2b73067c664167658b9c906a932686693fa9fd63edbb98072651f5fa79dfac9ba96e87c5329f2a5cd576d3e3cef349ea6a55f96bb3389963dfa54acec4a67a7c6c52674e246282fd351a2dc990fd1997ac94173ea859a2271b6eeaa4607f04cb19ae7672083590fe61db1a3bd599e9d88392f5cf686a41df9edb8cdfb19f9bc914b885c89ac2cda1734d6632af0ab55c4028710df569f2971a32c8de1b7af32bc1b11ff1fef7b42808745c3b59708475b80ec71b62c01c47741d291843f22a363a67b49d981953623385f2e2d404438932df0a8de3fb4996b8b724f914d7f385c7c025895167d89119de8d6fe47e2fa1ad1f6319ea2f3182671171f5177da76ae8a35c333fec51d54014c0318039b213409f1913c94e3e6f4d51280641e15f9d5128f2ee7b0cc3fbb4cfa3dc0d0d2884f02650e8bb8acdc051836b72c58a022d9c88245e90a41a832aa96c1c33fef77216187f7253b472ed5fd610fc5c2ea159a58971e02c9f60b2e557251b0188acaae1ad4f99d6d3d66857df486bfa3685ca086795529ce1b2dca03ab0aafd87b18b80e17d0e3fab7f7600106f71c5547db221965fe60d77d5f1975dd85b4b899f16212d1d28859b2a666f6f9a10278943389eaab5f245c7ddc289b2887bd8240d08743629e7c1995d41824b3f18d4efe05293f6f46147cad9d6982cdeb25dcc4379acc58a7cc0331bda9ba90b461572bb62ac983b14825fe06a81bbf16fab75b6ce7c1ba89f70839b3609facf21ed4ef55502331f232468e0b82c68904e9827f247573a7d76aef2ef3a85ae574bddd1cfbb1e8f6c53e7eea6422408cc05864552a753789d6aa56dd0ce03c25a57d3337708604c6ab3cd0043b4f1eb9de75360df43fe96f313790648dcb2bc325d2137c19b2fa600cbe3607419e7c28cb25b8a4be7b1d894131ca9fb4803e1179939e9d2968848ef11bef64039380e656f582a4b905c9a0aa046ac9237a75c971973115494914f829603ade29dbc7d3807fe5fac2d2d3801fce44982abe3b418d2852aeca4ad141d329d8073618fa183f62c9e48b56c4b21e431998fc07b7c0ffbde91a27e285ea7215683d5c233a019c0ffbb8c1b0c876baefbc6226e01c9265416a9334977f035caab94ae2b1604bade0caa8c51ad9b40a1fd4979bd87630e48f08800a282b67c9ca918c5d06dd6c63cfab50a751c3c9b38fb0027f878483c912b4ce48916be01f5f7a10afe0d3d910e39634958d54f2bccd17c87ce15878c61107230951493cde4521f4afef679971ca16ae3d58f12f43bbc1c58b3104f9b34194b95c44c536eef398925b8702c49be8d853d4294120b038de798732f5b718f744b98984e41dde717136ce1ba3f6928d9844e25d81fbbacd1143fd91d2f84fb31b80321aac6f01ba5023a4fd6c2c1003eb9c08d3705d2daa8647d1c6e285edf85e5844b8598b6691447608029ba66a503465dee6bc3d08c5b8e37dcc2c8c0f1937fba86e3072c8bd0446a0010a82c030a74da47ae8182b6548e65822fbfa6b3b9ac4314d3f13474c7f260737774648ca731a6e8d5e4cc8618f18ea0324229742389993905e077bb9a3fdf807db67357b01ee2c4d817bdc3998ce804e2b87e4bb7fc553c27b505e42d8b3d5aa7d1669b9ae7b20bc551f2df9b1ead2097cdbffa8dde9093ff078181cd5851eace6e6caa4b75ad22a49d05d9ccaa811e1c9e61cd3487d9225250b3df13464e1b4231e77540102e7c72f901092b818d8c564d083ab74449a140a3e56ffc6c201b8c161bd6723c6d321efb306e285104d789a8d689e9b8a521f2951fa29163f4963ac36d63e19f6184e57381d2bf730cb5e1b3d2f3a605ae1e850d36e20fc3fa0fe066b0608f4ded193b260f38516b92782caa046c4a5a1580756d5d61d12a65f85bc93df446a851a7ceb3ea3fda47a93c385c66305474ed0ca613288d35156343f7fc705a66d8757c4fa5438ac251cf3842c9c2f0b9a1508da56edd7bcabd66c00d565c6aded61b73d1fe258fe14b8c6ff0e67aa4fc9a045b90b6e3a567cee40250458bdf5c0ac681a7836980e4da9f4f20bdb0c8cb965eb3f766fd36221ea289709f64ab24f107f50acbf0e23594bcf499a93defda6ef0a9c3f13c94e7e4c2436236045e7c7586fd0cbabaab73ff16314f05ffce5cbca86d4e4f8bd6db405927b27cc0976d02397609d219a8ad1759bc6b0a2fa6528f250c3ce99c2b4224255033467c1cf17c8368e8822df9da267e76b230a7ce85485e203563470c40cd927f94240daf73aeaf552567a39c03126bbe8a350116929965db5d7db212472cbd086a7a4f6a59a3c2828fc319c62286b294bd2bf75475df3f4dad9c56358445082a6734ebd54b686c59e58be99116d7dc7fa01e391eeb82d7cb94a59abd118dafb6b154e13de22dced33762daf2a70b9eee3563c3130b12919f8bd1372ea8bbe9a43a6171e0c303d024ba2f8d7ba4c182cd9bcc0de037da3708bd41a2157dee9adcd62715f76f8ac5185b0fdf5453e73c6641612dcc6824bf8e4aa8d7271147d786bb33c203b939f8578cab06c44f191da40cc754931f7c02be6a26fab84c56995d648b20e093827e5a14ae104abaca8dbc672a4196bdb2b33552de94577640ac18ea0ba0666b7a79336849cad5bf07a91ab3a2d4ff810309081138ebd7b7e7c545da6384328cdf07e50394eac355afed07a9b2b2c366a26e2dbced7a975a583f9cbbbdef46a67903e7aa266a1f4f97df2ed466c9e18387c170143833f62bc1ea398c1320a1f8bd46d5ba42b3e365d832e7226b86554d6963fac6d4e955fcf05983ca9b5b08ec104e1108490719f73635d1ee679033ca6a3569b394afe7bc1704c15a8c2ff637d19094c3bd78e1806dcb7e9b4cdc4e92f95b6c928f39f9826699fc215742e6b3cba412cb3c7c58cb4fc08f0e48b37d503bce770a301d7ff79176d69e5c8360e2c1b3e5c9a5020ff0aa85041c9783a39bb7b3d58d406cc01fe4b362c68e1fa120c08adc8a8ffba4ccd1d4f2511532781b46186b98a65a1fed829ad5df5ebde25033351415175577963691da4f65b6c4aa31d9ce2297740852a332ca4f9f473b3dac41ca6fb702470add8020287aa79a05d373aa7ae7d8c56f99edda1e26f4168504ba14883185ecc46706ddab0506c111c6ebf429c9ca698e88f024ab1290170df614fac1c35f766622e0a08b25cdfbdd76da114bb675f6ef561ee13d90979acda3cc41a74ca85c38ae40dfd8e33af9269a343daa561dd6dc37baf89e2f8c3bf04c060f5633adba2500306f6004edfd430b1df4d10e989d4e64a1dee7fa135c72d91a188ada2a09eb210adde7ff5eed41000d5d61b8b41e1b1c3fd6bf491930c1cdf4fbdc01e16bc290194e3f0a0025fbf8ff52b227cfa73839a5d8e3da0e079dbb8a9b1b26277a19e3ab396af81061735a6ff963125db048335b453dc9f0361184f21bd6ca51e4f880f785c51f2493c39a8ae1b4693824617438f0c63c89e3d1e25ba595ea58661b84cb405ed9a0776f952c6cc794dbce3704e46031bc49a39a901cf9420e2e26a15047342b45aadf9c4e4392e843d3c081efeee466e826d85cb6be5e530dd413533a2dd8cb53b1178158f6d5186396161e0d516e057bcf67e660fc43d972017c48a396cf5e2d9c3a5d9e5f9757fcf9ab45df3e113539805a90553758cfac63660bacbce08c967674f4a9249d6a1ddb5fe361f67d9a88c7fed28f8c86a31575cdb4ce5277997f912b599e030d403ede2cc1536121d2e00f262797bc1aefb6c4c7232fb4275128fe9bd907ac50109dc00bd32cf23ff34b07f5099af4acd364b0689b060923b98a52185153365288302cc163bd299e742b4b98ec2a06cff719ec807d593bd7c558572d17cb5b4551f4326e7f192e3316fb810169bb4904ad9d6cccfc41ca063a4c06fd9394e7e95fc504fcf68e3c4d82158efc93305ba85a0de1ad7c766eaa884a5ff5d30aafe76a0067b4ba400cbd80dc78f6c22bd974737e361bb5f6ab984e755a0d89219a2d0044cefa58b024e35aa40a0c31c1095e566c6d4489a44050746a43f9678ecec01387c17f0d97096871adccb5336950972562eb4b4e9cf854fa6845c8ac5c2192c0c73dd5b4c9810e07d44a1713b22e4616fa66423e208dae347519389a4036368763d3170818978f9c21618b88b86cc9d96966ec01e9e2e5eeae278c6c8b79dc7a0cc41f15a3a72f7de135cd284676d7acff44fcd222413de7a9ebdd2d66dfe3655c95af2b81528fea7f5489f92216ccae28d42a35b5734f41421cc305df472f8fb6106f791969883454fc24732018f932b6afc6780eb5901f935da03d30921eb9582ea2b49904840f6500accb77458eeddb88e0877aace86786c9c37218de6721e3615f396ebbb3a8d1b654dc28488bc88ae71fd654b09fc4edd240bfcdc59267b39f586c00c3d020789de3f7f37ff871127138ad11b7f2cbf8dd295cf2e26ddcab3f204ecfe5d70e8957447b606c9f01ed4a14e0c200bd136b83d929dfd44dc66eee9024ccc59789340f5df8e9926ac7caec1b67b55a04199c9ac12b7dde6f18ffd23ae649aadb3ac86c5f620b2bbdb1cf041896913c2f9f911a0e3ad12b11916e250875e8b33ac2dc0010171d34eb6837ea10effdd879b3ab14ae1ec9b7af7fb27418cc4eff8e42d72846d8eedb27f4f8e76b7583efd7fa653c5d2450a4ebbcd0111713bcba8a630d161afa7d208f4ada93bbc10000f17fa2ec276951325b60f75c7411f2c9c138d3f812140a6dfafeb0eb7cc4ab52482856985e8faecf05c0213bd4db90723208bfc7b4c06d9334c559892cdf62e0ca6b51340f1145d85356b2db4e30dabf0c8df85712dd8095b08010a92179c36b89dd26c9393aab53a637ca7675c9194e0237203e7e724dab76cf8c15921632560fccedc602f2ff05075cc484410d8307fe5b7b0421841f781ae6b91174b9391fcadac4022e3229d15872479dd2c1121c8cca4a6c2a66b3337ec5b576abfbebc8a88c28d0790bfed99b7f232be33dac839234721fda77aaf70b5e2681e2455610dcb13e3b76ed5ac5c97156b893676ea7761eea558ae7a4ab3514aeb85e0389d94cafd8380e3ecdbb2ac1f889dcfd6922563009d595099a60e8002878ed78cb799528bc846170d3b615671febc71e865a8202db493a1317bf0e34cb989b0bd9c1bc97fc44cc6755afec0b0373509535382fe0a79b960181ff67f90e1d2640e7939e99bed81d4b25e32c2dd1dc746c540fd82c6eaf08d12d650fa81f3ba8497a3f9b68e15a1477a93ad337f463151cc7dcfad267426f3704e27356663352c8681aa42a8bb68b38a46df8193e9e9893230c21a2482f8888ce0fb00bd188bb8d0cf23ab81a6eab841f38428ae314fe81a9a737fa2e13fd95e33e22c5cd09b0a5b30d8c27d9b8e4e14f2437afb5c62182f74232acd13ca7e003fd9106ed98781068bdb0cb9bbeff67618ed001299a26bcba40a0dece3a2dfa01cc33fde3d20e4c20dc29639f7cbc6b7051e80348ae2536305c88c984b4adf02339f7133d411968b56d7445277bd860aeb24dab70ff77ed370f50e6c5257eba7efea784b5aef647d6bea5e5444b4a3b0627ef3bcd68ab130aaebc9d7b8e093d37390f2887140a8ebd99e045acf39dde3cb2ba0c35e4307aea78a38dbb401f8290f7ecc732a60d9831e882f18040112e0de24d230583a7eb591140b10d64212fe369f119ea3b63158dd57fe645f420bd2cb2041bc3b278fdfbdbe12cc3896bb590bdcc81456ba69e0e5c4fa60c897ed733b67e37cb0e63f1c0e532f07d3d9a1d12daed948320d5cae49b0f3a51c014235b60039d3a1a5da31fc5886a430442ea79ef5ee04477bb353c8671a6b56057769a87b06adfaacf42fdd62408be2f8031ece7b508fad29f4dfd47ad442532a3799388af9230e78a54ad99049523b8ab5f6da1f681e6b6c73edd6e78ea9d85e428aac5065c1ca5efd590c9db32080431f3e770f746143c914028ebbe77a9e1effd78347e72933135d269447cf433913b350a0bbedc8a41e26382e70f95489981f9ce923db46a4f115b89c1b721f44b4254cd7c2ff2268300e8b4106163b43e467bedcd578001c651b14ccba73db89f8a4b26f3831f9b6be9818add3240ee73419f8b0422e3218be8310c430f2251ff87b078953deafe192a5577c1283d1d5724f03b454cd619b8f3784431c1405263f906faec210976688af6b26ec42c8a92401c1a54378e1f44bb539beb20ac36acb432fe83b1f19b3bc243154dd55dd635a14bc38647af89fad2328bdee4c1f32782d17829516e17f18033056078c9dfe7ae0d7785fe96cfd44ea9ae45bdcf66ed1df1f592f986d6362429f855d807ae1f2babc881a8c8d34f8fbe92f1790b39d7084913286917a23274254b56ef0c47b78b76d76fbbcadd5c6d004349ef1377c6698711370a7a5b70265f59f8336ee48ba136971a668861280cb4661db4a0a4c8201b9feb9ad1b748c5ff40b4f21b3192c4d9de1007555e8c4736eb29f28106bd405fedb54e5a13fdc42ba7acf837068c691fa11b3cf632302897b1f5dc13f4ff362e5510cea2d85b77d73d5d3243483e2ebac273036477923b5fae56f7c59a2e23b2a13aa83ca2b2f7068176e2eccf60bc44229508957a04ed6eafd84e7905a7475bca54ce4d052455d93d658792550cbc78eefa844d4c9ebec2fa7853e6c6ca77d8249dd62fe9a27cb2c8cc7c7e25a63599130dd17f419105e40fe4b7fa1324156a977311dc53664fcff917683d3c42d2e1fa6a4fcec3c40d06984269cd3b96dc1506a64b6cd8d6845bd2c3e237534523f63b86c898fb774c2be23f033f7c4b0b96833c3285cd31c79e32faeecf5e72288d6397d907b4fdc83b905726d5fe64ea92f8ae7dd03ca316221c0cecd9828d02738d1fc5212dd322acca6a6762eb10a0b56dc16e34ad1516564cdf6bf855a2a29c7105975465901f3de0d51765d21e3068fe51bb024060ba65d784fc9bc3b1d5b73020065c0386d8992af5df3c44ab9c263b72d37b9c7f9278cba7aecc9457acdc97220fc07027acf772a7cad97de68d09574cf11806f376b89fdf561f4555b6f8b8a4d981392ed86e2d38bf07d277f83650d2083949fcde3ff15478f9f6fce38227cb3368bd7f3ab754cd8b9f8f0f6fdfcdab8a689d8fad996f79430bd1ce05f5803fc6fc895ff68dd3969986523b200e3995751d85f03e39c184da57e513370ee4036215e164fc88f22b8455fad615c149fd4acab8edc71dde7614a768f0ca3ce4a27765e385aa0c5f020e63523145a2b44005be059c1dbb6c816879e2df35c8cf1c40d380fbae94648c1c4eddf3a978b9a7eb42eb78a439f16505ace09c8e0d891dff8d6d33000a99e22a95e49e5913cc5b9dc34de38e4a1e31e759efdb1f345f60b945ed39d47c03f25403e7131cb7d208976bc80ffa7f07b7fcaa3dd1f9a119b0a2b1027b0c1e902864f509788833f7cc80062ee34896c40f70b0ed1cde66faf9e1d2c9813ddf81b29e8436e8eb16ccb5909aea4eb972c4b558947a562301e7f75e4c0a4a2a73c94f5b83cf6dae37437131764f1ad376077dfad7fc2bde36214907f699dc2389a96794b7f9478b5566710ec364ccd8f0841ef8591051c2fcbb8d55369384990c7191b50b24870832b68d7dd3d3c5ef62ee93b05af53f2accb2abac86349e79f072fc061b546be1a98d1fdb57f8cf5ef698715f846a57ed9e49bbee751d0f6a2b0e6bf616c220c2246dcfd01bf15b5084dcdb161c6c0b2061f9f0d31af6b31aab0e74eb3ec2fb0add8e1ed8b66ac2499bb7d1421374dc93fafa4848589342407f0f77bf8bccb9f857e4c9e11371fb75c4dab7c9ca58d9886ff10fc5259bfa09bedb248969dea98d70961c9ee3fac4ef7f1c08891ec20a81dd085b82ce84a2f6a4591e16923185e55e79b190b1b14630430d49c9d48b569a0eb3d77f97a9e37282808b9641f0b7e06e50a9e772626a70c33d245e32fc03d7af7d1b346bb1f5ba14275b8fb492804ebac9629dc0f65f82a5e641ecfff624d91225e2ce3a8ffe5391b500eef673e668edf82e7e2099a720dc0507b1b14ff5334713b8790061ece844296182b60cd5f98c0868b1c2953ae1e7b574a0b177e0609915450d8ca6329c297e7aa032c866fc555c8d7545d2183be3a71db35dd6816b9ed9303124363a4f97428df47160c2ae5785b1b488b6ce861bf6611e13bf1af9329da2f3fcf2c1a016e33ddccb743aa0b03f4a17da417200cb8239ea98e7c9e7f41d5786c92e7bcbbf85afe17f7377ccbd80b2aadd803ee10b307019a68bd31da2ff5dc4efcd611b40124f5846afc831e95fabbe0015a6113e2e2bb00fd7a826c9f766302736bc0e98a2fccdfdb5b203a7e74d752cfd341e90a97a43870a2e9be3566edf290ee37e79cfbca7fc1862967b0ab9bc8e67766d1d0805725779cbc9f3bfce3c2a27be6e534db7b440dcf04d367650f8a984fc9ae2a995aa6e80bbf448bc86d1faa519e8721896aac4cd2c81d1993502da0f99b1fea369162950bc51c712173ab7533ccf160ce2202f16a88e1da744e8bcd27ddcfd538945fad8b0504234a93c69a08fd874a5e1cc763d1a11b9db2957182a5d0c090675b58c2e450d512ecd26cc329b52c60d9d6e14a0595b9852358095ac543517f8f465c9d9e60068e68cebcd9905affd3dd7b4e2f212e2c2d507f01e1b88476873ae0c94a842bef0798f3789617956c2059ec57d88d45cca4c10f5edf4c246fdd6e8033639c30832302baf5268d77fe6848fd6b9fd1a12ada9d981ac27814bb8d47220ea7812010740525171076d74eaebbd1658a63bdd81bc705589c7db64eb00b30a1bcf21838a37658b292512017c10a5481a425d7ac68a52e92571b9d775e9ade6974c6a450e07f4f23ed9b8371569bc2f06ca4414af82df582c7bb0ee020db70ed55c7da65f50c7a520b605733a27749ce593cefa45c6037aa95fc550654834c9a2e1e95c72dd13e7eba95ded5202623a85e899651795eed85641ac8a82b3cd000f5aca6583d3a559fc884c65387dfbe5fe46a6790944b3540c814ccfcf32b3a2ae21745160d4cc3a35bc9426592f578ef8b0c217afefb6c98fb7d8a28b1a877b6cc703d41601a8c0a8a443dfc107b32447c7651f366f07e4fea79fa927c71fff793bfa4a2d2616ae9cb2e6e377cee89e3a549d54a7b392118af1da3b2b78881b88fc19586fa3940a63796b84f98848f16fdebf8e3850ba23582931f79f80ab1c56675a52f5ecdf4c4ab0bfa99fa26e19edf6f8a32feeb5d929b5df0672a39f75fd1d3c7285ce698ef4aee6e6d4c0a23e9f280f79663a68c9bd2446d4f2c825596a4d87bc642d8623cec0471b093e70c99edf537a8abb104038755874b8f2937d357429b21ccacfeda7b484c314a0dac6cccfb1fb262c3009cc8706e36368406e0cab52c5af57c92aaeee50c5031431d0535457791c7cf3221f3f23bff1bb8492a7cb6541607e82666c8191f7853236a351e1e5435a0740921b4f17be1154714931238ff528f2e51a7726a6e01930322e505691fe45e7e944cb426ceb96ae671bf00d847ce3d0b35edaef00cc9cff5beb05b030fe274c5bd76415b2d1dce2f6b91f574a8d4d02f95281f452cb63d2058ca8419f506fa93ea9884af55d7e6bd1c8e86d9bf36f67296859c95014521b1881f22d9473e03b51c2633758f9a5ed601989366bbd34027dc1bd2d91f9440c6eab4104d3d20dd005720a804a17691ad88915fa90901851f3d000384a766081cf8ca10a4dddf223329f6fd0c9f38fdccd214de1b86200632a7ace276b9f1a7a9612503cb4190ed123ce5817d290786af62e1404c4c413ef6d22a64e338052ddf443d5dc01417c9d0d291239550cc2dcd54ce9a1c5492239dcaa86117242b16b540dc5894a10e914d754af0ed35aad12d08b1c7e22bdac91d764ab8b2ac6199896d8d105f7830603ec337da37acb5df196dbc3ee4dca42d5318166a0dcf75442b2473d4cb7cf498fa97ca6d87b1cbb4ec4242573c2c9276fd310d111d9f459428571e0823c22c9a2065c3e5f8251b4da149eb646047e981480fdcdd557b5775ecd39b00539944507a237e761d5a92795e22d8d0</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>青春回忆</tag>
        <tag>我与她</tag>
      </tags>
  </entry>
  <entry>
    <title>第五周LeetCode</title>
    <url>/2019/04/25/fifth-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第五周LeetCode刷题记录"><a href="#第五周LeetCode刷题记录" class="headerlink" title="第五周LeetCode刷题记录"></a>第五周LeetCode刷题记录</h2><a id="more"></a>
<ol>
<li><a href="http://wuyunjie.top/2019/04/17/LeetCode-27-Remove-Element/" title="LeetCode--27. Remove Element">LeetCode—27. Remove Element</a></li>
<li><a href="http://wuyunjie.top/2019/04/17/LeetCode-28-Implement-strStr/" title="LeetCode--28. Implement strStr()">LeetCode—28. Implement strStr()</a></li>
<li><a href="http://wuyunjie.top/2019/04/22/LeetCode-29-Divide-Two-Integers/" title="LeetCode--29. Divide Two Integers">LeetCode—29. Divide Two Integers</a></li>
<li><a href="http://wuyunjie.top/2019/04/22/LeetCode-30-Substring-with-Concatenation-of-All-Words/" title="LeetCode--30. Substring with Concatenation of All Words">LeetCode—30. Substring with Concatenation of All Words</a></li>
<li><a href="http://wuyunjie.top/2019/04/22/LeetCode-31-Next-Permutation/" title="LeetCode--31. Next Permutation">LeetCode—31. Next Permutation</a></li>
<li><a href="http://wuyunjie.top/2019/04/23/LeetCode-32-Longest-Valid-Parentheses/" title="LeetCode--32. Longest Valid Parentheses">LeetCode—32. Longest Valid Parentheses</a></li>
<li><a href="http://wuyunjie.top/2019/04/23/LeetCode-33-Search-in-Rotated-Sorted-Array/" title="LeetCode--33. Search in Rotated Sorted Array">LeetCode—33. Search in Rotated Sorted Array</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>第四周LeetCode</title>
    <url>/2019/04/18/forth-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第四周LeetCode刷题记录"><a href="#第四周LeetCode刷题记录" class="headerlink" title="第四周LeetCode刷题记录"></a>第四周LeetCode刷题记录</h2><a id="more"></a>
<ol>
<li><a href="http://wuyunjie.top/2019/04/14/LeetCode-20-Valid-Parentheses/" title="LeetCode--20. Valid Parentheses">LeetCode—20. Valid Parentheses</a></li>
<li><a href="http://wuyunjie.top/2019/04/14/LeetCode-21-Merge-Two-Sorted-Lists/" title="LeetCode--21. Merge Two Sorted Lists">LeetCode—21. Merge Two Sorted Lists</a></li>
<li><a href="http://wuyunjie.top/2019/04/14/LeetCode-22-Generate-Parentheses/" title="LeetCode--22. Generate Parentheses">LeetCode—22. Generate Parentheses</a></li>
<li><a href="http://wuyunjie.top/2019/04/16/LeetCode-23-Merge-k-Sorted-Lists/" title="LeetCode--23. Merge k Sorted Lists">LeetCode—23. Merge k Sorted Lists</a></li>
<li><a href="http://wuyunjie.top/2019/04/16/LeetCode-24-Swap-Nodes-in-Pairs/" title="LeetCode--24. Swap Nodes in Pairs">LeetCode—24. Swap Nodes in Pairs</a></li>
<li><a href="http://wuyunjie.top/2019/04/16/LeetCode-25-Reverse-Nodes-in-k-Group/" title="LeetCode--25. Reverse Nodes in k-Group">LeetCode—25. Reverse Nodes in k-Group</a></li>
<li><a href="http://wuyunjie.top/2019/04/17/LeetCode-26-Remove-Duplicates-from-Sorted-Array/" title="LeetCode--26. Remove Duplicates from Sorted Array">LeetCode—26. Remove Duplicates from Sorted Array</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书|2021阅读]--《如何阅读一本书》</title>
    <url>/2021/05/14/Reading_2021--How_to_Read_a_Book.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>如何阅读一本书<br><a id="more"></a></p>
</blockquote>
<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><iframe src='https://www.xmind.net/embed/3TzT/' width='750' height='1000' frameborder='0' scrolling='no' allowfullscreen="true"></iframe>]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书]--2020 阅读清单</title>
    <url>/2020/09/11/Reading--2020_Reading_List.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>决定要开始好好读书了，需要一个仪式感来督促自己，写个书单记录一下<br><a id="more"></a></p>
</blockquote>
<h4 id="1-天蓝色的彼岸"><a href="#1-天蓝色的彼岸" class="headerlink" title="1. 天蓝色的彼岸"></a>1. 天蓝色的彼岸</h4><blockquote>
<p>这本书是一个温馨的童话故事，由 <strong><code>梁忆云</code></strong> 小姑娘倾情推荐。从一个小孩子的角度描述了去世后的世界，没有天堂，没有地域，只有<code>天蓝色的彼岸</code>，那是我们的最终归宿。</p>
<p>没有花大量笔墨描述另一个世界是什么，而是回到了原来的世界去弥补遗憾，顺带看看没有了<code>我</code>的世界会不会不一样。遗憾的是，世界照样会正常运转，只有最亲近的人会为<code>我</code>哀思。哈里从不可思议到不留遗憾向世界告别，整个过程穿插着各种人物的小故事，有阿瑟的温馨，也有依旧等待着温斯顿的斯坦。它教导我们: <strong>要珍惜生，但不必畏惧死</strong>。很治愈。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/The_Great_Blue_Yonder.jpg" alt="天蓝色的彼岸"></p>
<h4 id="2-追风筝的人"><a href="#2-追风筝的人" class="headerlink" title="2. 追风筝的人"></a>2. 追风筝的人</h4><blockquote>
<p>这本书还是去年开始读的, 或者准确来说是<code>听</code>的。去年刚上研究生独自留校, 在学校附件租房, 晚上回去的路上十分宁静寻思找点事做。从最最开始听歌听相声后, 开始逐渐喜欢上了听书, 也是这段时间在喜马拉雅上听了<code>追风筝的人</code>。但后来开学后没时间听书了, 也就搁置了, 一年了也没看完最后两章结局(这拖延症也是绝了)。最近两天开始读书, 又把它拿出来读了读。</p>
<p>最开始听说这本书时, 以为是逐梦+友谊的治愈类小说, 但实际上是遗憾、成长, 以及阿富汗的战乱, 二十年后的物是人非。阿米尔和仆人哈桑少年的友谊纯粹而干净, 但在残酷的社会环境现实面前, 懦弱而渐生偏见的阿米尔, 选择了沉默和逃避。他做了最错误的选择，设计赶走了哈桑, 可以<code>“为你，千千万万遍”</code> 的挚友。此后阿富汗战乱, 社会动荡, 哈桑也就此与阿米尔阴阳两隔。之后是寻求救赎的成长, 阿米尔收到拉辛汗来信决定赴约阿富汗并救回了哈桑的儿子, 自己的侄子索拉博。他不再是少年时对哈桑沉默逃避的阿米尔, 是在寻求救赎中勇敢果决, 抛弃偏见挺身而出, 最终坦然接受的阿米尔。阿米尔与哈桑的友谊固然光芒闪耀令人生叹, 但阿米尔的成长却更加打动人心。</p>
<p>在故事结尾, 作者对<code>结局</code>进行了一个简短讨论。</p>
<blockquote>
<p><code>阿富汗人喜欢说: 生活总会继续。他们不关心开始或结束、成功或失败、危在旦夕或柳暗花明，只顾像游牧部落那样风尘仆仆地缓慢前行</code>。</p>
</blockquote>
<p>或许我们有时候并不知道人生的方向, 路的终点, 但也不必知道, 我们在风尘仆仆的路途经历或许更加诱人而回味。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/kite_runner.jpg" alt="追风筝的人"></p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书|2021阅读]--《围城》</title>
    <url>/2021/05/11/Reading_2021--Fortress_Besieged.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><code>这个时间落伍的计时机无意中包涵对人生的讽刺和感伤，深于一切语言、一切啼笑。</code><br><a id="more"></a></p>
</blockquote>
<h4 id="《围城》"><a href="#《围城》" class="headerlink" title="《围城》"></a>《围城》</h4><p>早已听闻过《围城》的鼎鼎大名，尤其是那一句<code>&quot;城外的人想冲进去，城里的人想逃出来&quot;</code>听闻依旧，似乎暗含了人生至理，但对其也似懂非懂。这段时间也总算有些许空余时间，把这本讽刺小说给读完了。</p>
<p>初读第一章头几段就被钱钟书先生的辞藻，比喻给经验到了，有趣而又不失生动。对场景心境的描述都恰到好处，或许要比亲眼看见都更加形象，钟书先生不愧为文学大家，仿佛这些文字都信手拈来一般。这里摘几段对场景的描写：</p>
<blockquote>
<p>“红海早过了，船在印度洋面上开驶着，但是太阳依然不饶人地迟落早起，侵占去大部分的夜。夜仿佛纸浸了油，变成半透明体；它给太阳拥抱住了，分不出身来，也许是给太阳陶醉了，所以夕照晚霞隐褪后的夜色也带着酡红。”</p>
<p>“谁知道从冷盘到咖啡，没有一样东西可口：上来的汤是凉的，冰淇淋倒是热的；鱼像海军陆战队，已登陆了好几天；肉像潜水艇士兵，会长时期伏在水里；除醋以外，面包、牛油、红酒无一不酸。”</p>
<p>“满天的星又密又忙，它们声息全无，而看来只觉得天上热闹。一梳月亮像形容未长成的女孩子，但见人已不羞缩，光明和轮廓都清新刻露，渐渐可烘衬夜景。小园草地里的小虫琐琐屑屑地在夜谈。不知哪里的蛙群齐心协力地干号，像声浪给火煮得发沸。几只萤火虫游来游去，不像飞行，像在厚密的空气里漂浮，月光不到的阴黑处，一点萤火忽明，像夏夜的一只微绿的小眼睛。”</p>
</blockquote>
<p>这样的描述在书中很常见，我这样囫囵吞枣地读完，也不知道是不是能学到几分。除了用词外，钟书先生对人物心境的描写也是活灵活现，很容易引起我的共鸣，尤其是对爱而不得的失恋心态，入夜难眠的困扰，仕途不如意的烦躁……这些心境让人感觉，这好像就是我经历时候的想法，尽管经过百十年的变迁，现在看来这些人之常情的伤心困惑还是如出一辙，或者也可以说历史总是惊人的相似，我们所经历的不过都是历史的重演，并没有什么稀奇事。对自己来说它的确是痛苦万分，感觉难以熬过的坎，确实对每个人来说都是第一次经历。但从全景来看，这也不过是芸芸众生所共通的人生经历，那么平庸平凡，甚至没有一丝波澜。或许人生之事，尤其是感情上的事，无非也就那几分田地，无论多新式的现代自由恋爱观，也逃脱不了冥冥之中的定律。扯远了，来看看钱钟书先生对心理感受的描写吧.</p>
<p>比如对上台时紧张的心理变化，这不正是上台紧张忘词的状态吗。只能着急，但再着急都记不起自己的稿子。</p>
<blockquote>
<p>“拚命追忆，只像把筛子去盛水。一着急，注意力集中不起来，思想的线索要打成结又松散了。隐约还有些事实的影子，但好比在热闹地方等人，瞥眼人堆里像是他，走上去找，又不见了。“</p>
</blockquote>
<p>浑浑噩噩的人生状态：</p>
<blockquote>
<p>“早晨方醒，听见窗外树上鸟叫，无理由地高兴，无目的地期待，心似乎减轻重量，直升上去。可是这欢喜是空的，像小孩子放的气球，上去不到几尺，便爆裂归于乌有，只留下忽忽若失的无名怅惘。他坐立不安地要活动，却颓唐使不出劲来，好比杨花在春风里飘荡，而身轻无力，终飞不远。”</p>
</blockquote>
<p>对失恋后一段时间心态的描写，感觉很相似，真的失去一个人，就是这样感觉世界昏暗，自己也再也融不进去，与一切都格格不入，仿佛置身到了另一个世界。</p>
<blockquote>
<p>”方鸿渐把信还给唐小姐时，痴钝并无感觉。过些时，他才像从昏厥里醒过来，开始不住地心痛，就像因蜷曲而麻木的四肢，到伸直了血脉流通，就觉得刺痛。昨天囫囵吞地忍受的整块痛苦，当时没工夫辨别滋味，现在，牛反刍似的，零星断续，细嚼出深深没底的回味。卧室里的沙发书桌，卧室窗外的树木和草地，天天碰见的人，都跟往常一样，丝毫没变，对自己伤心丢脸这种大事全不理会似的。奇怪的是，他同时又觉得天地惨淡，至少自己的天地变了相。他个人的天地忽然从世人公共生活的天地里分出来，宛如与活人幽明隔绝的孤鬼，瞧着阳世的乐事，自己插不进，瞧着阳世的太阳，自己晒不到。人家的天地里，他进不去，而他的天地里，谁都可以进来。“</p>
</blockquote>
<p>也曾经有个这样的幻想，钱钟书先生倒是把所有可能，所有境遇都给补全了，这就是失恋人心理还存在着的不甘和侥幸吧：</p>
<blockquote>
<p>”每出门，心里总偷偷希望，在路上，在车子里，在电影院门口，会意外碰见唐小姐。碰见了怎样呢？有时理想自己冷淡、骄傲，对她视若无睹，使她受不了。有时理想中的自己是微笑地镇静，挑衅地多礼，对她客气招呼，她倒窘得不知所措。有时他的想像力愈雄厚了，跟一个比唐小姐更美的女人勾手同行，忽与尚无男友的唐小姐劈面相逢；可是，只要唐小姐有伤心绝望的表示，自己立刻甩了那女人来和她言归于好。理想里的唐小姐时而骂自己“残忍”，时而强抑情感，别转了脸，不让睫毛上眼泪给自己看见。“</p>
</blockquote>
<p>思恋与错过，爱而不得地无奈与痛苦:</p>
<blockquote>
<p>”心里仿佛黑牢里的禁锢者摸索着一根火柴，刚划亮，火柴就熄了，眼前没看清的一片又滑回黑暗里。譬如黑夜里两条船相迎擦过，一个在这条船上，瞥见对面船舱的灯光里正是自己梦寐不忘的脸，没来得及叫唤，彼此早距离远了。这一刹那的接近，反见得暌隔的渺茫。无抵抗、无救援地让痛苦蚕食虫蚀着他的心。“</p>
<p>”那种情感，追想起来也可怕，把人扰乱得做事吃饭睡觉都没有心思，一刻都不饶人，简直就是神经病，真要不得！不过，生这种病有它的快乐，有时宁可再生一次病。”</p>
</blockquote>
<p>或许多年以后回想起曾经，遇见故人，也会被时间冲淡，木然无动于衷。把曾经的感情或立碑志墓，或暴尸荒野。只是不知道这个时间对我来说会是多久。</p>
<blockquote>
<p>“等柔嘉睡熟了，他想现在想到重逢唐晓芙的可能性，木然无动于衷，真见了面，准也如此。缘故是一年前爱她的自己早死了，爱她、怕苏文纨、给鲍小姐诱惑这许多自己，一个个全死了。有几个死掉的自己埋葬在记忆里，立碑志墓，偶一凭吊，像对唐晓芙的一番情感。有几个自己，仿佛是路毙的，不去收拾，让它们烂掉化掉，给鸟兽吃掉——不过始终消灭不了，譬如向爱尔兰人买文凭的自己。”</p>
</blockquote>
<p>在文末，鸿渐悲伤到绝望麻木，或许也不过如此吧：</p>
<blockquote>
<p>鸿渐走出门，神经麻木，不感觉冷，意识里只有左颊在发烫。头脑里，情思弥漫纷乱像个北风飘雪片的天空。他信脚走着，彻夜不睡的路灯把他的影子一盏盏彼此递交。他仿佛另外有一个自己在说：“完了！完了！”散杂的心思立刻一撮似的集中，开始觉得伤心。左颊忽然星星作痛，他一摸湿腻腻的，以为是血，吓得心倒定了，腿里发软。走到灯下，瞧手指上没有痕迹，才知道流了眼泪。</p>
<p>不知不觉中黑地昏天合拢、裹紧，像灭尽灯火的夜，他睡着了。最初睡得脆薄，饥饿像镊子要镊破他的昏迷，他潜意识挡住它。渐渐这镊子松子、钝了，他的睡也坚实得镊不破了，没有梦，没有感觉，人生最原始的睡，同时也是死的样品。</p>
</blockquote>
<p>此外，本以为是书中金句应该出现得比较正式，至少是个什么深沉的感叹，隆重地引出这样的人生哲学。没想到确实一次开玩笑般的谈话里引出了，甚至不是主角所言，鸿渐这时候还在旁边插科打诨呢：</p>
<blockquote>
<p>慎明道：“关于Bertie结婚离婚的事，我也和他谈过。他引一句英国古话，说结婚仿佛金漆的鸟笼，笼子外面的鸟想住进去，笼内的鸟想飞出来；所以结而离，离而结，没有了局。”</p>
<p>苏小姐道：“法国也有这么一句话。不过，不说是鸟笼，说是被围困的城堡fortresse     assiégée，城外的人想冲进去，城里的人想逃出来。鸿渐，是不？”鸿渐摇头表示不知道。</p>
</blockquote>
<p>各个角色的形象性格也很鲜明，随着故事情节的发展愈发饱满。比较出乎意料的是赵辛楣，最初出场时与方鸿渐争风吃醋的情敌，或许是网络爽文看多了，把这样一个角色初步定位成了一个小反派，为了苏文纨故意刁难不爱苏文纨的方鸿渐，自以为出尽风头，反而弄巧成拙。看着就好像故意为了衬托方鸿渐而设置的一个悲剧角色。但愈到后面愈发感觉到赵辛楣可能是书中最为直率坦诚的人物了，也是我在里面最喜欢的角色。最初开始发生改观是他作为方鸿渐情敌，与之争论时发表的意见，语出惊人：</p>
<blockquote>
<p>“教书是开发民智，板报也是，两者都是精神动员，但论影响，还是教育来的深。”</p>
</blockquote>
<p>这么一看突然肃然起敬，没想法这个反派人物还有这样的思想高度，确实比网络爽文里面的无脑反派立体多了。看起来只是个因为爱情的醋意，冲昏头脑的有志青年。后面当他与方鸿渐和解，成为朋友后，大量的笔墨对他进行了进一步的描写。重情重义，为人坦诚，风趣可爱，这时候反过头看他开始的表现，反而感觉合情合理，衬托出他的深情与坦然直率。当然也并不是个完美人物，但这些已然让他散发出独特的人格魅力，不禁想跟他学习一些东西。说起来，书中看见他在喜欢了二十年的苏文纨结婚后，发表了这样一番话：</p>
<blockquote>
<p>“我没见过曹元朗，最初以为苏小姐赏识他，一定他比我强；我给人家比下去了，心上很难过。那天看见这样一个怪东西，苏小姐竟会看中他！老实说，眼光如此的女人就不配嫁我赵辛楣，我也不希罕她。”</p>
</blockquote>
<p>这时候对他肃然起敬，感觉这个豁达开朗，拿得起放得下。但后面看也不尽然，这里面或许还是有傲娇生气的成分在。后面还是是不是透露出对这份感情的悲伤遗憾，对其的执念，要不然也不会因为汪太太与苏文纨相似而迷了心，这也算是他的一份情深吧。此外，他对朋友的热情体贴，绅士风格也很让人钦佩。比如专门为朋友温牛奶，为鸿渐疏通工作，备厚礼等等，都感觉这是一个值得深交的好友。最后杨绛先生说到这个人物脱胎于一个五六岁男孩，小孩子的直率天真或许是我们逐渐失去，也奋力追求的事物。</p>
<p>不过除了正文部分，杨绛先生写的后记也生动有趣，感觉丝毫不弱于正文。反而看见她描述的带有“痴气”的钱钟书先生，感觉比正文更加精彩，或许正因为钱钟书先生的”顽皮”，才有了围城里面大量幽默风趣的描述。</p>
<p>全书围绕围城这一说法，或许婚姻是并不会如想象中那么美好，挤破头想进入婚姻的殿堂，最后反倒是柴米油盐酱醋茶的争吵，感情逐渐消磨，让人想逃离这样的困境。但尽管如此，我反而对这座围城有种更加的期待，那种点点滴滴的美好甜蜜也令人向往，或许我现在还是被美好冲昏了头脑，因为刚刚失去，反而更加憧憬希望，感觉自己可以妥善经营，将矛盾拒之门外。不过也可能是目前的一厢情愿了，真正面对时，可能又是另一番心态了。</p>
<p>最后全文以老钟的鸣响结束:</p>
<blockquote>
<p>那只祖传的老钟从容自在地打起来，仿佛积蓄了半天的时间，等夜深人静，搬出来一一细数：“当、当、当、当、当、当”响了六下。六点钟是五个钟头以前，那时候鸿渐在回家的路上走，蓄心要待柔嘉好，劝她别再为昨天的事弄得夫妇不欢；那时候，柔嘉在家里等鸿渐回来吃晚饭，希望他会跟姑母和好，到她厂里做事。这个时间落伍的计时机无意中包涵对人生的讽刺和感伤，深于一切语言、一切啼笑。</p>
</blockquote>
<p>生活就是这般讽刺，巧合。但一切却又只能随着老钟的鸣响，滴答滴答的往前行进，无论多么不舍不甘，多么令人啼笑皆非的错过误会，最终都会化为人生长河里的尘土，消散在过去，带不往未来。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/Fortress_Besieged.jpg" alt="围城"></p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书|2021阅读]--《月亮与六便士》</title>
    <url>/2021/04/22/Reading_2021--The_Moon_and_Sixpence.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>2021阅读开始啦，尽管之前也零零碎碎看了几本书，但我还是适合写写叙事类的小说吧，今年就从《月亮与六便士》开始了。<br><a id="more"></a></p>
</blockquote>
<h4 id="《月亮与六便士》"><a href="#《月亮与六便士》" class="headerlink" title="《月亮与六便士》"></a>《月亮与六便士》</h4><blockquote>
<p>阅读这本书的动机不大，只是最近失恋了，想多读读书提升自己，恰好这本书名声在外，没看书评和简介就开始读了。好巧不巧，这本书还真就包含了一部分爱情和梦想，跟预想的治愈心灵大相径庭，反而有种雪上加霜的感觉，这是天意吗/(ㄒoㄒ)/。</p>
<p>刚看开头枯燥难懂，讲的都是什么艺术家，什么艺术体系流派。咋一看真被唬住了，以为是一本介绍文艺复兴的纪实史，或者是针对开头介绍的人物的个人传记，会包含各种高深莫测的艺术赏析思想和术语，没想到到后面画风突变，又变成了一段爱恨情仇的小说。有人说这本书是讲追逐梦想的，也有人说这里面是包含了一种不正的爱情三观，只是被出版商的把戏炒成了畅销书。从我的角度来看，还是有收获的吧，这本书的故事并不轻松，甚至可以说有些沉重。结局也不好评判，对生活有不同态度的人会对结局有不同的看法吧。</p>
<p>首先从梦想的角度看吧，斯特里克兰依旧被塑造成为了一个性格怪异的传奇人物。尽管作者在文中提到:</p>
<blockquote>
<p><code>人类天生具有制造神话的特性，对于那些出类拔萃的人物，人们对发生在他们身上的奇闻逸事往往好奇心极强，编造出一个个传奇故事，然后对此深信不疑，达到近乎狂热的地步。这其实是浪漫主义对平庸生活的一种抗议。因此，一些传奇故事顺理成章地成为铸就不朽英雄的通行证。</code></p>
</blockquote>
<p>但实际上最后毛姆还是造就了一个与众不同的斯特里克兰，或许这样的大师本就与众不同，才能在芸芸众生之间鹤立鸡群。另一方面也或许正因为他们是大师/天才，业界传奇，所以他们的一切都被放大了，成为解释他们成功的理由。斯特里克兰四十多岁抛家弃子，放弃衣食无忧的生活走上了追逐艺术的道路，而且他很笃定，他不在意别人的看法，这是真的不在意，这是笃定地不断向前，不需要别人地认可，只是表达自己所想，活在自己自由的世界里。从生活环境的角度看，他是不幸的，大多数人都把梦想艺术看作酒足饭饱之后的精神满足，只有保证温饱后才能追求高层次的精神需求，这正式<code>马斯洛需求金字塔</code>，但斯特里克兰不一样，他似乎更看重自我实现上，当然这可能是我的片面理解。从这一点来说对主角很敬佩，但我也绝不大可能像主角一样放弃一切去逐梦，打破精神上的那层枷锁，实现自我。可能我是个大俗人吧。</p>
<p>如果看斯特里克兰的爱情，可以用一塌糊涂来形容吧。抛家弃子，拆散救命恩人的家庭，最后在孤岛上也留下苦命的妻女。可以说他似乎完全不在乎别人，他只在乎他自己还有他的画家梦，或者说是他对一种美，对一种精神上的追求，懵懵懂懂。但从他的绝情上看，确实描述得入木三分，对不爱的人那种绝情的言辞，真的让人很心痛，却又无懈可击，他这样的人活在自己想要的世界就已然足够了，别人的非议无关紧要，别人的生死哀愁痛苦也入不了他们的内心，可能连同情都没有，只有不屑一顾。从这方面来说，尽管敬佩他这样的处事态度，但这样的人却也是无论如何都喜欢不起来。</p>
<p>最后引用两段平常人的平庸爱情吧，感觉这是大多数人的人生：</p>
<blockquote>
<p>我能想象他们的生活，无灾无祸，日子过得踏实、体面，还有两个端庄、可爱的孩子，他们注定会弘扬良好的家风和地位。夫妻两个会在不知不觉中慢慢变老，看到一双儿女长大成人。到了适当的年龄他们的儿女便会结婚生子，漂亮的女儿将来会做个贤妻良母，生出健康活泼的孩子；而帅气的儿子也会成为英气逼人的男子汉，没准会成为一名军人。最后，这对夫妻开枝散叶后就会体面地隐退，子孙承欢膝下，过着充实、幸福的生活，到时寿终正寝，入土为安。</p>
</blockquote>
<hr>
<blockquote>
<p>爱情需要人们全神贯注，它使人忘掉自己去爱对方。最聪明的人虽然可能知道爱有尽头这道理，在实际中却不愿相信这一点。人们明知爱是虚幻，却还是为其放弃实实在在的东西，于他们而言，爱情胜过现实。爱情使一个人变得更强大，同时也使他变得更渺小。他们不再是自己。他们不再是人，而是成为一个物件、一个工具，要实现对于他们而言十分陌生的目的。</p>
</blockquote>
<hr>
<blockquote>
<p>“上帝的磨盘转得很慢，却也磨得很细。”<br>碰上这种情况一准会说：”魔鬼为达到目的总是会引用《圣经》。”</p>
</blockquote>
</blockquote>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/The_Moon_and_Sixpence.jpg" alt="月亮与六便士"></p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-3-从尾到头打印链表</title>
    <url>/2021/04/20/JZ3-print-LinkList-reverse.html</url>
    <content><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>输入一个链表，按链表从尾到头的顺序返回一个<code>ArrayList</code>。<br><a id="more"></a></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:   {67,0,24,58}<br>返回值: [58,24,0,67]</p>
</blockquote>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>这道题也挺简单的，感觉都是考察基础啊，怎么都标为较难。思路很简单，就是遍历链表元素，存入新建的ArrayList对象，最后通过一个反转函数对ArrayList反转。此外还有基于递归的方法，或者先对链表反转，再存入ArrayList。</p>
<p>这里对反转链表操作简单复习一下，可以总结为先存储当前节点的下一节点，再反转当前节点的pnext指针，最后重置head头部。</p>
<p><img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ3/reverse_linklist.gif" alt="反转链表"></p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><ol>
<li>解法1 存入ArrayList后反转<br>1.1. 直接加入到ArrayList第一个位置实现反转<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; List = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            List.add(<span class="number">0</span>, listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> List;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>1.2. 调用<code>Collections.reverse()</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; List = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            List.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(List);</span><br><span class="line">        <span class="keyword">return</span> List;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>解法2 反转链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = listNode;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(pre.val);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法3  递归方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><ol>
<li><p>Java <code>ArrayList</code>类<br>ArrayList 类是一个<strong>可以动态修改</strong>的数组，与普通数组的区别就是它是<strong>没有固定大小的限制</strong>，我们可以添加或删除元素。ArrayList 类位于<code>java.util</code>包中，使用前需要引入它，语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 引入 ArrayList 类</span></span><br><span class="line">ArrayList&lt;E&gt; objectName =<span class="keyword">new</span> ArrayList&lt;&gt;();　 <span class="comment">// 初始化</span></span><br></pre></td></tr></table></figure>
<p>ArrayList 是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p>
</li>
<li><p>Collections<br><code>Collections</code>是JDK提供的工具类，同样位于<code>java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。</p>
</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://www.runoob.com/java/java-arraylist.html" target="_blank" rel="noopener">String、StringBuffer和StringBuilder的区别</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
</search>
