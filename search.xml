<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git学习--基础</title>
    <url>/2019/11/23/Git-learning-foundation.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p><code>Git</code> 是一个"版本控制"工具, 可以用来管理我们的代码。简单来说, 就是可以像玩游戏一样, 给一定时间的代码存档, 以后就可以通过"读档"回退到以前的状态。 <a id="more"></a> Git 是<strong>分布式版本控制系统</strong>, 每个项目协作者电脑里都有完整的版本库, 完成修改后, 只需把各自的修改推送给其他人就可以让别人看见自己的修改, 也有充当“中央服务器”的电脑方便“交换”大家的修改。</p>
<p>这里版本库又名仓库，即<em>repository</em>，可以简单理解成一个目录，这个目录里面的所有文件都可以被<code>Git</code>管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以"还原"。</p>
<h3 id="git-配置">Git 配置</h3>
<p>安装 Git 之后, 使用之前需要先进行一些配置, 主要进行如下配置: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Zhang San&quot;            # your name</span><br><span class="line">$ git config --global user.email &quot;zhangsan@foo.com&quot;    # your email</span><br><span class="line">$ git config --global core.editor vim                  # your favourite editor</span><br><span class="line">$ git config --global color.ui true                    # your git color</span><br></pre></td></tr></table></figure> 前两个命令设置基本的用户信息, <code>core.editor</code>可以设置自己喜欢的文本编辑器, <code>color.ui</code> 能为输出到你终端的内容着色，以便你可以凭直观进行快速、简单地分析</p>
<h3 id="快速使用">快速使用</h3>
<h4 id="初始化">初始化</h4>
<p>现在可以开始用<code>Git</code>来管理代码了。首先需要将项目的目录初始化为Git可以管理的仓库, 切换到实验/项目的目录中, 然后输入: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init    # 初始化仓库</span><br></pre></td></tr></table></figure> 我们通过 git clone 命令下载项目, 里面已经包含一些 git 记录, 因此不需要额外进行初始化。</p>
<h4 id="查看版本信息">查看版本信息</h4>
<p>主要使用以下两条命令查看版本信息： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log        # 查看目前为止所有的存档.</span><br><span class="line">$ git status     # 查看与当前存档相比, 哪些文件发生了变化</span><br></pre></td></tr></table></figure></p>
<h4 id="存档">存档</h4>
<p>首先你需要使用 git status 查看是否有新的文件或已修改的文件未被跟踪, 可以使用以下命令将修改的文件加入跟踪列表 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add file.c    # 将文件 file.c 加入跟踪列表</span><br></pre></td></tr></table></figure> 如果需要一次添加所有未被跟踪的文件, 也可以使用 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add .     # 把工作时的所有变化提交到暂存区, 包括文件内容修改(modified)以及新文件(new), 但不包括被删除的文件</span><br><span class="line">$ git add -u    # 仅监控已经被add的文件(即tracked file), 他会将被修改的文件提交到暂存区。(git add --update的缩写)</span><br><span class="line">$ git add -A    # 是上面两个功能的合集(git add --all的缩写), 提交所有变化</span><br></pre></td></tr></table></figure> 可以通过编辑 <code>.gitignore</code> 文件, 在里面给出需要被 git 忽略的文件和文件类型从而筛选文件。新文件加入跟踪列表, 确认无误后就可以存档了: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit    # 提交工程当前的状态</span><br></pre></td></tr></table></figure> 执行这条命令后, 需要添加本次存档的注释, 可以根据这些注释来区别和寻找不同的存档。</p>
<h4 id="读档">读档</h4>
<p>首先使用 git log 来查看已有的存档, 并通过存档的 <code>hash code</code> 来回到过去。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard &lt;code&gt;</span><br></pre></td></tr></table></figure> <code>hard</code>模式会把你工作目录中所有未提交的内容清空, 所以需要慎用。</p>
<h4 id="分支功能">分支功能</h4>
<p>这就是 <code>Git</code> 的分支功能可以让我们创建不同的世界线, 即在一个时刻, 我们可以做出不同的选择, 使得多个"平行宇宙"并行存在: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch    # 查看所有分支</span><br></pre></td></tr></table></figure> 使用 <code>git init</code> 初始化之后会自动建立主分支 <code>master</code>。可以用以下命令创建一个新的分支: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b &lt;分支名&gt;    # 创建并切换分支</span><br></pre></td></tr></table></figure> 我们可以将新分支上的修改合并到主分支上： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge &lt;分支名&gt;    # 合并指定分支到当前分支</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文献">参考文献</h3>
<blockquote>
<ul>
<li><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/git.html" target="_blank" rel="noopener">git快速入门</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></li>
<li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Git Book(官方文档)</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo学习记录-博文加密</title>
    <url>/2019/11/16/hexo-learning-record--post-encryption.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="密码是 password" />
    <label for="hbePass">密码是 password</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="586a6d4bbda1292c2c009af368ee62897052921af6aa50e50b1dc6fed6b66eee">818ffb39eb08dc7f13d5091f8a8f23c728081811a2a8b86b35810d6b227ee0c579334aaf966a163a2da8f23c65394c48c7e71fa1f210a3c11d876a465166f502f0ba0b61f6f21f9b40ed22c5bf8c80aa77433ad3a5b8bfb5403e0ce183dae27bce084175852c60023ccd7cabb41743d8e9bd9d1df075f7d0c1d19072b5cc339c5a5fb2eeaaf1e3de410926069ccca677e314e14ad2b572de36e96467f736f757296f5cf7e9272d8386b624654e94892f5297d7c7a07a4593f517365f4183fffbacf460e2cb1cc349ad91649e66279204226457754f1e532a8472a3a024c0b6614fd9b1671088964757504d2b344ab6419367e191ea622f1a34925c4d71e7a3b56c3fc28afcf06f72188a2de063240fcf7c094e0a8821b113b2db3d9cbf7f9d6eb6ef7f7434e2664f85f629df9a925e06930f299be8a0f9435526e0544ca9f4b4151ee932874abf6a51c42a483f6880844d78aa4459199e22f8edff4e9b8d41f4782785c4907208ef74e018db8d446f3254bf8d37b1d7ff370d4ebc2d1f9db81fa9fb266e6c7ddaad563598355b34c659e1e84ed77586dd49c6994c303eb56f8bfdfc4bffd189be77618ecdffe131bfe0d3ecd43617eb704669a7aca0be538351f9aeccca2ce8e7748cdc844079b8c7771ffb62e4ceb73640cecc021a6d1d9f4b791a4b2403aa726a3d559124f826fe43d85062f78bcb3818d98fe0ab4afbd4915a02bb433dcb4f635fb9709ba277041c576d3c9670881eebbb918735e7a50ebf40a3af9ef4dea41992b356abd7137d25220f40d73b2d01a96cd3cd40f878589578dd74f0a155057c0ded2145d928df53be7b9672fa230b6c54f6e6375accacb886f9947db3f99af516c4478f47e404cb352549390bbd8be96532062c8a381ee6b9e7005c52714ef5e537287750dc574f1bec4d3f0dfa6ee83eebbd47b10a2e143c59885ee64b07e9f68c58ea207461344da07926f1115e2a343f48c415b7ec347a1b6331da78789c23c5c51a533bec1f109eb4553a12d5e18ba31320751e10c991230ba3e3f8f5c828b00862349ef066d01eecbbae6eaadb4c765cf3e5ae931a1c9d4bb6830ae7949cdb5c0a5dea76dc46ac0216d0bc5811e47f40e60d63f2abd0e9c382060d80a403ab6b148d198c30ad4aa98fd76835c66954a7b96eb40ede02036f133f88b882852bc1bab775f9f20dcdbe49b82b541d0340a3220c8223be11f460b05b1e2cacf354790886c016523a6f5e547c0d67b3dc7462a5caa9ece687f3f57bd5c469d1109052743ad36c34915adf99181ebaf4d1bbe8c13faa7254ccc41944de1cbfd6062352ad987fd883b789b9757413c75d84d6cd2f74c31f5154846696d8ea3104437725b02db7f0bfdc0742177ed08bd18e762274780628df3aff099abc0d427b9ee2471b095198a437cd201c37552208395f7a1661d95c73950426b2bb9476e65e2268189d29296b3749c7146fc9eaa6980ff6b60e5065bb4513e055e882fc394add1e364bd224f7fd91f7543a6b3aebe521863800b6b0bd3158075a4c8867456c2d5b5377797190eb11297627810602ce3cee3a513175a68a6c6b5ea1c30931a98d00c979df8769b7d2c0a5e61112acb2680aaee691d20ca51a05ffa56b30ec2389db7a815fe3acd35428bf56c1bef880eb4ae7694037f268b2b0057b2bafbd4d5d468b9b291b3cda6b4f256037c160775aeccbf818cb8a673cdbe58d4f881ec7975b0b5e763fa36a4d260b63a98e82384cf91236e3b46ee54d6df2a5857e86ea3f8c3cfe8671666cb98d882df11f8964602eec4d87266d993cbf9a7d6fc8f7cd091ca3aba131507faffc892b58d08750bbd606d8b5489c39c5b894313a963f340aac95b26f5b3c3519dbb0fb315e5b95ace090fe3b349068e71de09946cb6cfedb90f0d37f2152e5c482e3f87d4ee3ad22450754919377657935dab21c4fa7af6b54a46080494889cd543525887336ddf0b03b8e37fc9dbcdc584841d73f24f82450bbee22250007fe72df6212aad1b9a70b4ecb2bcbcc550331fcb374fd27113b2c21409135944dae941ad5b1cd98ccdf7864ef8f932329379631b881ec2a0896d05a08c90cf6707486870b8adfa5b64f04a6de03782f4128dd3085cb8e33354222ddcddd608fe286b03bd290c920e4a70d03393247fd14130a21f30c756fcf76f0f0637556d65abf73de7162647b8bd55e678c0e9edd827f77180ca35265a883e90d92cf58f3ea4d646ddaae8ae8e9e4cf566bed5a3358971632590278704f458bd957661257ef9dc38d2b89216b8f3250e9e9df533fb8f2f2b1509b2c1fb08503d31e06aa084d4636ed544665a5e8c8c047eda8d7f85abf280414126fe9fd89ce156bbbab1348b7ca93f7592bd4348d70fea3b8d088015838b5ac1be29abce5a056b40a749106da2188116301a8f73ba287d16a35f2e9eb1d20452a1d8001577f3d2788963dc71819c2717c110976a0bea2f46939352d5dba7adfbc46a99cfaa37b444357a55c2a6128501d4cf3b71ec0e3bd400834215a313760d61b80406e0ffccaba60e04955e6663d45e8e188320250027fd4dd47bdcdffe64e7247dfe3538fff82b11dfaa6d3699d250383fedb6982c202d603c746bbd08f6087943eb9e4a0577943cd2a96ef865b48b2aa7f6f3658388f1ea4443f492a0e5ec502cb2b31e2c3a2adeeb9ae7b57e07dd47da66e106a4171c85fa0032e83b290eb44d736b7892fdb9c7b5c542eac3f343699e03a213e8e9658c48b4460cd57efd9956c1c6576bdf7e625082e207baa2397eaba1b7d1ae7b3ec299cfc47d23b085b900c4886d6433524f6af5c30df3c04091b0e9a6cbc86421c2127408153f91c81fec956da1f4efdcc53b110c81c106a99d965aafbf77abca765932388a4885747689793bcf18ae3014713c4eb4ac32b3616e253d1f5876f50a8ab0e2e98dbb53cae670f35eb594a33e51150447a585422ec39cbfb5ae78a78ecca6f18201cf86f34016d192c80914d35dd5ae6b0d644dd7f741698dd60831dca287bd0cee32f4bf1236574b716691d100fba650c1adab1a64458e25f3f2dd34455eb81f4ae3d6e08d39ecba9b5689e9d099ee2d1b5454aac05f3c02721697abafe55befe2c23cdaf9834d89365c34762c71a034869ec2ca0956b124bd9dbf38258d352fc2ca1c7b08642c13f3a02699a95ce139980b0134cbdea1f01bcf47437a3bba140a31c8b04925e409a1f9d967c2ce313cd25b0b2714d0f96629db4b988058546bffb327e826fd783d0f0b0285309a5407f17bb42fe12604781229d6bbb6865ea80c0bb406fd43bb888202e75ce633eafb212986ef2c711a311c20b711f47317d68c542240ad73cfc0e0673f60ea8709c19722c35093e46b48b156367fdcb717a14f613ce41b8dcae4517750bb2446a8c63a619d4a5d14bf4b1c4e87634956971a0a363e62856c6535c7befc18016ab5d6e0971c0efc8231df4f77b3773ecb3af9b54b936b091cad98ff5a5ba2c584e0506110ee7e4691ef8560e3da42520adaa78772303f780ab77e6cff14a50afc38a5e10751c14969da0fc70f4375367e8376d8b7e84345d2cb320c841a71735b9f0e26abec715699f593ee153de9fd42034372bed2c73200ece37f74da8ee6785ae84baaf7d089be311a369a84f4e21e8d56d78f7f9fefd9fb723ddb19a06b2be553231563887b7e9b2edcb5d41449c37b20a031e8d40a0c3cb033e664480be05f162505ee196f3c5fbc3bd1ad2b04991b5c33f9b3d659faa49f1885ff6ba47474aea96185b442bb16d12d54825bd8d8830e6796e4020a734efdf35d200707899bc90957d8ae60955b88a88121fffdde589e65c7f40c8292b1a5bb0ef2c53df51559d0f27ef9099ac80b28bd91a7ac66e1af70eb708a2eb91648a792652a3593882f6b8b65caba5f41e0fdb21df93e78ae9330171a475701c1bb3d73943fb878335dedc513bdba256c3aea49ac1e1e4ddb0c247cec02d41e1114b17fc75bf25d2ccac21fb446ee7fd5d28b7872146bfd654b13a20ead353f14324025e4432fad1ee7afd4a5783a1cac1d2a4753788fa62409c920db61c240d0f88a2a128ce4cbed2656c2b6849d57d73798a8f71d21905001d5ebd6119483cb17337ec3fdc14370d0b5b1210586b66cb607a39912b3921c8200d229be1f9d4e9e83c5053d78983143beb8f5d985af0c3b077d4f85b27208dd9d9ed17a8dc3594e5c81611eda5c4f34429cd7ad3eb6881c242857ac16af16a8e6fcff819c60799eebdaabb81cd4f22b511c09c05c68b71405a1f067fb7c8b755c3977b051ed532aa20bd9143f7f5eed82584f01eeeec8eccf3cb51498a22b2002dd1a00ff9f3e43068f8fc31916102a4172d702cd4277cd5829c4038a2ae1b4466cd896c841be328b47f9384ac5d6bc6fe6d4104867a052a60443eb176a9c9727f89762610eed621c62e697991511876ef679c3df0f12a79265feb7a8fc6270748bcafd177bfc25d0eb429e3f89fdfe8853518a53108c4b9214589fa64b9ef97d1102c975f2edccff0564bde856b115b207aea5fb369eb970335ecde2e0975e2ecb8949bac1517ab8efd3679ea493ce385c44412c4afbfa924ca7d1c5000444bd8f97589ac0563947d37fec2898f53c251e0939c2e428b77adbeeafc72d3867113d4bc5308d5867a4b1451a378cc0dc19ebe86940570c9ee48b914557da9775f5bf4edefbbc4fde488f3af11817ef4c8d9b9e67eb24f1126233a94dedf0df3396ff8c9e800dd9f23943a348ece2d9ede4177b37b3ae1b4f33e8c5a59d249c81419d1521e348f201c21d4fd269e99989d2dd65995c3bcb50b7cd16b208ff549fde065f371107d9d3931e0c70a8c2bf06185bda7a22de7987e7f585fa1f5f3b8a23bce20093336d4c79f6ac9b224d9e0b6a81c69aed2d92428842c48979ba0c922d1962b7a3591c93ba288342e64cfd60ef488389affbda70ad2cb4fb182025d44f6eb83db6ceb01dd7aa14df21dc38d1d77c68d3bc76b446b631d863938ed5c811a31e363105c10474df875751798a4414dffb14a4d87a8f1449e9963f0a68eea602116e6df04ef236189c247db3a60f1a1c6ada46f6912b94032297a8d169c680997ce1bee9f6d5b6c919638cca5a3486e3ff09a314d5f60e8647fcb7a710f2a336821348390cd9a557c3d6e6f7b611d662b990193353198a03d8b4824e3c183417d449b156753993db3af24a2ab8a1cedfa2fd791aaeabce09682d03277f3136fad49da71e4b23d6a67d480fe051567fbe6623c2adc685eb7e60766396cdd298acda973b7964f4b4a277f4d2ad03680ec47b10a9166bbd8c2aa926d02071d59f7ffe2ddb2a1efe2d2efde55672059d5ba39aa09929357e53bf610e66eae7449687b13359f0829a9ae5ac023149d9bde3b417e8b81b10c8fff01e5efc011e06ec5e5096316e9a9ac925f9eb78fd426e027ae111fb0f9ecff8daf3c0a9c311d2a823604b4011ff3da0a7006d8ed27513ff6f721fe6b44838b186176fb0b0bd4dfbae1af800927f3709da50a7a352e7c7437f17f1fd1ce454dfce1fef9e988cfd9b9b77b009e6d6cf551ee1bb679ca5bdf13c6443a403e9b73b25ddbea7866c578b9b3c6ce3763a769b4e0028859f493ee46c7cde60843d036e66c5e9eb550a741ba5a8a3a57a4ecba740fc2b992a024895a3ed2051f4f106313c06bf997366c539dc54695307d03c99c35ef187e5715a72d87d6591d02ae9c2100da4db4936e97ced1071462d5264568981483e5cccd357ead6912662f178352cfa8a3b10cdc10683879da7a0e8bc49f01a17f18b3827731f8e7d8a5897145c42897d57fd6f8b58df52a2256a19040ae396e294514436b8f914045840bb55d73987c6cc04b6acb4f2af99b4b41dcf801e7aa20b8a86839fa915f5e96dc6ed6b83f9dfb9a30b6ef181500cee680efc3a1d808d66ea07c31f605ec75875e68bc744eeb5a4013fac865af9614a197b518e82a46c85eaa9c7d5cf790607b8fec3be355d5b615bd8b4847a1c8b24b8cea598ba8e6663f5a42ab6905e39062d209320f377808dba1062307b8b5a7b3d816caf454ab91ea9bd3e697e5853285abbee2ce4e5eac974ba5f9036878667b50d2ad51cd9b7ff97cc064b02b2dcb1974b61f6987f2e60c73201ef9aed6343ef62bbfa53d7cb61be83b19da9e097940671368eae8771c337698087c4b5d060d2fa7467d64af7eaed3a8ae8314a9a5114a281e21b7995e7c7eaf148e15f8fc8363c84c8741a86b4b5bcd3f368a33408128a251c82c52123729f8cf4338610bf994c4c34ea0b47a0fa2ce4b98b8e3917f525907fc25c35e034e7cb0c5ef5a331d1bc03b632136364ec144ff4ff4cee617659dd2a77559424ee99457544d9016695102e46c75b489eb22452c247f10b28bccd7d41727e24f7ba670b0eb74acde0fa6c8d48403518773abfffe6ef7d128bbbf4fa8847dd8f3f0ee77075a3feada71a03fc26c70e6503b6dab8def73acdccceb67e639ab908f6b7e816bef88ea66c291872c6f2415c9834ba5e3fa83ad21b1f375058e91384975db5792f87f34a131c0b0c2323614819c40b425c6a0b2aceade23c5afe03f9f648a7354eca02360204f1afb0e53b44b80ce1613ebebbb02814199914980046569d12cd34a358c710e18c20f7e2ccb968695812d887f67d2e9ba7e6748862f876e4258479557251ba090e6c304c294c550329b8a8e60e45b1a330dabf66e65b69516ecc09fab3002aa67011c693fa13fc8fdec1c0cb1ee43daadfc2ee237f28ce4f8b1b8ac80a1619f0cd4714805a195d4d2fb0c60bbb14a62783e45bc0ac9633db67e42bdf42deefe389ccbf64e24a3476034dc32baa96a311997eaf4bae6bc18e31cd2767d1512f372cfb106cfc0fe9006d645d773b33ec1a386bdcf31a2c0b4d56a2833f3485d127ee195835c79092cdd97e98c5c73caa68830c3dc3573fcf29d75a29ba593d2afa9730ff004c97bd46760764999e785174d4c452ca25d478c4a54fdabf67bb52a4fe51e754ff686d668136c2951b684e5844698de59b1a20a43b9d2f350b987fa8899e5f94f734fb9bd9946ba359933b5996a048bdf14082a21e4bdc2efbf88eaf6bb52193bce08070e112c7a9e109768cffd4b17604314cd8a343ec5dc7619079cdde96522e89c7b72b3619dd642c76d2e4f5137affe48ee03c3e8547e2cc47e0d76c658ea9a5991c748a37d9263cff027ad013ae1dc681b0a87268a555e0557e4bf9ada0084afc53bb2faea1ef86a5c208e80ef72ab37e971f41a2b58e1ae2c7dbac2ede1d6d65baf9583b6f7d716ec922fc9dc5ae8c4f3706bcf7297779bbcf97afe45cfcd0e8d8f0324018871fb338bcb0840e6e8342eef10d2d09762723174bc6418fa9fc7adffcd1da38c22d025b5c892e3ce2bd02ee26525c8ef1ddab532a300ed2fb37d2dd03f5258165c3c0b555838183e53b21324d4fdbb820fd60c6522b05b01731d016f698fe1788d339b2b7a05b28d39422a1847fed9d39dd3db64926c516d4b18be4022b309d00a17a752b7bdc6b414bdcded57a990aa644251617c71567148e2b904ab05645fd377127ca8257c1af129e08f9964a003e278f722fabe5a8fcd8144e6263dc3b57dbd886a45ea0307c05d5687f7b110a53de563d847fcc2a948cc884fc76f5f969af27c88d5b5d848f05bb695c5994ef36203aa523dbcce8938b896789080ebbf3f3232089982e8f9365f7de736b8e5918bbb8adf33f859e624dda7c71e57c75e4aade2aa3b99cd811769d07717a0242ea546c9769325c3e5a556df16428017fd2c076df5b3a83d3c9cca169fc6a796be871649525ae29c27a88eedbd577f5c0daaa6755c23d2241caa978c4ecdf8d693ad0f28bbfd129cd948434a7ff163e3fb3ca6b840ed1255a0d24bb8ab4fe8d2da3ab7fe75a03ee9dd9e6d4a1a49cac02feb269628c1cc154c0afb52c2cd5e71df3834e09850ee214e811dd3fe14153ccaf269843a4dcf5a46f147676ec4970025b31614d70b9f962e23e34313d905c01b4de74f4976dab556e5c5b10b0108b131c333fe7c63b52fefb71ae4885c361e2e28a4f61f561d36f5a4c53727357f0a65cfe79d51388b95d699a62fcbddd350ac7d35d450169dc196d21a17775884a0a154f8f9765915a74089f4e2ff7ec8adfa1db184360a14c45a3f089d598b5837035a498e1a6e588395e755f2f4867996098a7c5db5795608e53aa54bd8ecd04cf25d8bb364075f6eeee43905047840e61a6ef47b8948c2b0f1d2f0e3eb7e9b778e046fa0a015972c812fe60ec2675ff1e746628a940d2a74e2905b93b119459ea49739bcfb44ac753fba7248e37c2cdbe3d3cae18a76f307e448f38fa3bb261266eb71f3b325df5e13234dc61779037bbc5ceaa555e83db44f1f36f8e725b17eb7aa4b18fddfc6533f9e0e9cdacef59c498051857b7b47652a4696d01a3a88e00602c757bdc63ad204febd53c1fd6466bb92bb6abf140cd2210c60f8a9d0a0827e31341baa011c0d4d3461842301b62d515590563c3e8470b5220a4f49b88397d235edb4822691df46546c067dce361589e843f5ff9a4875e54d01de7d34cf2752e674462d6573d7d18b8dff3225b00627c4f66698fbfd7f34df22ebe95cc91c09f72d32f52ebcb606e1d605551dee82e6af83f482b70b7b65a56901e84c3dc42a3b5443f20edce7fa7bbd1be35fa52ba990c704c9bf69d48b16082a33d906b9d19fabaacbc5f51d4eebd1f67ddc70fa2b14d8a24812c31a4c3f4882a42df4caa6edd7685cf61c83415b3eb1f6a2c84731f51a377f71f98f4bfbee7a10b1fed563741eb1a5aca89da70e85a83a7d0d52fe62cb0556266ba54d982e52d1a33c144d86a9396d6f3ed349c9bb9045435915e7364ddab4b24157a346f0219244fd677e5570b54a72c81ff20cc9ed41a29c5b9fd489664dc26c8b95ac16dc6bf6bbd5b9a4bfd3256bfe8da863fb4b1d503c743a648bd3a456cc11061816ad9a2446f58734d94a31b6ff97866abc27e058acac6ab9fc6b7e0407c9c1076ef5d24e5e1d6b477181e96c4228093f1bebe39906826fcb9f76dfbeec67b0c194b19bf983defea75c2affb7df3923d87a467acbbd3da3682970e508148722f4b3b3c92bb8f0ec85ec4fa5c8aece989ba1a8c6340d526f2159c2849483878f1e9ac8ed424bf437cb0d45a4549c2284f06e07df8c9e1df79716c6dbc5f5fc87a67b3cc851c82d1b183b7fbb9a1129a713387ee57f6b1552f787b373c9a71511662dd0e9964a34c0b6a8b963d1c14eb2d458ffdbd833b615a68fcbca098d59a1c96360710d5027e7a3ac61a6063f765c913dc7fdfa54229e04ad12ceb82ed65c50de048d127e9fbc5da473a71dfbaaf6bdecd48228f59c07ee8a4d11e97fdb1e63c38f3df0e2a9bcf8f3a14e10d8d9630f95fbcfe28d76d14b0ba5641a714d850e012cc0e8d07f9e705cf22077fca21990be0d1ee32a9d134a0eb500841f4fd63d06cd8ac39f2615ad571d60ba49b830f4906ef93548f15f657e91a7a31ebcbaa7177488e86bbd3da2487f641ec08ff3d0b6f27e5822f875fc7a9e2a58d38c73f0bba99341af36477d283843dca5351f4abecc6aba0924faa20545a1af682f2e7b4c7f443360dc624996a53720de64d1fbc99616164642a0b4989b5634ae60e8239fd7cce93a2577393dfbf9f835935f203a22076ec5dec4fc6a62d6b14b041fb95d83f127fba2b86673b3d9ce54fe8815cb1d62ae274b27ae6b070e4fabc914ab98dc405be49a4d9170ad9633cbf9dcec58e43ad7f611e781e2b4d95f14ed95aaf5cd1dfda347f91c7e53b8a43ec4cfed7525f9e96f55b2dd30f2c5858d0caf2f679550bab74d7113dbb2fa6ac7bcd0e03cbe105037153e2c660a1e57e5775f7deb453f6e30fff5c77d76057d827b5f1adcbb3fc71e4524a501d25505e06052cbf3e5633056c3417df731c96b64aa92054e5456028bfca0b0b6aecab45da64bf5ba36d53db177b6a99bdaf4d072b023cd1e8d00d6acb8bfa9d30f0df1aabaac39c8393e78d7f63702a75e758da3ecf207847248cde855877a88e46f8dc70929b6546fc4b091ca2a22216fa552c0232d5a1166d8cd463079358dcbaa491d8d0635011c62de44ded38d38bb31f569838067c48c1affb1895788b28006d5f0be43d1f6fdb71914913b8c4bcb3ebaee7fc1d2b3b897e926929981fcc145329df1a6050316ba1bdedcc20126e9eb7e0358de17b13601a1396b8ce284e56f259733c7f883faceddd1dc2ef8a0954b16761fbc6993980ede1956f86f26c4ac89528ae80c539bfe39c6b6b2c63ffdbb0422673689ae0fdf2dca1fd5ea6ae0c4a3b6b1aecb033300bbf455c588781d31f12e337ac6ee5f7fa5dc0594565d3e4ee7ca7ec705efae849e7ebbe091974bb9af149a085f1b5040e5a611643af81721a53f8d6f4f0490301c6b8f87a55548b01cd4872e591cde9d2fe28690d6845079b25755e7a8b64e93e5c1e556258fa2e6e4c3180ad2c8509731bcb6e3dc74edbdf11e7317c985b40ce308ea26950a0106316017e600c806e3a6a3611be0c830502988510d829d6159d5daac78f47009df04f5afd75e2f2ae3e76086e1e1e97fe129d50491cf0816dff23ad3b78156184232afe7ce162511cfca15253509ac13bae00bc27f9f5de68317c144174b95795e6bdf48bf9569721437288640ef1b16a27cb0a67c9978d62f0d1478ebdff4c7a3d088ea62ec871b34bb613f12f16c80f0227ba69c87f75a84abcdf324e99c2fad671d7e16d8aed6d9e5feeb1fe3e58c06c3c82850193348994571511aa914aa428834de526911acb6b42f30f7319f7d49748004a7c2925fc5665a46902a47787065c70f80bb8efa878763a3036bd4ce269fc924a04efa7d5bf86e56bcba137ab28fe561dab6441b3a64ac4b92092d6cc0ff64c4297c95ecead9308535f1ff52e6b1cd89f01c3663a5c28056e0785ad48fe99fb532080ff8ceecf8f7541438ba1557c43aede60f6961859f5e415029a56371463b71de55749f807da3ce2137f0b97043c75c6c853996628997d67add03569623682dcc44a8da89e82dd5ea10ac629dd496046609d9c837a478494de3cdb9cc552e999a4d40e7176d81a13ec94cfa10f074766fe7f86a0cb50aeeb6671ec38b665614b03ba8a9f5cb60b670a44dd7f2b22cc29be312d5124bb346ecdd0a708c7712a90ce6cff862aa6b2809cc21b12a31894741ad423c26f1fc9750ebf01f6c3afaeeb477bb59718ae9f8c3ac91d15aaf0019cb86b8ed25de867474d8a45a6e3318ea757023a36688ec3a3e5c9b60486c2ccdfb04eba8be5345d21b99e89a375d07354ad33bf6a917f9da6f7a5b3a33dabb27fb5a85a619c65b1361fd267bc4f4f1cf498217922440a5f929700138ca48f293caae2f4c7c503b3390d346976d1d3eb0688eb351f86a11354b0146a89a337f70b53c3c7db01899c74979ff24812a3bf910093783c7b9eaac61abfd8057d19bdcb060014d57c378257a98d966d785eaa9754a6ff3a035558ed0ee60957d36f31e803ccfb740955eee39eda3bbb0a971b430f584b82f82c9a32ef2464d76524ab432f6cd265ac292559452a38e25b6ea021c1b65d35e075e4f57640c0db7e5b486912f0982a3bca0d4872e1914c285a6e7972936ce51f5c7bf7a8a5e39c15534953e5307f2afcaa98db78d6cdbb80dfafee9f32fe2a02a4eb718be67959fe38f0a8b8b4cec55e1ddd84fc0b5b1fe4cb5dc0dfb94f1efd75109b348366209a27f30f24c22a324e7eb7b930806363159a7d46c16e58dccbde1319e7a2ca88fe13737646596b1c5b09d00bdd803ce10871cfd60342bf53d97f7709c48d016485a5d453672d07d54266aa38ad2d805c0ded6c820653bf8a73a6123d06a3db057fa781ab6af4b98b5531056eaa7f3af64e54a9dc07bb2e48b610e0ee1b4e64e4e206f9a4f717529af866608e3b015473b2fa61613e5b20180d2e362d8c01a8813e6434394b0199b99a3160b4dfbeff636ba598430fd7771638f290ab78e1a695809ec38ea6312e424d8a564d1e1a59999b4a4a3df72829eaa7163d51e4a27a24871ecb738fd585db118ce639f90d0a9f0a90278b78fa6ad33955fd786ec8dabcd57cb2812c75c364f3c9a887ec42c122d0d51f9c3bbe3f99eb7f74d617e551c42f0dab4998fa57a14f3ec57c3928c8c643f5c6378f8580f22dd24bebb20c7de3d41f3ba952fbd93b94d6d135b2f31f7dfa8c31615345aab032b80f6884db2f7c9a215beb7fe9f5365cdeb277dcaba3ffbcbed0e74658abce1a6f1868fc4b76adbe9590f9b3bb9ed963d237db9b1cf5f3d0c2f8c68805abf57d91b391b0991fa7cf51f604d741b9fd07556b506c817509c34a28530fb7df2c13a1b3d41edc9706ecc6f6edf9393b63244153f3c0268a81fef282de4898a15b91939106769a8366f04cf2835b5339660ab31936898e162adb49cb0938c400ddb1b4a801fc022483b80717ffc50c2af7ff8c1bdc127764edd48b9aef290f487fbc78379260ad76dadcfab7d4ac6323d8c085ef8b3710571d4150f9793b209f4c2a5b7967e76114a40fb1b92f33fa4046ea42031008a2eb1fe23fcd570fea4d8c207678c8a67825841bf247b337cc7670ba0eaa1bd05d71ea9d1fb8d7dfc719fadb73bcea3c8df4b6f02bc6fbc8ee8ecf5810f9311ae847eadd7480868b94958aab1c0d26f6248156799565ae58e2a2b9ea98dcd06f36d0d37caef0a71e93bfe0d977fe652795a552609626caec7c4c9c42a11e4fb1d4e3ccd30b82f29e721f59dcaa5bdc5527dc46c84c171857f26ceea9c4e2f1f6ebfc53cb76b6fae974e86351efcbdbd2202ce88fe8273c85527adebc74f618b4c4ffaf7c68a562d264d79346d66eed7be5b5627fcc9717f3bda65026908d9b9dd9f30ff50e4c75aabad60589e6ed9c2662df8e30d6dd8a0fc9e8feb1dcfafae6f4a51d02655ca05147cca1efa480e264a75adb9a136e00f5df9387be3e3f67935c2411b75a65a066f0e1e2d12b5e0b75a0c0787d434d96d624893cd8cddcd2541f6a9e0d4a405e568c174308cd4d57dc16ea23320b9970952a38bd474d34a2caf3409124fda687c636dbcb84fbc60e15ca7cc1bfc0f8eeec33284d293b750de095342e19415435be421b886f8381e6a42946e25e209e5dfda6f37b563e8028f8da7574447024a95aed71c86c3ae67bb1266c9745c48bf0888b18c929349d47e25d8af688d0b644c0833c12192fdbb28aac77b9086b164e5a771a1ee3d8d7e8d0f1c1ef57ccd3c05d2dad67eed8c89b29a06fd28c3a4e7d347d7055ef0a85f9bfa39f7dc4f436cce1729f28aae6c5cc8a27563b2a3a090155420bfdac24f80f3f685d91a14c65b7101c3ae0dcc91bdfb41ed2361c7d47132fc3c70fe05de16fe4cd43ee673f4a5d3069929a296956df27c218a7fda6ee78c09b4a0c070466cf6d1752ddfa8297698f60427adf20a70143fab16828d3e45fd79b6f266890e240ac3b134d2013ced2108a42f31a5ce6970e44f0aa90c83d920658e312577bf7abeea552ba2f56e46ce20d1e7f2f09cf832fe81fd2e116399b17cec893c7a7d22cd89b61613e853fa9ed3cd390ddf6f7b3a4769d009e0d8c8c88dd6c6d8d2dfb0d3740d72ac7e6e1e3966c4b1984a35ccef8fa62d74af17078c78cce3c6a5c7339421a46df1c4909eeede7761645d15b2de62d82b48a7632e1711d030acf0ea2f8db2dd2cffbe32b9cebedb243e935585f8605c0ab9aa59fc2ff22bb1e0f72678529d5f5da97cff611648439da2b717d0a4c50d9c9736fb97504b3a08479d760964f6bc65fcbeb6dae709e2c0e657f49112d7c9a4eaf439f5af87b52c01ec8a1326f2510e005409df09c92fa1c612f0d7a47e77cf615e2c5af8207ac46dcefe571e0198d05600604b94cef00db63b313063d86feff364d6128d6b0d1635026ab09d362f71f8dfdfd4c83daad88ac5cff47d01adc37c761e224df20de520bd68ac8d95282b410cb27a01cf1e788a65e21272ececd6b42da272e6853ef563319e4c9b1270344b5a09c7b717ab86350b2bb8cb64ef47080cd4f9f1575fefc99e4677745370dc2e86f69ee3cb82b4fa475ee563746e9366e5dc7875c8899b3b54917164beb59fcc1577293e3ae5bd7cd75a3e44eee9dbf073d3b666a292826bad7e498a5b28bc9dc1eac6b35f79df4d8384a5741f64d208d56d515def0d7d6c3728b831f99bc10a4249979c5ea6f0b7ff3e6ef63659d69026686fa87035e0b48e11a84ecf47b03273677ca3b2da6379e37958b9349743f59d17da7475bb6fa3b1cf20862fba81e1aa991847ee1f3de604acb37858a5890291489722b7a7ed7f987f0711e04c32202ad183e8d41500143be623737d2b46dfc3765770ece0289ceb9233333a58a23b7f68272fb3ecc3a63a1b5bd191947a6c4e51f9f516a39af1c44dae20c9eccb210c9048140d91971234fc1c64fb27f3cfe5473a46f60e54a23cb2a54f99d43ecb1a8dc4a62f1fb48b0d2a54a2c3467b5cc56fbaf8e2f77d53992ad03d72c527fc23faa705d5fe9244cf8dba6a09103f45dffe8e29adb228e580a6983bd98836759ccc42d470c885a75e6968f3c572baeb16eac7f69b72fcb49c702d6c19e3249a377d8901c71ed13f5aa4878e9a89f70819dcffd70f87dbf5496a61247871c8116bae0746c3ca50de225050acc19edefe5a1bcb7a9780d90f1e90cd089d055d1c0c0b36832edb873c6e0355bd94d3eba1bb073b4f656858b89a6b7dbe175b4ffd141cd37a8b6c9ff93fc334ca7c05036e73ad43e4709ca55df46b55b2f43f7aa5931f994b9f</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Hexo</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java|正则表达式]</title>
    <url>/2021/08/05/JavaLearning_Regular-Expression.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>正则表达式，又称规则表达式（<code>Regular Expression</code>，在代码中常简写为<code>regex</code>、<code>regexp</code>或<code>RE</code>），通常被用来检索、替换那些符合某个模式(规则)的文本。 <a id="more"></a></p>
</blockquote>
<h3 id="正则表达式的规则">1. 正则表达式的规则</h3>
<ul>
<li><p>任意一个字符表示匹配任意对应的字符，如a匹配a，7匹配7，-匹配-。</p></li>
<li><p><code>[]</code>代表匹配中括号中其中任一个字符，如<code>[abc]</code>匹配a或b或c。</p></li>
<li><p><code>-</code>在中括号里面和外面代表含义不同，如在外时，就匹配<code>-</code>，如果在中括号内<code>[a-b]</code>表示匹配26个小写字母中的任一个。</p></li>
<li><p><code>^</code>在中括号里面和外面含义不同，如在外时，就表示开头，如<code>^7[0-9]</code>表示匹配开头是7的，且第二位是任一数字的字符串；如果在中括号里面，表示除了这个字符之外的任意字符(包括数字，特殊字符)，如<code>[^abc]</code>表示匹配出去<code>abc</code>之外的其他任一字符。</p></li>
<li><p><code>.</code>表示匹配任意的字符。</p></li>
<li><p><code>\d</code>表示数字。</p></li>
<li><p><code>\D</code>表示非数字。</p></li>
<li><p><code>\s</code>表示由空字符组成，<code>[ \t\n\r\x\f]</code>。</p></li>
<li><p><code>\S</code>表示由非空字符组成，<code>[^\s]</code>。</p></li>
<li><p><code>\w</code>表示字母、数字、下划线，<code>[a-zA-Z0-9_]</code>。</p></li>
<li><p><code>\W</code>表示不是由字母、数字、下划线组成。</p></li>
<li><p><code>?</code> 表示出现0次或1次，<code>X?</code> 表示匹配 0 个或 1 个字母 X。</p></li>
<li><p><code>+</code>表示出现1次或多次。</p></li>
<li><p><code>*</code>表示出现0次、1次或多次。</p></li>
<li><p><code>{n}</code>表示出现n次。</p></li>
<li><p><code>{n,m}</code>表示出现n~m次。</p></li>
<li><p><code>{n,}</code>表示出现n次或n次以上。</p></li>
<li><p><code>XY</code>表示<code>X</code>后面跟着<code>Y</code>，这里X和Y分别是正则表达式的一部分。</p></li>
<li><p><code>X|Y</code>表示X或Y，比如<code>"food|f"</code>匹配的是<code>foo(d或f)</code>，而<code>"(food)|f"</code>匹配的是<code>food</code>或<code>f</code>。</p></li>
<li><p><code>(X)</code>子表达式，将<code>X</code>看做是一个整体。</p></li>
</ul>
<h3 id="java中的正则表达式">2. Java中的正则表达式</h3>
<p>在<code>java</code>中调用正则表达式的类是<code>java.util.regex.Matcher</code>和<code>java.util.regex.Pattern</code>，<code>java.util.regex</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"8"</span>;</span><br><span class="line">    String regex = <span class="string">"[0-9]"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Pattern.matches(regex, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正则表达式</span></span><br><span class="line"><span class="comment"> * 正则表达式 的用法主要是4种方面的使用</span></span><br><span class="line"><span class="comment"> * 匹配，分割，替换，获取.</span></span><br><span class="line"><span class="comment"> * 用一些简单的符号来代表代码的操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cyc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//针对字符串处理</span></span><br><span class="line">        RegexMatches reg = <span class="keyword">new</span> RegexMatches();</span><br><span class="line">        <span class="comment">//校验qq的reg正则表达式</span></span><br><span class="line">        <span class="comment">//这里的\w 是指的是[a-zA-Z0-9],还有一个重要的是?,*.+这三个分别</span></span><br><span class="line">        <span class="comment">//?表示出现1次或者1次都没有，</span></span><br><span class="line">        <span class="comment">//+表示出现1次或者n次，</span></span><br><span class="line">        <span class="comment">//*表示出现0次或者n次，</span></span><br><span class="line">        <span class="comment">//还有些特殊的写法X&#123;n&#125;恰好n次X&#123;n,&#125;至少n次，X&#123;n,m&#125;n次到m次，</span></span><br><span class="line">        String mathReg = <span class="string">"[0-9]\\d&#123;4,19&#125;"</span>;</span><br><span class="line">        String divisionReg = <span class="string">"(.)\\1+"</span>;</span><br><span class="line">        <span class="comment">//\\b 是指的边界值</span></span><br><span class="line">        String getStringReg = <span class="string">"\\b\\w&#123;3&#125;\\b"</span>;</span><br><span class="line">        <span class="comment">//字符串匹配(首位是除0 的字符串)</span></span><br><span class="line">        reg.getMatch(<span class="string">"739295732"</span>,mathReg);</span><br><span class="line">        reg.getMatch(<span class="string">"039295732"</span>,mathReg);</span><br><span class="line">        <span class="comment">//字符串的替换</span></span><br><span class="line">        <span class="comment">//去除叠词</span></span><br><span class="line">        reg.getReplace(<span class="string">"12111123ASDASDAAADDD"</span>,divisionReg,<span class="string">"$1"</span>);</span><br><span class="line">        <span class="comment">//字符串的分割</span></span><br><span class="line">        <span class="comment">//切割叠词,重复的</span></span><br><span class="line">        <span class="comment">//这里要知道一个组的概念(.)\\1第二个和第一个至相同</span></span><br><span class="line">        reg.getDivision(<span class="string">"aadddddasdasdasaaaaaassssfq"</span>,divisionReg);</span><br><span class="line">        <span class="comment">//字符串的获取</span></span><br><span class="line">        <span class="comment">//现在获取三个字符串取出</span></span><br><span class="line">        reg.getString(<span class="string">"ming tian jiu yao fangjia le "</span>,getStringReg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取查询的字符串</span></span><br><span class="line"><span class="comment">     * 将匹配的字符串取出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getString</span><span class="params">(String str, String regx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.将正在表达式封装成对象Patten 类来实现</span></span><br><span class="line">        Pattern pattern = Pattern.compile(regx);</span><br><span class="line">        <span class="comment">//2.将字符串和正则表达式相关联</span></span><br><span class="line">        Matcher matcher = pattern.matcher(str);</span><br><span class="line">        <span class="comment">//3.String 对象中的matches 方法就是通过这个Matcher和pattern来实现的。</span></span><br><span class="line"></span><br><span class="line">        System.out.println(matcher.matches());</span><br><span class="line">        <span class="comment">//查找符合规则的子串</span></span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            <span class="comment">//获取 字符串</span></span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">            <span class="comment">//获取的字符串的首位置和末位置</span></span><br><span class="line">            System.out.println(matcher.start()+<span class="string">"--"</span>+matcher.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串的分割</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getDivision</span><span class="params">(String str, String regx)</span> </span>&#123;</span><br><span class="line">        String [] dataStr = str.split(regx);</span><br><span class="line">        <span class="keyword">for</span>(String s:dataStr)&#123;</span><br><span class="line">            System.out.println(<span class="string">"正则表达式分割++"</span>+s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串的替换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getReplace</span><span class="params">(String str, String regx,String replaceStr)</span> </span>&#123;</span><br><span class="line">        String stri = str.replaceAll(regx,replaceStr) ;</span><br><span class="line">        System.out.println(<span class="string">"正则表达式替换"</span>+stri);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串处理之匹配</span></span><br><span class="line"><span class="comment">     * String类中的match 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMatch</span><span class="params">(String str, String regx)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正则表达匹配"</span>+str.matches(regx));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, String&gt; <span class="title">splitCountry</span><span class="params">(String country)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; ret = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        Pattern mpattern = Pattern.compile(<span class="string">"(((.*省)|(.*市)|(.*区)).*?|.*)"</span>);</span><br><span class="line">        Matcher mmatcher = mpattern.matcher(country);</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (mmatcher.find()) &#123;</span><br><span class="line">            str = mmatcher.group();</span><br><span class="line">            <span class="keyword">if</span> (str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str.endsWith(<span class="string">"省"</span>))</span><br><span class="line">                    ret.put(<span class="string">"province"</span>, str);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (str.endsWith(<span class="string">"市"</span>))</span><br><span class="line">                    ret.put(<span class="string">"city"</span>, str);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (str.endsWith(<span class="string">"区"</span>))</span><br><span class="line">                    ret.put(<span class="string">"region"</span>, str);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ret.put(<span class="string">"province"</span>, str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考文献">参考文献</h3>
<p>[1] <a href="https://www.jianshu.com/p/3c076c6b2dc8" target="_blank" rel="noopener">Java中正则表达式</a></p>
<p>[2] <a href="https://segmentfault.com/a/1190000009162306" target="_blank" rel="noopener">Java 正则表达式详解</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>Regular Expression</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo学习记录--功能升级</title>
    <url>/2019/11/14/hexo-learning-record--Feature-Upgrade.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>增加一些新功能, 丰富一下博客内容和界面, 就是一些花里胡哨的东西。 <a id="more"></a></p>
<h3 id="leancloud添加文章阅读量">LeanCloud添加文章阅读量</h3>
<p>操作很简单，在 <code>LeanCloud</code>注册账号后，创建一个应用即可，主要参考官网教程和一些网上的博客： &gt; - <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">开始使用</a> &gt; - <a href="https://blog.csdn.net/weixin_39345384/article/details/80787998" target="_blank" rel="noopener">NexT主题下，用Leancloud统计文章阅读量</a></p>
<p>这里需要注意的主要是需要安装 <strong>Web安全</strong> 模块，否者无法正常使用 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-leancloud-counter-security --save</span><br></pre></td></tr></table></figure> &gt; - 主要参考这个博客解决问题 <a href="https://blog.csdn.net/w573719227/article/details/100704952" target="_blank" rel="noopener">HEXO博客使用LeanCloud报错“Counter not initialized! See more at console err msg.”</a></p>
<p>这里还有一个问题, 就是链接里带中文名, 所以导致链接在<code>leancloud</code>中以特殊字符形式存在, 在统计访问次数时出错。需要将其转换为英文的链接地址, 这里使用<a href="https://hexo.io/zh-cn/docs/permalinks.html" target="_blank" rel="noopener">Hexo-永久链接(Permalinks)</a>的方法，自定义链接地址，最终阅读量正常实现。</p>
<h3 id="永久链接permalinks">永久链接（Permalinks）</h3>
<p>可以在博客根目录的配置文件（<code>_config.yml</code>）中这样修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:entitle.html</span></span><br></pre></td></tr></table></figure>
<p>其中<code>entitle</code>是自定义的一个属性，同时在<code>.\scaffolds\post.md</code>中修改：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">entitle: </span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这样在编写文章时，可以在<code>entitle</code>输入指定字符，作为文章链接地址 &gt; - 参考文章<a href="https://blog.csdn.net/Likianta/article/details/79343427" target="_blank" rel="noopener">如何让你的Hexo博客网址使用全英文路径</a></p>
<h3 id="不蒜子统计">不蒜子统计</h3>
<p>更新到新版本后，启用不蒜子统计很简单，只需要在主题配置文件中启用即可：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">false</span> <span class="comment"># 与leancloud重复，故注释掉</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure>
<p>应该也可以用leancloud实现类似功能，但懒得折腾了，就直接<code>不蒜子统计</code>一块用吧。</p>
<h3 id="字数统计">字数统计</h3>
<p>启用字数统计需要安装一个插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>之后设置配置文件即可：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>
<h3 id="加载进度条">加载进度条</h3>
<p>同样需要安装一下依赖库，不过他的安装方法与之前不同，不是用<code>npm</code>命令来安装，而是直接添加到主题的<code>lib</code>中： 1. 进入博客文件夹的<code>/themes/next</code>文件夹下 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog_folder/themes/next-update # 注意转换为对应主题路径</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p>载安装<code>Progress module</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-pace source/lib/pace</span><br></pre></td></tr></table></figure></p></li>
<li><p>在<code>/themes/next/_config.yml</code>中设置使生效 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">bounce</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="github图床">GitHub图床</h3>
<p>在写博客时，我们常常需要在博客中插入图片什么的。这时一般需要一个图床，免费的图床有很多，但是上传文件后只能得到一个链接，不知道什么时候会丢失链接或者干脆图床网站不维护了。我们可以利用<code>GitHub</code>建立一个图床仓库，方便管理。顺便也可以练习一下<code>Git</code>的使用。如下图就是建立的一个图床仓库： <img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/GitHubImageRepository.PNG" alt="GitHub图床" /></p>
<blockquote>
<p>这里需要注意的一点是，GitHub图片的地址需要是源文件地址，比如上图的地址： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/GitHubImageRepository.PNG</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>之前一直用的<code>GitHub</code>下文件的url(<code>https://github.com</code>开头)，一直不显示，还以为是图片格式不兼容，笑哭。</p>
<h3 id="表格显示问题">表格显示问题</h3>
<p><code>table</code>表格显示异常，直接不显示表格。一开始以为是渲染器，语法什么的问题，后来发现原来解决方法很简单，表格和正文之间需要空行。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">测试</th>
<th style="text-align: left;">表格</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">正常</td>
<td style="text-align: left;">显示</td>
</tr>
</tbody>
</table>
<h3 id="加入豆瓣书单">加入豆瓣书单</h3>
<p>直接安装豆瓣依赖模块 <code>$ npm install hexo-douban --save</code>, 简单易操作。配置上需要在 <code>hexo</code> 配置文件中加入 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">douban:</span><br><span class="line">  user: mythsman</span><br><span class="line">  builtin: false</span><br><span class="line">  book:</span><br><span class="line">    title: &apos;This is my book title&apos;</span><br><span class="line">    quote: &apos;This is my book quote&apos;</span><br><span class="line">  movie:</span><br><span class="line">    title: &apos;This is my movie title&apos;</span><br><span class="line">    quote: &apos;This is my movie quote&apos;</span><br><span class="line">  game:</span><br><span class="line">    title: &apos;This is my game title&apos;</span><br><span class="line">    quote: &apos;This is my game quote&apos;</span><br><span class="line">  timeout: 10000</span><br></pre></td></tr></table></figure></p>
<p>然后部署到主题文件中, <code>next</code> 主题下设置为 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives</span><br><span class="line">  books: /books     # 这是链接到books页面</span><br><span class="line">  movies: /movies   #  这是链接到movies页面</span><br><span class="line">  games: /games   # 这是链接到games页面</span><br></pre></td></tr></table></figure></p>
<p>之后在启动过程中加入命令 <code>hexo douban -bgm</code> 自动抓取相关信息生成页面。 其中开启 <code>hexo-douban</code> 的命令中，<code>-bgm</code> 代表的是 <code>book、game、movie</code> 三个参数。</p>
<h3 id="加入搜索功能">加入搜索功能</h3>
<ol type="1">
<li><p>安装本地搜索插件 <code>hexo-generator-search</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure> 安装之后，会在站点目录的 <code>public</code> 文件夹下创建一个 <code>search.xml</code> 文件</p></li>
<li><p>在站点配置文件 <code>_config.yml</code> 中添加如下内容： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Search </span><br><span class="line">search:</span><br><span class="line">  path: ./public/search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure> <code>field</code>：搜索范围，默认是 <code>post</code>，还可以选择 <code>page</code>、<code>all</code>，设置成 <code>all</code> 表示搜索所有页面 <code>limit</code>：限制搜索的条目数</p></li>
<li><p>主题配置文件 在主题配置文件 <code>_config.yml</code> 中找到如下内容： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  trigger: auto</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure> 确保 <code>enable</code> 设成 <code>true</code>。</p></li>
</ol>
<h3 id="加入评论系统基于valine">加入评论系统(基于Valine)</h3>
<ol type="1">
<li><p>获取 <code>APP ID</code> 和 <code>APP Key</code> 先登录或注册 <code>LeanCloud</code>, 进入控制台后创建应用。选择<code>设置</code>&gt;<code>应用Key</code>，就可以获取<code>APP ID</code>和<code>APP Key</code>了。</p></li>
<li><p>在<code>next</code>主题中配置<code>valine</code> 在主题配置文件 <code>_config.yml</code> 中找到<code>comments</code>栏目并开启<code>valine</code>: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comments:</span><br><span class="line">  active: valine</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>然后在该配置文件中找到<code>valine</code>设置栏，开启<code>valine</code>并填入<code>appid</code>和<code>appkey</code>。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid: # your app id</span><br><span class="line">  appkey: # your app key</span><br><span class="line">  notify: true # 评论回复邮件提醒, See: https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # 验证码服务</span><br><span class="line">  placeholder: 留言区 # 评论框占位提示符</span><br><span class="line">  avatar: mm # 头像配置</span><br><span class="line">  guest_info: nick,mail,link # 回复要填写的信息</span><br><span class="line">  pageSize: 10 # 评论列表分页，每页条数</span><br><span class="line">  visitor: false # 文章访问量统计 </span><br><span class="line">  comment_count: true # if false, comment count will only be displayed in post page, not in home page</span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li>由于<code>valine 1.4</code>版本后，不再支持自带的<code>邮件提醒</code>，所以这里使用第三方<code>Valine-Admin</code>，基于<code>Leancloud</code>的云引擎与云函数。功能更完善，主要部署方法可以查阅<code>github</code>:<a href="https://github.com/DesertsP/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a>。 &gt; PS: 这里<code>Leancloud</code><strong>一定要用国际版</strong>，可以少去很多麻烦。</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Hexo</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--10 数字和静态</title>
    <url>/2021/05/14/JavaLearning_Head_First_Java_10_numbers_and_statics.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>盘算一下。 <a id="more"></a></p>
</blockquote>
<h3 id="静态static">1. 静态（static）</h3>
<h4 id="静态方法">1.1 静态方法</h4>
<p>在<code>Java</code>中没有<code>全局(global)</code>方法。但有些类中的方法不需要实例变量，为这样的类在堆上建立实例时很浪费的。</p>
<blockquote>
<p><code>Math</code>方法是最接近全局的方法。</p>
</blockquote>
<p><code>Math</code>类中所有方法都不需要实例变量，这些方法都是<code>静态(static)</code>的。而且无需也无法创建<code>Math</code>实例，只会用到它的类本身：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = Math.round(<span class="number">42.2</span>);</span><br><span class="line"><span class="keyword">int</span> y = Math.min(<span class="number">56</span>,<span class="number">12</span>);</span><br><span class="line"><span class="keyword">int</span> z = Math.abs(-<span class="number">343</span>);</span><br></pre></td></tr></table></figure>
<p><code>Java</code>中使用<code>static</code>这一关键词来标记出不需要实例的方法。一个静态方法代表<u><strong>一种不依靠实例变量(对象)的行为</strong></u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">     <span class="comment">//returns the lesser of a and b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以类名调用静态方法，以引用变量名调用非静态方法。</p>
</blockquote>
<p>带有静态方法的类通常会被设置为不可初始化。除了把类定义为抽象类之外，也可以<strong>把构造函数标记为私有</strong>防止类被初始化。但带有静态方法的类也可以被初始化(比如带有<code>main()</code>函数的类，<code>main()</code>函数是一个静态方法)</p>
<blockquote>
<p>静态方法不能调用非静态的变量。静态方法无法引用到该类的任何实例变量，静态方法也不能调用非静态的方法。</p>
</blockquote>
<p>可以用实例变量来调用静态方法，但编译器会解析出原来的类，并不会知道是哪个对象引用调用的该静态方法。</p>
<h4 id="静态变量">1.2 静态变量</h4>
<p>静态变量的值对所有实例来说都相同，而且该变量被所有实例共享。比如要计算当前<code>Duck</code>实例的数量，或许可以在构造函数中递增计算器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> duckCount = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         duckCount++;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但由于<code>duckCount</code>是实例变量，每个<code>Duck</code>对象都会将其初始化为0。而将其设置为静态变量可以实现所需要的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> duckCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         duckCount++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">         size = s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态变量只在类第一次载入时初始化。同一个类所有实例共享一份静态变量。</p>
</blockquote>
<p><code>Java</code>虚拟机会加载某个类主要因为第一次被尝试创建该类的实例，或使用该类的静态方法或变量时。静态项目的初始化又两项保证：</p>
<blockquote>
<ul>
<li>静态变量会在该类的任何对象创建前就完成初始化。</li>
<li>静态变量会在该类的任何静态方法执行前就初始化。</li>
</ul>
</blockquote>
<p>被标记为<code>final</code>的变量代表该变量初始化后就不会改动，是一个常数。而静态的<code>final</code>变量在类加载后就会一致维持原值。</p>
<blockquote>
<p><code>静态初始化程序(static initializer)</code>是一段在加载类时会执行的程序代码，会在其他程序可以使用该类前执行，所有适合放置<code>静态final变量</code>在该部分。</p>
</blockquote>
<blockquote>
<p>根据<code>命名惯例(naming convention)</code>，常数变量的名称应该都是大写字母！</p>
</blockquote>
<p><code>静态final变量</code>可以通过两种方法初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 在声明时初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FOO_X = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在静态初始化程序中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> BAR_SIGN;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">static</span> &#123; <span class="comment">// 这部分代码在类加载时就执行，早于任何方法或静态变量被使用之前</span></span><br><span class="line">         BAR_SIGN = (<span class="keyword">double</span>) Math.random();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若未使用上述方法为<code>静态final变量</code>初始化，编译器会报错。</p>
<blockquote>
<p><code>final</code>还可以修饰其他变量，方法甚至类</p>
<ul>
<li><code>final</code>变量代表不能改变它的值；</li>
<li><code>final</code>方法代表不能覆盖该方法；</li>
<li><code>final</code>类代表不能继承该类；</li>
</ul>
</blockquote>
<h3 id="数字">2. 数字</h3>
<h4 id="math方法">2.1 <code>Math</code>方法</h4>
<p>下面是对<code>Math</code>方法的一些结束：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/mathMethods.PNG" alt="Math方法" /><figcaption aria-hidden="true"><code>Math</code>方法</figcaption>
</figure>
<h4 id="primitive主数据类型包装">2.2 <code>primitive</code>主数据类型包装</h4>
<p>把<code>primitive</code>主数据类型当作对象来处理，需要一个包装该数据类型的类。每个<code>primitive</code>主数据类型都有一个包装类，存放在<code>java.lang</code>这个包中。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/wrapperClasses.PNG" alt="包装类" /><figcaption aria-hidden="true">包装类</figcaption>
</figure>
<p>包装类将<code>primitive</code>主数据类型名称第一个字母大写，以符合命名惯例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包装值</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">288</span>;</span><br><span class="line">Integer iWrap = <span class="keyword">new</span> Integer(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解开包装</span></span><br><span class="line"><span class="keyword">int</span> unWrapped = iWrap.intValue();</span><br></pre></td></tr></table></figure>
<h4 id="autoboxing">2.3 <code>autoboxing</code></h4>
<p><code>java 5.0</code>以后加入了<code>autoboxing</code>，自动将<code>primitive</code>主数据类型转换成包装过的对象。</p>
<blockquote>
<p>但依旧无法直接声明<code>ArrayList&lt;int&gt;</code>，因为<code>generic</code>类型的规则是只能指定类或接口类型，因此<code>ArrayList&lt;int&gt;</code>无法通过编译。但可以把该包装对象的<code>primitive</code>主数据类型直接放入<code>ArrayList</code>中。</p>
</blockquote>
<p><code>autoboxing</code>除了在包装或解包<code>primitive</code>主数据类型给<code>collection</code>之外，还可以用到其他地方：</p>
<ul>
<li><p>方法的参数</p>
<p>参数是包装类型，可以传入相应的<code>primitive</code>主数据类型。反之亦然。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">takeNumber</span><span class="params">(Integer i)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回值</p>
<p>如果方法声明为返回某些<code>primitive</code>主数据类型，也可以返回兼容的包装类型。</p></li>
<li><p><code>boolean</code>表达式</p>
<p>可以使用<code>Boolean</code>包装类型</p></li>
<li><p>数值运算</p>
<p>可以直接对包装类型进行数值运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">42</span>); </span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">5</span>); </span><br><span class="line">Integer k = j + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>赋值</p>
<p>将包装类型赋值给<code>primitive</code>主数据类型或相反。</p></li>
</ul>
<p>包装内也有实用的静态方法，比如字符串和主数据类型的转化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = Integer.parseInt(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">double</span> d = Double.parseDouble(“<span class="number">420.24</span>”);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意没有<code>Boolean.parseBoolean()</code>方法，但<code>Boolean</code>构造函数可以用<code>String</code>类型创建对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">42.5</span>;</span><br><span class="line">String doubleString = <span class="string">""</span> + d; <span class="comment">// "+"运算符是Java中唯一重载过的运算符，作为字符串拼接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">42.5</span>;</span><br><span class="line">String doubleString = Double.toString(d);</span><br></pre></td></tr></table></figure>
<h4 id="数字格式">2.4 数字格式</h4>
<p>Java中数字与日期的<code>格式化</code>功能没有结合在输入/输出功能上。该功能在<code>java 5.0</code>以后由<code>java.lang</code>中的<code>Formatter</code>类来提供，该类的功能加入到了部分输入/输出类和<code>String</code>中。可以直接调用<strong>静态</strong>的<code>String.format()</code>来实现格式设定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = String.format(<span class="string">"%, d"</span>, <span class="number">1000000000</span>); <span class="comment">// 将数字以带逗号的形式格式化</span></span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>
<p>格式化主要由两个主要部分组成：</p>
<ol type="1">
<li><strong>格式指令</strong>。概述要输出的特殊格式。</li>
<li><strong>要格式化的值</strong>。</li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/formatString.PNG" alt="格式化" /><figcaption aria-hidden="true">格式化</figcaption>
</figure>
<p>格式化说明中，跟在<code>百分号(%)</code>后面包括类型指示(如<code>d</code>或<code>f</code>)的每个东西都是格式化指令，类型指示后的字符被视作直接输出的字符串。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/formatSpecifier.PNG" alt="格式化说明" /><figcaption aria-hidden="true">格式化说明</figcaption>
</figure>
<blockquote>
<p>类型是唯一的必填项</p>
</blockquote>
<blockquote>
<p><code>format()</code>使用<code>可变参数列表(variable argument lists, varargs)</code>来对应有不同数目排列组合的参数。</p>
</blockquote>
<h4 id="日期格式">2.5 日期格式</h4>
<p><code>Date</code>类型是Java上表示时间用的，数值与日期时间格式化的主要差别在于日期格式的类型是用<code>"t"</code>开头的两个字符表示：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dateFormat.PNG" alt="日期格式" /><figcaption aria-hidden="true">日期格式</figcaption>
</figure>
<p><code>java.util.Date</code>适合用于查看当前日期时间，但许多功能已经停用。更多功能推荐使用API <code>java.util.Calendar</code>。<code>Calendar</code>是一个抽象类，当需要<code>Calendar</code>类型时，需要从<code>JVM</code>获取一个子类实例。需要用到静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br></pre></td></tr></table></figure>
<p>通过调用<code>getInstance()</code>会返回一个具体子类的实例。一般默认返回<code>java.util.GregorianCalendar</code>的实例。<code>Calendar</code>类的几个关键特性：</p>
<ul>
<li>字段会保持状态。比如可以读取或设置<code>year</code>或<code>month</code>字段；</li>
<li>日期和时间可以运算。</li>
<li>日期与时间可以用<code>milliseconds</code>表示。即可以将日期转化为微秒，也可以将微秒转换为日期。(相对于<code>1970年1月1日</code>的微秒数)。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/CalendarExample.PNG" alt="Calendar示例" /><figcaption aria-hidden="true">Calendar示例</figcaption>
</figure>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--12 图形用户接口</title>
    <url>/2021/05/17/JavaLearning_Head_First_Java_12_getting_gui.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>面对现实，你得做出图形用户接口。 <a id="more"></a></p>
</blockquote>
<h3 id="window">1. window</h3>
<p><code>JFrame</code>是代表屏幕上window的对象，可以把<code>button</code>，<code>checkbox</code>，<code>text</code>字段等接口放在window上。标准的<code>menu</code>也可以加到上面。</p>
<p>一旦创建了<code>JFrame</code>后，就可以把组件(<code>widget</code>)加到上面。最常用的组件包括：<code>JButton, JRadioButton, JCheckBox, JLabel, JList, JScrollPane, JSlider, JTextArea, JTextField, and JTable</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleGui1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 frame</span></span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 widget</span></span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">"click me"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// window关闭时结束程序</span></span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把widget加到frame上</span></span><br><span class="line">        frame.getContentPane().add(button);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定frame大小</span></span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        <span class="comment">// 显式</span></span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用户接口事件">2. 用户接口事件</h3>
<p>让按钮在按下时执行工作需要两项：</p>
<ul>
<li>被按下时要执行的方法(按钮任务)</li>
<li>检测按钮被按下的方法(按钮感应装置)</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/buttonEvent.PNG" alt="按钮事件" /><figcaption aria-hidden="true">按钮事件</figcaption>
</figure>
<p>取得与处理用户操作事件的过程称为<code>event-handling</code>。如果想知道按钮的事件，就会监听事件的接口，<code>监听接口</code>是<u>介于监听与事件源间的桥梁</u>。</p>
<p>事件来源将用户操作转换成事件的对象，事件几乎都是以对象来表示。程序大多数情况是事件的接收方而不是创建方。事件对象通过不同的事件方法来表示不同类型的事件。</p>
<p>比如取得按钮的<code>ActionEvent</code>：</p>
<ul>
<li>实现ActionListener接口</li>
<li>向按钮注册</li>
<li>定义事件处理的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口ActionListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleGui1B</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">    JButton button;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleGui1B gui = <span class="keyword">new</span> SimpleGui1B();</span><br><span class="line">        gui.go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line">        button = <span class="keyword">new</span> JButton(<span class="string">"click me"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        button.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        frame.getContentPane().add(button);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.setSize(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现ActionListener接口的方法，处理事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以ActionEvent对象作为参数调用</span></span><br><span class="line">        button.setText(<span class="string">"I’ve been clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绘图组件">3. 绘图组件</h3>
<p>创建具有绘图功能的<code>widget</code>放到<code>frame</code>上，创建<code>JPanel</code>的子类覆盖掉<code>paintComponet()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDrawPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        g.setColor(Color.orange);</span><br><span class="line">        g.fillRect(<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显式<code>JPEG</code>照片：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">     Image image = <span class="keyword">new</span> ImageIcon(<span class="string">"catzilla.jpg"</span>).getImage();</span><br><span class="line">     g.drawImage(image,<span class="number">3</span>,<span class="number">4</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随机色彩圆：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    g.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">this</span>.getWidth(), <span class="keyword">this</span>.getHeight());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> red = (<span class="keyword">int</span>) (Math.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">int</span> green = (<span class="keyword">int</span>) (Math.random() * <span class="number">256</span>);</span><br><span class="line">    <span class="keyword">int</span> blue = (<span class="keyword">int</span>) (Math.random() * <span class="number">256</span>);</span><br><span class="line">    Color randomColor = <span class="keyword">new</span> Color(red, green, blue);</span><br><span class="line">    g.setColor(randomColor);</span><br><span class="line">    g.fillOval(<span class="number">70</span>,<span class="number">70</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部类inner-class">4. 内部类（Inner class）</h3>
<p>一个类可以嵌套在另一个类的内部。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/innerClass.PNG" alt="简单内部类" /><figcaption aria-hidden="true">简单内部类</figcaption>
</figure>
<blockquote>
<p>内部类可以使用外部的所有方法与变量，就算私有内容也一样。即内部类可以把外部的方法或变量当作自己的。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/Inner_class_using_outer_class.PNG" alt="内部类使用外部类的变量" /><figcaption aria-hidden="true">内部类使用外部类的变量</figcaption>
</figure>
<blockquote>
<p>内部类的实例一定会绑定在外部类的实例上。从外部类程序代码中初始化的内部类，此内部对象会绑定在该外部对象上。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/innerOuterBound.PNG" alt="创建内部类实例" /><figcaption aria-hidden="true">创建内部类实例</figcaption>
</figure>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--11 异常处理</title>
    <url>/2021/05/14/JavaLearning_Head_First_Java_11_exception_handling.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>倒霉的事情就算会发生。找不到文件、服务器出现故障。 <a id="more"></a></p>
</blockquote>
<h3 id="异常">1. 异常</h3>
<p>需要对可能发生的异常情况进行处理，<strong>未雨绸缪</strong>！Java的<code>异常处理机制(exception-handling)</code>将处理错误状况的代码放在一个容易阅读的位置。如果知道调用某个方法可能会有异常情况，可以预先准备问题处理程序甚至从错误中恢复。</p>
<blockquote>
<p>异常是一种<code>Exception</code>类型的对象。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/exceptionClass.PNG" alt="异常类" /><figcaption aria-hidden="true">异常类</figcaption>
</figure>
<ul>
<li><p><strong>抛出异常(throws)</strong>。使用<code>throws</code>语句来抛出异常。</p>
<p>在编写可能会抛出异常的方法时，必须先声明有异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeRisk</span><span class="params">()</span> <span class="keyword">throws</span> BadException </span>&#123; <span class="comment">// 声明会抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> (abandonAllHope) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BadException(); <span class="comment">// 创建异常对象并抛出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意声明时是<code>throws</code>，抛出时是<code>throw</code>。</p>
</blockquote></li>
<li><p><strong>捕捉异常(catch)</strong>。使用<code>try/catch</code>块来捕捉处理异常。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 有风险的动作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 错误恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>非<code>RuntimeExceptions</code>子类的异常由编译器检查，称作<code>检查异常(checked exceptions)</code>；<code>RuntimeExceptions</code>类称为<code>非检查异常</code>，编译器不会检查。编译器会确保：</p>
<ol type="1">
<li>如果有抛出异常，一定使用了<code>throws</code>来声明</li>
<li>如果调用会抛出异常的方法，一定知道异常可能性。即会处理异常。</li>
</ol>
<h4 id="trycatch块">1.1 try/catch块</h4>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/tryCatchFlow.PNG" alt="try/catch块流程" /><figcaption aria-hidden="true">try/catch块流程</figcaption>
</figure>
<p><code>finally</code>块用来存放不管有没有异常都需要执行的程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     turnOvenOn();</span><br><span class="line">     x.bake(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (BakingException ex) &#123; </span><br><span class="line">     ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     turnOvenOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果try或catch块有<code>return</code>指令，<strong><code>finally</code>块还是会执行</strong>！流程会跳到<code>finally</code>块然后再回到return指令。</p>
</blockquote>
<h4 id="throws">1.2 throws</h4>
<p>方法可以抛出多个异常，声明时必须要含有全部可能的检查异常。调用方法时，编译器会坚持是否处理了所有可能的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laundry</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> PantsException, LingerieException </span>&#123;</span><br><span class="line">         <span class="comment">// code that could throw either exception</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Laundry laundry = <span class="keyword">new</span> Laundry();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             laundry.doLaundry();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(PantsException pex) &#123;</span><br><span class="line">             <span class="comment">// recovery code</span></span><br><span class="line">         &#125; <span class="keyword">catch</span>(LingerieException lex) &#123;</span><br><span class="line">             <span class="comment">// recovery code</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常也是多态的，所以异常也可以用多态的方式引用。抛出异常时可以声明多个异常的共同父类，捕捉异常时也同理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     laundry.doLaundry();</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClothingException cex) &#123;</span><br><span class="line">     <span class="comment">// recovery code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的确可以用<code>Exception</code>来捕捉所有异常，但也会在处理异常时无法精确定位捕捉到了何种异常。使用<code>catch</code>来处理异常时，在继承数中高层次的异常不能放到低层次的异常之前。</p>
<h4 id="duck异常">1.3 duck异常</h4>
<blockquote>
<p>如果不想处理异常，可以把它duck掉来避开。</p>
</blockquote>
<p>也就是不用try/catch处理异常，而是再度throw该异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Washer</span> </span>&#123;</span><br><span class="line">     Laundry laundry = <span class="keyword">new</span> Laundry();</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException </span>&#123; </span><br><span class="line">         laundry.doLaundry();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> ClothingException </span>&#123;</span><br><span class="line">         Washer a = <span class="keyword">new</span> Washer();</span><br><span class="line">         a.foo();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/duckException.PNG" alt="duck异常" /><figcaption aria-hidden="true">duck异常</figcaption>
</figure>
<h4 id="异常处理规则">1.4 异常处理规则</h4>
<ol type="1">
<li><code>catch</code>与<code>finally</code>不能没有<code>try</code>；</li>
<li><code>try</code>与<code>catch</code>之间不能有程序；</li>
<li><code>try</code>一定要有<code>catch</code>或<code>finally</code>；</li>
<li>只带有<code>finally</code>的方法必须duck异常(即声明)。</li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/exceptionRules.PNG" alt="异常处理规则" /><figcaption aria-hidden="true">异常处理规则</figcaption>
</figure>
<h3 id="创建midi音乐播放器">2. 创建<code>MIDI</code>音乐播放器</h3>
<p><code>MIDI</code>音乐播放器，类似一款乐队软件。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/MIDI.PNG" alt="MIDI音乐播放器" /><figcaption aria-hidden="true"><code>MIDI</code>音乐播放器</figcaption>
</figure>
<h4 id="javasound-api">2.1 <code>JavaSound</code> API</h4>
<p><code>JavaSound</code> API是<code>Java 1.3</code>后加入的一组类和接口，分为两部分：<code>MIDI(Musical Instrument Digital Interface)</code>和<code>取样(sampled)</code>。<code>MIDI</code>是不同电子发声装置沟通的标准协议，可以想象成<code>乐谱</code>，可以输入到“高级多功能电子魔音琴”中。</p>
<blockquote>
<p><code>MIDI</code>本身不带有声音，它带有的是有MIDI播放功能装置的指令</p>
</blockquote>
<h4 id="sequencer">2.2 Sequencer</h4>
<p>先获取<code>Sequencer</code>对象，它会将所有MIDI数据送到正确的装置上，由装置来产生音乐。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sequencer sequencer = MidiSystem.getSequencer();</span><br></pre></td></tr></table></figure>
<p>直接调用无法通过编译，编译器显式需要处理异常。API中说明<code>getSequencer()</code>可能会抛出<code>MidiUnavailableException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MusicTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Sequencer sequencer = MidiSystem.getSequencer();</span><br><span class="line">            System.out.println(<span class="string">"We get a sequencer"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MidiUnavailableException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Bummer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MusicTest1 mt = <span class="keyword">new</span> MusicTest1();</span><br><span class="line">        mt.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以下是<code>JavaSound</code>的工作原理：</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JavaSoundWorkFlow.PNG" alt="JavaSound的工作原理" /><figcaption aria-hidden="true"><code>JavaSound</code>的工作原理</figcaption>
</figure>
<ul>
<li>运行该播放器需要5个步骤：</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/fiveStepOfMIDI.PNG" alt="JavaSound的工作原理" /><figcaption aria-hidden="true"><code>JavaSound</code>的工作原理</figcaption>
</figure>
<blockquote>
<p>第5步是开始播放：<code>player.start();</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniMiniMusicApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiniMiniMusicApp mini = <span class="keyword">new</span> MiniMiniMusicApp();</span><br><span class="line">        mini.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个Sequencer并打开</span></span><br><span class="line">            Sequencer player = MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            Sequence seq = <span class="keyword">new</span> Sequence(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取一道音轨</span></span><br><span class="line">            Track track = seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage a = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOn = <span class="keyword">new</span> MidiEvent(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            ShortMessage b = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOff = <span class="keyword">new</span> MidiEvent(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Sequence放到Sequencer上(相对于把CD放到CD机上)</span></span><br><span class="line">            player.setSequence(seq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始播放</span></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="制作midievent">2.3 制作<code>MidiEvent</code></h4>
<p><code>MidiEvent</code>是组合乐曲的指令，一连串<code>MidiEvent</code>如同乐谱。必须在<code>MidiEvent</code>中指定何时开始播放某个音符(<code>NOTE ON event</code>)以及何时停止(<code>NOTE OFF event</code>)。</p>
<p><code>Midi</code>指令实际上放在<code>Message</code>对象中，<code>MidiEvent</code>由<code>Message</code>和发音时机组成。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/MidiEvent.PNG" alt="MidiEvent" /><figcaption aria-hidden="true">MidiEvent</figcaption>
</figure>
<p><code>Message</code>中信息的格式：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/AnatomyMessage.PNG" alt="信息的格式" /><figcaption aria-hidden="true">信息的格式</figcaption>
</figure>
<p>使用命令行参数版本的播放器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniMusicCmdLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiniMusicCmdLine mini = <span class="keyword">new</span> MiniMusicCmdLine();</span><br><span class="line"><span class="comment">//        if (args.length &lt; 2) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Don’t forget the instrument and note args");</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            int instrument = Integer.parseInt(args[0]);</span></span><br><span class="line"><span class="comment">//            int note = Integer.parseInt(args[1]);</span></span><br><span class="line"><span class="comment">//            mini.play(instrument, note);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Input the instrument and note"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                String instrumentS = <span class="keyword">null</span>;</span><br><span class="line">                instrumentS = is.readLine();</span><br><span class="line">                String noteS = <span class="keyword">null</span>;</span><br><span class="line">                noteS = is.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> instrument = Integer.parseInt(instrumentS);</span><br><span class="line">                <span class="keyword">int</span> note = Integer.parseInt(noteS);</span><br><span class="line">                mini.play(instrument, note);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(<span class="keyword">int</span> instrument, <span class="keyword">int</span> note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个Sequencer并打开</span></span><br><span class="line">            Sequencer player = MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            Sequence seq = <span class="keyword">new</span> Sequence(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line">            <span class="comment">// 获取一道音轨</span></span><br><span class="line">            Track track = seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage first = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            first.setMessage(<span class="number">192</span>, <span class="number">1</span>, instrument, <span class="number">0</span>);</span><br><span class="line">            MidiEvent changeInstrument = <span class="keyword">new</span> MidiEvent(first, <span class="number">1</span>);</span><br><span class="line">            track.add(changeInstrument);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将MidiEvents放入音轨track</span></span><br><span class="line">            ShortMessage a = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOn = <span class="keyword">new</span> MidiEvent(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            ShortMessage b = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            MidiEvent noteOff = <span class="keyword">new</span> MidiEvent(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Sequence放到Sequencer上(相对于把CD放到CD机上)</span></span><br><span class="line">            player.setSequence(seq);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始播放</span></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>AdPart复现--问题集锦</title>
    <url>/2019/11/23/AdPart-Repeat-Problem-Collect.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>最近在复现分布式RDF引擎<code>AdPart</code>, 复现过程中遇到了一些小问题, 就在这里记录一下吧。 <a id="more"></a></p>
<h3 id="problem-and-solve">Problem and Solve</h3>
<h4 id="g-编译问题">g++ 编译问题</h4>
<p>因为对 <code>g++</code> 编译项目不太熟悉, 这也是第一次自己写一个完整的项目并用 <code>g++</code> 来编译, 难免许多基础都不会。遇到了下面这个报错: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">undefined reference to &apos;Foo::Foo(std::string)&apos;</span><br></pre></td></tr></table></figure> 这个问题卡了我很久, 什么修改 <code>g++</code> 版本, 不使用<code>c++11</code>都试过，还一度怀疑是不是我代码写的有问题。后来发现是一个很简单的原因，没有在编译的时候将<code>Foo.cpp</code>(用这个来代指我的问题)添加进去, 也就是我编译的时候差不多是这样: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o testFoo</span><br></pre></td></tr></table></figure> 但是实际上需要是这样 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ main.cpp Foo.cpp -o testFoo</span><br></pre></td></tr></table></figure> 修改完之后成功编译, 还是对 <code>g++</code> 不熟, 得抽时间学学 <code>g++</code> 怎么编译 <code>c++</code> 代码了。</p>
<h3 id="参考文献">参考文献</h3>
<blockquote>
<ul>
<li><a href="https://stackoverflow.com/questions/3656050/c-undefined-reference-to-foofoostdstring" target="_blank" rel="noopener">c++ “ undefined reference to 'Foo::Foo(std::string)' ”</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>AdPart复现</category>
      </categories>
      <tags>
        <tag>AdPart</tag>
        <tag>代码复现</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--18 远程部署的RMI</title>
    <url>/2021/05/20/JavaLearning_Head_First_Java_18_remote%20deployment_with_RMI.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>分布式计算，距离不是问题。 <a id="more"></a></p>
</blockquote>
<h3 id="远程过程调用的设计">1. 远程过程调用的设计</h3>
<p>远程过程调用(<code>Remote Method Invocation, RMI</code>)要建出4种东西：<code>服务器</code>、<code>客户端</code>、<code>服务器辅助设施</code>和<code>客户端辅助设施</code>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/remoteMethod.PNG" alt="远程过程调用的设计" /><figcaption aria-hidden="true">远程过程调用的设计</figcaption>
</figure>
<h4 id="辅助设施的任务">1.1 <code>辅助设施</code>的任务</h4>
<p>辅助设施是个在实际上执行通信的对象，会让客户端对象看起来在调用远程的方法。辅助设施会去连接服务器，将调用的信息传送过去，然后等待服务器的响应。</p>
<p>服务器的辅助设施会接受客户端辅助设施打包的信息，调用真正的服务，然后取得返回值送回客户端辅助设施。</p>
<h4 id="创建远程服务">1.2 创建远程服务</h4>
<p>创建远程服务有5个步骤：</p>
<ol type="1">
<li><p>创建<code>Remote</code>接口。远程接口定义了客户端可以远程调用的方法，是一个作为服务的多态化类。stub和服务都会实现此接口。</p>
<ul>
<li><p>继承<code>java.rmi.Remote</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRemote</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>声明所有方法都会抛出<code>RemoteException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRemote</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>确定参数和返回值都是<code>primitive主数据类型</code>或<code>Serializable</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>实现<code>Remote</code>。真正执行的类，实现定义在该接口上的方法。</p>
<ul>
<li><p>实现<code>Remote</code>接口；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRemoteImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">MyRemote</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> “Server says, ‘Hey’”;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// more code in class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>继承<code>UnicastRemoteObject</code>。对象必须要有远程相关功能，最简单的方式就是继承<code>UnicastRemoteObject</code>类来处理。</p></li>
<li><p>编写声明<code>RemoteException</code>的无参数构造函数；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyRemoteImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向<code>RMI registry</code> 注册服务。将服务初始化并加入<code>RMI registry</code> ，<code>RMI</code>系统会把<code>stub</code>加到<code>registry</code>中。使用<code>java.rmi.Naming</code>的<code>rebind</code>方法来注册服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    MyRemote service = <span class="keyword">new</span> MyRemoteImpl();</span><br><span class="line">    <span class="comment">// 帮助服务命名，并向RMI registry注册</span></span><br><span class="line">    Naming.rebind(“Remote Hello”, service);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;...&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>用<code>rmic</code>产生<code>stub</code>与<code>skeleton</code>。由<code>JDK</code>附带的<code>rmic</code>工具自动处理。</p>
<ul>
<li><p>对实现出的类执行<code>rmic</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rmic MyRemoteImpl</span><br></pre></td></tr></table></figure>
<p><code>Java software development kit(JDK)</code>中的<code>rmic</code>工具会以服务的实现产生连个新类：<code>stub</code>和<code>skeleton</code>。</p></li>
</ul></li>
<li><p>启动<code>RMI registry</code> (<code>rmiregistry</code>)。用户从此处获取代理。</p>
<ul>
<li><p>在命令行启动<code>rmiregistry</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rmiregistry</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>启动远程服务。实现服务的类会启动服务的实例并向<code>RMI registry</code> 注册，要有注册才能对用户提供服务。</p>
<ul>
<li><p>启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java MyRemoteImpl</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h4 id="客户端获取stub">1.3 客户端获取<code>stub</code></h4>
<p>客户端需要获取<code>stub</code>对象，这需要<code>RMI registry</code>，客户端从上面查询得到有相符名称的服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyRemote service = (MyRemote) Naming.lookup(<span class="string">"rmi://127.0.0.1/Remote Hello"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>客户端查询<code>RMI registry</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Naming.lookup(<span class="string">"rmi://127.0.0.1/Remote Hello"</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><code>RMI registry</code>返回<code>stub</code>对象，<code>RMI</code>会自动将<code>stub</code>解序列化。</p></li>
<li><p>客户端可以调用<code>stub</code>上的方法</p></li>
</ul>
<h3 id="servlets">2. Servlets</h3>
<p><code>Servlets</code>是放在<code>Http Web</code>服务上面运行的Java程序，用户通过浏览器与网页交互时，如果请求需要Java的<code>Servlets</code>时，服务器会执行或调用已经执行的<code>Servlets</code>程序代码。</p>
<blockquote>
<p><code>Servlets</code>只运行在服务器上。</p>
</blockquote>
<ul>
<li>用户在网页上填写表格并提交，<code>HTTP</code>服务器受到请求，判断需要<code>Servlets</code>就传送该请求</li>
<li><code>Servlets</code>开始执行，把数据存入数据库，然后返回内容给浏览器。</li>
</ul>
<p>创建并执行<code>Servlets</code>的步骤：</p>
<ol type="1">
<li><p>找出可以存放<code>Servlets</code>的地方</p></li>
<li><p>取得<code>Servlets.jar</code>并添加到<code>classpath</code>上。<code>Servlets</code>不是标准库的一部分，需要单独下载。</p></li>
<li><p>通过继承<code>HttpServlet</code>来编写<code>Servlet</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletA</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写<code>HTML</code>来调用<code>Servlet</code></p></li>
<li><p>给服务器设定HTML网页和<code>Servlet</code></p></li>
</ol>
<h3 id="enterprise-javabeans">3. Enterprise JavaBeans</h3>
<p><code>Enterprise JavaBeans(EJB)</code>服务器作用与<code>RMI</code>调用和服务层之间，支持交易管理、安全性、并发性、数据库和网络功能等。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/EJB.PNG" alt="EJB架构的一部分" /><figcaption aria-hidden="true">EJB架构的一部分</figcaption>
</figure>
<h3 id="jini">4. Jini</h3>
<p><code>Jini</code>也是使用<code>RMI</code>，但有几个关键功能：</p>
<ol type="1">
<li>自适应探索(<code>Adaptive discovery</code>)</li>
<li>自恢复网络(<code>Self-healing networks</code>)</li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java|String,StringBuffer与StringBuilder的区别与用法]</title>
    <url>/2021/06/25/JavaLearning_String_StringBuffer_and_StringBuilder.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>字符串在<code>Java</code>中被广泛应用，学习一下<code>String</code>、<code>StringBuilder</code>和<code>StringBuffer</code>这几个类之间的异同和适用场景。 <a id="more"></a></p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/javaString.png" alt="String、StringBuilder和StringBuffer继承树" /><figcaption aria-hidden="true"><code>String</code>、<code>StringBuilder</code>和<code>StringBuffer</code>继承树</figcaption>
</figure>
<h3 id="string-类">1. <code>String</code> 类</h3>
<p>在 Java 中字符串属于<strong><code>对象</code></strong>，Java 提供了 <code>String</code> 类来创建和操作字符串。</p>
<h4 id="实例化">1.1 实例化</h4>
<p>主要有两种方法：直接赋值和构造法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>; <span class="comment">//直接赋值</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>); <span class="comment">//构造法</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>字符串常量是String的匿名对象</strong>。Java 本身没有提供<code>字符串常量</code>的概念，所有使用<code>""</code>定义的内容本质上来讲都是<code>String</code>的<code>匿名对象</code>。</p>
</blockquote>
<p>String 创建的字符串存储在<strong><code>公共池</code></strong>中，而 <code>new</code> 创建的字符串对象在<strong><code>堆</code></strong>上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"Runoob"</span>;              	<span class="comment">// String 直接创建</span></span><br><span class="line">String s2 = <span class="string">"Runoob"</span>;              	<span class="comment">// String 直接创建</span></span><br><span class="line">String s3 = s1;                    	<span class="comment">// 相同引用</span></span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"Runoob"</span>);   <span class="comment">// String 对象创建</span></span><br><span class="line">String s5 = <span class="keyword">new</span> String(<span class="string">"Runoob"</span>);   <span class="comment">// String 对象创建</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/javaStringPublicPool.png" alt="公共池和堆" /><figcaption aria-hidden="true">公共池和堆</figcaption>
</figure>
<p>String 类是<code>final</code>类，<strong>不可以继承</strong>。对String类型最好的重用方式是<strong>组合</strong>而不是继承。其构造函数源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// copyOf(source[],length); 从源数组的0位置拷贝length个；</span></span><br><span class="line">	<span class="comment">// copyOf是用System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength))实现的。</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断offset，count,offset+count是否越界之后</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用StringBuffer/StringBuilder类型初始化String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>String s = new String("xyz");</code> 创建两个对象，一个静态存储区<code>“xyz”</code>，一个用<code>new</code>创建在堆上的对象。但这种说法是片面的。可以参考<a href="https://www.iteye.com/blog/rednaxelafx-774673" target="_blank" rel="noopener">请别再拿“String s = new String("xyz");创建了多少个String实例”来面试了吧</a></p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/javaNew.jpg" alt="String的new反编译" /><figcaption aria-hidden="true"><code>String</code>的new反编译</figcaption>
</figure>
<p><code>new</code>只调用了一次，也就是说<strong><u>只创建了一个对象</u></strong>。这段代码在运行期间确实只创建了一个对象，即在堆上创建了<code>"abc"</code>对象。但在类加载的过程中，确实在运行时常量池中创建了一个<code>"abc"</code>对象，而在代码执行过程中确实只创建了一个<code>String</code>对象。因此更准确的说法是 <code>String str = new String("abc")</code> 涉及到2个<code>String</code>对象。</p>
<blockquote>
<p>一个是字符串字面量<code>"abc"</code>所对应的、驻留（<code>intern</code>）在一个<strong><u>全局共享的字符串常量池</u></strong>中的实例，另一个是通过<code>new String(String)</code>创建并初始化的、内容与<code>"abc"</code>相同的实例</p>
</blockquote>
<h4 id="不可变性">1.2 不可变性</h4>
<blockquote>
<p>String 类是<strong>不可改变</strong>的，所以你一旦创建了 String 对象，<u>那它的值就无法改变了</u>。</p>
</blockquote>
<p><code>String</code>类中使用<code>“final”</code>修饰的字符数组保存字符串，所以<code>string</code>对象是不可变的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex - beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == count)) ? <span class="keyword">this</span> :</span><br><span class="line">        <span class="keyword">new</span> String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[count + otherLen];</span><br><span class="line">    getChars(<span class="number">0</span>, count, buf, <span class="number">0</span>);</span><br><span class="line">    str.getChars(<span class="number">0</span>, otherLen, buf, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(<span class="number">0</span>, count + otherLen, buf);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = count;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line">        <span class="keyword">int</span> off = offset;   <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (val[off + i] == oldChar) &#123;</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">        	<span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">        	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; i ; j++) &#123;</span><br><span class="line">            	buf[j] = val[off+j];</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            	<span class="keyword">char</span> c = val[off + i];</span><br><span class="line">            	buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">            	i++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">new</span> String(<span class="number">0</span>, len, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sub</code>、<code>concat</code>、<code>replace</code>操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。</p>
<h4 id="多线程安全">1.3 多线程安全</h4>
<p><code>String</code>中的对象是不可变的，可以理解为常量，<strong>显然线程安全</strong>。</p>
<h4 id="intern方法">1.4 <code>intern</code>方法</h4>
<p>在<code>String</code>类中，<code>intern</code>方法是一个本地方法，在<code>JAVA SE6</code>之前，<code>intern</code>方法会<strong><u>在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用，如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用。</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"hello"</span>;</span><br><span class="line">        String b =  <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">        String c =  <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">        String d = b.intern();</span><br><span class="line">         </span><br><span class="line">        System.out.println(a==b);</span><br><span class="line">        System.out.println(b==c);</span><br><span class="line">        System.out.println(b==d);</span><br><span class="line">        System.out.println(a==d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<h4 id="string类中常用方法">1.5 String类中常用方法</h4>
<ul>
<li><p><code>char charAt(int index)</code></p>
<p>返回指定索引处的 char 值。</p></li>
<li><p><code>int compareTo(String anotherString)</code> 按字典顺序比较两个字符串。实际上返回的是字符ASCII码的差值，但通常只关心正负还是0</p></li>
<li><p><code>boolean contains(CharSequence s)</code> 当且仅当此字符串包含指定的 char 值序列时，返回 true。</p></li>
<li><p><code>boolean startsWith(String prefix)</code> 测试此字符串是否以指定的前缀开始。还可以指定开始检测位置下标</p></li>
<li><p><code>boolean endsWith(String suffix)</code> 测试此字符串是否以指定的后缀结束。</p></li>
<li><p><code>boolean equals(Object anObject)</code> 将此字符串与指定的对象比较。已覆写，比较内容是否相等</p></li>
<li><p><code>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code> 将字符从此字符串复制到目标字符数组。</p></li>
<li><p><code>int hashCode()</code> 返回此字符串的哈希码。</p></li>
<li><p><code>int indexOf(int ch)</code> 返回指定字符在此字符串中第一次出现处的索引。 没有则返回-1</p></li>
<li><p><code>int indexOf(int ch, int fromIndex)</code> 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</p></li>
<li><p><code>int indexOf(String str)</code> 返回指定子字符串在此字符串中第一次出现处的索引。</p></li>
<li><p><code>int indexOf(String str, int fromIndex)</code> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</p></li>
<li><p><code>int lastIndexOf(int ch)</code> 返回指定字符在此字符串中最后一次出现处的索引。</p></li>
<li><p><code>int lastIndexOf(int ch, int fromIndex)</code> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</p></li>
<li><p><code>int lastIndexOf(String str)</code> 返回指定子字符串在此字符串中最右边出现处的索引。</p></li>
<li><p><code>int lastIndexOf(String str, int fromIndex)</code> 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</p></li>
<li><p><code>int length()</code> 返回此字符串的长度。</p></li>
<li><p><code>boolean matches(String regex)</code> 告知此字符串是否匹配给定的正则表达式。</p></li>
<li><p><code>String replace(char oldChar, char newChar)</code> 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</p></li>
<li><p><code>String replace(CharSequence target, CharSequence replacement)</code> 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</p></li>
<li><p><code>String replaceAll(String regex, String replacement)</code> 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</p></li>
<li><p><code>String[] split(String regex)</code> 根据给定正则表达式的匹配拆分此字符串。</p></li>
<li><p><code>String[] split(String regex, int limit)</code> 根据匹配给定的正则表达式来拆分此字符串。</p></li>
<li><p><code>String substring(int beginIndex)</code> 返回一个新的字符串，它是此字符串的一个子字符串。</p></li>
<li><p><code>String substring(int beginIndex, int endIndex)</code> 返回一个新字符串，它是此字符串的一个子字符串。</p></li>
<li><p><code>char[] toCharArray()</code> 将此字符串转换为一个新的字符数组。</p></li>
<li><p><code>String toLowerCase()</code> 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</p></li>
<li><p><code>String toLowerCase(Locale locale)</code> 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</p></li>
<li><p><code>String toUpperCase()</code> 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</p></li>
<li><p><code>String toUpperCase(Locale locale)</code> 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写</p></li>
<li><p><code>String toString()</code> 返回此对象本身。</p></li>
<li><p><code>isEmpty()</code></p>
<p>判断字符串是否为空。</p></li>
</ul>
<h3 id="stringbuffer-类">2. <code>StringBuffer</code> 类</h3>
<p>如果需要对字符串对象进行修改，需要使用 <code>StringBuffer</code> 和 <code>StringBuilder</code> 类。和 <code>String</code> 类不同的是，<code>StringBuffer</code> 和 <code>StringBuilder</code> 类是可变的，即对象能够被多次的修改，并且不产生新的未使用对象。</p>
<blockquote>
<p>在使用 <code>StringBuffer</code> 类时，每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。</p>
</blockquote>
<h4 id="可变性">2.2 可变性</h4>
<p><code>StringBuilder</code>与<code>StringBuffer</code>都继承自<code>AbstractStringBuilder</code>类，在<code>AbstractStringBuilder</code>中也是使用字符数组保存字符串，但无<code>“final”</code>修饰符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure>
<h4 id="缓冲区">2.3 缓冲区</h4>
<p>每个<code>StringBuffer</code>对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer();	<span class="comment">//分配长16字节的字符缓冲区</span></span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer(<span class="number">512</span>); <span class="comment">//分配长512字节的字符缓冲区</span></span><br><span class="line">StringBuffer buf=<span class="keyword">new</span> StringBuffer(<span class="string">"this is a test"</span>); <span class="comment">//在缓冲区中存放了字符串，并在后面预留了16字节的空缓冲区。</span></span><br></pre></td></tr></table></figure>
<h4 id="多线程安全-1">2.4 多线程安全</h4>
<p><code>StringBuffer</code>对方法加了<code>同步锁</code>或者对调用的方法加了<code>同步锁</code>，所以是<strong>线程安全的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.reverse();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);  <span class="comment">//存在 public synchronized int indexOf(String str, int fromIndex) 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主要方法">2.5 主要方法</h4>
<ul>
<li><p><code>public StringBuffer append(String s)</code></p>
<p>将指定的字符串追加到此字符序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) str = <span class="string">"null"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);<span class="comment">//查看使用空间满足，不满足扩展空间</span></span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);<span class="comment">//getChars就是利用native的array copy,性能高效</span></span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>public StringBuffer reverse()</code></p>
<p>将此字符序列用其反转形式取代。</p></li>
<li><p><code>public delete(int start, int end)</code></p>
<p>移除此序列的子字符串中的字符。</p></li>
<li><p><code>public insert(int offset, int i)</code></p>
<p>将 int 参数的字符串表示形式插入此序列中。</p></li>
<li><p><code>insert(int offset, String str)</code></p>
<p>将 str 参数的字符串插入此序列中。</p></li>
<li><p><code>replace(int start, int end, String str)</code></p>
<p>使用给定 String 中的字符替换此序列的子字符串中的字符。</p></li>
<li><p><code>void setCharAt(int index, char ch)</code></p>
<p>将给定索引处的字符设置为 <code>ch</code>。</p></li>
<li><p><code>void setLength(int newLength)</code></p>
<p>设置字符序列的长度。</p></li>
<li><p><code>String toString()</code></p></li>
</ul>
<p>返回此序列中数据的字符串表示形式。</p>
<h3 id="stringbuilder-类">3. <code>StringBuilder</code> 类</h3>
<p><code>StringBuilder</code> 类在 <strong><code>Java 5</code></strong> 中被提出，它和 <code>StringBuffer</code>类功能基本相似，主要区别在于 <code>StringBuilder</code> 的方法不是线程安全的（不能同步访问）。</p>
<h4 id="可变性-1">3.2 可变性</h4>
<p><code>StringBuilder</code>与<code>StringBuffer</code>相同，是可变的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure>
<h4 id="多线程安全-2">3.3 多线程安全</h4>
<p><code>StringBuilder</code>没有对方法进行加同步锁，所以是<strong>非线程安全的</strong>。</p>
<blockquote>
<p>如果程序不是多线程的，那么使用<code>StringBuilder</code>效率高于<code>StringBuffer</code>。</p>
</blockquote>
<h3 id="主要区别与适用场景">4. 主要区别与适用场景</h3>
<p>主要区别是：</p>
<ul>
<li><code>String</code>：是<strong>不可改变</strong>的量，也就是创建后就不能在修改了。</li>
<li><code>StringBuffer</code>：是一个<strong>可变</strong>字符串序列。</li>
<li><code>StringBuilder</code>：与 <code>StringBuffer</code> 类基本相同，都是可变字符换字符串序列，不同点是 <code>StringBuffer</code> 是<strong>线程安全</strong>的，<code>StringBuilder</code> 是<strong>非线程安全</strong>的。</li>
</ul>
<p>适用场景：</p>
<ul>
<li><code>String</code> 类：在字符串不经常变化的场景中可以使用 <code>String</code> 类，例如常量的声明、少量的变量运算。</li>
<li><code>StringBuffer</code> 类：在频繁进行字符串运算（如拼接、替换、删除等），并且运行在<strong>多线程环境</strong>中，则可以考虑使用 <code>StringBuffer</code>，例如 <code>HTTP</code> 参数解析和封装。</li>
<li><code>StringBuilder</code> 类：在频繁进行字符串运算（如拼接、替换、和删除等），并且运行在<strong>单线程</strong>的环境中，则可以考虑使用 <code>StringBuilder</code>，如 <code>JSON</code> 封装等。</li>
</ul>
<p>性能：</p>
<p><code>String</code> 类的操作是<strong><u>产生新的 <code>String</code> 对象</u></strong>，而 <code>StringBuilder</code> 和 <code>StringBuffer</code> 是一个<strong>字符数组的扩容</strong>，所以 <code>String</code> 类的操作要远慢于 <code>StringBuffer</code> 和 <code>StringBuilder</code>。</p>
<ul>
<li>对 <code>String</code> 类型进行改变的时候其实都等同于<code>生成了一个新的 String 对象</code>，<code>然后将指针指向新的 String 对象</code>。所以经常改变内容的字符串会因<code>频繁生成对象对系统性能产生影响，内存不够时JVM 的 GC 就会开始工作</code>。</li>
<li><code>StringBuffer</code>每次结果都会对 <code>StringBuffer</code> 对象本身进行操作。</li>
<li>某些特别情况下， <code>String</code> 对象的字符串拼接其实是被 <code>JVM</code> 解释成了 <code>StringBuffer</code> 对象的拼接，所以这些时候 <code>String</code> 对象的速度并不会比 <code>StringBuffer</code> 对象慢。</li>
</ul>
<h3 id="参考文献">参考文献</h3>
<ol type="1">
<li><a href="https://www.runoob.com/java/java-string.html" target="_blank" rel="noopener">Java String 类</a></li>
<li><a href="https://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="noopener">Java StringBuffer 和 StringBuilder 类</a></li>
<li><a href="https://www.jb51.net/article/33398.htm" target="_blank" rel="noopener">全面解释java中StringBuilder、StringBuffer、String类之间的关系</a></li>
<li><a href="https://segmentfault.com/a/1190000002683782" target="_blank" rel="noopener">浅谈 Java 字符串（String, StringBuffer, StringBuilder）</a></li>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3778589.html" target="_blank" rel="noopener">探秘Java中的String、StringBuilder以及StringBuffer</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--15 网络与线程</title>
    <url>/2021/05/18/JavaLearning_Head_First_Java_15_networking_and_threads.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>连接到外面的世界。 <a id="more"></a></p>
</blockquote>
<h3 id="客户端client与服务器server">1. 客户端(Client)与服务器(Server)</h3>
<p>客户端必须要认识服务器，服务器必须要认识所有的客户端。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientAndServer.PNG" alt="客户端与服务器" /><figcaption aria-hidden="true">客户端与服务器</figcaption>
</figure>
<p>工作方式如下：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientAndServerWorks.PNG" alt="客户端与服务器工作方式" /><figcaption aria-hidden="true">客户端与服务器工作方式</figcaption>
</figure>
<p>连接、传送与接受：</p>
<p>客户端要连接服务器需要做三件事：</p>
<ol type="1">
<li>建立客户端与服务器之间的初始连接</li>
<li>传送信息到服务器</li>
<li>接受来自服务器的信息</li>
</ol>
<p>Java API的网络功能包(<code>java.net</code>)对底层工作细节进行了封装。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/clientConnectServer.PNG" alt="客户端" /><figcaption aria-hidden="true">客户端</figcaption>
</figure>
<h4 id="socket连接">1.1 Socket连接</h4>
<p>连接到其他机器需要<code>Socket连接</code>，<code>Socket</code>是代表两台机器间网络连接的对象(<code>java.net.Socket</code>)。创建Socket连接需要两项关于<strong>服务器</strong>的信息：<code>IP地址</code>和<code>端口号</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"196.164.1.103"</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
<p>Socket连接的建立代表两台机器间有对方的信息(包括<code>IP地址</code>和<code>端口号</code>)</p>
<p><code>TCP</code>端口是一个<code>16</code>位宽、用来识别服务器上特定程序的数字。一个地址可以有<code>65536</code>个不同的端口号可用。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/wellKnownTCPPort.PNG" alt="常用的TCP端口号" /><figcaption aria-hidden="true">常用的TCP端口号</figcaption>
</figure>
<blockquote>
<p><code>0~1023</code>的<code>TCP</code>端口号预留给已知特定服务使用，可以从<code>1024~65535</code>中选择端口号用于自定义程序</p>
</blockquote>
<p>不同程序不能共享一个端口，使用(也叫绑定)某个已被占用的端口，会受到<code>BindException</code>异常。</p>
<h4 id="读取socket数据">1.2 读取Socket数据</h4>
<p>可以用串流来通过Socket连接沟通，即使用<code>BufferedReader</code>从<code>Socket</code>上读取数据，而不管串流来自文件还是Socket。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 建立对服务器的Socket连接</span></span><br><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立连接到Socket上低层输入串流的InputStreamReader</span></span><br><span class="line">InputStreamReader stream = <span class="keyword">new</span> InputStreamReader(chatSocket.getInputStream());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 建立BufferedReader来读取</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(stream);</span><br><span class="line">String message = reader.readLine();</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/readFromSocket.PNG" alt="读取Socket数据" /><figcaption aria-hidden="true">读取Socket数据</figcaption>
</figure>
<h4 id="向socket写入数据">1.3 向Socket写入数据</h4>
<p>利用<code>PrintWriter</code>向Socket写入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 对服务器建立Socket连接</span></span><br><span class="line">Socket chatSocket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立连接到Socket的PrintWriter</span></span><br><span class="line">PrintWriter writer = <span class="keyword">new</span> PrintWriter(chatSocket.getOutputStream());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 写入数据</span></span><br><span class="line">writer.println(<span class="string">"message to send"</span>);</span><br><span class="line">writer.print(<span class="string">"another message"</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/PrintWriterToSocket.PNG" alt="向Socket写入数据" /><figcaption aria-hidden="true">向Socket写入数据</figcaption>
</figure>
<h4 id="客户端">1.4 客户端</h4>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/client.PNG" alt="客户端" /><figcaption aria-hidden="true">客户端</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyAdviceClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket s = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">4242</span>);</span><br><span class="line">            InputStreamReader streamReader = <span class="keyword">new</span> InputStreamReader(s.getInputStream());</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(streamReader);</span><br><span class="line">            String advice = reader.readLine();</span><br><span class="line">            System.out.println(<span class="string">"Today you should: "</span> + advice);</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DailyAdviceClient client = <span class="keyword">new</span> DailyAdviceClient();</span><br><span class="line">        client.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务器">1.5 服务器</h4>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/server.PNG" alt="客户端" /><figcaption aria-hidden="true">客户端</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyAdviceServer</span> </span>&#123;</span><br><span class="line">    String[] adviceList = &#123;<span class="string">"Take smaller bites"</span>, <span class="string">"Go for the tight jeans. No they do NOT make you look fat."</span>, <span class="string">"One word: inappropriate"</span>, <span class="string">"Just for today, be honest. Tell your boss what you *really* think"</span>, <span class="string">"You might want to rethink that haircut."</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSock = <span class="keyword">new</span> ServerSocket(<span class="number">4242</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket sock = serverSock.accept();</span><br><span class="line"></span><br><span class="line">                PrintWriter writer = <span class="keyword">new</span> PrintWriter(sock.getOutputStream());</span><br><span class="line">                String advice = getAdvice();</span><br><span class="line">                writer.println(advice);</span><br><span class="line">                writer.close();</span><br><span class="line">                System.out.println(advice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// close go</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> random = (<span class="keyword">int</span>) (Math.random() * adviceList.length);</span><br><span class="line">        <span class="keyword">return</span> adviceList[random];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DailyAdviceServer server = <span class="keyword">new</span> DailyAdviceServer();</span><br><span class="line">        server.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程">2. 线程</h3>
<p>每个线程有独立的<code>执行空间(stack)</code>。Java内置有<code>多线程(Multithreading)</code>功能，但只有一种<code>Thread</code>类。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/javaThread.PNG" alt="Thread类" /><figcaption aria-hidden="true">Thread类</figcaption>
</figure>
<h4 id="新建线程">2.1 新建线程</h4>
<p>每个Java应用程序会启动一个主线程，将<code>main()</code>函数放在执行空间最开始处。Java虚拟机负责主线程的启动。自定义建立的线程，需要在程序中启动。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JVMThread.PNG" alt="主线程与自建线程" /><figcaption aria-hidden="true">主线程与自建线程</figcaption>
</figure>
<p>启动新线程主要有以下几个步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 建立Runnable对象(线程的任务)，此类是对线程要执行的任务的定义</span></span><br><span class="line">Runnable threadJob = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立Thread对象(执行工人)并赋值Runnable对象</span></span><br><span class="line"><span class="comment">// 告诉Thread对象把Runnable的run()方法放到执行空间执行</span></span><br><span class="line">Thread myThread = <span class="keyword">new</span> Thread(threadJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 启动线程Thread</span></span><br><span class="line"><span class="comment">// 真正到执行空间执行run()方法</span></span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Thread</code>是个工人，<code>Runnable</code>是这个工人的工作。</p>
</blockquote>
<p><code>Runnable</code>是一个<strong>接口</strong>，只有<code>run()</code>这一个方法。<code>Runnable</code>带有会放在执行空间的第一项方法：<code>run()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// code that will be run by the new thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程的状态">2.2 线程的状态</h4>
<p>新建线程的3个状态：</p>
<ol type="1">
<li><p>等待启动(新建线程)。Thread实例已经创建，但还未启动。即未处于执行中的线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br></pre></td></tr></table></figure></li>
<li><p>可执行线程。启动线程时，变成可执行状态，已经布置好了执行空间，轮到它就可以执行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t.start();</span><br></pre></td></tr></table></figure></li>
<li><p>执行中线程。线程占用资源开始执行，该过程只能依靠JVM的线程调度机制来决定。</p></li>
</ol>
<blockquote>
<p>一旦线程进入可执行状态，会不断在可执行与执行中两种状态切换。也可有另一种状态：暂时不可执行(<code>阻塞状态</code>)</p>
</blockquote>
<ul>
<li>典型的可执行/执行中循环。即JVM线程调度器会把不断切换线程，给予不同线程执行机会。</li>
<li>暂时被阻挡。<code>调度器(scheduler)</code>会在特殊情况下把线程阻塞，比如线程执行到等待<code>Socket</code>输入流的程序段，但又无数据可读，调度器会把线程移出可执行状态。或者<code>Sleep()</code>函数、调用某个被<code>锁住(locked)</code>的对象等等。</li>
</ul>
<h4 id="线程调度器">2.3 线程调度器</h4>
<p><code>线程调度器(Thread Scheduler)</code>会<u>决定哪个线程从等待状态中被挑出来运行，以及何时把哪个线程送回等待被执行的状态</u>。</p>
<blockquote>
<p>调度是无法被控制的</p>
</blockquote>
<p>可以通过<code>sleep</code>强制要求线程睡眠，暂时不被唤醒。但调度器是不可预测的，线程之间可能有多个不同的执行顺序，每次执行可能得到不同的结果。</p>
<blockquote>
<p>Thread对象不能重复使用，一旦线程的run()方法完成后，线程就不能再重新启动。</p>
</blockquote>
<h4 id="sleep">2.4 <code>sleep()</code></h4>
<p>确保线程有机会执行，可以让它们周期性地进入<code>睡眠</code>状态。当线程醒来时，会进入可执行状态等待被调度器调度执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<p><code>sleep</code>方法可能会抛出<code>InterruptedException</code>异常，所以对它的调用需要放在<code>try/catch</code>块中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">     ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="建立与启动多个线程">2.5 建立与启动多个线程</h4>
<p>可以为线程命名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunThreads</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunThreads runner = <span class="keyword">new</span> RunThreads();</span><br><span class="line">        Thread alpha = <span class="keyword">new</span> Thread(runner);</span><br><span class="line">        Thread beta = <span class="keyword">new</span> Thread(runner);</span><br><span class="line">        alpha.setName(<span class="string">"Alpha thread"</span>);</span><br><span class="line">        beta.setName(<span class="string">"Beta thread"</span>);</span><br><span class="line">        alpha.start();</span><br><span class="line">        beta.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(threadName + <span class="string">" is running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程的并发性问题">2.6 线程的并发性问题</h4>
<p>线程的<code>并发性(Concurrency)</code>问题会引发<code>竞争状态(race condition)</code>。竞争状态可能会引起数据的损毁。需要对线程间的共享数据增加一道锁，以保证数据的安全。</p>
<p>要使得具有安全问题的方法<code>原子化</code>，比如对账户操作的方法<code>makeWithdrawal()</code>。确定线程一旦进入这个方法后，就必须能够在其他线程进入之前把任务执行完毕。</p>
<blockquote>
<p>使用<code>synchronized</code>关键词来修饰方法使它每次只能被单一线程存取。</p>
<ul>
<li><code>synchronized</code>关键词代表线程需要钥匙来存取被<code>同步化(synchronized)</code>过的线程。</li>
<li>要保护数据，就把作用在数据上的方法同步化</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">makeWithdrawal</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (account.getBalance() &gt;= amount) &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ is about to withdraw”);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             System.out.println(Thread.currentThread().getName() + “ is going to sleep”);</span><br><span class="line">             Thread.sleep(<span class="number">500</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;ex.printStackTrace(); &#125;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ woke up.”);</span><br><span class="line">         account.withdraw(amount);</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + “ completes the withdrawl”);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(“Sorry, not enough <span class="keyword">for</span> “ + Thread.currentThread().getName());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>锁不是配在方法上的，而是配在对象上的。这意味着对象有两个同步化的方法，就表示两个线程无法进入同一个方法，也表示两个线程无法进入不同的方法。</p>
</blockquote>
<p>同步化除了可以保证数据的安全，但同时也存在一些影响或潜在问题：</p>
<ul>
<li>同步化方法会带来额外的开销(查询钥匙等)</li>
<li>同步化方法会强制线程排队，影响并行性</li>
<li>同步化方法可能会导致死锁</li>
</ul>
<p>原则上只做最少量的同步化，可以用<code>synchronized</code>来修饰一行或数行指令而不必同步化整个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     doStuff();</span><br><span class="line">     <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">         criticalStuff();</span><br><span class="line">         moreCriticalStuff();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于静态方法，每个被载入的类也有锁。</p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--3 认识变量</title>
    <url>/2021/05/11/JavaLearning_Head_First_Java_3_recognize_variables.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>变量有两种：<code>primitive</code>主数据类型和引用。 <a id="more"></a></p>
</blockquote>
<h3 id="声明变量">1. 声明变量</h3>
<p><code>Java</code>中必须声明所有变量的类型。主要分为两种变量</p>
<blockquote>
<ul>
<li><code>primitive</code>主数据类型保存基本类型的值，包括<strong>整数、布尔和浮点数等</strong>；</li>
<li><code>对象引用</code>保存对象的引用</li>
</ul>
</blockquote>
<p>变量必须有<strong>类型</strong>和<strong>名称</strong>。（<strong><code>variables must have a type and a name</code></strong>）</p>
<h4 id="primitive主数据类型"><code>primitive</code>主数据类型</h4>
<p><code>primitive</code>主数据类型有不同大小和名称：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/variable_type_size.PNG" alt="primitive主数据类型有不同大小" /><figcaption aria-hidden="true"><code>primitive</code>主数据类型有不同大小</figcaption>
</figure>
<p>这里展示了<code>primitive</code>主数据类型的名称以及对应的位数：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/primitive_variable_type_size.PNG" alt="primitive主数据类型名称以及对应的位数" /><figcaption aria-hidden="true"><code>primitive</code>主数据类型名称以及对应的位数</figcaption>
</figure>
<blockquote>
<p>这里注意在声明浮点数时，除非加上<code>f</code>，否则所有带小数点的值都会被<code>Java</code>当作<code>double</code>处理。(比如<code>float f = 32.5f</code>)</p>
</blockquote>
<p><code>Java</code>编译器不允许将较大的类型值赋给较小类型，比如<code>int</code>类型值无法赋予<code>byte</code>类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">byte</span> b = x;</span><br></pre></td></tr></table></figure>
<p>即使<code>byte</code>可以装下<code>24</code>，这条语句也不能通过编译。</p>
<h4 id="对象引用">对象引用</h4>
<p>没有对象变量存在，只有<code>引用（reference）</code>到对象的变量。</p>
<blockquote>
<p>对象引用变量保存的是<strong>存取对象的方法</strong>；</p>
</blockquote>
<p>它不是对象的容器，而是类似于指向对象的指针或者说地址。</p>
<blockquote>
<p>但只有<code>Java</code>虚拟机知道如何使用引用来获取对象，我们并不知道引用变量中实际装载的是什么。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/variable_object_reference.PNG" alt="对象引用" /><figcaption aria-hidden="true">对象引用</figcaption>
</figure>
<p>对象的声明、创建与赋值有三个步骤：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/create_object.PNG" alt="对象的声明、创建与赋值" /><figcaption aria-hidden="true">对象的声明、创建与赋值</figcaption>
</figure>
<blockquote>
<p><strong>数组也是对象</strong></p>
</blockquote>
<p>无论声明来承载<code>primitive</code>主数据类型还是对象引用，数组永远是对象。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/array_is_object.PNG" alt="数组也是对象" /><figcaption aria-hidden="true">数组也是对象</figcaption>
</figure>
<h3 id="变量命名规范">2. 变量命名规范</h3>
<p>可以根据一下规则来为类、方法或变量命名：</p>
<blockquote>
<ul>
<li>名称必须以字母、下划线(<code>_</code>)或<code>$</code>符号开头，不能用数字开头；</li>
<li>除了第一个字符外，后面就可以用数字；</li>
<li>只要符合上述两条规则，就可以进行任意命名了。但要注意避开Java<code>保留字</code>。</li>
</ul>
</blockquote>
<p>这里的规则是最为基础的规则了，实际上为了命名规范，还有更多更复杂的要求。Java<code>保留字</code>一览表：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/reserved_word.PNG" alt="Java保留字一览表" /><figcaption aria-hidden="true">Java<code>保留字</code>一览表</figcaption>
</figure>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--6 认识Java的API</title>
    <url>/2021/05/12/JavaLearning_Head_First_Java_6_Using_the_Java_Library.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>Java内置有数百个类。 <a id="more"></a></p>
</blockquote>
<h3 id="解决上一章程序的bug">1. 解决上一章程序的bug</h3>
<p>上一章的简单版游戏中，一旦猜中了一格，可以持续攻击同一格结束游戏。需要一种机制判别之前是否已经猜中过。</p>
<h4 id="方案一">方案一</h4>
<p>使用第二个数组，一旦玩家猜中某格，就把对应的格设置为true，之后每次猜中都检查是否已经猜中过。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionOneForDotComBug.PNG" alt="方案一" /><figcaption aria-hidden="true">方案一</figcaption>
</figure>
<p>但这种方法过于耗时，每次猜中某一格，都必须检查或改变第二个数组的状态，且需要额外的空间。</p>
<h4 id="方案二">方案二</h4>
<p>只动用原来数组，将任何被命中的格子改为<code>-1</code>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionTwoForDotComBug.PNG" alt="方案二" /><figcaption aria-hidden="true">方案二</figcaption>
</figure>
<p>但依旧不是很有效率，已经命中过的格子还是需要再次被搜索。</p>
<h4 id="方案三">方案三</h4>
<p>在命中某个格子后，就把它删掉，格子会越来越少。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/optionThreeForDotComBug.PNG" alt="方案三" /><figcaption aria-hidden="true">方案三</figcaption>
</figure>
<p>但数组大小无法改变，必须创建新数组并进行拷贝。如果有<em>可变数组</em>就可以解决这个问题。</p>
<h3 id="arraylist类">2. <code>ArrayList</code>类</h3>
<p><code>ArrayList</code>类是Java库函数中的一个类，是一个"边长的数组"。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/someMethodsArrayList.PNG" alt="ArrayList类部分方法" /><figcaption aria-hidden="true"><code>ArrayList</code>类部分方法</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/someMethodsArrayList2.PNG" alt="ArrayList的操作" /><figcaption aria-hidden="true"><code>ArrayList</code>的操作</figcaption>
</figure>
<p><code>ArrayList</code>与一般数组的区别：</p>
<blockquote>
<ul>
<li>一般数组在创建时必须确定大小，但<code>ArrayList</code>只需要创建出该类型对象就可以。</li>
<li>存放对象时，一般数组需要指定位置；<code>ArrayList</code>可以使用方法<code>add()</code>。</li>
<li>一般数组使用<code>[]</code>来存取对象；<code>ArrayList</code>使用<code>get</code>方法。</li>
<li>在<code>Java 5.0</code>中<code>ArrayList</code>是<strong>参数化的(parameterized)</strong>，即<code>ArrayList&lt;Type&gt;</code>。<code>&lt;Type&gt;</code>是类型参数，代表<code>Type</code>类型的集合。</li>
</ul>
</blockquote>
<h3 id="完整版sink-a-dot-com">3. 完整版"Sink a Dot Com"</h3>
<p>需要对原来的三个类进行修改：</p>
<blockquote>
<ul>
<li><code>DotCom</code>类。原来的<code>SimpleDotCom</code>类。
<ul>
<li>需要增加名称变量来保存<code>DotCom</code>的名字。</li>
</ul></li>
<li><code>DotComBust</code>类。原来的<code>SimpleDotComGame</code>类。
<ul>
<li>需要创建多个<code>DotCom</code>对象。</li>
<li>将<code>DotCom</code>对象放到方阵上。</li>
<li>每次猜测要检查多个<code>DotCom</code>，所有都击沉后才能结束游戏。</li>
<li>脱离<code>main()</code>函数。</li>
</ul></li>
<li><code>GameHelper</code>类。</li>
</ul>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/fullDotComGame.PNG" alt="完整版&quot;Sink a Dot Com&quot;类间关系" /><figcaption aria-hidden="true">完整版"Sink a Dot Com"类间关系</figcaption>
</figure>
<h4 id="dotcombust类">3.1 <code>DotComBust</code>类</h4>
<h5 id="伪码">伪码</h5>
<p><code>DotComBust</code>类有3个任务：启动游戏，运行游戏以及结束游戏。可以对运行游戏任务分解，较小的方法更容易测试修改。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dotComBustPrepCode.PNG" alt="DotComBust伪码" /><figcaption aria-hidden="true">DotComBust伪码</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/dotComBustPrepCodeContinued.PNG" alt="DotComBust伪码（续）" /><figcaption aria-hidden="true">DotComBust伪码（续）</figcaption>
</figure>
<h5 id="真实码">真实码</h5>
<p><code>DotComBust</code>类Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotComBust</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GameHelper helper = <span class="keyword">new</span> GameHelper();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;DotCom&gt; dotComList = <span class="keyword">new</span> ArrayList&lt;DotCom&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfGuesses = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建dotCom实例，并加入到dotComList中</span></span><br><span class="line">        DotCom one = <span class="keyword">new</span> DotCom();</span><br><span class="line">        one.setName(<span class="string">"Pets.com"</span>);</span><br><span class="line">        dotComList.add(one);</span><br><span class="line"></span><br><span class="line">        DotCom two = <span class="keyword">new</span> DotCom();</span><br><span class="line">        two.setName(<span class="string">"eToys.com"</span>);</span><br><span class="line">        dotComList.add(two);</span><br><span class="line"></span><br><span class="line">        DotCom three = <span class="keyword">new</span> DotCom();</span><br><span class="line">        three.setName(<span class="string">"Go2.com"</span>);</span><br><span class="line">        dotComList.add(three);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出提示信息</span></span><br><span class="line">        System.out.println(<span class="string">"Your goal is to sink three dot coms."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Pets.com, eToys.com, Go2.com"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Try to sink them all in the fewest number of guesses"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化每个dotCom在棋盘中的位置</span></span><br><span class="line">        <span class="keyword">for</span> (DotCom dotComToSet: dotComList) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; newLocation = helper.placeDotCom(<span class="number">3</span>);</span><br><span class="line">            dotComToSet.setLocationCells(newLocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startPlaying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!dotComList.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取用户的猜测值</span></span><br><span class="line">            String userGuess = helper.getUserInput(<span class="string">"Enter a guess"</span>);</span><br><span class="line">            <span class="comment">// 检查玩家猜测值</span></span><br><span class="line">            checkUserGuess(userGuess);</span><br><span class="line">        &#125;</span><br><span class="line">        finishGame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkUserGuess</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        numOfGuesses++;</span><br><span class="line">        String result = <span class="string">"miss"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (DotCom dotComToSet: dotComList) &#123;</span><br><span class="line">            result = dotComToSet.checkYourself(userGuess);</span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"hit"</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"kill"</span>)) &#123;</span><br><span class="line">                dotComList.remove(dotComToSet);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"All Dot Coms are dead! Your stock is now worthless."</span>);</span><br><span class="line">        <span class="keyword">if</span> (numOfGuesses &lt;= <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"It only took you "</span> + numOfGuesses + <span class="string">" guesses."</span>);</span><br><span class="line">            System.out.println(<span class="string">" You got out before your options sank."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Took you long enough. "</span> + numOfGuesses + <span class="string">" guesses."</span>);</span><br><span class="line">            System.out.println(<span class="string">"Fish are dancing with your options."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotComBust game = <span class="keyword">new</span> DotComBust();</span><br><span class="line">        game.setUpGame();</span><br><span class="line">        game.startPlaying();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dotcom类">3.2 <code>DotCom</code>类</h4>
<p><code>DotCom</code>类Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotCom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; locationCells;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocationCells</span> <span class="params">(ArrayList&lt;String&gt; locations)</span> </span>&#123;</span><br><span class="line">        locationCells = locations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkYourself</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">"miss"</span>; <span class="comment">// 创建保存返回结果的变量, 以miss作为默认值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (locationCells.contains(userGuess)) &#123;</span><br><span class="line">            locationCells.remove(userGuess);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(locationCells.isEmpty()) &#123;</span><br><span class="line">                result = <span class="string">"kill"</span>;</span><br><span class="line">                System.out.println(<span class="string">"Ouch! You sunk "</span> + name + <span class="string">" :("</span>); <span class="comment">// 显式结果</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="string">"hit"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(result); // 显式结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="gamehelper类">3.3 <code>GameHelper</code>类</h4>
<p><code>GameHelper</code>类除了获取玩家输入外，还增加了设置<code>DotCom</code>的位置这一功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String alphabet = <span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gridLength = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gridSize = <span class="number">49</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] grid = <span class="keyword">new</span> <span class="keyword">int</span>[gridSize];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> comCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInput</span><span class="params">(String prompt)</span> </span>&#123;</span><br><span class="line">        String inputLine = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(prompt + <span class="string">"  "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">            );</span><br><span class="line">            inputLine = is.readLine();</span><br><span class="line">            <span class="keyword">if</span> (inputLine.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inputLine.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">placeDotCom</span><span class="params">(<span class="keyword">int</span> comSize)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; alphaCells = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        String temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 现有字符串</span></span><br><span class="line">        <span class="keyword">int</span> [] coords = <span class="keyword">new</span> <span class="keyword">int</span> [comSize];</span><br><span class="line">        <span class="comment">// 目前测试的字符串</span></span><br><span class="line">        <span class="keyword">int</span> attempts = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到适合的位置吗？</span></span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 目前起点</span></span><br><span class="line">        <span class="keyword">int</span> location = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在处理到第n个dot com</span></span><br><span class="line">        comCount++;</span><br><span class="line">        <span class="comment">// incr是增量, 水平方向增量(+1), 垂直增量(+7, gridLength)</span></span><br><span class="line">        <span class="keyword">int</span> incr = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果是单数号dot com, 垂直增量</span></span><br><span class="line">        <span class="keyword">if</span> ((comCount % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            incr = gridLength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主要搜索循环</span></span><br><span class="line">        <span class="keyword">while</span> (!success &amp; attempts++ &lt; <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 随机起点</span></span><br><span class="line">            location = (<span class="keyword">int</span>) (Math.random() * gridSize);</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 假设是适合的位置</span></span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查找未使用的点</span></span><br><span class="line">            <span class="keyword">while</span> (success &amp;&amp; x &lt; comSize) &#123;</span><br><span class="line">                <span class="comment">// 若未使用</span></span><br><span class="line">                <span class="keyword">if</span> (grid[location] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 存储位置，尝试下一个点</span></span><br><span class="line">                    coords[x++] = location;</span><br><span class="line">                    location += incr;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 超出边缘, 失败, 不是适合的</span></span><br><span class="line">                    <span class="keyword">if</span> (location &gt;= gridSize) &#123;</span><br><span class="line">                        success = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 水平方向超出边缘, 失败</span></span><br><span class="line">                    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; (location % gridLength) == <span class="number">0</span>) &#123;</span><br><span class="line">                        success = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 该位置已经使用过</span></span><br><span class="line">                    success = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将位置转换为字符串</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(x &lt; comSize) &#123;</span><br><span class="line">            <span class="comment">// 标示格子已用</span></span><br><span class="line">            grid[coords[x]] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 行值</span></span><br><span class="line">            row = (<span class="keyword">int</span>) (coords[x] / gridLength);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 列值</span></span><br><span class="line">            column = coords[x] % gridLength;</span><br><span class="line">            temp = String.valueOf(alphabet.charAt(column));</span><br><span class="line"></span><br><span class="line">            alphaCells.add(temp.concat(Integer.toString(row)));</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  alphaCells;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="布尔表达式">4. 布尔表达式</h3>
<ol type="1">
<li><p>“与”和“或”运算符(<code>&amp;&amp;</code>, <code>||</code>)</p></li>
<li><p>“不等于”运算符(<code>!=</code>和<code>!</code>)</p></li>
<li><p>短运算符(<code>&amp;&amp;</code>, <code>||</code>)</p>
<blockquote>
<p>比如<code>&amp;&amp;</code>表达式中，左右两边都为<code>true</code>这个表达式才为<code>true</code>。因此<code>Java</code>虚拟机发现左方表达式为<code>false</code>时不需要也不会计算右边表达式。<code>||</code>类似。基于这样的性质可以避免调用内容为<code>null</code>的引用变量：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (refVar != <span class="keyword">null</span> &amp;&amp; refVar.isValidType() ) &#123;</span><br><span class="line"> <span class="comment">// do ‘got a valid type’ stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>长运算符(<code>&amp;</code>, <code>|</code>)</p>
<p><code>&amp;</code>和 <code>|</code>运算符通常用于位运算，Java虚拟机会计算运算符两边的算式。</p></li>
</ol>
<h3 id="使用库函数java-api">5. 使用库函数(<code>Java API</code>)</h3>
<h4 id="库函数的使用">5.1 库函数的使用</h4>
<p>在<code>Java API</code>中，类是包装在<code>包</code>中的。要使用<code>API</code>中的类，必须直到它在哪个包中。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/apiPakage.PNG" alt="在Java API中，类被包装在包中" /><figcaption aria-hidden="true">在<code>Java API</code>中，类被包装在<code>包</code>中</figcaption>
</figure>
<p>必须指明程序代码中所使用到的类的完整名称。(<strong>除了<code>java.lang</code>之外</strong>)</p>
<blockquote>
<p>比如<code>ArrayList</code>的完整名称应该是：<code>java.util.ArrayList</code></p>
</blockquote>
<p>主要有两种方法可以指定使用的是哪一个<code>ArrayList</code>：</p>
<ol type="1">
<li><p><code>Import</code></p>
<p>在程序源文件最前面放上<code>import</code>述句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;... &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Type</code></p>
<p>直接在程序代码中打出全名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line">java.util.ArrayList&lt;Dog&gt; list = <span class="keyword">new</span> java.util.ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用参数</span></span><br><span class="line">java.util.ArrayList&lt;Dog&gt; list = <span class="keyword">new</span> java.util.ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型</span></span><br><span class="line"><span class="keyword">public</span> java.util.<span class="function">ArrayList&lt;Dog&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><code>java.lang</code>是个预先被引用的包，因为<code>java.lang</code>是经常会被用到的基础包，所有可以不必指定名称。比如<code>java.lang.String</code>与<code>java.lang.System</code>都不需要<code>import</code>或写全名。</p>
</blockquote>
<h4 id="关于javax开头的包中x的含义">5.2 关于<code>javax</code>开头的包中<code>x</code>的含义</h4>
<p><code>javax</code>作为开头的包是指标准版的扩展函数库。后来纳入到标准库中后，为了保持程序的兼容性，故而沿用了<code>javax</code>这一命名。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/javaxHistory.PNG" alt="javax中x的由来" /><figcaption aria-hidden="true"><code>javax</code>中<code>x</code>的由来</figcaption>
</figure>
<h4 id="如何查阅api">5.3 如何查阅<code>API</code></h4>
<p>使用函数库必须知道：</p>
<ol type="1">
<li>库中有哪些类</li>
<li>这些类是做什么的</li>
</ol>
<p>主要方法是：</p>
<ol type="1">
<li>查阅参考书</li>
<li>查阅HTML API文档</li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--16 集合与泛型</title>
    <url>/2021/05/19/JavaLearning_Head_First_Java_16_collections_and_generics.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>排序在Java中只是雕虫小技。 <a id="more"></a></p>
</blockquote>
<h3 id="集合">1. 集合</h3>
<p><code>ArrayList</code>是最常用的集合，此外还有一些较为重要的集合：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/collector.PNG" alt="一些集合类" /><figcaption aria-hidden="true">一些集合类</figcaption>
</figure>
<p>可以使用<code>TreeSet</code>或<code>Collections.sort()</code>方法对集合元素排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(songList);</span><br></pre></td></tr></table></figure>
<p>若将<code>ArrayList</code>声明为自定义类(如<code>Song</code>)的数组，使用<code>Collections.sort()</code>将无法通过编译。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/sortMethod.PNG" alt="sort方法定义" /><figcaption aria-hidden="true">sort方法定义</figcaption>
</figure>
<blockquote>
<p><code>sort()</code>方法取只能接受<code>Comparable</code>对象的<code>list</code>。</p>
</blockquote>
<h4 id="collections接口">1.1 Collections接口</h4>
<p><code>Collections</code>主要有<code>3</code>个接口：<code>List</code>，<code>Set</code>和<code>Map</code>。</p>
<ul>
<li><code>List</code>是一种知道索引位置的集合，可以存在重复元素。</li>
<li><code>Set</code>知道某物是否存在于集合中，它不允许重复。</li>
<li><code>Map</code>使用成对的键值(<code>key</code>)和数据值(<code>value</code>)，<code>key</code>可以引用相同的对象，但<code>key</code>自身不能重复。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/collectorTree.PNG" alt="Collection API" /><figcaption aria-hidden="true">Collection API</figcaption>
</figure>
<h4 id="对象等价">1.2 对象等价</h4>
<ul>
<li><code>引用相等性</code>。堆上同一对象的两个引用，引用对堆上同一个对象的两个引用时相等的。如果这两个引用调用<code>hashCode</code>，会得到相同的结果。使用<code>==</code>来比较变量上的子节组合，判断引用是否相等。</li>
<li><code>对象相等性</code>。堆上的两个不同对象在意义上是相同的，要把两个不同的对象视为相等，需要覆盖<code>hashCode</code>方法与<code>equals</code>方法。</li>
</ul>
<blockquote>
<p>要让<code>set</code>把对象视为重复的，必须满足<code>equals</code>和<code>hashCode</code>返回两对象相等。</p>
</blockquote>
<p><code>equals</code>和<code>hashCode</code>的相关规定：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/hashCodeEquals.PNG" alt="equals和hashCode" /><figcaption aria-hidden="true"><code>equals</code>和<code>hashCode</code></figcaption>
</figure>
<h4 id="treeset">1.3 TreeSet</h4>
<p>使用<code>TreeSet</code>必须使得以下一项为真：</p>
<ul>
<li><p>集合中的元素必须是有实现<code>Comparable</code>的类型；</p></li>
<li><p>使用重载、取用<code>Comparator</code>参数的构造函数创建<code>TreeSet</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BookCompare bCompare = <span class="keyword">new</span> BookCompare();</span><br><span class="line">TreeSet&lt;Book&gt; tree = <span class="keyword">new</span> TreeSet&lt;Book&gt;(bCompare);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="map">1.4 Map</h4>
<p><code>Map</code>的元素实际上是两个对象：关键词(key)和值(value)。值可以重复，但key不能重复。通过<code>Map</code>可以用名称来取值等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; scores = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">scores.put(“Kathy”, <span class="number">42</span>);</span><br><span class="line">scores.put(“Bert”, <span class="number">343</span>);</span><br><span class="line">scores.put(“Skyler”, <span class="number">420</span>);</span><br></pre></td></tr></table></figure>
<h3 id="泛型">2. 泛型</h3>
<p><code>&lt;&gt;</code>符号代表<code>泛型(generic)</code>正在起作用，它是从<code>Java 5.0</code>开始加入的特质。泛型的主要目的是能够获取有<u>更好的类型安全性的集合</u>。</p>
<blockquote>
<p>在泛型出现前，没有办法什么<code>ArrayList</code>的类型，所以只能用<code>Object</code>来操作。各种对象以引用的形式加入到<code>ArrayList</code>中，出来时会是<code>Object</code>类型的引用。</p>
</blockquote>
<p>使用泛型后，能定义<code>ArrayList</code>类型，在取出时还是该类型的引用。此外也不能在该<code>ArrayList</code>中加入非该类的对象。关于泛型几件重要的事：</p>
<ol type="1">
<li><p>创建被泛型化类的实例。比如创建<code>ArrayList</code>时必须指定它所容许的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ArrayList&lt;Song&gt;()</span><br></pre></td></tr></table></figure></li>
<li><p>声明与指定泛型类型的变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Song&gt; songList = <span class="keyword">new</span> ArrayList&lt;Song&gt;()</span><br></pre></td></tr></table></figure></li>
<li><p>声明(与调用)取用泛型类型的方法。</p></li>
</ol>
<h4 id="泛型的类">2.1 泛型的类</h4>
<p>查看泛型化类型，有两个关键的部分：</p>
<ol type="1">
<li>类的声明。</li>
<li>新增元素的方法的声明。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; ... </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>E</code>部分会用所声明和创建的真正类型来取代，<code>E</code>代指<code>Element</code>。在新增元素的方法中，也用<code>E</code>指示可以加入<code>ArrayList</code>的元素类型。</li>
<li>这里<code>E</code>并不是关键词，硬性规定的。也可以用其他合法字符串来当作类型参数。习惯用法是以单一字母表示。</li>
</ul>
</blockquote>
<h4 id="泛型的方法">2.2 泛型的方法</h4>
<p>泛型的类代表类的声明用到类型参数。泛型的方法代表方法的声明特征用到类型参数。</p>
<ol type="1">
<li><p>使用定义在类声明的类型参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; ... </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>声明类的类型参数后，就可以直接把该类或接口类型用在任何地方。</p></li>
<li><p>使用未定义在类声明的类型参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure>
<p>如果类本身未使用类型参数，可以通过在返回类型之前指定给该方法。<code>&lt;T extends Animal&gt;</code>意味着<code>T</code>可以是任意一种<code>Animal</code>。</p></li>
</ol>
<p>这里需要注意的是，以下两种方法的声明合法，但意义不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;Animal&gt; list)</span></span></span><br></pre></td></tr></table></figure>
<p><code>&lt;T extends Animal&gt;</code>是方法声明的一部分，表示任何被声明未<code>Animal</code>或<code>Animal</code>的子类型的<code>ArrayList</code>是合法的。可以使用<strong>任意一种</strong><code>Animal</code>的<code>ArrayList</code>。</p>
<p>但下面的方法中<code>ArrayList&lt;Animal&gt; list</code>代表只有<code>ArrayList&lt;Animal&gt;</code>是合法的，也就是它<strong>只能使用</strong><code>Animal</code>的<code>ArrayList</code>。</p>
<h4 id="sort方法中的泛型">2.3 <code>sort()</code>方法中的泛型</h4>
<p>回到<code>sort()</code>方法的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure>
<p>实际上<code>Comparable</code>是一个接口，但以泛型的观点，<code>extends</code>代表<code>extends</code>或<code>implement</code>。所以必须实现<code>Comparable</code>才能把类的<code>ArrayList</code>传给<code>sort</code>。只有一个方法需要实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>compareTo</code>方法会判别在排序位置上某个对象是高于、低于或等于另一个对象。<code>sort()</code>有重载方法，可以取用称为<code>Comparator</code>的参数。<code>Comparator</code>是独立的类，因此可以实现不同的比较方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用规则如下：</p>
<ul>
<li>调用单一参数的<code>sort(List o)</code>方法代表由<code>List</code>元素上的<code>compareTo</code>方法来决定顺序，需要实现<code>Comparable</code>接口。</li>
<li>调用<code>sort(List o, Comparator c)</code>方法代表不会调用<code>list</code>元素的<code>compareTo</code>方法，而会使用<code>Comparator</code>的<code>compare</code>方法，这种情况下list元素不需要实现<code>Comparable</code>接口。</li>
</ul>
<h4 id="多态与泛型">2.4 多态与泛型</h4>
<p>在普通的多态中，定义如下函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(Animal a: animals) &#123;</span><br><span class="line">         a.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法只能取用<code>ArrayList&lt;Animal&gt;</code>参数，而不能传入<code>ArrayList&lt;Dog&gt;</code>或<code>ArrayList&lt;Cat&gt;</code>，以为如果程序执行如下代码时，会出现类型错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">	animals.add(<span class="keyword">new</span> Cat());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数换成数组时尽管能通过编译，但在执行时也会出错。</p>
<blockquote>
<p>数组的类型在运行期间检查，集合的类型检查只发生在编译期间。</p>
</blockquote>
<p>可以使用泛型的<code>万用字符(wildcard)</code>来解决这个问题。创建出可以接受<code>Animal</code>子类型参数的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeAnimals</span><span class="params">(ArrayList&lt;? extends Animal&gt; animals)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(Animal a: animals) &#123;</span><br><span class="line">     	a.eat();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用带有<code>&lt;?&gt;</code>的声明时，编译器会组织任何可能破坏引用参数所指集合的行为。</p>
<ul>
<li>可以调用<code>list</code>中任何元素的方法，但不能加入元素。即可以操作集合元素，但不能新增集合元素，以保证安全性。</li>
</ul>
<p>两种不同的语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Animal&gt; <span class="function"><span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeThing</span><span class="params">(ArrayList&lt;? extends Animal&gt; list)</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--14 序列化和文件的输入/输出</title>
    <url>/2021/05/18/JavaLearning_Head_First_Java_14_serialization_and_file_IO.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>对象可以被序列化也可以展开。 <a id="more"></a></p>
</blockquote>
<h3 id="存储对象">1. 存储对象</h3>
<p>存储对象状态的数据格式（主要讨论两种）：</p>
<ul>
<li>序列化(serialization)。将被序列化的对象写到文件中，然后让程序去文件中读取序列化的对象并把他们展开变回状态。</li>
<li>纯文本文件。用可解析的特殊字符写到文件中，比如用<code>tab</code>字符来分隔数据。</li>
</ul>
<p>将对象序列化（存储）的方法步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1. 创建出 FileOutputStream</span></span><br><span class="line">FileOutputStream fileStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"MyGame.ser"</span>); <span class="comment">// 文件不存在会自动创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建出 ObjectOutputStream</span></span><br><span class="line">ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(fileStream); <span class="comment">// 可以向文件写入对象，但无法直接连接文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 写入对象</span></span><br><span class="line">os.writeObject(characterOne); <span class="comment">// 将变量所引用的对象序列化并写入文件</span></span><br><span class="line">os.writeObject(characterTwo);</span><br><span class="line">os.writeObject(characterThree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 关闭 ObjectOutputStream</span></span><br><span class="line">os.close(); <span class="comment">// 关闭所关联的输出串流</span></span><br></pre></td></tr></table></figure>
<p>Java输入/输出<code>API</code>带有连接类型的<code>串流(chain streams)</code>，代表来源与目的地之间的连接，连接串流将串流与其他串流连接起来。</p>
<p>串流要两两连接，一个表示连接，另一个是要被调用方法。<code>FileOutputStream</code>把子节写入文件，<code>ObjectOutputStream</code>把对象转换成可以写入串流的数据。当调用<code>ObjectOutputStream</code>的<code>writeObject</code>方法时，对象会被打成串流送到<code>FileOutputStream</code>来写入文件。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/chainStreams.PNG" alt="序列化" /><figcaption aria-hidden="true">序列化</figcaption>
</figure>
<blockquote>
<p>当对象被序列化时，被该对象引用的实例变量也会被序列化，且所有被引用的对象也会被序列化。</p>
</blockquote>
<p>如果要让类能够被序列化，需要实现<code>Serializable</code>。<code>Serializable</code>接口又被称为<code>marker</code>或<code>tag</code>类的标记用接口，此接口没有任何方法需要实现，唯一目的是<u><strong>声明所有实现它的类是可以被序列化的</strong></u>。所以此类型的对象可以通过序列化机制来存储。</p>
<blockquote>
<ul>
<li>某类是可序列化的，则它的子类也自动地可以序列化</li>
<li>序列化是全有或全无地，即整个对象版图必须全部正确序列化，不然全部失败。</li>
</ul>
</blockquote>
<p>如果某实例变量不能或不应该被序列化，需要标记其为<code>transient</code>(瞬时)。序列化程序会跳过标记的变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chat</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">transient</span> String currentID;</span><br><span class="line"> </span><br><span class="line">     String userName;</span><br><span class="line">     <span class="comment">// more code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="还原对象">2. 还原对象</h3>
<p><code>解序列化(Deserialization)</code>像是序列化的反向操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建FileInputStream</span></span><br><span class="line">FileInputStream fileStream = <span class="keyword">new</span> FileInputStream(<span class="string">"MyGame.ser"</span>); <span class="comment">// 文件不存在会抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建ObjectInputStream</span></span><br><span class="line"><span class="comment">// ObjectInputStream可以读取对象，但不能直接连接文件，需要一个连接流(connection stream)</span></span><br><span class="line">ObjectInputStream os = <span class="keyword">new</span> ObjectInputStream(fileStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 读取对象</span></span><br><span class="line"><span class="comment">// 每次readObject都会读出下一个对象，读取顺序与写入顺序相同，次数超过会抛出异常</span></span><br><span class="line">Object one = os.readObject();</span><br><span class="line">Object two = os.readObject();</span><br><span class="line">Object three = os.readObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 转换对象类型</span></span><br><span class="line"><span class="comment">// 返回值是Object类型，因此必须要转换类型</span></span><br><span class="line">GameCharacter elf = (GameCharacter) one;</span><br><span class="line">GameCharacter troll = (GameCharacter) two;</span><br><span class="line">GameCharacter magician = (GameCharacter) three;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 关闭ObjectInputStream</span></span><br><span class="line"><span class="comment">// FileInputStream会随之自动关闭</span></span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure>
<p>对象被解序列化时，Java虚拟机会通过尝试在堆上创建新对象，让它维持与被序列化时有相同的状态来恢复对象的原状。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/Deserialization.PNG" alt="解序列化" /><figcaption aria-hidden="true">解序列化</figcaption>
</figure>
<ol type="1">
<li>对象从<code>stream</code>中读出来；</li>
<li>Java虚拟机通过存储的消息判断出对象的class类型；</li>
<li>Java虚拟机尝试寻找和加载对象的类。如果Java虚拟机找不到或无法加载该类，则Java虚拟机会抛出异常</li>
<li>新的对象会被配置在堆上，但构造函数不会执行。</li>
<li>如果对象在继承树上有不可序列化的祖先类，则该不可序列化类以及它之上的类的构造函数会执行。</li>
<li>对象的实例变量会被还原成序列化时的状态值。<code>transient</code>变量会被赋值默认值。</li>
</ol>
<h3 id="将字符串写入文本文件">3. 将字符串写入文本文件</h3>
<p>写入文本数据与写入对象类似，可以使用<code>FileWriter</code>代替<code>FileOutputStream</code>，它不会被连接到<code>ObjectOutputStream</code>上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteAFile</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="string">"Foo.txt"</span>);</span><br><span class="line">             writer.write(<span class="string">"hello foo!"</span>);</span><br><span class="line">             writer.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">             ex.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.io.File</code>类代表磁盘上的文件，但并不是文件中的内容。<code>File</code>没有读写文件的方法，它提供一种比字符串文件名来表示文件更安全的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建出代表磁盘文件的File对象</span></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"MyCode.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 建立新的目录</span></span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"Chapter7"</span>); </span><br><span class="line">dir.mkdir();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 列出目录下的内容</span></span><br><span class="line"><span class="keyword">if</span> (dir.isDirectory()) &#123;</span><br><span class="line">	String[] dirContents = dir.list();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dirContents.length; i++) &#123;</span><br><span class="line">		System.out.println(dirContents[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 取得文件或目录的绝对路径</span></span><br><span class="line">System.out.println(dir.getAbsolutePath());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 删除文件或目录</span></span><br><span class="line"><span class="keyword">boolean</span> isDeleted = f.delete();</span><br></pre></td></tr></table></figure>
<p><strong>缓冲区</strong></p>
<p>缓冲区可以带来更高的效率。通过<code>BufferedWriter</code>和<code>FileWriter</code>的链接，<code>BufferedWriter</code>可以暂存一些数据，到满的时候在实际写入磁盘，可以减少对磁盘的操作次数。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/buffers.PNG" alt="缓冲区" /><figcaption aria-hidden="true">缓冲区</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(aFile));</span><br></pre></td></tr></table></figure>
<p>若想要强制缓冲区立即写入，可以调用以下方法要求立即写入缓冲区内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">writer.flush();</span><br></pre></td></tr></table></figure>
<h3 id="读取文本文件">4. 读取文本文件</h3>
<p>用<code>File</code>对象来表示文件，以<code>FileReader</code>来执行实际的读取，并用<code>BufferedReader</code>来让读取更有效。读取以<code>while</code>循环来逐行进行，知道<code>readLine()</code>的结果为<code>null</code>为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadAFile</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             File myFile = <span class="keyword">new</span> File(<span class="string">"MyText.txt"</span>);</span><br><span class="line">             <span class="comment">// FileReader是字符连接到文本文件的串流</span></span><br><span class="line">             FileReader fileReader = <span class="keyword">new</span> FileReader(myFile);</span><br><span class="line">             <span class="comment">// FileReader链接到BufferedReader以获取更高效率</span></span><br><span class="line">             BufferedReader reader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">             </span><br><span class="line">             <span class="comment">// 用String变量来承接所读取的结果</span></span><br><span class="line">             String line = <span class="keyword">null</span>;</span><br><span class="line">             </span><br><span class="line">             <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 读一行就列出一行</span></span><br><span class="line">                 System.out.println(line);</span><br><span class="line">             &#125;</span><br><span class="line">             reader.close(); </span><br><span class="line">         &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">             ex.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解析字符串</strong></p>
<p>用<code>String</code>的<code>split()</code>方法来解析字符串，<code>split()</code>可以将字符串拆开成<code>String</code>的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从文件读出来的格式</span></span><br><span class="line">String toTest = <span class="string">"What is blue + yellow?/green"</span>;</span><br><span class="line"><span class="comment">// split用参数所指定的字符来把这个String拆开成两个部分</span></span><br><span class="line">String[] result = toTest.split(<span class="string">"/"</span>);</span><br><span class="line"><span class="keyword">for</span> (String token:result) &#123;</span><br><span class="line">     System.out.println(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.nio</code>类可以直接控制<code>buffer</code>。另一个能力是<code>non-blocking</code>的输入/输出，能让输入/输出程序代码在没有东西可读取或写入时不必等待。</p>
<p><strong>序列化的识别</strong></p>
<p>版本控制很重要，如果在序列化后修改了类的定义，会伤害兼容性：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/changesForDeserialization.PNG" alt="修改对序列化的影响" /><figcaption aria-hidden="true">修改对序列化的影响</figcaption>
</figure>
<p>每当对象被序列化时，该对象会被盖上一个类版本识别ID，叫做<code>serialVersionUID</code>，根据类的结构消息计算所得。当对象被接序列化时，如果对象被序列化之后有了不同的<code>serialVersionUID</code>，还原操作会失败！</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/serialVersionUID.PNG" alt="serialVersionUID" /><figcaption aria-hidden="true">serialVersionUID</figcaption>
</figure>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--17 包、jar存档文件和部署</title>
    <url>/2021/05/19/JavaLearning_Head_First_Java_17_package_jars_and_deployment.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>该放手了。 <a id="more"></a></p>
</blockquote>
<h3 id="部署应用程序">1. 部署应用程序</h3>
<p>可以有多种部署选择：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/DeploymentOptions.PNG" alt="部署选择" /><figcaption aria-hidden="true">部署选择</figcaption>
</figure>
<p>首先需要将源代码与<code>class</code>文件分离，关键在于结合<code>-d</code>这个编译选项和目录组织的结构。</p>
<blockquote>
<p>将源代码(<code>.java</code>)存储在<code>source</code>目录下，将编译输出的类文件(<code>.class</code>)放入<code>classes</code>目录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/<span class="built_in">source</span></span><br><span class="line">javac -d ../classes MyApp.java</span><br></pre></td></tr></table></figure>
<h4 id="把程序打包为jar">1.1 把程序打包为JAR</h4>
<p><code>JAR</code>即<code>Java ARchive</code>，这种文件是<code>pkzip</code>格式的文件，能把一组类文件包装起来。创建可执行的<code>JAR</code>分为以下步骤：</p>
<ol type="1">
<li><p>确定所有的类文件都在<code>classes</code>目录下；</p></li>
<li><p>创建<code>manifest.txt</code>文件描述哪个类带有<code>main()</code>方法，该文件带有下面一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Main-Class: MyApp</span><br></pre></td></tr></table></figure>
<p>此行后面要有换行，该文件放入<code>classes</code>目录</p></li>
<li><p>执行<code>jar</code>工具来创建带有<strong>所有类</strong>以及<code>manifest</code>的<code>JAR</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/classes </span><br><span class="line">jar -cvmf manifest.txt app1.jar *.class</span><br><span class="line">OR</span><br><span class="line">jar -cvmf manifest.txt app1.jar MyApp.class</span><br></pre></td></tr></table></figure></li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/makingJAR.PNG" alt="创建JAR" /><figcaption aria-hidden="true">创建JAR</figcaption>
</figure>
<p><code>JVM</code>能从<code>JAR</code>中载入类，并调用该类的<code>main()</code>方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar app1.jar</span><br></pre></td></tr></table></figure>
<p>可以用包防止类名称的冲突。<code>Sun</code>建议加上所取得的域名(<code>domain</code>)名称来保证包名称不会重复。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/domainPackageNames.PNG" alt="使用域名的包名称" /><figcaption aria-hidden="true">使用域名的包名称</figcaption>
</figure>
<p>需要把类放在与包层次结构相对应的目录结构下：</p>
<ol type="1">
<li><p>选择包名称。</p></li>
<li><p>在类中加入包指令。这必须是程序源码的第一个语句，在<code>import</code>之上。每个源文件中只能有一个包指令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.headfirstjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageExercise</span> </span>&#123;</span><br><span class="line">     <span class="comment">// life-altering code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设定相对应的目录结构。按照包层次结构来放置类文件</p></li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/packageHierarchy.PNG" alt="包层次结构" /><figcaption aria-hidden="true">包层次结构</figcaption>
</figure>
<ol start="4" type="1">
<li><p>编译和执行<code>JAR</code></p>
<ul>
<li><p>加上<code>-d</code>选项来编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/<span class="built_in">source</span></span><br><span class="line"></span><br><span class="line">%编译器把输出放到class目录下正确的位置</span><br><span class="line">javac -d ../classes com/headfirstjava/PackageExercise.java</span><br><span class="line"></span><br><span class="line">%编译com.headfirstjava包下所有.java文件</span><br><span class="line">javac -d ../classes com/headfirstjava/*.java</span><br></pre></td></tr></table></figure></li>
<li><p>执行程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> MyProject/classes</span><br><span class="line">java com.headfirstjava.PackageExercise</span><br></pre></td></tr></table></figure>
<p>一旦类被包进包中后，就不能使用“简写”名称来调用它，必须在命令栏指定要执行<code>main()</code>的类完整名称。</p></li>
</ul></li>
</ol>
<p>还可以条列和解压<code>JAR</code>包：</p>
<ul>
<li><p>将<code>JAR</code>内容列出，<code>-tf</code>代表<code>Table File</code>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jar -tf packEx.jar</span><br></pre></td></tr></table></figure></li>
<li><p>解压<code>JAR</code>内容，<code>-xf</code>代表<code>eXtract File</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd Skyler</span><br><span class="line">jar -xf packEx.jar</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="java-web-start">1.2 Java Web Start</h4>
<p><code>Java Web Start(JWS)</code>可以让用户从浏览器上执行首次启动，一旦程序下载后就可以独立于浏览器执行。</p>
<ul>
<li><code>JWS</code>下载程序时会调用程序的<code>main()</code>，然后用户可以通过<code>JWS helper app</code>启动应用程序而无需回到网页</li>
<li><code>JWS</code>能偶检测服务器上应用程序局部更新，自动下载和整合更新过的程序</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JWS.PNG" alt="Java Web Start工作方式" /><figcaption aria-hidden="true">Java Web Start工作方式</figcaption>
</figure>
<p><code>.jnlp</code>(<code>Java  Network Launch Protocol</code>)文件用于创建JWS应用程序，<code>JWS</code>会读取文件来寻找<code>JAR</code>并启动应用程序，<code>.jnlp</code>是个简单的<code>XML</code>文件。</p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--4 对象的行为</title>
    <url>/2021/05/12/JavaLearning_Head_First_Java_4_behavior_of_objects.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>状态影响行为，行为影响变量。 <a id="more"></a></p>
</blockquote>
<h3 id="对象参数">1. 对象参数</h3>
<h4 id="对象的状态与行为">1.1. 对象的状态与行为</h4>
<p>类是对象的蓝图。在编写类时，是在描述Java虚拟机应该如何制作该类型的对象。</p>
<blockquote>
<p>类所描述的是对象<code>知道什么与执行什么</code></p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/instance_and_method.PNG" alt="实例变量与方法" /><figcaption aria-hidden="true">实例变量与方法</figcaption>
</figure>
<p>同一个类型的对象能有不同的方法行为。每个实例有相同的方法，但方法可以根据实例变量的值变现不同行为。</p>
<h4 id="方法的参数">1.2. 方法的参数</h4>
<p>可以传值给方法。可以使用<code>实参(argument)</code>或<code>形参(parameter)</code>来调用传给方法的参数</p>
<blockquote>
<p>方法会运用形参，调用一方会传入实参</p>
<ul>
<li>实参是传给方法的值；</li>
<li>实参传入方法后就成为了形参；</li>
<li>参数跟局部变量一样。它也有类型和名称，可以在方法内运用</li>
</ul>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/argument_and_parameter.PNG" alt="实参与形参" /><figcaption aria-hidden="true">实参与形参</figcaption>
</figure>
<h4 id="返回值">1.3. 返回值</h4>
<p>方法可以有返回值，每个方法都需要声明返回的类型。</p>
<blockquote>
<p><code>void</code>表示没有返回任何东西。</p>
</blockquote>
<p>比如可以声明一个返回<code>int</code>类型值的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">giveSecret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果声明了方法有返回值，必须返回声明类型的值！</p>
<h4 id="多个参数">1.4. 多个参数</h4>
<p>方法可以有多个参数，声明和传入时都要以逗号分开。</p>
<blockquote>
<p>一定要以正确数量，类型和顺序来传递参数</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/multipe_argument.PNG" alt="多个参数" /><figcaption aria-hidden="true">多个参数</figcaption>
</figure>
<h4 id="参数传递">1.5. 参数传递</h4>
<p>Java通过值传递，或者通过拷贝传递参数。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/argument_pass.PNG" alt="参数传递" /><figcaption aria-hidden="true">参数传递</figcaption>
</figure>
<blockquote>
<p><strong>方法无法改变调用方所传入的参数。</strong></p>
</blockquote>
<h4 id="要点">1.6. 要点</h4>
<blockquote>
<ul>
<li>如果传入的参数是对象，那么<strong>实际上传入的是远程控制的拷贝</strong>。</li>
<li>方法只能声明单一返回值。如果需要返回多个返回值，可以使用数组。如需要返回混合不同类型值，可以使用<code>ArrayList</code></li>
</ul>
</blockquote>
<h3 id="封装encapsulation">2. 封装(Encapsulation)</h3>
<p>不封装可能会导致数据泄露。比如直接通过圆点运算符(<code>.</code>)来存取实例变量，可能会出现异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">theCat.height = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>需要创建<code>Setter</code>方法，使得在设置变量前可以进行检查。将程序实现从不良数据改成可以保护数据，且还能保持数据可修改，可以使用两个<code>存取修饰符(access modifier)</code>：公有修饰符<code>public</code>和私有修饰符<code>private</code>。封装的基本原则是：</p>
<blockquote>
<p>将实例变量标记为私有，提供公有的<code>getter</code>与<code>setter</code>方法来控制存取动作。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/advantage_of_setter.PNG" alt="封装的好处" /><figcaption aria-hidden="true">封装的好处</figcaption>
</figure>
<h3 id="初始化实例变量">3. 初始化实例变量</h3>
<p>声明变量是需要名称和类型，也可以同时初始化变量(为变量赋值)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">256</span>;</span><br></pre></td></tr></table></figure>
<p>如果未明确初始化实例变量，会为实例变量设置默认值。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/init_variable.PNG" alt="实例变量默认值" /><figcaption aria-hidden="true">实例变量默认值</figcaption>
</figure>
<blockquote>
<p>这么看，<code>String</code>变量内存储的也是一个对象引用。</p>
</blockquote>
<h3 id="实例变量与局部变量">4. 实例变量与局部变量</h3>
<p>实例变量与局部变量的区别：</p>
<blockquote>
<ul>
<li>实例变量声明在类内而不是方法中；而局部变量声明在方法中</li>
<li>局部变量使用前必须初始化，即<strong>局部变量没有默认值！</strong>如果在初始化前被调用，编译器会报错。</li>
</ul>
</blockquote>
<p>方法参数基本上与局部变量是相同的。</p>
<h3 id="变量的比较">5. 变量的比较</h3>
<h4 id="section">5.1 <code>==</code></h4>
<blockquote>
<p><code>==</code>用于比较两个变量的字节组合是否相等。</p>
</blockquote>
<p>可以使用<code>==</code>来比较两个<code>primitive</code>主数据类型是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123; <span class="comment">// true &#125;</span></span><br></pre></td></tr></table></figure>
<p>也可以用<code>==</code>来判断两个引用是否指向同一对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo a = <span class="keyword">new</span> Foo();</span><br><span class="line">Foo b = <span class="keyword">new</span> Foo();</span><br><span class="line">Foo c = a;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123; <span class="comment">// false &#125;</span></span><br><span class="line"><span class="keyword">if</span> (a == c) &#123; <span class="comment">// true &#125;</span></span><br><span class="line"><span class="keyword">if</span> (b == c) &#123; <span class="comment">// false &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="equals">5.2 <code>equals()</code></h4>
<p>使用<code>equals()</code>方法来判断两个对象是否在含义上相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1,s2,s3 = <span class="string">"abc"</span>, s4 =<span class="string">"abc"</span> ;</span><br><span class="line">s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">s1==s2   是 <span class="keyword">false</span>      <span class="comment">//两个变量的内存地址不一样，也就是说它们指向的对象不一样，</span></span><br><span class="line"></span><br><span class="line">s1.equals(s2) 是 <span class="keyword">true</span>    <span class="comment">//两个变量的所包含的内容是abc，故相等。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--2 类与对象</title>
    <url>/2021/04/27/JavaLearning_Head_First_Java_2_class_and_objects.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>有人告诉我那里遍地都是对象！ <a id="more"></a></p>
</blockquote>
<h3 id="椅子大战阿花的对象">1. 椅子大战——阿花的"对象"</h3>
<p>面向对象信徒阿花利用面向对象的思想赢得了椅子大战(但最后赢家是阿娇——老板娘的侄女，作者调皮了)。</p>
<h4 id="类与继承inheritance">类与继承(inheritance)</h4>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_inheritance.PNG" alt="继承(inheritance)" /><figcaption aria-hidden="true">继承(inheritance)</figcaption>
</figure>
<h4 id="覆盖override">覆盖(override)</h4>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_override.PNG" alt="覆盖(override)" /><figcaption aria-hidden="true">覆盖(override)</figcaption>
</figure>
<h3 id="对象">2. 对象</h3>
<blockquote>
<p><code>对象</code>是依靠类的模型塑造出来的，对象也可以叫做<code>实例</code>。可以把对象分为两部分看：</p>
<ul>
<li>对象是已知的事物
<ul>
<li><code>实例变量</code>(instance variable)。对象本身已知的事物，代表对象的状态(数据)，且该类型的每一个对象都会独立地拥有一份该类型的值。</li>
</ul></li>
<li>对象会执行的当作
<ul>
<li><code>方法</code>(methods)。对象可以执行的动作，读取或操作实例变量。</li>
</ul></li>
</ul>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_override.PNG" alt="Java对象" /><figcaption aria-hidden="true">Java对象</figcaption>
</figure>
<h4 id="类与对象的区别">类与对象的区别</h4>
<blockquote>
<p>”<em>类不是对象，却是用来创建对象的模型</em>'"。类是对象的<strong>蓝图</strong>，告诉虚拟机如何创建某种类型的对象。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_object_relation.PNG" alt="类与对象" /><figcaption aria-hidden="true">类与对象</figcaption>
</figure>
<h4 id="创建对象">创建对象</h4>
<p>创建对象后，使用<code>圆点(.)</code>符号所代表的操作数来<em>存取该对象的变量和方法</em>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/class_create_object.PNG" alt="创建对象" /><figcaption aria-hidden="true">创建对象</figcaption>
</figure>
<h4 id="逃出main">逃出main()</h4>
<blockquote>
<p><code>main()</code>的两种用途</p>
<ul>
<li>测试真正的类</li>
<li>启动JAVA应用程序</li>
</ul>
</blockquote>
<p>Java程序普遍只会让对象与对象交互，即相互调研方法。猜数字游戏示例：</p>
<blockquote>
<p><strong>摘要：</strong></p>
<p>涉及到<code>game</code>和<code>player</code>两个对象，<code>game</code>会产生介于0~9之间的随机数，3个<code>player</code>对象会猜测该数字。</p>
<p><strong>类：</strong></p>
<ul>
<li>GuessGame.class</li>
<li>Player.class</li>
<li>GameLauncher.class</li>
</ul>
<p><strong>程序逻辑：</strong></p>
<ol type="1">
<li><code>GameLauncher</code>类带有<code>main()</code>方法，是应用程序<strong>入口点</strong>；</li>
<li><code>main()</code>中会创建<code>GuessGame</code>对象，并调用它的<code>startGame()</code>方法；</li>
<li><code>startGame()</code>方法是游戏的起点。它会创建3个player，然后挑出要猜测的随机数字。它会要求player猜测并检查结果，列出过程。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.schoolLearning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        number = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"I'm guessing "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    Player p1;</span><br><span class="line">    Player p2;</span><br><span class="line">    Player p3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        p1 = <span class="keyword">new</span> Player();</span><br><span class="line">        p2 = <span class="keyword">new</span> Player();</span><br><span class="line">        p3 = <span class="keyword">new</span> Player();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> guessp1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> guessp2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> guessp3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> p1isRight = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> p2isRight = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> p3isRight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetNumber = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"I'm thinking of a number between 0 and 9..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Number to guess is "</span> + targetNumber);</span><br><span class="line"></span><br><span class="line">            p1.guess();</span><br><span class="line">            p2.guess();</span><br><span class="line">            p3.guess();</span><br><span class="line"></span><br><span class="line">            guessp1 = p1.number;</span><br><span class="line">            System.out.println(<span class="string">"Player one guessed "</span> + guessp1);</span><br><span class="line">            guessp2 = p2.number;</span><br><span class="line">            System.out.println(<span class="string">"Player two guessed "</span> + guessp2);</span><br><span class="line">            guessp3 = p3.number;</span><br><span class="line">            System.out.println(<span class="string">"Player three guessed "</span> + guessp3);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (guessp1 == targetNumber) &#123;</span><br><span class="line">                p1isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp2 == targetNumber) &#123;</span><br><span class="line">                p2isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp3 == targetNumber) &#123;</span><br><span class="line">                p3isRight = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p1isRight || p2isRight || p3isRight) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"We have a winner!"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Player one got it right? "</span> + p1isRight);</span><br><span class="line">                System.out.println(<span class="string">"Player two got it right? "</span> + p2isRight);</span><br><span class="line">                System.out.println(<span class="string">"Player three got it right? "</span> + p3isRight);</span><br><span class="line">                System.out.println(<span class="string">"Game is over."</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Players will have to try again."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameLauncher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GuessGame game = <span class="keyword">new</span> GuessGame();</span><br><span class="line">        game.startGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tips">Tips</h3>
<ol type="1">
<li><p>在创建类时，<code>.java</code>文件内只能有一个<code>public</code>声明的类，且类名需要与文件名一致，一般设定为包含<code>main()</code>函数的类。更规范的写法是为不同的类分别创建<code>.java</code>文件，维护各自的代码，通过文件之间的调用(<code>import</code>)实现交互。</p></li>
<li><p>Java垃圾回收。</p>
<p>创建对象时，不管对象如何创建的，它都会被存放于称为<code>堆</code>的内存区域，在Java中是<code>可回收垃圾的堆(Garbage-Collectible Heap)</code>。Java会根据对象的大小来分配内存空间，当Java虚拟机察觉到对象不再会被使用到时，该对象会被标记为可回收的。如果内存不足，垃圾收集器就会启动来清理垃圾、回收空间。</p></li>
<li><p>包装多个类成为单一应用程序形式。</p>
<p>可以把所有文件包装进依据<code>pkzip</code>格式来存档的<code>Java Archive-.jar文件</code>。在该<code>jar</code>文件中可以引入一个简单文字格式的文字文件，被称为<code>manifest</code>，里面有定义出<code>jar</code>中的哪一个文件带有启动应用程序的<code>main()</code>方法。</p></li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--9 构造器与垃圾收集器</title>
    <url>/2021/05/13/JavaLearning_Head_First_Java_9_constructors_and_garbage_collection.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>对象有生死。 <a id="more"></a></p>
</blockquote>
<h3 id="栈与堆">1. 栈与堆</h3>
<p><code>Java</code>中主要在意两种内存区域：对象的生存空间<code>堆(heap)</code>与方法调用及变量的生存空间<code>栈(stack)</code>。<code>Java</code>虚拟机启动时，会从底层操作系统取得一块内存，用于执行Java程序。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/stackHeap.PNG" alt="栈与堆" /><figcaption aria-hidden="true">栈与堆</figcaption>
</figure>
<p>几乎所有对象都存活于可垃圾回收的堆上，而变量根据它的类型判断存在于那一个内存区域。实例变量存在于堆中，而局部变量(也叫区域变量)存在于栈上，所以也叫栈变量。</p>
<blockquote>
<ul>
<li><code>实例变量</code>被声明在类中方法之外，代表每个独理对象的“字段”，存在于所属对象中。</li>
<li><code>局部变量</code>和<code>方法</code>被声明在方法中，是<code>暂时</code>的，生命周期只限于方法被放置于栈上这段时间(即方法调用到执行完毕)</li>
</ul>
</blockquote>
<h4 id="局部变量">1.1 局部变量</h4>
<p>调用一个方法时，该方法会放在调用栈的栈顶。实际上放到栈顶的时<code>栈帧(stack frame)</code>，带有方法的状态，程序计数器及所有的局部变量值。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/twoMthodsStack.PNG" alt="放了两个方法的栈" /><figcaption aria-hidden="true">放了两个方法的栈</figcaption>
</figure>
<p>比如<code>foo()</code>调用了<code>bar()</code>，则<code>bar()</code>方法会放置在<code>foo()</code>上面。</p>
<h4 id="对象局部变量">1.2 对象局部变量</h4>
<p>非<code>primitive</code>的变量只是保存对象的引用，对象放于堆上，而局部变量本身放于栈上。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/objectLocalVariable.PNG" alt="对象局部变量" /><figcaption aria-hidden="true">对象局部变量</figcaption>
</figure>
<h4 id="实例变量">1.3 实例变量</h4>
<p>实例变量存在于对象所属的堆空间上。</p>
<ul>
<li>如果实例变量全是<code>primitive</code>主数据类型，<code>Java</code>会根据其类型的大小为该实例变量留下空间</li>
<li>如果实例变量是一个对象，会留下对象引用所用到的空间，而不是对象本身。</li>
</ul>
<h3 id="构造函数">2. 构造函数</h3>
<h4 id="创建对象">2.1 创建对象</h4>
<p>声明对象和赋值的3个步骤：<code>声明引用变量</code>、<code>创建对象</code>、<code>连接对象和引用</code>。第二步<code>创建对象</code>看起来好像在调用类名的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duck myDuck = <span class="keyword">new</span> Duck();</span><br></pre></td></tr></table></figure>
<p>实际上调用的是<code>Duck</code>的构造函数。</p>
<blockquote>
<p>构造函数并不是方法，它带有<code>new</code>的时候会执行的程序代码，在初始化对象时执行。调用构造函数唯一的方法是通过<code>new</code>新建一个类对象。</p>
</blockquote>
<p>未写构造函数时，编译器会有一个默认构造函数。下面是一个默认构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>构造函数没有返回类型，名字必须与类名相同。</p></li>
<li><p>可以有与类同名的方法而不会变成构造函数。</p></li>
<li><p>构造函数不会被继承。</p></li>
</ul>
</blockquote>
<p>构造函数的一个关键特征是，在对象与引用连接前就执行，可以对对象进行预处理。大部分人使用构造函数来初始化对象的状态，也就是给对象的实例变量赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> size;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">(<span class="keyword">int</span> duckSize)</span> </span>&#123; <span class="comment">// 构造函数加上参数</span></span><br><span class="line">     	System.out.println(“Quack”);</span><br><span class="line">    	size = duckSize;</span><br><span class="line">     	System.out.println(“size is “ + size);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseADuck</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Duck d = <span class="keyword">new</span> Duck(<span class="number">42</span>); <span class="comment">// 传值初始化类对象</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最好要有不需要参数的构造函数，来对应参数无法确定的默认情况。</p>
</blockquote>
<p>只有在完全没定义构造函数时，编译器才会帮忙编写默认构造函数。如果已经写了一个有参数的构造函数，编译器并不会增加无参数的构造函数，需要<code>手动编写</code>。</p>
<blockquote>
<p>构造函数可以是<code>公有</code>、<code>私有</code>或<code>不指定</code>的。</p>
</blockquote>
<h4 id="父类及继承与构造函数的关系">2.2 父类及继承与构造函数的关系</h4>
<p>在创建新对象时，所有继承下来的构造函数都会执行。即每个父类的构造函数都会在子类对象创建时期执行。</p>
<blockquote>
<p>抽象类也有构造函数，只是无法对其执行<code>new</code>操作，他的构造函数会在子类创建实例时执行。</p>
</blockquote>
<p>如果<code>Hippo</code>对象继承<code>Animal</code>，<code>Animal</code>继承了<code>Object</code>，那么创建对象的过程被称为一个<code>"构造函数链(Constructor Chaining)"</code>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/ConstructorChaining.PNG" alt="Hippo类构造函数调用" /><figcaption aria-hidden="true">Hippo类构造函数调用</figcaption>
</figure>
<blockquote>
<p>调用父类构造函数唯一的方法时调用<code>super()</code>。</p>
</blockquote>
<p>如果没有显式调用<code>super()</code>，编译器会自动加上<code>super()</code>的调用。且编译器自动加入的一定是<strong>没有参数的构造函数</strong>。</p>
<blockquote>
<p><code>super()</code>的调用必须是构造函数的第一个语句</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boop</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>();</span><br><span class="line">     size = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过要求父类的构造函数必须有名字，可以使得子类可以继承父类的<code>get</code>方法来访问私有的实例变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String theName)</span> </span>&#123;</span><br><span class="line">        name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hippo</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hippo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeHippo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hippo h = <span class="keyword">new</span> Hippo(<span class="string">"Buffy"</span>);</span><br><span class="line">        System.out.println(h.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类没有无参构造函数时，子类必须显式调用父类的构造函数，不然编译无法通过。</p>
<p>也可以在同一个类中调用另外的构造函数。比如多个构造函数有相同的工作部分，可以把这部分代码放在一个构造函数中，然后由其他构造函数调用。</p>
<blockquote>
<p>使用<code>this()</code>来从某个构造函数调用同一个类的另外一个构造函数。</p>
<p><code>this()</code>只能在构造函数中，且也必须时第一行语句。所以<code>super()</code>和<code>this()</code>不能在一个构造函数中同时调用。</p>
</blockquote>
<h4 id="垃圾收集器">3 垃圾收集器</h4>
<h4 id="对象的生命周期">3.1 对象的生命周期</h4>
<p>对象的生命周期取决于引用到它的"引用"，引用变量的声明周期又看它是局部变量还是实例变量。</p>
<blockquote>
<ul>
<li>局部变量只会存活在声明该变量的方法中</li>
<li>实例变量的寿命与对象相同。</li>
</ul>
</blockquote>
<p><strong>"life"与"scope"的差别</strong></p>
<ul>
<li><strong>life</strong>。只要变量的堆栈块还存在于堆栈上，局部变量就算存活。</li>
<li><strong>scope</strong>。局部变量的范围只限于声明它的方法之内。当此方法调用其他方法时，该变量依旧存活，但不在目前执行范围内。</li>
</ul>
<p>如果对象的唯一引用解散，那么对象就会从堆中被抛弃，变成可回收的。</p>
<blockquote>
<p>若没有引用指向该对象，对象无法被获取，<code>垃圾收集器(GC)</code>会自动回收内存空间。</p>
</blockquote>
<p>有三种方法可以释放对象的引用：</p>
<ol type="1">
<li><p>引用永久性的离开它的范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Life z = <span class="keyword">new</span> Life();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>引用被赋值到其他对象上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Life z = <span class="keyword">new</span> Life();</span><br><span class="line">z = <span class="keyword">new</span> Life();</span><br></pre></td></tr></table></figure></li>
<li><p>直接将引用设定为<code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Life z = <span class="keyword">new</span> Life();</span><br><span class="line">z = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--1 基础概念</title>
    <url>/2021/01/09/JavaLearning_Head_First_Java_1_basic_concepts.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>重新开始学习Java，同时为找工作开始做准备，加油。从《Head First Java》开始吧！ <a id="more"></a></p>
</blockquote>
<h3 id="java的工作方式">1. Java的工作方式</h3>
<p>基于Java写出应用程序并在任意设备上运行主要分为4步： &gt; 1. 源代码。编写源码文件 &gt; 2. 编译器。用编译器运行源代码，检查错误 &gt; 3. 输出。编译器对源码编译输出字节文件，编译后的<code>字节文件与平台无关</code> &gt; 4. Java虚拟机。Java虚拟机可以读取及执行字节文件</p>
<h3 id="java的程序结构">2. Java的程序结构</h3>
<p>类存在于源文件里，方法存在于类中，语句存在于方法中。 <img src="https://github.com/wwwwwyj/image_repository/blob/master/img/blog/JavaLearning/HeadFirstJava/JavaProgramStructure.PNG?raw=true" alt="Java程序结构" /></p>
<h4 id="源文件">源文件</h4>
<p>源文件(<code>.java</code>)带有类定义，类用于表示程序的一个组件。</p>
<h4 id="类">类</h4>
<p>类带有一个或多个方法。 <img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/JavaClassStructure.PNG" alt="Java类的结构" /></p>
<h4 id="方法">方法</h4>
<p>在方法中包含需要执行的指令，方法由一组语句组成，可以当作一个函数或过程。</p>
<h4 id="tips"><code>Tips</code></h4>
<h5 id="java中integer与boolean不兼容">Java中integer与boolean不兼容</h5>
<p>Java中integer与boolean不兼容，所以int类型不能用作条件，如： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Java中执行会报错，需要将其修改为boolean类型变量来实现相同功能： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isHot = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (isHot) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Java并发编程的艺术]--1 并发编程的挑战</title>
    <url>/2021/07/12/JavaLearning_The_art_of_concurrent_programming_in_Java-1-Challenges-of-concurrent-programming.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>并发编程的目的是为了让程序运行得更快。在进行并发编程时，如果希望通过多线程执行任务让程序运行得更快，会 面临非常多的挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题</code> <a id="more"></a></p>
</blockquote>
<h3 id="上下文切换">1. 上下文切换</h3>
<p>CPU通过<u>给每个线程分配CPU时间片来实现多线程</u>。<strong>时间片</strong>是<code>CPU</code>分配给各个线程的时间，一般是几十毫秒（ms）。<code>CPU</code>通过时间片分配算法来循环执行任务，在切换任务前会保存上一个任务的状态，以便下次切换回来时可以再加载这个任务的状态。所以<u>任务从保存到再加载的过程</u>就是一次<strong>上下文切换（CS，<code>Content Switch</code>）</strong>。</p>
<h4 id="多线程的效率">1.1 多线程的效率</h4>
<p>并发执行并不一定比串行执行快，比如下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Concurrency.Chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> count = <span class="number">1000000l</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        concurrency();</span><br><span class="line">        serial();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concurrency</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    a += <span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">"concurrency :"</span> + time+<span class="string">"ms,b="</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            a += <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">"serial:"</span> + time+<span class="string">"ms,b="</span>+b+<span class="string">",a="</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当并发执行累加操作<strong>不超过百万次</strong>时，速度会比串行执行累加操作要慢。因为<code>线程有创建和上下文切换的开销</code>。</p>
<h4 id="上下文切换次数和时长">1.2 上下文切换次数和时长</h4>
<p>可以度量上下文切换带来的消耗的工具：</p>
<ul>
<li><code>Lmbench3</code>：可以测量上下文切换的<strong>时长</strong>。</li>
<li><code>vmstat</code>：可以测量上下文切换的<strong>次数</strong>。</li>
</ul>
<h4 id="减少上下文切换">1.3 减少上下文切换</h4>
<p>减少上下文切换的方法有<code>无锁并发编程</code>、<code>CAS算法</code>、使用<code>最少线程</code>和使用<code>协程</code>。</p>
<ul>
<li><code>无锁并发编程</code>。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一 些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li>
<li><code>CAS算法</code>。Java的<code>Atomic</code>包使用<code>CAS算法</code>来更新数据，而不需要加锁。</li>
<li>使用<code>最少线程</code>。避免创建不需要的线程，创建过多线程会造成大量线程都处于等待状态。</li>
<li><code>协程</code>。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li>
</ul>
<h3 id="死锁">2. 死锁</h3>
<p>一旦产生死锁，就会造成系统功能不可用。如下代码会引发死锁，使线程<code>t1</code>和线程<code>t2</code>互相等待对方释放锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Concurrency.Chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String A = <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String B = <span class="string">"B"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DeadLockDemo().deadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>避免死锁的几个常见方法。</p>
<ul>
<li>避免一个线程同时获取多个锁。</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用<code>lock.tryLock(timeout)</code>来替代使用内部锁机制。</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
</ul>
<h3 id="资源限制的挑战">3. 资源限制的挑战</h3>
<h4 id="资源限制">3.1 资源限制</h4>
<p>资源限制是指在进行并发编程时，<u>程序的执行速度受限于计算机硬件资源或软件资源</u>。</p>
<ul>
<li>硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。</li>
<li>软件资源限制有数据库的连接数和socket连接数等。</li>
</ul>
<h4 id="资源限制引发的问题">3.2 资源限制引发的问题</h4>
<p>如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为<code>增加了上下文切换和资源调度的时间</code>。</p>
<h4 id="何解决资源限制的问题">3.3 何解决资源限制的问题</h4>
<ul>
<li>对于硬件资源限制，可以考虑<strong>使用集群</strong>并行执行程序。</li>
<li>对于软件资源限制，可以考虑<strong>使用资源池</strong>将资源复用。</li>
</ul>
<h4 id="资源限制情况下并发编程">3.4 资源限制情况下并发编程</h4>
<p>根据不同的资源限制调整程序的并发度。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--5 超强力方法</title>
    <url>/2021/05/12/JavaLearning_Head_First_Java_5_Extra-Strength_Methods.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>让方法产生更大的作用。创建一个类似战舰的游戏：攻击达康 <a id="more"></a></p>
</blockquote>
<h3 id="创建一个类似战舰的游戏攻击达康">1. 创建一个类似战舰的游戏：攻击达康</h3>
<h4 id="简介">1.1. 简介</h4>
<p>一种棋盘类的战舰游戏，目标是猜测对方战舰的坐标，然后轮流开炮攻击，命中数发可以击沉对方战舰。</p>
<ul>
<li><strong>游戏目标</strong>：以最少的猜测次数打掉计算机安排的<code>达康公司(Dot Com)</code>网站。计算机根据表现来评分。</li>
<li><strong>初始设置</strong>：程序启动后，计算机会在虚拟的<code>7×7</code>方格上安排3个达康网站。然后开始要求猜坐标。</li>
<li><strong>进行游戏</strong>：目前先在命令栏上进行游戏。计算机根据输入所猜测的位置(比如<code>A3</code>或<code>C5</code>)等，返回命中<code>Hit</code>，未命中<code>Miss</code>或击沉<code>Sunk</code>等回应。清关所有网站后，会列出分数并结束。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/sunk_site.PNG" alt="攻击达康棋盘" /><figcaption aria-hidden="true">攻击达康棋盘</figcaption>
</figure>
<h4 id="顶层设计">1.2 顶层设计</h4>
<p>首先，了解游戏流程。基本思路：</p>
<ol type="1">
<li>玩家启动游戏</li>
</ol>
<blockquote>
<p>A. 计算机创建3个网站 B. 将3个网站停在虚拟战场(棋盘)上</p>
</blockquote>
<ol start="2" type="1">
<li>游戏开始</li>
</ol>
<blockquote>
<p>重复以下操作直到所有网站被歼灭 A. 提示玩家输入坐标 B. 检查是否命中、未命中或击沉。命中删除格子，击沉删除网站。</p>
</blockquote>
<ol start="3" type="1">
<li>游戏结束</li>
</ol>
<blockquote>
<p>根据猜测次数给分。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/flow_of_sunk_dotcom.PNG" alt="游戏流程图" /><figcaption aria-hidden="true">游戏流程图</figcaption>
</figure>
<h4 id="简单的开始">1.3 简单的开始</h4>
<p>至少需要两个类：<code>Game</code>类和<code>DotCom</code>类。首先从一个简单版本开始。</p>
<blockquote>
<p>只使用一个横列作为棋盘(即一维数组)，并只设定一家达康公司。游戏目标依旧相同。</p>
</blockquote>
<p>要注意虚拟的横列是虚幻的，即并没有真正在程序中声明一个一维数组。只需要玩家和计算机直到有3个连续格子会出现在7格的横列中。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simple_sunk_site.PNG" alt="简单版游戏" /><figcaption aria-hidden="true">简单版游戏</figcaption>
</figure>
<h3 id="开发类">2 开发类</h3>
<p>在创建Java程序时，主要依照以下过程：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/process_of_create_javaapp.PNG" alt="Java程序开发基本流程" /><figcaption aria-hidden="true">Java程序开发基本流程</figcaption>
</figure>
<blockquote>
<p>最后一条是认真的吗</p>
</blockquote>
<p>我们会为每个类写出：<code>伪码(prep code)</code>、<code>测试码(test code)</code>和<code>真实码(real code)</code></p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/prepTestReal.PNG" alt="伪码、测试码和真实码" /><figcaption aria-hidden="true"><code>伪码</code>、<code>测试码</code>和<code>真实码</code></figcaption>
</figure>
<blockquote>
<p><strong>伪码</strong>：帮助我们专注于逻辑而无需考虑程序语法</p>
<p><strong>测试码</strong>：测试用的程序代码</p>
<p><strong>真实码</strong>：实际设计出的真正Java程序代码</p>
</blockquote>
<h4 id="simpledotcom类">2.1 <code>SimpleDotCom</code>类</h4>
<h5 id="伪码">伪码</h5>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComPrep.PNG" alt="SimpleDotCom类伪码" /><figcaption aria-hidden="true"><code>SimpleDotCom</code>类伪码</figcaption>
</figure>
<p>伪码介于Java程序和正常英语之间，大致包括3个部分：实例变量的声明、方法的声明和方法的逻辑。</p>
<blockquote>
<p>伪码最重要的部分是<strong>方法的逻辑</strong>。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComPrepCode.PNG" alt="SimpleDotCom类伪码" /><figcaption aria-hidden="true"><code>SimpleDotCom</code>类伪码</figcaption>
</figure>
<h5 id="测试码">测试码</h5>
<p>编写方法的实现部分，实现可用的方法程序代码。先编写测试用代码的概念来自于<code>极限编程(Extreme Programming, XP)</code>方法论，可以使我们更快更任意写出程序代码。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/Extreme_Programming.PNG" alt="极限编程" /><figcaption aria-hidden="true">极限编程</figcaption>
</figure>
<p>首先实现<code>SimpleDotCom</code>类中的方法，先实现<code>checkYourself()</code>这个方法。（至于<code>setLocationCells()</code>这个方法，可以很容易直到它是个<code>setter</code>方法）。首先要知道<code>checkYourself()</code>方法应该要测试的部分：</p>
<blockquote>
<ol type="1">
<li><code>SimpleDotCom</code>对象的初始化；</li>
<li>赋值位置(即一个<code>int</code>数组)；</li>
<li>创建代表玩家猜测的字符串；</li>
<li>传入伪造的玩家猜测来调用<code>checkYourself()</code>方法；</li>
<li>列出结果观察结果是否正确。</li>
</ol>
</blockquote>
<p><code>SimpleDotCom</code>测试码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotComDrive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleDotCom dot = <span class="keyword">new</span> SimpleDotCom(); <span class="comment">// 初始化SimpleDotCom对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] locations = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// 创建 dot com 位置数组</span></span><br><span class="line">        dot.setLocationCells(locations); <span class="comment">// 调用 dot com 的 setter</span></span><br><span class="line"></span><br><span class="line">        String userGuess = <span class="string">"2"</span>; <span class="comment">// 假的猜测</span></span><br><span class="line">        String result = dot.checkYourself(userGuess); <span class="comment">// 调用被测试的方法, 传入假数据</span></span><br><span class="line">        String testResult = <span class="string">"failed"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.equals(<span class="string">"hit"</span>)) &#123;</span><br><span class="line">            testResult = <span class="string">"passed"</span>; <span class="comment">// 测试返回 "hit" 才算成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.println(testResult); <span class="comment">// 输出测试结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思索与编写测试用的程序代码能够帮助我们了解被测试的应用程序应该要做哪些事情。当实作代码完成时，也可以有准备好地测试代码进行验证。</p>
<p>理想上，先写出一点测试码，然后编写能够通过该测试的方法。之后再编写测试码，编写新的实现使其通过测试。如此循环，就可以证明新加入代码不会破坏原有已经测试过的部分。</p>
</blockquote>
<h5 id="真实码">真实码</h5>
<p>从伪码到真正的Java程序代码之间，不会完美对应，需要有一些调整。下面使<code>checkYourself()</code>方法的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotCom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] locationCells;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfHIts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLocationCells</span> <span class="params">(<span class="keyword">int</span>[] locations)</span> </span>&#123;</span><br><span class="line">        locationCells = locations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkYourself</span><span class="params">(String userGuess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> guess = Integer.parseInt(userGuess); <span class="comment">// 字符串转int</span></span><br><span class="line">        String result = <span class="string">"miss"</span>; <span class="comment">// 创建保存返回结果的变量, 以miss作为默认值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cell: locationCells) &#123; <span class="comment">// 对每个格子重复执行</span></span><br><span class="line">            <span class="keyword">if</span> (guess == cell) &#123; <span class="comment">// 比较格子与猜测值</span></span><br><span class="line">                result = <span class="string">"hit"</span>; <span class="comment">// 命中</span></span><br><span class="line">                numOfHIts++;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 离开循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numOfHIts == locationCells.length) &#123; <span class="comment">// 判断是否击沉</span></span><br><span class="line">            result = <span class="string">"kill"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result); <span class="comment">// 显式结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="simpledotcomgame类">2.2 <code>SimpleDotComGame</code>类</h4>
<h5 id="伪码-1">伪码</h5>
<p><code>SimpleDotComGame</code>类伪码如下：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/simpleDotComGamePrepCode.PNG" alt="SimpleDotComGame类伪码" /><figcaption aria-hidden="true"><code>SimpleDotComGame</code>类伪码</figcaption>
</figure>
<p><code>SimpleDotComGame</code>类需要有以下功能：</p>
<blockquote>
<ol type="1">
<li>创建出<code>SimpleDotCom</code>对象</li>
<li>初始化赋值该对象</li>
<li>要求玩家开始猜测</li>
<li>检查猜测值</li>
<li>重复猜测直到击沉为止</li>
<li>显示玩家猜测次数</li>
</ol>
</blockquote>
<h5 id="真实码-1">真实码</h5>
<p>这里跳过了这个类的测试程序，因为次游戏测试程序只有一个<code>main</code>方法。其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDotComGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfGuesses = <span class="number">0</span>; <span class="comment">// 记录玩家猜测次数</span></span><br><span class="line">        GameHelper helper = <span class="keyword">new</span> GameHelper(); <span class="comment">// 使用该类来获取玩家输入</span></span><br><span class="line"></span><br><span class="line">        SimpleDotCom theDotCom = <span class="keyword">new</span> SimpleDotCom();</span><br><span class="line">        <span class="keyword">int</span> randomNum = (<span class="keyword">int</span>) (Math.random() * <span class="number">5</span>); <span class="comment">// 随机数用作第一格的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] locations = &#123;randomNum, randomNum+<span class="number">1</span>, randomNum+<span class="number">2</span>&#125;;</span><br><span class="line">        theDotCom.setLocationCells(locations);</span><br><span class="line">        <span class="keyword">boolean</span> isAlive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(isAlive) &#123;</span><br><span class="line">            String guess = helper.getUserInput(<span class="string">"enter a guess number"</span>);</span><br><span class="line">            String result = theDotCom.checkYourself(guess);</span><br><span class="line">            numOfGuesses++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">"kill"</span>)) &#123;</span><br><span class="line">                isAlive = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(<span class="string">"You took "</span> + numOfGuesses + <span class="string">" guesses!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有一个带有<code>getUserInput</code>方法的类<code>GameHelper</code>。它可以从命令行获取输入，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInput</span><span class="params">(String prompt)</span> </span>&#123;</span><br><span class="line">        String inputLine = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(prompt + <span class="string">"  "</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader is = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in)</span><br><span class="line">            );</span><br><span class="line">            inputLine = is.readLine();</span><br><span class="line">            <span class="keyword">if</span> (inputLine.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"IOException: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inputLine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="要点">2.3 要点</h4>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/keyPointOfChapter5.PNG" alt="要点" /><figcaption aria-hidden="true">要点</figcaption>
</figure>
<h3 id="关于for循环">3. 关于<code>for</code>循环</h3>
<h4 id="基本的for循环">3.1 基本的<code>for</code>循环</h4>
<p>一个基本的<code>for</code>循环如下：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/regularForLoops.PNG" alt="基本的for循环" /><figcaption aria-hidden="true">基本的<code>for</code>循环</figcaption>
</figure>
<p>即重复执行代码100次，编译器解释为:</p>
<blockquote>
<ol type="1">
<li>创建变量<code>i</code>并赋值为<code>0</code>；</li>
<li>只要<code>i</code>小于<code>100</code>就重复执行；</li>
<li>每次重复过程最后把<code>i</code>加<code>1</code>。</li>
</ol>
</blockquote>
<p>主要分为三个部分：</p>
<h5 id="第一部分初始化initialization">第一部分：初始化(initialization)</h5>
<p>声明和初始化在循环体内的变量，通常将该变量作为<code>计数器</code>。</p>
<h5 id="第二部分boolean测试boolean-test">第二部分：boolean测试(boolean test)</h5>
<p>测试条件计算出一个<code>boolean</code>值。可以使boolean表达式，或返回boolean值的方法。</p>
<h5 id="第三部分重复表达式-iteration-expression">第三部分：重复表达式( iteration expression)</h5>
<p>安置每趟循环完成后要执行的项目。</p>
<blockquote>
<p><code>whlie</code>循环与<code>for</code>循环的区别是，<code>while</code>循环只有<code>boolean</code>测试，它并没有内建的初始化或重复表达式。</p>
<ul>
<li><code>while</code>适合在不清楚循环次数的循环上；</li>
<li><code>for</code>相对来说更容易阅读。</li>
</ul>
</blockquote>
<p>此外，这里可以说明一下前置与后置的递增/递减操作符：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/IncrementDecrementOperator.PNG" alt="基本的for循环" /><figcaption aria-hidden="true">基本的<code>for</code>循环</figcaption>
</figure>
<h4 id="加强版的for循环">3.2 加强版的<code>for</code>循环</h4>
<p>从<code>Java 5.0</code>开始，有加强版的<code>for</code>循环，可以逐个运行数组或其他集合的元素。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/enhancedforloop.PNG" alt="加强版的for循环" /><figcaption aria-hidden="true">加强版的<code>for</code>循环</figcaption>
</figure>
<p>即对<code>nameArray</code>中每个元素执行一次，编译器解释为:</p>
<blockquote>
<ol type="1">
<li>创建名称为<code>name</code>的<code>String</code>变量；</li>
<li>将<code>nameArray</code>的第一个元素赋值给<code>name</code>；</li>
<li>执行重复内容；</li>
<li>赋值给下一个元素<code>name</code>；</li>
<li>重复执行直到所有元素都被运行为止。</li>
</ol>
</blockquote>
<p>主要分为两个部分：</p>
<h5 id="第一部分声明循环变量iteration-variable-declaration">第一部分：声明循环变量(iteration variable declaration)</h5>
<p>声明和初始化用在循环体内的变量，循环过程中该变量的值会不断变化。此变量的类型需要与数组元素类型匹配。</p>
<h5 id="第二部分要运行的集合the-actual-collection">第二部分：要运行的集合(the actual collection)</h5>
<p>必须是对数组或其他集合的引用。</p>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Java并发编程的艺术]--2 Java并发机制的底层实现原理</title>
    <url>/2021/07/13/JavaLearning_The_art_of_concurrent_programming_in_Java-2-The-underlying-implementation-principle.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>Java中所使用的并发机制依赖于JVM的实现和CPU的指令</code> <a id="more"></a></p>
</blockquote>
<h3 id="volatile的应用">1. <code>volatile</code>的应用</h3>
<p><code>volatile</code>是<strong>轻量级</strong>的<code>synchronized</code>，它在多处理器开发中保证了共享变量的<code>“可见性”</code>。</p>
<blockquote>
<p><code>可见性</code>是<u>当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值</u>。</p>
</blockquote>
<h4 id="volatile的定义与实现原理">1.1 <code>volatile</code>的定义与实现原理</h4>
<p>Java编程语言允许线程访问共享变量，为了确保共享变量能被<code>准确</code>和<code>一致</code>地更新，线程应该确保通过<code>排他锁</code>单独获得这个变量。如果一个字段被声明成<code>volatile</code>，Java线程内存模型确保<u>所有线程看到这个变量的值是一致的</u>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/CPUTerm.png" alt="CPU的术语定义" /><figcaption aria-hidden="true">CPU的术语定义</figcaption>
</figure>
<p>有<code>volatile</code>变量修饰的共享变量进行写操作时会有一行<code>Lock</code>前缀的指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x01a3de1d: movb $0×0,0×1104800(%esi);</span><br><span class="line">0x01a3de24: lock addl $0×0,(%esp);</span><br></pre></td></tr></table></figure>
<p><code>Lock</code>指令在多核处理器下会:</p>
<ul>
<li>将当前处理器缓存行的数据<strong>写回到系统内存</strong>。</li>
<li>写回内存的操作会使在其他CPU里缓存了该内存地址的数据<strong>无效</strong>。在多处理器下，理由<code>缓存一致性协议</code>保证各个处理器的缓存是一致的，每个处理器通过<strong>嗅探</strong>在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成<code>无效状态</code>，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</li>
</ul>
<p><code>volatile</code>的两条实现原则：</p>
<ul>
<li><code>Lock</code>前缀指令会引起处理器缓存回写到内存。</li>
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</li>
</ul>
<h4 id="volatile的使用优化">1.2 <code>volatile</code>的使用优化</h4>
<p>队列集合类<code>LinkedTransferQueue</code>在使用<code>volatile</code>变量时，用一种追加字节的方式来优化队列出队和入队的性能。<code>LinkedTransferQueue</code>的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 队列中的头部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"><span class="comment">/** 队列中的尾部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedAtomicReference</span> &lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">// 使用很多4个字节的引用追加到64个字节</span></span><br><span class="line">	Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;</span><br><span class="line"></span><br><span class="line">    PaddedAtomicReference(T r) &#123;</span><br><span class="line">		<span class="keyword">super</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span> &lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line">	<span class="comment">// 省略其他代码</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>类<code>LinkedTransferQueue</code>使用一个内部类<code>PaddedAtomicReference</code>来定义队列的<strong>头节点（head）</strong>和<strong>尾节点（tail）</strong>，这个内部类相对于父类 <code>AtomicReference</code>只将共享变量追加到<code>64</code>字节。</p>
<p>主要原因是一些处理器的<code>L1</code>、<code>L2</code>或<code>L3</code>缓存的高速缓存行是64个字节宽，不支持部分填充缓存行。如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都<strong><u>读到同一个高速缓存行中</u></strong>，当一 个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，严重影响到队列的入队和出队效率。</p>
<p>通过追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。但在两种场景下不应该使用这种方式：</p>
<ul>
<li>缓存行非64字节宽的处理器。</li>
<li>共享变量不会被频繁地写。</li>
</ul>
<blockquote>
<p><code>Java 7</code>会淘汰或重新排列无用字段，需要使用其他追加字节的方式</p>
</blockquote>
<h3 id="synchronized的实现原理与应用">2. <code>synchronized</code>的实现原理与应用</h3>
<p><code>synchronized</code>被称呼为<strong>重量级锁</strong>。随着<code>Java SE 1.6</code>对<code>synchronized</code>的优化，它变得轻量级了。下利用<code>synchronized</code>实现同步的基础：<strong>Java中的每一个对象都可以作为锁</strong>。</p>
<ul>
<li>对于<strong>普通同步方法</strong>，锁是当前实例对象。</li>
<li>对于<strong>静态同步方法</strong>，锁是当前类的<code>Class</code>对象。</li>
<li>对于<strong>同步方法块</strong>，锁是<code>Synchonized</code>括号里配置的对象。</li>
</ul>
<p>当一个线程试图<u>访问同步代码块</u>时，它首先<strong>必须得到锁，退出或抛出异常时必须释放锁</strong>。<code>JVM</code>基于进入和退出<code>Monitor对象</code>来实现<strong>方法同步</strong>和<strong>代码块同步</strong>：</p>
<ul>
<li><code>代码块同步</code>是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的；
<ul>
<li><code>monitorenter</code>指令是在编译后插入到同步代码块的开始位置；</li>
<li><code>monitorexit</code>是插入到方法结束处和异常处；</li>
<li><code>JVM</code>要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对；</li>
<li>任何对象都有一个<code>monitor</code>与之关联，当且仅当一个<code>monitor</code>被持有后，它将处于<strong>锁定状态</strong>。线程执行到<code>monitorenter</code>指令时，将会尝试获取对象所对应的<code>monitor</code>的所有权，即尝试获得对象的锁。</li>
</ul></li>
<li><code>方法同步</code>是使用另外一种方式实现的，细节在<strong>JVM规范</strong>里并没有详细说明。方法的同步同样可以使用这两个指令来实现。</li>
</ul>
<h4 id="java对象头">2.1 Java对象头</h4>
<p><code>synchronized</code>用的锁是存在<strong>Java对象</strong>头里的。Java对象头里的<code>Mark Word</code>里默认存储对象的<code>HashCode</code>、分代年龄和锁标记位。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/objectHeadLength.PNG" alt="Java对象头的长度" /><figcaption aria-hidden="true">Java对象头的长度</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/objectHeadStructure.PNG" alt="Java对象头的存储结构" /><figcaption aria-hidden="true">Java对象头的存储结构</figcaption>
</figure>
<p>在运行期间，<code>Mark Word</code>里存储的数据会随着锁标志位的变化而变化。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/objectHeadMarkWord.PNG" alt="Mark Word的状态变化" /><figcaption aria-hidden="true">Mark Word的状态变化</figcaption>
</figure>
<p><code>64位虚拟机</code>下，<code>Mark Word</code>是<code>64bit</code>大小的，其存储结构如下：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/objectHeadMarkWord64.PNG" alt="Mark Word的状态变化(64bits)" /><figcaption aria-hidden="true">Mark Word的状态变化(64bits)</figcaption>
</figure>
<h4 id="锁的升级与对比">2.2 锁的升级与对比</h4>
<p>在<code>Java SE 1.6</code>中，锁一共有<code>4</code>种状态，级别从低到高依次是：<code>无锁状态</code>、<code>偏向锁状态</code>、<code>轻量级锁状态</code>和<code>重量级锁状态</code>，这几个状态会随着竞争情况逐渐升级。</p>
<blockquote>
<ul>
<li><p><strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。</p></li>
<li><p>引入了<code>“偏向锁”</code>和<code>“轻量级锁”</code>，是为了<u>减少获得锁和释放锁带来的性能消耗</u>。</p></li>
</ul>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/BiasedLock.PNG" alt="偏向锁" /><figcaption aria-hidden="true">偏向锁</figcaption>
</figure>
<h5 id="偏向锁">2.2.1 偏向锁</h5>
<p>大多数情况下，锁不仅不存在多线程竞争，而且<u><strong>总是由同一线程多次获得</strong></u>，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储<strong>锁偏向的线程ID</strong>，以后该线程在进入和退出同步块时不需要进行<code>CAS</code>操作来加锁和解锁，只需简单地测试一下对象头的<code>Mark Word</code>里<u><strong>是否存储着指向当前线程的偏向锁</strong></u>。</p>
<ul>
<li>如果测试成功，表示线程已经获得了锁。</li>
<li>如果测试失败，则需要再测试一下<code>Mark Word</code>中偏向锁的标识是否设置成<code>1</code>（表示当前是偏向锁）。如果没有设置，则使用<code>CAS</code>竞争锁；如果设置了，则尝试使用<code>CAS</code>将对象头的偏向锁指向当前线程。</li>
</ul>
<p>偏向锁使用了一种<u>等到竞争出现才释放锁的机制</u>，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待<strong>全局安全点</strong>（在这个时间点上没有正在执行的字节码）。</p>
<ul>
<li>首先暂停拥有偏向锁的线程；</li>
<li>然后检查持有偏向锁的线程是否活着：
<ul>
<li>如果线程不处于活动状态，则将对象头设置成无锁状态；</li>
<li>如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的<code>Mark Word</code>要么重新偏向于其他 线程，要么恢复到无锁或者标记对象不适合作为偏向锁。</li>
</ul></li>
<li>最后唤醒暂停的线程。</li>
</ul>
<h5 id="轻量级锁">2.2.2 轻量级锁</h5>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/LightweightLock.PNG" alt="轻量级锁" /><figcaption aria-hidden="true">轻量级锁</figcaption>
</figure>
<h6 id="轻量级锁加锁">2.2.2.1 轻量级锁加锁</h6>
<p>线程在执行同步块之前，<code>JVM</code>会先在当前线程的<strong>栈桢</strong>中创建<u>用于存储锁记录</u>的空间，并将对象头中的<code>Mark Word</code>复制到锁记录中，官方称为<code>Displaced Mark Word</code>。然后线程尝试使用<code>CAS</code>将对象头中的<code>Mark Word</code>替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋</strong>来获取锁。</p>
<h6 id="轻量级锁解锁">2.2.2.2 轻量级锁解锁</h6>
<p>轻量级解锁时，会使用原子的<code>CAS</code>操作将<code>Displaced Mark Word</code>替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会<strong>膨胀</strong>成重量级锁。因为<code>自旋</code>会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。</p>
<h4 id="锁的优缺点对比">2.2.3 锁的优缺点对比</h4>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/LockAdAndDisad.PNG" alt="锁的优缺点的对比" /><figcaption aria-hidden="true">锁的优缺点的对比</figcaption>
</figure>
<h3 id="原子操作的实现原理">3. 原子操作的实现原理</h3>
<p>原子操作（atomic operation）指“不可被中断的一个或一系列操作”。</p>
<h4 id="术语定义">3.1 术语定义</h4>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter2/CPUTerm2.PNG" alt="术语定义" /><figcaption aria-hidden="true">术语定义</figcaption>
</figure>
<h4 id="实现原子操作">3.2 实现原子操作</h4>
<p><code>32位IA-32处理器</code>使用<strong><u>基于对缓存加锁</u></strong>或<strong><u>总线加锁</u></strong>的方式来实现多处理器之间的原子操作。</p>
<ul>
<li>首先处理器会自动保证<strong>基本的内存操作</strong>的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，即当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。</li>
<li>但是处理器不能自动保证<strong>复杂的内存操作</strong>的原子性，比如<u>跨总线宽度</u>、<u>跨多个缓存行</u>和<u>跨页表</u>的访问。</li>
</ul>
<p>处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来<u>保证复杂内存操作的原子性</u>。</p>
<h5 id="总线锁保证原子性">3.2.1 总线锁保证原子性</h5>
<p>总线锁就是使用处理器提供的一个<code>LOCK＃</code>信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以<strong>独占共享内存</strong>。</p>
<h5 id="缓存锁保证原子性">3.2.2 缓存锁保证原子性</h5>
<p>同一时刻只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，锁定期间其他处理器<u><strong>不能操作其他内存地址的数据</strong></u>，所以总线锁定的开销比较大，目前处理器在某些场合下<u>使用缓存锁定代替总线锁定来进行优化</u>。</p>
<p><code>“缓存锁定”</code>是指内存区域如果被缓存在处理器的缓存行中，并且在<code>Lock</code>操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言<code>LOCK＃</code>信号，而是<strong><u>修改内部的内存地址</u></strong>，并允许它的缓存一致性机制来保证操作的原子 性，因为<u>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</u>，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p>
<p><strong>有两种情况下处理器不会使用缓存锁定</strong>：</p>
<ul>
<li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，处理器会调用总线锁定。</li>
<li>有些处理器不支持缓存锁定。</li>
</ul>
<h4 id="java实现原子操作">3.3 Java实现原子操作</h4>
<p>在<code>Java</code>中可以通过<strong>锁</strong>和<strong>循环CAS</strong>的方式来实现原子操作：</p>
<h5 id="使用循环cas实现原子操作">3.3.1 使用<code>循环CAS</code>实现原子操作</h5>
<p>JVM中的<code>CAS操作</code>利用了处理器提供的<code>CMPXCHG</code>指令实现的，自旋CAS实现的基本思路是<u><strong>循环进行CAS操作直到成功为止</strong></u>。从<code>Java 1.5</code>开始，<code>JDK</code>的并发包里提供了一些类来支持原子操作，如<code>AtomicBoolean</code>、<code>AtomicInteger</code>和<code>AtomicLong</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger atomicI = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/** * 使用CAS实现线程安全计数器 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">int</span> i = atomicI.get();</span><br><span class="line">		<span class="keyword">boolean</span> suc = atomicI.compareAndSet(i, ++i);</span><br><span class="line">		<span class="keyword">if</span> (suc) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="cas实现原子操作的三大问题">3.3.2 CAS实现原子操作的三大问题</h5>
<ol type="1">
<li><strong>ABA问题</strong>。因为<code>CAS</code>需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是<code>A</code>，变成了<code>B</code>，又变成了<code>A</code>，那么使用<code>CAS</code>进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是<strong><u>使用版本号</u></strong>。<code>JDK</code>的<code>Atomic</code>包里提供了一个类<code>AtomicStampedReference</code>来解决<code>ABA</code>问题。这个类的<code>compareAndSet</code>方法：
<ul>
<li>首先检查当前引用是否等于预期引用；</li>
<li>然后检查当前标志是否等于预期标志；</li>
<li>如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li>
</ul></li>
<li><strong>循环时间长开销大</strong>。自旋<code>CAS</code>如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持<code>pause指令</code>，那么效率会有一定的提升。pause指令有两个作用：
<ul>
<li><strong>延迟流水线执行指令（de-pipeline）</strong>，使CPU不会消耗过多的执行资源；</li>
<li>避免在退出循环的时候因<code>内存顺序冲突（Memory Order Violation）</code>而引起<code>CPU流水线被清空（CPU Pipeline Flush）</code>，从而提高CPU的执行效率。</li>
</ul></li>
<li><strong>只能保证一个共享变量的原子操作</strong>。对多个共享变量操作时，循环<code>CAS</code>就无法保证操作的原子性，这个时候就可以用<strong>锁</strong>。JDK也提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行<code>CAS操作</code>。</li>
</ol>
<h5 id="使用锁机制实现原子操作">3.3.3 使用锁机制实现原子操作</h5>
<p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。除了<code>偏向锁</code>，JVM实现锁的方式都用了<code>循环 CAS</code>，即当一个线程想进入同步块的时候<strong>使用循环CAS的方式来<u>获取锁</u></strong>，当它退出同步块的时候<strong>使用循环CAS<u>释放锁</u></strong>。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Java并发编程的艺术]--11 Java并发编程实践</title>
    <url>/2021/07/22/JavaLearning_The_art_of_concurrent_programming_in_Java-11-concurrent-programming-practice.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>并发编程产生的问题和风险可能也会随之而来。 <a id="more"></a></p>
<h3 id="生产者和消费者模式">1. 生产者和消费者模式</h3>
<p>生产者和消费者模式是<strong><u>通过一个容器来解决生产者和消费者的强耦合问题</u></strong>。生产者和消费者彼此之间不直接通信，而是<strong><u>通过阻塞队列来进行通信</u></strong>。</p>
<ul>
<li>生产者生产完数据之后不用等待消费者处理，直接放入阻塞队列；</li>
<li>消费者不找生产者要数据，而是直接从阻塞队列取数据；</li>
<li>阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</li>
</ul>
<h4 id="多生产者和多消费者">1.1 多生产者和多消费者</h4>
<p>消费者消费的数据，有可能需要继续处理，于是消费者处理完数据之后，它又要作为生产者把数据放在新的队列里，交给其他消费者继续处理。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/MultipleProducePay.PNG" alt="多生产者消费者模式" /><figcaption aria-hidden="true">多生产者消费者模式</figcaption>
</figure>
<h3 id="线上问题定位">2. 线上问题定位</h3>
<p>主要讲述了利用<code>top</code>来查看每个进程的情况，然后定位问题。其实有个更好用的<code>htop</code>，但需要单独安装，<code>top</code>是linux内置的：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/top.PNG" alt="top指令" /><figcaption aria-hidden="true">top指令</figcaption>
</figure>
<ul>
<li>COMMAND表示启动当前进程的命令</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/top1.PNG" alt="top交互" /><figcaption aria-hidden="true">top交互</figcaption>
</figure>
<p>使用top的交互命令数字<code>1</code>查看每个<code>CPU</code>的性能数据。参数的含义如下：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/CPUParam.PNG" alt="CPU参数含义" /><figcaption aria-hidden="true">CPU参数含义</figcaption>
</figure>
<h3 id="性能测试">3. 性能测试</h3>
<ul>
<li><p>使用<code>netstat</code>命令查询有多少台机器连接到端口上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -nat | grep 12200 –c</span><br></pre></td></tr></table></figure></li>
<li><p>通过<code>ps</code>命令查看下线程数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -eLf | grep java -c</span><br></pre></td></tr></table></figure></li>
<li><p>查看网络流量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/net/dev</span><br></pre></td></tr></table></figure></li>
<li><p>查看系统平均负载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/loadavg</span><br></pre></td></tr></table></figure></li>
<li><p>查看系统内存情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure></li>
<li><p>查看CPU的利用率</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/<span class="built_in">stat</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="异步任务池">4. 异步任务池</h3>
<p>任务池的主要处理流程是，每台机器会启动一个任务池，每个任务池里有多个线程池，当某台机器将一个任务交给任务池后，任务池会先将这个任务保存到数据库中，然后某台机器上的任务池会从数据库中获取待执行的任务，再执行这个任务。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/AsynchronousTaskPool.PNG" alt="异步任务池" /><figcaption aria-hidden="true">异步任务池</figcaption>
</figure>
<p>每个任务有几种状态：</p>
<ul>
<li>创建（<code>NEW</code>）：提交给任务池之后的状态；</li>
<li>执行中（<code>EXECUTING</code>）：任务池从数据库中拿到任务执行时的状态；</li>
<li>重试（<code>RETRY</code>）：当执行任务时出现错误，程序显式地告诉任务池这个任务需要重试，并设置下一次执行时间；</li>
<li>挂起 （<code>SUSPEND</code>）：当一个任务的执行依赖于其他任务完成时，可以将这个任务挂起，当收到消息后，再开始执行；</li>
<li>中止（<code>TEMINER</code>）：任务执行失败，让任务池停止执行这个任务，并设置错误消息告诉调用端；</li>
<li>执行完成（<code>FINISH</code>）：任务执行结束。</li>
</ul>
<p><strong>任务池的任务隔离</strong>。异步任务有很多种类型，不同类型的任务优先级不一样，所以对任务进行隔离执行。使用不同的线程池处理不同的任务，或者不同的线程池处理不同优先级的任务。</p>
<p><strong>任务池的重试策略</strong>。根据不同的任务类型设置不同的重试策略。</p>
<p><strong>使用任务池的注意事项</strong>。任务必须无状态：任务不能在执行任务的机器中保存数据，上传的文件必须存在其他的集群里，比如<code>OSS</code>或<code>SFTP</code>。</p>
<p><strong>异步任务的属性</strong>。包括任务名称、下次执行时间、已执行次数、任务类型、任务优先级和执行时的报错信息。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head First Java]--7 继承与多态</title>
    <url>/2021/05/12/JavaLearning_Head_First_Java_7_inheritance_and_polymorphism.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>规划程序时要考虑未来。 <a id="more"></a></p>
</blockquote>
<h3 id="继承">1. 继承</h3>
<h4 id="继承-1">1.1 继承</h4>
<p>设计<strong>继承</strong>时，会把共同程序代码放在某个类中，告诉其他类此类事他们的父类。当某个类继承另一个类的时候，也就是子类继承自父类。继承的关系意味着子类继承了父类的方法和实例变量。</p>
<p>如下一个例子</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceExample.PNG" alt="继承" /><figcaption aria-hidden="true">继承</figcaption>
</figure>
<p><code>PantherMan</code>会自动继承<code>SuperHero</code>的实例变量和方法，且<code>PantherMan</code>也可以加入自己的方法和实例变量，或者覆盖掉继承的方法。而<code>FriedEggMan</code>不需要独特的行为，所以没有覆盖任何方法。</p>
<blockquote>
<p>实例变量无法覆盖是因为不需要，它们没有定义特殊的行为。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceExample.PNG" alt="继承范例" /><figcaption aria-hidden="true">继承范例</figcaption>
</figure>
<p>在这个继承范例中，<code>Family Doctor</code>增加了实例变量和方法，<code>Surgeon</code>覆盖了继承的方法并增加了一个新方法。</p>
<blockquote>
<ul>
<li><p>需要注意继承使用的关键词<code>extends</code></p></li>
<li><p>如果在子类中还打算引用父类的方法，可以使用<code>super</code>关键字：</p></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.roam();</span><br><span class="line">     <span class="comment">// my own roam stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承层次设计">1.2 继承层次设计</h4>
<p>比如以设计动物仿真程序为例，主要有以下步骤：</p>
<ol type="1">
<li>找出具有共同属性和行为的对象</li>
<li>设计代表共同状态与行为的类</li>
<li>决定子类是否需要让某项行为(即方法的实现)有特定不同的运作方式</li>
<li>通过寻找使用共同行为的子类来找出更多抽象化的机会</li>
<li>完成类的继承层次</li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/animalInheritanceTree.PNG" alt="动物类继承层次" /><figcaption aria-hidden="true">动物类继承层次</figcaption>
</figure>
<blockquote>
<p>当调用对象引用的方法时，会调用到与该对象类型最接近的方法。即<code>最低阶</code>会胜出。Java虚拟机会从树的叶节点开始往上寻找方法。</p>
</blockquote>
<p>所有子类与其任一个上层父类之间应该都是<code>IS-A</code>的关系。</p>
<h4 id="存取权限">1.3 存取权限</h4>
<p>父类可以通过存取权限决定子类是否能够继承某些特定的成员。主要有以下4种存取权限，左边最受限制，越往右限制程度越小：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/accessLevels.PNG" alt="存取权限" /><figcaption aria-hidden="true">存取权限</figcaption>
</figure>
<p><code>存取权限(Access levels)</code>控制谁可以接触什么：</p>
<blockquote>
<ul>
<li><code>public</code>类型的成员会被继承</li>
<li><code>private</code>类型的成员不会被继承</li>
</ul>
</blockquote>
<h4 id="继承的意义">1.4 继承的意义</h4>
<p>通过继承，子类不需要重新编译就能运行到新版本的父类。此外通过继承可以：</p>
<ol type="1">
<li><p>避免重复的程序代码</p>
<p>即可以在父类这一单一位置定义共同程序代码。</p></li>
<li><p>定义出共同的协议</p>
<p>继承可以确保每个父类下的所有类都会有父类所持有的全部(可继承的)方法。也就是说，通过继承来定义相关类之间的共同协议。</p></li>
</ol>
<h4 id="私有类">1.5 "私有类"</h4>
<p>实际上没有"私有类"的概念，但有三种方法可以防止这个类被继承：</p>
<ol type="1">
<li><p>存取控制。不能标记类为私有，但可以不标记为公有。非公有类只能被同一个包的类继承。</p></li>
<li><p>使用<code>final</code>修饰符。表示它是继承树的末端，不能被继承。</p>
<blockquote>
<p><code>final</code>表示符主要为保证安全，确保方法都是当前版本。</p>
<p>如果想防止特定方法被覆盖，可以在该方法前表示<code>final</code>修饰符。</p>
</blockquote></li>
<li><p>让类只拥有<code>private</code>的构造函数。</p></li>
</ol>
<h3 id="多态">2. 多态</h3>
<p>一般声明引用和创建对象时，重点在于要求引用类型与对象类型必须相符。而在多态下，引用与对象可以是不同类型：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphismExample.PNG" alt="多态" /><figcaption aria-hidden="true">多态</figcaption>
</figure>
<p>运用多态时，引用类型可以时实际对象类型的父类。所以可以实现<code>多态数组(polymorphic arrays)</code>这一类东西：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphicArray.PNG" alt="多态数组" /><figcaption aria-hidden="true">多态数组</figcaption>
</figure>
<p>参数和返回类型也可以用多态。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/polymorphicArgument.PNG" alt="参数多态" /><figcaption aria-hidden="true">参数多态</figcaption>
</figure>
<h3 id="覆盖的规则">3. 覆盖的规则</h3>
<p>当要覆盖父类的方法时，必须遵守以下规则：</p>
<ol type="1">
<li>参数必须一样，且返回类型必须兼容</li>
<li><strong>不能降低</strong>方法的存取权限</li>
</ol>
<h3 id="方法的重载overload">4. 方法的重载(overload)</h3>
<p>重载的意义是两个方法的名称相同，但参数不同。所以<strong>重载与多态毫无关系</strong>。</p>
<blockquote>
<p>重载的方法只是刚好有相同名字的不同方法，它与继承或多态无关</p>
</blockquote>
<p>重载的方法有更多的扩展性：</p>
<ol type="1">
<li>返回类型可以不同</li>
<li>不能只改变返回类型。重载的条件是<strong>要使用不同的参数</strong>。</li>
<li>可以任意设定存取权限</li>
</ol>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--8 接口与抽象类</title>
    <url>/2021/05/13/JavaLearning_Head_First_Java_8_interfaces_and_abstract_classes.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>继承只是个开始。 <a id="more"></a></p>
</blockquote>
<h3 id="抽象类">1. 抽象类</h3>
<h4 id="抽象类-1">1.1 抽象类</h4>
<p>有些类不应该被初始化。比如如果尝试创建一个<code>Animal</code>对象，很难定义该对象或者说该对象并没有意义(没有一种叫做<code>Animal</code>的动物)。而又需要<code>Animal</code>类来继承和产生多态，需要<strong>限制只有它的子类才能被初始化</strong>。</p>
<p>通过标记类为<code>抽象类</code>，可以告诉编译器这个类不能创建任何类型实例。记让这个类不能被<code>"nwe"</code>出来。设计抽象类只需要在类前加入关键词<code>abstract</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Canie</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roam</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是可以用这种抽象类作为引用类型给多态使用。不是<code>抽象(abstract)</code>的类就被称为<code>具体(concrete)</code>类</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/abstractConcrete.PNG" alt="抽象与具体" /><figcaption aria-hidden="true">抽象与具体</figcaption>
</figure>
<h4 id="抽象方法">1.2 抽象方法</h4>
<p>方法也可以被标及为<code>abstract</code>。抽象类代表此类必须要被<code>extend</code>，抽象方法代表此方法必须要被覆盖。</p>
<blockquote>
<p><strong>抽象的方法没有实体</strong></p>
</blockquote>
<p>比如一个抽象的方法可以写作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果声明了一个抽象方法，那么这个类也必须被标记为抽象类。</p>
<blockquote>
<p>即<strong>非抽象类不能拥有抽象方法</strong></p>
</blockquote>
<p>抽象方法的意义是<u>就算无法实现出方法的内容，但还是可以定义出一组子类共同的协议</u>。由于抽象方法没有内容，只是为了标记出多态而存在，所以<strong>继承树下的第一个具体类必须要实现出所有的抽象方法</strong>。</p>
<p>一个抽象类继承另一个抽象类，不需要实现其抽象方法。但抽象类可以同时带有抽象和非抽象方法，所以如果有需要，也可以对抽象方法进行实现。</p>
<h4 id="多态范例">1.3 多态范例</h4>
<p>如果要一个可以保持Dog对象的list，可以写一个专用的list类。但如果Cat也要用同样的方法，如果重新编写一个类似的类过于麻烦。可以利用多态的特点，编写一个<code>AnimalList</code>类来处理<code>Animal</code>的所有子类。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/animalList.PNG" alt="Animal List" /><figcaption aria-hidden="true">Animal List</figcaption>
</figure>
<p>进一步，可以设计处理<code>Animal</code>之上的类，得到更通用、更抽象的类。</p>
<blockquote>
<p>Java中所有类都是从<code>Object</code>这个类继承出来的。<code>Object</code>是所有类的源头，即所有类的父类。</p>
</blockquote>
<p>没有直接继承过其他类的类会隐含地继承<code>Object</code>类。这样一个终极类(<code>ultra-super-megaclass</code>)需要带有一些每个对象都需要的行为。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/ultra-super-megaclass-Object.PNG" alt="终极类Object" /><figcaption aria-hidden="true">终极类<code>Object</code></figcaption>
</figure>
<p><code>Object</code>不是一个正式的<code>Java</code>抽象类，也就是说可以创建<code>Object</code>对象。</p>
<blockquote>
<p><code>Object</code>对象的意义主要在于，有时需要一个<u>通用的、轻量化的</u>对象。比如在线程同步中。</p>
</blockquote>
<p><code>Object</code>类的主要目的是：</p>
<ul>
<li>作为多态让方法可以应付多种类型的机制；</li>
<li>提供Java在执行期间对任何对象都需要实现的程序代码。</li>
</ul>
<p>而如果使用<code>Object</code>类型的多态引用会带来一些问题：</p>
<ul>
<li>以<code>Object</code>类型作为引用时，<code>Java</code>会把它当作<code>Object</code>类型的实例，这代表只能调用由<code>Object</code>声明的方法。</li>
<li>任何重<code>ArrayList&lt;Object&gt;</code>取出的东西都会被当作<code>Object</code>类型的引用，也就导致无法复制给原来的类型。</li>
</ul>
<blockquote>
<p>编译器是<u>根据引用类型来判断有那些method可以调用，而不是<code>Object</code>的确实类型</u>。</p>
</blockquote>
<p>对象会带有从父类继承的所有东西。所以无论这个对象实际类型，它也是一个<code>Object</code>实例。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/snowboardObject.PNG" alt="内部Object" /><figcaption aria-hidden="true">内部<code>Object</code></figcaption>
</figure>
<p>但也有办法可以让<code>Object</code>引用恢复成原来的类，那就是使用<code>类型转化</code>。如果确定对象类型，可以直接转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dog d = (Dog) o;</span><br></pre></td></tr></table></figure>
<p>如果无法确定类型，可以使用<code>instanceof</code>来检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">	Dog d = (Dog) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口">2. 接口</h3>
<h4 id="接口-1">2.1 接口</h4>
<p>如果想要修改<code>合约</code>，比如为Dog类加入Pet的方法，而又不影响其他非Pet类的使用，就需要<code>接口</code>。先看看没有<code>接口</code>会遇到的问题，可以用如下方式加入<code>Pet</code>方法进行修改：</p>
<ol type="1">
<li>把<code>Pet</code>方法加入到<code>Animal</code>类中。
<ul>
<li><code>优点</code>：所有子类马上继承<code>Pet</code>方法，无需改变子类程序代码。</li>
<li><code>缺点</code>：<code>非Pet</code>类也会继承到<code>Pet</code>方法</li>
</ul></li>
<li>把<code>Pet</code>方法加入到<code>Animal</code>类中，但把其设定为抽象的。
<ul>
<li><code>优点</code>：<code>非Pet</code>类覆盖方法时，作出合理动作。</li>
<li><code>缺点</code>：所有子类都需要实现<code>Pet</code>方法，耗时。</li>
</ul></li>
<li>把方法添加到需要的子类中。
<ul>
<li><code>优点</code>：<code>非Pet</code>类无需实现，更灵活。</li>
<li><code>缺点</code>：失去合约保证，且多态无法其作用。</li>
</ul></li>
</ol>
<p>真正需要的是：<code>Pet</code>方法只需要在宠物上实现；所有宠物类都有相同的方法定义；可以运用到多态。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/twoSuperClassesAtTop.PNG" alt="继承多个上次父类" /><figcaption aria-hidden="true">继承多个上次父类</figcaption>
</figure>
<p>图中的<code>多重继承</code>会有被称为<code>”致命方块”（Deadly Diamond of Death）</code>的问题，而且Java也并不支持这种方式。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/DeadlyDiamondofDeath.PNG" alt="”致命方块”（Deadly Diamond of Death）" /><figcaption aria-hidden="true">”致命方块”（Deadly Diamond of Death）</figcaption>
</figure>
<p>·同名的实例变量和函数会导致冲突，带来更复杂的问题。</p>
<p>Java里使用<code>接口(interface)</code>来解决这一问题，接口把全部方法设为抽象的，所有子类都需要实现其方法。接口定义如下，使用<code>interface</code>代替<code>class</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pet</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>接口实现如下，使用关键字<code>implements</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Canine</span> <span class="keyword">implements</span> <span class="title">Pet</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实现某接口的类<code>必须实现它所有的方法</code>，因为这些方法都是<code>public</code>与<code>abstract</code>的。</p>
</blockquote>
<p>接口主要为<code>多态</code>服务，以接口取代具体的子类或抽象父类作为参数或返回值，<code>可以传入任何有实现该接口的东西</code>。此外，使用接口可以继承超过一个以上的来源。</p>
<blockquote>
<p>不同继承树的类也可以实现相同的接口</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/inheritanceTreeInterface.PNG" alt="继承树中的接口" /><figcaption aria-hidden="true">继承树中的接口</figcaption>
</figure>
<p>用接口作为多态类型时，对象可以来自任何地方。唯一的条件是<strong>该对象必须是来自有实现此接口的类</strong>。类可以实现多个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Pet</span>, <span class="title">Saveable</span>, <span class="title">Paintable</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>可以把接口理解为<strong>类可以扮演的角色</strong>。</p>
<h4 id="super的使用">2.2 <code>Super</code>的使用</h4>
<p>如果子类不打算完全覆盖某个父类方法，又需要加入额外动作，可以使用<code>super</code>关键词来调用父类方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">runReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	<span class="comment">// set-up report </span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">printReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">// generic printing</span></span><br><span class="line"> 	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuzzwordsReport</span> <span class="keyword">extends</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">runReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.runReport();  <span class="comment">//调用父类方法</span></span><br><span class="line">		buzzwordCompliance();</span><br><span class="line">		printReport();</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">buzzwordCompliance</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/superClass.PNG" alt="superClass" /><figcaption aria-hidden="true">superClass</figcaption>
</figure>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Head_First_Java]--十大遗珠之憾</title>
    <url>/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>什么！有完没完啊？这本书到底还要看多久？ <a id="more"></a></p>
</blockquote>
<h3 id="枚举又称为枚举类型或enum">1. 枚举(又称为枚举类型或<code>Enum</code>)</h3>
<p>枚举类型定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Members &#123; JERRY, BOBBY, PHIL &#125;;</span><br><span class="line"><span class="keyword">public</span> Members selectedBandMember;</span><br><span class="line"></span><br><span class="line"><span class="comment">// later in the code</span></span><br><span class="line"><span class="keyword">if</span> (selectedBandMember == Members.JERRY) &#123;</span><br><span class="line">	<span class="comment">// do JERRY related stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在<code>enum</code>中加入构造函数、方法、变量和特定常量的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HfjEnum</span> </span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> Names &#123;</span><br><span class="line">        <span class="comment">// 传给下方定义构造函数的参数</span></span><br><span class="line">		JERRY(“lead guitar”) &#123; <span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">							<span class="keyword">return</span> “plaintively”; &#125;&#125;,</span><br><span class="line">		BOBBY(“rhythm guitar”) &#123; <span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">							<span class="keyword">return</span> “hoarsely”; &#125;&#125;,</span><br><span class="line">		PHIL(“bass”);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String instrument;</span><br><span class="line"> 		</span><br><span class="line">        <span class="comment">// enum的构造函数，会对每个被声明的enum值执行一次</span></span><br><span class="line">        Names(String instrument) &#123;</span><br><span class="line">            <span class="keyword">this</span>.instrument = instrument;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getInstrument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.instrument;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">sings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> “occasionally”;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Names n : Names.values()) &#123;</span><br><span class="line">            System.out.print(n);</span><br><span class="line">            System.out.print(“, instrument: “+ n.getInstrument());</span><br><span class="line">            System.out.println(“, sings: “ + n.sings());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多维数组">2. 多维数组</h3>
<p>Java中，二维数组实际上是一个<strong><code>数组的数组</code></strong>。</p>
<h3 id="string-and-stringbufferstringbuilder-methods">3. <code>String</code> and <code>StringBuffer/StringBuilder</code> Methods</h3>
<p><code>Java 5.0</code>起，应该用<code>StringBuilder</code>取代<code>StringBuffer</code>。<code>StringBuffer/StringBuilder</code> 来操作字符串更有效率。</p>
<h3 id="存取权限和存取修饰符">4. 存取权限和存取修饰符</h3>
<p><code>Java</code>有4种存取权限等级与3种存取修饰符。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/HeadFirstJava/AccessLevelsModifiers.PNG" alt="存取权限和存取修饰符" /><figcaption aria-hidden="true">存取权限和存取修饰符</figcaption>
</figure>
<h3 id="anonymous和static-nested-classes">5. <code>Anonymous</code>和<code>Static Nested Classes</code></h3>
<p><code>静态嵌套类</code>可以不需要外部类的实例就调用，但还是被看作外部类的一个成员，能够存取任何外部类的静态成员(包括私有)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooOuter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarInner</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sayIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(“method of a <span class="keyword">static</span> inner <span class="class"><span class="keyword">class</span>”)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FooOuter.BarInner foo = <span class="keyword">new</span> FooOuter.BarInner();</span><br><span class="line">        foo.sayIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>匿名的内部类</code>，是在需要传入一个实例的地方创建一个类，并把整个类作为参数传进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnon</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line">		JButton button = <span class="keyword">new</span> JButton(“click”);</span><br><span class="line">		frame.getContentPane().add(button);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// button.addActionListener(quitListener);</span></span><br><span class="line">		button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent ev)</span> </span>&#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连接的调用">6. 连接的调用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"spring"</span>);</span><br><span class="line">sb = sb.delete(<span class="number">3</span>,<span class="number">6</span>).insert(<span class="number">2</span>,<span class="string">"umme"</span>).deleteCharAt(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>第二行程序从左到右执行。如下调用方法可以调用方法又不需要维护一个引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo().go();</span><br></pre></td></tr></table></figure>
<h3 id="块区域">7. 块区域</h3>
<p>区段程序代码通常在方法中，以<code>{}</code>字符来区分。在某个块区域中声明的变量，一旦离开块区域，就超出范围，无法再被使用。</p>
<h3 id="断言">8. 断言</h3>
<p>断言的使用类似<code>println()</code>，执行时未特别设定，被加入到程序中的<code>assert</code>命令会被Java虚拟机忽略。只有打开断言，才会输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> (height &gt; <span class="number">0</span>); </span><br><span class="line"><span class="comment">// if true, program continues normally</span></span><br><span class="line"><span class="comment">// if false, throw an AssertionError</span></span><br></pre></td></tr></table></figure>
<p>也可以加入信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> (height &gt; <span class="number">0</span>) : <span class="string">"height = "</span> + height + <span class="string">" weight = "</span> + weight;</span><br></pre></td></tr></table></figure>
<h3 id="不变性">9. 不变性</h3>
<p><code>String</code>的不变性，主要为了安全性和节省空间。比如下面的程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = “<span class="number">0</span>”;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">     s = s + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上创建了<code>10</code>个<code>String</code>对象("0", "01", ..., "0123456789")。创建新<code>String</code>时，<code>JVM</code>会把它放在<code>"String Pool"</code>的特殊存储区域，如果已经出现同值的<code>String</code>，JVM不会重复建立<code>String</code>，会引用已经存在的内容。因为<code>String</code>是不变的，引用变量无法改变其他参数变量引用到的同一个<code>String</code>值。</p>
<p><code>包装类</code>也具有不变性。</p>
<h3 id="位操作">10. 位操作</h3>
<ul>
<li>按位非运算：<code>~</code></li>
<li>按位与运算：<code>&amp;</code></li>
<li>按位或运算：<code>|</code></li>
<li>按位异或运算：<code>^</code></li>
<li>右移运算：<code>&gt;&gt;</code></li>
<li>无符号右移：<code>&gt;&gt;&gt;</code>。第一位补<code>0</code>，正负号可能改变。</li>
<li>左移运算符：<code>&lt;&lt;</code></li>
</ul>
]]></content>
      <categories>
        <category>headFirstJava</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Java并发编程的艺术]--3 Java内存模型</title>
    <url>/2021/07/17/JavaLearning_The_art_of_concurrent_programming_in_Java-3-Java-memory-model.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>Java线程之间的通信对程序员完全透明，内存可见性问题很容易困扰Java程序员</code> <a id="more"></a></p>
</blockquote>
<h3 id="java内存模型的基础">1. <code>Java</code>内存模型的基础</h3>
<h4 id="并发编程模型的两个关键问题">1.1 并发编程模型的两个关键问题</h4>
<p>在并发编程中，需要处理两个关键问题：</p>
<ul>
<li><strong>线程之间如何通信</strong>。线程之间的通信机制有两种：<code>共享内存</code>和<code>消息传递</code>。
<ul>
<li><code>共享内存</code>是线程之间共享程序的公共状态，通过<u>写-读内存中的公共状态</u>进行<strong>隐式</strong>通信。</li>
<li><code>消息传递</code>是线程之间通过<u>发送消息</u>来<strong>显式</strong>进行通信。</li>
</ul></li>
<li><strong>线程之间如何同步</strong>。
<ul>
<li>在<code>共享内存</code>并发模型里，同步是<strong>显式</strong>进行的。必须显式指定某个方法或某段代码需要在线程之间互斥执行。</li>
<li>在<code>消息传递</code>并发模型里，同步是<strong>隐式</strong>进行的。消息的发送必须在消息的接收之前。</li>
</ul></li>
</ul>
<p>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行。</p>
<h4 id="java内存模型的抽象结构">1.2 Java内存模型的抽象结构</h4>
<p>Java中所有<code>实例域</code>、<code>静态域</code>和<code>数组元素</code>都存储在<strong>堆内存</strong>中，<strong><u>堆内存在线程之间共享</u></strong>。Java内存模型（为<code>JMM</code>）<u>决定一个线程对共享变量的写入何时对另一个线程可见</u>。<code>JMM</code>定义了线程和主内存之间的抽象关系：</p>
<blockquote>
<p>线程之间的共享变量存储在<code>主内存（Main Memory）</code>中，每个线程都有一个私有的<code>本地内存（Local Memory）</code>，本地内存中存储了该线程以读/写共享变量的副本。本地内存是<code>JMM</code>的一个<strong>抽象概念</strong>，并不真实存在。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/JMMStructure.PNG" alt="Java内存模型的抽象结构" /><figcaption aria-hidden="true">Java内存模型的抽象结构</figcaption>
</figure>
<p>Java线程之间的通信过程必须要经过<code>主内存</code>。<code>JMM</code>通过控制主内存与每个线程的本地内存之间的交互，来提供<strong>内存可见性保证</strong>。</p>
<h4 id="从源代码到指令序列的重排序">1.3 从源代码到指令序列的重排序</h4>
<p>为了提高性能，编译器和处理器常常会对指令做<code>重排序</code>。<code>重排序</code>分3种类型：</p>
<ol type="1">
<li><code>编译器优化的重排序</code>。<strong>编译器</strong>在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li><code>指令级并行的重排序</code>。现代<strong>处理器</strong>采用了<code>指令级并行技术（Instruction-Level Parallelism，ILP）</code>来<u>将多条指令重叠执行</u>。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li><code>内存系统的重排序</code>。由于<strong>处理器</strong>使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>重排序可能会导致<strong>多线程程序</strong>出现<strong>内存可见性问题</strong>。JMM属于<u>语言级</u>的内存模型，通过<u>禁止<strong>特定类型</strong>的编译器重排序和处理器重排序，提供一致的内存可见性保证</u>。</p>
<h4 id="并发编程模型的分类">1.4 并发编程模型的分类</h4>
<p>现代的处理器使用<strong>写缓冲区</strong>临时保存<u>向内存写入的数据</u>，它可以</p>
<ul>
<li>避免由于处理器停顿下来<u>等待向内存写入数据而产生的延迟</u>。</li>
<li>以<strong>批处理</strong>的方式刷新写缓冲区，合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。</li>
</ul>
<p>每个处理器上的写缓冲区，仅仅对它所在的处理器可见，这会它会导致<u>处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致</u>。为了保证<strong>内存可见性</strong>，Java编译器在生成指令序列的适当位置会插入<code>内存屏障</code>指令来<u>禁止特定类型的处理器重排序</u>。<code>JMM</code>把内存屏障指令分为4类：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/MemoryBarriers.PNG" alt="内存屏障类型" /><figcaption aria-hidden="true">内存屏障类型</figcaption>
</figure>
<p><code>StoreLoad Barriers</code>是一个<code>“全能型”</code>的屏障，同时具有其他3个屏障的效果。但<u>执行该屏障开销会很昂贵</u>，因为当前处理器通常要把写缓冲区中的数据<code>全部刷新到内存中（Buffer Fully Flush）</code>。</p>
<h4 id="happens-before">1.5 <code>happens-before</code></h4>
<p><code>happens-before</code>用于表示操作之间的<code>内存可见性</code>。在<code>JMM</code>中，如果<u>一个操作执行的<strong>结果</strong>需要对另一个操作可见</u>，那么这两个操作之间必须要存在<code>happens-before</code>关系。</p>
<ul>
<li><code>程序顺序规则</code>：一个线程中的每个操作，<code>happens-before</code>于该线程中的任意后续操作。</li>
<li><code>监视器锁规则</code>：对一个锁的解锁，<code>happens-before</code>于随后对这个锁的加锁。</li>
<li><code>volatile变量规则</code>：对一个volatile域的写，<code>happens-before</code>于任意后续对这个volatile域的读。</li>
<li><code>传递性</code>：如果A <code>happens-before</code> B，且B <code>happens-before</code> C，那么A <code>happens-before</code> C。</li>
</ul>
<p>一个<code>happens-before</code>规则对应于一个或多个<strong>编译器和处理器重排序规则</strong>。</p>
<h3 id="重排序">2. 重排序</h3>
<h4 id="数据依赖性">2.1 数据依赖性</h4>
<p>如果两个操作访问<strong>同一个变量</strong>，且这两个操作中<strong>有一个为写操作</strong>，此时这两个操作之间就存在<code>数据依赖性</code>。只要重排序两个操作的执行顺序，程序的执行结果就会被改变。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/DataDependency.PNG" alt="数据依赖类型" /><figcaption aria-hidden="true">数据依赖类型</figcaption>
</figure>
<p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<h4 id="as-if-serial语义">2.2 <code>as-if-serial</code>语义</h4>
<p><code>as-if-serial</code>语义的意思是：不管怎么重排序，（单线程）程序的执行结果不能被改变。如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<h4 id="程序顺序规则">2.3 程序顺序规则</h4>
<p>如果<code>A happens-before B</code>，<code>JMM</code>并不要求A一定要在B之前执行。JMM仅仅要求<u>前一个操作（执行的结果）对后一个操作可见</u>，且<u>前一个操作按顺序排在第二个操作之前</u>。</p>
<p>若操作A的执行结果<strong>不需要对操作B可见</strong>，而且重排序操作A和操作B后的执行结果，与操作A和操作B按<code>happens-before</code>顺序<strong>执行的结果一致</strong>，<code>JMM</code>会允许这种重排序。</p>
<h4 id="重排序对多线程的影响">2.4 重排序对多线程的影响</h4>
<p>重排序可能会改变多线程程序的执行结果。如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">		flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Public <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (f?lag) &#123; <span class="comment">// 3</span></span><br><span class="line">			<span class="keyword">int</span> i = a * a; <span class="comment">// 4</span></span><br><span class="line">			……</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序。如果操作1和操作2做了重排序，程序执行时</p>
<ul>
<li>线程A首先写标记变量<code>flag</code>；</li>
<li>随后线程B读变量<code>flag</code>；</li>
<li>由于条件判断为真，线程B将读取变量<code>a</code>。此时，变量<code>a</code>还没有被线程A写入，此时多线程程序的语义被重排序破坏。</li>
</ul>
<p>同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。操作3和操作4存在<code>控制依赖关系</code>。编译器和处理器会采用<code>猜测（Speculation）执行</code>来克服控制相关性<u>对并行度的影响</u>。</p>
<ul>
<li>执行线程B的处理器可以提前读取并计算<code>a*a</code>；</li>
<li>然后把计算结果临时保存到一个名为<code>重排序缓冲（Reorder Buffer，ROB）</code>的<strong>硬件缓存</strong>中；</li>
<li>当操作3的条件判断为真时，就把该计算结果写入变量<code>i</code>中。在此时，重排序也破坏了多线程程序的语义。</li>
</ul>
<h3 id="顺序一致性">3. 顺序一致性</h3>
<h4 id="数据竞争与顺序一致性">3.1 数据竞争与顺序一致性</h4>
<p><code>Java内存模型规范</code>把<code>数据竞争</code>的定义为：</p>
<blockquote>
<p><strong>在一个线程中写一个变量，另一个线程读同一个变量，而且写和读没有通过同步来排序。</strong></p>
</blockquote>
<p><code>JMM</code>对正确同步的多线程程序的内存一致性保证：</p>
<blockquote>
<p>如果程序是正确同步的，程序的执行将具有<code>顺序一致性（Sequentially Consistent）</code>——即<u>程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同</u>。</p>
</blockquote>
<h4 id="顺序一致性内存模型">3.2 顺序一致性内存模型</h4>
<p>顺序一致性内存模型有两大特性：</p>
<ol type="1">
<li>一个线程中的所有操作必须<u>按照程序的顺序来执行</u>。</li>
<li>（不管程序是否同步）所有线程都<u>只能看到一个单一的操作执行顺序</u>。在顺序一致性内存模型中，每个操作都必须<strong>原子执行且立刻对所有线程可见</strong>。</li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/SequentiallyConsistent.PNG" alt="顺序一致性内存模型" /><figcaption aria-hidden="true">顺序一致性内存模型</figcaption>
</figure>
<p>顺序一致性内存模型是一个<strong>理论参考模型</strong>，在概念上顺序一致性模型有一个<u><strong>单一的全局内存</strong></u>，这个内存通过一个<u>左右摆动的开关</u>可以连接到任意一个线程，同时每一个线程<strong>必须按照程序的顺序</strong>来执行内存读/写操作。</p>
<p>未同步程序在<code>JMM</code>中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。</p>
<ul>
<li>在当前线程把写过的数据缓存在<code>本地内存</code>中，在没有刷新到<code>主内存</code>之前，这个写操作仅对当前线程可见；</li>
<li>从其他线程的角度来观察，会认为这个写操作根本没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。</li>
<li>当前线程和其他线程看到的操作执行顺序将不一致。</li>
</ul>
<h4 id="同步程序的顺序一致性效果">3.3 同步程序的顺序一致性效果</h4>
<ul>
<li><p>顺序一致性模型中，所有操作完全按程序的顺序串行执行。</p></li>
<li><p>而在<code>JMM</code>中，<u>临界区内的代码可以重排序</u>（但JMM不允许临界区内的代码<code>“逸出”</code>到临界区之外，那样会破坏监视器的语义）。虽然线程A在临界区内做了重排序，但由于<u>监视器互斥执行</u>的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。</p></li>
</ul>
<h4 id="未同步程序的执行特性">3.4 未同步程序的执行特性</h4>
<p>对于未同步或未正确同步的多线程程序，<code>JMM</code>只提供<u><strong>最小安全性</strong></u>：</p>
<blockquote>
<p>线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，Null，False），JMM保证<u><strong>线程读操作读取到的值不会<code>无中生有（Out Of Thin Air）</code>的冒出来</strong></u>。</p>
</blockquote>
<p>JMM不保证未同步程序的<strong>执行结果</strong>与该程序在顺序一致性模型中的执行结果一致，整体上是无序的，其执行结果无法预知。两个模型中的执行特性有如下几个差异：</p>
<ol type="1">
<li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行。</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。</li>
<li>JMM不保证对64位的<code>long</code>型和<code>double</code>型变量的<code>写操作</code>具有<strong>原子性</strong>，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li>
</ol>
<h3 id="volatile的内存语义">4. <code>volatile</code>的内存语义</h3>
<h4 id="volatile的特性">4.1 volatile的特性</h4>
<p>理解<code>volatile</code>特性的一个好方法是把对<code>volatile</code>变量的单个读/写，看成是使用<strong>同一个锁</strong>对这些<strong>单个读/写操作</strong>做了同步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> vl = <span class="number">0L</span>; <span class="comment">// 使用volatile声明64位的long型变量</span></span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">		vl = l; <span class="comment">// 单个volatile变量的写</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		vl++; <span class="comment">// 复合（多个）volatile变量的读/写</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vl; <span class="comment">// 单个volatile变量的读</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个程序在语义上等价。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> vl = <span class="number">0L</span>; <span class="comment">// 64位的long型普通变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123; <span class="comment">// 对单个的普通变量的写用同一个锁同步</span></span><br><span class="line">		vl = l;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123; <span class="comment">// 普通方法调用</span></span><br><span class="line">        <span class="keyword">long</span> temp = get(); <span class="comment">// 调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>; <span class="comment">// 普通写操作</span></span><br><span class="line">        set(temp); <span class="comment">// 调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// 对单个的普通变量的读用同一个锁同步</span></span><br><span class="line">        <span class="keyword">return</span> vl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>volatile</code>变量自身具有下列特性：</p>
<ul>
<li><strong>可见性</strong>。锁的<code>happens-before</code>规则保证释放锁和获取锁的两个线程之间的<strong>内存可见性</strong>，这意味着对一个<code>volatile</code>变量的读，总是能看到（任意线程）对这个<code>volatile</code>变量<u><strong>最后的写入</strong></u>。</li>
<li><strong>原子性</strong>。锁的语义决定了临界区代码的执行具有<strong>原子性</strong>，对任意单个volatile变量的读/写具有原子性。</li>
</ul>
<h4 id="volatile写-读建立的happens-before关系">4.2 <code>volatile</code>写-读建立的<code>happens-before</code>关系</h4>
<p><code>volatile</code>变量的<strong>写-读</strong>可以实现线程之间的通信。<code>volatile</code>的<strong>写-读</strong>与<code>锁</code>的<strong>释放-获取</strong>有相同的内存效果：</p>
<ul>
<li><code>volatile写</code>和<code>锁的释放</code>有相同的内存语义；</li>
<li><code>volatile读</code>与<code>锁的获取</code>有相同的内存语义。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (flag) &#123; <span class="comment">// 3</span></span><br><span class="line">    		<span class="keyword">int</span> i = a; <span class="comment">// 4</span></span><br><span class="line">    		……</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设线程A执行<code>writer()</code>方法之后，线程B执行<code>reader()</code>方法。根据<code>happens-before</code>规则，这个过程建立的<code>happens-before</code>关系可以分为3类：</p>
<ol type="1">
<li>根据<strong>程序次序规则</strong>，<strong>1</strong> <code>happens-before</code> <strong>2</strong>；<strong>3</strong> <code>happens-before</code> <strong>4</strong>。</li>
<li>根据<code>volatile规则</code>，<strong>2</strong> <code>happens-before</code> <strong>3</strong>。</li>
<li>根据<code>happens-before</code>的<strong>传递性规则</strong>，<strong>1</strong> <code>happens-before</code> <strong>4</strong>。</li>
</ol>
<h4 id="volatile写-读的内存语义">4.3 volatile写-读的内存语义</h4>
<ul>
<li><code>volatile写</code>的内存语义即：当写一个volatile变量时，JMM会<strong><u>把该线程对应的本地内存中的共享变量值刷新到主内存</u></strong>。</li>
<li><code>volatile读</code>的内存语义即：当读一个volatile变量时，JMM会<strong><u>把该线程对应的本地内存置为无效</u></strong>。线程接下来将从主内存中读取共享变量。</li>
</ul>
<p>把<code>volatile写</code>和<code>volatile读</code>两个步骤综合起来看，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将<strong><u>立即变得对读线程B可见</u></strong>。</p>
<ul>
<li>·线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<h4 id="volatile内存语义的实现">4.4 volatile内存语义的实现</h4>
<p>JMM针对<strong>编译器</strong>制定的volatile重排序规则：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/volatileReorderRule.PNG" alt="volatile重排序规则表" /><figcaption aria-hidden="true">volatile重排序规则表</figcaption>
</figure>
<ul>
<li>当<strong>第二个操作是volatile写</strong>时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li>
<li>当<strong>第一个操作是volatile读</strong>时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当<strong>第一个操作是volatile写，第二个操作是volatile读</strong>时，不能重排序。</li>
</ul>
<p>JMM采取保守策略插入内存屏障：</p>
<ul>
<li>在每个volatile写操作的<strong>前面</strong>插入一个<code>StoreStore</code>屏障。</li>
<li>在每个volatile写操作的<strong>后面</strong>插入一个<code>StoreLoad</code>屏障。</li>
<li>在每个volatile读操作的<strong>后面</strong>插入一个<code>LoadLoad</code>屏障。</li>
<li>在每个volatile读操作的<strong>后面</strong>插入一个<code>LoadStore</code>屏障。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/volatileWrite.PNG" alt="volatile写指令序列" /><figcaption aria-hidden="true">volatile写指令序列</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/volatileRead.PNG" alt="volatile读指令序列" /><figcaption aria-hidden="true">volatile读指令序列</figcaption>
</figure>
<p>在实际执行时，只要不改变 volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。</p>
<h3 id="锁的内存语义">5. 锁的内存语义</h3>
<h4 id="锁的释放-获取建立的happens-before关系">5.1 锁的释放-获取建立的happens-before关系</h4>
<p>锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123; <span class="comment">// 1</span></span><br><span class="line">        a++; <span class="comment">// 2</span></span><br><span class="line">    &#125; <span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123; <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">int</span> i = a; <span class="comment">// 5</span></span><br><span class="line">        ……</span><br><span class="line">    &#125; <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设线程A执行<code>writer()</code>方法，随后线程B执行<code>reader()</code>方法。根据happens-before规则，这个过程包含的happens-before关系可以分为3类。</p>
<ol type="1">
<li>根据<strong>程序次序规则</strong>，<strong>1</strong> <code>happens-before</code> <strong>2</strong>, <strong>2</strong> <code>happens-before</code> <strong>3</strong>; <strong>4</strong> <code>happens-before</code> <strong>5</strong>,<strong>5</strong> <code>happens-before</code> <strong>6</strong>。</li>
<li>根据<strong>监视器锁规则</strong>，<strong>3</strong> <code>happens-before</code> <strong>4</strong>。</li>
<li>根据<strong>happens-before的传递性</strong>，<strong>2</strong> <code>happens-before</code> <strong>5</strong>。</li>
</ol>
<h4 id="锁的释放和获取的内存语义">5.2 锁的释放和获取的内存语义</h4>
<ul>
<li>当线程<strong>释放锁</strong>时，JMM会<u><strong>把该线程对应的本地内存中的共享变量刷新到主内存中</strong></u>。</li>
<li>当线程<strong>获取锁</strong>时，JMM会<strong><u>把该线程对应的本地内存置为无效</u></strong>。从而使得被监视器保护的临界区代码<strong><u>必须从主内存中读取共享变量</u></strong>。</li>
</ul>
<h4 id="锁内存语义的实现">5.3 锁内存语义的实现</h4>
<p>在<code>ReentrantLock</code>中，调用<code>lock()</code>方法获取锁；调用<code>unlock()</code>方法释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	a++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    	lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = a;</span><br><span class="line">            ……</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReentrantLock</code>的实现依赖于Java同步器框架<code>AbstractQueuedSynchronizer</code>（<code>AQS</code>）。<code>AQS</code>使用一个<strong>整型的volatile变量</strong>（命名为state）来维护同步状态。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/ReentrantLockPKG.PNG" alt="ReentrantLock的类图" /><figcaption aria-hidden="true">ReentrantLock的类图</figcaption>
</figure>
<p><code>ReentrantLock</code>分为<code>公平锁</code>和<code>非公平锁</code>。</p>
<h5 id="公平锁">5.3.1 公平锁</h5>
<p>使用<code>公平锁</code>时，加锁方法<code>lock()</code>调用轨迹为：</p>
<ol type="1">
<li><code>ReentrantLock:lock()</code>；</li>
<li><code>FairSync:lock()</code>；</li>
<li><code>AbstractQueuedSynchronizer:acquire(int arg)</code>；</li>
<li><code>ReentrantLock:tryAcquire(int acquires)</code>，真正开始加锁，加锁方法首先<strong>读</strong>volatile变量<code>state</code>；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">// 获取锁的开始，首先读volatile变量state</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个锁，使用CAS操作进行加锁</span></span><br><span class="line">        <span class="keyword">if</span> (isFirst(current) &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 已经获取过锁</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 增加锁数量</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 超出锁的数量，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公平锁解锁方法<code>unlock()</code>调用轨迹为：</p>
<ol type="1">
<li><code>ReentrantLock:unlock()</code>；</li>
<li><code>AbstractQueuedSynchronizer:release(int arg)</code>；</li>
<li><code>Sync:tryRelease(int releases)</code>，真正开始释放锁，释放锁的最后<strong>写</strong>volatile变量<code>state</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读volatile变量state，尝试释放</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程未获取锁，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// c == 0 该线程所有锁已经释放</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    	free = <span class="keyword">true</span>;</span><br><span class="line">    	setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放锁的最后，写volatile变量state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据<code>volatile</code>的happens-before规则：释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。</p>
<h5 id="非公平锁">5.3.2 非公平锁</h5>
<p>非公平锁加锁方法<code>lock()</code>调用轨迹为：</p>
<ol type="1">
<li><code>ReentrantLock:lock()</code>；</li>
<li><code>NonfairSync:lock()</code>；</li>
<li><code>AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)</code>，真正开始加锁，以<strong>原子操作</strong>的方式更新state变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值</span></span><br><span class="line">	<span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非公平锁的释放和公平锁完全一样。</p>
<ul>
<li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li>
<li>公平锁获取时，首先会去读volatile变量。</li>
<li>非公平锁获取时，首先会用<code>CAS</code>更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。</li>
</ul>
<p>为了同时实现<code>volatile读</code>和<code>volatile写的</code>内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。</p>
<p><strong>锁释放-获取</strong>的内存语义的实现至少有下面两种方式：</p>
<ul>
<li>利用volatile变量的写-读所具有的内存语义。</li>
<li>利用<code>CAS</code>所附带的volatile读和volatile写的内存语义。</li>
</ul>
<h4 id="concurrent包的实现">5.4 concurrent包的实现</h4>
<p>由于Java的<code>CAS</code>同时具有<code>volatile读</code>和<code>volatile写</code>的内存语义，因此Java线程之间的通信有4种方式：</p>
<ul>
<li>A线程写volatile变量，随后B线程读这个volatile变量。</li>
<li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li>
</ul>
<p>Java的<code>CAS</code>会使用现代处理器上提供的高效机器级别的<strong>原子指令</strong>，这些原子指令以原子方式对内存执行<code>读-改-写操作</code>。<code>concurrent</code>包一个通用化的实现模式：</p>
<ul>
<li>首先，声明共享变量为volatile。</li>
<li>然后，使用CAS的原子条件更新来实现线程之间的<strong>同步</strong>。</li>
<li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的<strong>通信</strong>。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/concurrentPackage.PNG" alt="concurrent包的实现示意图" /><figcaption aria-hidden="true">concurrent包的实现示意图</figcaption>
</figure>
<h3 id="final域的内存语义">6. final域的内存语义</h3>
<h4 id="final域的重排序规则">6.1 final域的重排序规则</h4>
<p>对于<code>final</code>域，编译器和处理器要遵守两个重排序规则。</p>
<ol type="1">
<li>在<strong>构造函数</strong>内对一个<code>final</code>域的<strong>写入</strong>，与随后<u>把这个被构造对象的引用赋值给一个引用变量</u>，这两个操作之间不能重排序。</li>
<li><strong>初次读</strong>一个<u>包含<code>final</code>域的对象的引用</u>，与随后<strong>初次读</strong>这个<u><code>final</code>域</u>，这两个操作之间不能重排序。</li>
</ol>
<h4 id="写final域的重排序规则">6.2 写final域的重排序规则</h4>
<p>写final域的重排序规则<u>禁止把final域的写重排序到<strong>构造函数</strong>之外</u>。</p>
<ol type="1">
<li>JMM禁止编译器把final域的写重排序到构造函数之外。</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个<code>StoreStore</code>屏障。这个屏障<u>禁止处理器把final域的写重排序到构造函数之外</u>。</li>
</ol>
<p>写final域的重排序规则可以确保：<u>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了</u>，而普通域不具有这个保障。</p>
<h4 id="读final域的重排序规则">6.3 读final域的重排序规则</h4>
<p>读final域的重排序规则是，在一个线程中，<u>初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作</u>。</p>
<ul>
<li>编译器会在读final域操作的前面插入一个<code>LoadLoad</code>屏障。</li>
</ul>
<p>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在<strong>间接依赖关系</strong>。</p>
<p>读final域的重排序规则可以确保：<u>在读一个对象的final域之前，一定会先读包含这个final 域的对象的引用</u>。</p>
<h4 id="final域为引用类型">6.4 final域为引用类型</h4>
<p>对于<code>引用类型</code>，写final域的重排序规则对编译器和处理器<strong>增加了</strong>如下约束：</p>
<ul>
<li>在<strong>构造函数</strong>内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
</ul>
<p>JMM可以确保读final引用对象时，至少能看到<strong>构造函数</strong>中<u>对final引用对象的成员域的写入</u>。(可以理解为<strong><u>构造函数</u></strong>中对引用对象的操作看作一个整体)。</p>
<h4 id="final引用不能从构造函数内逸出">6.5 final引用不能从构造函数内<code>“逸出”</code></h4>
<p>要实现<code>“在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了”</code>， 还需要一个前提：</p>
<ul>
<li>在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中<code>“逸出”</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>; <span class="comment">// 1写final域</span></span><br><span class="line">        obj = <span class="keyword">this</span>; <span class="comment">// 2 this引用在此"逸出"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">new</span> FinalReferenceEscapeExample ();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123; <span class="comment">// 3</span></span><br><span class="line">        	<span class="keyword">int</span> temp = obj.i; <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="final语义在处理器中的实现">6.6 final语义在处理器中的实现</h4>
<ul>
<li>写final域的重排序规则会要求编译器在final域的写之后，构造函数return之前插入一个<code>StoreStore</code>障屏。</li>
<li>读final域的重排序规则要求编译器在读final域的操作前面插入一个<code>LoadLoad</code>屏障。</li>
</ul>
<h3 id="happens-before-1">7. happens-before</h3>
<h4 id="jmm的设计">7.1 JMM的设计</h4>
<p><strong>JSR-133专家组</strong>在设计JMM时的核心目标就是找到一个好的平衡点：</p>
<ul>
<li>一方面，要为程序员提供足够强的内存可见性保证；</li>
<li>另一方面，对编译器和处理器的限制要尽可能地放松。</li>
</ul>
<p>JMM对这两种不同性质的重排序，采取了不同的策略：</p>
<ul>
<li>对于<strong><u>会改变程序执行结果的重排序</u></strong>，JMM要求编译器和处理器<strong>必须禁止</strong>这种重排序。</li>
<li>对于<strong><u>不会改变程序执行结果的重排序</u></strong>，JMM对编译器和处理器不做要求（JMM<u>允许</u>这种重排序）。</li>
</ul>
<h4 id="happens-before的定义">7.2 happens-before的定义</h4>
<p><code>《JSR-133:Java Memory Model and Thread Specification》</code>对happens-before关系的定义如下。</p>
<ol type="1">
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。</li>
</ol>
<p><code>as-if-serial</code>语义和<code>happens-before</code>的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</p>
<h4 id="happens-before规则">7.3 happens-before规则</h4>
<p><code>《JSR-133:Java Memory Model and Thread Specification》</code>定义了如下<code>happens-before</code>规则：</p>
<ol type="1">
<li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ol>
<h3 id="双重检查锁定与延迟初始化">8. 双重检查锁定与延迟初始化</h3>
<p><strong>双重检查锁定</strong>是常见的<strong>延迟初始化</strong>技术，但它是一个<u>错误</u>的用法。</p>
<h4 id="双重检查锁定的由来">8.1 双重检查锁定的由来</h4>
<p>有时候可能需要推迟一些<strong><u>高开销</u></strong>的对象初始化操作，并且只有在使用这些对象时才进行初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非线程安全的延迟初始化对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeLazyInitialization</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">// 1：A线程执行</span></span><br><span class="line">        	instance = <span class="keyword">new</span> Instance(); <span class="comment">// 2：B线程执行</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以对getInstance()方法做同步处理来实现线程安全的延迟初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeLazyInitialization</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronized将导致性能开销</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">// 1：A线程执行</span></span><br><span class="line">        	instance = <span class="keyword">new</span> Instance(); <span class="comment">// 2：B线程执行</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>早期的JVM中<code>synchronized</code>（甚至是<u>无竞争</u>的<code>synchronized</code>）存在巨大的性能开销。因此，人们想通过<code>双重检查锁定（Double-Checked Locking）</code>来降低同步的开销：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLocking</span> </span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance; <span class="comment">// 2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 4:第一次检查</span></span><br><span class="line">        	<span class="keyword">synchronized</span> (DoubleCheckedLocking<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">// 5:加锁</span></span><br><span class="line">        		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">// 6:第二次检查</span></span><br><span class="line">        			instance = <span class="keyword">new</span> Instance(); <span class="comment">// 7:问题的根源出在这里</span></span><br><span class="line">        	&#125; <span class="comment">// 8</span></span><br><span class="line">        &#125; <span class="comment">// 9</span></span><br><span class="line">        <span class="keyword">return</span> instance; <span class="comment">// 10</span></span><br><span class="line">    &#125; <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果第一次检查instance不为null，那么就<u>不需要执行下面的加锁和初始化操作</u>。因此，可以大幅降低<code>synchronized</code>带来的性能开销。<code>但这是一个错误的优化！</code>在线程执行到第4行，代码读取到instance不为null时，<u><strong>instance引用的对象有可能还没有完成初始化</strong></u>。</p>
<p>双重检查锁定的第7行（<code>instance = new Instance();</code>）创建了一个对象。这一行代码可以分解为3行伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">// 1：分配对象的内存空间</span></span><br><span class="line">ctorInstance(memory); <span class="comment">// 2：初始化对象</span></span><br><span class="line">instance = memory; <span class="comment">// 3：设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure>
<p>上面3行伪代码中的2和3之间，可能会被重排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">// 1：分配对象的内存空间</span></span><br><span class="line">instance = memory; 	<span class="comment">// 3：设置instance指向刚分配的内存地址</span></span><br><span class="line">					<span class="comment">// 注意，此时对象还没有被初始化！</span></span><br><span class="line">ctorInstance(memory); <span class="comment">// 2：初始化对象</span></span><br></pre></td></tr></table></figure>
<p>如果发生重排序，另一个并发执行的线程B就有可能访问到未被A线程初始化的instance对象：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter3/DoubleCheckedLock.PNG" alt="双重检查锁定问题的根源" /><figcaption aria-hidden="true">双重检查锁定问题的根源</figcaption>
</figure>
<p>本质上还是因为创建了一个对象的过程是非原子性的。</p>
<h4 id="基于volatile的解决方案">8.2 基于volatile的解决方案</h4>
<p>基于<code>volatile</code>可以禁止2和3重排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeDoubleCheckedLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">synchronized</span> (SafeDoubleCheckedLocking<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    			<span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">    				instance = <span class="keyword">new</span> Instance(); <span class="comment">// instance为volatile，现在没问题了</span></span><br><span class="line">    			&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于类初始化的解决方案">8.3 基于类初始化的解决方案</h4>
<p>允许2和3重排序，但不允许其他线程“看到”这个重排序。</p>
<p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会去获取一个锁。基于这个特性，可以实现另一种线程安全的延迟初始化方案：<code>Initialization On Demand Holder idiom</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> Instance instance = <span class="keyword">new</span> Instance();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> InstanceHolder.instance ; <span class="comment">// 这里将导致InstanceHolder类被初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化一个类，包括执行这个类的<strong>静态初始化</strong>和初始化在这个类中声明的<strong>静态字段</strong>。根据Java语言规范，在<code>首次发生</code>下列任意一种情况时，一个类或接口类型<code>T</code>将被立即初始化。</p>
<ol type="1">
<li><code>T</code>是一个类，而且一个<code>T</code>类型的实例被创建。</li>
<li><code>T</code>是一个类，且<code>T</code>中声明的一个静态方法被调用。</li>
<li><code>T</code>中声明的一个静态字段被赋值。</li>
<li><code>T</code>中声明的一个静态字段被使用，而且<u><strong>这个字段不是一个常量字段</strong></u>。</li>
<li><code>T</code>是一个顶级类（Top Level Class），而且一个<strong>断言语句</strong>嵌套在<code>T</code>内部被执行。</li>
</ol>
<p>Java语言规范规定，对于每一个类或接口都有一个唯一的初始化锁与之对应。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了。Java初始化一个类或接口的处理过程如下：</p>
<ul>
<li>第1阶段：通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化。这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。</li>
<li>第2阶段：线程A执行类的初始化，同时线程B在初始化锁对应的condition上等待。</li>
<li>第3阶段：线程A设置state=initialized，然后唤醒在condition中等待的所有线程。</li>
<li>第4阶段：线程B结束类的初始化处理。</li>
<li>第5阶段：线程C执行类的初始化的处理。在第3阶段之后，类已经完成了初始化。因此线程C在第5阶段的类初始化处理过程相对简单一些（线程C的类初始化处理只需要经历一次锁获取-锁释放）。</li>
</ul>
<p>字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。在大多数时候，正常的初始化要优于延迟初始化。</p>
<h3 id="java内存模型综述">9. Java内存模型综述</h3>
<h4 id="处理器的内存模型">9.1 处理器的内存模型</h4>
<p>根据<u><strong>对不同类型的读/写操作组合的执行顺序的放松</strong></u>，可以把常见处理器的内存模型划分为如下几种类型。</p>
<ul>
<li>放松程序中<code>写-读操作</code>的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）。</li>
<li>在上面的基础上，继续放松程序中<code>写-写操作</code>的顺序，由此产生了Partial Store Order内存模型（简称为PSO）。</li>
<li>在前面两条的基础上，继续放松程序中<code>读-写</code>和<code>读-读</code>操作的顺序，由此产生了Relaxed Memory Order内存模型（简称为RMO）和PowerPC内存模型。</li>
</ul>
<h4 id="jmm的内存可见性保证">9.2 JMM的内存可见性保证</h4>
<p>按程序类型，Java程序的内存可见性保证可以分为下列3类。</p>
<ul>
<li><strong>单线程程序</strong>。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>
<li><strong>正确同步的多线程程序</strong>。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。</li>
<li><strong>未同步/未正确同步的多线程程序</strong>。JMM为它们提供了<u>最小安全性保障</u>：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。</li>
</ul>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Java并发编程的艺术]--6 Java并发容器和框架</title>
    <url>/2021/07/20/JavaLearning_The_art_of_concurrent_programming_in_Java-6-Java-concurrent-container-and-framework.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>并发编程大师Doug Lea不遗余力地为Java开发者提供了非常多的并发容器和框架</code> <a id="more"></a></p>
</blockquote>
<h3 id="concurrenthashmap的实现原理">1. <code>ConcurrentHashMap</code>的实现原理</h3>
<p>在并发编程中使用<code>HashMap</code>可能导致程序死循环，而使用线程安全的<code>HashTable</code>效率又非常低下。<code>ConcurrentHashMap</code>是线程安全且高效的<code>HashMap</code>。</p>
<ul>
<li><p><strong>线程不安全的<code>HashMap</code></strong>。在多线程环境下，使用<code>HashMap</code>进行<code>put</code>操作会引起死循环。</p></li>
<li><p><strong>效率低下的<code>HashTable</code></strong>。<code>HashTable</code>容器使用<code>synchronized</code>来保证线程安全，但在线程竞争激烈的情况下<code>HashTable</code>的效率非常低下。</p></li>
<li><p><code>ConcurrentHashMap</code>的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p></li>
</ul>
<h4 id="concurrenthashmap的结构">1.1 <code>ConcurrentHashMap</code>的结构</h4>
<p><code>ConcurrentHashMap</code>是由<code>Segment</code>数组结构和<code>HashEntry</code>数组结构组成。</p>
<ul>
<li><code>Segment</code>是一种<strong>可重入锁</strong>（<code>ReentrantLock</code>），一个<code>ConcurrentHashMap</code>里包含一个<code>Segment</code>数组；
<ul>
<li><code>Segment</code>的结构和<code>HashMap</code>类似，是一种<strong>数组和链表结构</strong>；</li>
<li>一个<code>Segment</code>里包含一个<code>HashEntry</code>数组，每个<code>Segment</code>守护着一个<code>HashEntry</code>数组里的元素，当对<code>HashEntry</code>数组的数据进行修改时，必须首先获得与它对应的<code>Segment</code>锁。</li>
</ul></li>
<li><code>HashEntry</code>则用于存储键值对数据，每个<code>HashEntry</code>是一个<strong>链表结构</strong>的元素。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentHashMapClass.PNG" alt="ConcurrentHashMap类图" /><figcaption aria-hidden="true">ConcurrentHashMap类图</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentHashMapStructure.PNG" alt="ConcurrentHashMap结构" /><figcaption aria-hidden="true">ConcurrentHashMap结构</figcaption>
</figure>
<h4 id="concurrenthashmap的初始化">1.2 <code>ConcurrentHashMap</code>的初始化</h4>
<p><code>ConcurrentHashMap</code>初始化方法是通过<code>initialCapacity</code>、<code>loadFactor</code>和<code>concurrencyLevel</code>等几个参数来初始化<code>segment</code>数组、段偏移量<code>segmentShift</code>、段掩码<code>segmentMask</code>和每个<code>segment</code>里的<code>HashEntry</code>数组来实现的。</p>
<h5 id="初始化segments数组">1.2.1 初始化<code>segments</code>数组</h5>
<p><code>segments</code>数组的长度<code>ssize</code>是通过<code>concurrencyLevel</code>计算得出的：</p>
<ul>
<li>为了能通过<code>按位与的散列算法</code>来定位<code>segments</code>数组的索引，必须保证<code>segments</code>数组的长度是<code>2</code>的<code>N</code>次方，所以必须计算出一个大于或等于<code>concurrencyLevel</code>的最小的2的N次方值来作为<code>segments</code>数组的长度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">	concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure>
<h5 id="初始化segmentshift和segmentmask">1.2.2 初始化<code>segmentShift</code>和<code>segmentMask</code></h5>
<p>这两个全局变量需要在定位<code>segment</code>时的散列算法里使用：</p>
<ul>
<li><code>sshift</code>等于<code>ssize</code>从1向左移位的次数。<code>segmentShift</code>用于<u><strong>定位参与散列运算的位数</strong></u>，<code>segmentShift</code>等于<code>32</code>减<code>sshift</code>，这里之所以用32是因为<code>ConcurrentHashMap</code>里的<code>hash()</code>方法输出的最大数是32位的。</li>
<li><code>segmentMask</code>是散列运算的掩码，等于<code>ssize</code>减<code>1</code>，掩码的二进制各个位的值都是<code>1</code>。</li>
</ul>
<h5 id="初始化每个segment">1.2.3 初始化每个<code>segment</code></h5>
<p>输入参数<code>initialCapacity</code>是<code>ConcurrentHashMap</code>的<strong>初始化容量</strong>，<code>loadfactor</code>是每个<code>segment</code>的<strong>负载因子</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">	initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">	++c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">	cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line">	<span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);</span><br></pre></td></tr></table></figure>
<ul>
<li>变量<code>cap</code>是<code>segment</code>里<code>HashEntry</code>数组的长度，它等于<code>initialCapacity</code>除以<code>ssize</code>的倍数<code>c</code>。</li>
<li><code>segment</code>的容量<code>threshold＝（int）cap*loadFactor</code>。</li>
</ul>
<h4 id="定位segment">1.3 定位<code>Segment</code></h4>
<p>在<strong>插入和获取</strong>元素的时候，必须先通过散列算法定位到<code>Segment</code>。</p>
<ul>
<li><code>ConcurrentHashMap</code>会首先使用<code>Wang/Jenkins hash</code>的变种算法对元素的<code>hashCode</code>进行一次再散列。目的是<strong><u>减少散列冲突</u></strong>，使元素能够均匀地分布在不同的<code>Segment</code>上， 从而提高容器的存取效率。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种再散列能让数字的每一位都参加到散列运算当中，从而减少散列冲突。<code>ConcurrentHashMap</code>通过以下散列算法定位<code>segment</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="concurrenthashmap的操作">1.4 <code>ConcurrentHashMap</code>的操作</h4>
<h5 id="get操作">1.4.1 <code>get</code>操作</h5>
<p><code>Segment</code>的<code>get</code>操作先经过一次再散列，然后使用这个散列值通过散列运算定位到<code>Segment</code>，再通过散列算法定位到元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">	<span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get</code>操作的高效之处在于<u><strong>整个<code>get</code>过程不需要加锁，除非读到的值是空才会加锁重读</strong></u>。</p>
<ul>
<li><p><code>get</code>方法里将要使用的共享变量都定义成<code>volatile</code>类型，如用于统计当前<code>Segement</code>大小的<code>count</code>字段和用于存储值的<code>HashEntry</code>的<code>value</code>。这是用volatile替换锁的经典应用场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">volatile</span> V value;</span><br></pre></td></tr></table></figure></li>
<li><p>定位<code>Segment</code>使用的是元素的<code>hashcode</code>通过再散列后得到的值的高位，而定位<code>HashEntry</code>直接使用的是再散列后的值。其目的是避免两次散列后的值一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask <span class="comment">// 定位Segment所使用的hash算法</span></span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); <span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="put操作">1.4.2 <code>put</code>操作</h5>
<p><code>put</code>方法首先定位到<code>Segment</code>，然后在<code>Segment</code>里进行插入操作。插入操作需要经历两个步骤</p>
<ul>
<li>第一步判断是否需要对<code>Segment</code>里的<code>HashEntry</code>数组进行扩容；
<ul>
<li>在<strong><u>插入元素前</u></strong>先判断<code>Segment</code>里的<code>HashEntry</code>数组是否超过<code>容量（threshold）</code>，如果超过阈值，则对数组进行扩容。扩容的时候首先会创建一个容量是<strong><u>原来容量两倍</u></strong>的数组，然后将原数组里的元素进行<u><strong>再散列后插入</strong></u>到新的数组里。</li>
<li><code>HashMap</code>是在<strong><u>插入元素后</u></strong>判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时<code>HashMap</code>就进行了一次无效的扩容。</li>
</ul></li>
<li>第二步定位添加元素的位置，然后将其放在<code>HashEntry</code>数组里。</li>
</ul>
<h5 id="size操作">1.4.3 <code>size</code>操作</h5>
<p><code>ConcurrentHashMap</code>统计<code>size</code>时，先尝试<code>2</code>次通过<strong>不锁住</strong><code>Segment</code>的方式来统计各个<code>Segment</code>大小，如果统计的过程中，容器的<code>count</code>发生了变化，则再采用<strong>加锁</strong>的方式来统计所有<code>Segment</code>的大小。</p>
<h3 id="concurrentlinkedqueue">2. <code>ConcurrentLinkedQueue</code></h3>
<p>实现一个线程安全的队列有两种方式：</p>
<ul>
<li><strong>使用阻塞算法</strong>。用一个<strong>锁</strong>（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</li>
<li><strong>使用非阻塞算法</strong>。使用循环<code>CAS</code>的方式来实现。</li>
</ul>
<p><code>ConcurrentLinkedQueue</code>是一个基于链接节点的<strong>无界线程安全队列</strong>。它采用了<code>“wait-free”算法</code>（即<code>CAS</code>算法）来实现。</p>
<h4 id="concurrentlinkedqueue的结构">2.1 <code>ConcurrentLinkedQueue</code>的结构</h4>
<p><code>ConcurrentLinkedQueue</code>由<code>head</code>节点和<code>tail</code>节点组成。</p>
<ul>
<li>每个节点（Node）由节点元素（item）和 指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一 张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail = head;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentLinkedQueueClass.PNG" alt="ConcurrentLinkedQueue类图" /><figcaption aria-hidden="true">ConcurrentLinkedQueue类图</figcaption>
</figure>
<h4 id="入队列">2.2 入队列</h4>
<h5 id="入队列的过程">2.2.1 入队列的过程</h5>
<p>入队列就是将入队节点添加到队列的尾部。入队主要做两件事情：</p>
<ul>
<li>将<strong>入队节点</strong>设置成当前队列尾节点的下一个节点；</li>
<li>更新<code>tail</code>节点，如果<code>tail</code>节点的<code>next</code>节点不为空，则将入队节点设置成<code>tail</code>节点，如果<code>tail</code>节点的<code>next</code>节点为空，则将入队节点设置成<code>tail</code>的<code>next</code>节点，<u><strong>所以<code>tail</code>节点不总是尾节点</strong></u>。</li>
</ul>
<p>多个线程同时进行入队操作时，使用<code>CAS</code>算法来入队：</p>
<ul>
<li>首先定位出尾节点；</li>
<li>然后使用<code>CAS</code>算法将入队节点设置成尾节点的<code>next</code>节点，如不成功则重试。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 入队前，创建一个入队节点</span></span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    </span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 死循环，入队不成功反复入队。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 创建一个指向tail节点的引用</span></span><br><span class="line">        Node&lt;E&gt; t = tail;</span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class="line">        Node&lt;E&gt; p = t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">            <span class="comment">// 获得p节点的下一个节点。</span></span><br><span class="line">            Node&lt;E&gt; next = succ(p);</span><br><span class="line">            <span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;</span><br><span class="line">                <span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</span></span><br><span class="line"><span class="comment">                  更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt;= HOPS)</span><br><span class="line">                    casTail(t, n); <span class="comment">// 更新tail节点，允许失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = succ(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>入队方法永远返回<code>true</code>，所以不要通过返回值判断入队是否成功。</p>
</blockquote>
<h5 id="定位尾节点">2.2.2 定位尾节点</h5>
<p><code>tail</code>节点并不总是尾节点，所以每次入队都必须先通过<code>tail</code>节点来找到尾节点。</p>
<blockquote>
<p>尾节点可能是<code>tail</code>节点，也可能是<code>tail</code>节点的<code>next</code>节点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">	Node&lt;E&gt; next = p.getNext();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取tail节点的next节点需要注意的是 p 节点等于 p 的 next 节点的情况，</span></span><br><span class="line"><span class="comment">     * 此时p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="设置入队节点为尾节点">2.2.3 设置入队节点为尾节点</h5>
<p><code>p.casNext(null，n)</code>方法用于将入队节点设置为当前队列尾节点的<code>next</code>节点：</p>
<ul>
<li>如果<code>p</code>是<code>null</code>， 表示<code>p</code>是当前队列的尾节点；</li>
<li>如果不为<code>null</code>，表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</li>
</ul>
<h5 id="hops的设计">2.2.4 <code>HOPS</code>的设计</h5>
<p>使用<code>hops</code>变量来<strong><u>控制并减少<code>tail</code>节点的更新频率</u></strong>。</p>
<ul>
<li>不是每次节点入队后都将<code>tail</code>节点更新成尾节点，而是当<code>tail</code>节点和尾节点的距离大于等于常量<code>HOPS</code>的值（默认等于1）时才更新<code>tail</code>节点。<strong><u><code>tail</code>和尾节点的距离越长，使用<code>CAS</code>更新<code>tail</code>节点的次数就会越少</u></strong>；</li>
<li>但是距离越长带来的<strong>负面效果</strong>就是<u>每次入队时定位尾节点的时间就越长</u>，因为循环体需要多循环一次来定位出尾节点。但是这样仍然能提高入队的效率，因为<u><strong>通过增加对<code>volatile</code>变量的读操作来减少对<code>volatile</code>变量的写操作</strong></u>，而对volatile变量的写操作开销要远远大于读操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOPS = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="出队列">2.3 出队列</h4>
<p><strong>出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用</strong>。与入队列类似，<u>不是每次出队时都更新<code>head</code>节点</u>，通过<code>hops</code>变量来减少使用<code>CAS</code>更新<code>head</code>节点的消耗。</p>
<ul>
<li>当<code>head</code>节点里<strong>有元素</strong>时，直接弹出<code>head</code>节点里的元素，而不会更新<code>head</code>节点。</li>
<li>只有当<code>head</code>节点里<strong>没有元素</strong>时，出队操作才会更新<code>head</code> 节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">// p表示头节点，需要出队的节点</span></span><br><span class="line">    Node&lt;E&gt; p = h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">        <span class="comment">// 获取p节点的元素</span></span><br><span class="line">        E item = p.getItem();</span><br><span class="line">        <span class="comment">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</span></span><br><span class="line">        <span class="comment">// 如果成功则返回p节点的元素。</span></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hops &gt;= HOPS) &#123;</span><br><span class="line">                <span class="comment">// 将p节点下一个节点设置成head节点</span></span><br><span class="line">                Node&lt;E&gt; q = p.getNext();</span><br><span class="line">                updateHead(h, (q != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</span></span><br><span class="line">        <span class="comment">// 一个线程修改了。那么获取p节点的下一个节点</span></span><br><span class="line">        Node&lt;E&gt; next = succ(p);</span><br><span class="line">        <span class="comment">// 如果p的下一个节点也为空，说明这个队列已经空了</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 更新头节点。</span></span><br><span class="line">            updateHead(h, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span></span><br><span class="line">        p = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个线程同时进行出队操作时，使用<code>CAS</code>算法来出队：</p>
<ul>
<li>首先获取<strong>头节点的元素</strong>，然后判断<strong>头节点元素</strong>是否为空；</li>
<li>如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走；</li>
<li>如果不为空，则使用<code>CAS</code>的方式将头节点的引用设置成<code>null</code>；
<ul>
<li>如果<code>CAS</code>成功，则直接返回头节点的元素；</li>
<li>如果不成功，表示另外一个线程已经进行了一次出队操作更新了<code>head</code>节点，需要重新获取头节点。</li>
</ul></li>
</ul>
<h3 id="java中的阻塞队列">3. Java中的阻塞队列</h3>
<h4 id="阻塞队列介绍">3.1 阻塞队列介绍</h4>
<p><code>阻塞队列（BlockingQueue）</code>支持阻塞的插入和移除方法。</p>
<ul>
<li><strong>支持阻塞的插入方法</strong>：当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>
<li><strong>支持阻塞的移除方法</strong>：在队列为空时，获取元素的线程会等待队列变为非空。</li>
</ul>
<p>在阻塞队列不可用时，这两个附加操作提供了4种处理方式：</p>
<ul>
<li><strong>抛出异常</strong>：当队列满时，如果再往队列里插入元素，会抛出<code>IllegalStateException("Queue full")</code>异常。当队列空时，从队列里获取元素会抛出<code>NoSuchElementException</code>异常。主要方法有：<code>add(e), remove(), element()</code>。</li>
<li><strong>返回特殊值</strong>：当往队列插入元素时，会返回元素是否插入成功，成功返回<code>true</code>。如果是移除方法，则是从队列里取出一个元素，如果没有则返回<code>null</code>。主要方法有：<code>offer(e), poll(), peek()</code>。</li>
<li><strong>一直阻塞</strong>：当阻塞队列满时，如果生产者线程往队列里<code>put</code>元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里<code>take</code>元素，队列会阻塞住消费者线程，直到队列不为空。主要方法有：<code>put(e), take()</code>。</li>
<li><strong>超时退出</strong>：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。主要方法有：<code>offer(e, time, unit), poll(time, unit)</code>。</li>
</ul>
<blockquote>
<p>无界阻塞队列<strong>不可能会出现满</strong>的情况，所以使用<code>put</code>或<code>offer</code>方法永远不会被阻塞，而且使用<code>offer</code>方法时，该方法永远返回<code>true</code>。</p>
</blockquote>
<h4 id="java里的阻塞队列">3.2 Java里的阻塞队列</h4>
<p><code>JDK 7</code>提供了<code>7</code>个阻塞队列。</p>
<h5 id="arrayblockingqueue">3.2.1 <code>ArrayBlockingQueue</code></h5>
<p>一个由<strong><u>数组结构</u></strong>组成的<strong>有界</strong>阻塞队列，默认情况下不保证线程公平的访问队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="linkedblockingqueue">3.2.2 <code>LinkedBlockingQueue</code></h5>
<p>一个由<strong><u>链表结构</u></strong>组成的<strong>有界</strong>阻塞队列。此队列的默认和最大长度为<code>Integer.MAX_VALUE</code>。</p>
<h5 id="priorityblockingqueue">3.2.3 <code>PriorityBlockingQueue</code></h5>
<p>一个<strong><u>支持优先级排序</u></strong>的<strong>无界</strong>阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现<code>compareTo()</code>方法来指定元素排序规则，或者初始化<code>PriorityBlockingQueue</code>时，指定构造参数<code>Comparator</code>来对元素进行排序。</p>
<blockquote>
<p>不能保证同优先级元素的顺序。</p>
</blockquote>
<h5 id="delayqueue">3.2.4 <code>DelayQueue</code></h5>
<p>一个使用<u><strong>优先级队列(<code>PriorityQueue</code>)</strong></u>实现的<strong>无界</strong>阻塞队列，支持<strong><u>延时获取元素</u></strong>。</p>
<ul>
<li>队列中的元素必须实现<code>Delayed</code>接口，在创建元素时可以指定多久才能从队列中获取当前元素。</li>
<li>只有在延迟期满时才能从队列中提取元素。</li>
</ul>
<h6 id="delayed接口实现">3.2.4.1 <code>Delayed</code>接口实现</h6>
<p>参考<code>ScheduledThreadPoolExecutor</code>里<code>ScheduledFutureTask</code>类的实现。</p>
<ul>
<li>第一步：在对象创建的时候，初始化基本数据。使用<code>time</code>记录当前对象延迟到什么时候可以使用，使用<code>sequenceNumber</code>来标识元素在队列中的先后顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步：实现<code>getDelay</code>方法，该方法返回当前元素还需要延时多长时间，单位是纳秒。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三步：实现<code>compareTo</code>方法来指定元素的顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero ONLY if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;&gt; x = (ScheduledFutureTask&lt;&gt;)other;</span><br><span class="line">        <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// othter 不是 ScheduledFutureTask 对象时</span></span><br><span class="line">    <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) - other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">    <span class="keyword">return</span> (d == <span class="number">0</span>) ? <span class="number">0</span> : ( (d &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实现延时阻塞队列">3.2.4.2 实现延时阻塞队列</h6>
<p>当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> q.poll();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">    available.await();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    Thread thisThread = Thread.currentThread();</span><br><span class="line">    leader = thisThread;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        available.awaitNanos(delay);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>leader</code>是一个<u><strong>等待获取队列头部元素的线程</strong></u>。</p>
<ul>
<li>如果<code>leader</code>不等于空，表示<u>已经有线程在等待获取队列的头元素</u>。使用<code>await()</code>方法让当前线程等待信号；</li>
<li>如果<code>leader</code>等于空，则把当前线程设置成<code>leader</code>，并使用<code>awaitNanos()</code>方法让当前线程等待接收信号或等待<code>delay</code>时间。</li>
</ul>
<h6 id="delayqueue应用场景">3.2.4.3 <code>DelayQueue</code>应用场景</h6>
<ul>
<li><strong>缓存系统的设计</strong>：用<code>DelayQueue</code>保存缓存元素的<u>有效期</u>，使用一个线程循环查询<code>DelayQueue</code>，一旦能从<code>DelayQueue</code>中获取元素时，表示缓存有效期到了。</li>
<li><strong>定时任务调度</strong>：使用<code>DelayQueue</code>保存当天将会执行的任务和执行时间，一旦从<code>DelayQueue</code>中获取到任务就开始执行，比如<code>TimerQueue</code>就是使用<code>DelayQueue</code>实现的。</li>
</ul>
<h5 id="synchronousqueue">3.2.5 <code>SynchronousQueue</code></h5>
<p>一个<strong><u>不存储元素</u></strong>的阻塞队列。每一个<code>put</code>操作<strong><u>必须等待</u></strong>一个<code>take</code>操作， 否则不能继续添加元素。默认情况下线程采用非公平性策略访问队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">	transferer = fair ? <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列本身并不存储任何元素，非常适合传递性场景。</p>
<ul>
<li><code>SynchronousQueue</code>的吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>。</li>
</ul>
<h5 id="linkedtransferqueue">3.2.6 <code>LinkedTransferQueue</code></h5>
<p>一个由<strong><u>链表结构</u></strong>组成的<strong>无界</strong>阻塞队列。<code>LinkedTransferQueue</code>增加了<code>tryTransfer</code>和<code>transfer</code>方法。</p>
<ol type="1">
<li><p><code>transfer</code>方法</p>
<ul>
<li>如果当前有消费者正在等待接收元素，<code>transfer</code>方法可以把生产者传入的元素立刻<code>transfer</code>（传输）给消费者。</li>
<li>如果没有消费者在等待接收元素，<code>transfer</code>方法会将元素存放在队列的<code>tail</code>节点，并等到该元素被消费者消费了才返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 试图把存放当前元素的s节点作为tail节点</span></span><br><span class="line">Node pred = tryAppend(s, haveData);</span><br><span class="line"><span class="comment">// 让CPU自旋等待消费者消费元素</span></span><br><span class="line"><span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br></pre></td></tr></table></figure></li>
<li><p><code>tryTransfer</code>方法</p>
<p>用来试探生产者传入的元素是否能直接传给消费者。</p>
<ul>
<li>如果没有消费者等待接收元素，则返回<code>false</code>；</li>
<li><code>tryTransfer</code>方法无论消费者是否接收，方法<u><strong>立即返回</strong></u>；<code>transfer</code>方法是<u><strong>必须等到消费者消费了才返回</strong></u>。</li>
<li>带有时间限制的<code>tryTransfer(E e, long timeout, TimeUnit unit)</code>方法，如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false；如果在超时时间内消费了元素，则返回true。</li>
</ul></li>
</ol>
<h5 id="linkedblockingdeque">3.2.7 <code>LinkedBlockingDeque</code></h5>
<p>一个由<strong><u>链表结构</u></strong>组成的<strong><u>双向</u></strong>阻塞队列。在初始化<code>LinkedBlockingDeque</code>时可以设置容量防止其过度膨胀。</p>
<blockquote>
<p>双向阻塞队列可以运用在<code>“工作窃取”模式</code>中。</p>
</blockquote>
<h4 id="阻塞队列的实现">3.3 阻塞队列的实现</h4>
<p>使用<strong><u>通知模式</u></strong>实现阻塞队列。如<code>ArrayBlockingQueue</code>使用了<code>Condition</code>来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略其他代码</span></span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        insert(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> extract();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    putIndex = inc(putIndex);</span><br><span class="line">    ++count;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阻塞生产者主要通过 <code>LockSupport.park(this)</code>来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程加入等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步状态，也就是释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 调用setBlocker先保存一下将要阻塞的线程</span></span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    <span class="comment">// 调用unsafe.park阻塞当前线程</span></span><br><span class="line">    unsafe.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unsafe.park是个native方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>park</code>方法会阻塞当前线程，只有以下4种情况中的一种发生时，该方法才会返回：</p>
<ul>
<li>与<code>park</code>对应的<code>unpark</code>执行或已经执行时。<code>“已经执行”</code>是指<u><code>unpark</code>先执行，然后再执行<code>park</code></u>的情况。</li>
<li>线程被中断时。</li>
<li>等待完<code>time</code>参数指定的毫秒数时。</li>
<li>异常现象发生时，这个异常现象没有任何原因。</li>
</ul>
<p><code>Linux</code>下使用的是系统方法<code>pthread_cond_wait</code>实现<code>park</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> os::PlatformEvent::park() &#123;</span><br><span class="line">    <span class="keyword">int</span> v ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        v = _Event ;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg (v<span class="number">-1</span>, &amp;_Event, v) == v) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    guarantee (v &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// Do this the hard way by blocking ...</span></span><br><span class="line">        <span class="keyword">int</span> status = pthread_mutex_lock(_mutex);</span><br><span class="line">        assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_lock"</span>);</span><br><span class="line">        guarantee(_nParked == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">        ++ _nParked;</span><br><span class="line">        <span class="keyword">while</span> (_Event &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// pthread_cond_wait是一个多线程的条件变量函数</span></span><br><span class="line">            status = pthread_cond_wait(_cond, _mutex);</span><br><span class="line">			<span class="comment">// for some reason, under 2.7 lwp_cond_wait() may return ETIME ...</span></span><br><span class="line">			<span class="comment">// Treat this the same as if the wait was interrupted</span></span><br><span class="line">            <span class="keyword">if</span> (status == ETIME) &#123; status = EINTR; &#125;</span><br><span class="line">            assert_status(status == <span class="number">0</span> || status == EINTR, status, <span class="string">"cond_wait"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        -- _nParked ;</span><br><span class="line">		<span class="comment">// In theory we could move the ST of 0 into _Event past the unlock(),</span></span><br><span class="line">		<span class="comment">// but then we'd need a MEMBAR after the ST.</span></span><br><span class="line">        _Event = <span class="number">0</span> ;</span><br><span class="line">        status = pthread_mutex_unlock(_mutex);</span><br><span class="line">        assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_unlock"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    guarantee (_Event &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="forkjoin框架">4. Fork/Join框架</h3>
<h4 id="forkjoin框架介绍">4.1 Fork/Join框架介绍</h4>
<p><code>Fork/Join框架</code>是<code>Java 7</code>提供的一个<strong><u>用于并行执行任务</u></strong>的框架。它<u>把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果</u>。</p>
<ul>
<li><code>Fork</code>就是把一个大任务切分为若干子任务并行的执行；</li>
<li><code>Join</code>就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li>
</ul>
<h4 id="工作窃取算法">4.2 工作窃取算法</h4>
<p><code>工作窃取（work-stealing）</code>算法是指<u><strong>某个线程从其他队列里窃取任务来执行</strong></u>。</p>
<ul>
<li>把大任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。</li>
<li>但某个线程先完成自己队列里的任务，而其他线程对应的队列里还有任务等待处理，它会去其他线程的队列里窃取一个任务来执行。</li>
<li>为了减少窃取任务线程和被窃取任务线程之间的竞争，通常使用<strong><u>双端队列</u></strong>，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</li>
</ul>
<p><strong>工作窃取算法的优点</strong>：充分利用线程进行并行计算，减少了线程间的竞争。</p>
<p><strong>工作窃取算法的缺点</strong>：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。且会消耗更多的系统资源。</p>
<h4 id="forkjoin框架的设计">4.3 Fork/Join框架的设计</h4>
<p>Fork/Join框架主要有两个步骤：</p>
<ul>
<li><strong>步骤1 分割任务</strong>。首先需要一个<code>fork类</code>来把大任务分割成子任务。</li>
<li><strong>步骤2 执行任务并合并结果</strong>。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。<u>子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据</u>。</li>
</ul>
<blockquote>
<p>很像<code>MapReduce</code>算法，都是任务分解(Map)，然后聚合结果(Reduce)</p>
</blockquote>
<p><code>Fork/Join</code>使用两个类来完成以上两件事情：</p>
<ul>
<li><code>ForkJoinTask</code>：首先创建一个<code>ForkJoin</code>任务。它提供在任务中执行<code>fork()</code>和<code>join()</code>操作的机制。一般不需要直接继承<code>ForkJoinTask</code>类，<strong>Fork/Join框架</strong>提供了两个子类。
<ul>
<li><code>RecursiveAction</code>：用于<strong><u>没有返回结果</u></strong>的任务。</li>
<li><code>RecursiveTask</code>：用于<strong><u>有返回结果</u></strong>的任务。</li>
</ul></li>
<li><code>ForkJoinPool</code>：<code>ForkJoinTask</code>需要通过<code>ForkJoinPool</code>来执行。</li>
</ul>
<h4 id="使用forkjoin框架">4.4 使用Fork/Join框架</h4>
<p><code>ForkJoinTask</code>需要实现<code>compute</code>方法，在这个方法里首先需要判断任务是否足够小：</p>
<ul>
<li>如果足够小就直接执行任务。</li>
<li>如果不足够小，就必须分割成两个子任务，每个子任务在调用<code>fork</code>方法时，又会进入<code>compute</code>方法。</li>
</ul>
<p>使用<code>join</code>方法会等待子任务执行完并得到其结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>; <span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="forkjoin框架的异常处理">4.5 Fork/Join框架的异常处理</h4>
<p><code>ForkJoinTask</code>提供了<code>isCompletedAbnormally()</code>方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过<code>ForkJoinTask</code>的<code>getException</code>方法获取异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(task.isCompletedAbnormally()) &#123;</span><br><span class="line">	System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="forkjoin框架的实现">4.6 Fork/Join框架的实现</h4>
<p><code>ForkJoinPool</code>由<code>ForkJoinTask</code>数组和<code>ForkJoinWorkerThread</code>数组组成：</p>
<ul>
<li><code>ForkJoinTask</code>数组负责将存放程序提交给<code>ForkJoinPool</code>的任务；</li>
<li><code>ForkJoinWorkerThread</code>数组负责执行这些任务。</li>
</ul>
<h5 id="forkjointask的fork方法">4.6.1 ForkJoinTask的fork方法</h5>
<p>调用<code>ForkJoinTask</code>的<code>fork</code>方法时</p>
<ul>
<li>首先调用<code>ForkJoinWorkerThread</code>的<code>pushTask</code>方法<strong><u>异步地执行</u></strong>这个任务。</li>
<li><code>pushTask</code>方法把当前任务存放在<code>ForkJoinTask</code>数组队列里。然后再调用<code>ForkJoinPool</code>的<code>signalWork()</code>方法唤醒或创建一个工作线程来执行任务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	((ForkJoinWorkerThread) Thread.currentThread()).pushTask(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pushTask</span><span class="params">(ForkJoinTask&lt;&gt; t)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;&gt;[] q; </span><br><span class="line">    <span class="keyword">int</span> s, m;</span><br><span class="line">    <span class="keyword">if</span> ((q = queue) != <span class="keyword">null</span>) &#123; <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="comment">// 计算t放到队列中的位置，即u</span></span><br><span class="line">        <span class="keyword">long</span> u = (((s = queueTop) &amp; (m = q.length - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="comment">// 加入队列</span></span><br><span class="line">        UNSAFE.putOrderedObject(q, u, t);</span><br><span class="line">        queueTop = s + <span class="number">1</span>; <span class="comment">// or use putOrderedInt</span></span><br><span class="line">        <span class="comment">// 激活或创建工作线程</span></span><br><span class="line">        <span class="keyword">if</span> ((s -= queueBase) &lt;= <span class="number">2</span>)</span><br><span class="line">            pool.signalWork();</span><br><span class="line">        <span class="comment">// 队列已满</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == m)</span><br><span class="line">            growQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="forkjointask的join方法">4.6.2 ForkJoinTask的join方法</h5>
<p><code>Join</code>方法的主要作用是阻塞当前线程并等待获取结果。</p>
<ul>
<li>首先通过<code>doJoin()</code>方法得到当前任务的状态。任务状态有4种：<code>已完成（NORMAL）</code>、<code>被取消（CANCELLED）</code>、<code>信号（SIGNAL）</code>和<code>出现异常（EXCEPTIONAL）</code>。
<ul>
<li>如果任务状态是已完成，则直接返回任务状态；</li>
<li>如果没有执行完，则从任务数组里取出任务并执行；</li>
<li>如果任务顺利执行完成，则设置任务状态为<code>NORMAL</code>；</li>
<li>如果出现异常，则记录异常，并将任务状态设置为<code>EXCEPTIONAL</code>。</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (doJoin() != NORMAL)</span><br><span class="line">        <span class="keyword">return</span> reportResult();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t; ForkJoinWorkerThread w; <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                completed = exec();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (completed)</span><br><span class="line">                <span class="keyword">return</span> setCompletion(NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w.joinTask(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> externalAwaitDone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">reportResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Throwable ex;</span><br><span class="line">    <span class="comment">// 如果任务状态是被取消，则直接抛出CancellationException</span></span><br><span class="line">    <span class="keyword">if</span> ((s = status) == CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="comment">// 如果任务状态是抛出异常，则直接抛出对应的异常</span></span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.throwException(ex);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Java并发编程的艺术]--4  Java并发编程基础</title>
    <url>/2021/07/18/JavaLearning_The_art_of_concurrent_programming_in_Java-4-Java-concurrent-programming-basics.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>线程作为操作系统调度的最小单元，多个线程能够同时执行，这将显著提升程序性能，在多核环境中表现得更加明显。</code> <a id="more"></a></p>
</blockquote>
<h3 id="线程简介">1. 线程简介</h3>
<h4 id="线程定义">1.1 线程定义</h4>
<p>现代操作系统<strong>调度的最小单元</strong>是线程，也叫<code>轻量级进程（Light Weight Process）</code>，在一个进程里可以创建多个线程，这些线程都拥有<u>各自的计数器、堆栈和局部变量</u>等属性，并且能够访问共享的内存变量。</p>
<blockquote>
<p>Java程序<u>天生就是多线程程序</u>，因为执行<code>main()</code>方法的是一个名称为main的线程。</p>
</blockquote>
<p>一个Java程序的运行是main线程和多个其他线程的同时运行。</p>
<h4 id="多线程">1.2 多线程</h4>
<p>使用多线程的原因主要有以下几点：</p>
<ol type="1">
<li><strong>更多的处理器核心</strong>。使用多线程技术将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。</li>
<li><strong>更快的响应时间</strong>。使用多线程技术，将数据一致性不强的操作派发给其他线程处理，缩短响应时间。</li>
<li><strong>更好的编程模型</strong>。</li>
</ol>
<h4 id="线程优先级">1.3 线程优先级</h4>
<p>线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。在Java线程中，通过一个整型成员变量<code>priority</code>来控制优先级，优先级的范围从<code>1~10</code>，在线程构建的时候可以通过<code>setPriority(int)</code>方法来修改优先级，默认优先级是<code>5</code>。</p>
<blockquote>
<p>优先级只是一个建议，实际执行时可能会忽略对线程优先级的设定。</p>
</blockquote>
<h4 id="线程的状态">1.4 线程的状态</h4>
<p>Java线程在运行的生命周期中可能处于<code>6</code>种不同的状态，且在给定的一个时刻，线程<u><strong>只能处于其中的一个状态</strong></u>：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter4/threadState.PNG" alt="线程状态" /><figcaption aria-hidden="true">线程状态</figcaption>
</figure>
<p>可以使用<code>jps</code>查看进程<code>ID</code>，然后用<code>"jstack 进程ID"</code>查看运行时的线程信息。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter4/threadStateChange.PNG" alt="Java线程状态变迁" /><figcaption aria-hidden="true">Java线程状态变迁</figcaption>
</figure>
<h4 id="daemon线程">1.5 Daemon线程</h4>
<p><code>Daemon</code>线程是一种<strong>支持型线程</strong>，因为它主要被用作程序中<u>后台调度以及支持性工作</u>。</p>
<blockquote>
<p>当一个Java虚拟机中<strong>不存在非Daemon线程</strong>的时候，Java虚拟机将会退出。</p>
</blockquote>
<p>通过调用<code>Thread.setDaemon(true)</code>将线程设置为Daemon线程，<u>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置</u>。</p>
<blockquote>
<p>在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</p>
</blockquote>
<p>实际上经过测试，甚至Daemon线程中<code>run()</code>内的代码都不一定会被执行，。main线程（非 Daemon线程）在启动了线程<code>DaemonRunner</code>之后随着main方法执行完毕而终止，而此时Java虚拟机中已经没有非Daemon线程，虚拟机需要退出。Java虚拟机中的所有Daemon线程都需要立即终止，因此<code>DaemonRunner</code>立即终止，但是<code>DaemonRunner</code>中的finally块并没有执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(), <span class="string">"DaemonRunner"</span>);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"DaemonThread finally run."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"DaemonThread finally run."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"DaemonThread finally run."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动和终止线程">2. 启动和终止线程</h3>
<h4 id="构造线程">2.1 构造线程</h4>
<p>线程对象在构造的时候需要提供线程所需要的属性，如线程所属的<strong>线程组</strong>、<strong>线程优先级</strong>、<strong>是否是Daemon线程</strong>等信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程就是该线程的父线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将daemon、priority属性设置为父线程的对应属性</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将父线程的InheritableThreadLocal复制过来</span></span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">// 分配一个线程ID</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个新构造的线程对象是由其parent线程来进行空间分配的。</p>
<h4 id="启动线程">2.2 启动线程</h4>
<p>线程对象在初始化完成之后，调用<code>start()</code>方法启动这个线程：<u><strong>当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用<code>start()</code>方法的线程</strong></u>。</p>
<h4 id="中断">2.3 中断</h4>
<p><code>中断</code>可以理解为线程的一个<strong>标识位属性</strong>，它表示<u>一个运行中的线程是否被其他线程进行了中断操作</u>。</p>
<ul>
<li>其他线程通过调用该线程的<code>interrupt()</code>方法对其进行中断操作；</li>
<li>线程通过方法<code>isInterrupted()</code>来进行判断自身是否被中断；
<ul>
<li>如果该线程已经处于<strong><u>终结状态</u></strong>，即使该线程被中断过，在调用该线程对象的<code>isInterrupted()</code>时依旧会返回<code>false</code>；</li>
<li>方法在抛出<code>InterruptedException</code>之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出<code>InterruptedException</code>，此时调用<code>isInterrupted()</code>方法将会返回<code>false</code>。</li>
</ul></li>
<li>可以调用静态方法<code>Thread.interrupted()</code>对当前线程的中断标识位进行复位；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeWaiting(), <span class="string">"TimeWaitingThread"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Waiting(), <span class="string">"WaitingThread"</span>).start();</span><br><span class="line">        <span class="comment">// 使用两个Blocked线程，一个获取锁成功，另一个被阻塞</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该线程不断地进行睡眠</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该线程在Waiting.class实例上等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Waiting<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Waiting<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该线程在Blocked.class实例上加锁后，不会释放该锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Blocked<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(<span class="keyword">long</span> seconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="过期deprecated的suspendresume和stop">2.4 过期(<code>deprecated</code>)的<code>suspend()</code>、<code>resume()</code>和<code>stop()</code></h4>
<p><code>suspend()</code>、<code>resume()</code>和<code>stop()</code>方法完成线程的<strong>暂停</strong>、<strong>恢复</strong>和<strong>终止</strong>工作。但是这些<code>API</code>是过期的，已经不建议使用，因为这些方法会带来副作用：</p>
<ul>
<li>在调用<code>suspend()</code>后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发<strong>死锁问题</strong>；</li>
<li><code>stop()</code>方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</li>
</ul>
<h4 id="安全地终止线程">2.5 安全地终止线程</h4>
<p>中断操作是一种适合用来取消或停止任务的交互方式。除了中断以外，还可以利用一个boolean变量来控制<u>是否需要停止任务并终止该线程</u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shutdown</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread countThread = <span class="keyword">new</span> Thread(one, <span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line"></span><br><span class="line">        Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">        countThread = <span class="keyword">new</span> Thread(two, <span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Count i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种通过<strong>标识位</strong>或者<strong>中断操作</strong>的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止。</p>
<h3 id="线程间通信">3. 线程间通信</h3>
<h4 id="volatile和synchronized关键字">3.1 <code>volatile</code>和<code>synchronized</code>关键字</h4>
<ul>
<li>关键字<code>volatile</code>可以用来修饰字段（成员变量），告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</li>
<li>关键字<code>synchronized</code>可以修饰方法或者以同步块的形式来进行使用，它确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</li>
</ul>
<h4 id="等待通知机制">3.2 等待/通知机制</h4>
<p>等待/通知的相关方法是<u><strong>任意Java对象都具备的</strong></u>，因为这些方法被定义在所有对象的超类<code>java.lang.Object</code>上。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter4/WaitAndNotify.PNG" alt="等待/通知方法" /><figcaption aria-hidden="true">等待/通知方法</figcaption>
</figure>
<p>等待/通知机制通过对象O来完成线程之间的交互：</p>
<ul>
<li>一个线程A调用了对象O的<code>wait()</code>方法进入等待状态；</li>
<li>另一个线程B调用了对象O的<code>notify()</code>或者<code>notifyAll()</code>方法，线程A收到通知后从对象O的<code>wait()</code>方法返回，进而执行后续操作。</li>
<li>对象上的<code>wait()</code>和<code>notify/notifyAll()</code>的关系就如同开关信号，用来完成等待方和通知方之间的交互工作。</li>
</ul>
<p>调用<code>wait()</code>、<code>notify()</code>以及<code>notifyAll()</code>时需要注意的细节：</p>
<ol type="1">
<li>使用<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>时需要先对调用<strong>对象加锁</strong>。</li>
<li>调用<code>wait()</code>方法后，线程状态由<code>RUNNING</code>变为<code>WAITING</code>，并将当前线程放置到对象的等待队列。</li>
<li><code>notify()</code>或<code>notifyAll()</code>方法调用后，<u><strong>等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回</strong></u>。</li>
<li><code>notify()</code>方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而<code>notifyAll()</code>方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为 BLOCKED。</li>
<li>从<code>wait()</code>方法返回的<strong>前提</strong>是<u>获得了调用对象的锁</u>。</li>
</ol>
<h4 id="等待通知的经典范式">3.3 等待/通知的经典范式</h4>
<p><strong>等待/通知的经典范式</strong>分为两部分，分别针对<strong>等待方（消费者）</strong>和<strong>通知方（生产者）</strong>：</p>
<ul>
<li><strong>等待方</strong>遵循如下原则：
<ol type="1">
<li>获取对象的锁；</li>
<li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件；</li>
<li>条件满足则执行对应的逻辑；</li>
</ol></li>
<li><strong>通知方</strong>遵循如下原则：
<ol type="1">
<li>获得对象的锁；</li>
<li>改变条件；</li>
<li>通知所有等待在对象上的线程。</li>
</ol></li>
</ul>
<h4 id="管道输入输出流">3.4 管道输入/输出流</h4>
<p>管道输入/输出流主要用于<strong>线程</strong>之间的数据传输，而<u>传输的媒介为内存</u>。主要包括4种具体实现：</p>
<ul>
<li>面向字节：<code>PipedOutputStream</code>、<code>PipedInputStream</code></li>
<li>面向字符：<code>PipedReader</code>、<code>PipedWriter</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        <span class="comment">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</span></span><br><span class="line">        out.connect(in);</span><br><span class="line"></span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">"PrintThread"</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader in;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="thread.join的使用">3.5 <code>Thread.join()</code>的使用</h4>
<p>一个线程A执行<code>thread.join()</code>后，当前线程A等待thread线程终止之后才从<code>thread.join()</code>返回。线程Thread除了提供<code>join()</code>方法之外，还提供了<code>join(long millis)</code>和<code>join(long millis, int nanos)</code>两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁当前线程对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 条件不满足，继续等待</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    	wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件符合，方法返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="threadlocal的使用">3.6 <code>ThreadLocal</code>的使用</h4>
<p><code>ThreadLocal</code>，即线程变量，是一个<u>以<code>ThreadLocal</code>对象为<strong>键</strong></u>、<u>任意对象为<strong>值</strong></u>的存储结构。一个线程可以根据一个<code>ThreadLocal</code>对象查询到绑定在这个线程上的一个值。</p>
<ul>
<li>可以通过<code>set(T)</code>方法来设置一个值；</li>
<li>在当前线程下再通过<code>get()</code>方法获取到原先设置的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程应用实例">4. 线程应用实例</h3>
<h4 id="等待超时模式">4.1 等待超时模式</h4>
<p>在<strong>等待/通知的经典范式</strong>上加入<strong>超时等待</strong>，可以使得该模式更具有灵活性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对当前对象加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">	<span class="keyword">long</span> remaining = mills;</span><br><span class="line">    <span class="comment">// 当超时大于0并且result返回值不满足要求</span></span><br><span class="line">    <span class="keyword">while</span> ((result == <span class="keyword">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	wait(remaining);</span><br><span class="line">        remaining = future - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据库连接池示例">4.2 数据库连接池示例</h4>
<p>使用等待超时模式来构造一个简单的<code>数据库连接池</code>，从连接池中<strong>获取</strong>、<strong>使用</strong>和<strong>释放连接</strong>，而客户端获取连接的过程被设定为等待超时的模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">                <span class="comment">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span></span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在mills内无法获取到连接，将会返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">            <span class="comment">// 完全超时</span></span><br><span class="line">            <span class="keyword">if</span> (mills &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty()) &#123;</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">                <span class="keyword">long</span> remaining = mills;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                Connection result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (!pool.isEmpty()) &#123;</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在资源一定的情况下（连接池中的10个连接），随着客户端线程的逐步增加，客户端出现超时无法获取连接的比率会不断升高。</p>
<h4 id="线程池技术及其示例">4.3 线程池技术及其示例</h4>
<p>对于服务端的程序，经常面对的是客户端传入的<strong>短小（执行时间短、工作内容较为单一）</strong>任务，需要服务端快速处理并返回结果。如果采用一个任务一个线程的方式，任务过多时会创建大量线程，线程上下文切换会增加系统的负载。</p>
<p><code>线程池技术</code>预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。</p>
<ul>
<li>一方面，消除了频繁创建和消亡线程的系统资源开销；</li>
<li>另一方面，面对过量任务的提交能够平缓的劣化。</li>
</ul>
<p>一个简单的线程池接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 执行一个Job，这个Job需要实现Runnable</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 增加工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 减少工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 得到正在等待执行的任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端可以通过<code>execute(Job)</code>方法将<code>Job</code><strong><u>提交入线程池执行</u></strong>，而客户端自身不用等待<code>Job</code>的执行完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 线程池最大限制数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 线程池默认的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 线程池最小的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这是一个工作列表，将会向里面插入工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;Job&gt;();</span><br><span class="line">    <span class="comment">// 工作者列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Worker&gt;());</span><br><span class="line">    <span class="comment">// 工作者线程的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">    <span class="comment">// 线程编号生成</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong threadNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initializeWokers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;</span><br><span class="line">        initializeWokers(workerNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加一个工作，然后进行通知</span></span><br><span class="line">            <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="comment">// 限制新增的Worker数量不能超过最大值</span></span><br><span class="line">            <span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWokers(num);</span><br><span class="line">            <span class="keyword">this</span>.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="keyword">this</span>.workerNum) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"beyond workNum"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 按照给定的数量停止Worker</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程工作者</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWokers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">"ThreadPool-Worker-"</span> + threadNum.incrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作者，负责消费任务</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否工作</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                    <span class="comment">// 如果工作者列表是空的，那么就wait</span></span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                            <span class="comment">// 感知到外部对WorkerThread的中断操作，返回</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 取出一个Job</span></span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        job.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        <span class="comment">// 忽略Job执行中的Exception</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程池的本质就是使用了一个线程安全的工作队列连接工作者线程和客户端线程：</p>
<ul>
<li>客户端线程将任务放入工作队列后便返回；</li>
<li>工作者线程则不断地从工作队列上取出工作并执行。</li>
</ul>
<h4 id="基于线程池技术的简单web服务器">4.4 基于线程池技术的简单Web服务器</h4>
<p>常用的Java Web服务器，如<code>Tomcat</code>、<code>Jetty</code>，在其处理请求的过程中都使用到了线程池技术。</p>
<p>构造一个简单的Web服务器，这个Web服务器用来处理<code>HTTP</code>请求，使用<code>main</code>线程不断地接受客户端<code>Socket</code>的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处理多个客户端请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理HttpRequest的线程池</span></span><br><span class="line">    <span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool&lt;HttpRequestHandler&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// SimpleHttpServer的根路径</span></span><br><span class="line">    <span class="keyword">static</span> String basePath;</span><br><span class="line">    <span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="comment">// 服务监听端口</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (port &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span><span class="params">(String basePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (basePath != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> File(basePath).exists() &amp;&amp; <span class="keyword">new</span> File(basePath).isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动SimpleHttpServer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">            InputStream in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 由相对路径计算出绝对路径</span></span><br><span class="line">                String filePath = basePath + header.split(<span class="string">" "</span>)[<span class="number">1</span>];</span><br><span class="line">                out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">"jpg"</span>) || filePath.endsWith(<span class="string">"ico"</span>)) &#123;</span><br><span class="line">                    in = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: image/jpeg"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Length: "</span> + array.length);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(filePath)));</span><br><span class="line">                    out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: text/html; charset=UTF-8"</span>);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                out.println(<span class="string">"HTTP/1.1 500"</span>);</span><br><span class="line">                out.println(<span class="string">""</span>);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(br, in, reader, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭流或者Socket</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeables != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable closeable : closeables) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SimpleHttpServer</code>在建立了与客户端的连接之后，并不会处理客户端的请求，而是将其包装成<code>HttpRequestHandler</code>并交由线程池处理。启动服务的测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleHttpServer newSever = <span class="keyword">new</span> SimpleHttpServer();</span><br><span class="line">        newSever.setBasePath(<span class="string">"..\\src\\Concurrency\\Chapter4\\DefaultThreadPool"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newSever.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>Apache HTTP server benchmarking tool</code>来测试不同线程数下，<code>SimpleHttpServer</code>的吞吐量表现。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/cjsblog/p/9038838.html" target="_blank" rel="noopener">Apache HTTP server benchmarking tool</a>是服务器压力测试工具，可以参考链接查看使用方法。</p>
</blockquote>
<p>随着线程池中线程数量的增加，<code>SimpleHttpServer</code>响应时间不断变小。</p>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Java并发编程的艺术]--5 Java中的锁</title>
    <url>/2021/07/19/JavaLearning_The_art_of_concurrent_programming_in_Java-5-Java-lock.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。</code> <a id="more"></a></p>
</blockquote>
<h3 id="lock接口">1. Lock接口</h3>
<p><code>Java SE 5</code>之后，<strong>并发包</strong>中新增了<code>Lock</code>接口（以及相关实现类）用来实现锁功能。</p>
<ul>
<li>提供了与<code>synchronized</code>关键字类似的同步功能，在使用时需要<strong>显式地</strong>获取和释放锁。</li>
<li>拥有<strong>锁获取与释放</strong>的<code>可操作性</code>、<code>可中断的获取锁</code>以及<code>超时获取锁</code>等多种synchronized关键字所不具备的同步特性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 保证在获取到锁之后，最终能够被释放</span></span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/LockFeature.PNG" alt="Lock接口提供的主要特性" /><figcaption aria-hidden="true">Lock接口提供的主要特性</figcaption>
</figure>
<p>Lock接口定义了锁获取和释放的基本操作：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/LockAPI.PNG" alt="Lock API" /><figcaption aria-hidden="true">Lock API</figcaption>
</figure>
<h3 id="队列同步器">2. 队列同步器</h3>
<p>队列同步器<code>AbstractQueuedSynchronizer</code>，是用来构建锁或者其他同步组件的基础框架。</p>
<blockquote>
<p>使用了一个i<strong>nt成员变量</strong>表示<code>同步状态</code>，通过内置的<code>FIFO</code>队列来完成<u>资源获取线程的排队工作</u>。</p>
</blockquote>
<p>子类通过继承同步器并实现它的抽象方法来管理同步状态，同步器提供3个方法对同步状态进行更改，保证状态的改变是安全的：</p>
<ul>
<li><code>getState()</code>，获取当前同步状态；</li>
<li><code>setState(int newState)</code>，设置当前同步状态；</li>
<li><code>compareAndSetState(int expect, int update)</code>，使用CAS设置当前状态，该方法能够保证状态设置的<strong>原子性</strong>。</li>
</ul>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义：</p>
<ul>
<li>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；</li>
<li>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</li>
</ul>
<h4 id="队列同步器的接口与示例">2.1 队列同步器的接口与示例</h4>
<p>使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法。同步器可重写的方法如下：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/AQSMethod.PNG" alt="同步器可重写的方法" /><figcaption aria-hidden="true">同步器可重写的方法</figcaption>
</figure>
<p>同步器提供的模板方法基本上分为3类：</p>
<ul>
<li><p>独占式获取与释放同步状态；</p></li>
<li><p>共享式获取与释放同步状态；</p></li>
<li><p>查询同步队列中的等待线程情况。</p></li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/AQSMethodTemplate.PNG" alt="同步器提供的模板方法" /><figcaption aria-hidden="true">同步器提供的模板方法</figcaption>
</figure>
<p><code>独占锁</code>是<u><strong>在同一时刻只能有一个线程获取到锁</strong>，而其他获取锁的线程只能处于同步队列中等待</u>，只有获取锁的线程释放了锁，后继的线程才能够获取锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类，自定义同步器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否处于占用状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当状态为0的时候获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁，将状态设置为0</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅需要将操作代理到Sync上即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用户使用<code>Mutex</code>时并不会直接和内部同步器的实现打交道，而是调用<code>Mutex</code>提供的方法；</li>
<li>在Mutex的实现中，只需要在方法实现中调用同步器的模板方法即可，当前线程调用该方法获取同步状态失败后会被加入到同步队列中等待。</li>
</ul>
<h4 id="队列同步器的实现">2.2 队列同步器的实现</h4>
<h5 id="同步队列">2.2.1 同步队列</h5>
<p>同步器依赖内部的同步队列来完成<strong>同步状态的管理</strong>：</p>
<ul>
<li>当前线程获取同步状态失败时，同步器会将<strong><u>当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列</u></strong>，同时会阻塞当前线程；</li>
<li>当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/AQSNode.PNG" alt="同步队列中的节点（Node）" /><figcaption aria-hidden="true">同步队列中的节点（Node）</figcaption>
</figure>
<p>同步器拥有<code>首节点（head）</code>和<code>尾节点（tail）</code>，没有成功获取同步状态的线程将会成为节点加入该队列的尾部。</p>
<ul>
<li>同步器提供了一个基于<code>CAS</code>的设置尾节点的方法：<code>compareAndSetTail(Node expect, Node update)</code>，需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</li>
<li>首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是<u><strong>通过获取同步状态成功的线程来完成的</strong></u>，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/SynchronizedQueue.PNG" alt="同步队列" /><figcaption aria-hidden="true">同步队列</figcaption>
</figure>
<h5 id="独占式同步状态获取与释放">2.2.2 独占式同步状态获取与释放</h5>
<p>同步器的<code>acquire(int arg)</code>方法可以获取同步状态，该方法对中断不敏感。主要完成<strong>同步状态获取</strong>、<strong>节点构造</strong>、<strong>加入同步队列</strong>以及<strong>在同步队列中自旋等待</strong>的相关工作。</p>
<ul>
<li>首先调用自定义同步器实现的<code>tryAcquire(int arg)</code>方法，该方法保证<strong>线程安全的获取同步状态</strong>；</li>
<li>如果同步状态获取失败，则构造同步节点（独占式<code>Node.EXCLUSIVE</code>，同一时刻只能有一个线程成功获取同步状态）；</li>
<li>通过<code>addWaiter(Node node)</code> 方法将该节点加入到同步队列的尾部；</li>
<li>最后调用<code>acquireQueued(Node node, int arg)</code>方法，使得该节点以<strong>“死循环”</strong>的方式获取同步状态；</li>
<li>如果获取不到则<u><strong>阻塞节点中的线程</strong></u>，而被阻塞线程的<strong>唤醒</strong><u>主要依靠前驱节点的出队或阻塞线程被中断来实现</u>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 快速尝试在尾部添加</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用 compareAndSetTail 方法来确保节点能够被线程安全添加</span></span><br><span class="line">    	<span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">    		pred.next = node;</span><br><span class="line">    		<span class="keyword">return</span> node;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同步器通过“死循环”来保证节点的正确添加</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// 通过CAS将节点设置成为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">            	tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点进入同步队列之后，就进入了一个自旋的过程</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 只有前驱节点是头节点才能够尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            	interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        	cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/acquireFlow.PNG" alt="独占式同步状态获取流程" /><figcaption aria-hidden="true">独占式同步状态获取流程</figcaption>
</figure>
<p>同步器的<code>release(int arg)</code>方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    	Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// unparkSuccessor(Node node)方法使用LockSupport来唤醒处于等待状态的线程。</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="共享式同步状态获取与释放">2.2.3 共享式同步状态获取与释放</h5>
<p><strong>共享式获取</strong>与<strong>独占式获取</strong>最主要的区别：<u><strong>在于同一时刻能否有多个线程同时获取到同步状态</strong></u>。</p>
<ul>
<li>共享式访问资源时，<u>其他<strong>共享式</strong>的访问均被允许</u>，而<strong>独占式</strong>访问被阻塞；</li>
<li>独占式访问资源时，同一时刻其他访问均被阻塞。</li>
</ul>
<p>同步器的<code>acquireShared(int arg)</code>方法可以共享式地获取同步状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquireShared 方法尝试获取同步状态，</span></span><br><span class="line">    <span class="comment">// tryAcquireShared 方法返回值为int类型，</span></span><br><span class="line">    <span class="comment">// 当返回值大于等于0时，表示能够获取到同步状态</span></span><br><span class="line">	<span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">		doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果当前节点的前驱为头节点时，尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">            	<span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 获取同步状态成功，从自旋过程中退出</span></span><br><span class="line">            	<span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            		setHeadAndPropagate(node, r);</span><br><span class="line">            		p.next = <span class="keyword">null</span>;</span><br><span class="line">            		<span class="keyword">if</span> (interrupted)</span><br><span class="line">            			selfInterrupt();</span><br><span class="line">            		failed = <span class="keyword">false</span>;</span><br><span class="line">            		<span class="keyword">return</span>;</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            	interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        	cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用<code>releaseShared(int arg)</code>方法可以释放同步状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryReleaseShared 必须确保同步状态（或者资源数）线程安全释放，</span></span><br><span class="line">    <span class="comment">// 一般是通过循环和CAS来保证的</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="独占式超时获取同步状态">2.2.4 独占式超时获取同步状态</h5>
<p>同步器的<code>doAcquireNanos(int arg, long nanosTimeout)</code>方法可以超时获取同步状态，<code>doAcquireNanos</code>方法在<strong><u>支持响应中断</u></strong>的基础上，增加了<u><strong>超时获取</strong></u>的特性。</p>
<ul>
<li><strong>支持响应中断</strong>。在等待获取同步状态时，如果当前线程被中断，会立刻返回，并抛出<code>InterruptedException</code>。</li>
<li><strong>超时获取</strong>。即在指定的时间段内获取同步状态，如果获取到同步状态则返回<code>true</code>；否则，返回<code>false</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> lastTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            	setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">            	LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 计算时间，当前时间now减去睡眠之前的时间lastTime得到已经睡眠</span></span><br><span class="line">            <span class="comment">// 的时间delta，然后被原有超时时间nanosTimeout减去，得到了</span></span><br><span class="line">            <span class="comment">// 还应该睡眠的时间</span></span><br><span class="line">            nanosTimeout -= now - lastTime;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">              	<span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        	cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/doAcquireNanosFlow.PNG" alt="独占式超时获取同步状态流程" /><figcaption aria-hidden="true">独占式超时获取同步状态流程</figcaption>
</figure>
<h5 id="自定义同步组件twinslock">2.2.5 自定义同步组件——<code>TwinsLock</code></h5>
<p><code>TwinsLock</code>要求在同一时刻，只允许<strong><u>至多两个</u></strong>线程同时访问，超过两个线程的访问将被阻塞：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count must large than zero."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current - reduceCount;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> returnCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current + returnCount;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步器作为一个桥梁，连接<strong>线程访问</strong>以及<strong>同步状态控制</strong>等底层技术与不同并发组件的接口语义。</p>
<h3 id="重入锁">3 重入锁</h3>
<p>重入锁<code>ReentrantLock</code>，即支持重进入的锁，该锁能够支持<u><strong>一个线程对资源的重复加锁</strong></u>。</p>
<ul>
<li>在调用<code>lock()</code>方法时，<strong>已经获取到锁</strong>的线程，能够<strong>再次调用</strong><code>lock()</code>方法获取锁而<u>不被阻塞</u>。</li>
</ul>
<p>该锁的还支持获取锁时的公平和非公平性选择。</p>
<ul>
<li>在<strong>绝对时间</strong>上，先对锁进行获取的请求一定先被满足，那么这个锁是<code>公平</code>的；</li>
<li>反之，是<code>不公平</code>的。</li>
</ul>
<h4 id="实现重进入">3.1 实现重进入</h4>
<p>重进入是指<u><strong>任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞</strong></u>：</p>
<ul>
<li><strong>线程再次获取锁</strong>。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</li>
<li><strong>锁的最终释放</strong>。线程重复<code>n</code>次获取了锁，随后在第<code>n</code>次释放该锁后，其他线程能够获取到该锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 再次获取同步状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 将同步状态值进行增加并返回true，表示获取同步状态成功</span></span><br><span class="line">    	<span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    	<span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">    	setState(nextc);</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在释放同步状态时减少同步状态值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    	free = <span class="keyword">true</span>;</span><br><span class="line">    	setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="公平与非公平获取锁">3.2 公平与非公平获取锁</h4>
<ul>
<li>对于非公平锁，<code>nonfairTryAcquire</code>方法，只要<code>CAS</code>设置同步状态成功，则表示当前线程获取了锁；</li>
<li>对于公平锁，<code>tryAcquire</code>方法为判断条件增加了<code>hasQueuedPredecessors()</code>方法，判断同步队列中当前节点是否有前驱节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        	setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察公平和非公平锁在获取锁时的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairAndUnfairTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock fairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock unfairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//    @Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(fairLock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    @Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(unfairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动10个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Job w = <span class="keyword">new</span> Job(lock);</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FairAndUnfairTest test = <span class="keyword">new</span> FairAndUnfairTest();</span><br><span class="line">        test.testLock(fairLock);</span><br><span class="line"><span class="comment">//        test.testLock(unfairLock);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Lock lock;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.print(<span class="string">"Lock by ["</span> + Thread.currentThread().getName() + <span class="string">"], Waiting by ["</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Thread t : ((ReentrantLock2) lock).getQueuedThreads()) &#123;</span><br><span class="line">                    System.out.print(t.getName() + <span class="string">", "</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"]"</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock2</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            List&lt;Thread&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="keyword">super</span>.getQueuedThreads());</span><br><span class="line">            Collections.reverse(arrayList);</span><br><span class="line">            <span class="keyword">return</span> arrayList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公平性锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁出现了一个线程连续获取锁的情况。</p>
<blockquote>
<p>非公平性锁可能使线程<code>“饥饿”</code>，但被设定成默认的实现</p>
</blockquote>
<p>非公平性锁虽然可能造成线程“饥饿”，但线程切换极少，减小了线程上下文切换带来的开销，保证了其更大的吞吐量。</p>
<h3 id="读写锁">4. 读写锁</h3>
<p><code>读写锁</code>维护了<strong>一对锁</strong>，一个<code>读锁</code>和一个<code>写锁</code>，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p>
<ul>
<li>读操作时获取读锁；</li>
<li>写操作时获取写锁。写锁被获取到时，后续（非当前写 操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行。</li>
</ul>
<p>Java并发包提供读写锁的实现是<code>ReentrantReadWriteLock</code>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ReentrantReadWriteLock.PNG" alt="ReentrantReadWriteLock特性" /><figcaption aria-hidden="true">ReentrantReadWriteLock特性</figcaption>
</figure>
<h4 id="读写锁的接口">4.1 读写锁的接口</h4>
<p><code>ReadWriteLock</code>仅定义了<strong>获取</strong>读锁和写锁的两个方法，即<code>readLock()</code>方法和<code>writeLock()</code>方法；<code>ReentrantReadWriteLock</code>除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ReentrantReadWriteLockMthods.PNG" alt="ReentrantReadWriteLock方法" /><figcaption aria-hidden="true">ReentrantReadWriteLock方法</figcaption>
</figure>
<h4 id="读写锁的实现">4.2 读写锁的实现</h4>
<h5 id="读写状态的设计">4.2.1 读写状态的设计</h5>
<p>读写锁同样依赖<strong>自定义同步器</strong>来实现同步功能，而<strong>读写状态</strong>就是其同步器的同步状态。</p>
<ul>
<li>读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态。</li>
</ul>
<p>读写锁将变量切分成了两个部分，<u><strong>高16位表示读</strong>，<strong>低16位表示写</strong></u>。读写锁通过<code>位运算</code>迅速确定读和写各自的状态。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ReadWriteLockStatus.PNG" alt="读写锁状态的划分" /><figcaption aria-hidden="true">读写锁状态的划分</figcaption>
</figure>
<h5 id="写锁的获取与释放">4.2.2 写锁的获取与释放</h5>
<p>写锁是一个支持重进入的<strong>排它锁</strong>。</p>
<ul>
<li>如果当前线程已经获取了写锁，则增加写状态。</li>
<li>如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程， 则当前线程进入等待状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">        <span class="comment">// c != 0 且 w == 0，代表存在读锁</span></span><br><span class="line">    	<span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 写锁超过最大值</span></span><br><span class="line">    	<span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">    		<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">    	<span class="comment">// 设置写锁(此时该线程已经获取过写锁，所以无需CAS也是线程安全的)</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为加锁，尝试获取写锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取写锁成功</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写锁的释放与<code>ReentrantLock</code>的释放过程基本类似，每次释放均减少写状态，当写状态为<code>0</code>时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁。</p>
<h5 id="读锁的获取与释放">4.2.3 读锁的获取与释放</h5>
<p>读锁是一个支持重进入的<strong>共享锁</strong>。</p>
<ul>
<li>能够被<u>多个线程</u>同时获取，在没有其他<u>写线程访问</u>（或者写状态为0）时，读锁总会被成功地获取，只需增加读状态。</li>
<li>如果当前线程已经获取了<strong>读锁或写锁</strong>，则增加读状态。</li>
<li>如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</li>
<li>读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在<code>ThreadLocal</code>中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; c)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="锁降级">4.2.4 锁降级</h5>
<p><code>锁降级</code>指的是<strong><u>写锁降级成为读锁</u></strong>。线程已经持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程，即<code>锁降级</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">        <span class="comment">// 必须先释放读锁</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">// 锁降级从写锁获取到开始</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">                <span class="comment">// 准备数据的流程（略）</span></span><br><span class="line">                update = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            readLock.lock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 锁降级完成，写锁降级为读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">// 使用数据的流程（略）</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁降级中读锁的获取主要是为了保证数据的可见性。</p>
<ul>
<li>如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。</li>
<li>如果当前线程获取读锁，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进 行数据更新。</li>
</ul>
<h3 id="locksupport工具">5. <code>LockSupport</code>工具</h3>
<p>当需要<strong>阻塞</strong>或<strong>唤醒</strong>一个线程的时候，都会使用<code>LockSupport</code>工具类来完成相应工作。<code>LockSupport</code>定义了一组的<strong><u>公共静态方法</u></strong>，这些方法提供了最基本的线程阻塞和唤醒功能，而<code>LockSupport</code>也成为构建同步组件的基础工具。</p>
<ul>
<li>以<code>park</code>开头的方法用来<strong><u>阻塞当前线程</u></strong>；</li>
<li><code>unpark(Thread thread)</code> 方法来<u><strong>唤醒一个被阻塞的线程</strong></u>。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/LockSupportMethods.PNG" alt="读写锁状态的划分" /><figcaption aria-hidden="true">读写锁状态的划分</figcaption>
</figure>
<p><code>Java 6</code>中，<code>LockSupport</code>增加了<code>park(Object blocker)</code>、<code>parkNanos(Object blocker, long nanos)</code>和<code>parkUntil(Object blocker, long deadline)</code>3个方法，用于实现阻塞当前线程的功能，其中参数<code>blocker</code>是用来<u><strong>标识当前线程在等待的对象</strong></u>（以下称为阻塞对象）。</p>
<h3 id="condition接口">6. <code>Condition</code>接口</h3>
<p><code>Condition</code>接口也提供了类似<code>Object</code>的<strong>监视器</strong>方法，与<code>Lock</code>配合可以实现等待/通知模式。</p>
<h4 id="condition接口与示例">6.1 Condition接口与示例</h4>
<p><code>Condition</code>定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要<strong><u>提前获取</u></strong>到<code>Condition</code>对象关联的锁。<code>Condition</code>对象是由<code>Lock</code>对象（调用Lock对象的<code>newCondition()</code>方法）创建出来的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 一般都会将Condition对象作为成员变量</span></span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用await()方法后，当前线程会释放锁并在此等待</span></span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 其他线程调用Condition对象的signal()方法，</span></span><br><span class="line">        <span class="comment">// 通知当前线程后，当前线程才从await()方法返回，</span></span><br><span class="line">        <span class="comment">// 并且在返回前已经获取了锁。</span></span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter5/ConditionMethods.PNG" alt="Condition的方法" /><figcaption aria-hidden="true">Condition的方法</figcaption>
</figure>
<p>基于<code>Condition</code>实现的有界队列：</p>
<ul>
<li>当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素；</li>
<li>当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] items;</span><br><span class="line">    <span class="comment">// 添加的下标，删除的下标和数组当前数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addIndex, removeIndex, count;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个元素，如果数组满，则添加线程进入等待状态，直到有"空位"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[addIndex] = t;</span><br><span class="line">            <span class="keyword">if</span> (++addIndex == items.length)</span><br><span class="line">                addIndex = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[removeIndex];</span><br><span class="line">            <span class="keyword">if</span> (++removeIndex == items.length)</span><br><span class="line">                removeIndex = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> (T) x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="condition的实现">6.2 Condition的实现</h4>
<p><code>ConditionObject</code>是同步器<code>AbstractQueuedSynchronizer</code>的内部类。每个<code>Condition</code>对象都包含着一个队列（等待队列），该队列是<code>Condition</code>对象实现<strong><u>等待/通知功能</u></strong>的关键。</p>
<h5 id="等待队列">6.2.1 等待队列</h5>
<p>等待队列是一个<code>FIFO</code>的队列，在队列中的每个节点都包含了一个<strong><code>线程引用</code></strong>，该线程就是在<code>Condition</code>对象上等待的线程：</p>
<ul>
<li>同步队列和等待队列中节点类型都是同步器的静态内部类<code>AbstractQueuedSynchronizer.Node</code>。</li>
<li><code>Lock</code>（同步器）拥有一个同步队列和多个等待队列</li>
</ul>
<p>同理，<code>Condition</code>拥有<code>首节点（firstWaiter）</code>和<code>尾节点（lastWaiter）</code>。</p>
<ul>
<li>当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。节点引用更新的过程并<strong><u>没有使用</u></strong><code>CAS</code>保证，原因在于调用<code>await()</code>方法的线程必定是获取了锁的线程。</li>
</ul>
<h5 id="等待">6.2.2 等待</h5>
<p>调用<code>Condition</code>的<code>await()</code>方法，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。从await()方法返回时，当前线程<u><strong>一定获取了<code>Condition</code>相关联的锁</strong></u>。</p>
<ul>
<li>被唤醒后的线程，将从<code>await()</code>方法中的while循环中退出（<code>isOnSyncQueue(Node node)</code>方法返回true，节点已经在同步队列中）；</li>
<li>进而调用同步器的<code>acquireQueued()</code>方法加入到获取同步状态的竞争中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程加入等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步状态，也就是释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于<u><strong>同步队列的<code>首节点</code>（获取了锁的节点）移动到Condition的<code>等待队列</code>中</strong></u>。</p>
<h5 id="通知">6.2.3 通知</h5>
<p>调用Condition的<code>signal()</code>方法，将会唤醒在等待队列中<u><strong>等待时间最长</strong></u>的节点（<code>首节点</code>），在唤醒节点之前，会将节点移到同步队列中。</p>
<ul>
<li>调用该方法的前置条件是当前线程必须获取了锁；</li>
<li>通过调用同步器的<code>enq(Node node)</code>方法，等待队列中的头节点线程安全地移动到同步队列。</li>
<li>当节点移动到同步队列后，当前线程再使用<code>LockSupport</code>唤醒该节点的线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用该方法的前置条件是当前线程必须获取了锁</span></span><br><span class="line">	<span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">	</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">	<span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">		doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--11 后端编译与优化</title>
    <url>/2021/06/03/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_11_Back-end_compilation_and_optimization.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>后端编译器的编译速度及编译结果质量高低，是衡量Java虚拟机性能最重要的一个指标。 <a id="more"></a></p>
</blockquote>
<p>如果把字节码看作是程序语言的一种<code>中间表示形式（Intermediate Representation，IR）</code>， 那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的<code>后端</code>。</p>
<h3 id="即时编译器">1. 即时编译器</h3>
<p>目前主流的两款商用Java虚拟机（<code>HotSpot</code>、<code>OpenJ9</code>）里，Java程序最初都是通过<code>解释器（Interpreter）</code>进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为<code>“热点代码”（Hot Spot Code）</code>，为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为<strong><code>即时编译器</code></strong>。</p>
<h4 id="解释器与编译器">1.1 解释器与编译器</h4>
<p>目前主流的商用Java虚拟机都采用<strong><u>解释器与编译器并存</u></strong>的运行架构，解释器与编译器两者各有优势：</p>
<ul>
<li>当程序需要<strong>迅速启动和执行</strong>的时候，解释器可以首先发挥作用，<u>省去编译的时间，立即运行</u>。</li>
<li>当程序启动后，随着时间的推移，编译器逐渐发挥作用，<u>把越来越多的代码编译成本地代码</u>，这样可以<strong>减少解释器的中间损耗，获得更高的执行效率</strong>。</li>
<li>当程序运行环境中<strong>内存资源限制较大</strong>，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。</li>
<li>解释器还可以作为编译器激进优化时后备的<code>“逃生门”</code>，让编译器根据概率选择一些不能保证所有情况都正确，但<u>大多数时候都能提升运行速度的优化手段</u>，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现<code>“罕见陷阱”（Uncommon Trap）</code>时可以通过<code>逆优化（Deoptimization）</code>退回到解释状态继续执行。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/InteractionBetweenInterpreterAndCompiler.PNG" alt="解释器与编译器的交互" /><figcaption aria-hidden="true">解释器与编译器的交互</figcaption>
</figure>
<p><code>HotSpot</code>虚拟机中内置了两个（或三个）<code>即时编译器</code>：</p>
<ul>
<li>其中两个编译器存在已久，分别被称为<code>“客户端编译器”（Client Compiler）</code>和<code>“服务端编译器”（Server Compiler）</code>，或者简称为<code>C1编译器</code>和<code>C2编译器</code>（部分资料和JDK源码中<code>C2</code>也叫<code>Opto</code>编译器）</li>
<li>第三个是在<code>JDK 10</code>时才出现的、长期目标是代替<code>C2</code>的<code>Graal</code>编译器。目前还处于实验状态。</li>
</ul>
<p><code>分层编译（Tiered Compilation）</code>的工作模式出现以前，<code>HotSpot</code>虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作。</p>
<ul>
<li>解释器与编译器搭配使用的方式在虚拟机中被称为<code>“混合模式”（Mixed Mode）</code></li>
<li>用户可以使用参数<code>“-Xint”</code>强制虚拟机运行于<code>“解释模式”（Interpreted Mode）</code>，这时候编译器<strong>完全不介入</strong>工作，全部代码都使用解释方式执行。</li>
<li>也可以使用参数<code>“-Xcomp”</code>强制虚拟机运行于<code>“编译模式”（Compiled Mode）</code>，这时候将<strong>优先</strong>采用编译方式执行程序，但是<u>解释器仍然要在编译无法进行的情况下介入执行过程</u>。</li>
</ul>
<p>为了在<u>程序启动响应速度与运行效率</u>之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了<code>分层编译</code>的功能，分层编译根据编译器<u><strong>编译、优化的规模与耗时</strong></u>，划分出不同的编译层次：</p>
<ul>
<li>第0层。程序<strong>纯解释执行</strong>，并且解释器不开启<code>性能监控功能（Profiling）</code>。</li>
<li>第1层。使用<code>客户端编译器</code>将字节码编译为本地代码来运行，进行简单可靠的<u>稳定优化</u>，<u>不开启</u>性能监控功能。</li>
<li>第2层。使用<code>客户端编译器</code>执行，仅开启<u>方法及回边次数统计</u>等<strong>有限</strong>的性能监控功能。</li>
<li>第3层。使用<code>客户端编译器</code>执行，开启<strong>全部</strong>性能监控，还会收集如<u>分支跳转、虚方法调用版本</u>等全部的统计信息。</li>
<li>第4层。使用<code>服务端编译器</code>将字节码编译为本地代码，服务端编译器会启用更多<u>编译耗时更长的优化</u>，还会根据性能监控信息进行一些不可靠的<u>激进优化</u>。</li>
</ul>
<p>实施分层编译后，解释器、客户端编译器和服务端编译器就会<strong>同时工作</strong>，热点代码都可能会被多次编译：</p>
<ul>
<li>用客户端编译器获取更高的编译速度</li>
<li>用服务端编译器来获取更好的编译质量</li>
<li>在解释执行的时候也无须额外承担收集性能监控信息的任务</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/TieredCompilation.PNG" alt="分层编译的交互关系" /><figcaption aria-hidden="true">分层编译的交互关系</figcaption>
</figure>
<h4 id="编译对象与触发条件">1.2 编译对象与触发条件</h4>
<h5 id="热点代码">1.2.1 热点代码</h5>
<p>在运行过程中会被即时编译器编译的目标是<code>“热点代码”</code>，这里所指的热点代码主要有两类：</p>
<ul>
<li>被多次调用的<strong>方法</strong>。</li>
<li>被多次执行的<strong>循环体</strong>。</li>
</ul>
<p>对于这两种情况，编译的目标对象都是<strong><u>整个方法体</u></strong>，而不会是单独的循环体。由循环体所触发的热点只是方法的一部分，但编译器依然必须以整个方法作为编译对象，只是执行入口会稍有不同，编译时会传入执行入口点<code>字节码序号（Byte Code Index，BCI）</code>。</p>
<blockquote>
<p><code>“栈上替换”（On Stack Replacement，OSR）</code>，即方法的栈帧还在栈上，方法就被替换了。</p>
</blockquote>
<h5 id="热点探测判定方式">1.2.2 热点探测判定方式</h5>
<p>要知道某段代码是不是<code>热点代码</code>，是不是需要触发<code>即时编译</code>，这个行为称为<code>“热点探测”（Hot Spot Code Detection）</code>，目前主流的热点探测判定方式有两种：</p>
<ul>
<li><code>基于采样的热点探测（Sample Based Hot Spot Code Detection）</code>。采用这种方法的虚拟机会<u>周期性地检查各个线程的<strong>调用栈顶</strong>，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是<code>“热点方法”</code></u>。
<ul>
<li><strong>好处</strong>是实现简单高效，可以很容易地获取方法调用关系（将调用堆栈展开即可）</li>
<li><strong>缺点</strong>是很难精确地确认一个方法的热度，容易因为<strong>受到线程阻塞或别的外界因素的影响而扰乱热点探测</strong>。</li>
</ul></li>
<li><code>基于计数器的热点探测（Counter Based Hot Spot Code Detection）</code>。采用这种方法的虚拟机会<u>为每个方法（甚至是代码块）建立<strong>计数器</strong>，统计方法的执行次数，如果执行次数超过一定的<code>阈值</code>就认为它是<code>“热点方法”</code>。</u>
<ul>
<li><strong>缺点</strong>是需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。</li>
<li><strong>优点</strong>是统计结果相对来说更加精确严谨。</li>
</ul></li>
</ul>
<h5 id="基于计数器的热点探测">1.2.3 基于计数器的热点探测</h5>
<p><code>HotSpot虚拟机</code>中使用的是基于计数器的热点探测，<code>HotSpot</code>为每个方法准备了两类计数器：</p>
<ul>
<li><p><code>方法调用计数器（Invocation Counter）</code>。这个计数器就是<u>用于统计方法被调用的次数</u>。</p>
<ul>
<li><p>它的<code>默认阈值</code>在<strong>客户端模式</strong>下是<code>1500</code>次，在<strong>服务端模式</strong>下是<code>10000</code>次，这个阈值可以通过虚拟机参数<code>-XX：CompileThreshold</code>来人为设定。</p></li>
<li><p>当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的版本</p>
<ul>
<li>如果存在，则优先使用编译后的本地代码来执行。</li>
<li>如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后判断<u><strong>方法调用计数器与回边计数器值之和</strong></u>是否超过方法调用计数器的阈值。</li>
<li>一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。当编译工作完成后，这个方法的调用入口地址就会被系统自动改写成新值</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/InvocationCounter.PNG" alt="方法调用计数器触发即时编译" /><figcaption aria-hidden="true">方法调用计数器触发即时编译</figcaption>
</figure></li>
<li><p>方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<u>一段时间之内方法被调用的次数</u>。</p>
<ul>
<li>超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为<code>方法调用计数器热度的衰减（Counter Decay）</code>，而这段时间就称为此方法统计的<code>半衰周期（Counter Half Life Time）</code>。</li>
<li>热度衰减的动作是<u>在虚拟机进行垃圾收集时顺便进行的</u>。</li>
</ul></li>
</ul></li>
<li><p><code>回边计数器（Back Edge Counter）</code>，<code>“回边”</code>的意思就是指在循环边界往回跳转。这个计数器就是用于<u>统计一个方法中循环体代码执行的次数</u>。</p>
<ul>
<li><p>在字节码中遇到控制流向后跳转的指令就称为<code>“回边（Back Edge）</code>”，建立回边计数器统计的目的是为了<u>触发栈上的替换编译</u>。</p></li>
<li><p>当前的<code>HotSpot</code>虚拟机必须设置参数<code>-XX:OnStackReplacePercentage</code>来<strong>间接调整</strong>回边计数器的阈值，其计算公式有如下两种：</p>
<ul>
<li>虚拟机运行在<strong>客户端模式</strong>下，回边计数器阈值计算公式为： <span class="math display">\[
\frac{方法调用计数器阈值 \times OSR比率}{100}
\]</span></li>
</ul>
<p><code>OSR比率（-XX：OnStackReplacePercentage）</code>默认值为<code>933</code></p>
<ul>
<li>虚拟机运行在<strong>服务端模式</strong>下，回边计数器阈值的计算公式为：</li>
</ul>
<p><span class="math display">\[
\frac{方法调用计数器阈值 \times (OSR比率-解释器监控比率)}{100}
\]</span></p>
<p>其中<code>-XX：OnStackReplacePercentage</code>默认值为<code>140</code>，<code>- XX：InterpreterProfilePercentage</code>默认值为<code>33</code>。</p></li>
<li><p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本</p>
<ul>
<li>如果有，将会优先执行已编译的代码</li>
<li>否则就把回边计数器的值加一，然后判断<u><strong>方法调用计数器与回边计数器值之和</strong></u>是否超过回边计数器的阈值。</li>
<li>若超过阈值，将会提交一个<strong>栈上替换</strong>编译请求， 并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/BackEdgeCounter.PNG" alt="回边计数器触发即时编译" /><figcaption aria-hidden="true">回边计数器触发即时编译</figcaption>
</figure></li>
<li><p>回边计数器<u>没有计数热度衰减的过程</u>，因此这个计数器统计的就是该方法循环执行的<code>绝对次数</code>。</p></li>
</ul></li>
</ul>
<h4 id="编译过程">1.3 编译过程</h4>
<p>虚拟机在编译器还未完成编译之前将按照解释方式继续执行代码，而编译动作则在<strong>后台的编译线程</strong>中进行。</p>
<h5 id="客户端编译器">1.3.1 客户端编译器</h5>
<p>对于<strong>客户端编译器</strong>来说，主要的关注点在于<u>局部性的优化</u>，而放弃了许多耗时较长的全局优化手段：</p>
<ul>
<li>第一个阶段，一个<code>平台独立的前端</code>将字节码构造成一种<code>高级中间代码表示（High-Level Intermediate Representation，HIR</code>），即<u><strong>与目标机器指令集无关</strong></u>的中间表示。
<ul>
<li><code>HIR</code>使用<code>静态单分配（Static Single Assignment，SSA）</code>的形式来代表代码值。</li>
<li>在字节码被构造成<code>HIR</code>之前，编译器已经会在字节码上完成一部分基础优化，如<u>方法内联</u>、<u>常量传播</u>等优。</li>
</ul></li>
<li>第二个阶段，一个<code>平台相关的后端</code>从<code>HIR</code>中产生<code>低级中间代码表示（Low-Level Intermediate Representation，LIR</code>，即<u><strong>与目标机器指令集相关</strong></u>的中间表示。
<ul>
<li>而在此之前会在<code>HIR</code>上完成一些优化，如<u>空值检查消除</u>、<u>范围检查消除</u>等。</li>
</ul></li>
<li>最后的阶段，在<code>平台相关的后端</code>使用<code>线性扫描算法（Linear Scan Register Allocation）</code>在<code>LIR</code>上分配寄存器，并在<code>LIR</code>上做<code>窥孔（Peephole）</code>优化，然后产生机器代码。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ClientCompiler.PNG" alt="Client Compiler架构" /><figcaption aria-hidden="true">Client Compiler架构</figcaption>
</figure>
<h5 id="服务端编译器">1.3.2 服务端编译器</h5>
<p>服务端编译器是一个能容忍很高优化复杂度的高级编译器，会执行大部分经典的优化动作，如：</p>
<ul>
<li>无用代码消除（Dead Code Elimination）</li>
<li>循环展开（Loop Unrolling）</li>
<li>循环表达式外提（Loop Expression Hoisting）</li>
<li>消除公共子表达式（Common Subexpression Elimination）</li>
<li>常量传播（Constant Propagation）</li>
<li>基本块重排序（Basic Block Reordering）</li>
<li>等</li>
</ul>
<p>还会实施一些<strong>与Java语言特性密切相关的优化技术</strong>，如：</p>
<ul>
<li>范围检查消除（Range Check Elimination）</li>
<li>空值检查消除（Null Check Elimination）</li>
<li>等</li>
</ul>
<p>还可能根据解释器或客户端编译器提供的性能监控信息，进行一些<strong>不稳定的预测性激进优化</strong>，如：</p>
<ul>
<li>守护内联（Guarded Inlining）</li>
<li>分支频率预测 （Branch Frequency Prediction）</li>
<li>等</li>
</ul>
<p>服务端编译采用的<strong>寄存器分配器</strong>是一个<code>全局图着色分配器</code>，它可以充分利用某些处理器架构（如<code>RISC</code>）上的大寄存器集合。</p>
<h4 id="实战查看及分析即时编译结果">1.4 实战：查看及分析即时编译结果</h4>
<p>从外部观察Java虚拟机的即时编译行为。</p>
<ul>
<li>可以使用参数<code>-XX:+PrintCompilation</code>要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来。如下图所示（其中带有<code>“%”</code>的输出说明是由回边计数器触发的栈上替换编译）</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testJIT1.PNG" alt="被即时编译的代码(部分)" /><figcaption aria-hidden="true">被即时编译的代码(部分)</figcaption>
</figure>
<ul>
<li><p>加上参数<code>-XX:+PrintInlining</code>要求虚拟机输出方法内联信息</p></li>
<li><p>可以使用<code>-XX:+PrintAssembly</code>参数要求虚拟机打印编译方法的汇编代码。如果没有<code>HSDIS</code>插件支持，也可以使用<code>-XX：+PrintOptoAssembly</code>（用于服务端模式的虚拟机） 或<code>-XX：+PrintLIR</code>（用于客户端模式的虚拟机）来输出比较接近最终结果的中间代码表示</p></li>
<li><p>可以使用参数<code>-XX：+PrintCFGToFile</code>（用于客户端编译器）或<code>-XX：PrintIdealGraphFile</code>（用于服务端编译器）要求Java虚拟机将编译过程中各个阶段的数据输出到文件中。可以使用<code>Java HotSpot Client Compiler Visualizer</code>（用于分析客户端编译器）或<code>Ideal Graph Visualizer</code>（用于分析服务端编译器）打开这些数据文件进行分析。</p></li>
</ul>
<h3 id="提前编译器">2. 提前编译器</h3>
<h4 id="提前编译的优劣得失">2.1 提前编译的优劣得失</h4>
<p><code>提前编译</code>的研究有着两条明显的分支：</p>
<ul>
<li>一条分支是做与传统<code>C、C++</code>编译器类似的，<u>在程序运行之前把程序代码编译成机器码的静态翻译</u>工作。
<ul>
<li>这是传统的提前编译应用形式，在Java中存在的价值是为了解决<u><strong>即时编译要占用程序运行时间和运算资源</strong></u>。</li>
</ul></li>
<li>另一条分支是<u>把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码时直接把它加载进来使用</u>。
<ul>
<li>这种提前编译被称为<code>动态提前编译（Dynamic AOT）</code>或者<code>即时编译缓存（JIT Caching）</code>。</li>
<li>本质是给即时编译器做<strong>缓存加速</strong>，去改善Java程序的启动时间，以及需要一段时间预热后才能到达最高性能的问题。</li>
</ul></li>
</ul>
<p>即时编译器相对于提前编译器的天然优势：</p>
<ul>
<li><code>性能分析制导优化（Profile-Guided Optimization，PGO）</code>。</li>
<li><code>激进预测性优化（Aggressive Speculative Optimization）</code>，这也已经成为很多即时编译优化措施的基础。</li>
<li><code>链接时优化（Link-Time Optimization，LTO）</code>，Java语言天生就是动态链接的，一个个Class文件在运行期被加载到虚拟机内存当中，然后在即时编译器里产生优化后的本地代码。</li>
</ul>
<h4 id="实战jaotc的提前编译">2.2 实战：<code>Jaotc</code>的提前编译</h4>
<p><code>JDK 9</code>引入了用于支持对Class文件和模块进行提前编译的工具<code>Jaotc</code>，以减少程序的启动时间和到达全速性能的预热时间，但这项功能必须针对特定物理机器和目标虚拟机的运行参数来使用。</p>
<p><code>Jaotc</code>做的提前编译属于<code>“第二条分支”</code>，即做即时编译的缓存；而<code>Substrate VM</code>则是选择的<code>“第一条分支”</code>，做的是传统的静态提前编译。</p>
<h3 id="编译器优化技术">3. 编译器优化技术</h3>
<p>编译器的目标虽然是做由程序代码翻译为本地机器码的工作，但<strong>输出代码优化质量的高低</strong>才是决定编译器优秀与否的关键。</p>
<h4 id="优化技术概览">3.1 优化技术概览</h4>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/PerformanceTacticIndex1.PNG" alt="即时编译器优化技术一览" /><figcaption aria-hidden="true">即时编译器优化技术一览</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/PerformanceTacticIndex2.PNG" alt="即时编译器优化技术一览（续）" /><figcaption aria-hidden="true">即时编译器优化技术一览（续）</figcaption>
</figure>
<p>即时编译器对这些代码优化变换是建立在<strong>代码的中间表示或者是机器码</strong>之上的，而不是直接在Java源码上去做的。使用Java语言的语法来表示优化技术所发挥的作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优化前的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	y = b.get();</span><br><span class="line">	<span class="comment">// ...do stuff...</span></span><br><span class="line">	z = b.get();</span><br><span class="line">	sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个要进行的优化是<code>方法内联</code>，它的主要目的有两个：</p>
<ul>
<li>一是去除方法调用的成本（如查找方法版本、建立栈帧等）；</li>
<li>二是为其他优化建立良好的基础。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内联后的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    z = b.value;</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步进行<code>冗余访问消除（Redundant Loads Elimination）</code>，也可以把这项优化看作一种<code>公共子表达式消除（Common Subexpression Elimination）</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冗余访问消除的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    z = y;</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步进行<code>复写传播（Copy Propagation）</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复写传播的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    y = y;</span><br><span class="line">    sum = y + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四步进行<code>无用代码消除（Dead Code Elimination）</code>，无用代码可能是<u>永远不会被执行的代码</u>，也可能是<u>完全没有意义的代码</u>，因此它又被称为<code>“Dead Code”</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行无用代码消除的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    sum = y + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四种具有代表性的优化技术：</p>
<ul>
<li>最重要的优化技术之一：方法内联。</li>
<li>最前沿的优化技术之一：逃逸分析。</li>
<li>语言无关的经典优化技术之一：公共子表达式消除。</li>
<li>语言相关的经典优化技术之一：数组边界检查消除。</li>
</ul>
<h4 id="方法内联">3.2 方法内联</h4>
<p>内联被业内戏称为<code>优化之母</code>，因为除了消除方法调用的成本之外，它更重要的意义是<u><strong>为其他优化手段建立良好的基础</strong></u>。</p>
<blockquote>
<p>方法内联的优化行为可以理解为<u><strong>把目标方法的代码原封不动地“复制”到发起调用的方法之中，避免发生真实的方法调用</strong></u>。但Java的虚方法调用都必须在运行时进行方法接收者的多态选择，它们都有可能存在多于一个版本的方法接收者，编译器静态地去做内联的时候很难确定应该使用哪个方法版本。</p>
</blockquote>
<p>为了解决虚方法的内联问题，Java虚拟机引入了<code>类型继承关系分析（Class Hierarchy Analysis，CHA）</code>技术。</p>
<blockquote>
<p>是<code>整个应用程序范围内</code>的类型分析技术，用于确定在目前已加载的类中，<u>某个接口是否有多于一种的实现</u>、<u>某个类是否存在子类</u>、<u>某个子类是否覆盖了父类的某个虚方法</u>等信息。</p>
</blockquote>
<ul>
<li>如果是非虚方法，直接进行内联；</li>
<li>如果是虚方法，则会向<code>CHA</code>查询此方法在当前程序状态下是否真的有多个目标版本可供选择
<ul>
<li>如果查询到只有一个版本，那就可以假设<em>“应用程序的全貌就是现在运行的这个样子”</em>来进行内联，这种内联被称为<code>守护内联（Guarded Inlining）</code>。由于Java程序是动态连接的，可能会加载到新类型从而改变<code>CHA</code>结论，因此这种内联属于<code>激进预测性优化</code>，必须预留<code>“逃生门”</code>，即当假设条件不成立时的<code>“退路”（Slow Path）</code>。
<ul>
<li>若在程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。</li>
<li>若加载了导致继承关系发生变化的新类，那么必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。</li>
</ul></li>
<li>如果向<code>CHA</code>查询出来的结果是该方法有多个版本的目标方法可供选择，即时编译器还将使用<code>内联缓存（Inline Cache）</code>的方式来缩减方法调用的开销。<code>内联缓存</code>是一个建立在<u><strong>目标方法正常入口之前</strong></u>的缓存，工作原理大致为：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。
<ul>
<li>如果以后进来的每次调用的方法接收者版本都是一样的，那么这时它就是一种<code>单态内联缓存（Monomorphic Inline Cache）</code>。通过该缓存来调用，比用不内联的非虚方法调用，仅多了一次类型判断的开销。</li>
<li>如果出现方法接收者不一致，说明程序用到了方法的多态特性，这时候会退化成<code>超多态内联缓存（Megamorphic Inline Cache）</code>，其开销相当于真正查找虚方法表来进行方法分派。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="逃逸分析">3.3 逃逸分析</h4>
<p><code>逃逸分析（Escape Analysis）</code>与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。</p>
<blockquote>
<p>基本原理是：分析对象<code>动态作用域</code>，当一个对象在方法里面被定义后：</p>
<ul>
<li>可能被<strong>外部方法</strong>所引用，例如作为调用参数传递到其他方法中，这种称为<code>方法逃逸</code>；</li>
<li>可能被<strong>外部线程</strong>访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为<code>线程逃逸</code>；</li>
<li>从不逃逸、方法逃逸到线程逃逸，称为对象<strong>由低到高</strong>的不同<code>逃逸程度</code>。</li>
</ul>
</blockquote>
<p>根据<code>逃逸程度</code>可以为这个对象实例采取不同程度的优化：</p>
<ul>
<li><code>栈上分配（Stack Allocations）</code>：如果确定一个对象<strong>不会逃逸出线程</strong>之外，可以让这个对象<u>在栈上分配内存</u>，对象所占用的内存空间就可以随栈帧出栈而自动销毁，垃圾收集子系统的压力将会下降很多。<u>栈上分配可以支持方法逃逸，但不能支持线程逃逸</u>。</li>
<li><code>标量替换（Scalar Replacement）</code>：Java虚拟机中的原始数据类型都不能再进一步分解分解成更小的数据来表示，这些数据可以被称为<code>标量</code>。如果一个数据可以继续分解，那它就被称为<code>聚合量（Aggregate）</code>。
<ul>
<li><u>把一个Java对象拆散，根据程序访问的情况，<strong>将其用到的成员变量恢复为原始类型来访问</strong></u>，这个过程就称为<code>标量替换</code>。</li>
<li>假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。对象拆分后可以让对象的成员变量在栈上 分配和读写，标量替换可以视作<code>栈上分配的一种特例</code>，实现更简单。</li>
<li><u><strong>它不允许对象逃逸出方法范围内</strong></u>。</li>
</ul></li>
<li><code>同步消除（Synchronization Elimination）</code>：如果逃逸分析能够确定一个变量<strong>不会逃逸出线程</strong>，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，<u>对这个变量实施的同步措施也就可以安全地消除掉</u>。</li>
</ul>
<p>逃逸分析的<u>计算成本非常高</u>，甚至不能保证逃逸分析带来的性能收益会高于它的消耗，但它是即时编译器优化技术的一个重要前进方向。</p>
<h4 id="公共子表达式消除">3.4 公共子表达式消除</h4>
<p>公共子表达式消除是：如果一个表达式<code>E</code>之前已经被计算过了，并且从先前的计算到现在<code>E</code>中所有变量的值都没有发生变化，那么<code>E</code>的这次出现就称为<code>公共子表达式</code>。对于这种表达式，只需要直接用前面计算过的表达式结果代替<code>E</code>。</p>
<ul>
<li>如果这种优化仅限于<strong>程序基本块</strong>内，便可称为<code>局部公共子表达式消除（Local Common Subexpression Elimination）</code>；</li>
<li>如果这种优化的范围涵盖了<strong>多个基本块</strong>，那就称为<code>全局公共子表达式消除（Global Common Subexpression Elimination）</code>。</li>
</ul>
<h4 id="数组边界检查消除">3.5 数组边界检查消除</h4>
<p><code>数组边界检查消除（Array Bounds Checking Elimination）</code>是语言相关的。Java语言是一门<code>动态安全</code>的语言，访问数组元素<code>foo[i]</code>时系统将会自动进行<u>上下界的范围检查</u>，即i必须满足<code>“i&gt;=0&amp;&amp;i&lt;foo.length”</code>的访问条件，所以每次数组元素的读写都带有一次隐含的条件判定操作。</p>
<ul>
<li>可以进行<code>数组边界检查优化</code>，尽可能把运行期检查提前到编译期完成。比如通过数据流分析就可以判定循环变量的取值范围是否在上下界区间内，如果在，可以把上下界检查消除掉。</li>
<li>还可以进行隐式异常处理。需要根据运行期收集到的性能监控信息选择最合适的方案</li>
</ul>
<h3 id="实战深入理解graal编译器">4. 实战：深入理解<code>Graal</code>编译器</h3>
<h4 id="java虚拟机编译器接口">4.1 Java虚拟机编译器接口</h4>
<p><code>Java虚拟机编译器接口（Java-Level JVM Compiler Interface，JVMCI）</code>使得<code>Graal</code>可以从<code>HotSpot</code>的代码中分离出来。<code>JVMCI</code>主要提供如下三种功能：</p>
<ul>
<li>响应<code>HotSpot</code>的编译请求，并将该请求分发给Java实现的即时编译器。</li>
<li>允许编译器访问<code>HotSpot</code>中<u>与即时编译相关的数据结构</u>，包括类、字段、方法及其性能监控数据等，并提供了一组这些数据结构在Java语言层面的抽象表示。</li>
<li>提供<code>HotSpot</code>代码缓存（<code>Code Cache</code>）的Java端抽象表示，允许编译器部署编译完成的二进制机器码。</li>
</ul>
<p><code>JVMCI</code>编译器接口输入要编译的方法的字节码，即<code>“用一个字节数组表示的代码”</code>。输出与方法对应的二进制机器码，二进制机器码也应该是<code>“用一个字节数组表示的代码”</code>。这样的话，<code>JVMCI</code>接口就应该类似于下面形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JVMCICompiler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] compileMethod(<span class="keyword">byte</span>[] bytecode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上<code>JVMCI</code>接口只比上面这个稍微复杂一点，其输入除了字节码外，<code>HotSpot</code>还会向编译器提供各种该方法的相关信息，譬如<u>局部变量表中变量槽的个数</u>、<u>操作数栈的最大深度</u>，还有<u>分层编译在底层收集到的统计信息</u>等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JVMCICompiler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">compileMethod</span><span class="params">(CompilationRequest request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompilationRequest</span> </span>&#123;</span><br><span class="line">	<span class="function">JavaMethod <span class="title">getMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JavaMethod</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] getCode();</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getMaxLocals</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getMaxStackSize</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">ProfilingInfo <span class="title">getProfilingInfo</span><span class="params">()</span></span>;</span><br><span class="line">	... <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码中间表示">4.2 代码中间表示</h4>
<p><code>Graal编译器</code>在采用了与<code>HotSpot</code>服务端编译器一致（略有差异但已经非常接近）的中间表示形式，也即是被称为<code>Sea-of-Nodes</code>的中间表示，或者与其等价的被称为<code>理想图</code>（<code>Ideal Graph</code>，在代码中称为<code>Structured Graph</code>）的<code>程序依赖图（Program Dependence Graph，PDG）</code>形式。</p>
<blockquote>
<p>从编译器内部来看理想图上翻译和优化输入代码的整体过程即：<code>字节码→理想图→优化→机器码</code></p>
</blockquote>
<p>理想图是一种<code>有向图</code>，用节点来表示<strong>程序中的元素</strong>，譬如变量、操作符、方法、字段等，而用边来表示<strong>数据</strong>或者<strong>控制流</strong>。如表达式：<code>x+y</code>，在理想图中可以表示为<code>x</code>、<code>y</code>两个节点的数据流流入加法操作符。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/IdealGraph1.PNG" alt="构造理想图" /><figcaption aria-hidden="true">构造理想图</figcaption>
</figure>
<p>把表达式<code>x+y</code>变为<code>getX()+getY()</code>，理想图除了需要表达数据流向之外，还必须要考虑方法调用的顺序。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/IdealGraph2.PNG" alt="构造理想图" /><figcaption aria-hidden="true">构造理想图</figcaption>
</figure>
<blockquote>
<p>理想图本质上就是这种将<code>数据流图</code>和<code>控制流图</code>以某种方式合并到一起，用一种边来表示数据流向，另一种边来表示控制流向的图形表示。</p>
</blockquote>
<h4 id="代码优化与生成">4.3 代码优化与生成</h4>
<p><code>Graal编译器</code>中创建理想图的方法是<code>createGraph()</code>，<code>createGraph()</code>方法内调用了<code>StructuredGraph::Builder()</code>构造器来创建理想图。</p>
<h5 id="理想图本身的数据结构">4.3.1 理想图本身的数据结构</h5>
<p>它是一组<strong>不为空</strong>的节点的集合，它的节点都是用<code>ValueNode</code>的不同类型的<strong>子类节点</strong>来表示的。如加法操作就由<code>AddNode</code>节点来表示，到加法操作是<code>二元算术操作节点（BinaryArithmeticNode&lt;OP&gt;）</code>的一种，而二元算术操作节点又是<code>二元操作符（BinaryNode）</code>的一种。</p>
<h5 id="从字节码转换到理想图">4.3.2 从字节码转换到理想图</h5>
<p>该过程被封装在<code>BytecodeParser</code>类中，可以按照字节码解释器的思路去理解该解析器。<code>BytecodeParser::genArithmeticOp()</code>方法如下：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/genArithmeticOp.PNG" alt="genArithmeticOp方法" /><figcaption aria-hidden="true">genArithmeticOp方法</figcaption>
</figure>
<p>其中，<code>genIntegerAdd()</code>方法中就只有一行代码，即调用<code>AddNode</code>节点的<code>create()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ValueNode <span class="title">genIntegerAdd</span><span class="params">(ValueNode x, ValueNode y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> AddNode.create(x, y, NodeView.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ValueNode <span class="title">create</span><span class="params">(ValueNode x, ValueNode y, NodeView view)</span> </span>&#123;</span><br><span class="line">	BinaryOp&lt;Add&gt; op = ArithmeticOpTable.forStamp(x.stamp(view)).getAdd();</span><br><span class="line">	Stamp stamp = op.foldStamp(x.stamp(view), y.stamp(view));</span><br><span class="line">	ConstantNode tryConstantFold = tryConstantFold(op, x, y, stamp, view);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (tryConstantFold != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> tryConstantFold;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x.isConstant() &amp;&amp; !y.isConstant()) &#123;</span><br><span class="line">		<span class="keyword">return</span> canonical(<span class="keyword">null</span>, op, y, x, view);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> canonical(<span class="keyword">null</span>, op, x, y, view);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个理想图的节点都有两个共同的主要操作：</p>
<ul>
<li><strong>规范化</strong>（<code>Canonicalisation</code>），即代码优化。在理想图的基础上优化代码所要采取的措施，实现在<code>canonical()</code>方法中。</li>
<li><strong>生成机器码</strong>（<code>Generation</code>），即代码翻译。实现在<code>generate()</code>方法中。<code>Graal</code>并不是直接由理想图转换到机器码，而是会先生成<code>低级中间表示</code>（<code>LIR</code>，与具体机器指令集相关的中间表示），然后再由<code>HotSpot</code>统一后端来产生机器码。</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Java并发编程的艺术]--10 Executor框架</title>
    <url>/2021/07/22/JavaLearning_The_art_of_concurrent_programming_in_Java-10-Executor-framework.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>Java的线程既是<strong>工作单元</strong>，也是<strong>执行机制</strong>。<code>JDK 5</code>开始，把<strong>工作单元</strong>与<strong>执行机制</strong>分离开来，<strong>工作单元</strong>包括<code>Runnable</code>和<code>Callable</code>，而执行机制由<code>Executor</code>框架提供。 <a id="more"></a></p>
<h3 id="executor框架简介">1. <code>Executor</code>框架简介</h3>
<h4 id="executor框架的两级调度模型">1.1 <code>Executor</code>框架的两级调度模型</h4>
<p>两级调度模型即：</p>
<ul>
<li><strong>应用程序通过<code>Executor</code>框架控制<u>上层的调度</u></strong>。<code>Java</code>多线程程序把应用分解为若干个任务，然后使用用户级的调度器（<code>Executor</code>框架）将这些任务映射为固定数量的线程；</li>
<li><strong>由<code>操作系统内核</code>控制<u>下层的调度</u></strong>。操作系统内核将这些线程映射到硬件处理器上，下层的调度不受应用程序的控制。在<code>HotSpot VM</code>的线程模型中，<code>Java</code>线程（<code>java.lang.Thread</code>）被一对一映射为本地操作系统线程。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/TwoLevelSchedule.PNG" alt="线程池的主要处理流程" /><figcaption aria-hidden="true">线程池的主要处理流程</figcaption>
</figure>
<h4 id="executor框架的结构与成员">1.2 <code>Executor</code>框架的结构与成员</h4>
<h5 id="executor框架的结构">1.2.1 <code>Executor</code>框架的结构</h5>
<p><code>Executor</code>框架主要由3大部分组成：</p>
<ul>
<li><strong>任务</strong>。包括被执行任务需要实现的接口：<code>Runnable</code>接口或<code>Callable</code>接口。
<ul>
<li><code>Runnable</code>接口和<code>Callable</code>接口的实现类，都可以被<code>Executor</code>接口的<strong>实现类</strong>执行。</li>
</ul></li>
<li><strong>任务的执行</strong>。包括任务执行机制的核心接口<code>Executor</code>，以及继承自<code>Executor</code>的<code>ExecutorService</code>接口。<code>Executor</code>接口是<strong>Executor框架</strong>的基础，它将任务的提交与任务的执行分离开来。<code>Executor</code>框架有两个<strong>关键类</strong>实现了<code>ExecutorService</code>接口：
<ul>
<li><code>ThreadPoolExecutor</code>，线程池的核心实现类，用来<strong><u>执行被提交的任务</u></strong>；</li>
<li><code>ScheduledThreadPoolExecutor</code>，可以<strong><u>在给定的延迟后运行命令，或者定期执行命令</u></strong>。比<code>Timer</code>更灵活，功能更强大。</li>
</ul></li>
<li><strong>异步计算的结果</strong>。包括接口<code>Future</code>和实现<code>Future</code>接口的<code>FutureTask</code>类，代表异步计算的结果。</li>
</ul>
<p><code>Executor</code>框架的使用过程一般如下：</p>
<ul>
<li>主线程首先要创建实现<code>Runnable</code>或者<code>Callable</code>接口的任务对象。工具类<code>Executors</code>可以把一 个<code>Runnable</code>对象封装为一个<code>Callable</code>对象：
<ul>
<li><code>Executors.callable(Runnable task)</code>；</li>
<li><code>Executors.callable(Runnable task, Object resule)</code>。</li>
</ul></li>
<li>然后可以把<code>Runnable</code>对象<strong><u>直接</u></strong>交给<code>ExecutorService</code>执行；或者也可以把<code>Runnable</code>对象或<code>Callable</code>对象<strong><u>提交</u></strong>给<code>ExecutorService</code>执行：
<ul>
<li><code>ExecutorService.execute(Runnable command)</code></li>
<li><code>ExecutorService.submit(Runnable task)</code></li>
<li><code>ExecutorService.submit(Callabletask)</code></li>
</ul></li>
<li>如果执行<code>ExecutorService.submit</code>，<code>ExecutorService</code>将返回一个实现<code>Future</code>接口的对象。
<ul>
<li>由于<code>FutureTask</code>实现了<code>Runnable</code>，也可以创建<code>FutureTask</code>，然后直接交给<code>ExecutorService</code>执行</li>
</ul></li>
<li>最后，主线程可以执行<code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行<code>FutureTask.cancel(boolean mayInterruptIfRunning)</code>来取消此任务的执行。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/ExractorFramework.PNG" alt="线程池的主要处理流程" /><figcaption aria-hidden="true">线程池的主要处理流程</figcaption>
</figure>
<h5 id="executor框架的成员">1.2.2 <code>Executor</code>框架的成员</h5>
<h6 id="threadpoolexecutor">1.2.2.1 <code>ThreadPoolExecutor</code></h6>
<p><code>ThreadPoolExecutor</code>通常使用工厂类<code>Executors</code>来创建。<code>Executors</code>可以创建3种类型的<code>ThreadPoolExecutor</code>：</p>
<ul>
<li><p><code>SingleThreadExecutor</code>。适用于<strong><u>需要保证顺序地执行各个任务</u></strong>；并且在任意时间点，不会有多个线程是活动的应用场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Executors提供的API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><code>FixedThreadPool</code>。适用于为了满足资源管理的需求，而<strong><u>需要限制当前线程数量</u></strong>的应用场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Executors提供的API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><code>CachedThreadPool</code>。<strong><u>大小无界</u></strong>的线程池，适用于执行很多的<strong><u>短期异步任务</u></strong>的小程序，或者是负载较轻的服务器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Executors提供的API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="scheduledthreadpoolexecutor">1.2.2.2 <code>ScheduledThreadPoolExecutor</code></h6>
<p><code>ScheduledThreadPoolExecutor</code>通常使用工厂类<code>Executors</code>来创建。Executors可以创建2种类型的<code>ScheduledThreadPoolExecutor</code>：</p>
<ul>
<li><p><code>ScheduledThreadPoolExecutor</code>。包含若干个线程的<code>ScheduledThreadPoolExecutor</code>。适用于<strong><u>需要多个后台线程执行周期任务</u></strong>，同时为了满足资源管理的需求而<strong><u>需要限制后台线程的数量</u></strong>的应用场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize,ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><code>SingleThreadScheduledExecutor</code>。只包含一个线程的<code>ScheduledThreadPoolExecutor</code>。适用于需要<strong><u>单个后台线程执行周期任务</u></strong>，同时<strong><u>需要保证顺序地执行各个任务</u></strong>的应用场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="future接口">1.2.2.3 <code>Future</code>接口</h6>
<p><code>Future</code>接口和实现<code>Future</code>接口的<code>FutureTask</code>类用来表示异步计算的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span></span><br><span class="line"><span class="function">Future&lt;&gt; <span class="title">submit</span><span class="params">(Runnable task)</span></span></span><br></pre></td></tr></table></figure>
<p>把<code>Runnable</code>接口或<code>Callable</code>接口的实现类<strong><u>提交（submit）</u></strong>给<code>ThreadPoolExecutor</code>或<code>ScheduledThreadPoolExecutor</code>时，<code>ThreadPoolExecutor</code>或<code>ScheduledThreadPoolExecutor</code>会返回一个<code>FutureTask</code>对象。</p>
<h6 id="runnable接口和callable接口">1.2.2.4 <code>Runnable</code>接口和<code>Callable</code>接口</h6>
<p>它们之间的区别是<code>Runnable</code><strong>不会返回结果</strong>，而<code>Callable</code><strong>可以返回结果</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把一个Runnable包装成一个Callable</span></span><br><span class="line"><span class="comment">// 当任务成功完成后FutureTask.get()方法将返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 把一个Runnable和一个待返回的结果包装成一个Callable</span></span></span><br><span class="line"><span class="function"><span class="comment">// 当任务成功完成后FutureTask.get()方法将返回result对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="threadpoolexecutor详解">2. <code>ThreadPoolExecutor</code>详解</h3>
<p><code>Executor</code>框架<strong>最核心</strong>的类是<code>ThreadPoolExecutor</code>，它是<strong><u>线程池的实现类</u></strong>，主要由下列4个组件构成。</p>
<ul>
<li><code>corePool</code>：核心线程池的大小。</li>
<li><code>maximumPool</code>：最大线程池的大小。</li>
<li><code>BlockingQueue</code>：用来暂时保存任务的工作队列。</li>
<li><code>RejectedExecutionHandler</code>：当<code>ThreadPoolExecutor</code>已经关闭或<code>ThreadPoolExecutor</code>已经饱和时，<code>execute()</code>方法将要调用的Handler。</li>
</ul>
<h4 id="fixedthreadpool详解">2.1 <code>FixedThreadPool</code>详解</h4>
<p><code>FixedThreadPool</code>被称为<strong><u>可重用固定线程数</u></strong>的线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>FixedThreadPool</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>都被设置为创建<code>FixedThreadPool</code>时指定的参数<code>nThreads</code>。</li>
<li>当线程池中的线程数大于<code>corePoolSize</code>时，<code>keepAliveTime</code>为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。这里把<code>keepAliveTime</code>设置为<code>0L</code>，意味着<strong><u>多余的空闲线程会被立即终止</u></strong>。</li>
</ul>
<p><code>FixedThreadPool</code>的<code>execute()</code>方法的运行流程如下：</p>
<ul>
<li>如果当前运行的线程数少于<code>corePoolSize</code>，则创建新线程来执行任务；</li>
<li>在线程池完成预热之后（当前运行的线程数等于<code>corePoolSize</code>），将任务加入 <code>LinkedBlockingQueue</code>。</li>
<li>线程执行完<code>1</code>中的任务后，会在循环中反复从<code>LinkedBlockingQueue</code>获取任务来执行。</li>
</ul>
<p><code>FixedThreadPool</code>使用<strong><u>无界队列</u></strong><code>LinkedBlockingQueue</code>作为线程池的工作队列（队列的容量为 <code>Integer.MAX_VALUE</code>）。使用无界队列作为工作队列会对线程池带来如下影响：</p>
<ol type="1">
<li>当线程池中的线程数达到<code>corePoolSize</code>后，新任务将在无界队列中等待，因此线程池中的线程数不会超过<code>corePoolSize</code>。</li>
<li>使用无界队列时<code>maximumPoolSize</code>将是一个无效参数。使用无界队列时<code>keepAliveTime</code>将是一个无效参数。</li>
<li>由于使用无界队列，运行中的<code>FixedThreadPool</code>（未执行方法<code>shutdown()</code>或<code>shutdownNow()</code>）不会拒绝任务。</li>
</ol>
<h4 id="singlethreadexecutor详解">2.2 <code>SingleThreadExecutor</code>详解</h4>
<p><code>SingleThreadExecutor</code>是使用<strong><u>单个</u></strong><code>worker</code>线程的<code>Executor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>SingleThreadExecutor</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>被设置为<code>1</code>。</li>
<li><code>SingleThreadExecutor</code>使用无界队列<code>LinkedBlockingQueue</code>作为线程池的工作队列（队列的容量为<code>Integer.MAX_VALUE</code>）。</li>
</ul>
<h4 id="cachedthreadpool详解">2.3 <code>CachedThreadPool</code>详解</h4>
<p><code>CachedThreadPool</code>是一个会根据需要创建新线程的线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>CachedThreadPool</code>的<code>corePoolSize</code>被设置为<code>0</code>，即<code>corePool</code>为空；</p></li>
<li><p><code>maximumPoolSize</code>被设置为<code>Integer.MAX_VALUE</code>，即<code>maximumPool</code>是无界的。</p></li>
<li><p><code>keepAliveTime</code>设置为<code>60L</code>，意味着<code>CachedThreadPool</code>中的空闲线程等待新任务的最长时间为<code>60</code>秒，空闲线程超过<code>60</code>秒后将会被终止。</p></li>
<li><p><code>CachedThreadPool</code>使用<strong><u>没有容量</u></strong>的<code>SynchronousQueue</code>作为线程池的工作队列，但<code>CachedThreadPool</code>的<code>maximumPool</code>是无界的。</p>
<ul>
<li>如果主线程提交任务的速度高于<code>maximumPool</code>中线程处理任务的速度时，<code>CachedThreadPool</code>会不断创建新线程。</li>
<li>极端情况下，<code>CachedThreadPool</code>会<strong><u>因为创建过多线程而耗尽CPU和内存资源</u></strong>。</li>
</ul></li>
</ul>
<p><code>CachedThreadPool</code>的<code>execute()</code>方法的执行流程为：</p>
<ol type="1">
<li>首先执行<code>SynchronousQueue.offer(Runnable task)</code>。如果当前<code>maximumPool</code>中有空闲线程正在执行<code>SynchronousQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>，那么主线程执行<code>offer</code>操作与空闲线程执行的<code>poll</code>操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code>方法执行完成；</li>
<li>当初始<code>maximumPool</code>为空，或者<code>maximumPool</code>中当前没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>。此时<code>CachedThreadPool</code>会创建一个新线程执行任务，<code>execute()</code>方法执行完成。</li>
<li>新创建的线程将任务执行完后，会执行 <code>SynchronousQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>。这个<code>poll</code>操作会让空闲线程最多在<code>SynchronousQueue</code>中等待<code>60</code>秒钟。
<ul>
<li>如果<code>60</code>秒钟内主线程提交了一个新任务，那么这个空闲线程将执行主线程提交的新任务；</li>
<li>否则，这个空闲线程将终止。</li>
</ul></li>
</ol>
<h3 id="scheduledthreadpoolexecutor详解">3. <code>ScheduledThreadPoolExecutor</code>详解</h3>
<p><code>ScheduledThreadPoolExecutor</code>继承自<code>ThreadPoolExecutor</code>。主要用来在给定的延迟之后运行任务，或者定期执行任务。</p>
<h4 id="scheduledthreadpoolexecutor的运行机制">3.1 <code>ScheduledThreadPoolExecutor</code>的运行机制</h4>
<p><code>ScheduledThreadPoolExecutor</code>使用无界队列<code>DelayQueue</code>作为线程池的工作队列。执行主要分为两大部分：</p>
<ul>
<li>当调用<code>ScheduledThreadPoolExecutor</code>的<code>scheduleAtFixedRate()</code>方法或者<code>scheduleWithFixedDelay()</code>方法时，会向<code>ScheduledThreadPoolExecutor</code>的<code>DelayQueue</code>添加一个实现了<code>RunnableScheduledFutur</code>接口的<code>ScheduledFutureTask</code>。</li>
<li>线程池中的线程从<code>DelayQueue</code>中获取<code>ScheduledFutureTask</code>，然后执行任务。</li>
</ul>
<p>为了实现<strong><u>周期性</u></strong>的执行任务，<code>ScheduledThreadPoolExecutor</code>做了如下修改：</p>
<ul>
<li>使用<code>DelayQueue</code>作为任务队列。</li>
<li>获取任务的方式不同。</li>
<li>执行周期任务后，增加了额外的处理。</li>
</ul>
<h4 id="scheduledthreadpoolexecutor的实现">3.2 <code>ScheduledThreadPoolExecutor</code>的实现</h4>
<p><code>ScheduledFutureTask</code>主要包含3个成员变量：</p>
<ul>
<li><code>long</code>型成员变量<code>time</code>，表示这个任务将要被执行的具体时间。</li>
<li><code>long</code>型成员变量<code>sequenceNumber</code>，表示这个任务被添加到<code>ScheduledThreadPoolExecutor</code>中的序号。</li>
<li><code>long</code>型成员变量<code>period</code>，表示任务执行的间隔周期。</li>
</ul>
<p><code>DelayQueue</code>封装了一个<code>PriorityQueue</code>，这个<code>PriorityQueue</code>会对队列中的<code>ScheduledFutureTask</code>进行排序。</p>
<ul>
<li><code>time</code>小的排在前面。</li>
<li>如果两个<code>ScheduledFutureTask</code>的<code>time</code>相同，<code>sequenceNumber</code>小的排在前面。</li>
</ul>
<p><code>ScheduledThreadPoolExecutor</code>执行某个周期任务的4个步骤：</p>
<ol type="1">
<li><p>工作线程从<code>DelayQueue</code>中获取已到期的<code>ScheduledFutureTask</code>（<code>DelayQueue.take()</code>）。到期任务是指<code>ScheduledFutureTask</code>的<strong><u><code>time</code>大于等于当前时间</u></strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                available.await(); <span class="comment">// 2.1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> tl = available.awaitNanos(delay); <span class="comment">// 2.2</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    E x = q.poll(); <span class="comment">// 2.3.1</span></span><br><span class="line">                    <span class="keyword">assert</span> x != <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (q.size() != <span class="number">0</span>)</span><br><span class="line">                        available.signalAll(); <span class="comment">// 2.3.2</span></span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取任务分为3大步骤。</p>
<ul>
<li>获取<code>Lock</code>。</li>
<li>获取周期任务。
<ul>
<li>如果<code>PriorityQueue</code>为空，当前线程到<code>Condition</code>中等待；</li>
<li>如果<code>PriorityQueue</code>的头元素的<code>time</code>时间比当前时间大，到<code>Condition</code>中等待到<code>time</code>时间；</li>
<li>获取<code>PriorityQueue</code>的头元素，如果<code>PriorityQueue</code>不为空，则唤醒在<code>Condition</code>中等待的所有线程。</li>
</ul></li>
<li>释放<code>Lock</code>。</li>
</ul></li>
<li><p>工作线程执行这个<code>ScheduledFutureTask</code>，并修改<code>ScheduledFutureTask</code>的<code>time</code>变量为下次将要被执行的时间。</p></li>
<li><p>工作线程把这个修改<code>time</code>之后的<code>ScheduledFutureTask</code>放回<code>DelayQueue</code>中（<code>DelayQueue.add()</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E first = q.peek();</span><br><span class="line">        q.offer(e); <span class="comment">// 2.1</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || e.compareTo(first) &lt; <span class="number">0</span>)</span><br><span class="line">            available.signalAll(); <span class="comment">// 2.2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加任务分为3大步骤：</p>
<ul>
<li>获取<code>Lock</code>。</li>
<li>添加任务。
<ul>
<li>向<code>PriorityQueue</code>添加任务。</li>
<li>如果添加的任务是<code>PriorityQueue</code>的<strong>头元素</strong>，唤醒在<code>Condition</code>中等待的所有线程。</li>
</ul></li>
<li>释放<code>Lock</code>。</li>
</ul></li>
</ol>
<h3 id="futuretask详解">4. <code>FutureTask</code>详解</h3>
<h4 id="futuretask简介">4.1 <code>FutureTask</code>简介</h4>
<p><code>FutureTask</code>除了实现<code>Future</code>接口外，还实现了<code>Runnable</code>接口。因此，<code>FutureTask</code>可以交给<code>Executor</code>执行，也可以由调用线程直接执行（<code>FutureTask.run()</code>）。<code>FutureTask</code>可以处于下面3种状态：</p>
<ul>
<li><strong>未启动</strong>。当创建一 个<code>FutureTask</code>，<code>FutureTask.run()</code>方法还没有被执行之前，<code>FutureTask</code>处于未启动状态。</li>
<li><strong>已启动</strong>。<code>FutureTask.run()</code>方法被执行的过程中，<code>FutureTask</code>处于已启动状态。</li>
<li><strong>已完成</strong>。<code>FutureTask.run()</code>方法执行完后正常结束，或被取消（<code>FutureTask.cancel(…)</code>），或执行<code>FutureTask.run()</code>方法时抛出异常而异常结束，<code>FutureTask</code>处于已完成状态。</li>
</ul>
<p>不同状态下调用<code>FutureTask</code>方法的响应不同：</p>
<ul>
<li>当<code>FutureTask</code>处于<strong>未启动</strong>或<strong>已启动</strong>状态时，执行<code>FutureTask.get()</code>方法将导致调用线程阻塞；</li>
<li>当<code>FutureTask</code>处于<strong>已完成</strong>状态时，执行<code>FutureTask.get()</code>方法将导致调用线程立即返回结果或抛出异常。</li>
<li>当<code>FutureTask</code>处于<strong>未启动</strong>状态时，执行<code>FutureTask.cancel()</code>方法将导致此任务<strong><u>永远不会被执行</u></strong>；</li>
<li>当<code>FutureTask</code>处于<strong>已启动</strong>状态时，执行<code>FutureTask.cancel(true)</code>方法将以<strong><u>中断执行此任务线程</u></strong>的方式来试图停止任务；</li>
<li>当<code>FutureTask</code>处于<strong>已启动</strong>状态时，执行<code>FutureTask.cancel(false)</code>方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；</li>
<li>当<code>FutureTask</code>处于<strong>已完成</strong>状态时，执行<code>FutureTask.cancel(…)</code>方法将返回<code>false</code>。</li>
</ul>
<h4 id="futuretask的使用">4.2 <code>FutureTask</code>的使用</h4>
<p>当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行，此时可以使用<code>FutureTask</code>。</p>
<ul>
<li>可以把<code>FutureTask</code>交给<code>Executor</code>执行；</li>
<li>可以通过<code>ExecutorService.submit(…)</code>方法返回一个<code>FutureTask</code>，然后执行<code>FutureTask.get()</code>方法或<code>FutureTask.cancel(…)</code>方法；</li>
<li>也可以单独使用<code>FutureTask</code>。</li>
</ul>
<h4 id="futuretask的实现">4.3 <code>FutureTask</code>的实现</h4>
<p><code>FutureTask</code>的实现基于<code>AbstractQueuedSynchronizer</code>（<code>AQS</code>）：</p>
<ul>
<li><code>FutureTask</code>的<code>get()</code>/<code>get(long timeout, TimeUnit unit)</code>方法调用<code>AQS</code>的<code>acquire</code>操作。</li>
<li><code>FutureTask</code>的<code>run()</code>方法和<code>cancel(…)</code>方法调用<code>AQS</code>的<code>release</code>操作。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter10/FutureTask.PNG" alt="FutureTask的设计" /><figcaption aria-hidden="true">FutureTask的设计</figcaption>
</figure>
<p><code>Sync</code>是<code>FutureTask</code>继承自<code>AQS</code>的<strong><u>内部私有类</u></strong>，实现了<code>tryAcquireShared(int)</code>方法和<code>tryReleaseShared(int)</code>方法，<code>Sync</code>通过这两个方法来检查和更新同步状态。</p>
<blockquote>
<p>需要注意的是，在<code>jdk 1.8</code>，不再基于<code>AQS</code>实现<code>FutureTask</code>：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Revision notes: This differs from previous versions of this</span></span><br><span class="line"><span class="comment"> * class that relied on AbstractQueuedSynchronizer, mainly to</span></span><br><span class="line"><span class="comment"> * avoid surprising users about retaining interrupt status during</span></span><br><span class="line"><span class="comment"> * cancellation races. Sync control in the current design relies</span></span><br><span class="line"><span class="comment"> * on a "state" field updated via CAS to track completion, along</span></span><br><span class="line"><span class="comment"> * with a simple Treiber stack to hold waiting threads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Style note: As usual, we bypass overhead of using</span></span><br><span class="line"><span class="comment"> * AtomicXFieldUpdaters and instead directly use Unsafe intrinsics.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p><code>FutureTask.get()</code>方法执行过程为：</p>
<ol type="1">
<li>调用<code>AQS.acquireSharedInterruptibly(int arg)</code>方法，这个方法首先会回调在子类Sync中实现的<code>tryAcquireShared()</code>方法来判断<code>acquire</code>操作是否可以成功。
<ul>
<li><code>acquire</code>操作可以成功的条件为：<code>state</code>为<strong><u>执行完成</u></strong>状态<code>RAN</code>或<strong><u>已取消</u></strong>状态<code>CANCELLED</code>，且<code>runner</code>不为<code>null</code>。</li>
</ul></li>
<li>如果成功则<code>get()</code>方法立即返回。如果失败则到线程等待队列中去等待其他线程执行<code>release</code>操作。</li>
<li>当其他线程执行<code>release</code>操作唤醒当前线程后，当前线程再次执行<code>tryAcquireShared()</code>将返回正值<code>1</code>，当前线程将离开线程等待队列并唤醒它的后继线程。</li>
<li>最后返回计算的结果或抛出异常。</li>
</ol>
<p><code>FutureTask.run()</code>的执行过程如下：</p>
<ol type="1">
<li>执行在构造函数中指定的任务（<code>Callable.call()</code>）。</li>
<li>以原子方式来更新同步状态（调用<code>AQS.compareAndSetState(int expect，int update)</code>，设置<code>state</code>为执行完成状态<code>RAN</code>）。如果这个原子操作成功，就设置代表计算结果的变量<code>result</code>的值为<code>Callable.call()</code>的返回值，然后调用<code>AQS.releaseShared(int arg)</code>。</li>
<li><code>AQS.releaseShared(int arg)</code>首先会回调在子类<code>Sync</code>中实现的<code>tryReleaseShared(arg)</code>来执行<code>release</code>操作（设置运行任务的线程<code>runner</code>为<code>null</code>，然会返回<code>true</code>）；然后唤醒线程等待队列中的第一个线程。</li>
<li>调用<code>FutureTask.done()</code>。</li>
</ol>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--12  Java内存模型与线程</title>
    <url>/2021/06/06/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_12_Java_memory_model_and_threads.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>并发处理是人类压榨计算机运算能力的最有力武器。 <a id="more"></a></p>
</blockquote>
<h3 id="硬件的效率与一致性">1. 硬件的效率与一致性</h3>
<p>绝大多数的运算任务都不可能只靠处理器<code>“计算”</code>就能完成。处理器至少要与内存交互，如<u>读取运算数据</u>、 <u>存储运算结果</u>等，这个I/O操作很难消除（无法仅靠寄存器来完成所有运算任务）。</p>
<p>由于计算机的存储设备与处理器的运算速度有着几个<strong>数量级的差距</strong>，所以现代计算机系统都不得不加入<em>一层</em>或<em>多层</em>读写速度尽可能接近处理器运算速度的<code>高速缓存（Cache）</code>来作为内存与处理器之间的缓冲：</p>
<blockquote>
<p>将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p>
</blockquote>
<p>基于高速缓存的存储交互引入了一个新的问题：<code>缓存一致性（Cache Coherence）</code>。</p>
<blockquote>
<p>在多路处理器系统中，每 个处理器都有自己的高速缓存，而它们又共享同一<code>主内存（Main Memory）</code>，这种系统称为<code>共享内存多核系统（Shared Memory Multiprocessors System）</code>。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的<u><strong>缓存数据不一致</strong></u>。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/SharedMemoryMultiprocessorsSystem.PNG" alt="处理器、高速缓存、主内存间的交互关系" /><figcaption aria-hidden="true">处理器、高速缓存、主内存间的交互关系</figcaption>
</figure>
<p>为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有<code>MSI</code>、<code>MESI（Illinois Protocol）</code>、<code>MOSI</code>、 <code>Synapse</code>、<code>Firefly</code>及<code>Dragon Protocol</code>等。</p>
<h3 id="java内存模型">2. Java内存模型</h3>
<p><code>“Java内存模型”</code>（<code>Java Memory Model，JMM</code>）用于<u><strong>屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果</strong></u>。</p>
<h4 id="主内存与工作内存">2.1 主内存与工作内存</h4>
<p>Java内存模型的主要目的是定义程序中各种<code>变量（Variables）</code>的访问规则，即关注在虚拟机中把变量值<u><strong>存储到内存</strong></u>和<u><strong>从内存中取出</strong></u>变量值这样的底层细节。</p>
<blockquote>
<p>此处的变量<strong>包括</strong><u>实例字段</u>、<u>静态字段</u>和<u>构成数组对象的元素</u>，但是<strong>不包括</strong><u>局部变量</u>与<u>方法参数</u>，因为后者是<u><strong>线程私有</strong></u>的，不会被共享，不会存在竞争问题。</p>
</blockquote>
<p>Java内存模型规定了所有的变量都存储在<code>主内存（Main Memory）</code>中，每条线程还有自己的<code>工作内存（Working Memory）</code>，线程的工作内存中保存了被该线程<u><strong>使用的变量的主内存副本</strong></u>，线程对变量的所有操作（读取、赋值等）都<u><strong>必须在工作内存中进行，而不能直接读写主内存中的数据</strong></u>。不同的线程之间也无法直接访问对方工作内存中的变量，<u><strong>线程间变量值的传递均需要通过主内存来完成</strong></u>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaMemoryModel.PNG" alt="线程、主内存、工作内存三者的交互关系" /><figcaption aria-hidden="true">线程、主内存、工作内存三者的交互关系</figcaption>
</figure>
<h4 id="内存间交互操作">2.2 内存间交互操作</h4>
<p>关于主内存与工作内存之间具体的交互协议，即一个变量<u>如何从主内存拷贝到工作内存</u>、<u>如何从工作内存同步回主内存</u>这一类的实现细节，Java内存模型中定义了以下8种操作来完成，每一种操作都是原子的、不可再分的：</p>
<ul>
<li><code>lock（锁定）</code>：作用于<strong>主内存</strong>的变量，它<strong>把一个变量标识为一条线程独占的状态</strong>。</li>
<li><code>unlock（解锁）</code>：作用于<strong>主内存</strong>的变量，它<strong>把一个处于锁定状态的变量释放出来</strong>，释放后的变量才可以被其他线程锁定。</li>
<li><code>read（读取）</code>：作用于<strong>主内存</strong>的变量，它<strong>把一个变量的值从主内存传输到线程的工作内存中</strong>，以便随后的<code>load</code>动作使用。</li>
<li><code>load（载入）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把<code>read</code>操作从主内存中得到的变量值放入工作内存的变量副本中</strong>。</li>
<li><code>use（使用）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把工作内存中一个变量的值传递给执行引擎</strong>，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li><code>assign（赋值）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把一个从执行引擎接收的值赋给工作内存的变量</strong>， 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><code>store（存储）</code>：作用于<strong>工作内存</strong>的变量，它<strong>把工作内存中一个变量的值传送到主内存中</strong>，以便随后的<code>write</code>操作使用。</li>
<li><code>write（写入）</code>：作用于<strong>主内存</strong>的变量，它<strong>把<code>store</code>操作从工作内存中得到的变量的值放入主内存的变量中</strong>。</li>
</ul>
<p>Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p>
<ul>
<li>不允许<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它最近的<code>assign</code>操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何<code>assign</code>操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在<strong>主内存</strong>中<code>“诞生”</code>，不允许在工作内存中直接使用一个未被初始化（<code>load</code>或 <code>assign</code>）的变量，换句话说就是对一个变量实施<code>use</code>、<code>store</code>操作之前，必须先执行<code>assign</code>和<code>load</code>操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行<code>lock</code>操作，但<code>lock</code>操作可以被同一条线程重复执行多次，多次执行<code>lock</code>后，只有执行<strong>相同次数</strong>的<code>unlock</code>操作，变量才会被解锁。</li>
<li>如果对一个变量执行<code>lock</code>操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行<code>load</code>或<code>assign</code>操作以初始化变量的值。</li>
<li>如果一个变量事先没有被<code>lock</code>操作锁定，那就不允许对它执行<code>unlock</code>操作，也不允许去<code>unlock</code>一个被<strong>其他线程</strong>锁定的变量。</li>
<li>对一个变量执行<code>unlock</code>操作之前，必须先把此变量同步回主内存中（执行<code>store</code>、<code>write</code>操作）。</li>
</ul>
<p>Java内存模型的操作在最新的<code>JSR-133</code>文档中简化为<code>read</code>、<code>write</code>、<code>lock</code>和<code>unlock</code>四种，但这只是语言描述上的等价化简，Java内存模型的基础设计并未改变。</p>
<h4 id="对于volatile型变量的特殊规则">2.3 对于volatile型变量的特殊规则</h4>
<p>关键字<code>volatile</code>可以说是Java虚拟机提供的<strong>最轻量级</strong>的<code>同步机制</code>，Java内存模型为<code>volatile</code>专门定义了一些特殊的访问规则，当一个变量被定义成<code>volatile</code>之后，它将具备两项特性：</p>
<h5 id="保证此变量对所有线程的可见性">2.3.1 保证此变量对所有线程的<code>可见性</code></h5>
<p>这里的<code>“可见性”</code>是指<u>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的</u>。而普通变量的值在线程间传递时均需要通过主内存来完成。</p>
<blockquote>
<p><code>volatile</code>变量依然有工作内存的拷贝，但是由于它<strong><u>特殊的操作顺序性规定</u></strong>，所以看起来如同直接在主内存中读写访问一般。</p>
</blockquote>
<p><code>volatile</code>变量在各个线程的工作内存中是不存在一致性问题的，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile变量自增运算测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码并不会获得期望的结果，而且每次运行程序输出的结果都不一样。用<code>Javap</code>反编译这段代码后发现<code>increase()</code>方法在<code>Class</code>文件中是由4条字节码指令构成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void increase();</span><br><span class="line">Code:</span><br><span class="line">	Stack=2, Locals=0, Args_size=0</span><br><span class="line">	0: getstatic #13; //Field race:I</span><br><span class="line">	3: iconst_1</span><br><span class="line">	4: iadd</span><br><span class="line">	5: putstatic #13; //Field race:I</span><br><span class="line">	8: return</span><br><span class="line">LineNumberTable:</span><br><span class="line">	line 14: 0</span><br><span class="line">	line 15: 8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>并发失败的原因：当<code>getstatic</code>指令把<code>race</code>的值取到<strong>操作栈顶</strong>时，<code>volatile</code>关键字保证了<code>race</code>的值在此时是正确的，但是在执行<code>iconst_1</code>、<code>iadd</code>指令时，其他线程可能已经把<code>race</code>的值改变了，而操作栈顶的值就变成了<strong>过期的数据</strong>，所以<code>putstatic</code>指令执行后就可能把<strong>较小的race值</strong>同步回主内存之中。</p>
</blockquote>
<p>由于<code>volatile</code>变量只能保证可见性，在<strong><u>不符合</u></strong>以下两条规则的运算场景中，仍然要通过加锁来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<h5 id="禁止指令重排序优化">2.3.2 禁止指令重排序优化</h5>
<p>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而<u>不能保证变量赋值操作的顺序与程序代码中的执行顺序一致</u>，即<code>“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="comment">// 此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">// 模拟读取配置信息，当读取完成后</span></span><br><span class="line"><span class="comment">// 将initialized设置为true,通知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span> (!initialized) &#123;</span><br><span class="line">sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure>
<p>如果定义<code>initialized</code>变量时没有使用<code>volatile</code>修饰，就可能会由于<code>指令重排序的优化</code>，导致位于线程<code>A</code>中最后一条 代码<code>“initialized=true”</code>被提前执行（实际上<code>重排序优化</code>是<strong>机器级</strong>的优化操作），这样在线程<code>B</code>中使用配置信息的代码就可能出现错误。</p>
<p>下面是标准的<code>双锁检测（Double Check Lock，DCL）</code>单例的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有<code>volatile</code>修饰的变量，赋值后多执行了一个<code>“lock addl$0x0，(%esp)”</code>操作，这个操作的作用相当于一个<code>内存屏障</code>（<code>Memory Barrier</code>或<code>Memory Fence</code>，指重排序时不能把后面的指令重排序到内存屏障之前的位置）。</p>
<p><code>“addl$0x0，(%esp)”</code>（把ESP寄存器的值加0）是一个<strong>空操作</strong>。</p>
<blockquote>
<p>之所以用这个空操作而不是空操作专用指令<code>nop</code>，是因为<code>IA32</code>手册规定<code>lock</code>前缀不允许配合<code>nop</code>指令使用。</p>
</blockquote>
<p>它的作用是将本处理器的缓存写入了内存，该写入动作也会引起别的处理器或者别的内核<code>无效化（Invalidate）</code>其缓存。所以通过这样一个空操作，可让前面<code>volatile</code>变量的修改对其他处理器立即可见。</p>
<p>在volatile与锁中选择的<strong>唯一判断依据</strong>仅仅是<u><code>volatile</code>的语义能否满足使用场景的需求</u>。假定<code>T</code>表示一个线程，<code>V</code>和<code>W</code>分别表示两个<code>volatile</code>型变量，那么在进行<code>read</code>、<code>load</code>、<code>use</code>、<code>assign</code>、<code>store</code>和<code>write</code>操作时需要满足如下规则：</p>
<ul>
<li>在<strong>工作内存</strong>中，每次使用<code>V</code>前都必须先从<strong>主内存</strong><u>刷新最新的</u>值，用于保证能看见其他线程对变量V所做的修改。
<ul>
<li>只有当线程<code>T</code>对变量<code>V</code>执行的前一个动作是<code>load</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>use</code>动作；</li>
<li>只有当线程<code>T</code>对变量<code>V</code>执行的后一个动作是<code>use</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>load</code>动作。</li>
<li>线程<code>T</code>对变量<code>V</code>的<code>use</code>动作可以认为是和线程<code>T</code>对变量<code>V</code>的<code>load</code>、<code>read</code>动作相关联的，必须连续且一起出现。</li>
</ul></li>
<li>在<strong>工作内存</strong>中，每次修改<code>V</code>后都必须<strong>立刻</strong>同步回<strong>主内存</strong>中，用于保证其他线程可以看到自己对变量V所做的修改。
<ul>
<li>只有当线程<code>T</code>对变量<code>V</code>执行的前一个动作是<code>assign</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>store</code>动作；</li>
<li>只有当线程<code>T</code>对变量|V执行的后一个动作是<code>store</code>的时候，线程<code>T</code>才能对变量<code>V</code>执行<code>assign</code>动作。</li>
<li>线程<code>T</code>对变量<code>V</code>的<code>assign</code>动作可以认为是和线程<code>T</code>对变量<code>V</code>的<code>store</code>、<code>write</code>动作相关联的，必须连续且一起出现。</li>
</ul></li>
<li><code>volatile</code>修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。
<ul>
<li>假定动作<code>A</code>是线程<code>T</code>对变量<code>V</code>实施的<code>use</code>或<code>assign</code>动作，假定动作<code>F</code>是和动作<code>A</code>相关联的<code>load</code>或<code>store</code>动 作，假定动作<code>P</code>是和动作<code>F</code>相应的对变量<code>V</code>的<code>read</code>或<code>write</code>动作；</li>
<li>假定动作<code>B</code>是线程<code>T</code>对变量<code>W</code>实施的<code>use</code>或<code>assign</code>动作，假定动作<code>G</code>是和动作<code>B</code>相关联的<code>load</code>或<code>store</code>动作，假定动作<code>Q</code>是和动作<code>G</code>相应的对变量<code>W</code>的<code>read</code>或<code>write</code>动作。</li>
<li><strong>如果<code>A</code>先于<code>B</code>，那么<code>P</code>先于<code>Q</code></strong>。</li>
</ul></li>
</ul>
<h4 id="针对long和double型变量的特殊规则">2.4 针对long和double型变量的特殊规则</h4>
<p>Java内存模型要求上述八种操作都具有<code>原子性</code>， 但是对于<code>64</code>位的数据类型（<code>long</code>和<code>double</code>），在模型中特别定义了一条宽松的规定：</p>
<blockquote>
<p>允许虚拟机将<strong>没有</strong>被<code>volatile</code>修饰的<code>64</code>位数据的读写操作划分为两次<code>32</code>位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的<code>load</code>、<code>store</code>、<code>read</code>和<code>write</code>这四个操作的原子性，这就是所谓的<code>“long和double的非原子性协定”（Non-Atomic Treatment of double and long Variables）</code>。</p>
</blockquote>
<p>读取到<code>“半个变量”</code>的情况是非常罕见的，除非该数据有明确可知的线程竞争，否则在编写代码时一般不需要因为这个原因刻意把用到的<code>long</code>和<code>double</code>变量专门声明为<code>volatile</code>。</p>
<h4 id="原子性可见性与有序性">2.5 原子性、可见性与有序性</h4>
<p>Java内存模型是围绕着在并发过程中如何处理<code>原子性</code>、<code>可见性</code>和<code>有序性</code>这三个特征来建立的。</p>
<h5 id="原子性atomicity">2.5.1 <code>原子性（Atomicity）</code></h5>
<p>由Java内存模型来<strong>直接保证</strong>的原子性变量操作包括<code>read</code>、<code>load</code>、<code>assign</code>、<code>use</code>、<code>store</code>和<code>write</code>，基本数据类型的<strong>访问</strong>、<strong>读写</strong>都是具备原子性的。</p>
<p>Java内存模型提供了<code>lock</code>和<code>unlock</code>操作来满足更大范围的原子性保证，尽管虚拟机未把<code>lock</code>和<code>unlock</code>操作直接开放给用户使用，但是却提供了更高层次的字节码指令<code>monitorenter</code>和<code>monitorexit</code>来隐式地使用这两个操作。这两个字节码指令反映到Java 代码中就是同步块——<code>synchronized</code>关键字，因此在<code>synchronized</code>块之间的操作也具备原子性。</p>
<h5 id="可见性visibility">2.5.2 <code>可见性（Visibility）</code></h5>
<p>可见性就是指<u>当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改</u>。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。</p>
<blockquote>
<p>volatile的特殊规则保证了新值能<strong>立即同步到主内存</strong>，以及每次使用前<strong>立即从主内存刷新</strong>。</p>
</blockquote>
<p>除了<code>volatile</code>之外，<code>synchronized</code>和<code>final</code>两个关键字也能实现可见性。</p>
<ul>
<li><code>synchronized</code>同步块的可见性是由<code>“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”</code>这条规则获得的。</li>
<li><code>final</code>关键字的可见性是指：被<code>final</code>修饰的字段在构造器中一旦被初始化完成，并且构造器没有把<code>“this”</code>的引用传递出去，那么在其他线程中就能看见<code>final</code>字段的值。</li>
</ul>
<h5 id="有序性ordering">2.5.3 <code>有序性（Ordering）</code></h5>
<p>Java程序中天然的有序性即：</p>
<ul>
<li>如果在本线程内观察，所有的操作都是有序的，指<code>“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）</code>；</li>
<li>如果在一个线程中观察另一个线程， 所有的操作都是无序的，是指<code>“指令重排序”</code>现象和<code>“工作内存与主内存同步延迟”</code>现象。</li>
</ul>
<p>Java语言提供了<code>volatile</code>和<code>synchronized</code>两个关键字来保证线程之间操作的有序性。</p>
<h4 id="先行发生原则">2.6 先行发生原则</h4>
<p>Java语言的<code>“先行发生”（Happens-Before）原则</code>，是判断<u>数据是否存在竞争</u>，<u>线程是否安全</u>的手段。</p>
<blockquote>
<p><code>先行发生</code>是Java内存模型中定义的两项操作之间的<code>偏序关系</code>，比如说<code>操作A</code>先行发生于<code>操作B</code>，其实就是说在发生<code>操作B</code>之前，<code>操作A</code>产生的影响能被<code>操作B</code>观察到，<code>“影响”</code>包括<u>修改了内存中共享变量的值</u>、<u>发送了消息</u>、<u>调用了方法</u>等。</p>
</blockquote>
<p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系<u>无须任何同步器协助就已经存在</u>，可以在编码中直接使用。</p>
<ul>
<li><code>程序次序规则（Program Order Rule）</code>：在一个线程内，按照<strong><u>控制流顺序</u></strong>，书写在前面的操作先行发生于书写在后面的操作。</li>
<li><code>管程锁定规则（Monitor Lock Rule）</code>：一个<code>unlock</code>操作先行发生于后面对<strong>同一个锁</strong>的<code>lock</code>操作。</li>
<li><code>volatile变量规则（Volatile Variable Rule）</code>：对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量 的读操作。</li>
<li><code>线程启动规则（Thread Start Rule）</code>：<code>Thread</code>对象的<code>start()</code>方法先行发生于此线程的每一个动作。</li>
<li><code>线程终止规则（Thread Termination Rule）</code>：线程中的所有操作都先行发生于对此线程的终止检测，可以通过<code>Thread::join()</code>方法是否结束、<code>Thread::isAlive()</code>的返回值等手段检测线程是否已经终止执行。</li>
<li><code>线程中断规则（Thread Interruption Rule）</code>：对线程<code>interrupt()</code>方法的调用先行发生于<u>被中断线程的代码检测到中断事件</u>的发生，可以通过<code>Thread::interrupted()</code>方法检测到是否有中断发生。</li>
<li><code>对象终结规则（Finalizer Rule）</code>：一个对象的初始化完成（构造函数执行结束）先行发生于它的<code>finalize()</code>方法的开始。</li>
<li><code>传递性（Transitivity）</code>：如果<code>操作A</code>先行发生于<code>操作B</code>，<code>操作B</code>先行发生于<code>操作C</code>，那就可以得出<u><code>操作A</code>先行发生于<code>操作C</code></u>的结论。</li>
</ul>
<p><code>时间先后顺序</code>与<code>先行发生原则</code>之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须<u><strong>以先行发生原则为准</strong></u>。</p>
<h3 id="java与线程">3. Java与线程</h3>
<p>线程是比进程<strong>更轻量级</strong>的<u>调度执行单位</u>，线程可以把一个进程的<code>资源分配</code>和<code>执行调度</code>分开，各个线程既可以<strong>共享进程资源</strong>（内存地址、文件I/O等），又可以<strong>独立调度</strong>。目前线程是Java里面进行处理器资源调度的<strong>最基本单位</strong>。</p>
<h4 id="线程的实现">3.1 线程的实现</h4>
<p>实现线程主要有三种方式：使用<code>内核线程实现（1：1实现）</code>，使用<code>用户线程实现（1：N实现）</code>，使用用户线程加轻量级进程<code>混合实现（N：M实现）</code>。</p>
<h5 id="内核线程实现">3.1.1 内核线程实现</h5>
<p><code>内核线程（Kernel-Level Thread，KLT）</code>就是<strong><u>直接由操作系统<code>内核（Kernel）</code>支持的线程</u></strong>。</p>
<blockquote>
<p>这种线程由内核来完成<code>线程切换</code>，内核通过操纵<code>调度器（Scheduler）</code>对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为<code>多线程内核（Multi-Threads Kernel）</code>。</p>
</blockquote>
<p>程序一般<strong>不会直接使用内核线程</strong>，而是使用内核线程的一种高级接口——<code>轻量级进程（Light Weight Process，LWP）</code>，由于每个轻量级进程都由一个内核线程支持，因此<strong>只有先支持内核线程，才能有轻量级进程</strong>。这种轻量级进程与内核线程之间<code>1：1</code>的关系称为一对一的线程模型。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/KernelLevelThread.PNG" alt="内核线程实现" /><figcaption aria-hidden="true">内核线程实现</figcaption>
</figure>
<ul>
<li>优点：每个轻量级进程都成为一个<code>独立的调度单元</code>，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作。</li>
<li>局限性：
<ul>
<li>由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的<strong>代价相对较高</strong>，需要在<code>用户态（User Mode）</code>和<code>内核态（Kernel Mode）</code>中来回切换。</li>
<li>每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要<strong>消耗一定的内核资源</strong>，因此一个系统支持轻量级进程的<strong>数量是有限</strong>的。</li>
</ul></li>
</ul>
<h5 id="用户线程实现">3.1.2 用户线程实现</h5>
<p><strong>广义上</strong>，一个线程只要不是内核线程，都可以认为是<code>用户线程（User Thread，UT）</code>的一种。</p>
<p><strong>狭义上</strong>，用户线程指的是<strong>完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的</strong>。</p>
<blockquote>
<p>用户线程的建立、同步、销毁和调度完全在<code>用户态</code>中完成，<strong><u>不需要内核的帮助</u></strong>。</p>
</blockquote>
<p>这种进程与用户线程之间<code>1：N</code>的关系称为一对多的线程模型。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/UserThread.PNG" alt="用户线程实现" /><figcaption aria-hidden="true">用户线程实现</figcaption>
</figure>
<ul>
<li>用优势在于不需要系统内核支援，如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量。</li>
<li>劣势也在于没有系统内核的支援，所有的线程操作都需要由用户程序自己去处理。使用用户线程实现的程序通常都比较复杂，除了有明确的需求外，一般的应用程序都不倾向使用用户线程。但近年来许多以高并发为卖点的编程语言普遍支持了用户线程，譬如<code>Golang</code>、<code>Erlang</code>等。</li>
</ul>
<h5 id="混合实现">3.1.3 混合实现</h5>
<p>线程除了<code>依赖内核线程实现</code>和<code>完全由用户程序自己实现</code>之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为<code>N：M</code>实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/HybridThread.PNG" alt="混合实现" /><figcaption aria-hidden="true">混合实现</figcaption>
</figure>
<ul>
<li><strong><code>用户线程</code></strong><u>完全建立在用户空间中</u>，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。</li>
<li><strong><code>轻量级进程</code></strong>则作为<strong><code>用户线程</code></strong>和<strong><code>内核线程</code></strong>之间的桥梁， 这样可以<u>使用内核提供的线程调度功能及处理器映射</u>，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。</li>
</ul>
<h4 id="java线程调度">3.2 Java线程调度</h4>
<p>线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种：</p>
<ul>
<li><code>协同式（Cooperative Threads-Scheduling）线程调度</code>，线程的执行时间<u>由线程本身来控制</u>，线程把自己的工作执行完之后主动通知系统切换到另外一个线程上去。
<ul>
<li>好处是实现简单，切换操作对线程自己是可知的，一般没有<code>线程同步</code>的问题。</li>
<li>坏处是<u><strong>线程执行时间不可控制</strong></u>，甚至如果线程一直不告知系统进行线程切换，那么程序就会一直阻塞。</li>
</ul></li>
<li><code>抢占式（Preemptive Threads-Scheduling）线程调度</code>，每个线程将<u>由系统来分配执行时间</u>，线程的切换不由线程本身来决定。
<ul>
<li>好处是线程的<strong>执行时间是系统可控的</strong>，不会有一个线程导致整个进程甚至整个系统阻塞的问题。</li>
</ul></li>
</ul>
<p>Java使用的线程调度方式就是抢占式调度。虽然Java线程调度是系统自动完成的，但可以设置<code>线程优先级</code>给操作系统提供调度建议。Java设置了<code>10</code>个级别的线程优先级（<code>Thread.MIN_PRIORITY</code>至<code>Thread.MAX_PRIORITY</code>）。在两个线程同时处于<code>Ready</code>状态时，<strong>优先级越高的线程越容易被系统选择执行</strong>。</p>
<p><code>Windows</code>中就只有<code>七</code>种优先级，比Java线程优先级少，所以会出现几个线程优先级对应到同一个操作系统优先级的情况。</p>
<blockquote>
<p><code>Windows</code>平台的虚拟机中使用了除<code>THREAD_PRIORITY_IDLE</code>之外的其余<code>6</code>种线程优先级，因此在<code>Windows</code>下设置线程优先级为<code>1</code>和<code>2</code>、<code>3</code> 和<code>4</code>、<code>6</code>和<code>7</code>、<code>8</code>和<code>9</code>的效果是<strong>完全相同</strong>的。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/THREAD_PRIORITY.PNG" alt="Java线程优先级与Windows线程优先级之间的对应关系" /><figcaption aria-hidden="true">Java线程优先级与Windows线程优先级之间的对应关系</figcaption>
</figure>
<p>线程优先级并不是一项稳定的调节手段，优先级可能会被系统自行改变，所以不能在程序中通过优先级来完全准确判断一组状态都为<code>Ready</code>的线程将会先执行哪一个。</p>
<h4 id="状态转换">3.3 状态转换</h4>
<p>Java定义了<code>6</code>种线程状态，任意一个时间点中，一个线程<strong>只能有且只有其中的一种状态</strong>，可以通过特定的方法在不同状态之间转换：</p>
<ul>
<li><code>新建（New）</code>：创建后尚未启动的线程处于这种状态。</li>
<li><code>运行（Runnable）</code>：包括操作系统线程状态中的<code>Running</code>和<code>Ready</code>，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。</li>
<li><code>无限期等待（Waiting）</code>：处于这种状态的线程不会被分配处理器执行时间，它们要等待<strong>被其他线程显式唤醒</strong>。以下方法会让线程陷入无限期的等待状态：
<ul>
<li>没有设置<code>Timeout</code>参数的<code>Object::wait()</code>方法；</li>
<li>没有设置<code>Timeout</code>参数的<code>Thread::join()</code>方法；</li>
<li><code>LockSupport::park()</code>方法。</li>
</ul></li>
<li><code>限期等待（Timed Waiting）</code>：处于这种状态的线程也不会被分配处理器执行时间，不过<strong>无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒</strong>。以下方法会让线程进入限期等待状态：
<ul>
<li><code>Thread::sleep()</code>方法；</li>
<li>设置了<code>Timeout</code>参数的<code>Object::wait()</code>方法；</li>
<li>设置了<code>Timeout</code>参数的<code>Thread::join()</code>方法；</li>
<li><code>LockSupport::parkNanos()</code>方法；</li>
<li><code>LockSupport::parkUntil()</code>方法。</li>
</ul></li>
<li><code>阻塞（Blocked）</code>：线程被阻塞，<code>“阻塞状态”</code>与<code>“等待状态”</code>的区别是：
<ul>
<li><code>“阻塞状态”</code>在等待着获取到一个<code>排它锁</code>，这个事件将在另外一个线程放弃这个锁的时候发生；</li>
<li><code>“等待状态”</code>则是在等待一段时间，或者唤醒动作的发生。</li>
<li>在程序等待进入同步区域的时候，线程将进入这种状态。</li>
</ul></li>
<li><code>结束（Terminated）</code>：已终止线程的线程状态，线程已经结束执行</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ThreadState.PNG" alt="线程状态转换关系" /><figcaption aria-hidden="true">线程状态转换关系</figcaption>
</figure>
<h3 id="java与协程">4. Java与协程</h3>
<h4 id="内核线程的局限">4.1 内核线程的局限</h4>
<ul>
<li><code>1：1</code>的内核线程模型是如今Java虚拟机线程实现的<strong>主流选择</strong>，但是天然的缺陷是<strong>切换、调度成本高昂</strong>，系统能<strong>容纳的线程数量也很有限</strong>。现在在每个请求本身的执行时间变得很短、数量变得很多的前提下， 用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费。</li>
<li>传统的<code>Java Web</code>服务器的线程池的容量通常在几十个到两百之间，当以百万计的请求往线程池里面灌时，系统即使能处理得过来，但其中的切换损耗也是相当可观的。</li>
</ul>
<h4 id="协程的复苏">4.2 协程的复苏</h4>
<p>内核线程的调度成本主要来自于<strong>用户态与核心态之间的状态转换</strong>，而这两种状态转换的开销主要来自于<strong><code>响应中断</code>、<code>保护</code>和<code>恢复执行现场</code></strong>的成本。</p>
<blockquote>
<p>线程A -&gt; 系统中断 -&gt; 线程B</p>
</blockquote>
<p>当中断发生，从<code>线程A</code>切换到<code>线程B</code>去执行之前，操作系统首先要把<code>线程A</code>的上下文数据妥善保管好，然后把寄存器、内存分页等恢复到<code>线程B</code>挂起时候的状态，这样<code>线程B</code>被重新激活后才能仿佛从来没有被挂起过。这种<code>保护和恢复现场</code>的工 作，免不了涉及一系列数据在各种寄存器、缓存中的来回拷贝，当然不可能是一种轻量级的操作。</p>
<p>最初多数的用户线程是被设计成<code>协同式调度 （Cooperative Scheduling）</code>的，它也被叫做<code>“协程”（Coroutine）</code>。又由于这时候的协程会<u>完整地做调用栈的保护、恢复工作</u>，所以也被称为<code>“有栈协程”（Stackfull Coroutine）</code>。后来又出现比<code>有栈协程</code>恢复调用栈要轻量得多<code>“无栈协程”（Stackless Coroutine）</code>。</p>
<blockquote>
<p>一个协程的栈通常在<code>几百个字节</code>到<code>几KB</code>之间，所以Java虚拟机里线程池容量达到两百就已经不算小了，而很多支持协程的应用中，同时并存的协程数量可<code>以十万</code>计。</p>
</blockquote>
<h4 id="纤程fiber">4.3 纤程（Fiber）</h4>
<p>对于有栈协程，有一种特例实现名为<code>纤程（Fiber）</code>。在新并发模型下，一段使用纤程并发的代码会被分为两部分：</p>
<ul>
<li><code>执行过程（Continuation）</code>，主要用于维护执行现场，保护、恢复上下文状态；</li>
<li><code>调度器（Scheduler）</code>，负责编排所有要执行的代码的顺序。</li>
</ul>
<p>将调度程序与执行过程分离的好处是，用户可以选择自行控制其中的一个或者多个，而且Java中现有的调度器也可以被直接重用。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--4 虚拟机性能监控、故障处理工具</title>
    <url>/2021/05/20/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_4_Performance_monitoring_fault_handling.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code> <a id="more"></a></p>
</blockquote>
<h3 id="基础故障处理工具">1. 基础故障处理工具</h3>
<p>除了编译和运行Java程序外，打包、部署、签名、调试、监控、运维等各种场景都可能会用到<code>JDK</code>的<code>bin</code>目录下的小工具。根据软件可用性和授权的不同，可以把它们划分成三类：</p>
<ul>
<li><strong>商业授权工具</strong>：主要是<code>JMC（Java Mission Control）</code>及它要使用到的<code>JFR（Java Flight Recorder）</code>；</li>
<li><strong>正式支持工具</strong>：这一类工具属于被长期支持的工具，不同平台、不同版本的<code>JDK</code>之间，这类工具可能会略有差异；</li>
<li><strong>实验性工具</strong>：这一类工具在它们的使用说明中被声明为“<code>没有技术支持，并且是实验性质的</code>”（<code>Unsupported and Experimental</code>）产品。</li>
</ul>
<h4 id="jps虚拟机进程状况工具">1.1 <code>jps</code>：虚拟机进程状况工具</h4>
<p><code>jps（JVM Process Status Tool）</code>功能和<code>UNIX</code>的<code>ps</code>命令类似：</p>
<blockquote>
<p>可以列出<code>正在运行</code>的虚拟机进程，并显示虚拟机<u><strong>执行主类（Main Class，main()函数所在的类）</strong></u>名称以及这些进程的<code>本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）</code>。</p>
</blockquote>
<p><code>jps</code>命令格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/jps.PNG" alt="jps参数" /><figcaption aria-hidden="true">jps参数</figcaption>
</figure>
<h4 id="jstat虚拟机统计信息监视工具">1.2 <code>jstat</code>：虚拟机统计信息监视工具</h4>
<p><code>jstat（JVM Statistics Monitoring Tool）</code>是用于监视虚拟机各种运行状态信息的命令行工具。</p>
<blockquote>
<p>可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据</p>
</blockquote>
<h4 id="jinfojava配置信息工具">1.3 <code>jinfo</code>：Java配置信息工具</h4>
<p><code>jinfo（Configuration Info for Java）</code>的作用是实时查看和调整虚拟机各项参数。</p>
<blockquote>
<p>使用<code>jps</code>命令的<code>-v</code>参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用<code>jinfo</code>的<code>-flag</code>选项进行查询了</p>
</blockquote>
<h4 id="jmapjava内存映像工具">1.4 <code>jmap</code>：Java内存映像工具</h4>
<p><code>jmap（Memory Map for Java）</code>命令用于生成<strong>堆转储快照</strong>（一般称为<code>heapdump</code>或<code>dump</code>文件）。</p>
<blockquote>
<p>还可以查询<u><code>finalize</code>执行队列</u>、<u>Java堆</u>和<u>方法区的详细信息</u>，如空间使用率、当前用的是哪种收集器等。</p>
</blockquote>
<h4 id="jhat虚拟机堆转储快照分析工具">1.5 <code>jhat</code>：虚拟机堆转储快照分析工具</h4>
<p><code>jhat（JVM Heap Analysis Tool）</code>命令与<code>jmap</code>搭配使用，来分析<code>jmap</code>生成的堆转储快照。</p>
<h4 id="jstackjava堆栈跟踪工具">1.6 <code>jstack</code>：Java堆栈跟踪工具</h4>
<p><code>jstack（Stack Trace for Java）</code>命令用于生成虚拟机当前时刻的线程快照（一般称为<code>threaddump</code>或者<code>javacore</code>文件）。</p>
<blockquote>
<p>线程快照就是当前虚拟机内每一条线程正在执行的<strong>方法堆栈</strong>的集合，生成线程快照的目的通常是<u>定位线程出现长时间停顿的原因</u>，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。</p>
</blockquote>
<h4 id="基础工具总结">1.7 基础工具总结</h4>
<ul>
<li><strong>基础工具</strong>：用于支持基本的程序创建和运行</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/basicJavaTools.PNG" alt="基础工具" /><figcaption aria-hidden="true">基础工具</figcaption>
</figure>
<ul>
<li><strong>安全</strong>：用于程序签名、设置安全测试等</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/securityJavaTools.PNG" alt="安全工具" /><figcaption aria-hidden="true">安全工具</figcaption>
</figure>
<p>还有许多工具，就不一一列举了，需要的时候在查找学习就行。</p>
<h3 id="可视化故障处理工具">2. 可视化故障处理工具</h3>
<p>这类工具主要包括<code>JConsole</code>、 <code>JHSDB</code>、<code>VisualVM</code>和<code>JMC</code>四个。</p>
<h4 id="jhsdb基于服务性代理的调试工具">2.1 <code>JHSDB</code>：基于服务性代理的调试工具</h4>
<p><code>JHSDB</code>是一款基于<code>服务性代理（Serviceability Agent，SA）</code>实现的进程外调试工具。服务性代理是<code>HotSpot</code>虚拟机中一组用于映射<code>Java</code>虚拟机运行信息的、主要基于<code>Java</code>语言（含少量<code>JNI</code>代码）实现的<code>API</code>集合。</p>
<p>通过服务性代理的<code>API</code>，可以在一个独立的Java虚拟机的进程里分析其他<code>HotSpot</code>虚拟机的内部数据，或者从<code>HotSpot</code>虚拟机进程内存中<code>dump</code>出来的转储快照里还原出它的运行状态细节。</p>
<h4 id="jconsolejava监视与管理控制台">2.2 <code>JConsole</code>：Java监视与管理控制台</h4>
<p><code>JConsole（Java Monitoring and Management Console）</code>是一款基于<code>JMX（Java Manage-ment Extensions）</code>的可视化监视、管理工具。它的主要功能是通过<code>JMX</code>的<code>MBean（Managed Bean）</code>对系统进行信息收集和参数动态调整。</p>
<h4 id="visualvm多合-故障处理工具">2.3 <code>VisualVM</code>：多合-故障处理工具</h4>
<p><code>VisualVM（All-in-One Java Troubleshooting Tool）</code>是功能最强大的运行监视和故障处理程序之一，除了常规的运行监视、故障处理外，还将提供其他方面的能力，譬如<code>性能分析（Profiling）</code>。</p>
<p><code>VisualVM</code>还有一个很大的<strong>优点</strong>：<u><strong>不需要被监视的程序基于特殊<code>Agent</code>去运行</strong></u>，因此它的通用性很强，对应用程序实际性能的影响也较小，使得它可以直接应用在生产环境中。</p>
<h4 id="java-mission-control可持续在线的监控工具">2.4 <code>Java Mission Control</code>：可持续在线的监控工具</h4>
<p><code>JMC</code>最初是<code>BEA</code>公司的产品，选择了由<code>IBM</code>捐赠的<code>Eclipse RCP</code>作为基础框架，更常见的是作为Eclipse的插件来使用。</p>
<p><code>JMC</code>与虚拟机之间同样采取<code>JMX</code>协议进行通信，<code>JMC</code>一方面作为<code>JMX</code>控制台，显示来自虚拟机<code>MBean</code>提供的数据；另一方面作为<code>JFR</code>的分析工具，展示来自<code>JFR</code>的数据。</p>
<h3 id="hotspot虚拟机插件及工具">3. <code>HotSpot</code>虚拟机插件及工具</h3>
<p><code>HotSpot</code>的插件及工具存放在HotSpot源码<code>hotspot/src/share/tools</code>目录下，包括：</p>
<ul>
<li><code>Ideal Graph Visualizer</code>：用于可视化展示<code>C2</code>即时编译器是如何将字节码转化为理想图，然后转化为机器码的。</li>
<li><code>Client Compiler Visualizer</code>：用于查看<code>C1</code>即时编译器生成高级中间表示（<code>HIR</code>），转换成低级中间表示（<code>LIR</code>）和做物理寄存器分配的过程。</li>
<li><code>MakeDeps</code>：帮助处理<code>HotSpot</code>的编译依赖的工具。</li>
<li><code>Project Creator</code>：帮忙生成<code>Visual Studio</code>的<code>.project</code>文件的工具。</li>
<li><code>LogCompilation</code>：将<code>-XX：+LogCompilation</code>输出的日志整理成更容易阅读的格式的工具。</li>
<li><code>HSDIS</code>：即时编译器的反汇编插件。</li>
</ul>
<p><strong><code>HSDIS</code>：<code>JIT</code>生成代码反汇编</strong></p>
<p><code>HSDIS</code>是一个被官方推荐的<code>HotSpot</code>虚拟机即时编译代码的反汇编插件。<code>HSDIS</code>插件的作用是让<code>HotSpot</code>的<code>-XX：+PrintAssembly</code>指令调用它来把即时编译器动态生成的本地代码还原为<u>汇编代码</u>输出，同时还会自动产生大量非常有价值的注释，这样我们就可以通过输出的汇编代码来从最本质的角度分析问题。</p>
<p><code>JITWatch</code>是<code>HSDIS</code>经常搭配使用的可视化的编译日志分析工具，在<code>JITWatch</code>中加载日志后，就可以看到执行期间使用过的各种对象类型和对应调用过的方法。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--1 走近Java</title>
    <url>/2021/04/23/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_1_Approaching_Java.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。</code> <a id="more"></a></p>
</blockquote>
<h4 id="java技术体系">1. Java技术体系</h4>
<p><code>JCP(Java Community Process)</code>所定义的Java技术体系包括了以下几个组成部分：</p>
<ul>
<li>Java程序设计语言</li>
<li>各种硬件平台上的Java虚拟机实现</li>
<li>Class文件格式</li>
<li>Java类库API</li>
<li>来自商业机构和开源社区的第三方Java类库</li>
</ul>
<p><code>JDK(Java Development Kit)</code>是用于支持Java程序开发的最小环境，主要分为三部分：</p>
<ul>
<li>Java程序设计语言</li>
<li>Java虚拟机</li>
<li>Java类库</li>
</ul>
<p><code>JRE(Java Runtime Environment)</code>是支持Java程序运行的标准环境，主要包括：</p>
<ul>
<li>Java SE API子集</li>
<li>Java虚拟机</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Java_technology_system.PNG" alt="Java技术体系" /><figcaption aria-hidden="true">Java技术体系</figcaption>
</figure>
<p>按照技术关注的重点业务来划分，可以分为以下四条主要的产品线：</p>
<ul>
<li><strong>Java Card</strong>：支持Java小程序（Applets）运行在<strong><code>小内存设备（如智能卡）</code></strong>上的平台。</li>
<li><strong>Java ME（Micro Edition）</strong>：支持Java程序运行在<strong><code>移动终端（手机、PDA）</code></strong>上的平台，对Java API 有所精简，并加入了移动终端的针对性支持，这条产品线在JDK 6以前被称为<code>J2ME</code>。</li>
<li><strong>Java SE（Standard Edition）</strong>：支持面向<strong><code>桌面级应用（如Windows下的应用程序）</code></strong>的Java平台，提 供了完整的Java核心API，这条产品线在JDK 6以前被称为<code>J2SE</code>。</li>
<li><strong>Java EE（Enterprise Edition）</strong>：支持<strong><code>使用多层架构的企业应用（如ERP、MIS、CRM应用）</code></strong>的 Java平台，除了提供Java SE API外，还对其做了大量有针对性的扩充，并提供了相关的部署支持， 这条产品线在JDK 6以前被称为<code>J2EE</code>；在JDK 10以后被Oracle放弃，捐献给Eclipse基金会管理，此后被 称为<code>Jakarta EE</code>。(PS:扩展一般以<code>javax.*</code>作为包名，而以<code>java.*</code>为包名的包都是Java SE API的核心包。一部分曾经是扩展包的API后来进入了核心包中，因此核心包中也包含了不少<code>javax.*</code>开头的包名)</li>
</ul>
<h4 id="java虚拟机家族">2. Java虚拟机家族</h4>
<h5 id="虚拟机始祖sun-classicexact-vm">2.1 虚拟机始祖：Sun Classic/Exact VM</h5>
<p><code>Classic VM</code>只能使用<strong>纯解释器方式</strong>来执行Java代码，如果要使用<strong>即时编译器</strong>就必须进行外挂，但是假如外挂了即时编译器的话，即时编译器就会完全接管虚拟机的执行系统，解释器便不能再工作了。由于解释器和编译器不能配合工作，这就意味着<code>如果要使用编译执行，编译器就不得不对每一个方法、每一行代码都进行编译，而无论它们执行的频率是否具有编译的价值</code>。</p>
<p><code>Exact VM</code>因它使用<code>准确式内存管理</code>（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management）而得名。准确式内存管理是指<code>虚拟机可以知道内存中某个位置的数据具体是什么类型</code>。已经具备现代高性能虚拟机雏形，如热点探测、两级即时编译器、编译器与解释器混合工作模式等。</p>
<h5 id="武林盟主hotspot-vm">2.2 武林盟主：HotSpot VM</h5>
<p><code>HotSpot VM</code>是Sun/OracleJDK和OpenJDK中的默认Java虚拟机，也是目前<em>使用范围最广</em>的Java虚拟机。</p>
<blockquote>
<p>它是由一家名为<code>“Longview Technologies”</code>的小公司设计；甚至这个虚拟机最初<em>并非是为Java语言而研发的</em>，它来源于<code>Strongtalk虚拟机</code>，而这款虚拟机中相当多的技术又是来源于一款为<em>支持Self语言</em>实现“达到C语言50%以上的执行效率”的目标而设计的Self虚拟机， 最终甚至可以追溯到20世纪80年代中期开发的<code>Berkeley Smalltalk</code>上。</p>
</blockquote>
<p>它名称中的HotSpot指的就是它的<code>热点代码探测技术</code>。</p>
<blockquote>
<p>HotSpot虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器<strong>以方法为单位进行编译</strong>。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发<code>标准即时编译和栈上替换编译（On-Stack Replacement，OSR）行为</code>。</p>
</blockquote>
<h5 id="小家碧玉mobileembedded-vm">2.3 小家碧玉：Mobile/Embedded VM</h5>
<p>面对移动和嵌入式市场，在Java ME这条产品线上的虚拟机名为CDC-HI（C Virtual Machine， CVM）和CLDC-HI（Monty VM）。</p>
<blockquote>
<p>CDC/CLDC全称是<code>Connected（Limited）Device Configuration</code>，HI则是<code>HotSpot Implementation</code>的缩写，但它们并不是由HotSpot直接裁剪而来，只是借鉴过其中一些技术，并没有血缘关系，充其量能叫有所渊源。</p>
</blockquote>
<h5 id="天下第二bea-jrockitibm-j9-vm">2.4 天下第二：BEA JRockit/IBM J9 VM</h5>
<p>BEA System公司的<code>JRockit</code>与 IBM公司的<code>IBM J9</code>曾经与HotSpot并称<strong>“三大商业Java虚拟机”</strong>。</p>
<p>JRockit虚拟机曾经号称是“世界上速度最快的Java虚拟机”，BEA将其发展为一款<strong>专门为服务器硬件和服务端应用场景高度优化的虚拟机</strong>，由于专注于服务端应用，它可以不太关注于程序启动速度，因此JRockit内部<em>不包含解释器实现</em>，全部代码都靠<code>即时编译器编译后执行</code>。JRockit的<strong>垃圾收集器</strong>和<strong>Java Mission Control故障处理套件</strong>等部分的实现，在当时众多的Java虚拟机中也处于领先水平。</p>
<p>IBM J9虚拟机机最初是由IBM Ottawa实验室的一个<code>SmallTalk虚拟机</code>项目扩展而来。IBM J9虚拟机的市场定位与HotSpot比较接近，它是一款在<em>设计上全面考虑服务端、桌面应用，再到嵌入式的多用途虚拟机</em>。</p>
<blockquote>
<p>IBM J9虚拟机的<code>职责分离与模块化</code>做得比HotSpot更优秀，由J9 虚拟机中抽象封装出来的核心组件库（包括垃圾收集器、即时编译器、诊断监控子系统等）就单独构成了IBM OMR项目</p>
</blockquote>
<h5 id="软硬合璧bea-liquid-vmazul-vm">2.5 软硬合璧：BEA Liquid VM/Azul VM</h5>
<p>一类<strong>与特定硬件平台绑定、软硬件配合工作的专有虚拟机</strong>，往往能够实现更高的执行性能，或提供某些特殊的功能特性。</p>
<blockquote>
<p>Liquid VM也被称为JRockit VE(Virtual Edition，VE)，BEA公司开发的可以直接运行在自家 Hypervisor系统上的JRockit虚拟机的虚拟化版本。Liquid VM不需要操作系统的支持，或者说<strong>它自己本身实现了一个专用操作系统的必要功能</strong>。</p>
</blockquote>
<blockquote>
<p>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的<strong>专有硬件Vega系统</strong>上的Java虚拟机。</p>
</blockquote>
<blockquote>
<p>Zing虚拟机(Azul Systems公司研发)是一个从HotSpot某旧版代码分支基础上独立出来重新开发的高性能Java虚拟机。在要求低延迟、快速预热等场景中，Zing VM都要比HotSpot表现得更好。Zing的PGC、 C4收集器可以轻易支持TB级别的Java堆内存，而且保证暂停时间仍然可以维持在不超过10毫秒的范围里。</p>
</blockquote>
<h5 id="挑战者apache-harmonygoogle-android-dalvik-vm">2.6 挑战者：Apache Harmony/Google Android Dalvik VM</h5>
<p>Harmony虚拟机（准确地说是Harmony里的DRLVM）和Dalvik虚拟机<code>只能称作“虚拟 机”，而不能称作“Java虚拟机”</code>。</p>
<h5 id="没有成功但并非失败microsoft-jvm及其他">2.7 没有成功，但并非失败：Microsoft JVM及其他</h5>
<p>微软为了在Internet Explorer 3浏览器中支持Java Applets应用而开发了自己的Java虚拟机，</p>
<h5 id="百家争鸣">2.8 百家争鸣</h5>
<p>一些Java虚拟机是单纯为了用于生产，甚至在设计之初就仅仅是用于研究、验证某种技术和观点，又或者是作为一些规范的标准实现：</p>
<blockquote>
<ul>
<li>KVM。KVM中的K是“Kilobyte”的意思，它强调简单、轻量、高度可移植，但是运行速度比较慢。主要用于手机平台。</li>
<li>Java Card VM。JCVM必须精简到能放入智能卡、SIM卡、银行信用卡、借记卡内。</li>
<li>Squawk VM。运行于Sun SPOT（Sun Small Programmable Object Tech-nology，一种手持的Wi-Fi设备），也曾经运用于Java Card。</li>
<li>JavaInJava。试图以Java语言来实现Java语言本身的运行环境，既所谓的“元循环”（Meta-Circular，是指使用语言自身来实现其运行环境）虚拟机。</li>
<li>Maxine VM。也是一个几乎全部以Java代码实现（只有用于启动 Java虚拟机的加载器使用C语言编写）的元循环Java虚拟机。</li>
<li>Jikes RVM。是IBM开发的专门用来研究Java虚拟机实现技术的项目，也是一个元循环虚拟机。</li>
<li>IKVM.NET。基于微软.NET框架实现的Java虚拟机，并借助Mono获得一定的跨平台能力。</li>
</ul>
</blockquote>
<h4 id="实战自己编译jdk">3. 实战：自己编译JDK</h4>
<h5 id="openjdk和oraclejdk">3.1 OpenJDK和OracleJDK</h5>
<p>OpenJDK和 OracleJDK在程序上是非常接近的，两者共用了绝大部分相同的代码。在JDK 11以前，OracleJDK中还会存在一些OpenJDK没有的、闭源的功能，即OracleJDK 的“商业特性”。许多功能在JDK 11时全部开源到了OpenJDK中。到了这个阶段，已经可以认为OpenJDK与OracleJDK代码实质上已达到完全一致的程度。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OpenJDK_and_OracleJDK.PNG" alt="OpenJDK和 OracleJDK的关系" /><figcaption aria-hidden="true">OpenJDK和 OracleJDK的关系</figcaption>
</figure>
<p>OpenJDK内部不同版本之间的关系，按照开发习惯，新的功能或Bug修复通常是在最新分支上进行的，当功能或修复在最新分支上稳定之后会同步到其他老版本的维护分支上。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Relationship_between_OpenJDK_versions.PNG" alt="OpenJDK版本之间的关系" /><figcaption aria-hidden="true">OpenJDK版本之间的关系</figcaption>
</figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Java并发编程的艺术]--9 Java中的线程池</title>
    <url>/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-9-Java-thread-pool.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。 <a id="more"></a></p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。使用线程池可以进行统一分配、调优和监控。</li>
</ul>
<h3 id="线程池的实现原理">1. 线程池的实现原理</h3>
<p>当提交一个新任务到线程池时，线程池的处理流程如下。</p>
<ul>
<li>线程池判断<u><strong>核心线程池是否已满</strong></u>。
<ul>
<li>如果不是，则创建一个新的工作线程来执行任务。</li>
<li>如果是，则进入下个流程。</li>
</ul></li>
<li>线程池判断<strong><u>工作队列是否已经满</u></strong>。</li>
<li>如果工作队列没有满，则将新提交的任务存储在这个工作队列里。</li>
<li>如果工作队列满了，则进入下个流程。</li>
<li>线程池判断<strong><u>线程池是否已满</u></strong>。
<ul>
<li>如果没有，则创建一个新的工作线程来执行任务。</li>
<li>如果已经满了，则交给饱和策略来处理这个任务。</li>
</ul></li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter9/thradPoolFlow.PNG" alt="线程池的主要处理流程" /><figcaption aria-hidden="true">线程池的主要处理流程</figcaption>
</figure>
<p><code>ThreadPoolExecutor</code>执行<code>execute()</code>方法有四种情况：</p>
<ol type="1">
<li>如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（<strong><u>需要获取全局锁</u></strong>）。</li>
<li>如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li>
<li>如果无法将任务加入<code>BlockingQueue</code>（队列已满），则创建新的线程来处理任务（<strong><u>需要获取全局锁</u></strong>）。</li>
<li>如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并调用 <code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li>
</ol>
<p>在<code>ThreadPoolExecutor</code>完成预热之后（当前运行的线程数大于等于<code>corePoolSize</code>），几乎所有的<code>execute()</code>方法调用都是执行步骤<code>2</code>，而步骤<code>2</code>不需要获取全局锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">	<span class="comment">// 如果线程数小于基本线程数，则创建线程并执行当前任务</span></span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">		<span class="comment">// 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span></span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，</span></span><br><span class="line">		<span class="comment">// 则创建一个线程执行任务。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">			<span class="comment">// 抛出RejectedExecutionException异常</span></span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter9/thradPoolExecute.PNG" alt="ThreadPoolExecutor" /><figcaption aria-hidden="true">ThreadPoolExecutor</figcaption>
</figure>
<p>线程池创建线程时，会将线程封装成工作线程<code>Worker</code>，<code>Worker</code>在执行完任务后，还会循环获取工作队列里的任务来执行。线程池中的线程执行任务分两种情况。</p>
<ol type="1">
<li>在<code>execute()</code>方法中创建一个线程时，会让这个线程执行当前任务。</li>
<li>这个线程执行完<code>1</code>的任务后，会反复从<code>BlockingQueue</code>获取任务来执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Worker类的run()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Runnable task = firstTask;</span><br><span class="line">        firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            runTask(task);task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        workerDone(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池的使用">2 线程池的使用</h3>
<h4 id="线程池的创建">2.1 线程池的创建</h4>
<p>通过<code>ThreadPoolExecutor</code>来创建一个线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);</span><br></pre></td></tr></table></figure>
<p>输入几个参数介绍如下：</p>
<ul>
<li><code>corePoolSize</code>：线程池的基本大小。
<ul>
<li>需要执行的任务数小于线程池基本大小时，即使其他空闲的基本线程能够执行新任务，线程池会先创建一个线程来执行任务。</li>
<li>如果调用了线程池的<code>prestartAllCoreThreads()</code>方法，线程池会<strong><u>提前</u></strong>创建并启动所有基本线程。</li>
</ul></li>
<li><code>runnableTaskQueue</code>：任务队列。用于保存等待执行的任务的阻塞队列。可以选择的阻塞队列有：
<ul>
<li><code>ArrayBlockingQueue</code>；</li>
<li><code>LinkedBlockingQueue</code>。静态方法<code>Executors.newFixedThreadPool()</code>使用这个队列。</li>
<li><code>SynchronousQueue</code>。静态方法<code>Executors.newCachedThreadPool</code>使用这个队列。</li>
<li><code>PriorityBlockingQueue</code>。</li>
</ul></li>
<li><code>maximumPoolSize</code>：线程池允许创建的最大线程数。
<ul>
<li>如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</li>
</ul></li>
<li><code>ThreadFactory</code>：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li>
<li><code>RejectedExecutionHandler</code>：饱和策略。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。策略默认情况下是<code>AbortPolicy</code>，表示无法处理新任务时抛出异常。Java线程池框架提供了以下4种策略。
<ul>
<li><code>AbortPolicy</code>：直接抛出异常。</li>
<li><code>CallerRunsPolicy</code>：用调用者所在线程来运行任务。</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li><code>DiscardPolicy</code>：不处理，直接丢弃掉。</li>
<li>也可以实现<code>RejectedExecutionHandler</code>接口自定义策略</li>
</ul></li>
<li><code>keepAliveTime</code>：线程活动保持时间。线程池的工作线程空闲后，保持存活的时间。</li>
<li><code>TimeUnit</code>：线程活动保持时间的单位。可选的单位有<code>天（DAYS）</code>、<code>小时（HOURS）</code>、<code>分钟（MINUTES）</code>、<code>毫秒（MILLISECONDS）</code>、<code>微秒（MICROSECONDS）</code>和<code>纳秒（NANOSECONDS）</code>。</li>
</ul>
<h4 id="向线程池提交任务">2.2 向线程池提交任务</h4>
<p>可以使用两个方法向线程池提交任务：</p>
<ul>
<li><p><code>execute()</code>方法。用于提交<u><strong>不需要返回值</strong></u>的任务，所以无法判断任务是否被线程池执行成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><code>submit()</code>方法。用于提交<u><strong>需要返回值</strong></u>的任务，线程池会返回一个<code>future</code>类型的对象，通过该<code>future</code>对象可以判断任务是否执行成功，并可以通过<code>future</code>的<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Object s = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 处理中断异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="关闭线程池">2.3 关闭线程池</h4>
<p>通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。</p>
<blockquote>
<p>原理是<strong><u>遍历线程池中的工作线程</u></strong>，然后逐个调用线程的<code>interrupt</code>方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p>
</blockquote>
<ul>
<li><p><code>shutdownNow</code>首先将线程池的状态设置成<code>STOP</code>，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表；</p></li>
<li><p><code>shutdown</code>只是将线程池的状态设置成<code>SHUTDOWN</code>状态，然后中断所有<strong><u>没有正在执行任务</u></strong>的线程。</p></li>
<li><p>只要调用了关闭方法，<code>isShutdown</code>方法就会返回<code>true</code>。</p></li>
<li><p>当所有的任务都已关闭后，才表示线程池关闭成功，这时调用<code>isTerminaed</code>方法会返回<code>true</code>。</p></li>
</ul>
<h4 id="合理地配置线程池">2.4 合理地配置线程池</h4>
<ul>
<li>性质不同的任务可以用不同规模的线程池分开处理。</li>
<li>优先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理。</li>
<li>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</li>
<li><strong><u>建议使用有界队列</u></strong>。有界队列能增加系统的稳定性和预警能力。</li>
</ul>
<h4 id="线程池的监控">2.5 线程池的监控</h4>
<p>可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。</p>
<ul>
<li><code>taskCount</code>：线程池需要执行的任务数量。</li>
<li><code>completedTaskCount</code>：线程池在运行过程中已完成的任务数量，小于或等于<code>taskCount</code>。</li>
<li><code>largestPoolSize</code>：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。</li>
<li><code>getPoolSize</code>：线程池的线程数量。<u>如果线程池不销毁的话，线程池里的线程不会自动销毁</u>，所以这个大小<strong><u>只增不减</u></strong>。</li>
<li><code>getActiveCount</code>：获取活动的线程数。</li>
</ul>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--13 线程安全与锁优化</title>
    <url>/2021/06/07/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_13_Thread_safety_and_lock_optimization.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>首先需要保证并发的正确性，然后在此基础上来实现高效。 <a id="more"></a></p>
</blockquote>
<h3 id="线程安全">1. 线程安全</h3>
<blockquote>
<p><code>“线程安全”</code>是<code>“当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。”</code></p>
</blockquote>
<h4 id="java语言中的线程安全">1.1 Java语言中的线程安全</h4>
<p>将Java语言中各种操作共享的数据分为以下五类：<code>不可变</code>、<code>绝对线程安全</code>、<code>相对线程安全</code>、<code>线程兼容</code>和<code>线程对立</code>。</p>
<h5 id="不可变">1.1.1 不可变</h5>
<p><code>不可变（Immutable）</code>的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。</p>
<ul>
<li>如果多线程共享的数据是一个<code>基本数据类型</code>，那么只要在定义时使用<code>final</code>关键字修饰它就可以保证它是不可变的。</li>
<li>如果共享数据是一个<code>对象</code>，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。
<ul>
<li>Java类库<code>API</code>中<code>不可变</code>的类型，除了<code>String</code>外，常用的还有<code>枚举类型</code>及<code>java.lang.Number</code>的部分子类。</li>
</ul></li>
</ul>
<h5 id="绝对线程安全">1.1.2 绝对线程安全</h5>
<p><code>绝对的线程安全</code>能够完全满足给出的线程安全的定义，但一个类要达到<code>“不管运行时环境如何，调用者都不需要任何额外的同步措施”</code>可能需要付出非常高昂的， 甚至不切实际的代价。</p>
<p>在<code>Java API</code>中标注自己是线程安全的类，大多数都<strong>不是绝对的线程安全</strong>。</p>
<h5 id="相对线程安全">1.1.3 相对线程安全</h5>
<p><code>相对线程安全</code>就是通常意义上所讲的线程安全，它需要<u><strong>保证对这个对象单次的操作是线程安全的，在调用的时候不需要进行额外的保障措施</strong></u>，但是对于一些<strong>特定顺序的连续调用</strong>，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>
<h5 id="线程兼容">1.1.4 线程兼容</h5>
<p><code>线程兼容</code>是指<u>对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用</u>。平常说一个类不是线程安全的，通常就是指这种情况。</p>
<h5 id="线程对立">1.1.5 线程对立</h5>
<p><code>线程对立</code>是指<u>不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码</u>。</p>
<h4 id="线程安全的实现方法">1.2 线程安全的实现方法</h4>
<h5 id="互斥同步">1.2.1 互斥同步</h5>
<p><code>互斥同步（Mutual Exclusion &amp; Synchronization）</code>是一种最常见也是最主要的并发正确性保障手段。</p>
<ul>
<li><code>同步</code>是指<u>在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用</u>。</li>
<li><code>互斥</code>是实现同步的一种手段，<code>临界区（Critical Section）</code>、<code>互斥量（Mutex）</code>和<code>信号量（Semaphore）</code>都是常见的互斥实现方式。</li>
</ul>
<p>在<code>Java</code>里面，最基本的互斥同步手段就是<code>synchronized</code>关键字。</p>
<blockquote>
<p><code>synchronized</code>关键字经过<code>Javac</code>编译之后，会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令。这两个字节码指令都需要一个<code>reference</code>类型的参数来指明要锁定和解锁的对象。</p>
<ul>
<li>在执行<code>monitorenter</code>指令时，首先要去尝试获取对象的<code>锁</code>。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把<code>锁的计数器</code>的值增加一</li>
<li>在执行<code>monitorexit</code>指令时会将<code>锁计数器</code>的值减一。一旦计数器的值为零，锁随即就被释放了。</li>
<li>如果获取对象锁失败，那当前线程就应当被<code>阻塞等待</code>，直到请求锁定的对象被持有它的线程释放为止。</li>
</ul>
</blockquote>
<p>两个关于<code>synchronized</code>的直接推论：</p>
<ul>
<li>被<code>synchronized</code>修饰的同步块对<strong>同一条线程</strong>来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li>
<li>被<code>synchronized</code>修饰的同步块在<u>持有锁的线程执行完毕并释放锁之前</u>，会<strong>无条件地阻塞后面其他线程的进入</strong>。这意味着<u>无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁</u>；也<u>无法强制正在等待锁的线程中断等待或超时退出</u>。</li>
</ul>
<p>持有锁是一个<code>重量级（Heavy-Weight）</code>的操作，尤其是对于代码特别简单的同步块，状态转换消耗的时间甚至会比用户代码本身执行的时间还要长。<code>JDK 5</code>起提供了<code>java.util.concurrent.locks.Lock</code>接口，作为另一种全新的互斥同步手段。基于<code>Lock</code>接口，用户能够以<code>非块结构（Non-Block Structured）</code>来实现互斥同步，在<strong>类库层面去实现同步</strong>。</p>
<p><code>重入锁（ReentrantLock）</code>是<code>Lock</code>接口最常见的一种实现，它与<code>synchronized</code>一样是可重入的。主要增加了以下三项高级功能：</p>
<ul>
<li><code>等待可中断</code>：是指<u>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</u>。</li>
<li><code>公平锁</code>：是指<u>多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</u>；而<code>非公平锁</code>则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。
<ul>
<li><code>synchronized</code>中的锁是非公平的；</li>
<li><code>ReentrantLock</code>在<strong>默认情况</strong>下也是非公平的，但可以通过构造函数要求使用公平锁。但一旦使用了公平锁，将会导致<code>ReentrantLock</code>的性能急剧下降，会明显影响吞吐量。</li>
</ul></li>
<li><code>锁绑定多个条件</code>：是指<u><strong>一个<code>ReentrantLock</code>对象可以同时绑定多个<code>Condition</code>对象</strong></u>。</li>
</ul>
<h5 id="非阻塞同步">1.2.2 非阻塞同步</h5>
<p>互斥同步面临的主要问题是进行线程<strong>阻塞</strong>和<strong>唤醒</strong>所带来的性能开销，因此这种同步也被称为<code>阻塞同步（Blocking Synchronization）</code>，互斥同步属于一种<strong>悲观的并发策略</strong>。</p>
<p>另外有一种基于<code>冲突检测</code>的<strong>乐观并发策略</strong>，通俗地说就是<u><strong>不管风险，先进行操作</strong></u>：</p>
<ul>
<li>如果<strong>没有</strong>其他线程争用共享数据，那操作就直接成功；</li>
<li>如果<strong>有</strong>其他线程争用共享数据，产生了冲突，再进行其他的补偿措施，比如不断地重试，直到出现没有竞争的共享数据为止。</li>
</ul>
<p>这种乐观并发策略的实现<strong><u>不再需要把线程阻塞挂起</u></strong>，因此这种同步操作被称为<code>非阻塞同步（Non-Blocking Synchronization）</code>，使用这种措施的代码也常被称为<code>无锁（Lock-Free）编程</code>。</p>
<p>乐观并发策略需要<code>“硬件指令集的发展”</code>，因为要求<code>操作</code>和<code>冲突检测</code>这两个步骤具备<strong>原子性</strong>。硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，这类指令常用的有：</p>
<ul>
<li><code>测试并设置（Test-and-Set）</code>；</li>
<li><code>获取并增加（Fetch-and-Increment）</code>；</li>
<li><code>交换（Swap）</code>；</li>
<li><code>比较并交换（Compare-and-Swap）</code>；</li>
<li><code>加载链接/条件储存（Load-Linked/Store-Conditional）</code>。</li>
</ul>
<h5 id="无同步方案">1.2.3 无同步方案</h5>
<p>同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的：</p>
<ul>
<li><code>可重入代码（Reentrant Code）</code>：这种代码又称<code>纯代码（Pure Code）</code>，是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。
<ul>
<li><code>可重入代码</code>有一些共同的特征，例如<u>不依赖全局变量、存储在堆上的数据和公用的系统资源</u>， 用到的状态量都由参数中传入，不调用非可重入的方法等。</li>
<li>如果一个方法的返回结果是<strong>可以预测的</strong>，那它就满足可重入性的要求。</li>
</ul></li>
<li><code>线程本地存储（Thread Local Storage）</code>：如果一段代码中所需要的数据必须与其他代码共享，如果能保证这些共享数据的代码在同一个线程中执行，就可以把共享数据的可见范围限制在同一个线程之内，无须同步也能保证线程之间不出现数据争用的问题。</li>
</ul>
<h3 id="锁优化">2. 锁优化</h3>
<h4 id="自旋锁与自适应自旋adaptive-spinning">2.1 自旋锁与自适应自旋（Adaptive Spinning）</h4>
<p>如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，就可以让后面请求锁的那个线程<code>“稍等一会”</code>，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，只须让线程执行一个<code>忙循环（自旋）</code>，这项技术就是所谓的<code>自旋锁</code>。</p>
<blockquote>
<ul>
<li>自旋等待本身虽然避免了<code>线程切换</code>的开销，但它需要<strong>占用处理器时间</strong>，所以如果锁被占用的时间很短，自旋等待的效果就会非常好；</li>
<li>反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。</li>
</ul>
</blockquote>
<p>自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。引入了<code>自适应的自旋</code>，自旋的时间不再是固定，而是由<u><strong>前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</strong></u>的。</p>
<h4 id="锁消除lock-elimination">2.2 锁消除（Lock Elimination）</h4>
<p>锁消除是指虚<u>拟机即时编译器在运行时，对一些代码要求同步，但是对<strong>被检测到不可能存在共享数据竞争的锁</strong>进行消除</u>。</p>
<blockquote>
<p>锁消除的主要判定依据来源于<code>逃逸分析</code>的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以认为它们是<code>线程私有</code>的。</p>
</blockquote>
<h4 id="锁粗化lock-coarsening">2.3 锁粗化（Lock Coarsening）</h4>
<p>如果一系列的<code>连续操作</code>都对<strong>同一个对象</strong>反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围<strong><code>扩展（粗化）</code>到整个操作序列的外部</strong>。</p>
<h4 id="轻量级锁lightweight-locking">2.4 轻量级锁（Lightweight Locking）</h4>
<p><code>HotSpot</code>虚拟机的<code>对象头（Object Header）</code>分为两部分：</p>
<ul>
<li>第一部分用于<strong><u>存储对象自身的运行时数据</u></strong>，如<code>哈希码（HashCode）</code>、<code>GC分代年龄（Generational GC Age）</code> 等，官方称为<code>“Mark Word”</code>。这部分是实现轻量级锁和偏向锁的关键。</li>
<li>另一部分用于<u><strong>存储指向方法区对象类型数据的指针</strong></u>，如果是数组对象，还会有一个额外的部分用于存储数组长度。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/HotSpotMarkWord.PNG" alt="HotSpot虚拟机对象头Mark Word" /><figcaption aria-hidden="true">HotSpot虚拟机对象头Mark Word</figcaption>
</figure>
<p>轻量级锁的工作过程：</p>
<ul>
<li>在代码即将进入同步块的时候，如果此同步对象<strong>没有被锁定</strong>（锁标志位为<code>“01”</code>状态），虚拟机首先将在当前线程的栈帧中建立一个名为<code>锁记录（Lock Record）</code>的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝（即<code>Displaced Mark Word</code>）</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/BeforeCAS.PNG" alt="轻量级锁CAS操作之前堆栈与对象的状态" /><figcaption aria-hidden="true">轻量级锁CAS操作之前堆栈与对象的状态</figcaption>
</figure>
<ul>
<li>然后，虚拟机将使用<code>CAS</code>操作尝试把对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。
<ul>
<li>如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象<code>Mark Word</code>的<code>锁标志位</code>将转变为<code>“00”</code>，表示此对象处于轻量级锁定状态。</li>
<li>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，
<ul>
<li>如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行；</li>
<li>否则，就说明这个锁对象已经被其他线程抢占了。</li>
</ul></li>
<li>如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要<strong>膨胀为重量级锁</strong>，锁标志的状态值变为<code>“10”</code>，此时<code>Mark Word</code>中存储的就是指向<code>重量级锁（互斥量）</code>的指针，后面等待锁的线程也必须进入阻塞状态。</li>
</ul></li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/AfterCAS.PNG" alt="轻量级锁CAS操作之后堆栈与对象的状态" /><figcaption aria-hidden="true">轻量级锁CAS操作之后堆栈与对象的状态</figcaption>
</figure>
<p>轻量级锁的解锁过程也同样是通过<code>CAS</code>操作来进行的：</p>
<ul>
<li>如果对象的<code>Mark Word</code>仍然指向线程的锁记录，那就用<code>CAS</code>操作把对象当前的<code>Mark Word</code>和线程中复制的<code>Displaced Mark Word</code>替换回来。</li>
<li>假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</li>
</ul>
<h4 id="偏向锁biased-locking">2.5 偏向锁（Biased Locking）</h4>
<p>偏向锁的目的是<u><strong>消除数据在无竞争情况下的同步原语</strong></u>， 进一步提高程序的运行性能。</p>
<blockquote>
<p>偏向锁是在无竞争的情况下把整个同步都消除掉，连<code>CAS</code>操作都不去做了。</p>
</blockquote>
<ul>
<li>假设当前虚拟机启用了偏向锁，那么当锁对象<strong>第一次</strong>被线程获取的时候，虚拟机将会把对象头中的<code>标志位</code>设置为<code>“01”</code>、把<code>偏向模式</code>设置为<code>“1”</code>，表示进入<strong>偏向模式</strong>。同时使用<code>CAS</code>操作把获取到这个锁的线程的<code>ID</code>记录在对象的<code>Mark Word</code>之中。如果<code>CAS</code>操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。</li>
<li>一旦出现另外一个线程去尝试获取这个锁的情况，<strong>偏向模式</strong>就<u>马上宣告结束</u>。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为<code>“0”</code>），撤销后标志位恢复到未锁定（标志位为<code>“01”</code>）或轻量级锁定（标志位为<code>“00”</code>）的状态，后续的同步操作就按照轻量级锁那样去执行。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/BiasedLocking.PNG" alt="偏向锁、轻量级锁的状态转化及对象Mark Word的关系" /><figcaption aria-hidden="true">偏向锁、轻量级锁的状态转化及对象Mark Word的关系</figcaption>
</figure>
<ul>
<li>当一个对象已经计算过<code>一致性哈希码</code>后，它就再也无法进入偏向锁状态了；</li>
<li>当一个对象当前正处于<code>偏向锁</code>状态，又收到需要计算其<code>一致性哈希码</code>请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的<code>ObjectMonitor</code>类里有字段可以记录非加锁状态（标志位为<code>“01”</code>）下的<code>Mark Word</code>，其中自然可以存储原来的哈希码。</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Java并发编程的艺术]--8 Java中的并发工具类</title>
    <url>/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-8-Java-concurrent-tools.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>CountDownLatch</code>、<code>CyclicBarrier</code>和<code>Semaphore</code>工具类提供了一种<strong><u>并发流程控制</u></strong>的手段，<code>Exchanger</code>工具类则提供了在<strong><u>线程间交换数据</u></strong>的一种手段。 <a id="more"></a></p>
</blockquote>
<h3 id="等待多线程完成的countdownlatch">1. 等待多线程完成的<code>CountDownLatch</code></h3>
<p>要实现主线程等待所有线程完成操作，最简单的做法是使用<code>join()</code>方法。<code>join</code>用于让当前执行线程等待<code>join</code>线程执行结束。原理是不停检查<code>join</code>线程是否存活，如果<code>join</code>线程存活则让当前线程永远等待。<code>join</code>线程中止后，线程的<code>this.notifyAll()</code>方法会被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">	wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CountDownLatch</code>允许一个或多个线程等待其他线程完成操作，比<code>join</code>的功能更多。</p>
<ul>
<li><code>CountDownLatch</code>的构造函数接收一个<code>int</code>类型的参数作为计数器，表示需要等待<code>N</code>个点完成。</li>
<li>调用<code>CountDownLatch</code>的<code>countDown</code>方法时，<code>N</code>就会减<code>1</code>；</li>
<li><code>CountDownLatch</code>的<code>await</code>方法会阻塞当前线程，直到<code>N</code>变成零。</li>
</ul>
<blockquote>
<p>由于<code>countDown</code>方法可以用在<strong><u>任何地方</u></strong>，所以这里说的<code>N</code>个点，可以是<code>N</code>个线程，也可以是<code>1</code>个线程里的<code>N</code>个执行步骤。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        c.await();</span><br><span class="line">        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步屏障cyclicbarrier">2. 同步屏障<code>CyclicBarrier</code></h3>
<p><code>CyclicBarrier</code>的字面意思是<strong><u>可循环使用（Cyclic）</u></strong>的<u><strong>屏障（Barrier）</strong></u>。让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<h4 id="cyclicbarrier简介">2.1 <code>CyclicBarrier</code>简介</h4>
<p><code>CyclicBarrier</code>默认的构造方法是<code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉<code>CyclicBarrier</code>我已经到达了屏障，然后当前线程被阻塞。</p>
<p><code>CyclicBarrier</code>还提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行<code>barrierAction</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment"> * given number of parties (threads) are waiting upon it, and which</span></span><br><span class="line"><span class="comment"> * will execute the given barrier action when the barrier is tripped,</span></span><br><span class="line"><span class="comment"> * performed by the last thread entering the barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties the number of threads that must invoke &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment"> *        before the barrier is tripped</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> barrierAction the command to execute when the barrier is</span></span><br><span class="line"><span class="comment"> *        tripped, or &#123;<span class="doctag">@code</span> null&#125; if there is no action</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties&#125; is less than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment"> * given number of parties (threads) are waiting upon it, and</span></span><br><span class="line"><span class="comment"> * does not perform a predefined action when the barrier is tripped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties the number of threads that must invoke &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment"> *        before the barrier is tripped</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> parties&#125; is less than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>CyclicBarrier</code>可以用于<u><strong>多线程计算数据，最后合并计算结果的场景</strong></u>。</p>
</blockquote>
<h4 id="cyclicbarrier和countdownlatch的区别">2.2 <code>CyclicBarrier</code>和<code>CountDownLatch</code>的区别</h4>
<p><code>CountDownLatch</code>的计数器只能使用一次，<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置。<code>CyclicBarrier</code>还提供其他有用的方法：</p>
<ul>
<li><code>getNumberWaiting</code>方法可以获得<code>CyclicBarrier</code>阻塞的线程数量。</li>
<li><code>isBroken()</code>方法用来了解阻塞的线程是否被中断。</li>
</ul>
<h3 id="控制并发线程数的semaphore">3. 控制并发线程数的<code>Semaphore</code></h3>
<p><code>Semaphore（信号量）</code>是用来控制<strong><u>同时访问特定资源的线程数量</u></strong>，它通过协调各个线程，以保证合理的使用公共资源。</p>
<h4 id="应用场景">3.1 应用场景</h4>
<p><code>Semaphore</code>可以用于做<strong><u>流量控制</u></strong>，特别是公用资源有限的应用场景，比如数据库连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println(<span class="string">"save data"</span>);</span><br><span class="line">                        s.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他方法">3.2 其他方法</h4>
<ul>
<li><code>intavailablePermits()</code>：返回此信号量中当前可用的许可证数。</li>
<li><code>intgetQueueLength()</code>：返回正在等待获取许可证的线程数。</li>
<li><code>booleanhasQueuedThreads()</code>：是否有线程正在等待获取许可证。</li>
<li><code>void reducePermits(int reduction)</code>：减少<code>reduction</code>个许可证，是个<code>protected</code>方法。</li>
<li><code>Collection getQueuedThreads()</code>：返回所有等待获取许可证的线程集合，是个<code>protected</code>方法。</li>
</ul>
<h3 id="线程间交换数据的exchanger">4. 线程间交换数据的<code>Exchanger</code></h3>
<p><code>Exchanger（交换者）</code>是一个用于<strong><u>线程间协作</u></strong>的工具类。<code>Exchanger</code>用于进行<strong><u>线程间的数据交换</u></strong>。</p>
<ul>
<li>它提供一个<code>同步点</code>，在这个同步点，两个线程通过<code>exchange</code>方法交换彼此的数据，如果第一个线程先执行<code>exchange()</code>方法，它会一直等待第二个线程也执行<code>exchange</code>方法；</li>
<li>当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方；</li>
<li>可以使用<code>exchange(V x，longtimeout，TimeUnit unit)</code>设置最大等待时长。</li>
</ul>
<h4 id="应用场景-1">4.1 应用场景</h4>
<ul>
<li><code>Exchanger</code>可以用于<strong><u>遗传算法</u></strong>，遗传算法里需要选出两个人作为配对对象，这时候会交换两人的数据。</li>
<li><code>Exchanger</code>也可以用于<strong><u>校对工作</u></strong>。如对两份录入数据进行校对，看看是否录入一致。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String A = <span class="string">"银行流水A"</span>; <span class="comment">// A录入银行流水数据</span></span><br><span class="line">                    String B = exgr.exchange(A);</span><br><span class="line">                    System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span>+ A + <span class="string">"，B录入是："</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String B = <span class="string">"银行流水B"</span>; <span class="comment">// B录入银行流水数据</span></span><br><span class="line">                    String A = exgr.exchange(<span class="string">"B"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span>+ A + <span class="string">"，B录入是："</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--2 Java内存区域与内存溢出异常</title>
    <url>/2021/05/12/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_2_Java_memory_area.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code> <a id="more"></a></p>
</blockquote>
<p>在<code>Java</code>虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的<code>delete/free</code>代码，不容易出现内存泄漏和内存溢出问题。</p>
<p>但也因此，如果不了解虚拟机是怎样使用内存的，一旦出现内存泄漏和溢出方面的问题，那排查错误、修正问题将会成为一项异常艰难的工作。</p>
<h3 id="运行时数据区域">1 运行时数据区域</h3>
<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为<strong>若干个不同的数据区域</strong>。这些区域有各自的用途，以及创建和销毁的时间，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/runtimeDataArea.PNG" alt="Java虚拟机运行时数据区" /><figcaption aria-hidden="true">Java虚拟机运行时数据区</figcaption>
</figure>
<h4 id="程序计数器">1.1 程序计数器</h4>
<p><code>程序计数器（Program Counter Register）</code>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。字节码解释器工作时就是通过改变这个计数器的值来<strong>选取下一条需要执行的字节码指令</strong>。</p>
<blockquote>
<p>程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
</blockquote>
<p>Java虚拟机的多线程是通过<strong>线程轮流切换、分配处理器执行时间</strong>的方式来实现的，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</p>
<blockquote>
<p>这类内存区域为“线程<code>私有</code>”的内存</p>
</blockquote>
<p>如果线程正在执行的是一个<code>Java方法</code>，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<code>本地（Native）方法</code>，这个计数器值则应为空（Undefined）。</p>
<blockquote>
<p>此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何<code>OutOfMemoryError情况</code>的区域。</p>
</blockquote>
<h4 id="java虚拟机栈">1.2 Java虚拟机栈</h4>
<p><code>Java虚拟机栈（Java Virtual Machine Stack）</code>描述的是<strong>Java<code>方法</code>执行的线程内存模型</strong>：每个<code>方法</code>被执行的时候，Java虚拟机都会同步创建一个<code>栈帧（Stack Frame）</code>用于存储<em>局部变量表、操作数栈、动态连接、方法出口</em>等信息。</p>
<blockquote>
<p><code>Java虚拟机栈（Java Virtual Machine Stack）</code>也是线程<code>私有</code>的，它的生命周期与线程相同。</p>
</blockquote>
<p>有人把Java内存区域笼统地划分为<code>堆内存（Heap）</code>和<code>栈内存（Stack）</code>。<strong>“栈”通常就是指虚拟机栈</strong>，或者更多的情况下只是指虚拟机栈中<em>局部变量表部分</em>。</p>
<blockquote>
<p>局部变量表中的存储空间以<code>局部变量槽（Slot）</code>来表示，其中64位长度的<code>long</code>和<code>double</code>类型的数据会<em>占用两个变量槽</em>，其余的数据类型只占用一个。</p>
<p><strong>局部变量表所需的内存空间在编译期间完成分配</strong>，一个方法需要在栈帧中分配多大的局部变量空间是<strong>完全确定</strong>的，在方法运行期间不会改变局部变量表的大小(<em>“大小”是指变量槽的数量</em>)</p>
</blockquote>
<p>这个内存区域规定了两类异常状况：</p>
<blockquote>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError异常</code></li>
<li>如果Java虚拟机栈容量可以<em>动态扩展</em>，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError异常</code></li>
</ul>
</blockquote>
<h4 id="本地方法栈">1.3 本地方法栈</h4>
<p><code>本地方法栈（Native Method Stacks）</code>与虚拟机栈所发挥的作用是非常相似的，其<strong>区别</strong>只是：</p>
<blockquote>
<p>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务；</p>
<p>本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
</blockquote>
<p>有的Java虚拟机（譬如<code>Hot-Spot虚拟机</code>）直接把<strong>本地方法栈和虚拟机栈合二为一</strong>。</p>
<blockquote>
<p>本地方法栈规定了<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p>
</blockquote>
<h4 id="java堆">1.4 Java堆</h4>
<p><code>Java堆（Java Heap）</code>唯一目的就是<strong>存放对象实例</strong>，Java世界里<em>“几乎”</em>所有的对象实例都在这里分配内存。Java堆是被所有线程<code>共享</code>的一块内存区域，在虚拟机启动时创建，也是虚拟机所管理的内存中<em>最大</em>的一块。</p>
<blockquote>
<p>在《Java虚拟机规范》中对Java堆的描述是：<code>“所有的对象实例以及数组都应当在堆上分配”</code></p>
</blockquote>
<p>Java堆是<strong>垃圾收集器管理的内存区域</strong>，因此它也被称作<code>“GC堆”（Garbage Collected Heap）</code>。如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个<strong>线程私有</strong>的<code>分配缓冲区 （Thread Local Allocation Buffer，TLAB）</code>。</p>
<p>Java堆可以处于<code>物理上不连续</code>的内存空间中，但在逻辑上它应该被视为连续的。</p>
<blockquote>
<p>如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出<code>OutOfMemoryError异常</code>。</p>
</blockquote>
<h4 id="方法区">1.5 方法区</h4>
<p><code>方法区（Method Area）</code>用于存储<strong>已被虚拟机加载</strong>的<em>类型信息、常量、静态变量、即时编译器编译后的代码缓存</em>等数据。与Java堆一样，是各个线程<code>共享</code>的内存区域。</p>
<blockquote>
<p>《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作<code>“非堆”（Non-Heap）</code></p>
</blockquote>
<p>很多人都更愿意把方法区称为<code>“永久代”（Permanent Generation）</code>，或将两者混为一谈。<strong>本质上这两者并不是等价的</strong>，因为仅仅是<strong>使用永久代来实现方法区</strong>而已。</p>
<blockquote>
<ul>
<li>永久代来实现方法区导致了Java应用更容易遇到<code>内存溢出</code>的问题（永久代有<code>-XX：MaxPermSize</code>的上限，即使不设置也有默认大小)；</li>
<li>在JDK 6的时候HotSpot开发团队就有<strong>放弃永久代</strong>，逐步改为<strong>采用本地内存（Native Memory）</strong>来实现方法区的计划了；</li>
<li>JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出；</li>
<li>而到了JDK 8，终于<strong>完全废弃了永久代的概念</strong>，改用与JRockit、J9一样在本地内存中实现的<code>元空间（Meta-space）</code>来代替。</li>
</ul>
</blockquote>
<p>除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择<strong>不实现垃圾收集</strong>。</p>
<blockquote>
<p>这区域的内存回收目标主要是针<strong>对常量池的回收</strong>和<strong>对类型的卸载</strong></p>
</blockquote>
<blockquote>
<p>如果方法区无法满足新的内存分配需求时，将抛出 <code>OutOfMemoryError异常</code>。</p>
</blockquote>
<h4 id="运行时常量池">1.6 运行时常量池</h4>
<p><code>运行时常量池（Runtime Constant Pool）</code>是<strong>方法区的一部分</strong>。<code>Class文件</code>中有一项信息是<code>常量池表（Constant Pool Table）</code>，用于存放编译期生成的各种<strong>字面量</strong>与<strong>符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<blockquote>
<p>Class文件中还包括类的<em>版本、字段、方法、接口等描述信息</em></p>
</blockquote>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，运行期间也可以将新的常量放入池中。</p>
<blockquote>
<p>当常量池无法再申请到内存时会抛出<code>OutOfMemoryError异常</code>。</p>
</blockquote>
<h4 id="直接内存">1.7 直接内存</h4>
<p><code>直接内存（Direct Memory）</code>并不是虚拟机运行时数据区的一部分。</p>
<blockquote>
<p>在<code>JDK 1.4</code>中新加入了<code>NIO（New Input/Output）类</code>，引入了一种基于<code>通道（Channel）</code>与<code>缓冲区 （Buffer）</code>的I/O方式，它可以使用<strong><code>Native函数库</code>直接分配堆外内存</strong>，然后通过一个存储在Java堆里面的<code>DirectByteBuffer</code>对象作为<strong>这块内存的引用</strong>进行操作。</p>
<p>避免了在<code>Java堆</code>和<code>Native堆</code>中来回复制数据。</p>
</blockquote>
<p>本机直接内存的分配不会受到Java堆大小的限制，但是肯定还是会受到本机总内存大小以及处理器寻址空间的限制：</p>
<blockquote>
<p>动态扩展时可能会出现 <code>OutOfMemoryError异常</code>。</p>
</blockquote>
<h3 id="hotspot虚拟机对象探秘">2. <code>HotSpot</code>虚拟机对象探秘</h3>
<h4 id="对象的创建">2.1 对象的创建</h4>
<p>在虚拟机中<code>(普通)对象</code>的创建过程如下：</p>
<blockquote>
<ol type="1">
<li>当Java虚拟机遇到一条<code>字节码new指令</code>时，首先将去检查这个指令的参数是否能在<code>常量池</code>中定位到一个类的<code>符号引用</code>，并且检查这个符号引用代表的类是否已被<strong>加载、解析和初始化</strong>过。如果没有，必须先执行相应的<strong>类加载过程</strong>。</li>
<li>在类加载检查通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。<em>对象所需内存的大小在类加载完成后便可完全确定</em>，为对象分配空间的任务实际上便等同于把一块<u>确定大小</u>的内存块从<code>Java堆</code>中划分出来。
<ul>
<li><code>“指针碰撞”（Bump The Pointer）</code>。如果Java堆中内存是<strong>绝对规整</strong>的，所有被<u>使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器</u>。那所分配内存就仅仅是把指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</li>
<li><code>“空闲列表”（Free List）</code>。如果Java堆中的内存是<strong>不规整</strong>的，已被使用的内存和空闲的内存相互交错在一起，<u>虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</u>。</li>
<li>Java堆是否规整<u>由所采用的垃圾收集器是否带有<code>空间压缩整理（Compact）</code>的能力决定</u>。</li>
<li>为了保证对象创建过程<code>线程安全</code>，有两种方法：
<ul>
<li>对分配内存空间的动作进行<code>同步处理</code>——实际上虚拟机是采用<code>CAS配上失败重试</code>的方式保证<strong>更新操作的原子性</strong>；</li>
<li><u>把内存分配的动作按照线程划分在不同的空间之中进行</u>，即每个线程在Java堆中<strong>预先分配一小块内存</strong>，称为<code>本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）</code>。线程要分配内存，就在该线程的本地缓冲区中分配，<u>只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定</u>。</li>
</ul></li>
</ul></li>
<li>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都<strong><code>初始化为零值</code></strong>，如果使用了<code>TLAB</code>，这一项工作也可以提前至<code>TLAB</code>分配时进行。</li>
<li>Java虚拟机对对象进行<strong>必要的设置</strong>，例如<u>对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的<code>GC</code>分代年龄等</u>信息。这些信息存放在对象的<code>对象头（Object Header）</code>之中。</li>
</ol>
</blockquote>
<p>从<code>虚拟机的视角</code>来看，一个新的对象已经产生了。但是从<code>Java程序的视角</code>看来，对象创建才<u>刚刚开始</u>:</p>
<blockquote>
<p><strong>构造函数</strong>，即<code>Class文件</code>中的<code>&lt;init&gt;()</code>方法还没有执行，<u>所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好</u>。</p>
</blockquote>
<h4 id="对象的内存布局">2.2 对象的内存布局</h4>
<p>在<code>HotSpot虚拟机</code>里，对象在堆内存中的存储布局可以划分为三个部分：<code>对象头（Header）</code>、<code>实例数据（Instance Data）</code>和<code>对齐填充（Padding）</code>。</p>
<h5 id="对象头">2.2.1 对象头</h5>
<p>对象头部分包括两类信息：</p>
<ol type="1">
<li>第一类是用于存储<strong>对象自身的<code>运行时数据</code></strong>，如<u>哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</u>等。官方称它为<code>“Mark Word”</code>。</li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/markWord.PNG" alt="HotSpot虚拟机对象头Mark Word" /><figcaption aria-hidden="true">HotSpot虚拟机对象头<code>Mark Word</code></figcaption>
</figure>
<blockquote>
<p><code>Mark Word</code>被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p>
</blockquote>
<ol start="2" type="1">
<li>另外一部分是<strong><code>类型指针</code></strong>，即<u>对象指向它的类型元数据的指针</u>，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</li>
</ol>
<blockquote>
<p>此外，如果对象是一个<code>Java数组</code>，那在对象头中还必须有一块用于<u>记录数组长度</u>的数据。</p>
</blockquote>
<h5 id="实例数据">2.2.2 实例数据</h5>
<p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面<u>所定义的各种类型的字段内容</u>。</p>
<blockquote>
<p>存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</p>
<ul>
<li>HotSpot虚拟机默认的分配顺序为<code>longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs）</code>，相同宽度的字段总是被分配到一起存放</li>
<li>在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前</li>
</ul>
</blockquote>
<h5 id="对齐填充">2.2.3 对齐填充</h5>
<p>对齐填充<em>不是必然存在</em>的，它仅仅起着<code>占位符</code>的作用。主要由于HotSpot虚拟机的自动内存管理系统要求<u>对象起始地址必须是8字节的整数倍</u>。</p>
<h4 id="对象的访问定位">2.3 对象的访问定位</h4>
<p>Java程序会通过栈上的reference数据来操作堆上的具体对象。主流的访问方式主要有<code>使用句柄</code>和<code>直接指针</code>两种：</p>
<ol type="1">
<li><code>使用句柄</code>。Java堆中将可能会划分出一块内存来作为<code>句柄池</code>，<code>reference</code>中存储的就是对象的<code>句柄地址</code>，而句柄中包含了<u>对象实例数据与类型数据</u>各自具体的<strong>地址信息</strong>。</li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/handleAccess.PNG" alt="通过句柄访问对象" /><figcaption aria-hidden="true">通过句柄访问对象</figcaption>
</figure>
<blockquote>
<p>最大好处就是reference中存储的是稳定句柄地址，在对象被移动时<strong>只会改变句柄中的实例数据指针</strong>，而 <code>reference</code>本身不需要被修改。可以理解为只需要移动对象实例数据。</p>
</blockquote>
<ol start="2" type="1">
<li><code>直接指针</code>。Java堆中对象的内存布局需要考虑<u>如何放置访问类型数据的相关信息</u>，<code>reference</code>中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/pointerAccess.PNG" alt="通过直接指针访问对象" /><figcaption aria-hidden="true">通过直接指针访问对象</figcaption>
</figure>
<blockquote>
<p>最大的好处就是速度更快，它节省了一次指针定位的时间开销。</p>
</blockquote>
<h3 id="outofmemoryerror异常处理">3. <code>OutOfMemoryError</code>异常处理</h3>
<h4 id="java堆溢出">3.1 Java堆溢出</h4>
<p>为了捕捉堆溢出，书中实现了如下异常测试程序：</p>
<blockquote>
<p>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证<strong><code>GC Roots</code>到对象之间有可达路径</strong>来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>堆的<code>最小值-Xms</code>参数与<code>最大值-Xmx</code>参数设置为一样即可避免堆自动扩展</li>
<li>参数<code>-XX：+HeapDumpOnOutOf-MemoryError</code>可以让虚拟机在出现内存溢出异常的时候<strong>Dump出当前的内存堆转储快照</strong>以便进行事后分析</li>
</ul>
</blockquote>
<p>运行结果如下：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/heapOOM.PNG" alt="HeapOOM测试结果" /><figcaption aria-hidden="true">HeapOOM测试结果</figcaption>
</figure>
<p>要解决这个内存区域的异常，常规的处理方法是首先通过内存映像分析工具对Dump出来的堆转储快照进行分析。</p>
<blockquote>
<p>这里使用的是<code>IDEA</code>的插件<code>jprofiler</code>，安装方法参考文章：<a href="https://blog.csdn.net/wytocsdn/article/details/79258247" target="_blank" rel="noopener">Intellij IDEA集成JProfiler性能分析神器</a></p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/heapOOMJprofiler.PNG" alt="HeapOOM Jprofiler结果" /><figcaption aria-hidden="true">HeapOOM Jprofiler结果</figcaption>
</figure>
<p>第一步首先应确认内存中<code>导致OOM的对象是</code>否是必要的，也就是要先分清楚到底是出现了<code>内存泄漏（Memory Leak）</code>还是<code>内存溢出（Memory Overflow）</code>。</p>
<ul>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到<code>GC Roots</code>的<code>引用链</code></li>
<li>如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数设置，与机器的内存对比，看看是否还有向上调整的空间。</li>
</ul>
<h4 id="虚拟机栈和本地方法栈溢出">3.2 虚拟机栈和本地方法栈溢出</h4>
<p>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，<code>-Xoss参数</code>（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，<strong>栈容量只能由-<code>Xss参数</code>来设定</strong>。</p>
<p>先将实验范围限制在单线程中操作，尝试下面行为是否能让HotSpot虚拟机产生<code>OutOfMemoryError</code>异常：</p>
<ol type="1">
<li>使用<code>-Xss参数</code>减少栈内存容量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xss128k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaVMStackSOF.PNG" alt="JavaVMStackSOF结果" /><figcaption aria-hidden="true">JavaVMStackSOF结果</figcaption>
</figure>
<blockquote>
<p>栈容量最小值主要取决于操作系统内存分页大小</p>
</blockquote>
<ol start="2" type="1">
<li>定义大量的本地变量，增大此方法帧中本地变量表的长度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> unused1, unused2, unused3, unused4, unused5,</span><br><span class="line">                unused6, unused7, unused8, unused9, unused10,</span><br><span class="line">                unused11, unused12, unused13, unused14, unused15,</span><br><span class="line">                unused16, unused17, unused18, unused19, unused20,</span><br><span class="line">                unused21, unused22, unused23, unused24, unused25,</span><br><span class="line">                unused26, unused27, unused28, unused29, unused30,</span><br><span class="line">                unused31, unused32, unused33, unused34, unused35,</span><br><span class="line">                unused36, unused37, unused38, unused39, unused40,</span><br><span class="line">                unused41, unused42, unused43, unused44, unused45,</span><br><span class="line">                unused46, unused47, unused48, unused49, unused50,</span><br><span class="line">                unused51, unused52, unused53, unused54, unused55,</span><br><span class="line">                unused56, unused57, unused58, unused59, unused60,</span><br><span class="line">                unused61, unused62, unused63, unused64, unused65,</span><br><span class="line">                unused66, unused67, unused68, unused69, unused70,</span><br><span class="line">                unused71, unused72, unused73, unused74, unused75,</span><br><span class="line">                unused76, unused77, unused78, unused79, unused80,</span><br><span class="line">                unused81, unused82, unused83, unused84, unused85,</span><br><span class="line">                unused86, unused87, unused88, unused89, unused90,</span><br><span class="line">                unused91, unused92, unused93, unused94, unused95,</span><br><span class="line">                unused96, unused97, unused98, unused99, unused100;</span><br><span class="line">        stackLength ++;</span><br><span class="line">        test();</span><br><span class="line">        unused1 = unused2 = unused3 = unused4 = unused5 =</span><br><span class="line">        unused6 = unused7 = unused8 = unused9 = unused10 =</span><br><span class="line">        unused11 = unused12 = unused13 = unused14 = unused15 =</span><br><span class="line">        unused16 = unused17 = unused18 = unused19 = unused20 =</span><br><span class="line">        unused21 = unused22 = unused23 = unused24 = unused25 =</span><br><span class="line">        unused26 = unused27 = unused28 = unused29 = unused30 =</span><br><span class="line">        unused31 = unused32 = unused33 = unused34 = unused35 =</span><br><span class="line">        unused36 = unused37 = unused38 = unused39 = unused40 =</span><br><span class="line">        unused41 = unused42 = unused43 = unused44 = unused45 =</span><br><span class="line">        unused46 = unused47 = unused48 = unused49 = unused50 =</span><br><span class="line">        unused51 = unused52 = unused53 = unused54 = unused55 =</span><br><span class="line">        unused56 = unused57 = unused58 = unused59 = unused60 =</span><br><span class="line">        unused61 = unused62 = unused63 = unused64 = unused65 =</span><br><span class="line">        unused66 = unused67 = unused68 = unused69 = unused70 =</span><br><span class="line">        unused71 = unused72 = unused73 = unused74 = unused75 =</span><br><span class="line">        unused76 = unused77 = unused78 = unused79 = unused80 =</span><br><span class="line">        unused81 = unused82 = unused83 = unused84 = unused85 =</span><br><span class="line">        unused86 = unused87 = unused88 = unused89 = unused90 =</span><br><span class="line">        unused91 = unused92 = unused93 = unused94 = unused95 =</span><br><span class="line">        unused96 = unused97 = unused98 = unused99 = unused100 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JavaVMStackSOF.PNG" alt="JavaVMStackSOF2结果" /><figcaption aria-hidden="true">JavaVMStackSOF2结果</figcaption>
</figure>
<blockquote>
<p>出现<code>StackOverflowError</code>异常时，会有明确错误堆栈可供分析，相对而言比较容易定位到问题所在。</p>
</blockquote>
<h4 id="方法区和运行时常量池溢出">3.3 方法区和运行时常量池溢出</h4>
<h5 id="运行时常量池-1">运行时常量池</h5>
<p><code>String::intern()</code>是一个本地方法，它的作用是：</p>
<ul>
<li>如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；</li>
<li>否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</li>
</ul>
<p>对于<code>JDK 6</code>来运行如下代码，会出现运行时常量池的内存溢出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-XX:PermSize=6M -XX:MaxPermSize=6M</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Set保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在short范围内足以让6MB的PermSize产生OOM了</span></span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里没有安装<code>JDK 6</code>就没测试了，按书中所述，会出现如下异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">	at java.lang.String.intern(Native Method)</span><br><span class="line">	at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java: <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p><code>“PermGen space”</code>说明运行时常量池的确是属于方法区的一部分。使用<code>JDK 7</code>或更高版本的<code>JDK</code>并不会得到相同的结果，因为自<code>JDK 7</code>起，原本<u>存放在永久代的字符串常量池被移至Java堆之中</u>，所以在<code>JDK 7</code>及以上版 本，限制方法区的容量对该测试用例来说是毫无意义的。</p>
<h5 id="字符串常量池的实现方式的影响">字符串常量池的实现方式的影响</h5>
<p>对于字符串常量池的实现引出了对<code>String.intern()</code>这个方法的影响，见如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1);</span><br><span class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>在<code>JDK 6</code>中运行，会得到<strong>两个<code>false</code></strong>。在<code>JDK 6</code>中，<code>intern()</code>方法会<strong>把首次遇到的字符串实例复制到永久代的字符串常量池中存储</strong>，返回的也是<u>永久代里面这个字符串实例</u>的引用，而由<code>StringBuilder</code>创建的字符串对象实例<strong>在Java堆</strong>上，所以必然不可能是同一个引用，结果将返回false。</p></li>
<li><p>在<code>JDK 7</code>中运行，会得到一个<code>true</code>和一个<code>false</code>。<code>JDK 7</code>的<code>intern()</code>方法<strong>不需要再拷贝字符串的实例到永久代</strong>，<u>字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可</u>，因此intern()返回的引用和由<code>StringBuilder</code>创建的那个字符串实例就是同一个。</p>
<ul>
<li>对<code>str2</code>比较返回<code>false</code>，这是因为<code>“java”</code>这个字符串在执行<code>StringBuilder.toString()</code>之前就已经出现过了，字符串常量池中已经有它的引用。<code>“java”</code>在加载<code>sun.misc.Version</code>这个类的时候进入常量池</li>
</ul></li>
</ul>
</blockquote>
<h5 id="方法区-1">方法区</h5>
<p>方法区的主要职责是用于存放类型的相关信息，如<u>类名、访问修饰符、常量池、字段描述、方法描述</u>等。对于这部分区域的测试，基本的思路是<strong>运行时产生大量的类去填满方法区，直到溢出为止</strong>。作者借助了<code>CGLib</code>直接操作字节码运行时生成了大量的动态类。</p>
<blockquote>
<p>类似这样的代码确实可能会<strong>出现在实际应用</strong>中：当前的很多主流框架，如<code>Spring</code>、<code>Hibernate</code>对类进行增强时，都会使用到<code>CGLib</code>这类字节码技术。</p>
</blockquote>
<p>一个类如果要被垃圾收集器回收，要达成的条件是<strong>比较苛刻</strong>的。在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。</p>
<p><code>JDK 8</code>以后，<code>元空间</code>作为<code>永久代</code>替代者登场。<code>HotSpot</code>还是提供了一 些参数作为元空间的防御措施：</p>
<blockquote>
<ul>
<li><code>-XX：MaxMetaspaceSize</code>：设置元空间最大值；</li>
<li><code>-XX：MetaspaceSize</code>：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整</li>
<li><code>-XX：MinMetaspaceFreeRatio</code>：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。</li>
</ul>
</blockquote>
<h4 id="本机直接内存溢出">3.4 本机直接内存溢出</h4>
<p><code>直接内存（Direct Memory）</code>的容量大小可通过<code>-XX：MaxDirectMemorySize</code>参数来指定，如果不去指定，则默认与<code>Java堆最大值</code>（由<code>-Xmx</code>指定）一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通 过反射获取<code>Unsafe</code>实例进行内存分配，虽然使用<code>DirectByteBuffer</code>分配内存也会抛出<code>内存溢出异常</code>，但它抛出异常时并没有真正向操作系统申请分配内存，而是<u>通过计算得知内存无法分配就会在代码里手动抛出溢出异常</u>，真正申请分配内存的方法是<code>Unsafe::allocateMemory()</code>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/DirectMemoryOOM.PNG" alt="DirectMemoryOOM结果" /><figcaption aria-hidden="true">DirectMemoryOOM结果</figcaption>
</figure>
<p>如果发现内存溢出之后产生的<code>Dump文件</code>很小，而程序中又直接或间接使用了<code>DirectMemory</code>（<strong>典型的间接使用就是<code>NIO</code></strong>），可以考虑重点检查一下直接内存方面的原因。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--8 虚拟机字节码执行引擎</title>
    <url>/2021/05/28/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_8_Virtual_machine_bytecode_execution_engine.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>执行引擎是Java虚拟机核心的组成部分之一。 <a id="more"></a></p>
</blockquote>
<p>在不同的虚拟机实现中，执行引擎在执行字节码的时候，通常会有<code>解释执行（通过解释器执行）</code>和<code>编译执行（通过即时编译器产生本地代码执行）</code>两种，也可能两者兼备。</p>
<p>但从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：</p>
<ul>
<li>输入的是字节码二进制流；</li>
<li>处理过程是字节码解析执行的等效过程；</li>
<li>输出的是执行结果，</li>
</ul>
<h3 id="运行时栈帧结构">1. 运行时栈帧结构</h3>
<p>Java虚拟机<strong><u>以方法作为最基本的执行单元</u></strong>，<code>“栈帧”（Stack Frame）</code>则是用于支持虚拟机进行<strong>方法调用</strong>和<strong>方法执行</strong>背后的数据结构，它也是虚拟机运行时数据区中的<code>虚拟机栈（Virtual Machine Stack）</code>的栈元素。</p>
<blockquote>
<p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。一个栈帧需要分配多少内存仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/StackFrame.PNG" alt="栈帧结构" /><figcaption aria-hidden="true">栈帧结构</figcaption>
</figure>
<h4 id="局部变量表">1.1 局部变量表</h4>
<p><code>局部变量表（Local Variables Table）</code>是一组变量值的存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>。</p>
<blockquote>
<p>局部变量表的容量以<code>变量槽（Variable Slot）</code>为最小单位，一个变量槽应占用的内存空间大小未明确定义，每个变量槽都应该能存放一个<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>reference</code>或<code>returnAddress</code>类型的数据。对于64位的数据类型，Java虚拟机会以<strong>高位对齐</strong>的方式为其分配两个连续的变量槽空间。</p>
</blockquote>
<p>Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是<u><strong>从0开始至局部变量表最大的变量槽数量</strong></u>。</p>
<blockquote>
<p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成<u><strong>参数值到参数变量列表的传递过程， 即实参到形参的传递</strong></u>。</p>
<ul>
<li>如果执行的是实例方法，局部变量表中<strong><u>第0位索引</u></strong>的变量槽默认是<strong><u>用于传递方法所属对象实例的引用</u></strong>，在方法中可以通过关键字<code>“this”</code>来访问到这个隐含的参数。</li>
<li>其余参数则按照参数表顺序排列，占用<strong><u>从1开始</u></strong>的局部变量槽；</li>
<li>参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</li>
</ul>
</blockquote>
<p>为了尽可能节省栈帧耗用的内存空间，局部变量表中的变量槽是可以重用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 局部变量表Slot复用对垃圾收集的影响</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>placeholder</code>能否被回收的根本原因就是：局部变量表中的变量槽是否还存有关于<code>placeholder</code>数组对象的引用。</p>
<ul>
<li>未加入<code>int a = 0;</code>语句时，虽然已经离开了<code>placeholder</code>的作用域，<code>placeholder</code>原本所占用的变量槽还没有被其他变量所复用，所以作为<code>GC Roots</code>一部分的局部变量表仍然保持着对它的关联。所以<code>placeholder</code>数组对象不会被回收。</li>
<li>手动将其设置占用了大量内存但实际上已经不会再使用的变量为<code>null</code>值(代替那句<code>int a = 0;</code>)，可以作为一种在极特殊情形下的<code>“奇技”</code>来使用。</li>
</ul>
<p>此外，局部变量不像类变量那样存在“准备阶段”，即不会被系统初始化为默认值。</p>
<h4 id="操作数栈">1.2 操作数栈</h4>
<p><code>操作数栈（Operand Stack）</code>也常被称为操作栈，它是一个<code>后入先出（Last In First Out，LIFO）</code>栈。</p>
<blockquote>
<p><code>Javac编译器</code>的<strong>数据流分析工作</strong>保证了在方法执行的任何时候，操作数栈的深度都不会超过在<code>max_stacks</code>数据项中设定的最大值。</p>
</blockquote>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OperandStackShareData.PNG" alt="栈帧之间的数据共享" /><figcaption aria-hidden="true">栈帧之间的数据共享</figcaption>
</figure>
<p>概念上，两个不同栈帧作为不同方法的虚拟机栈的元素，是<strong><u>完全相互独立</u></strong>的。但在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现<u>一部分重叠</u>。让<strong>下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起</strong>，这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了。</p>
<h4 id="动态连接">1.3 动态连接</h4>
<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的<code>动态连接（Dynamic Linking）</code>。</p>
<h4 id="方法返回地址">1.4 方法返回地址</h4>
<p>当一个方法开始执行后，只有两种方式退出这个方法：</p>
<ol type="1">
<li>第一种方式是<u><strong>执行引擎遇到任意一个方法返回的字节码指令</strong></u>，这时候可能会有返回值传递给上层的方法调用者，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为<code>“正常调用完成”（Normal Method Invocation Completion）</code>。</li>
<li>另外一种是在<u><strong>方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理</strong></u>。无论是Java虚拟机内部产生的异常，还是代码中使用<code>athrow</code>字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为<code>“异常调用完成（Abrupt Method Invocation Completion）”</code>。一个方法使用异常完成出口的方式退出，是<strong><u>不会给它的上层调用者提供任何返回值的</u></strong>。</li>
</ol>
<p>方法退出之后必须返回到最初方法被调用时的位置，退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>
<ul>
<li>方法正常退出时，<u><strong>主调方法的PC计数器的值就可以作为返回地址</strong></u>，栈帧中很可能会保存这个计数器值；</li>
<li>方法异常退出时，<u><strong>返回地址要通过异常处理器表来确定</strong></u>，栈帧中就一般不会保存这部分信息。</li>
</ul>
<h4 id="附加信息">1.5 附加信息</h4>
<p>比如与调试、性能收集相关的信息。一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为<code>栈帧信息</code>。</p>
<h3 id="方法调用">2. 方法调用</h3>
<p><strong>方法调用并<u>不等同于</u>方法中的代码被执行</strong>，方法调用阶段唯一的任务就是<strong>确定被调用方法的版本</strong>。</p>
<h4 id="解析">2.1 解析</h4>
<p>所有方法调用的目标方法在Class文件里面都是一个<strong>常量池中的符号引用</strong>，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：</p>
<ul>
<li>方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为<code>解析（Resolution）</code>。</li>
</ul>
<blockquote>
<p>在Java语言中符合<code>“编译期可知，运行期不可变”</code>这个要求的方法，主要有静态方法、私有方法、实例构造器、父类方法，再加上被<code>final</code>修饰的方法（尽管它使用<code>invokevirtual</code>指令调用），这5种方法调用会在<strong>类加载</strong>的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为<code>“非虚方法”（Non-Virtual Method）</code>，其他方法就被称为<code>“虚方法”（Virtual Method）</code>。</p>
</blockquote>
<p>解析调用一定是个<code>静态的过程</code>，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用。</p>
<h4 id="分派">2.2 分派</h4>
<p><code>分派 （Dispatch）</code>调用可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。</p>
<h5 id="静态分派">2.2.1 静态分派</h5>
<p>通过如下代码来定义两个关键概念：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>静态类型（Static Type）</code>。“Human”称为变量的<code>“静态类型”（Static Type）</code>，或者叫<code>“外观类型”（Apparent Type）</code>，静态类型的变化仅仅<u>在使用时发生</u>，变量本身的静态类型不会被改变，并且最终的静态类型是<u><strong>在编译期可知的</strong></u>；</li>
<li><code>实际类型（Actual Type）</code>。“Man”则被称为变量的<code>“实际类型”（Actual Type）</code>或者叫<code>“运行时类型”（Runtime Type）</code>，实际类型变化的结果<u>在运行期才可确定</u>，编译器<strong><u>在编译程序的时候并不知道</u></strong>一个对象的实际类型是什么。</li>
</ul>
<p>比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line">Human human = (<span class="keyword">new</span> Random()).nextBoolean() ? <span class="keyword">new</span> Man() : <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">sr.sayHello((Man) human)</span><br><span class="line">sr.sayHello((Woman) human)</span><br></pre></td></tr></table></figure>
<ul>
<li>对象<code>human</code>的实际类型是可变的，到底是Man还是Woman，必须等到程序运行到这行的时候才能确定。</li>
<li>human的静态类型是Human，也可以在使用时（如<code>sayHello()</code>方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的</li>
</ul>
<p>在如下的例子中，使用哪个重载版本的<code>sayHello()</code>方法，完全取决于传入参数的数量和数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,guy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,gentleman!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,lady!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚拟机（或者准确地说是编译器）在重载时是<strong><u>通过参数的静态类型而不是实际类型作为判定依据的</u></strong>，所以在编译阶段，<code>Javac</code>编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了<code>sayHello(Human)</code>作为调用目标。</p>
<blockquote>
<p>所有依赖<code>静态类型</code>来决定方法执行版本的分派动作，都称为<code>静态分派</code>。</p>
</blockquote>
<p>静态分派的最典型应用表现就是<code>方法重载</code>。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。从下面的示例代码可以看出方法重载中，选择重载版本的匹配优先级：</p>
<ul>
<li><p>如果注释掉 <code>sayHello(char arg)</code>方法，会输出：<code>hello int</code>。这时发生了一次自动类型转换，<code>'a'</code>转换为<code>int</code>类型。</p></li>
<li><p>继续注释掉<code>sayHello(int arg)</code>方法，那输出会变为：<code>hello long</code>。这时发生了两次自动类型转换，<code>'a'</code>转型为整数<code>97</code>之后，进一步转型为长整数<code>97L</code>。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello int"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello long"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello char ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello Serializable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自动转型可以依<code>据char&gt;int&gt;long&gt;float&gt;double</code>的顺序转型进行匹配。</li>
<li>自动装箱为封装类型<code>java.lang.Character</code>，但是自动装箱的封装类型<code>java.lang.Character</code>不会转换为其他封装类型，比如<code>Integer</code>。</li>
<li>封装类型<code>java.lang.Character</code>只能安全地转型为它实现的接口(如<code>java.lang.Serializable</code>)或父类(如<code>Object</code>)。</li>
<li>可见变长参数的重载优先级是最低的，这里使用的是<code>char</code>类型的变长参数。</li>
</ul>
<h5 id="动态分派">2.2.2 动态分派</h5>
<p>动态分派与<code>重写（Override）</code>有着密切关联，考虑如下方法的动态分派：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法动态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"woman say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里选择调用的方法版本不可能再根据静态类型来决定的，因为静态类型同样都是<code>Human</code>的两个变量<code>man</code>和<code>woman</code>在调用<code>sayHello()</code>方法时产生了不同的行为。导致这个现象的原因很明显，是因为这两个变量的<code>实际类型</code>不同。</p>
<p>从子节码看，这两条调用指令无论是指令（都是<code>invokevirtual</code>）还是参数都完全一样，但是这两句指令最终执行的目标方法并不相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span><br><span class="line">20: aload_2</span><br><span class="line">21: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span><br></pre></td></tr></table></figure>
<p><code>invokevirtual</code>指令的运行时解析过程大致分为以下几步：</p>
<ol type="1">
<li>找到操作数栈顶的第一个元素所指向的对象的<code>实际类型</code>，记作<code>C</code>。</li>
<li>如果在类型<code>C</code>中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回<code>java.lang.IllegalAccessError</code>异常。</li>
<li>否则，按照继承关系从下往上依次对<code>C</code>的各个父类进行第二步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li>
</ol>
<p><code>invokevirtual</code>指令执行的第一步就是在运行期确定<code>接收者（Receiver）</code>的<code>实际类型</code>，所以两次调用中的 <code>invokevirtual</code>指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。</p>
<blockquote>
<p>把这种在运行期根据<code>实际类型</code>确定方法执行版本的分派过程称为<code>动态分派</code>。</p>
</blockquote>
<h5 id="单分派与多分派">2.2.3 单分派与多分派</h5>
<p>方法的<code>接收者</code>与方法的<code>参数</code>统称为方法的<code>宗量</code>，根据分派基于多少种宗量，可以将分派划分为<code>单分派</code>和<code>多分派</code>两种。</p>
<ul>
<li><code>单分派</code>是根据一个宗量对目标方法进行选择；</li>
<li><code>多分派</code>则是根据多于一个宗量对目标方法进行选择。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单分派、多分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先是编译阶段中编译器的选择过程，也就是<code>静态分派</code>的过程。选择目标方法的依据有两点：
<ul>
<li>一是静态类型是Father还是Son；</li>
<li>二是方法参数是QQ还是360。</li>
</ul></li>
<li>选择结果的最终产生了两条<code>invokevirtual</code>指令，两条指令的参数分别为常量池中指向<code>Father::hardChoice(360)</code>及<code>Father::hardChoice(QQ)</code>方法的符号引用。</li>
</ul>
<blockquote>
<p>因为是根据两个宗量进行选择，所以Java语言的<code>静态分派</code>属于<code>多分派</code>类型。</p>
</blockquote>
<ul>
<li>然后是运行阶段中虚拟机的选择，也就是动态分派的过程：
<ul>
<li>执行<code>“son.hardChoice(new QQ())”</code>所对应的<code>invokevirtual</code>指令时，由于编译期已经决定目标方法的签名必须为<code>hardChoice(QQ)</code>，这时候参数的<code>静态类型</code>、<code>实际类型</code>都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有该方法的<code>接受者的实际类型</code>。</li>
</ul></li>
</ul>
<blockquote>
<p>因为只有一个宗量作为选择依据， 所以Java语言的<code>动态分派</code>属于<code>单分派</code>类型。</p>
</blockquote>
<p>如今的Java语言是一门<code>静态多分派</code>、<code>动态单分派</code>的语言。</p>
<h5 id="虚拟机动态分派的实现">2.3.4 虚拟机动态分派的实现</h5>
<p>动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的<code>方法元数据</code>中搜索合适的目标方法。基于执行性能的考虑，一种基础而且常见的优化手段是使用<code>虚方法表索引</code>来代替元数据查找以提高性能。</p>
<ul>
<li>为类型在方法区中建立一个<code>虚方法表（Virtual Method Table</code>，也称为<code>vtable</code>）</li>
<li>在<code>invokeinterface</code>执行时也会用到接口方法表（<code>Interface Method Table</code>，简称<code>itable</code>）</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/MethodTable.PNG" alt="方法表结构" /><figcaption aria-hidden="true">方法表结构</figcaption>
</figure>
<p>虚方法表中存放着各个方法的<code>实际入口地址</code>。</p>
<ul>
<li>如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。</li>
<li>如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</li>
</ul>
<p>具有<code>相同签名</code>的方法，在父类、子类的虚方法表中都应当具有一样的<code>索引序号</code>，当类型变换时仅需要变更查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p>
<p>虚拟机除了使用虚方法表之外，为了进一步提高性能，还会使用<code>类型继承关系分析（Class Hierarchy Analysis，CHA）</code>、<code>守护内联（Guarded Inlining）</code>、<code>内联缓存（Inline Cache）</code>等多种非稳定的激进优化来争取更大的性能空间。</p>
<h3 id="动态类型语言支持">3. 动态类型语言支持</h3>
<p><code>invokedynamic</code>指令是为了实现<code>动态类型语言（Dynamically Typed Language）</code>支持而进行的改进。</p>
<h4 id="动态类型语言">3.1 动态类型语言</h4>
<p><code>动态类型语言</code>的<u>关键特征</u>是<strong><u>它的类型检查的主体过程是在运行期而不是编译期进行的</u></strong>。在编译期就进行类型检查过程的语言（譬如C++和Java等）就是<code>静态类型语言</code>。</p>
<p>动态类型语言与<code>Java</code>有一个核心的差异就是<u><strong>变量本身并没有类型，变量的值才具有类型</strong></u>，所以编译器在编译时最多只能确定<u>方法名称</u>、<u>参数</u>、<u>返回值</u>这些信息，而不会去确定方法所在的具体类型（即方法接收者不固定）。</p>
<blockquote>
<p><code>“变量无类型而变量值才有类型”</code>是动态类型语言的一个核心特征。</p>
</blockquote>
<h4 id="java与动态类型">3.2 Java与动态类型</h4>
<p><code>JDK 7</code>以前的字节码指令集中，4条方法调用指令（<code>invokevirtual</code>、<code>invokespecial</code>、<code>invokestatic</code>、 <code>invokeinterface</code>）的第一个参数都是<code>被调用方法的符号引用</code>，方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定方法的接收者。</p>
<h4 id="java.lang.invoke包">3.3 <code>java.lang.invoke</code>包</h4>
<p><code>JDK 7</code>时新加入的<code>java.lang.invoke</code>包的主要目的是<u><strong>在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制</strong></u>，称为<code>“方法句柄”（Method Handle）</code>。</p>
<p>拥有方法句柄之后，Java语言也可以拥有类似于<code>函数指针</code>或者<code>委托</code>的方法别名这样的工具：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JSR 292 MethodHandle基础用法演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> ClassA();</span><br><span class="line">        <span class="comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。</span></span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">"icyfenix"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和具体参数（methodType()第二个及以后的参数）。</span></span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</span></span><br><span class="line">        <span class="comment">// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情。</span></span><br><span class="line">        <span class="keyword">return</span> lookup().findVirtual(reveiver.getClass(), <span class="string">"println"</span>, mt).bindTo(reveiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getPrintlnMH()</code>方法实际上是模拟了<code>invokevirtual</code>指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个由用户设计的Java方法来实现。而这个方法本身的返回值 <code>（MethodHandle对象）</code>，可以视为对最终调用方法的一个<code>“引用”</code>。</p>
<p><code>MethodHandle</code>与<code>Reflection</code>的区别：</p>
<ul>
<li><code>Reflection</code>和<code>MethodHandle</code>机制本质上都是在<strong>模拟方法调用</strong>，但是<code>Reflection</code>是在<strong>模拟Java代码层次</strong>的方法调用，而<code>MethodHandle</code>是在<strong>模拟字节码层次</strong>的方法调用。</li>
<li><code>Reflection</code>中的<code>java.lang.reflect.Method</code>比<code>MethodHandle</code>中的 <code>java.lang.invoke.MethodHandle</code>对象所包含的信息多。
<ul>
<li>前者是方法在Java端的全面映像，包含了方法的<u>签名</u>、<u>描述符</u>以及<u>方法属性表中各种属性的Java端表示方式</u>，还包含<u>执行权限等的运行期信息</u>。</li>
<li>后者仅包含执行该方法的相关信息。<code>Reflection</code>是重量级，而<code>MethodHandle</code> 是轻量级。</li>
</ul></li>
<li>理论上<code>MethodHandle</code>上也可以采用虚拟机在字节码层次的各种优化方法 （如方法内联），而通过反射去调用方法则几乎不可能直接去实施各类调用点优化措施。</li>
<li><code>Reflection API</code>的设计目标是只为Java语言服务的，而<code>MethodHandle</code>则设计为可服务于所有Java虚拟机之上的语言。</li>
</ul>
<h4 id="invokedynamic指令">3.4 <code>invokedynamic</code>指令</h4>
<p><code>invokedynamic</code>指令与<code>MethodHandle</code>机制的作用是一样的，都是把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中。两者的思路也是可类比的，只是一个用<strong>上层代码和API</strong>来实现， 另一个用<strong>字节码和Class中其他属性、常量</strong>来完成。</p>
<p>每一处含有<code>invokedynamic</code>指令的位置都被称作<code>“动态调用点（Dynamically-Computed Call Site）”</code>，这条指令的第一个参数是<code>JDK 7</code>时新加入的<code>CONSTANT_InvokeDynamic_info</code>常量，从中可以得到3项信息：</p>
<ul>
<li><code>引导方法（Bootstrap Method）</code>，该方法存放在新增的<code>BootstrapMethods</code>属性中，有固定的参数，并且返回值规定是<code>java.lang.invoke.CallSite</code>对象，这个对象代表了真正要执行的目标方法调用；</li>
<li><code>方法类型（MethodType）</code>；</li>
<li><code>名称</code>。</li>
</ul>
<h3 id="基于栈的字节码解释执行引擎">4. 基于栈的字节码解释执行引擎</h3>
<h4 id="解释执行">4.1 解释执行</h4>
<p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过如下各个步骤</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/compileProcess.PNG" alt="编译过程" /><figcaption aria-hidden="true">编译过程</figcaption>
</figure>
<h4 id="基于栈的指令集与基于寄存器的指令集">4.2 基于栈的指令集与基于寄存器的指令集</h4>
<p><code>基于栈的指令集架构（Instruction Set Architecture，ISA）</code>，字节码指令流里面的指令大部分都是<strong><u>零地址指令</u></strong>，它们依赖操作数栈进行工作。<code>Javac</code>编译器输出的字节码指令流基本上是基于栈的指令集架构。</p>
<ul>
<li>主要优点是可移植，因为寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。还有一些其他的优点，如代码相对更加紧凑，编译器实现更加简单。</li>
<li>主要缺点是理论上执行速度相对来说会稍慢一些。完成相同功能所需的指令数量一般会比寄存器架构来得更多，更重要的是栈实现在内存中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。</li>
</ul>
<p><code>基于寄存器的指令集</code>，就是现在我们主流PC机中物理硬件直接支持的指令集架构，这些指令依赖寄存器进行工作。最典型的就是<code>x86</code>的<strong><u>二地址指令集</u></strong>。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--5 调优案例分析与实战</title>
    <url>/2021/05/26/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_5_Tuning_case_study_and_practice.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code> <a id="more"></a></p>
</blockquote>
<h3 id="案例分析">1. 案例分析</h3>
<p>如何在不改变已有软硬件版本和规格的前提下，调整部署和配置策略去解决或者缓解问题。</p>
<h4 id="大内存硬件上的程序部署策略">1.1 大内存硬件上的程序部署策略</h4>
<p>案例描述：</p>
<blockquote>
<p>升级网址服务器硬件后，<code>HotSpot</code>虚拟机是以服务端模式运行，默认使用的是吞吐量优先收集器，回收<code>12GB</code>的<code>Java</code>堆，一次<code>Full GC</code>的停顿时间就高达14秒。过大的堆内存进行回收时带来的长时间的停顿，将Java堆分配的内存重新缩小到<code>1.5GB</code>或者<code>2GB</code>，这样的确可以避免长时间停顿，但是在硬件上的投资就显得非常浪费。</p>
</blockquote>
<p>解决方式：</p>
<p>目前单体应用在较大内存的硬件上主要部署方式为：</p>
<blockquote>
<ol type="1">
<li>通过一个<u>单独的Java虚拟机</u>实例来管理大量的Java堆内存。
<ul>
<li>这种部署方式必须把应用的<code>Full GC</code>频率控制得足够低，至少要低到不会在用户使用过程中发生。这样可以通过在深夜执行<code>定时任务的方式触发Full GC</code>甚至是<code>自动重启应用服务器</code>来保持内存可用空间在一个稳定的水平。</li>
</ul></li>
<li>同时使用若干个Java虚拟机，建立<u>逻辑集群</u>来利用硬件资源。
<ul>
<li>做法是在一台物理机器上启动多个应用服务器进程，为每个服务器进程分配不同端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。</li>
</ul></li>
</ol>
</blockquote>
<p>最后的部署方案是调整为建立<code>5</code>个<code>32</code>位<code>JDK</code>的逻辑集群，每个进程按<code>2GB</code>内存计算（其中堆固定为<code>1.5GB</code>），占用了 <code>10GB</code>内存。另外建立一个<code>Apache</code>服务作为前端均衡代理作为访问门户。</p>
<h4 id="集群间同步导致的内存溢出">1.2 集群间同步导致的内存溢出</h4>
<p>案例描述：</p>
<blockquote>
<p>构成一个亲合式集群，使用<code>JBossCache</code>构建了一个全局缓存来解决数据库中<u>读写频繁、竞争激烈</u>对性能影响较大的问题，全局缓存启用后，服务正常使用了一段较长的时间，最近不定期出现多次的内存溢出问题。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<ul>
<li><p><code>JBossCache</code>是基于自家的<code>JGroups</code>进行集群间的数据通信，<code>JGroups</code>使用协议栈的方式来实现收发数据包的各种所需特性自由组合，数据包接收和发送时要经过每层协议栈的<code>up()</code>和<code>down()</code>方法，其中的<code>NAKACK</code>栈用于<u>保障各个包的有效顺序以及重发</u>。</p></li>
<li><p>也有<code>MIS</code>系统实现方式上的缺陷。网络情况不能满足传输要求时，重发数据在内存中不断堆积，很快就产生了内存溢出。</p></li>
</ul>
</blockquote>
<h4 id="堆外内存导致的溢出错误">1.3 堆外内存导致的溢出错误</h4>
<p>案例描述：</p>
<blockquote>
<p>基于<code>B/S</code>的电子考试系统服务端不定时抛出内存溢出异常。尝试过把堆内存调到最大，<code>32</code>位系统最多到 <code>1.6GB</code>基本无法再加大了，而且开大了基本没效果，抛出内存溢出异常好像还更加频繁。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<p><code>Direct Memory</code>耗用的内存并不算入这<code>1.6GB</code>的堆之内，因此它最大也只能在剩余的<code>0.4GB</code>空间中再分出一部分而已。在此应用中导致溢出的关键是</p>
<ul>
<li><u>垃圾收集进行时，虚拟机虽然会对直接内存进行回收，但是直接内存只能等待老年代满后<code>Full GC</code>出现后，“顺便”帮它清理掉内存的废弃对象</u>。</li>
<li>否则需要等到抛出内存溢出异常时捕获到异常，再在Catch块里面通过<code>System.gc()</code>来触发垃圾收集。</li>
</ul>
</blockquote>
<p>下面这些区域还会占用较多的内存，内存总和受到操作系统进程最大内存的限制：</p>
<ul>
<li>直接内存：可通<code>过-XX：MaxDirectMemorySize</code>调整大小；</li>
<li>线程堆栈：可通过<code>-Xss</code>调整大小，内存不足时抛出<code>StackOverflowError</code>或者<code>OutOfMemoryError</code>；</li>
<li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，如果无法分配，可能会抛出<code>IOException：Too many open files</code>异常。</li>
<li>JNI代码：如果代码中使用了JNI调用本地库，占用的是Java虚拟机的本地方法栈和本地内存的。</li>
</ul>
<h4 id="外部命令导致系统缓慢">1.4 外部命令导致系统缓慢</h4>
<p>案例描述：</p>
<blockquote>
<p>一个数字校园应用系统，发现请求响应时间比较慢，通过操作系统的<code>mpstat</code>工具发现处理器使用率很高，但是<u>系统中占用绝大多数处理器资源的程序并不是该应用本身</u>。通过<code>dtrace</code>脚本发现最消耗处理器资源的竟然是<code>“fork”</code>系统调用，<code>“fork”</code>系统调用是Linux用来产生新进程的，在Java虚拟机中，用户编写的Java代码通常最多只会创建新的线程，不应当有进程的产生。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<p>每个用户请求的处理都需要执行一个外部<code>Shell</code>脚本来获得系统的一些信息。执行这个Shell脚本是通过Java的<code>Runtime.getRuntime().exec()</code>方法来调用的。即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也会非常可观。</p>
<p>去掉这个Shell脚本执行的语句，改为使用Java的<code>API</code>去获取这些信息后，系统很快恢复了正常。</p>
</blockquote>
<h4 id="服务器虚拟机进程崩溃">1.5 服务器虚拟机进程崩溃</h4>
<p>案例描述：</p>
<blockquote>
<p>一个基于B/S的MIS系统，正常运行一段时间后，最近发现在运行期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下了一个<code>hs_err_pid###.log</code>文件后，虚拟机进程就消失了。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<p>由于MIS系统的用户多，待办事项变化很快，为了不被<code>OA系统</code>速度拖累，使用了<strong>异步的方式</strong>调用 Web服务，但由于两边服务速度的完全不对等，时间越长就累积了越多Web服务没有调用完成，导致在等待的线程和Socket连接越来越多，最终超过虚拟机的承受能力后导致虚拟机进程崩溃。</p>
<p>修复<code>OA门户</code>无法使用的集成接口，并将异步调用改为<u>生产者/消费者模式</u>的消息队列实现后，系统恢复正常。</p>
</blockquote>
<h4 id="不恰当数据结构导致内存占用过大">1.6 不恰当数据结构导致内存占用过大</h4>
<p>案例描述：</p>
<blockquote>
<p>一个后台<code>RPC</code>服务器，业务上需要每 10分钟加载一个约<code>80MB</code>的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个<code>HashMap&lt;Long，Long&gt;Entry</code>，在这段时间里面<code>Minor GC</code>就会造成超过<code>500毫秒</code>的停顿，对于这种长度的停顿时间就接受不了了。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<ul>
<li>如果不修改程序，仅从GC调优的角度去解决这个问题，可以考虑直接将Survivor空间去掉，让新生代中存活的对象在第一次<code>Minor GC</code>后立即进入老年代，等到<code>Major GC</code>的时候再去清理它们。</li>
<li>这里产生问题的根本原因是用<code>HashMap&lt;Long, Long&gt;</code>结构来存储数据文件空间效率太低了，只有<code>Key</code>和<code>Value</code>所存放的两个长整型数据是有效数据，空间效率为有效数据除以全部内存空间，即16字节/88字节=18%。</li>
</ul>
</blockquote>
<h4 id="由windows虚拟内存导致的长时间停顿">1.7 由Windows虚拟内存导致的长时间停顿</h4>
<p>案例描述：</p>
<blockquote>
<p>一个带<code>心跳检测功能</code>的GUI桌面程序，每15秒会发送一次心跳检测信号，如果对方30秒以内都没有信号返回，那就认为和对方程序的连接已经断开。程序上线后发现心跳检测有误报的可能，原因是程序会偶尔出现间隔约一分钟的时间完全无日志输出，处于停顿状态。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<ul>
<li>程序在最小化时它的工作内存被自动交换到磁盘的页面文件之中了，这样发生垃圾收集时就有可能因为恢复页面文件的操作导致不正常的垃圾收集停顿。在Java的GUI程序中要避免这种现象，可以加入参数“<code>-Dsun.awt.keepWorkingSetOnMinimize=true</code>”来解决。</li>
</ul>
</blockquote>
<h4 id="由安全点导致长时间停顿">1.8 由安全点导致长时间停顿</h4>
<p>案例描述：</p>
<blockquote>
<p>一个比较大的承担公共计算任务的离线HBase集群，因为集群读写压力较大，而离线分析任务对延迟又不会特别敏感，所以将<code>-XX:MaxGCPauseMillis</code>参数设置到了<em>500毫秒</em>。不过运行一段时间后发现垃圾收集的停顿经常达到<em>3秒</em>以 上，而且实际垃圾收集器进行回收的动作就只占其中的几百毫秒。</p>
</blockquote>
<p>解决方式：</p>
<blockquote>
<ul>
<li>日志显示当前虚拟机的操作（VM Operation，VMOP）是等待所有用户线程进入到安全点，但是有两个线程特别慢，导致发生了很长时间的<code>自旋等待</code>。</li>
<li>使用int类型或范围更小 的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为<code>可数循环（Counted Loop）</code>，相对应地，使用long或者范围更大的数据类型作为索引值的循环就被称为<code>不可数循环（Uncounted Loop）</code>，将会被放置安全点。把循环索引的数据类型从int改为long即可。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--3 垃圾收集器与内存分配策略</title>
    <url>/2021/05/17/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_3_Garbage_collector_and_memory_allocation_strategy.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</code> <a id="more"></a></p>
</blockquote>
<h3 id="对象已死">1. 对象"已死"？</h3>
<p>垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（<code>“死去”即不可能再被任何途径使用的对象</code>）。</p>
<h4 id="引用计数算法">1.1 引用计数算法</h4>
<p>在对象中添加一个<code>引用计数器（Reference Counting）</code>，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；<strong>任何时刻计数器为零的对象就是不可能再被使用的</strong>。</p>
<blockquote>
<ul>
<li>占用了一些额外的内存空间来进行计数</li>
<li>原理简单，判定效率也很高</li>
</ul>
</blockquote>
<p>主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作。</p>
<blockquote>
<p>譬如单纯的引用计数就很难解决对象之间<code>相互循环引用</code>的问题。</p>
<ul>
<li>对象<code>objA</code>和<code>objB</code>都有字段<code>instance</code>；</li>
<li>赋值令 <code>objA.instance=objB</code>及<code>objB.instance=objA</code>，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问；</li>
<li>但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。</li>
</ul>
</blockquote>
<p>打印内存回收日志的参数设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails      //打印GC详细信息</span><br><span class="line">-Xms100M    //堆大小100M</span><br><span class="line">-Xmx200M   //堆最大占用内存</span><br><span class="line">-Xmn10M     //新生代 大小 </span><br><span class="line">-XX:SurvivorRatio=8   //Eden:Survivor1:Survivor2 = 8:1:1</span><br><span class="line">-XX:MaxPermSize30M   //永久代内存大小</span><br><span class="line">-XX:MetaspaceSize=30M  //元空间 初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</span><br><span class="line">-XX:MaxMetaspaceSize=300M //最大空间，默认是没有限制的。</span><br></pre></td></tr></table></figure>
<h4 id="可达性分析算法">1.2 可达性分析算法</h4>
<p><code>可达性分析（Reachability Analysis）算法</code>的基本思路是：</p>
<blockquote>
<ul>
<li>通过 一系列称为<code>“GC Roots”</code>的根对象作为<strong>起始节点集</strong>，从这些节点开始，根据引用关系向下搜索；</li>
<li>搜索过程所走过的路径称为<code>“引用链”（Reference Chain）</code>，如果某个对象到<code>GC Roots</code>间没有任何引用链相连， 或者用图论的话来说就是从<code>GC Roots</code>到这个对象不可达时，则证明此对象是不可能再被使用的。</li>
</ul>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Reachability_Analysis.PNG" alt="可达性分析算法" /><figcaption aria-hidden="true">可达性分析算法</figcaption>
</figure>
<p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是使用了可达性分析算法。固定可作为<code>GC Roots</code>的对象包括以下几种：</p>
<ul>
<li>在<code>虚拟机栈（栈帧中的本地变量表）中引用的对象</code>，譬如各个线程被调用的方法堆栈中使用到的<u>参数、局部变量、临时变量</u>等。</li>
<li>在<strong>方法区</strong>中<code>类静态属性引用的对象</code>，譬如Java类的引用类型静态变量。</li>
<li>在<strong>方法区</strong>中<code>常量引用的对象</code>，譬如字符串常量池（String Table）里的引用。</li>
<li>在<code>本地方法栈中JNI</code>（即通常所说的Native方法）引用的对象。</li>
<li><code>Java虚拟机内部的引用</code>，如基本数据类型对应的Class对象，一些常驻的<strong>异常对象</strong>（比如<code>NullPointExcepiton</code>、<code>OutOfMemoryError</code>）等，还有系统类加载器。</li>
<li>所有被<code>同步锁（synchronized关键字）持有的对象</code>。</li>
<li>反映Java虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI中注册的回调</code>、<code>本地代码缓存</code>等。</li>
</ul>
<p>除了这些<strong>固定</strong>的<code>GC Roots</code>集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象<strong>“临时性”</strong>地加入，共同构成完整<code>GC Roots</code>集合。</p>
<h4 id="引用的分类">1.3 引用的分类</h4>
<p>在<code>JDK 1.2</code>版之后，Java对引用的概念进行了扩充，将引用分为<code>强引用（Strongly Re-ference）</code>、<code>软引用（Soft Reference）</code>、<code>弱引用（Weak Reference）</code>和<code>虚引用（Phantom Reference）</code>4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li><p>强引用是指在程序代码之中普遍存在的引用赋值，即类似<code>“Object obj=new Object()”</code>这种引用关系。</p>
<blockquote>
<p>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。`</p>
</blockquote></li>
<li><p>软引用是用来描述一些<strong>还有用，但非必须的对象</strong>。</p>
<blockquote>
<ul>
<li>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</li>
<li>在<code>JDK 1.2</code>版之后提供了<code>SoftReference</code>类来实现软引用。</li>
</ul>
</blockquote></li>
<li><p>弱引用也是用来描述那些<strong>非必须对象</strong>，但是它的强度比软引用更弱一些。</p>
<blockquote>
<p>被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
<p>在<code>JDK 1.2</code>版之后提供了<code>WeakReference</code>类来实现弱引用。</p>
</blockquote></li>
<li><p>虚引用也称为<code>“幽灵引用”</code>或者<code>“幻影引用”</code>，它是最弱的一种引用关系。</p>
<blockquote>
<p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的<u>只是为了能在这个对象被收集器回收时收到一个系统通知</u>。</p>
<p>在<code>JDK 1.2</code>版之后提供 了<code>PhantomReference</code>类来实现虚引用。</p>
</blockquote></li>
</ul>
<h4 id="对象的死亡宣告">1.4 对象的死亡宣告</h4>
<p>在可达性分析算法中判定为不可达的对象，至少要经历两次标记过程：</p>
<ol type="1">
<li><p>如果对象在进行可达性分析后发现没有与<code>GC Roots</code>相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是<u>此对象是否有必要执行<code>finalize()</code>方法</u>。</p>
<ul>
<li><p>假如对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为<strong>“没有必要执行”</strong>。</p></li>
<li><p>如果这个对象被判定为确<strong>有必要执行<code>finalize()</code>方法</strong>，那么该对象将会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条由虚拟机<strong>自动建立的、低调度优先级</strong>的<code>Finalizer</code>线程去执行它们的<code>finalize()</code> 方法。</p>
<ul>
<li><code>“执行”</code>是<u>指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束</u>。</li>
</ul></li>
</ul></li>
<li><p>稍后收集器将对<code>F-Queue</code>中的对象进行<u>第二次小规模的标记</u>，如果对象要在<code>finalize()</code>中重新与引用链上的任何一个对象建立关联，那在第二次标记时它将被移出“即将回收”的集合。</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此代码演示了两点：</span></span><br><span class="line"><span class="comment">* 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment">* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes, i am still alive :)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/FinalizeEscapeGC.PNG" alt="FinalizeEscapeGC运行结果" /><figcaption aria-hidden="true">FinalizeEscapeGC运行结果</figcaption>
</figure>
<p>代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败了。这是因为<strong>任何一个对象的finalize()方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p>
<blockquote>
<p><code>finalize()</code>是不推荐使用的语法</p>
</blockquote>
<h4 id="回收方法区">1.5 回收方法区</h4>
<p>方法区的垃圾收集主要回收两部分内容：<code>废弃的常量</code>和<code>不再使用的类型</code>。</p>
<ul>
<li>回收废弃常量与回收 Java堆中的对象非常类似。</li>
<li>判定一个类型是否属于<code>“不再被使用的类”</code>需要同时满足下面三个条件：
<ul>
<li><strong>该类所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li><strong>加载该类的类加载器已经被回收</strong>，这个条件则通常是很难达成。</li>
<li><strong>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li>
</ul></li>
</ul>
<h3 id="垃圾收集算法">2. 垃圾收集算法</h3>
<p>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为<code>“引用计数式垃圾收集”（Reference Counting GC）</code>和<code>“追踪式垃圾收集”（Tracing GC）</code>两大类，这两类也常被称作<code>“直接垃圾收集”</code>和<code>“间接垃圾收集”</code>。</p>
<h4 id="分代收集理论">2.1 分代收集理论</h4>
<p><code>“分代收集”（Generational Collection）</code>建立在两个分代假说之上：</p>
<ol type="1">
<li><code>弱分代假说（Weak Generational Hypothesis）</code>：绝大多数对象都是朝生夕灭的。</li>
<li><code>强分代假说（Strong Generational Hypothesis）</code>：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
<p>设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（<strong>年龄即对象熬过垃圾收集过程的次数</strong>）分配到不同的区域之中存储。</p>
<blockquote>
<ul>
<li>如果一个区域中大多数对象都是朝生夕灭，那么把它们集中放在一起，每次回收时只关注如何保留少量存活，就能以较低代价回收到大量的空间；</li>
<li>如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域；</li>
<li>同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</li>
</ul>
</blockquote>
<p>设计者一般至少会把Java堆划分为<code>新生代（Young Generation）</code>和<code>老年代（Old Generation）</code>两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p>
<p>假如要现在进行一次只局限于新生代区域内的收集<code>（Minor GC）</code>，但新生代中的对象是完全有可能被老年代所引用的。需要对分代收集理论添加第三条经验法则：</p>
<ol start="3" type="1">
<li><code>跨代引用假说（Intergenerational Reference Hypothesis）</code>：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
<p>依据这条假说，只需在新生代上建立一个全局的数据结构（该结构被称为<code>“记忆集”</code>，<code>Remembered Set</code>），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生<code>Minor GC</code>时，只有包含了跨代引用的小块内存里的对象才会被加入到<code>GC Roots</code>进行扫描。</p>
<blockquote>
<ul>
<li><code>部分收集（Partial GC）</code>：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
<ul>
<li><code>新生代收集（Minor GC/Young GC）</code>：指目标只是新生代的垃圾收集。</li>
<li><code>老年代收集（Major GC/Old GC）</code>：指目标只是老年代的垃圾收集。</li>
<li><code>混合收集（Mixed GC）</code>：指目标是收集整个新生代以及部分老年代的垃圾收集。</li>
</ul></li>
<li><code>整堆收集（Full GC）</code>：收集整个Java堆和方法区的垃圾收集。</li>
</ul>
</blockquote>
<h4 id="标记-清除mark-sweep算法">2.2 标记-清除(Mark-Sweep)算法</h4>
<p>算法分为<code>“标记”</code>和<code>“清除”</code>两个阶段：</p>
<ul>
<li>首先标记出所有需要回收的对象；</li>
<li>在标记完成后，统一回收掉所有被标记的对象；</li>
</ul>
<p>也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p>
<blockquote>
<p>主要缺点:</p>
<ol type="1">
<li><strong>执行效率不稳定</strong>，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li>
<li><strong>内存空间的碎片化问题</strong>，标记、清除之后会产生大量不连续的内存碎片。</li>
</ol>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Sweep.PNG" alt="“标记-清除”算法" /><figcaption aria-hidden="true">“标记-清除”算法</figcaption>
</figure>
<h4 id="标记-复制mark-copying算法">2.3 标记-复制(Mark-Copying)算法</h4>
<p>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，标记-复制(Mark-Copying)算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。<u>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</u>。</p>
<blockquote>
<p>缺点：</p>
<ul>
<li>如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销；</li>
<li>这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一 点。</li>
</ul>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Copying.PNG" alt="“标记-复制”算法" /><figcaption aria-hidden="true">“标记-复制”算法</figcaption>
</figure>
<p><code>Appel式回收</code>(<code>Andrew Appel</code>提出的一种更优化的<code>半区复制分代策略</code>)的具体做法是：</p>
<ul>
<li>把新生代分为一块较大的<code>Eden空间</code>和两块较小的<code>Survivor空间</code>，每次分配内存只使用<code>Eden</code>和其中一块<code>Survivor</code>。</li>
<li>发生垃圾搜集时，将<code>Eden</code>和<code>Survivor</code>中仍然存活的对象一次性复制到另外一块<code>Survivor</code>空间上，然后直接清理掉<code>Eden</code>和已用过的那块<code>Survivor</code>空间。</li>
</ul>
<p><code>HotSpot虚拟机</code>默认<code>Eden</code>和<code>Survivor</code>的大小比例是<code>8∶1</code>，也即每次新生代中可用内存空间为整个新生代容量的<strong>90%</strong>（<code>Eden</code>的<strong>80%</strong>加上一个<code>Survivor</code>的<strong>10%</strong>）。</p>
<blockquote>
<p><code>Appel式回收</code>还有一个充当罕见情况的<code>“逃生门”</code>的安全设计，当<code>Survivor</code>空间不足以容纳一次<code>Minor GC</code>之后存活的对象时，就需要依赖<strong>其他内存区域（实际上大多就是老年代）</strong>进行<code>分配担保（Handle Promotion）</code>。</p>
</blockquote>
<h4 id="标记-整理mark-compact算法">2.4 标记-整理(Mark-Compact)算法</h4>
<p><code>“标记-整理”（Mark-Compact）算法</code>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Mark_Compact.PNG" alt="“标记-整理”算法" /><figcaption aria-hidden="true">“标记-整理”算法</figcaption>
</figure>
<p>是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。</p>
<h3 id="hotspot的算法细节实现">3. HotSpot的算法细节实现</h3>
<h4 id="根节点枚举">3.1 根节点枚举</h4>
<p>所有收集器在根节点枚举这一步骤时都是<strong>必须暂停用户线程</strong>的，因此毫无疑问根节点枚举与整理内存碎片一样会面临相似的<code>“Stop The World”</code>的困扰。</p>
<p><code>HotSpot</code>使用一组称为<code>OopMap</code>的数据结构直接得到哪些地方存放着对象引用。（<code>普通对象指针（Ordinary Object Pointer，OOP）</code>）</p>
<blockquote>
<ul>
<li>一旦类加载动作完成的时候，就会把对象内什么偏移量上是什么类型的数据计算出来；</li>
<li>在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。</li>
</ul>
</blockquote>
<p>这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等<code>GC Roots</code>开始查找。</p>
<h4 id="安全点">3.2 安全点</h4>
<p><code>HotSpot</code>没有为每条指令都生成<code>OopMap</code>，只是在<strong>“特定的位置”</strong>记录了这些信息，这些位置被称为<code>安全点（Safepoint）</code>。有了安全点的设定，强制要求必须执行到达安全点后才能够暂停下来开始垃圾收集。</p>
<blockquote>
<p>安全点位置的选取基本上是以“<code>是否具有让程序长时间执行的特征</code>”，<code>“长时间执行”</code>的最明显特征就是<strong>指令序列的复用</strong>，例如<u>方法调用、循环跳转、异常跳转</u>等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p>
</blockquote>
<p>如何在垃圾收集发生时让所有线程（这里其实<code>不包括执行JNI调用的线程</code>）都跑到最近的安全点，然后停顿下来。</p>
<blockquote>
<p><code>抢先式中断（Preemptive Suspension）</code>在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。</p>
<p><code>主动式中断（Voluntary Suspension）</code>当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一 个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。</p>
</blockquote>
<p><code>HotSpot</code>使用<code>内存保护陷阱</code>的方式，把轮询操作精简至只有一条汇编指令的程度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x01b6d62d: test %eax,0x160100</span><br></pre></td></tr></table></figure>
<p>当需要暂停用户线程时，虚拟机把<code>0x160100</code>的内存页设置为不可读，那线程执行到<code>test</code>指令时就会产生一个<code>自陷异常信号</code>，然后在预先注册的异常处理器中挂起线程实现等待。</p>
<h4 id="安全区域">3.3 安全区域</h4>
<p><code>安全区域</code>是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。</p>
<blockquote>
<ul>
<li>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。</li>
<li>当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段）:
<ul>
<li>如果完成了，那线程就当作没事发生过，继续执行；</li>
<li>否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</li>
</ul></li>
</ul>
</blockquote>
<h4 id="记忆集与卡表">3.4 记忆集与卡表</h4>
<p><code>记忆集（Remembered Set）</code>是一种用于记录<u>从非收集区域指向收集区域的指针集合</u>的抽象数据结构。实现记忆集的一些可供选择（当然也可以选择这个范围以外的）的记录精度：</p>
<ul>
<li><strong>字长精度</strong>：每个记录精确到一个机器字长，该字包含跨代指针。</li>
<li><strong>对象精度</strong>：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li><strong>卡精度</strong>：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>“卡精度”所指的是用一种称为<code>“卡表”（Card Table）</code>的方式去实现记忆集，字节数组<code>CARD_TABLE</code>的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作<code>“卡页”（Card Page）</code>。</p>
<blockquote>
<p>只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为<code>1</code>，称为这个元素变脏（Dirty），没有则标识为<code>0</code>。</p>
</blockquote>
<h4 id="写屏障">3.5 写屏障</h4>
<p>卡表元素何时变脏?</p>
<blockquote>
<p>有其他分代区域中对象引用了本区域对象时</p>
</blockquote>
<p>如何变脏?</p>
<blockquote>
<p>在<code>HotSpot</code>虚拟机里是通过<code>写屏障（Write Barrier）</code>技术维护卡表状态的。写屏障可以看作在虚拟机层面对<code>“引用类型字段赋值”</code>这个动作的<code>AOP切面</code></p>
<ul>
<li>在引用对象赋值时会产生一个<code>环形（Around）</code>通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。
<ul>
<li>在赋值前的部分的写屏障叫作<code>写前屏障（Pre-Write Barrier）</code>；</li>
<li>在赋值后的则叫作<code>写后屏障（Post-Write Barrier）</code>。</li>
</ul></li>
</ul>
</blockquote>
<p><strong>“伪共享”（False Sharing）问题</strong></p>
<blockquote>
<p>现代中央处理器的缓存系统中是以<code>缓存行（Cache Line）</code>为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低。</p>
<p>为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏</p>
</blockquote>
<h4 id="并发的可达性分析">3.6 并发的可达性分析</h4>
<p>可达性分析的停顿时间与Java堆容量直接成正比例关系，把遍历对象图过程中遇到的对象，按照<strong>“是否访问过”</strong>这个条件标记成以下三种颜色，演示并发出现<strong>“对象消失”</strong>问题：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Object_disappeared.PNG" alt="并发出现“对象消失”问题" /><figcaption aria-hidden="true">并发出现“对象消失”问题</figcaption>
</figure>
<ul>
<li><strong>白色</strong>：表示对象尚未被垃圾收集器访问过。</li>
<li><strong>黑色</strong>：表示对象已经被垃圾收集器访问过，且这个对象的<u>所有引用都已经扫描过</u>。</li>
<li><strong>灰色</strong>：表示对象已经被垃圾收集器访问过，但这个对象上<u>至少存在一个引用还没有被扫描过</u>。</li>
</ul>
<p>当且仅当以下两个条件同时满足时，会产生“对象消失”的问题：</p>
<blockquote>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
</blockquote>
<p>产生了两种解决方案：</p>
<blockquote>
<ul>
<li><p><code>增量更新（Incremental Update）</code>破坏的是第一个条件。当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</p></li>
<li><p><code>原始快照（Snapshot At The Beginning，SATB）</code>破坏的是第二个条件。当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p></li>
</ul>
</blockquote>
<h3 id="经典垃圾收集器">4. 经典垃圾收集器</h3>
<p>七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Garbage_collector.PNG" alt="HotSpot虚拟机的垃圾收集器" /><figcaption aria-hidden="true">HotSpot虚拟机的垃圾收集器</figcaption>
</figure>
<h4 id="新生代收集器">4.1 新生代收集器</h4>
<h5 id="serial收集器">4.1.1 Serial收集器</h5>
<p><code>Serial收集器</code>是一个单线程工作的收集器，但它的“单线程”的意义是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/serial_collector.PNG" alt="Serial/Serial Old收集器运行示意图" /><figcaption aria-hidden="true">Serial/Serial Old收集器运行示意图</figcaption>
</figure>
<blockquote>
<p>它是所有收集器里<code>额外内存消耗（Memory Footprint）</code>最小的，简单而高效</p>
</blockquote>
<h5 id="parnew收集器">4.1.2 ParNew收集器</h5>
<p><code>ParNew收集器</code>实质上是<code>Serial收集器</code>的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为都与Serial收集器完全一致。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ParNew_collector.PNG" alt="ParNew/Serial Old收集器运行示意图l Old收集器运行示意图" /><figcaption aria-hidden="true">ParNew/Serial Old收集器运行示意图l Old收集器运行示意图</figcaption>
</figure>
<p>在谈论垃圾收集器的上下文语境中，<code>并行和并发</code>可以理解为：</p>
<ul>
<li><code>并行（Parallel）</code>：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态</li>
<li><code>并发（Concurrent）</code>：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。</li>
</ul>
<h5 id="parallel-scavenge收集器">4.1.3 Parallel Scavenge收集器</h5>
<p><code>Parallel Scavenge收集器</code>也是一款<code>新生代收集器</code>，它同样是基于<u>标记-复制算法</u>实现的收集器，也是能够并行收集的多线程收集器。Parallel Scavenge收集器的目标则是达到一个可控制的<code>吞吐量（Throughput）</code>，吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值： <span class="math display">\[
吞吐量 = \frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}
\]</span> 高吞吐量可以最高效率地利用处理器资源，尽快完成程序的运算任务，<em>主要适合在后台运算而不需要太多交互的分析任务</em>。</p>
<blockquote>
<p><code>自适应的调节策略（GC Ergonomics）</code>让虚拟机根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
</blockquote>
<h4 id="老年代收集器">4.2 老年代收集器</h4>
<h5 id="serial-old收集器">4.2.1 Serial Old收集器</h5>
<p><code>Serial Old</code>是Serial收集器的老年代版本，它同样是一个单线程收集器，使用<u>标记-整理算法</u>。</p>
<h5 id="parallel-old收集器">4.2.2 Parallel Old收集器</h5>
<p><code>Parallel Old</code>是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于<u>标记-整理算法</u>实现。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Parallel_Old_collector.PNG" alt="ParNew/Serial Old收集器运行示意图" /><figcaption aria-hidden="true">ParNew/Serial Old收集器运行示意图</figcaption>
</figure>
<blockquote>
<p>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p>
</blockquote>
<h5 id="cms收集器">4.2.3 CMS收集器</h5>
<p><code>CMS（Concurrent Mark Sweep）收集器</code>是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于<u>标记-清除算法</u>实现的，它的运作过程分为四个步骤：</p>
<ol type="1">
<li><code>初始标记（CMS initial mark）</code>。只是标记一下<code>GC Roots</code>能<strong>直接</strong>关联到的对象，速度很快；</li>
<li><code>并发标记（CMS concurrent mark）</code>。从<code>GC Roots</code>的<u>直接关联对象</u>开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</li>
<li><code>重新标记（CMS remark）</code>。修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；</li>
<li><code>并发清除（CMS concurrent sweep）</code>。清理删除掉标记阶段判断的已经死亡的对象。</li>
</ol>
<p>初始标记、重新标记这两个步骤仍然需要<code>“Stop The World”</code>。在整个过程中<em>耗时最长</em>的<code>并发标记</code>和<code>并发清除</code>阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说<code>CMS收集器</code>的内存回收过程是与用户线程一起<strong>并发执行</strong>的。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Concurrent_Mark_Sweep.PNG" alt="Concurrent Mark Sweep收集器运行示意图" /><figcaption aria-hidden="true">Concurrent Mark Sweep收集器运行示意图</figcaption>
</figure>
<blockquote>
<p>优点：并发收集、低停顿。也称之为<code>“并发低停顿收集器”（Concurrent Low Pause Collector）</code>。</p>
<p>缺点：</p>
<ul>
<li>CMS收集器对<code>处理器资源</code>非常敏感。</li>
<li>由于CMS收集器无法处理<code>“浮动垃圾”（Floating Garbage）</code>，有可能出现<code>“Con-current Mode Failure”</code>失败进而导致另一次完全<code>“Stop The World”</code>的<code>Full GC</code>的产生。
<ul>
<li><code>“浮动垃圾”</code>：在CMS的<code>并发标记</code>和<code>并发清理</code>阶段，用户线程运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。</li>
<li><code>“并发失败”（Concurrent Mode Failure）</code>：CMS运行期间预留的内存无法满足程序分配新对象的需要。虚拟机将不得不启动<code>后备预案</code>：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集。</li>
</ul></li>
<li>CMS是一款基于“标记-清除”算法实现的收集器，收集结束时会有大量<code>空间碎片</code>产生。</li>
</ul>
</blockquote>
<h4 id="garbage-first收集器">4.3 Garbage First收集器</h4>
<p><code>Garbage First（简称G1）收集器</code>开创了收集器<code>面向局部收集</code>的设计思路和<code>基于Region的内存布局</code>形式，也被Oracle官方称为<code>“全功能的垃圾收集器”（Fully-Featured Garbage Collector）</code>。</p>
<blockquote>
<p><code>“停顿时间模型”（Pause Prediction Model）</code>是能够支持指定在一个长度为<strong>M毫秒</strong>的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。</p>
</blockquote>
<p><code>G1</code>面向堆内存任何部分来组成<code>回收集（Collection Set，一般简称CSet）</code>进行回收，衡量标准是<u>哪块内存中存放的垃圾数量最多，回收收益最大</u>。这就是G1收集器的<code>Mixed GC模式</code>。</p>
<h5 id="基于region的堆内存布局">4.3.1 基于Region的堆内存布局</h5>
<p>G1不再坚持固定大小以及固定数量的分代区域划分，而是<u>把连续的Java堆划分为多个大小相等的<code>独立区域（Region）</code></u>，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理。</p>
<blockquote>
<p>Region中一类特殊的<code>Humongous区域</code>，专门用来存储大对象。只要大小超过了一个 Region容量一半的对象即可判定为大对象。</p>
</blockquote>
<h5 id="面向局部收集">4.3.2 面向局部收集</h5>
<p>G1中新生代和老年代不再是固定的了，它们都是一系列区域（<strong>不需要连续</strong>）的<code>动态集合</code>。将Region作为单次回收的最小单元，可以有计划地避免<u>在整个Java堆中进行全区域的垃圾收集</u>。G1收集器跟踪各个Region里面的垃圾堆积的“价值”大小：</p>
<blockquote>
<p>价值即回收所获得的空间大小以及回收所需时间的经验值</p>
</blockquote>
<p>在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region。(“Garbage First”名字的由来)</p>
<h5 id="关键的细节问题">4.3.3 关键的细节问题</h5>
<ul>
<li><u>将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？</u>使用记忆集避免全堆作为GC Roots扫描。G1的记忆集在存储结构的<u>本质上是一 种哈希表</u>，<code>Key</code>是别的Region的起始地址，<code>Value</code>是一个集合，里面存储的元素是卡表的索引号。</li>
<li><u>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</u>G1 收集器是通过<code>原始快照（SATB）算法</code>保证用户线程改变对象引用关系时，不能打破原本的对象图结构。此外，G1为每一个Region设计了两个名为<code>TAMS（Top at Mark Start）</code>的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li>
<li><u>怎样建立起可靠的停顿预测模型？</u>G1收集器的停顿预测模型是以<code>衰减均值（Decaying Average）</code>为理论基础来实现的。在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。衰减平均值更准确地代表“最近的”平均状态。</li>
</ul>
<h5 id="关键的细节问题-1">4.3.4 关键的细节问题</h5>
<p>G1收集器的运作过程大致可划分为以下四个步骤：</p>
<ul>
<li><code>初始标记（Initial Marking）</code>。仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象，并且修改<code>TAMS</code>指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。</li>
<li><code>并发标记（Concurrent Marking）</code>。从<code>GC Root</code>开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。当对象图扫描完成以后，还要重新处理<code>原始快照SATB</code>记录下的在并发时有引用变动的对象。</li>
<li><code>最终标记（Final Marking）</code>。对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的<code>SATB记录</code>。</li>
<li><code>筛选回收（Live Data Counting and Evacuation）</code>。负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。
<ul>
<li>这里的操作涉及存活对象的移动，是<strong>必须暂停用户线程</strong>，由多条收集器线程并行完成的。</li>
</ul></li>
</ul>
<p>G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/G1_collector.PNG" alt="G1收集器运行示意图" /><figcaption aria-hidden="true">G1收集器运行示意图</figcaption>
</figure>
<blockquote>
<p>从G1开始，最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的<code>内存分配速率 （Allocation Rate）</code>，应用在分配，同时收集器在收集，只要收集的速度能跟得上对象分配的速度，那一切就能运作得很完美。</p>
</blockquote>
<p>优点：</p>
<ul>
<li>可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集</li>
<li>G1<strong>从整体来看是基于“标记-整理”算法</strong>实现的收集器，但<strong>从局部（两个Region之间）上看又是基于“标记-复制”</strong>算法实现，G1运作期间不会产生内存空间碎片。</li>
</ul>
<p>缺点：</p>
<ul>
<li>G1为了垃圾收集产生的内存占用（Footprint）比CMS要高。G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间；</li>
<li>G1程序运行时的额外执行负载（Overload）比CMS要高。G1除了使用写后屏障来进行卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。</li>
</ul>
<h3 id="低延迟垃圾收集器">5. 低延迟垃圾收集器</h3>
<p>衡量垃圾收集器的三项最重要的指标是：<code>内存占用（Footprint）</code>、<code>吞吐量（Throughput）</code>和<code>延迟 （Latency）</code>。两款目前仍处于实验状态的收集器<code>Shenandoah</code>和<code>ZGC</code>，被官方命名为<code>“低延迟垃圾收集器”（Low-Latency Garbage Collector或者Low-Pause-Time Garbage Collector）</code>。</p>
<h4 id="shenandoah收集器">5.1 Shenandoah收集器</h4>
<p><code>Shenandoah</code>是一款只有<code>OpenJDK</code>才会包含，而<code>OracleJDK</code>里反而不存在的收集器。Shenandoah反而更像是G1的下一代继承者，在管理堆内存方面，它与G1至少有三个明显的不同之处：</p>
<ul>
<li>支持并发的整理算法；</li>
<li>Shenandoah是默认不使用分代收集的；</li>
<li>Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为<code>“连接矩阵”（Connection Matrix）</code>的全局数据结构来记录<em>跨Region的引用关系</em>，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。</li>
</ul>
<p>Shenandoah收集器的工作过程大致可以划分为以下九个阶段：</p>
<ul>
<li><code>初始标记（Initial Marking）</code>。标记与<code>GC Roots</code>直接关联的对象，这个阶段仍是<code>“Stop The World”</code>的。</li>
<li><code>并发标记（Concurrent Marking）</code>。遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的。</li>
<li><code>最终标记（Final Marking）</code>。处理剩余的<code>SATB扫描</code>，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组<code>回收集（Collection Set）</code>。<em>会有一小段短暂的停顿</em>。</li>
<li><code>并发清理（Concurrent Cleanup）</code>。清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为<code>Immediate Garbage Region</code>）。</li>
<li><code>并发回收（Concurrent Evacuation）</code>。Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中，Shenandoah通过读屏障和被称为“<code>Brooks Pointers</code>”的转发指针来解决并发回收阶段遇到的困难。</li>
<li><code>初始引用更新（Initial Update Reference）</code>。把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务。<em>会产生一个非常短暂的停顿</em>。</li>
<li><code>并发引用更新（Concurrent Update Reference）</code>。按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值。<em>与用户线程一起并发的</em>。</li>
<li><code>最终引用更新（Final Update Reference）</code>。修正存在于<code>GC Roots</code>中的引用，这个阶段是Shenandoah的最后一次停顿。</li>
<li><code>并发清理（Concurrent Cleanup）</code>。经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成<code>Immediate Garbage Regions</code>了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</li>
</ul>
<p>三个最重要的并发阶段<strong>（并发标记、并发回收、并发引用更新）</strong>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Shenandoah.PNG" alt="Shenandoah收集器的工作过程" /><figcaption aria-hidden="true">Shenandoah收集器的工作过程</figcaption>
</figure>
<p>黄色的区域代表的是<em>被选入回收集的Region</em>，绿色部分就代表<em>还存活的对象</em>，蓝色就是<em>用户线程可以用来分配对象的内存Region</em>。</p>
<p><code>Brooks Pointer</code>。<code>Brooks</code>提出了使用<code>转发指针</code>（<code>Forwarding Pointer</code>，也常被称为<code>Indirection Pointer</code>）来实现对象移动与用户程序并发的一种解决方案。<code>Brooks</code>在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Brooks_Pointers.PNG" alt="Brooks Pointers示意图" /><figcaption aria-hidden="true">Brooks Pointers示意图</figcaption>
</figure>
<p>转发指针加入后带来的收益是当对象拥有了一份新的副本时，只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Brooks_Pointers2.PNG" alt="Brooks Pointers原理" /><figcaption aria-hidden="true">Brooks Pointers原理</figcaption>
</figure>
<p><strong>Brooks转发指针的多线程竞争问题</strong>：</p>
<ul>
<li>收集器线程与用户线程发生的只是并发读取，那无论读到旧对象还是新对象上的字段，返回的结果都应该是一样的；</li>
<li>如果发生的是并发写入，就一定必须保证<code>写操作</code>只能发生在新复制的对象上。</li>
</ul>
<p>Shenandoah收集器是通过<code>比较并交换（Compare And Swap，CAS）操作</code>来保证并发时对象的访问正确性的。</p>
<h4 id="zgc收集器">5.2 ZGC收集器</h4>
<p><code>ZGC（Z Garbage Collector）</code>是一款在 <code>JDK 11</code>中新加入的具有实验性质的低延迟垃圾收集器。ZGC和Shenandoah的目标是高度相似的，都希望<u>在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</u>。</p>
<h5 id="zgc的内存布局">5.2.1 ZGC的内存布局</h5>
<p>ZGC也采用基于Region的堆内存布局（在一些官方资料中将它称为<code>Page</code>或者<code>ZPage</code>），ZGC的Region具有<strong>动态性</strong>——<u>动态创建和销毁，以及动态的区域容量大小</u>。ZGC的 Region可以有大、中、小三类容量：</p>
<ul>
<li><code>小型Region（Small Region）</code>：容量固定为<code>2MB</code>，用于放置<u>小于</u><code>256KB</code>的小对象。</li>
<li><code>中型Region（Medium Region）</code>：容量固定为<code>32MB</code>，用于放置<u>大于等于</u><code>256KB</code>但<u>小于</u><code>4MB</code>的对象。</li>
<li><code>大型Region（Large Region）</code>：容量不固定，可以动态变化，但必须为<code>2MB</code>的<strong>整数倍</strong>，用于放置<code>4MB</code>或以上的大对象。每个大型Region中只会存放一个大对象，大型Region在ZGC的实现中<strong>不会被重分配</strong>。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ZGC_memory.PNG" alt="ZGC的堆内存布局" /><figcaption aria-hidden="true">ZGC的堆内存布局</figcaption>
</figure>
<h5 id="zgc的并发整理算法">5.2.2 ZGC的并发整理算法</h5>
<p>ZGC收集器采用的<code>染色指针技术</code>（<code>Colored Pointer</code>，其他类似的技术中可能将它称为<code>Tag Pointer</code>或者<code>Version Pointer</code>）。染色指针直接把标记信息记在引用对象的指针上。</p>
<p>在64位系统中，理论可以访问的内存高达<code>16EB</code>（<code>2的64次幂</code>）字节。基于需求 、性能和成本的考虑，在<code>AMD64</code>架构中只支持到<code>52</code>位（<code>4PB</code>）的<u>地址总线</u>和<code>48</code>位（<code>256TB</code>）的<u>虚拟地址空间</u>。</p>
<blockquote>
<p>操作系统也还会施加自己的约束，64位的<code>Linux</code>则分别支持<code>47</code>位（<code>128TB</code>）的进程虚拟地址空间和<code>46</code>位（<code>64TB</code>）的物理地址空间，64位的<code>Windows</code>系统甚至只支持<code>44</code>位（<code>16TB</code>）的物理地址空间。</p>
</blockquote>
<p>Linux下64位指针的高18位不能用来寻址，ZGC的染色指针技术利用这剩下的46位指针宽度，将其<code>高4位</code>提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的<strong>三色标记状态</strong>、<strong>是否进入了重分配集</strong>（即被移动过）、<strong>是否只能通过finalize()方法才能被访问到</strong>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Colored_Pointer.PNG" alt="染色指针" /><figcaption aria-hidden="true">染色指针</figcaption>
</figure>
<blockquote>
<p>这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致ZGC能够管理的内存不可以超过<code>4TB</code></p>
</blockquote>
<p>染色指针的三大优势：</p>
<ul>
<li>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</li>
<li>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。</li>
<li>染色指针可以作为一种<code>可扩展</code>的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li>
</ul>
<h5 id="虚拟内存映射技术">5.2.3 虚拟内存映射技术</h5>
<p>处理器会使用<code>分页管理机制</code>把线性地址空间和物理地址空间分别划分为大小相同的块，这样的内存块被称为<code>“页”（Page）</code>。通过在线性虚拟空间的页与物理地址空间的页之间建立的<code>映射表</code>，分页管理机制会进行线性地址到物理地址空间的映射，完成线性地址到物理地址的转换。</p>
<p><code>Linux/x86-64</code>平台上的ZGC使用了<code>多重映射（Multi-Mapping）</code>将<u>多个不同的虚拟内存地址映射到同一个物理内存地址上</u>，这是一种<strong>多对一映射</strong>，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。把染色指针中的标志位看作是<code>地址的分段符</code>，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Multi_Mapping.PNG" alt="多重映射下的寻址" /><figcaption aria-hidden="true">多重映射下的寻址</figcaption>
</figure>
<h5 id="zgc的运作过程">5.2.4 ZGC的运作过程</h5>
<p>ZGC的运作过程大致可划分为以下四个大的阶段。全部四个阶段<strong><u>都是可以并发执行</u></strong>的，仅是两个阶段中间会存在短暂的停顿小阶段，如初始化<code>GC Root</code>直接关联对象的<code>Mark Start</code>。</p>
<ul>
<li><code>并发标记（Concurrent Mark）</code>：并发标记是<strong>遍历对象图做可达性分析的阶段</strong>，前后也要经过初始标记、最终标记的短暂停顿。ZGC 的标记是在指针上进行的，标记阶段会更新染色指针中的<code>Marked0</code>、<code>Marked1</code>标志位。</li>
<li><code>并发预备重分配（Concurrent Prepare for Relocate）</code>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成<code>重分配集（Relocation Set）</code>。ZGC每次回收都会<strong>扫描所有的Region</strong>，用范围更大的扫描成本换取<u>省去G1中记忆集的维护成本</u>。</li>
<li><code>并发重分配（Concurrent Relocate）</code>：把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<code>转发表（Forward Table）</code>，<u>记录从旧对象到新对象的转向关系</u>。
<ul>
<li>指针的<code>“自愈”（Self-Healing）</code>能力：ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被<code>预置的内存屏障</code>所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象。这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次。</li>
</ul></li>
<li><code>并发重映射（Concurrent Remap）</code>：重映射所做的就是<u>修正整个堆中指向重分配集中旧对象的所有引用</u>，但是ZGC重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。ZGC把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成。</li>
</ul>
<h5 id="numa-aware的内存分配">5.2.5 “NUMA-Aware”的内存分配</h5>
<p>ZGC支持<code>“NUMA-Aware”的内存分配</code>。<code>NUMA</code>（<code>Non-Uniform Memory Access</code>，<strong>非统一内存访问架构</strong>）是一种为多处理器或者多核处理器的计算机所设计的内存架构。在<code>NUMA</code>架构下，ZGC收集器会优先尝试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问。</p>
<h3 id="选择合适的垃圾收集器">6. 选择合适的垃圾收集器</h3>
<h4 id="epsilon收集器">6.1 Epsilon收集器</h4>
<p><code>Epsilon</code>这是一款以<u>不能够进行垃圾收集</u>为“卖点”的垃圾收集器。</p>
<blockquote>
<p>Epsilon收集器由<code>RedHat</code>公司在<code>JEP 318</code>中提出，在此提案里<code>Epsilon</code>被形容成一个<code>无操作的收集器（A No-Op Garbage Collector）</code>。</p>
</blockquote>
<p>一个垃圾收集器除了垃圾收集这个本职工作之外，它还要负责<u>堆的管理与布局</u>、<u>对象的分配</u>、<u>与解释器的协作</u>、<u>与编译器的协作</u>、<u>与监控子系统协作</u>等职责。Epsilon是垃圾收集器的统一接口，用于需要剥离垃圾收集器影响的性能测试和压力测试。</p>
<p>在实际生产环境中，不能进行垃圾收集的Epsilon也用于应对<code>短时间、小规模</code>的服务形式，只要Java虚拟机<u>能正确分配内存，在堆耗尽之前就会退出</u>，那显然运行负载极小、没有任何回收行为的Epsilon便是很恰当的选择。</p>
<h4 id="收集器的权衡">6.2 收集器的权衡</h4>
<p>选择一款适合自己应用的收集器主要受以下三 个因素影响：</p>
<ul>
<li><code>应用程序的主要关注点是什么？</code>
<ul>
<li>如果是数据分析、科学计算类的任务，目标是能尽快算出结果， 那吞吐量就是主要关注点；</li>
<li>如果是<code>SLA（（Service Level Agreements））</code>应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点；</li>
<li>而如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的。</li>
</ul></li>
<li><code>运行应用的基础设施如何？</code>
<ul>
<li>譬如硬件规格，要涉及的系统架构；</li>
<li>处理器的数量多少，分配内存的大小；</li>
<li>选择的操作系统。</li>
</ul></li>
<li>使用JDK的发行商是什么？版本号是多少？是ZingJDK/Zulu、OracleJDK、Open-JDK、OpenJ9抑或是其他公司的发行版？该JDK对应了《Java虚拟机规范》的哪个版本？</li>
</ul>
<p>实战中切不可纸上谈兵，<strong>根据系统实际情况去测试才是选择收集器的最终依据</strong>。</p>
<h4 id="虚拟机及垃圾收集器日志">6.3 虚拟机及垃圾收集器日志</h4>
<p><code>JDK 9</code>后，<code>HotSpot</code>所有功能的日志都收归到了<code>“-Xlog”</code>参数上，这个参数的能力也相应被极大拓展：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xlog[:[selector][:[output][:[decorators][:output-options]]]]</span><br></pre></td></tr></table></figure>
<p>最关键的参数是<code>选择器（Selector）</code>，它由<code>标签（Tag）</code>和<code>日志级别（Level）</code>共同组成。</p>
<p>日志级别从低到高，共有<code>Trace，Debug，Info，Warning，Error，Off</code>六种级别，默认级别为<code>Info</code>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Log_parameter.PNG" alt="JDK 9前后日志参数变化" /><figcaption aria-hidden="true">JDK 9前后日志参数变化</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/Log_parameter2.PNG" alt="JDK 9前后日志参数变化(续)" /><figcaption aria-hidden="true">JDK 9前后日志参数变化(续)</figcaption>
</figure>
<h4 id="垃圾收集器参数总结">6.4 垃圾收集器参数总结</h4>
<p>具体可以查看书籍，主要还是用到的时候查一下就行。</p>
<h3 id="内存分配与回收策略">7. 内存分配与回收策略</h3>
<p>Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：<u><strong>自动给对象分配内存</strong></u>以及<u><strong>自动回收分配给对象的内存</strong></u>。对象的内存分配，从概念上讲，应该都是在堆上分配（而实际上也有可能经过<code>即时编译</code>后被拆散为标量类型并间接地在栈上分配）。</p>
<h4 id="对象优先在eden分配">7.1 对象优先在Eden分配</h4>
<p>对象在新生代<code>Eden区</code>中分配。当<code>Eden区</code>没有足够空间进行分配时，虚拟机将发起 一次<code>Minor GC</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">	allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">	allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">	allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">	allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">// 出现一次Minor GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>testAllocation()</code>中分配<code>allocation4</code>对象的语句时会发生一次<code>Minor GC</code>，产生这次垃圾收集的原因是为<code>allocation4</code>分配内存时，发现 <code>Eden</code>已经被占用了<code>6MB</code>，剩余空间已不足以分配<code>allocation4</code>所需的<code>4MB</code>内存，因此发生<code>Minor GC</code>。</p>
<p>垃圾收集期间虚拟机又发现已有的三个<code>2MB</code>大小的对象全部无法放入<code>Survivor</code>空间（<strong>Survivor空间只有 1MB大小</strong>），所以只好通过分配担保机制提前转移到老年代去。</p>
<p>收集结束后，<code>4MB</code>的<code>allocation4</code>对象顺利分配在<code>Eden</code>中。因此程序执行完的结果是<code>Eden</code>占用 <code>4MB</code>（被<code>allocation4</code>占用），<code>Survivor</code>空闲，老年代被占用<code>6MB</code>（被<code>allocation1、2、3</code>占用）。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testAllocation.PNG" alt="testAllocation运行结果" /><figcaption aria-hidden="true">testAllocation运行结果</figcaption>
</figure>
<h4 id="大对象直接进入老年代">7.2 大对象直接进入老年代</h4>
<p>最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。</p>
<blockquote>
<p>在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">* -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] allocation;</span><br><span class="line">	allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">//直接分配在老年代中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Eden空间几乎没有被使用，而老年代的<code>10MB</code>空间被使用了40%，也就是<code>4MB</code>的allocation对象<strong>直接就分配在老年代中</strong></p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/testPretenureSizeThreshold.PNG" alt="testPretenureSizeThreshold运行结果" /><figcaption aria-hidden="true">testPretenureSizeThreshold运行结果</figcaption>
</figure>
<h4 id="长期存活的对象将进入老年代">7.3 长期存活的对象将进入老年代</h4>
<p>虚拟机给每个对象定义了一个<code>对象年龄（Age）计数器</code>，存储在对象头中。</p>
<p>对象通常在<code>Eden区</code>里诞生，如果经过第一次 <code>Minor GC</code>后仍然存活，并且能被<code>Survivor</code>容纳的话，该对象会被移动到<code>Survivor</code>空间中，并且将其对象年龄设为<code>1岁</code>。对象在<code>Survivor</code>区中每熬过一次<code>Minor GC</code>，年龄就增加<code>1岁</code>，当它的年龄增加到一定程度（默认为15），就会<strong>被晋升到老年代中</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment">* -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">	allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>]; <span class="comment">// 什么时候进入老年代决定于XX:MaxTenuringThreshold设置</span></span><br><span class="line">	allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">	allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">	allocation3 = <span class="keyword">null</span>;</span><br><span class="line">	allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当<code>-XX：MaxTenuringThreshold=1</code>时，<code>allocation1</code>对象在第二次<code>GC</code>发生时进入老年代， 新生代已使用的内存在垃圾收集以后非常干净地变成<code>0KB</code>。</li>
<li>当<code>-XX：MaxTenuringThreshold=15</code>时， 第二次<code>GC</code>发生后，<code>allocation1</code>对象则还留在新生代<code>Survivor</code>空间，这时候新生代仍然有<code>404KB</code>被占用。</li>
</ul>
<h4 id="动态对象年龄判定">7.4 动态对象年龄判定</h4>
<p>如果在<code>Survivor</code>空间中相同年龄所有对象大小的总和大于<code>Survivor</code>空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p>
<h4 id="空间分配担保">7.5 空间分配担保</h4>
<p>在发生<code>Minor GC</code>之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间：</p>
<ul>
<li>如果这个条件成立，那这一次<code>Minor GC</code>可以确保是安全的；</li>
<li>如果不成立，会查看是否允许担保失败（Handle Promotion Failure）：
<ul>
<li>如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次<code>Minor GC</code>，尽管这次<code>Minor GC</code>是有风险的；</li>
<li>如果小于，或设置不允许冒险，那这时就要改为进行一次<code>Full GC</code>。</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--10. Regular Expression Matching</title>
    <url>/2019/04/07/LeetCode--10-Regular-Expression-Matching.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given an input string (s) and a pattern (p), implement regular expression matching with support for <strong>'.'</strong> and **'*'**. <a id="more"></a> - '.' Matches any single character. - '*' Matches zero or more of the preceding element.</p>
</blockquote>
<blockquote>
<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>
</blockquote>
<p><strong>Note :</strong> &gt; - s could be empty and contains only lowercase letters a-z. &gt; - p could be empty and contains only lowercase letters a-z, and characters like . or *.</p>
<p><strong>Example 1:</strong> &gt;Input: &gt;s = "aa" &gt;p = "a" &gt;Output: false &gt;Explanation: "a" does not match the entire string "aa".</p>
<p><strong>Example 2:</strong> &gt;Input: &gt;s = "aa" &gt;p = "a*" &gt;Output: true &gt;Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".</p>
<p><strong>Example 3:</strong> &gt;Input: &gt;s = "ab" &gt;p = ".*" &gt;Output: true &gt;Explanation: ".*" means "zero or more (*) of any character (.)".</p>
<p><strong>Example 4:</strong> &gt;Input: &gt;s = "aab" &gt;p = "c*a*b" &gt;Output: true &gt;Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".</p>
<p><strong>Example 5:</strong> &gt;Input: &gt;s = "mississippi" &gt;p = "mis*is*p*." &gt;Output: false</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题主要是看了题目的题解后才解出来的，这里就主要对这道题总结一下。一种直观的方法是 使用递归求解，我们发现在进行匹配时有如下考虑： &gt;1. 如果没有"*"，那么我们可以简单的从左到右逐个字符比较，判断是否匹配； &gt;2. 如果有"*"，我们需要检查各种可能的情况，观察是否存在一种匹配的扩展方式。</p>
<p>所以可以看出递归是一种简单直观的实现方式。如果存在"*"，那么它必定出现在一个字符后面。我们要么忽略这段表达式(即假设它重复0次)，要么从字符串S中后移一位(即假设它重复至少1次)。在匹配完所有情况后，若有匹配成功的情况，那么就匹配成功了。</p>
<p>这种方法尽管简单，但是效率不高。一种优化的解法是，我们将中间结果保存起来，不使用递归。这样可以省略大量的计算。这种方法也就是DP算法，定义DP[i][j]如下：若S[0:i]与P[0:j]匹配，那么DP[i][j]值为真；否者，值为假。</p>
<blockquote>
<ol type="1">
<li>dp[i][j] = dp[i - 1][j - 1], if p[j - 1] != '*' &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.');</li>
<li>dp[i][j] = dp[i][j - 2], if p[j - 1] == '*' 且表达式重复0次;</li>
<li>dp[i][j] = dp[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == '.'), if p[j - 1] == '*' 且表达式重复至少1次.</li>
</ol>
</blockquote>
<p><strong>参考文献：</strong><a href="https://leetcode.com/problems/regular-expression-matching/discuss/5684/9-lines-16ms-c-dp-solutions-with-explanations" target="_blank" rel="noopener" title="C++ O(n)-space DP">C++ O(n)-space DP</a></p>
<h3 id="三代码">三、代码</h3>
<h4 id="递归算法">递归算法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.empty()) <span class="keyword">return</span> s.empty();</span><br><span class="line">        <span class="keyword">bool</span> first_match = (!s.empty() &amp;&amp; (p[<span class="number">0</span>] == s[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p.length() &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p.substr(<span class="number">2</span>)) || (first_match &amp;&amp; isMatch(s.substr(<span class="number">1</span>),p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; isMatch(s.substr(<span class="number">1</span>),p.substr(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="dp算法">DP算法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length(),plen=p.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(slen+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(plen+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= slen; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">'*'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-2</span>] || (i &amp;&amp; dp[i<span class="number">-1</span>][j] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">'.'</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = i &amp;&amp; dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">'.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法三-bottom-up-variation">解法三 (Bottom-Up Variation)</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.length()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(p.length()+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        dp[s.length()][p.length()] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length();i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = p.length()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> first_match = (i&lt; s.length() &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'.'</span>));</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span> &lt; p.length() &amp;&amp; p[j+<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">2</span>] || first_match &amp;&amp; dp[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = first_match &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--7 虚拟机类加载机制</title>
    <url>/2021/05/27/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_7_Virtual_machine_class_loading_mechanism.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>在Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。 <a id="more"></a></p>
</blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的<code>类加载机制</code>。</p>
<h3 id="类加载的时机">1. 类加载的时机</h3>
<p>一个类型<strong><u>从被加载到虚拟机内存中开始，到卸载出内存为止</u></strong>，它的整个生命周期将会经历七个阶段:</p>
<ul>
<li>加载（Loading）</li>
<li>验证（Verification）</li>
<li>准备（Preparation）</li>
<li>解析（Resolution）</li>
<li>初始化 （Initialization）</li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<p>其中验证、准备、解析三个部分统称为连接（Linking）。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ClassLifeCycle.PNG" alt="类的生命周期" /><figcaption aria-hidden="true">类的生命周期</figcaption>
</figure>
<blockquote>
<p>解析阶在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的<code>运行时绑定</code>特性（也称为<code>动态绑定</code>或<code>晚期绑定</code>）。</p>
</blockquote>
<p>只有六种情况必须立即对类进行<code>“初始化”</code>（而加载、验证、准备自然需要在此之前开始）：</p>
<ul>
<li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段；</li>
<li>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化；</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；
<ul>
<li>一个<code>接口</code>在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li>
</ul></li>
<li>当虚拟机启动时，用户需要指定一个要执行的<code>主类（包含main()方法的那个类）</code>，虚拟机会先初始化这个主类；</li>
<li>当使用<code>JDK 7</code>新加入的<code>动态语言支持</code>时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析的方法句柄对应的类没有进行过初始化，则需要先触发其初始化；</li>
<li>当一个接口中定义了<code>JDK 8</code>新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化；</li>
</ul>
<h3 id="类加载的过程">2. 类加载的过程</h3>
<h4 id="加载">2.1 加载</h4>
<p><code>“加载”（Loading）</code>阶段是整个<code>“类加载”（Class Loading）</code>过程中的一个阶段，在加载阶段，Java虚拟机需要完成以下三件事情：</p>
<ol type="1">
<li>通过一个类的全限定名来获取定义此类的<code>二进制字节流</code>。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的<code>findClass()</code>或<code>loadClass()</code>方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p>
<h4 id="验证">2.2 验证</h4>
<p>验证是连接阶段的第一步，这一阶段的目的是<u>确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</u>。从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节 码验证和符号引用验证。</p>
<h5 id="文件格式验证">2.2.1 文件格式验证</h5>
<p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p>
<p>该验证阶段的主要目的是<u><strong>保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。</strong></u>这阶段的验证是<strong>基于二进制字节流进行的</strong>，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储。</p>
<h5 id="元数据验证">2.2.2 元数据验证</h5>
<p>对字节码描述的信息进行<code>语义分析</code>，以保证其描述的信息符合《Java语言规范》的要求。</p>
<h5 id="字节码验证">2.2.3 字节码验证</h5>
<p>通过<code>数据流分析</code>和<code>控制流分析</code>，确定程序语义是合法的、符合逻辑的。</p>
<p>这阶段对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。</p>
<h5 id="符号引用验证">2.2.4 符号引用验证</h5>
<p>符号引用验证可以看作是<strong><u>对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验</u></strong>，即该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p>
<p>该校验过程发生在虚拟机<u>将符号引用转化为直接引用</u>的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</p>
<h4 id="准备">2.3 准备</h4>
<p>准备阶段是正式<u><strong>为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值</strong></u>的阶段。</p>
<p>两个容易产生混淆的概念：</p>
<ul>
<li>此时进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</li>
<li>这里所说的初始值“通常情况”下是<code>数据类型的零值</code>。
<ul>
<li>比如对于<code>public static int value = 123;</code>，变量value在准备阶段过后的初始值为0，把 <code>value</code>赋值为<code>123</code>的<code>putstatic</code>指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中，所以把<code>value</code>赋值为<code>123</code>的动作要到<strong>类的初始化阶段</strong>才会被执行。</li>
<li>如果类字段的字段属性表中存在<code>ConstantValue</code>属性，那在准备阶段变量值就会被初始化为<code>ConstantValue</code>属性所指定的初始值(比如<code>public static final int value = 123;</code>)</li>
</ul></li>
</ul>
<h4 id="解析">2.4 解析</h4>
<p>解析阶段是Java虚拟机<strong>将常量池内的符号引用替换为直接引用</strong>的过程。</p>
<ul>
<li><code>符号引用（Symbolic References）</code>：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的<strong>字面量</strong>，只要使用时能无歧义地定位到目标即可。
<ul>
<li>符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。</li>
</ul></li>
<li><code>直接引用（Direct References）</code>：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。
<ul>
<li>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</li>
<li>如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li>
</ul></li>
</ul>
<p>虚拟机实现可以对第一次解析的结果进行缓存(除<code>invokedynamic</code>指令以外)，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。无论是否真正执行了多次解析动作，Java虚拟机都需要保证的是在同一个实体中：</p>
<ul>
<li>如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功；</li>
<li>如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功加载进Java虚拟机内存之中。</li>
</ul>
<p>对于<code>invokedynamic</code>指令，上面的规则就不成立了。当碰到某个前面已经由<code>invokedynamic</code>指令触发过解析的符号引用时，并不意味着这个解析结果对于其他<code>invokedynamic</code>指令也同样生效。</p>
<ul>
<li><code>invokedynamic</code>指令的目的本来就是用于动态语言支持，它对应的引用称为<code>“动态调用点限定符 （Dynamically-Computed Call Site Specifier）”</code>，这里<code>“动态”</code>的含义是指<u><strong>必须等到程序实际运行到这条指令时，解析动作才能进行</strong></u>。</li>
</ul>
<p>解析动作主要针对<u><strong>类或接口</strong></u>、<u><strong>字段</strong></u>、<u><strong>类方法</strong></u>、<u><strong>接口方法</strong></u>、<u><strong>方法类型</strong></u>、<u><strong>方法句柄</strong></u>和<u><strong>调用点限定符</strong></u>这7类符号引用进行。</p>
<h5 id="类或接口的解析">2.4.1 类或接口的解析</h5>
<p>假设当前代码所处的类为<code>D</code>，如果要把一个从未解析过的符号引用<code>N</code>解析为一个类或接口<code>C</code>的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p>
<ol type="1">
<li>如果<code>C</code>不是一个数组类型，那虚拟机将会把代表<code>N</code>的全限定名传递给<code>D</code>的类加载器去加载这个类<code>C</code>。</li>
<li>如果<code>C</code>是一个数组类型，并且数组的元素类型为对象，也就是<code>N</code>的描述符会是类似“<code>[Ljava/lang/Integer</code>”的形式，那将会按照第一点的规则加载数组元素类型。</li>
<li>如果上面两步没有出现任何异常，那么<code>C</code>在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认<code>D</code>是否具备对<code>C</code>的访问权限。如果发现不具备访问权限， 将抛出<code>java.lang.IllegalAccessError</code>异常。</li>
</ol>
<p>如果我们说一个<code>D</code>拥有<code>C</code>的访问权限，那就意味着以下3条规则中至少有其中一条成立：</p>
<ul>
<li>被访问类<code>C</code>是<code>public</code>的，并且与访问类<code>D</code>处于同一个模块。</li>
<li>被访问类<code>C</code>是<code>public</code>的，不与访问类<code>D</code>处于同一个模块，但是<code>被访问类C</code>的模块允许<code>访问类D</code>的模块进行访问。</li>
<li>被访问类<code>C</code>不是<code>public</code>的，但是它与访问类<code>D</code>处于同一个包中。</li>
</ul>
<h5 id="字段解析">2.4.2 字段解析</h5>
<p>要解析一个未被解析过的字段符号引用，首先将会对字段表内<code>class_index</code>项中索引的<code>CONSTANT_Class_info</code>符号引用进行解析，也就是<strong><u>字段所属的类或接口的符号引用</u></strong>。</p>
<p>如果解析成功完成，那把这个字段所属的类或接口用<code>C</code>表示，按照如下步骤对C进行后续字段的搜索：</p>
<ol type="1">
<li>如果<code>C</code>本身就包含了<strong>简单名称</strong>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>如果在<code>C</code>中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口， 如果接口中包含了<strong>简单名称</strong>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>如果<code>C</code>不是<code>java.lang.Object</code>的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了<code>简单名称</code>，<strong>字段描述符</strong>都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出<code>java.lang.NoSuchFieldError</code>异常。</li>
</ol>
<p>如果查找过程成功返回了引用，将会对这个字段进行权限验证。</p>
<h5 id="方法解析">2.4.3 方法解析</h5>
<p>方法解析的第一个步骤也是需要先解析出方法表的<code>class_index</code>项中索引的方法所属的类或接口的符号引用，如果解析成功，那么依然用<code>C</code>表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：</p>
<ol type="1">
<li>由于Class文件格式中<strong><u>类的方法和接口的方法符号引用的常量类型定义是分开的</u></strong>，如果在类的方法表中发现<code>class_index</code>中索引的<code>C</code>是个接口的话，那就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li>
<li>在类<code>C</code>中查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>在类<code>C</code>的父类中递归查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>在类<code>C</code>实现的接口列表及它们的父接口之中递归查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果存在匹配的方法，说明类<code>C</code>是一个抽象类，这时候查找结束，抛出<code>java.lang.AbstractMethodError</code>异常。</li>
<li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>。</li>
</ol>
<p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证。</p>
<h5 id="接口方法解析">2.4.4 接口方法解析</h5>
<p>接口方法也是需要先解析出接口方法表的<code>class_index</code>项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用<code>C</code>表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p>
<ol type="1">
<li>与类的方法解析相反，如果在接口方法表中发现<code>class_index</code>中的索引<code>C</code>是个类而不是接口，那么就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li>
<li>在接口<code>C</code>中查找是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>在接口<code>C</code>的父接口中递归查找，直到<code>java.lang.Object</code>类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有<strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
<ul>
<li>由于Java的<u>接口允许多重继承</u>，如果C的不同父接口中存有<u>多个</u><strong>简单名称</strong>，<strong>描述符</strong>都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，不同发行商实现的<code>Javac</code>编译器有可能会按照<u><strong>更严格的约束拒绝编译这种代码来避免不确定性</strong></u>。</li>
</ul></li>
<li>否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</li>
</ol>
<blockquote>
<ul>
<li>在<code>JDK 9</code>之前，Java接口中的所有方法都<u>默认是<code>public</code>的</u>，也没有模块化的访问约束，所以不存在访问权限的问题。</li>
<li>但在<code>JDK 9</code>中增加了<u>接口的静态私有方法</u>，也有了模块化的访问约束，所以接口方法的访问也完全有可能因访问权限控制而出现<code>java.lang.IllegalAccessError</code>异常。</li>
</ul>
</blockquote>
<h4 id="初始化">2.5 初始化</h4>
<blockquote>
<p>直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p>
</blockquote>
<p>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<blockquote>
<p><code>&lt;clinit&gt;()</code>并不是程序员在Java代码中直接编写的方法，它是<code>Javac</code>编译器的自动生成物。</p>
</blockquote>
<p><code>&lt;clinit&gt;()</code>方法是由编译器<u>自动收集</u>类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块（static{}块）中的语句</strong>合并产生的。</p>
<ul>
<li><code>&lt;clinit&gt;()</code>方法不需要显式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。意味着父类中定义的静态语句块要优先于子类的变量赋值操作；</li>
<li><code>&lt;clinit&gt;()</code>方法不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法</li>
<li>执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，接口的<strong><u>实现类</u></strong>在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法；</li>
<li>Java虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法方法在多线程环境中被正确地加锁同步。</li>
<li>同一个类加载器下，一个类型只会被初始化一次。</li>
</ul>
<h3 id="类加载器">3. 类加载器</h3>
<p>实现<code>“通过一个类的全限定名来获取描述该类的二进制字节流”</code>这个动作的代码被称为<code>“类加载器”（Class Loader）</code>。</p>
<h4 id="类与类加载器">3.1 类与类加载器</h4>
<p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的<strong><u>唯一性</u></strong>，每一个类加载器都拥有一个独立的类名称空间。</p>
<blockquote>
<p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，只要加载它们的类加载器不同，那这两个类就<strong>必定不相等</strong>。</p>
</blockquote>
<h4 id="双亲委派模型">3.2 双亲委派模型</h4>
<p>Java虚拟机的角度来看，只存在两种不同的类加载器：</p>
<ul>
<li><code>启动类加载器（Bootstrap ClassLoader）</code>，这个类加载器是虚拟机自身的一部分；</li>
<li>其他所有的类加载器，这些类加载器都由Java语言实现，<strong><u>独立存在于虚拟机外部</u></strong>，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。</li>
</ul>
<p>Java开发人员的角度来看，类加载器是<code>三层类加载器</code>、<code>双亲委派</code>的类加载架构：</p>
<ul>
<li><code>启动类加载器（Bootstrap Class Loader）</code>：负责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用；</li>
<li><code>扩展类加载器（Extension Class Loader）</code>：负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库。这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoader</code>中以Java代码的形式实现的。</li>
<li><code>应用程序类加载器（Application Class Loader）</code>：负责加载用户类路径<code>（ClassPath）</code>上所有的类库，由 <code>sun.misc.Launcher$AppClassLoader</code>来实现。</li>
</ul>
<p><u><code>JDK 9</code>之前</u>的Java应用都是由这三种类加载器互相配合来完成加载的，用户可以加入自定义的类加载器来进行拓展，如：</p>
<ul>
<li>增加除了磁盘位置之外的Class文件来源</li>
<li>通过类加载器实现类的隔离、重载等功能。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ParentsDelegation.PNG" alt="双亲委派模型" /><figcaption aria-hidden="true">双亲委派模型</figcaption>
</figure>
<p><code>“双亲委派模型（Parents Delegation Model）”</code>要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
<blockquote>
<p>类加载器之间的父子关系一般不是以<code>继承（Inheritance）</code>来实现的，而是通常使用<code>组合（Composition）</code>关系来复用父加载器的代码。</p>
</blockquote>
<p>双亲委派模型的工作过程是：</p>
<ul>
<li>如果一个类加载器收到了类加载的请求，首先把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中；</li>
<li>只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</li>
</ul>
<h4 id="破坏双亲委派模型">3.3 破坏双亲委派模型</h4>
<p>直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况：</p>
<ul>
<li>第一次“被破坏”其实发生在双亲委派模型出现之前——即<code>JDK 1.2</code>面世以前。</li>
<li>第二次“被破坏”是由这个模型自身的缺陷导致的，有基础类型要调用回用户的代码。</li>
<li>第三次“被破坏”是由于用户对程序动态性的追求而导致的。</li>
</ul>
<p><code>OSGi</code>实现模块化热部署的关键是<u><strong>它自定义的类加载器机制的实现</strong></u>：</p>
<ul>
<li>每一个程序模块（<code>OSGi</code>中称为<code>Bundle</code>）都有一个自己的类加载器，当需要更换一个<code>Bundle</code>时，就把<code>Bundle</code>连同类加载器一起换掉以实现代码的热替换。</li>
</ul>
<p>在<code>OSGi</code>环境下，类加载器发展为更加复杂的网状结构，当收到类加载请求时，<code>OSGi</code>将按照下面的顺序进行类搜索：</p>
<ol type="1">
<li>将以<code>java.*</code>开头的类，委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类，委派给父类加载器加载。</li>
<li>否则，将<code>Import</code>列表中的类，委派给<code>Export</code>这个类的<code>Bundle</code>的类加载器加载。</li>
<li>否则，查找当前<code>Bundle</code>的<code>ClassPath</code>，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的<code>Fragment Bundle</code>中，如果在，则委派给<code>Fragment Bundle</code>的类加载器加载。</li>
<li>否则，查找<code>Dynamic Import</code>列表的<code>Bundle</code>，委派给对应<code>Bundle</code>的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
<h3 id="java模块化系统">4. Java模块化系统</h3>
<p><code>JDK 9</code>中引入的<code>Java模块化系统（Java Platform Module System，JPMS）</code>能够实现模块化的关键目标——可配置的封装隔离机制。<code>JDK 9</code>的模块除了简单地充当代码的容器，还包含以下内容：</p>
<ul>
<li>依赖其他模块的列表。</li>
<li>导出的包列表，即其他模块可以使用的列表。</li>
<li>开放的包列表，即其他模块可反射访问模块的列表。</li>
<li>使用的服务列表。</li>
<li>提供服务的实现列表。</li>
</ul>
<p><u><strong>可配置的封装隔离机制</strong></u>解决了：</p>
<ul>
<li><code>JDK 9</code>之前基于<code>类路径（ClassPath）</code>来查找依赖的<strong>可靠性问题</strong>。</li>
<li>原来类路径上跨<code>JAR</code>文件的<code>public</code>类型的<strong>可访问性问题</strong>。</li>
</ul>
<h4 id="模块的兼容性">4.1 模块的兼容性</h4>
<p><code>JDK 9</code>提出了与<code>“类路径”（ClassPath）</code>相对应的<code>“模块路径”（ModulePath）</code>的概念，使<u><strong>可配置的封装隔离机制</strong></u>能够兼容传统的类路径查找机制。</p>
<p>模块化系统将按照以下规则来保证使用传统类路径依赖的Java程序可以不经修改地直接运行在<code>JDK 9</code>及以后的Java版本上：</p>
<ul>
<li><strong>JAR文件在类路径的访问规则</strong>：所有类路径下的<code>JAR</code>文件及其他资源文件，都被视为自动打包在一个<code>匿名模块（Unnamed Module）</code>里，这个匿名模块<strong>几乎是没有任何隔离的</strong>，它可以看到和使用<u>类路径上所有的包</u>、<u>JDK系统模块中所有的导出包</u>，以及<u>模块路径上所有模块中导出的包</u>。</li>
<li><strong>模块在模块路径的访问规则</strong>：模块路径下的<code>具名模块（Named Module）</code>只能访问到它<u>依赖定义中列明依赖的模块和包</u>，匿名模块里所有的内容对具名模块来说都是不可见的，即<strong><u>具名模块看不见传统JAR包的内容</u></strong>。</li>
<li><strong>JAR文件在模块路径的访问规则</strong>：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个<code>自动模块（Automatic Module）</code>。尽管不包含<code>module-info.class</code>，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到<u>所有模块导出的</u>包，自动模块也<strong>默认导出自己所有的包</strong>。</li>
</ul>
<h4 id="模块化下的类加载器">4.2 模块化下的类加载器</h4>
<p><code>JDK 9</code>为了模块化系统的顺利施行，模块化下的类加载器发生了一些变动，主要包括以下几个方面：</p>
<ul>
<li><code>扩展类加载器（Extension Class Loader）</code>被<code>平台类加载器（Platform Class Loader）</code>取代。</li>
<li><code>平台类加载器</code>和<code>应用程序类加载器</code>都不再派生自<code>java.net.URLClassLoader</code>，现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 <code>jdk.internal.loader.BuiltinClassLoader</code>。<code>BuiltinClassLoader</code>中实现了新的模块化架构下<u>类如何从模块中加载的逻辑</u>，以及<u>模块中资源可访问性的处理</u>。</li>
<li><code>JDK 9</code>中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。
<ul>
<li>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类<u>是否能够归属到某一个系统模块中</u>，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>
</ul></li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JDK9ClassLoaderDelegation.PNG" alt="JDK 9后的类加载器委派关系" /><figcaption aria-hidden="true">JDK 9后的类加载器委派关系</figcaption>
</figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--6 类文件结构</title>
    <url>/2021/05/26/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_6_Class_file_structure.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</code> <a id="more"></a></p>
</blockquote>
<h3 id="无关性的基石">1. 无关性的基石</h3>
<p>各种不同平台的Java虚拟机，以及所有平台都统一支持的<u>程序存储格式</u>——<code>字节码（Byte Code）</code>是构成平台无关性的基石。Java虚拟机<strong>不与包括Java语言在内的任何程序语言绑定，它只与<code>“Class文件”</code>这种特定的二进制文件格式所关联</strong>，<code>Class文件</code>中包含了<code>Java虚拟机指令集</code>、<code>符号表</code>以及<code>若干其他辅助信息</code>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/JVMLanguageIndependence.PNG" alt="Java虚拟机的语言无关性" /><figcaption aria-hidden="true">Java虚拟机的语言无关性</figcaption>
</figure>
<p>Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，这决定了<u>字节码指令所能提供的语言描述能力比Java语言本身更加强大</u>。</p>
<h3 id="class类文件的结构">2. Class类文件的结构</h3>
<p><code>Class文件</code>是一组以<code>8</code>个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，<strong>中间没有添加任何分隔符</strong>，这使得<u>整个Class文件中存储的内容几乎全部是程序运行的必要数据</u>，没有空隙存在。遇到需要占用8个字节以上空间的数据项时，则会<strong><code>按照高位在前的方式分割</code></strong>成若干个8个字节进行存储。</p>
<blockquote>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息。反过来说，<strong>类或接口并不一定都得定义在文件里</strong>（譬如类或接口也可以动态生成，直接送入类加载器中）。</p>
</blockquote>
<p>Class文件格式采用一种类似于C语言结构体的<code>伪结构</code>来存储数据，这种伪结构中只有两种数据类型：<code>“无符号数”</code>和<code>“表”</code>。</p>
<ul>
<li><code>无符号数</code>属于<u><strong>基本的数据类型</strong></u>，以<code>u1</code>、<code>u2</code>、<code>u4</code>、<code>u8</code>来分别代表1个字节、2个字节、4个字节和8个 字节的无符号数，可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li><code>表</code>是<u><strong>由多个无符号数或者其他表作为数据项构成的复合数据类型</strong></u>，所有表的命名都习惯性地以<code>“_info”</code>结尾。表用于描述有层次关系的复合结构的数据，<strong><code>整个Class文件本质上也可以视作是一张表</code></strong>。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ClassFileStructure.PNG" alt="Class文件格式" /><figcaption aria-hidden="true">Class文件格式</figcaption>
</figure>
<h4 id="魔数与class文件的版本">2.1 魔数与Class文件的版本</h4>
<p>每个Class文件的头4个字节被称为<code>魔数（Magic Number）</code>，它的<strong>唯一作用</strong>是<u><strong>确定这个文件是否为一个能被虚拟机接受的Class文件</strong></u>。</p>
<blockquote>
<p>Class文件的魔数取得很有“浪漫气息”，值为<code>0xCAFEBABE</code>(咖啡宝贝?)</p>
</blockquote>
<p>第5和第6个字节是<code>次版本号（Minor Version）</code>，第7和第8个字节是<code>主版本号（Major Version）</code>。</p>
<blockquote>
<p>Java的版本号是从45开始的。在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p>
</blockquote>
<h4 id="常量池">2.2 常量池</h4>
<p>常量池可以比喻为<code>Class</code>文件里的资源仓库，通常也是占用<code>Class</code>文件空间最大的数据项目之一，它还是在Class文件中第一个出现的<code>表类型数据项目</code>。</p>
<p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项<code>u2</code>类型的数据，代表<code>常量池容量计数值（constant_pool_count）</code>。</p>
<blockquote>
<p>Class文件结构中只有常量池的容量计数是<strong>从1开始</strong>。将第0项常量空出来目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达<strong>“不引用任何一个常量池项目”</strong>的含义，可以把索引值设置为0来表示。</p>
</blockquote>
<p>常量池中主要存放两大类常量：<code>字面量（Literal）</code>和<code>符号引用（Symbolic References）</code>。</p>
<ul>
<li>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等；</li>
<li>符号引用则属于编译原理方面的概念，主要包括下面几类常量：
<ul>
<li>被模块导出或者开放的包（Package）；</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul></li>
</ul>
<p>常量池中每一项常量都是一个表。这类表都有一个共同的特点，表结构起始的第一位是个<code>u1</code>类型的标志位（<code>tag</code>），代表着当前常量属于哪种常量类型。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ItemTypeOfConstantPool.PNG" alt="常量池的项目类型" /><figcaption aria-hidden="true">常量池的项目类型</figcaption>
</figure>
<blockquote>
<p>可以使用用于分析Class文件字节码的工具：<code>javap</code>，输出的<code>TestClass.class</code>文件字节码内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javap -verbose TestClass</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="访问标志">2.3 访问标志</h4>
<p><code>访问标志（access_flags）</code>，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；等等。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/accessFlags.PNG" alt="访问标志" /><figcaption aria-hidden="true">访问标志</figcaption>
</figure>
<p>举例：TestClass是一个普通Java类，它的<code>ACC_PUBLIC</code>、<code>ACC_SUPER</code>标志应当为真，其他为假，因此它的<code>access_flags</code>的值应为：<code>0x0001|0x0020=0x0021</code>。</p>
<h4 id="类索引父类索引与接口索引集合">2.4 类索引、父类索引与接口索引集合</h4>
<p><code>类索引（this_class）</code>和<code>父类索引（super_class）</code>都是一个<code>u2</code>类型的数据，而<code>接口索引集合（interfaces）</code>是一组<code>u2</code>类型的数据的集合，Class文件中由这三项数据来确定该<strong><u>类型的继承关系</u></strong>。</p>
<blockquote>
<ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名。父类索引只有一个(不允许多重继承)</li>
<li>接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按<code>implements</code>关键字后的接口顺序从左到右排列在接口索引集合中。</li>
</ul>
</blockquote>
<p>类索引和父类索引用两个<code>u2</code>类型的索引值表示，它们各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过<code>CONSTANT_Class_info</code>类型的常量中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型的常量中的<code>全限定名字符串</code>。</p>
<p>对于接口索引集合，入口的第一项<code>u2</code>类型的数据为<code>接口计数器（interfaces_count）</code>，表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0。</p>
<h4 id="字段表集合">2.5 字段表集合</h4>
<p><code>字段表（field_info）</code>用于描述接口或者类中声明的变量。<code>“字段”（Field）</code>包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/fieldInfo.PNG" alt="字段表结构" /><figcaption aria-hidden="true">字段表结构</figcaption>
</figure>
<p><code>name_index</code>和<code>descriptor_index</code>都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p>
<ul>
<li><code>全限定名</code>和<code>简单名称</code>。比如<code>“org/fenixsoft/clazz/TestClass”</code>是类的<code>全限定名</code>；<code>简单名称</code>则就是指没有类型和参数修饰的方法或者字段名称，类中的<code>inc()</code>方法和<code>m</code>字段的简单名称分别就是“<code>inc</code>”和“<code>m</code>”。</li>
<li><code>描述符</code>的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。
<ul>
<li>对于数组类型，每一维度将使用一个前置的<code>“[”</code>字符来描述。比如<code>“int[]”</code>将被记录成<code>“[I”</code>。</li>
<li>描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号<code>“()”</code>之内。<code>void inc()</code>的描述符为<code>“()V”</code>。</li>
</ul></li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/descriptor.PNG" alt="描述符" /><figcaption aria-hidden="true">描述符</figcaption>
</figure>
<blockquote>
<p>字段表集合中不会列出从父类或者父接口中继承而来的字段</p>
</blockquote>
<h4 id="方法表集合">2.6 方法表集合</h4>
<p>对方法的描述与对字段的描述采用了几乎完全一致的方式，依次包括<code>访问标志（access_flags）</code>、<code>名称索引（name_index）</code>、<code>描述符索引（descriptor_index）</code>、<code>属性表集合（attributes）</code>几项。</p>
<blockquote>
<p>父类方法在子类中没有被<code>重写（Override）</code>，方法表集合中就不会出现来自父类的方法信息。</p>
</blockquote>
<h4 id="属性表集合">2.7 属性表集合</h4>
<p>Class文件、字段表、方法表都可以携带自己的<code>属性表集合（attribute_info）</code>。对于每一个属性，它的名称都要从常量池中引用一个<code>CONSTANT_Utf8_info</code>类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个<code>u4</code>的长度属性去说明属性值所占用的位数即可。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/attributeInfo.PNG" alt="属性表结构" /><figcaption aria-hidden="true">属性表结构</figcaption>
</figure>
<h5 id="code属性">2.7.1 Code属性</h5>
<p>Java程序方法体里面的代码经过<code>Javac</code>编译器处理之后，最终变为字节码指令存储在<code>Code属性</code>内。Code属性出现在方法表的属性集合之中。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/CodeAttributeInfo.PNG" alt="Code属性表的结构" /><figcaption aria-hidden="true">Code属性表的结构</figcaption>
</figure>
<ul>
<li><code>attribute_name_index</code>是一项指向<code>CONSTANT_Utf8_info</code>型常量的索引，此常量值<strong>固定为<code>“Code”</code></strong>；</li>
<li><code>attribute_length</code>指示了属性值的长度；</li>
<li><code>max_stack</code>代表了<code>操作数栈（Operand Stack）</code>深度的最大值；</li>
<li><code>max_locals</code>代表了局部变量表所需的存储空间。<code>Javac</code>编译器会根据变量的作用域来分配变量槽给各个变量使用，根据<u><strong>同时生存的最大局部变量数量和类型</strong></u>计算出<code>max_locals</code>的大小。</li>
<li><code>code_length</code>和code用来存储Java源程序编译后生成的字节码指令。<code>code_length</code>代表字节码长度，虽然它是一个<code>u4</code>类型的长度值，理论上最大值可以达到<code>2的32次幂</code>。有可能<strong><u>因为方法生成字节码超长的原因而导致编译失败</u></strong>。</li>
<li>Code属性用于描述代码。
<ul>
<li>Java语言里面的潜规则：在任何实例方法里面，都可以通过“<code>this”</code>关键字访问到此方法所属的对象。是通过在<code>Javac</code>编译器编译的时候把对<code>this</code>关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数。所以在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量。</li>
</ul></li>
<li>显式异常处理表对于Code属性来说并不是必须存在的。如果存在异常表，它包含<u>四个字段</u>，这些字段的含义为：如果当字节码从第<code>start_pc</code>行到第<code>end_pc</code>行之间（不含第<code>end_pc</code>行）出现了类型为<code>catch_type</code>或者其子类的异常（<code>catch_type</code>为指向一个<code>CONSTANT_Class_info</code>型常量的索引），则转到第<code>handler_pc</code>行继续处理。当 <code>catch_type</code>的值为0时，代表任意异常情况都需要转到<code>handler_pc</code>处进行处理。</li>
</ul>
<h5 id="exceptions属性">2.7.2 Exceptions属性</h5>
<p><code>Exceptions属性</code>是在方法表中与Code属性平级的一项属性，作用是列举出方法中可能抛出的<code>受查异常（Checked Excepitons）</code>。</p>
<h5 id="linenumbertable属性">2.7.3 LineNumberTable属性</h5>
<p><code>LineNumberTable</code>属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。</p>
<h5 id="localvariabletable及localvariabletypetable属性">2.7.4 LocalVariableTable及LocalVariableTypeTable属性</h5>
<ul>
<li><code>LocalVariableTable</code>属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。</li>
<li><code>LocalVariableTypeTable</code>把<code>LocalVariableTabl</code>字段描述符的<code>descriptor_index</code>替换成了字段的<code>特征签名（Signature）</code>。泛型引入之后，由于描述符中泛型的参数化类型<code>被擦除掉</code>，描述符就不能准确描述泛型类型了。因此出现了<code>LocalVariableTypeTable</code>属性，<strong><u>使用字段的特征签名来完成泛型的描述</u></strong>。</li>
</ul>
<h5 id="sourcefile及sourcedebugextension属性">2.7.5 SourceFile及SourceDebugExtension属性</h5>
<p><code>SourceFile</code>属性用于记录生成这个Class文件的源码文件名称。</p>
<p><code>SourceDebugExtension</code>属性用于存储额外的代码调试信息。</p>
<h5 id="constantvalue属性">2.7.6 ConstantValue属性</h5>
<p><code>ConstantValue</code>属性的作用是通知虚拟机自动为静态变量赋值。只有被<code>static</code>关键字修饰的变量（类变量）才可以使用这项属性。</p>
<h5 id="innerclasses属性">2.7.7 InnerClasses属性</h5>
<p><code>InnerClasses</code>属性用于记录内部类与宿主类之间的关联。</p>
<h5 id="deprecated及synthetic属性">2.7.8 Deprecated及Synthetic属性</h5>
<ul>
<li><code>Deprecated</code>属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用<code>“@deprecated”</code>注解进行设置；</li>
<li><code>Synthetic</code>属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的。</li>
</ul>
<blockquote>
<p><code>Deprecated</code>和<code>Synthetic</code>两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</p>
</blockquote>
<h5 id="stackmaptable属性">2.7.9 StackMapTable属性</h5>
<p><code>StackMapTable</code>属性会在虚拟机类加载的字节码验证阶段被<code>新类型检查验证器（Type Checker）</code>使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p>
<h5 id="signature属性">5.7.10 Signature属性</h5>
<p><code>Signature</code>属性记录泛型类型，是因为Java语言的泛型采用的是<code>擦除法</code>实现的伪泛型，字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。</p>
<blockquote>
<ul>
<li>使用擦除法的好处是实现简单（主要修改<code>Javac</code>编译器，虚拟机内部只做了很少的改动）、非常容易实现<code>Backport</code>，运行期也能够节省一些类型所占的内存空间。</li>
<li>坏处是运行期就无法像有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待</li>
</ul>
</blockquote>
<h5 id="bootstrapmethods属性">2.7.11 BootstrapMethods属性</h5>
<p><code>BootstrapMethods</code>属性用于保存<code>invokedynamic</code>指令引用的引导方法限定符。</p>
<h5 id="methodparameters属性">2.7.12 MethodParameters属性</h5>
<p><code>MethodParameters</code>的作用是记录方法的各个形参名称和信息。</p>
<h5 id="模块化相关属性">2.7.13 模块化相关属性</h5>
<p><code>模块描述文件（module-info.java）</code>最终是要编译成一个独立的Class文件来存储的，所以Class文件格式也扩展了<code>Module</code>、<code>ModulePackages</code>和<code>ModuleMainClass</code>三个属性用于支持Java模块化相关功能。</p>
<ul>
<li><code>Module</code>属性除了表示该模块的名称、版本、标志信息以外，还存储了这个模块requires、exports、opens、uses和provides定义的全部内容；</li>
<li><code>ModulePackages</code>用于描述该模块中所有的包</li>
<li><code>ModuleMainClass</code>用于确定该模块的<code>主类（Main Class）</code></li>
</ul>
<h5 id="运行时注解相关属性">2.7.14 运行时注解相关属性</h5>
<p>为了存储源码中注解信息，Class文件同步增加了</p>
<ul>
<li><code>RuntimeVisibleAnnotations</code>；</li>
<li><code>RuntimeInvisibleAnnotations</code>；</li>
<li><code>RuntimeVisibleParameterAnnotations</code>；</li>
<li><code>RuntimeInvisibleParameterAnnotations</code></li>
</ul>
<p>后来又新增类型注解 （JSR 308）：</p>
<ul>
<li><code>RuntimeVisibleTypeAnnotations</code></li>
<li><code>RuntimeInvisibleTypeAnnotations</code></li>
</ul>
<p><code>RuntimeVisibleAnnotations</code>记录了类、字段或方法的声明上记录运行时可见注解，当我们使用<code>反射API</code>来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。</p>
<h3 id="字节码指令简介">3. 字节码指令简介</h3>
<p>Java虚拟机的指令由<u><strong>一个字节长度的</strong>、<strong>代表着某种特定操作含义</strong></u>的数字（称为<code>操作码，Opcode</code>）以及跟随其后的零至多个代表<strong>此操作所需的参数</strong>（称为<code>操作数，Operand</code>）构成。</p>
<p>如果不考虑异常处理的话，那Java虚拟机的解释器可以使用下面这段伪代码作为最基本的执行模型来理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    自动计算PC寄存器的值加<span class="number">1</span>;</span><br><span class="line">    根据PC寄存器指示的位置，从字节码流中取出操作码;</span><br><span class="line">    <span class="keyword">if</span> (字节码存在操作数) 从字节码流中取出操作数;</span><br><span class="line">    执行操作码所定义的操作;</span><br><span class="line">&#125; <span class="keyword">while</span> (字节码流长度 &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="字节码与数据类型">3.1 字节码与数据类型</h4>
<p>Java虚拟机的指令集中，<strong>大多数指令都包含其操作所对应的数据类型信息</strong>。</p>
<blockquote>
<p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：<code>i</code>代表对<code>int</code>类型的数据操作，<code>l</code>代表<code>long</code>，<code>s</code>代表<code>short</code>，<code>b</code>代表<code>byte</code>，<code>c</code>代表<code>char</code>，<code>f</code>代表<code>float</code>，<code>d</code>代表<code>double</code>，<code>a</code>代表<code>reference</code>。</p>
</blockquote>
<p>Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，即指令集将会被故意设计成非完全独立的。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</p>
<h4 id="加载和存储指令">3.2 加载和存储指令</h4>
<p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输：</p>
<ul>
<li>将一个局部变量加载到操作栈：<code>load</code>、<code>iload_&lt;n&gt;</code>、<code>lload</code>、<code>lload_&lt;n&gt;</code>、<code>fload</code>、<code>fload_&lt;n&gt;</code>、<code>dload</code>、<code>dload_&lt;n&gt;</code>、<code>aload</code>、<code>aload_&lt;n&gt;</code>；</li>
<li>将一个数值从操作数栈存储到局部变量表：<code>istore</code>、<code>istore_&lt;n&gt;</code>、<code>lstore</code>、<code>lstore_&lt;n&gt;</code>、<code>fstore</code>、<code>fstore_&lt;n&gt;</code>、<code>dstore</code>、<code>dstore_&lt;n&gt;</code>、<code>astore</code>、<code>astore_&lt;n&gt;</code>；</li>
<li>将一个常量加载到操作数栈：<code>bipush</code>、<code>sipush</code>、<code>ldc</code>、<code>ldc_w</code>、<code>ldc2_w</code>、<code>aconst_null</code>、<code>iconst_m1</code>、<code>iconst_&lt;i&gt;</code>、<code>lconst_&lt;l&gt;</code>、<code>fconst_&lt;f&gt;</code>、<code>dconst_&lt;d&gt;</code></li>
<li>扩充局部变量表的访问索引的指令：<code>wide</code></li>
</ul>
<p>是以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>）指令助记符实际上代表了一组指令，某个带有一个操作数的通用指令（例如<code>iload</code>）的特殊形式。省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中。</p>
<h4 id="运算指令">3.3 运算指令</h4>
<p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶：</p>
<ul>
<li>对整型数据进行运算的指令</li>
<li>对浮点型数据进行运算的指令</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ArithmeticInstructions.PNG" alt="算术指令" /><figcaption aria-hidden="true">算术指令</figcaption>
</figure>
<h4 id="类型转换指令">3.4 类型转换指令</h4>
<p>类型转换指令可以<strong><u>将两种不同的数值类型相互转换</u></strong>，这些转换操作一般用于：</p>
<ul>
<li>实现用户代码中的显式类型转换操作；</li>
<li>处理字节码指令集中数据类型相关指令无法与数据类型 一一对应的问题。</li>
</ul>
<p>Java虚拟机<strong><u>直接支持（即转换时无须显式的转换指令）</u></strong>以下数值类型的<code>宽化类型转换（Widening Numeric Conversion）</code>：</p>
<ul>
<li>int类型到long、float或者double类型</li>
<li>long类型到float、double类型</li>
<li>float类型到double类型</li>
</ul>
<p>处理<code>窄化类型转换（Narrowing Numeric Conversion）</code>时，就必须显式地使用转换指令来完成，这些转换指令包括<code>i2b</code>、<code>i2c</code>、<code>i2s</code>、<code>l2i</code>、<code>f2i</code>、<code>f2l</code>、<code>d2i</code>、<code>d2l</code>和<code>d2f</code>。</p>
<h4 id="对象创建与访问指令">3.5 对象创建与访问指令</h4>
<p>对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ObjectInstructions.PNG" alt="对象创建与访问指令" /><figcaption aria-hidden="true">对象创建与访问指令</figcaption>
</figure>
<h4 id="操作数栈管理指令">3.6 操作数栈管理指令</h4>
<p>Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p>
<ul>
<li>将操作数栈的栈顶一个或两个元素出栈：<code>pop</code>、<code>pop2</code></li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：<code>dup</code>、<code>dup2</code>、<code>dup_x1</code>、<code>dup2_x1</code>、<code>dup_x2</code>、<code>dup2_x2</code></li>
<li>将栈最顶端的两个数值互换：<code>swap</code></li>
</ul>
<h4 id="控制转移指令">4.7 控制转移指令</h4>
<p>控制转移指令可以让Java虚拟机<strong><u>有条件</u></strong>或<strong><u>无条件</u></strong>地从指定位置指令（而不是控制转移指令）的下 一条指令继续执行程序。控制转移指令包括：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/ControlTransferInstruction.PNG" alt="控制转移指令" /><figcaption aria-hidden="true">控制转移指令</figcaption>
</figure>
<h4 id="方法调用和返回指令">4.8 方法调用和返回指令</h4>
<p>方法调用（分派、执行过程）的指令：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/MethodCallAndReturnInstructions.PNG" alt="方法调用和返回指令" /><figcaption aria-hidden="true">方法调用和返回指令</figcaption>
</figure>
<h4 id="异常处理指令">4.9 异常处理指令</h4>
<p>而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用<code>jsr</code>和 <code>ret</code>指令来实现，现在已经不用了），而是<strong><u>采用异常表来完成</u></strong>。</p>
<h4 id="同步指令">4.10 同步指令</h4>
<p>支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用<code>管程</code>（<code>Monitor</code>，更常见的是直接将它称为<code>“锁”</code>）来实现的。</p>
<ul>
<li>方法级的同步是<strong>隐式的</strong>，<u>无须通过字节码指令来控制</u>，它实现在方法调用和返回操作之中。调用指令将会检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成时释放管程。</li>
<li>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持synchronized关键字的语义</li>
</ul>
<h3 id="公有设计私有实现">5. 公有设计，私有实现</h3>
<p>任何一款Java虚拟机实现都必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。在此前提下，虚拟机实现者可以使用让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--1. Two Sum</title>
    <url>/2019/03/28/LeetCode--1-Two-Sum.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target. <a id="more"></a> You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the same element twice.</p>
</blockquote>
<p><strong>Example1:</strong> &gt;Given nums = [2, 7, 11, 15], target = 9, &gt;Because nums[0] + nums[1] = 2 + 7 = 9, &gt;return [0, 1].</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>给定一个数组，和一个目标数target，要求数组中，和为target的两个数的下标。 想到的方法是暴力求法，即直接逐个遍历数组，找出满足要求的两个数。尽管这种方法能成功AC,但显然效率不高，这种方法比较耗时。需要寻找更加优化的算法。 查阅资料和题解思路得知，更加优化的方法是使用哈希表，这是一种通过以空间换取速度的方式，我们可以将查找时间从 O(n)降低到 O(1)。主要有以下两种： &gt;1.两遍哈希表 &gt;一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。</p>
<blockquote>
<p>2.一遍哈希表 更优化的方法是，我们可以一次完成计算。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
</blockquote>
<p>这里将这两种方法都实现了一遍。</p>
<h3 id="三代码">三、代码</h3>
<ol type="1">
<li><p>解法1 暴力求法 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indices;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            indices.push_back(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==target-nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    indices.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> indices;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            indices.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>解法2 两遍哈希表 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  indices;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.count(complement) &amp;&amp; hash[complement] != i)</span><br><span class="line">            &#123;</span><br><span class="line">                indices.push_back(i);</span><br><span class="line">                indices.push_back(hash[complement]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>一遍哈希表 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  indices;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.count(complement))</span><br><span class="line">            &#123;</span><br><span class="line">                indices.push_back(i);</span><br><span class="line">                indices.push_back(hash[complement]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> indices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<hr />
<p>更新：map与unordered_map区别 原文：https://blog.csdn.net/BillCYJ/article/details/78985895 <strong>1.内部实现机理不同</strong> <strong>map</strong>： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。</p>
<p><strong>unordered_map</strong>: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p>
<p><strong>2.优缺点以及适用处</strong> <strong>map：</strong> 优点： 1. 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作 2. 红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</p>
<p>缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间</p>
<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>
<p><strong>unordered_map：</strong> 优点： 因为内部实现了哈希表，因此其查找速度非常的快</p>
<p>缺点： 哈希表的建立比较耗费时间</p>
<p>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<p><strong>总结：</strong> 1. 内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。 2. 但是unordered_map执行效率要比map高很多 3. 对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--11. Container With Most Water</title>
    <url>/2019/04/03/LeetCode--11-Container-With-Most-Water.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given n non-negative integers <strong>a1, a2, ..., an</strong> , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. <a id="more"></a></p>
</blockquote>
<p><strong>Note:</strong> You may not slant the container and n is at least 2.</p>
<p><img src="https://i.niupic.com/images/2019/04/03/5Ujc.jpg" /> The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example :</strong> &gt;Input: [1,8,6,2,5,4,8,3,7] &gt;Output: 49</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>首先想到的是暴力解法，直接遍历所有可能的二元组，最终可以找到满足题目要求的最大值。但是题目对时间有要求，这种时间复杂度O(n^2)的方法超时了。所以需要使用更优的方法，一种优化的方法思路如下：</p>
<blockquote>
<p>使用两个变量，一个表示底的开始，一个表示底的终点。一开始底的起点是数组第一位，终点是数组最后一位。这样去计算两者之间围成的区域，如果比当前记录的最大区域大，则将之记为最大区域值。之后，将两边中较短的一边向中间移动一个单位，再次计算区域大小，重复刚才的后续过程。 这里的难点是为什么移动的是两边中较小的一条呢？因为这条是这个区域增加的“短板“。移动较短的一边，也许会遇到一条更大的边，这样的话这种增加有可能抵消了底边的变短，甚至可能使得区域面积变得更大。相反的，如果移动的是较大的一边，最好的情况是遇到一条比较短边还要长的边，但是因为“木桶效应“，整个区域大小还是取决于较短的边，所以移动较长的一边是不可能得到更好的结果的。</p>
</blockquote>
<h3 id="三代码">三、代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArea = min(height[i],height[j])*j;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            maxArea = max(maxArea,min(height[i],height[j])*(j-i));</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;height[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--13. Roman to Integer</title>
    <url>/2019/04/07/LeetCode--13-Roman-to-Integer.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. <a id="more"></a></p>
</blockquote>
<p>剩余部分略，描述与它前一道题<a href="http://wuyunjie.top/2019/04/03/LeetCode-12-Integer-to-Roman/" title="12. Integer to Roman">12. Integer to Roman</a>大致相同</p>
<p><strong>Example 1:</strong> &gt;Input: "III" &gt;Output: 3</p>
<p><strong>Example 2:</strong> &gt;Input: "IV" &gt;Output: 4</p>
<p><strong>Example 3:</strong> &gt;Input: "IX" &gt;Output: 9</p>
<p><strong>Example 4:</strong> &gt;Input: "LVIII" &gt;Output: 58 &gt;Explanation: L = 50, V= 5, III = 3.</p>
<p><strong>Example 5:</strong> &gt;Input: "MCMXCIV" &gt;Output: 1994 &gt;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题与它前一道题恰好相反，是从罗马数变成阿拉伯数字。细心观察可以发现，罗马数字一般都是大的数字在前面，如果存在某个较小的数字在某个较大的数字前——比如"IV"，那么他们表示的是一个数字4，即 V - I 。</p>
<p>利用这种特性，一开始思考，是否可以设置一个优先级，来判断某个数字应该比另一个优先出现。转念一想，他们的大小就已经代表优先级了，那么处理起来就很简单了： &gt; 1. 若一个数比它下一个数优先级高，加入该数的值； &gt; 2. 若一个数比它下一个数优先级低，减去该数的值。</p>
<h3 id="三代码">三、代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; roToInt = &#123;</span><br><span class="line">            &#123;<span class="string">'I'</span>,<span class="number">1</span>&#125;, &#123;<span class="string">'V'</span>,<span class="number">5</span>&#125;, &#123;<span class="string">'X'</span>,<span class="number">10</span>&#125;, </span><br><span class="line">            &#123;<span class="string">'L'</span>,<span class="number">50</span>&#125;,&#123;<span class="string">'C'</span>,<span class="number">100</span>&#125;,&#123;<span class="string">'D'</span>,<span class="number">500</span>&#125;,&#123;<span class="string">'M'</span>,<span class="number">1000</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// int roToInt[256] = &#123;0&#125;;</span></span><br><span class="line">        <span class="comment">// roToInt['I']=1;roToInt['V']=5;roToInt['X']=10;</span></span><br><span class="line">        <span class="comment">// roToInt['L']=50;roToInt['C']=100;roToInt['D']=500;roToInt['M']=1000;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(roToInt[s[i]]&lt;roToInt[s[i+<span class="number">1</span>]])</span><br><span class="line">            &#123;</span><br><span class="line">                result-=roToInt[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result+=roToInt[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--12. Integer to Roman</title>
    <url>/2019/04/03/LeetCode--12-Integer-to-Roman.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. <a id="more"></a> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure> For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
</blockquote>
<blockquote>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
</blockquote>
<blockquote>
<ul>
<li>I can be placed before V (5) and X (10) to make 4 and 9.</li>
<li>X can be placed before L (50) and C (100) to make 40 and 90.</li>
<li>C can be placed before D (500) and M (1000) to make 400 and 900.</li>
</ul>
</blockquote>
<blockquote>
<p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p>
</blockquote>
<p><strong>Example 1:</strong> &gt;Input: 3 &gt;Output: "III"</p>
<p><strong>Example 2:</strong> &gt;Input: 4 &gt;Output: "IV"</p>
<p><strong>Example 3:</strong> &gt;Input: 9 &gt;Output: "IX"</p>
<p><strong>Example 4:</strong> &gt;Input: 58 &gt;Output: "LVIII" &gt;Explanation: L = 50, V = 5, III = 3.</p>
<p><strong>Example 5:</strong> &gt;Input: 1994 &gt;Output: "MCMXCIV" &gt;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>题目描述很长，但意思很简单，就是将普通的阿拉伯数字转换为罗马数字。罗马数字有自己的表示规则，所以需要进行一定处理。其实处理方法很简单：</p>
<blockquote>
<p>每次找到数字中包含的最大罗马数字，然后减去这个数，并把该罗马数加入表示数的字符串中。不断重复这个过程，直到数字为0停止，输出结果。</p>
</blockquote>
<p>最开始实现时，写了一长串的if-else语句，尽管能够成功解决。但是代码不够简洁，需要想办法使代码美观规范。可以将这些罗马数字和其对应的阿拉伯数字从大到小存放到数组或者map中，之后直接从大到小遍历这个数组即可，可以省去大部分if-else语句，且结构更加清晰。</p>
<p>评论区有另一种解法，直接把0<sub>10,10</sub>100,100<sub>1000,1000</sub>3999范围类，罗马数的可能表示直接列出来放到一个数字中，然后直接按位查表，O(1)的时间复杂度。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="方法1">方法1</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= val[i]) &#123;</span><br><span class="line">                num -= val[i];</span><br><span class="line">                res += str[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法2">方法2</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> THOUS[];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> HUNDS[];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> TENS[];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="built_in">string</span> ONES[];</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        result += THOUS[(<span class="keyword">int</span>)(num/<span class="number">1000</span>)%<span class="number">10</span>];</span><br><span class="line">        result += HUNDS[(<span class="keyword">int</span>)(num/<span class="number">100</span>)%<span class="number">10</span>];</span><br><span class="line">        result += TENS[(<span class="keyword">int</span>)(num/<span class="number">10</span>)%<span class="number">10</span>];</span><br><span class="line">        result += ONES[num%<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::THOUS[]	= &#123;<span class="string">""</span>,<span class="string">"M"</span>,<span class="string">"MM"</span>,<span class="string">"MMM"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::HUNDS[]	= &#123;<span class="string">""</span>,<span class="string">"C"</span>,<span class="string">"CC"</span>,<span class="string">"CCC"</span>,<span class="string">"CD"</span>,<span class="string">"D"</span>,<span class="string">"DC"</span>,<span class="string">"DCC"</span>,<span class="string">"DCCC"</span>,<span class="string">"CM"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::TENS[]	= &#123;<span class="string">""</span>,<span class="string">"X"</span>,<span class="string">"XX"</span>,<span class="string">"XXX"</span>,<span class="string">"XL"</span>,<span class="string">"L"</span>,<span class="string">"LX"</span>,<span class="string">"LXX"</span>,<span class="string">"LXXX"</span>,<span class="string">"XC"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Solution::ONES[]	= &#123;<span class="string">""</span>,<span class="string">"I"</span>,<span class="string">"II"</span>,<span class="string">"III"</span>,<span class="string">"IV"</span>,<span class="string">"V"</span>,<span class="string">"VI"</span>,<span class="string">"VII"</span>,<span class="string">"VIII"</span>,<span class="string">"IX"</span>&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--14. Longest Common Prefix</title>
    <url>/2019/04/07/LeetCode--14-Longest-Common-Prefix.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Write a function to find the longest common prefix string amongst an array of strings. <a id="more"></a> If there is no common prefix, return an empty string "".</p>
</blockquote>
<p><strong>Example 1:</strong> &gt;Input: ["flower","flow","flight"] &gt;Output: "fl"</p>
<p><strong>Example 2:</strong> &gt;Input: ["dog","racecar","car"] &gt;Output: "" &gt;Explanation: There is no common prefix among the input strings.</p>
<p><strong>Note :</strong> &gt; All given inputs are in lowercase letters <strong>a-z</strong>.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>题目很简单，求一组字符串的最长公共前缀。因为是公共前缀，所以必定所有字符串都包含这个前缀。想法是用一个字符串LCP保存已经比较过的字符串的公共前缀，然后逐个遍历修正这个公共前缀，最终就可以得到结果。</p>
<p>看了题解后，发现这种方法叫做水平扫描法，除了这种方法外，还有许多其他方法可以求解。</p>
<p>算法二： 垂直扫描法 &gt;若数组末尾有一个非常短的字符串，使用水平扫描法依旧会进行S次比较，可以对其进行优化。即从前往后扫描字符串每一列，先判断每个字符串相同列上字符是否相同。</p>
<p>算法三： 分治 &gt;使用分治的技巧，将原问题 LCP(Si...Sj) 分成两个子问题 LCP(Si...Smid) 与 LCP(Smid+1...Sj)，其中mid = (i+j)/2.用子问题的解 lcpLeft 与 lcpRight 构造原问题的解 LCP(Si...Sj)。</p>
<p><img src="https://leetcode-cn.com/media/original_images/14_lcp_diviso_et_lmpera.png" /></p>
<p>算法四： &gt;还有一种解法，这种方法给输入字符串数组排了个序。按字母顺序排序的话，那么有共同字母多的两个字符串会被排到一起，而跟大家相同的字母越少的字符串会被挤到首尾两端，那么如果有共同前缀的话，一定会出现在首尾两端的字符串中，所以我们只需要找首尾字母串的共同前缀即可。 &gt;比如例子1排序后为 ["flight", "flow", "flower"]，例子2排序后为 ["car", "dog", "racecar"]，虽然例子2没有共同前缀，但也可以认为共同前缀是空串，且出现在首尾两端的字符串中。由于是按字母顺序排的，而不是按长度，所以首尾字母的长度关系不知道，为了防止溢出错误，我们只遍历而这种较短的那个的长度，找出共同前缀返回即可。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="水平扫描">水平扫描</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> lcp = strs[<span class="number">0</span>]; <span class="comment">//初始化公共前缀</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逐个遍历，不断修正</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; strs.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j &lt; lcp.length() &amp;&amp; j &lt; strs[i].length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lcp[j] != strs[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            lcp = lcp.substr(<span class="number">0</span>,j);</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="垂直扫描">垂直扫描</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> lcp = strs[<span class="number">0</span>]; <span class="comment">//初始化公共前缀</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逐个遍历，不断修正</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lcp.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; strs.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == strs[j].size() || strs[j][i] != lcp[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> lcp.substr(<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="分治">分治</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">commomPredix</span><span class="params">(<span class="built_in">string</span> left, <span class="built_in">string</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; left.length() &amp;&amp; i &lt; right.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left[i] != right[i]) <span class="keyword">return</span> left.substr(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.substr(<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LCP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">string</span> leftLCP = LCP(strs, l, mid);</span><br><span class="line">            <span class="built_in">string</span> rightLCP = LCP(strs, mid+<span class="number">1</span>, r);</span><br><span class="line">            <span class="keyword">return</span> commomPredix(leftLCP,rightLCP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> LCP(strs, <span class="number">0</span>, strs.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="算法四">算法四</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        sort(strs.begin(), strs.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = min(strs[<span class="number">0</span>].size(), strs.back().size());</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; strs[<span class="number">0</span>][i] == strs.back()[i]) ++i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--15. 3Sum</title>
    <url>/2019/04/07/LeetCode--15-3Sum.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given an array <strong>nums</strong> of n integers, are there elements a, b, c in <strong>nums</strong> such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. <a id="more"></a></p>
</blockquote>
<p><strong>Note :</strong> &gt;The solution set must not contain duplicate triplets.</p>
<p><strong>Example :</strong> &gt;Given array nums = [-1, 0, 1, 2, -1, -4],</p>
<blockquote>
<p>A solution set is: [ [-1, 0, 1], [-1, -1, 2]]</p>
</blockquote>
<h3 id="二解题思路">二、解题思路</h3>
<p>这个题和第一题Two Sum有些类似，但是要比那道题复杂一些。它的结果不止一个，而且返回的结果里不能有重复的解，由于用向量保存解，可能同一个解有不同的排列方式，去重的话会很麻烦。需要想一种算法，在计算结果的同时，跳过重复解。所以这道题应该不是考察Two Sum的解法。</p>
<p>分析一下这道题的特点，要我们找出三个数且和为0，那么除了三个数全是0的情况之外，肯定会有负数和正数。我们可以先固定一个数a，然后去找另外两个数b和c，我们只要找到两个数且和(b+c)为第一个数a的相反数就行了。在寻找这两个数组合的过程中，我们肯定不希望遍历所有两个数的组合。最先想到的就是，对原数组先进行一个排序，然后遍历这个排序后的数组，寻找合适的解。主要过程大致如下： &gt; 1. 设置low, high，分别从左边和右边向中间遍历数组:如果找到了 a+b+c=0，把结果放入答案集内;若a+b+c &lt; 0，则(b+c)过小，增大low；若a+b+c &gt; 0，则(b+c)过大，减小high &gt; 2. 在遍历过程中，若两个数相同，在数组中一定是相邻的，可以跳过这些相同的数。 &gt; 3. 我们也可以先做个剪枝优化，就是当遍历到正数a的时候就break，因为我们的数组现在是有序的了，如果第一个要数a就是正数了，那么后面的数字b,c就都是正数，就永远不会出现和为0的情况了。</p>
<h3 id="三代码">三、代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">2</span> || nums.front()&gt;<span class="number">0</span> || nums.back() &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>,high = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[low] + nums[high];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tuple = &#123;nums[i], nums[low], nums[high]&#125;;</span><br><span class="line">                    res.push_back(tuple);</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] == nums[++low] );</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] == nums[--high] );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) high--;</span><br><span class="line">                <span class="keyword">else</span> low++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--17. Letter Combinations of a Phone Number</title>
    <url>/2019/04/10/LeetCode--17-Letter-Combinations-of-a-Phone-Number.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. <a id="more"></a> A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" /></p>
<p><strong>Example :</strong> &gt; Input: "23" &gt;Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].</p>
<p><strong>Note :</strong> &gt; Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>题目让模拟手机9键的键盘，给定一个数字字符串(代表按键顺序)，给出可能的所有字母组合。简单理解，就是求每个数字所代表的字符集合的笛卡尔积，找出所有可能的情况。</p>
<p>想法是先在一个vector数组内放入一个空字符""。之后扫描字符串，每次识别到一个数字，就将这个数字所对应的字符分别与vector数组内的字符串连接加入数组，然后删去连接前的旧字符串，继续下一次扫描。当扫描完数字字符串时，就可以成功得到结果了。除此之外还有其他方法： &gt; <strong>回溯法(Backtracking)</strong> &gt; 回溯法是寻找所有可能的候选结果的一种算法。定义一个回溯函数<code>backtrack(combination, next_digits)</code>，生成结果并逐个字符检查。 &gt; - 若已经没有digits需要继续处理，说明结果已经成功生成，存入结果集。 &gt; - 如果仍然有还未检查的digits字符，继续处理该字符： - 将该字符代表的字母加入当前生成的结果 <code>combination = combination + letter</code> - 继续处理剩余的字符：<code>backtrack(combination + letter, next_digits[1:])</code></p>
<p><a href="https://imgchr.com/i/AT0u8J" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/10/AT0u8J.png" alt="AT0u8J.png" /></a></p>
<blockquote>
<p>这是一种递归迭代的方法。方法思想差不多，只是这种方法用递归实现。</p>
</blockquote>
<blockquote>
<p>其中还可以继续优化的是，可以不使用unordered_map，直接用一个一维string数组来存储mapping数组。</p>
</blockquote>
<h3 id="三代码">三、代码</h3>
<h4 id="方法一">方法一</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; mapping = &#123;</span><br><span class="line">        &#123;<span class="string">'1'</span>,<span class="string">""</span>&#125;, &#123;<span class="string">'2'</span>,<span class="string">"abc"</span>&#125;,&#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,&#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;, &#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,&#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(<span class="number">1</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; digits.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res_length = res.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mapping[digits[i]].length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; res_length;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(res[k]+mapping[digits[i]][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.erase(res.begin(),res.begin()+res_length);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二">方法二</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; mapping = &#123;</span><br><span class="line">        &#123;<span class="string">'1'</span>,<span class="string">""</span>&#125;, &#123;<span class="string">'2'</span>,<span class="string">"abc"</span>&#125;,&#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,&#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;, &#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,&#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">string</span> combination, <span class="built_in">string</span> digits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(combination);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> letters = mapping[digits[<span class="number">0</span>]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;letters.length();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                backtrack(combination+letters[i], digits.substr(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() != <span class="number">0</span>) </span><br><span class="line">            backtrack(<span class="string">""</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法三不使用unordered_map">方法三(不使用unordered_map)</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> mapping[<span class="number">10</span>] = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(<span class="number">1</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; digits.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res_length = res.size();</span><br><span class="line">            <span class="built_in">string</span> letters = mapping[digits[i]-<span class="string">'0'</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; letters.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; res_length;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(res[k]+letters[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.erase(res.begin(),res.begin()+res_length);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--16. 3Sum Closest</title>
    <url>/2019/04/09/LeetCode--16-3Sum-Closest.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given an array <strong>nums</strong> of n integers and an integer <strong>target</strong>, find three integers in <strong>nums</strong> such that the sum is closest to <strong>target</strong>. Return the sum of the three integers. You may assume that each input would have exactly one solution. <a id="more"></a></p>
</blockquote>
<p><strong>Example :</strong> &gt; Given array nums = [-1, 2, 1, -4], and target = 1.</p>
<blockquote>
<p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<h3 id="二解题思路">二、解题思路</h3>
<p>这个题和它的前一道题<a href="http://wuyunjie.top/2019/04/07/LeetCode-15-3Sum/" title="15. 3Sum">15. 3Sum</a>很像，前一道题可以看做本题在target = 0时的特殊情况。但这道题进行了一定的改写和简化： &gt; 1. 存在且仅存在一个解，所以我们可以在找到一个最优解后立即停止; &gt; 2. 要寻找的是最接近target的三数和。也就是说可能会没有等于target的情况，比如题目的例子就是如此；另一方面只需要返回这三个数的和，不需要记录这三个数，所以对结果的记录和判断简化了。</p>
<p>我们只需要在15题的算法的基础上进行一定的修改就可以得到这道题的结果了。我们可以用同样的方法，先对数组进行排序，固定一个数a，然后去找另外两个数b和c的组合： 1. 如果我们只要找到两个数且和(b+c)为(target - a)，那么找到了最接近的三数和即target; 2. 否者我们记录下当前数以及与target的距离(定义为|target-(a+b+c)|)，继续遍历数组找下一个更相近的三数和。</p>
<p>同样的，在寻找过程中，我们可以跳过那些重复的组合，并且进行合适的剪枝进行优化。</p>
<h3 id="三代码">三、代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> closesetDistance = <span class="built_in">abs</span>(nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[nums.size()<span class="number">-1</span>] - target);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>,high = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[low] + nums[high];</span><br><span class="line">                <span class="keyword">if</span>(sum == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(sum-target &lt; closesetDistance)</span><br><span class="line">                    &#123;</span><br><span class="line">                        closesetDistance = sum-target;</span><br><span class="line">                        res = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] == nums[--high]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(target-sum &lt; closesetDistance)</span><br><span class="line">                    &#123;</span><br><span class="line">                        closesetDistance = target-sum;</span><br><span class="line">                        res = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] == nums[++low]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--18. 4Sum</title>
    <url>/2019/04/10/LeetCode--18-4Sum.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given an array <code>nums</code> of n integers and an integer <code>target</code>, are there elements a, b, c, and d in <code>nums</code> such that a + b + c + d = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>. <a id="more"></a></p>
</blockquote>
<p><strong>Note :</strong> &gt; The solution set must not contain duplicate quadruplets.</p>
<p><strong>Example :</strong> &gt; Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</p>
<blockquote>
<p>A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]</p>
</blockquote>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题和前面几道关于数字之和的题应该是同一个系列(<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%941-Two-Sum/" title="Two Sum">Two Sum</a>，<a href="http://wuyunjie.top/2019/04/07/LeetCode-15-3Sum/" title="3Sum">3Sum</a>，<a href="http://wuyunjie.top/2019/04/09/LeetCode-16-3Sum-Closest/" title="3Sum Closest">3Sum Closest</a>)。尽管难度有所提升，但是解题的思想和算法实际上都一致，其实也就是多了层循环。比如四个数a,b,c,d，我们可以先固定数a，然后寻找b,c,d，这就转换成了三数和的问题。</p>
<p>现在遇到了许多类似的问题，而且可以看出他们的解决方法具有一定规律，可以进行拓展。那么是不是可以找到一种泛化的方法计算KSUM，使得我们以后遇到5sum, 6sum...等等类似的问题时，不必再去重写这些算法，只用一个泛化的算法就可以搞定这一些。翻看评论区后，发现已经有人实现了这样的算法，主要是通过递归DFS实现的。每次先固定一个数，然后递归找到K-1SUM的结果。依次类推，直到找到2SUM返回最终结果，开始回溯。代码实现如下。</p>
<p>参考文献： <a href="https://leetcode.com/problems/4sum/discuss/8641/12ms-KSum-c%2B%2B-code" target="_blank" rel="noopener" title="12ms KSum, c++ code">[1] 12ms KSum, c++ code</a> <a href="https://leetcode.com/problems/4sum/discuss/163559/C%2B%2B-solution-for-all-Ksum-question" target="_blank" rel="noopener" title="[1] C++ solution for all Ksum question">[2] C++ solution for all Ksum question</a></p>
<h3 id="三代码">三、代码</h3>
<h4 id="sum">4SUM</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">3</span> || (nums.front() &gt; target &amp;&amp; nums.front() &gt; <span class="number">0</span>) || (nums.back() &lt; target &amp;&amp; nums.back() &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[n<span class="number">-3</span>]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>]&lt;target) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> tmp_target = target - nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n <span class="number">-2</span>  ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[j+<span class="number">1</span>]+nums[j+<span class="number">2</span>]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>]&lt;target) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> low = j+<span class="number">1</span>,high = n<span class="number">-1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>( low &lt; high)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[j] + nums[low] + nums[high];</span><br><span class="line">                    <span class="keyword">if</span>(sum == tmp_target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tuple = &#123;nums[i], nums[j], nums[low], nums[high]&#125;;</span><br><span class="line">                        res.push_back(tuple);</span><br><span class="line">                        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] == nums[++low] );</span><br><span class="line">                        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] == nums[--high] );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; tmp_target) high--;</span><br><span class="line">                    <span class="keyword">else</span> low++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="ksum">KSUM</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Valid for K &gt;= 2</span></span><br><span class="line">    <span class="comment">// k表示求ksum,nums是目标数组,l,r分别是左右游标</span></span><br><span class="line">    <span class="comment">// target是当前目标数, retVal是最终结果, cur是当前阶段的中间结果</span></span><br><span class="line">    <span class="comment">// ci表示当前是正在求第ci个数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">KSum</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; retVal, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="keyword">int</span> ci )</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mn, mx; <span class="comment">//mn表示当前最小的数，mx表示当前最大的数</span></span><br><span class="line">        <span class="keyword">int</span> km1 = k - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( r-l+<span class="number">1</span> &lt; k ) <span class="keyword">return</span>; <span class="comment">//若剩余的数比K小，已经无法找到结果，结束递归</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ( l &lt; r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新当前最小数和最大数</span></span><br><span class="line">            mn = nums[l];</span><br><span class="line">            mx = nums[r];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 若mn + (k-1)*mx &lt; target，mn太小，l右移</span></span><br><span class="line">            <span class="keyword">if</span> ( ( mn + km1*mx ) &lt; target ) l++;</span><br><span class="line">            <span class="comment">// 若(k-1)*mn + mx &gt; target，mx太大，r左移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( ( km1*mn + mx ) &gt; target ) r--;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// K=2,直接求出最终结果，其中包括去重操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( k == <span class="number">2</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                cur[ci] = mn;</span><br><span class="line">                cur[ci+<span class="number">1</span>] = mx;</span><br><span class="line">                retVal.push_back( cur );</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">while</span> ( ( l &lt; r ) &amp;&amp; ( nums[l] == mn ) ) l++;</span><br><span class="line">                r--;</span><br><span class="line">                <span class="keyword">while</span> ( ( l &lt; r ) &amp;&amp; ( nums[r] == mx ) ) r--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否者，递归转化为k-1 Sum的问题，递归求解</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur[ci] = mn; <span class="comment">//记录下当前可能的第ci个数</span></span><br><span class="line">                <span class="comment">//递归求解k-1 Sum</span></span><br><span class="line">                KSum( km1, nums, ++l, r, target - mn, retVal, cur, ci+<span class="number">1</span> );</span><br><span class="line">                <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">while</span> ( ( l &lt; r ) &amp;&amp; ( nums[l] == nums[l<span class="number">-1</span>] ) ) l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; RetVal;</span><br><span class="line">        <span class="comment">//初始化中间结果向量</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序，用于后面去重</span></span><br><span class="line">        sort( nums.begin(), nums.end() );</span><br><span class="line">        </span><br><span class="line">        KSum( <span class="number">4</span>, nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>, target, RetVal, cur, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RetVal;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--9 类加载及执行子系统的案例与实战</title>
    <url>/2021/05/31/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_9_Case_and_practice_of_class_loading_and_execution_subsystem.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变。 <a id="more"></a></p>
</blockquote>
<p>能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能。</p>
<h3 id="案例分析">1. 案例分析</h3>
<h4 id="tomcat正统的类加载器架构">1.1 <code>Tomcat</code>：正统的类加载器架构</h4>
<p>主流的<code>Java Web服务器</code>，如<code>Tomcat</code>、<code>Jetty</code>、<code>WebLogic</code>、<code>WebSphere</code>等，都实现了自己定义的类加载器，而且一般不止一个。一个功能健全的Web服务器，要解决如下的这些问题：</p>
<ul>
<li>部署在<u>同一个服务器</u>上的两个Web应用程序所使用的Java类库可以实现<strong><u>相互隔离</u></strong>。</li>
<li>部署在<u>同一个服务器</u>上的两个Web应用程序所使用的Java类库可以<u><strong>互相共享</strong></u>。</li>
<li>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响。</li>
<li>支持<code>JSP</code>应用的Web服务器，十有八九都需要支持<code>HotSwap</code>功能。<code>JSP</code>文件由于其<u>纯文本存储</u>的特性，被运行时修改的概率远大于第三方类库或程序自己的Class文件。而且<code>ASP</code>、<code>PHP</code>和<code>JSP</code>这些网页应用也把<u><strong>修改后无须重启</strong></u>作为一 个很大的“优势”来看待，因此“主流”的Web服务器都会支持<code>JSP</code>生成类的<strong><code>热替换</code></strong>。</li>
</ul>
<p>由于存在上述问题，在部署Web应用时，各种Web服务器都提供了好几个有着不同含义的<code>ClassPath</code>路径供用户存放<u>第三方类库</u>，这些路径一般会以<code>“lib”</code>或<code>“classes”</code>命名。通常每一个目录都会有一个相应的<strong><code>自定义类加载器</code></strong>去加载放置在里面的Java类库。</p>
<h4 id="osgi灵活的类加载器架构">1.2 <code>OSGi</code>：灵活的类加载器架构</h4>
<p><code>OSGi （Open Service Gateway Initiative）</code>是<code>OSGi联盟（OSGi Alliance）</code>制订的一个基于Java语言的<code>动态模块化规范</code>。<code>OSGi</code>中的每个模块（称为<code>Bundle</code>）与普通的Java类库区别并不太大，两者一般都以<code>JAR</code>格式进行封装，并且内部存储的都是Java的<code>Package</code>和<code>Class</code>。</p>
<ul>
<li>但是一个<code>Bundle</code>可以声明它所依赖的<code>Package</code>（通过<code>Import-Package</code>描述），也可以声明它允许导出发布的<code>Package</code>（通过<code>Export-Package</code>描述）。</li>
<li>在<code>OSGi</code>里面，<code>Bundle</code>之间的依赖关系从传统的上层模块依赖底层模块转变为<strong>平级模块之间的依赖</strong>，而且类库的可见性能得到非常精确的控制，一个模块里只有被<code>Export</code>过的<code>Package</code>才可能被外界访问，其他的<code>Package</code>和<code>Class</code>将会被隐藏起来。</li>
</ul>
<p>但引入<code>OSGi</code>的主要理由是基于<code>OSGi</code>架构的程序很可能会实现模块级的<strong><u>热插拔功能</u></strong>，该特性要归功于它灵活的类加载器架构：</p>
<ul>
<li><code>OSGi</code>的<code>Bundle</code>类加载器之间只有规则，没有固定的委派关系。例如，某个<code>Bundle</code>声明了一个它依赖的<code>Package</code>，如果有其他<code>Bundle</code>声明了发布这个<code>Package</code>后，那么所有对这个<code>Package</code>的类加载动作都会委派给发布它的<code>Bundle</code>类加载器去完成。</li>
<li>不涉及某个具体的Package时，各个Bundle加载器都是平级的关系，只有具体使用到某个<code>Package</code>和<code>Class</code>的时候，才会根据<code>Package</code><strong>导入导出定义</strong>来构造<code>Bundle</code>间的委派和依赖。</li>
<li>一个<code>Bundle</code>类加载器为其他<code>Bundle</code>提供服务时，会根据<code>Export-Package</code>列表严格控制访问范围。</li>
</ul>
<p>假设存在<code>Bundle A</code>、<code>Bundle B</code>、<code>Bundle C</code>这<code>3</code>个模块，并且这<code>3</code>个<code>Bundle</code>定义的依赖关系如下：</p>
<ul>
<li><code>Bundle A</code>：声明发布了<code>package A</code>，依赖了<code>java.*</code>的包；</li>
<li><code>Bundle B</code>：声明依赖了<code>package A</code>和<code>package C</code>，同时也依赖了<code>java.*</code>的包；</li>
<li><code>Bundle C</code>：声明发布了<code>package C</code>，依赖了<code>package A</code>。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/OSGiClassloaderArchitecture.PNG" alt="OSGi的类加载器架构" /><figcaption aria-hidden="true">OSGi的类加载器架构</figcaption>
</figure>
<p>在 <code>OSGi</code>里，类加载时可能进行的查找规则如下：</p>
<ul>
<li>以<code>java.*</code>开头的类，委派给父类加载器加载。</li>
<li>否则，委派列表名单内的类，委派给父类加载器加载。</li>
<li>否则，<code>Import</code>列表中的类，委派给<code>Export</code>这个类的<code>Bundle</code>的类加载器加载。</li>
<li>否则，查找当前<code>Bundle</code>的<code>Classpath</code>，使用自己的类加载器加载。</li>
<li>否则，查找是否在自己的<code>Fragment Bundle</code>中，如果是则委派给<code>Fragment Bundle</code>的类加载器加载。</li>
<li>否则，查找<code>Dynamic Import</code>列表的<code>Bundle</code>，委派给对应<code>Bundle</code>的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ul>
<h4 id="字节码生成技术与动态代理的实现">1.3 字节码生成技术与动态代理的实现</h4>
<h5 id="字节码生成技术">1.3.1 字节码生成技术</h5>
<p>要深入从Java源码到字节码编译过程，阅读<code>Javac</code>的源码是个很好的途径。在Java世界里面除了<code>Javac</code>和字节码类库外，使用到字节码生成的例子比比皆是：</p>
<ul>
<li>Web服务器中的<code>JSP编译器</code>，编译时植入的<code>AOP框架</code>；</li>
<li>动态代理技术；</li>
<li>使用反射的时候虚拟机有可能会在运行时生成字节码来提高执行速度。</li>
</ul>
<h5 id="动态代理技术">1.3.2 动态代理技术</h5>
<p>动态代理的优势在于，<u>实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中</u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        Object originalObj;</span><br><span class="line"></span><br><span class="line">        <span class="function">Object <span class="title">bind</span><span class="params">(Object originalObj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.originalObj = originalObj;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"welcome"</span>);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(originalObj, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IHello hello = (IHello) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> Hello());</span><br><span class="line">        hello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Proxy::newProxyInstance()</code>方法返回一个实现了<code>IHello</code>的接口，并且代理了<code>new Hello()</code>实例行为的对象，程序进行过验证、优化、缓存、同步、生成字节码、显式类加载等操作，它最后调用<code>sun.misc.ProxyGenerator::generateProxyClass()</code>方法来完成<code>生成字节码</code>的动作，这个方法会在运行时产生一个描述代理类的字节码<strong>byte[]数组</strong>。</p>
<h4 id="backport工具java的时光机器">1.4 <code>Backport</code>工具：Java的时光机器</h4>
<p>“Java逆向移植”的工具（<code>Java Backporting Tools</code>）用于把<strong>高版本JDK</strong>中编写的代码放到低版本JDK环境中去部署使用。<code>Retrotranslator</code>和<code>Retrolambda</code>是这类工具中的杰出代表。</p>
<ul>
<li><code>Retrotranslator</code>的作用是将<code>JDK 5</code>编译出来的Class文件转变为可以在<code>JDK 1.4</code>或<code>1.3</code>上部署的版本，它能很好地支持<u>自动装箱</u>、<u>泛型</u>、<u>动态注解</u>、<u>枚举</u>、<u>变长参数</u>、<u>遍历循环</u>、<u>静态导入</u>这些语法特性， 甚至还可以支持<code>JDK 5</code>中新增的<u>集合改进</u>、<u>并发包</u>及<u>对泛型、注解等的反射操作</u>。</li>
<li><code>Retrolambda</code>将<code>JDK 8</code>的<code>Lambda</code>表达式和<code>try-resources</code>语法转变为可以在<code>JDK 5</code>、<code>JDK 6</code>、<code>JDK 7</code>中使用的形式，同时也对<code>接口默认方法</code>提供了<strong>有限度</strong>的支持。</li>
</ul>
<p>JDK的每次升级新增的功能大致可以分为以下五类：</p>
<ol type="1">
<li>对Java类库API的代码增强。</li>
<li>在前端编译器层面做的改进。</li>
<li>需要在字节码中进行支持的改动。</li>
<li>需要在JDK整体结构层面进行支持的改进。</li>
<li>集中在虚拟机内部的改进。</li>
</ol>
<p>上述的5类新功能中，逆向移植工具能比较完美地模拟了前两类。</p>
<h3 id="实战自己动手实现远程执行功能">2. 实战：自己动手实现远程执行功能</h3>
<p>做程序维护的时候会遇到只要在服务中执行一小段程序代码，就可以定位或排除问题，但就是偏偏找不到可以让服务器执行时代码的途径。通常解决这类问题有以下几种途径：</p>
<ol type="1">
<li>可以使用<code>BTrace</code>这类<code>JVMTI</code>工具去动态修改程序中某一部分的运行代码，类似的<code>JVMTI</code>工具还有阿里巴巴的<code>Arthas</code>等。</li>
<li>使用<code>JDK 6</code>之后提供了<code>Compiler API</code>，可以动态地编译Java程序，这样虽然达不到动态语言的灵活度，但让服务器执行临时代码的需求是可以得到解决的。</li>
<li>写一个<code>JSP文件</code>上传到服务器，然后在浏览器中运行它，或者在服务端程序中加入一个<code>BeanShell Script</code>、<code>JavaScript</code>等的执行引擎去执行动态脚本。</li>
<li>在应用程序中内置动态执行的功能。</li>
</ol>
<h4 id="目标">2.1 目标</h4>
<p>希望最终的产品：</p>
<ul>
<li>不依赖某个JDK版本才加入的特性（包括<code>JVMTI</code>），能在目前还被普遍使用的JDK中部署。</li>
<li>不改变原有服务端程序的部署，不依赖任何第三方类库。</li>
<li>不侵入原有程序，即无须改动原程序的任何代码。也不会对原有程序的运行带来任何影响。</li>
<li>考虑到<code>BeanShell Script</code>或<code>JavaScript</code>等脚本与Java对象交互起来不太方便，<code>“临时代码”</code>应该直接支持Java语言。</li>
<li><code>“临时代码”</code>应当具备足够的自由度，不需要依赖特定的类或实现特定的接口。</li>
<li><code>“临时代码”</code>的执行结果能返回到客户端，执行结果可以包括程序中输出的信息及抛出的异常等。</li>
</ul>
<h4 id="思路">2.2 思路</h4>
<p>需要解决以下3个问题：</p>
<ol type="1">
<li>如何编译提交到服务器的Java代码？
<ul>
<li>在服务器上编译，在<code>JDK 6</code>以后可以使用<code>Compiler API</code>，在<code>JDK 6</code>以前可以使用<code>tools.jar</code>包中的 <code>com.sun.tools.Javac.Main</code>类来编译Java文件。这种思路的缺点是引入了额外的依赖，而且把程序绑死在<strong>特定</strong>的<code>JDK</code>上了。</li>
<li>在客户端编译好，把<strong><u>字节码</u></strong>传到服务端。</li>
</ul></li>
<li>如何执行编译之后的Java代码？
<ul>
<li>让类加载器加载这个类生成一个Class对象，然后反射调用一下某个方法；</li>
</ul></li>
<li>如何收集Java代码的执行结果？
<ul>
<li>把程序往<code>标准输出（System.out）</code>和<code>标准错误输出（System.err）</code>中打印的信息收集起来。但会对原有程序产生影响：<u>会把其他线程向标准输出中打印的信息也收集了</u>。</li>
<li>直接在执行的类中把对<code>System.out</code>的符号引用替换为我们准备的<code>PrintStream</code>的符号引用。</li>
</ul></li>
</ol>
<h4 id="实现">2.3 实现</h4>
<p>实现过程中需要用到的4个支持类：</p>
<h5 id="hotswapclassloader">2.3.1 <code>HotSwapClassLoader</code></h5>
<p><code>HotSwapClassLoader</code>类于实现<code>“同一个类的代码可以被多次加载”</code>这个需求。<code>HotSwapClassLoader</code>所做的事情仅仅是公开父类（即<code>java.lang.ClassLoader</code>）中的<code>protected</code>方法<code>defineClass()</code>，我们将会使用这个方法<u><strong>把提交执行的Java类的<code>byte[]</code>数组转变为Class对象</strong></u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了多次载入执行类而加入的加载器</span></span><br><span class="line"><span class="comment"> * 把defineClass方法开放出来，只有外部显式调用的时候才会使用到loadByte方法</span></span><br><span class="line"><span class="comment"> * 由虚拟机调用时，仍然按照原有的双亲委派规则使用loadClass方法进行类加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotSwapClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HotSwapClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HotSwapClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadByte</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, classByte, <span class="number">0</span>, classByte.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="classmodifier">2.3.2 <code>ClassModifier</code></h5>
<p><code>ClassModifier</code>类实现将<code>java.lang.System</code>替换为我们自己定义的<code>HackSystem</code>类的过程，它<strong><u>直接修改符合Class文件格式的byte[]数组中的<code>常量池</code>部分，将常量池中指定内容的<code>CONSTANT_Utf8_info</code>常量替换为新的字符串</u></strong>。</p>
<p>经过<code>ClassModifier</code>处理后的<code>byte[]数组</code>才会传给<code>HotSwapClassLoader.loadByte()</code>方法进行类加载，<code>byte[]数组</code>在这里替换符号引用之后，与客户端直接在Java代码中引用<code>HackSystem</code>类再编译生成的Class是完全一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** 修改Class文件，暂时只提供修改常量池常量的功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassModifier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class文件中常量池的起始偏移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_POOL_COUNT_INDEX = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CONSTANT_Utf8_info常量的tag标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_Utf8_info = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量池中11种常量所占的长度，CONSTANT_Utf8_info型常量除外，因为它不是定长的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] CONSTANT_ITEM_LENGTH = &#123; -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] classByte;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassModifier</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classByte = classByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改常量池中CONSTANT_Utf8_info常量的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldStr 修改前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newStr 修改后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 修改结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] modifyUTF8Constant(String oldStr, String newStr) &#123;</span><br><span class="line">        <span class="keyword">int</span> cpc = getConstantPoolCount();</span><br><span class="line">        <span class="keyword">int</span> offset = CONSTANT_POOL_COUNT_INDEX + u2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cpc; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tag = ByteUtils.bytes2Int(classByte, offset, u1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tag == CONSTANT_Utf8_info) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = ByteUtils.bytes2Int(classByte, offset + u1, u2);</span><br><span class="line">                offset += (u1 + u2);</span><br><span class="line">                String str = ByteUtils.bytes2String(classByte, offset, len);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (str.equalsIgnoreCase(oldStr)) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] strBytes = ByteUtils.string2Bytes(newStr);</span><br><span class="line">                    <span class="keyword">byte</span>[] strLen = ByteUtils.int2Bytes(newStr.length(), u2);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset - u2, u2, strLen);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset, len, strBytes);</span><br><span class="line">                    <span class="keyword">return</span> classByte;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    offset += len;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                offset += CONSTANT_ITEM_LENGTH[tag];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classByte;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取常量池中常量的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 常量池数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getConstantPoolCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ByteUtils.bytes2Int(classByte, CONSTANT_POOL_COUNT_INDEX, u2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="byteutils">2.3.3 <code>ByteUtils</code></h5>
<p><code>ClassModifier</code>中涉及对<code>byte[]数组</code>操作的部分， 主要是将<code>byte[]</code>与<code>int</code>和<code>String</code>互相转换，以及把对<code>byte[]数据</code>的替换操作封装在<code>ByteUtils</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** Bytes数组处理工具</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bytes2Int</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = start + len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = ((<span class="keyword">int</span>) b[i]) &amp; <span class="number">0xff</span>;</span><br><span class="line">            n &lt;&lt;= (--len) * <span class="number">8</span>;</span><br><span class="line">            sum = n + sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] int2Bytes(<span class="keyword">int</span> value, <span class="keyword">int</span> len) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            b[len - i - <span class="number">1</span>] = (<span class="keyword">byte</span>) ((value &gt;&gt; <span class="number">8</span> * i) &amp; <span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytes2String</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(b, start, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] string2Bytes(String str) &#123;</span><br><span class="line">        <span class="keyword">return</span> str.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] bytesReplace(<span class="keyword">byte</span>[] originalBytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, <span class="keyword">byte</span>[] replaceBytes) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] newBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[originalBytes.length + (replaceBytes.length - len)];</span><br><span class="line">        System.arraycopy(originalBytes, <span class="number">0</span>, newBytes, <span class="number">0</span>, offset);</span><br><span class="line">        System.arraycopy(replaceBytes, <span class="number">0</span>, newBytes, offset, replaceBytes.length);</span><br><span class="line">        System.arraycopy(originalBytes, offset + len, newBytes, offset + replaceBytes.length, originalBytes.length - offset - len);</span><br><span class="line">        <span class="keyword">return</span> newBytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="hacksystem">2.3.4 <code>HackSystem</code></h5>
<p>用来代替<code>java.lang.System</code>的<code>HackSystem</code>，主要把<code>out</code>和<code>err</code>两个静态变量改成使用<code>ByteArrayOutputStream</code>作为打印目标的同一个<code>PrintStream</code>对象，以及增加了<u><strong>读取</strong></u>、<u><strong>清理</strong></u><code>ByteArrayOutputStream</code>中内容的<code>getBufferString()</code>和 <code>clearBuffer()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为Javaclass劫持java.lang.System提供支持</span></span><br><span class="line"><span class="comment"> * 除了out和err外，其余的都直接转发给System处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HackSystem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> InputStream in = System.in;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out = <span class="keyword">new</span> PrintStream(buffer);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream err = out;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getBufferString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buffer.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSecurityManager</span><span class="params">(<span class="keyword">final</span> SecurityManager s)</span> </span>&#123;</span><br><span class="line">        System.setSecurityManager(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecurityManager <span class="title">getSecurityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.getSecurityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(src, srcPos, dest, destPos, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">identityHashCode</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.identityHashCode(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面所有的方法都与java.lang.System的名称一样</span></span><br><span class="line">    <span class="comment">// 实现都是字节转调System的对应方法</span></span><br><span class="line">    <span class="comment">// 因版面原因，省略了其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="javaclassexecuter">2.3.5 <code>JavaclassExecuter</code></h5>
<p><code>JavaclassExecuter</code>是提供给外部调用的入口，调用前面几个支持类组装逻辑，完成类加载工作。</p>
<ul>
<li>用输入的符合Class文件格式的<code>byte[]数组</code>替换掉<code>java.lang.System</code>的符号引用后，使用<code>HotSwapClassLoader</code>加载生成一个Class对象；</li>
<li>然后<code>反射</code>调用这个Class对象的<code>main()</code>方法，如果期间出现任何异常，将异常信息打印到<code>HackSystem.out</code>中，</li>
<li>最后把缓冲区中的信息作为方法的结果来返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Javaclass执行工具</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaclassExecuter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行外部传过来的代表一个Java类的Byte数组&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 将输入类的byte数组中代表java.lang.System的CONSTANT_Utf8_info常量修改为劫持后的HackSystem类</span></span><br><span class="line"><span class="comment">     * 执行方法为该类的static main(String[] args)方法，输出结果为该类向System.out/err输出的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classByte 代表一个Java类的Byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">execute</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        HackSystem.clearBuffer();</span><br><span class="line">        ClassModifier cm = <span class="keyword">new</span> ClassModifier(classByte);</span><br><span class="line">        <span class="keyword">byte</span>[] modiBytes = cm.modifyUTF8Constant(<span class="string">"java/lang/System"</span>, <span class="string">"org/fenixsoft/classloading/execute/HackSystem"</span>);</span><br><span class="line">        HotSwapClassLoader loader = <span class="keyword">new</span> HotSwapClassLoader();</span><br><span class="line">        Class clazz = loader.loadByte(modiBytes);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = clazz.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[]&#123;String[]<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">            method.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> String[]&#123; <span class="keyword">null</span> &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace(HackSystem.out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HackSystem.getBufferString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="验证">2.4 验证</h4>
<p>写一个Java类，只要向<code>System.out</code>输出信息即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test executor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立一个测试代码，就可以在输出这个类的运行结果(原文是通过<code>JSP</code>来实现的，这里没有搭建服务器，就用这个小例子试试，可能不是那么合适的代替)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecuter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/Users/yunjiewu/IdeaProjects/JavaLearning/out/production/JavaLearning/JVMLearning/JavaclassExecuter/TestClass.class"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line">            is.close();</span><br><span class="line">            System.out.println(JavaclassExecuter.execute(b));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|深入理解Java虚拟机]--10 前端编译与优化</title>
    <url>/2021/06/02/JavaLearning_Undertanding_the_JVM_Advanced_Features_and_Best_Practives_10_Front-end_compilation_and_optimization.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>从计算机程序出现的第一天起，对效率的追逐就是程序员天生的坚定信仰，这个过程犹如一场没有终点、永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛车。 <a id="more"></a></p>
</blockquote>
<p><code>Java</code>有<code>3</code>类编译过程：</p>
<ul>
<li><strong>前端编译器</strong>：<strong>“编译器的前端”</strong>，把<code>*.java</code>文件转变成<code>*.class</code>文件，比如<code>JDK</code>的<code>Javac</code>、<code>Eclipse JDT</code>中的增量式编译器（<code>ECJ</code>）。</li>
<li><strong>即时编译器</strong>：常称<code>JIT编译器</code>（<code>Just In Time Compiler</code>），运行期把字节码转变成本地机器码，比如<code>HotSpot</code>虚拟机的<code>C1</code>、<code>C2</code>编译器，<code>Graal</code>编译器。</li>
<li><strong>提前编译器</strong>：常称<code>AOT编译器</code>（<code>Ahead Of Time Compiler</code>），直接把程序编译成与目标机器指令集相关的二进制代码。<code>JDK</code>的<code>Jaotc</code>、<code>GNU Compiler for the Java（GCJ）</code>、<code>Excelsior JET</code>。</li>
</ul>
<p>Java中即时编译器在运行期的优化过程，支撑了<strong>程序执行效率的不断提升</strong>；而前端编译器在编译期的优化过程，则是支撑着<strong>程序员的编码效率和语言使用者的幸福感的提高</strong>。</p>
<h3 id="javac编译器">1. <code>Javac</code>编译器</h3>
<p><code>Javac</code>编译器不像<code>HotSpot</code>虚拟机那样使用<code>C++</code>语言（包含少量<code>C</code>语言）实现，它本身就是一个由<code>Java</code>语言编写的程序。</p>
<h4 id="javac的源码与调试">1.1 <code>Javac</code>的源码与调试</h4>
<p><code>javac</code>的发展历史：</p>
<ul>
<li><code>JDK 6</code>以前，<code>Javac</code>并不属于标准<code>Java SE API</code>，它实现代码单独存放在<code>tools.jar</code>中。</li>
<li><code>JDK 6</code>发布时通过了<code>JSR 199</code>编译器<code>API</code>的提案，使得<code>Javac</code>编译器的实现代码晋升成为标准Java类库之一，它的源码就改为放在<code>JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac</code>中</li>
<li><code>JDK 9</code>时，整个<code>JDK</code>所有的<code>Java</code>类库都采用模块化进行重构划分，<code>Javac</code>编译器就被挪到了<code>jdk.compiler</code>模块（路径为：<code>JDK_SRC_HOME/src/jdk.compiler/share/classes/com/sun/tools/javac</code>）里面</li>
</ul>
<p>从<code>Javac</code>代码的总体结构来看，编译过程大致可以分为<code>1</code>个准备过程和<code>3</code>个处理过程：</p>
<ol type="1">
<li><strong>准备过程</strong>：初始化插入式注解处理器。</li>
<li><strong>解析与填充符号表过程</strong>，包括：
<ul>
<li><strong>词法、语法分析</strong>。将源代码的字符流转变为标记集合，构造出抽象语法树。</li>
<li><strong>填充符号表</strong>。产生符号地址和符号信息。</li>
</ul></li>
<li><strong>插入式注解处理器的注解处理过程</strong>：插入式注解处理器的执行阶段。</li>
<li><strong>分析与字节码生成过程</strong>，包括：
<ul>
<li><strong>标注检查</strong>。对语法的静态信息进行检查。</li>
<li><strong>数据流及控制流分析</strong>。对程序动态运行过程进行检查。</li>
<li><strong>解语法糖</strong>。将简化代码编写的语法糖还原为原有的形式。</li>
<li><strong>字节码生成</strong>。将前面各个步骤所生成的信息转化成字节码。</li>
</ul></li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/javacComplierProcess.PNG" alt="Javac的编译过程" /><figcaption aria-hidden="true">Javac的编译过程</figcaption>
</figure>
<p>Javac编译动作的入口是<code>com.sun.tools.javac.main.JavaCompiler</code>类:</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/javacComplierCode.PNG" alt="Javac编译过程的主体代码" /><figcaption aria-hidden="true">Javac编译过程的主体代码</figcaption>
</figure>
<h4 id="解析与填充符号表">1.2 解析与填充符号表</h4>
<p>解析过程包括了<code>词法分析</code>和<code>语法分析</code>两个步骤：</p>
<h5 id="词法语法分析">1.2.1 词法、语法分析</h5>
<ul>
<li><strong>词法分析</strong>是将源代码的字符流转变为<code>标记（Token）</code>集合的过程，单个字符是<u>程序编写</u>时的最小元素，但标记才是<u>编译</u>时的最小元素。
<ul>
<li>词法分析过程由<code>com.sun.tools.javac.parser.Scanner</code>类来实现。</li>
</ul></li>
<li><strong>语法分析</strong>是根据标记序列构造抽象语法树的过程，<code>抽象语法树（Abstract Syntax Tree，AST）</code>是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个<code>语法结构（Syntax Construct）</code>，例如<u>包、类型、修饰符、运算符、接口、返回值</u>甚至连<u>代码注释</u>等都可以是一种特定的语法结构。
<ul>
<li>语法分析过程由<code>com.sun.tools.javac.parser.Parser</code>类实现的</li>
<li>抽象语法树是以<code>com.sun.tools.javac.tree.JCTree</code> 类表示的。</li>
</ul></li>
</ul>
<p>经过词法和语法分析生成语法树以后，编译器就不会再对源码字符流进行操作了，<u><strong>后续的操作都建立在抽象语法树之上</strong></u>。</p>
<h5 id="填充符号表">1.2.2 填充符号表</h5>
<p><code>符号表（Symbol Table）</code>是由一组<u><strong>符号地址</strong></u>和<u><strong>符号信息</strong></u>构成的数据结构。符号表中所登记的信息在编译的不同阶段都要被用到。</p>
<ul>
<li>在语义分析的过程中，符号表所登记的内容将用于语义检查和产生中间代码</li>
<li>在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。</li>
<li>填充符号表的过程由<code>com.sun.tools.javac.comp.Enter</code>类实现。</li>
</ul>
<h4 id="注解处理器">1.3 注解处理器</h4>
<p><code>注解（Annotations）</code>在设计上原本是与普通的Java代码一样，都只会在程序运行期间发挥作用的。但在<code>JDK 6</code>中设计了一组被称为<code>“插入式注解处理器”</code>的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。</p>
<ul>
<li><code>插入式注解处理器</code>可以看作是一组编译器的<strong>插件</strong>，它允许<strong>读取</strong>、<strong>修改</strong>、<strong>添加</strong>抽象语法树中的<strong>任意元素</strong>。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个<code>轮次（Round）</code>。</li>
</ul>
<h4 id="语义分析与字节码生成">1.4 语义分析与字节码生成</h4>
<p>抽象语法树能够表示一个<code>结构正确</code>的源程序，但无法保证源程序的<code>语义是符合逻辑</code>的。语义分析的主要任务则是<u><strong>对结构上正确的源程序进行上下文相关性质的检查</strong></u>，譬如进行<u>类型检查</u>、<u>控制流检查</u>、<u>数据流检查</u>，等等。</p>
<h5 id="标注检查">1.4.1 标注检查</h5>
<p>语义分析过程可分为<strong>标注检查</strong>和<strong>数据及控制流分析</strong>两个步骤。</p>
<p>标注检查步骤要检查的内容包括诸如<u>变量使用前是否已被声明</u>、<u>变量与赋值之间的数据类型是否能够匹配</u>，等等。还会顺便进行一个称为<code>常量折叠（Constant Folding）</code>的代码优化。</p>
<h5 id="数据及控制流分析">1.4.2 数据及控制流分析</h5>
<p><code>数据流分析</code>和<code>控制流分析</code>是对程序上下文逻辑更进一步的验证，它可以检查出诸如<u>程序局部变量在使用前是否有赋值</u>、<u>方法的每条路径是否都有返回值</u>、<u>是否所有的受查异常都被正确处理</u>等问题。</p>
<h5 id="解语法糖">1.4.3 解语法糖</h5>
<p><code>语法糖（Syntactic Sugar）</code>，也称<code>糖衣语法</code>，指的是在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响， 但是却能更方便程序员使用该语言。通常来说使用语法糖能够<em>减少代码量、增加程序的可读性</em>。</p>
<p>Java中最常见的语法糖包括了<strong><u>泛型</u></strong>、<u><strong>变长参数</strong></u>、<strong><u>自动装箱拆箱</u></strong>，等等，它们在编译阶段被还原回原始的基础语法结构，这个过程就称为<code>解语法糖</code>。</p>
<h5 id="字节码生成">1.4.4 字节码生成</h5>
<p>字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了<u>少量的代码添加和转换工作</u>。</p>
<ul>
<li>实例构造器<code>&lt;init&gt;()</code>方法和类构造器<code>&lt;clinit&gt;()</code>方法就是在这个阶段被添加到语法树之中的。</li>
</ul>
<p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交到<code>com.sun.tools.javac.jvm.ClassWriter</code>类手上，由这个类的<code>writeClass()</code>方法输出字节码，生成最终的Class 文件。</p>
<h3 id="java语法糖的味道">2. Java语法糖的味道</h3>
<p>语法糖虽然不会提供实质性的功能改进，但是它们或能提高效率，或能提升语法的严谨性，或能减少编码出错的机会。</p>
<h4 id="泛型">2.1 泛型</h4>
<p><code>泛型</code>的本质是<code>参数化类型（Parameterized Type）</code>或者<code>参数化多态（Parametric Polymorphism）</code>的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。</p>
<h5 id="java与c的泛型">2.1.1 Java与C#的泛型</h5>
<p><code>Java</code>选择的泛型实现方式叫作<code>“类型擦除式泛型”（Type Erasure Generics）</code>，而<code>C#</code>选择的泛型实现方式是<code>“具现化式泛型”（Reified Generics）</code>。</p>
<ul>
<li><code>C#</code>里面泛型无论在程序源码里面、编译后的中间语言表示（<code>Intermediate Language</code>）里面，抑或是运行期的<code>CLR</code>里面都是切实存在的，有着自己独立的虚方法表和类型数据。</li>
<li><code>Java</code>语言中的泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的<code>裸类型（Raw Type）</code>，并且在相应的地方插入了强制转型代码。
<ul>
<li>对于运行期的Java语言来说，<code>ArrayList&lt;int&gt;</code>与<code>ArrayList&lt;String&gt;</code>其实是同一个类型。</li>
</ul></li>
</ul>
<p>Java的类型<code>擦除式泛型</code>无论在使用效果上还是运行效率上，几乎是全面落后于<code>C#</code>的<code>具现化式泛型</code>，而它的<u><strong>唯一优势</strong></u>是：</p>
<blockquote>
<p><code>擦除式泛型</code>的实现几乎只需要在<code>Javac</code>编译器上做出改进即可，不需要改动字节码、不需要改动Java虚拟机，也保证了以前没有使用泛型的库可以直接运行在Java 5.0之上。</p>
</blockquote>
<h5 id="类型擦除">2.1.2 类型擦除</h5>
<p>为了保证以前编译出来的<code>Class</code>文件可以在<code>Java 5.0</code>引入泛型之后继续运行，大体上有两条路可以选择：</p>
<ol type="1">
<li>需要泛型化的类型（主要是容器类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型。</li>
<li>直接把已有的类型泛型化，即让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。</li>
</ol>
<p>Java选择了<u><strong>直接把已有的类型泛型化</strong></u>，譬如<code>ArrayList</code>原地泛型化后变成了<code>ArrayList&lt;T&gt;</code>。要保证以前直接用<code>ArrayList</code>的代码在泛型新版本里必须还能继续用这同一个容器，这就必须让所有泛型化的实例类型全部自动成为<code>ArrayList</code>的子类型才能可以，否则类型转换就是不安全的。由此就引出了<code>“裸类型”（Raw Type）</code>的概念。</p>
<blockquote>
<p><code>裸类型</code>应被视为所有该类型泛型化实例的<code>共同父类型（Super Type）</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ilist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; slist = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList list; <span class="comment">// 裸类型</span></span><br><span class="line">list = ilist;</span><br><span class="line">list = slist;</span><br></pre></td></tr></table></figure>
<p>如何实现裸类型又有两种选择：</p>
<ol type="1">
<li>在运行期由<code>Java</code>虚拟机来自动地、真实地构造出<code>ArrayList&lt;Integer&gt;</code>这样的类型，并且自动实现从<code>ArrayList&lt;Integer&gt;</code>派生自<code>ArrayList</code>的继承关系来满足裸类型的定义；</li>
<li>简单粗暴地直接在编译时把<code>ArrayList&lt;Integer&gt;</code>还原回<code>ArrayList</code>，只在<u>元素访问</u>、<u>修改</u>时自动插入一些<u>强制类型转换和检查指令</u>。</li>
</ol>
<p>显然Java选择了后一种实现方式。可以看一个<code>Java</code>泛型擦除的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型擦除前的例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">    map.put(<span class="string">"how are you?"</span>, <span class="string">"吃了没？"</span>);</span><br><span class="line">    System.out.println(map.get(<span class="string">"hello"</span>));</span><br><span class="line">    System.out.println(map.get(<span class="string">"how are you?"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型擦除后的例子</span></span><br><span class="line"><span class="comment"> * 上一段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译的结果</span></span><br><span class="line"><span class="comment"> * 泛型类型都变回了裸类型，只在元素访问时插入了从Object到String的强制转型代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"hello"</span>, <span class="string">"你好"</span>);</span><br><span class="line">    map.put(<span class="string">"how are you?"</span>, <span class="string">"吃了没？"</span>);</span><br><span class="line">    System.out.println((String) map.get(<span class="string">"hello"</span>));</span><br><span class="line">    System.out.println((String) map.get(<span class="string">"how are you?"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型擦除带来的缺陷：</p>
<ol type="1">
<li><p>使用擦除法实现泛型直接导致了对<code>原始类型（Primitive Types）</code>数据的支持又成了新的麻烦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原始类型的泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ArrayList&lt;<span class="keyword">int</span>&gt; ilist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">ArrayList&lt;<span class="keyword">long</span>&gt; llist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line">ArrayList list;</span><br><span class="line">list = ilist;</span><br><span class="line">list = llist;</span><br></pre></td></tr></table></figure>
<p>由于Java不支持<code>int</code>、<code>long</code>与<code>Object</code>之间的强制转型，所以泛型擦除后在需要插入强制转型代码的地方就无法进行了。Java给出的解决方案简单粗暴：</p>
<blockquote>
<p>不支持原生类型的泛型，使用<code>ArrayList&lt;Integer&gt;</code>、<code>ArrayList&lt;Long&gt;</code>，遇到原生类型时自动装箱、拆箱。</p>
</blockquote></li>
<li><p>运行期无法取到泛型类型信息，会让一些代码变得相当啰嗦</p>
<p><code>Java</code>不支持如下泛型的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeErasureGenerics</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (item <span class="keyword">instanceof</span> E) &#123; <span class="comment">// 不合法，无法对泛型进行实例判断</span></span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		E newItem = <span class="keyword">new</span> E(); <span class="comment">// 不合法，无法使用泛型创建对象</span></span><br><span class="line">		E[] itemArray = <span class="keyword">new</span> E[<span class="number">10</span>]; <span class="comment">// 不合法，无法使用泛型创建数组</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些限制都是由于<u><strong>运行期Java虚拟机无法取得泛型类型</strong></u>而导致的，要实现类似操作，需要写一个泛型版本的从<code>List</code>到数组的转换方法，由于不能从<code>List</code>中取得参数化类型<code>T</code>，所以不得不从一个额外参数中再传入一个数组的组件类型进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] convert(List&lt;T&gt; list, Class&lt;T&gt; componentType) &#123;</span><br><span class="line">	T[] array = (T[])Array.newInstance(componentType, list.size());</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>丧失了一些面向对象思想应有的优雅，带来了一些模棱两可的模糊状况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"invoke method(List&lt;String&gt; list)"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"invoke method(List&lt;Integer&gt; list)"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为参数<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>编译之后都被擦除了，变成了同一种的裸类型<code>List</code>，类型擦除导致这两个方法的特征签名变得一模一样，无法重载。</p></li>
</ol>
<h5 id="值类型与未来的泛型">2.1.3 值类型与未来的泛型</h5>
<p>Oracle建立了一个名为<code>Valhalla</code>的语言改进项目，希望改进Java语言留下的各种缺陷。</p>
<p>在<code>Valhalla</code>项目中规划了几种不同的新泛型实现方案，被称为<code>Model 1</code>到<code>Model 3</code>，泛型类型有可能被：</p>
<ul>
<li><strong>具现化</strong></li>
<li>继续维持<strong>类型擦除以</strong>保持兼容
<ul>
<li>泛型的参数化类型也可以选择不被完全地擦除掉，而是相对完整地记录在Class文件中，能够在运行期被使用</li>
<li>也可以指定编译器默认要擦除哪些类型。</li>
</ul></li>
</ul>
<p>相对于使用不同方式实现泛型，目前比较明确的是未来的Java应该会提供<code>“值类型”（Value Type）</code>的语言层面的支持。</p>
<blockquote>
<ul>
<li><p><code>值类型</code>可以与<code>引用类型</code>一样，具有<u>构造函数</u>、<u>方法</u>或是<u>属性字段</u>，等等</p></li>
<li><p><code>值类型</code>与<code>引用类型</code>的区别在于<u><strong>它在赋值的时候通常是整体复制，而不是像引用类型那样传递引用的</strong></u>。</p></li>
<li><p>值类型的实例很容易实现分配在方法的调用栈上的，值类型可以随着当前方法的退出而自动释放，不会给垃圾收集子系统带来任何压力。</p></li>
</ul>
</blockquote>
<p>Java的值类型方案被称为<code>“内联类型”</code>，计划通过一个新的关键字<code>inline</code>来定义，字节码层面也有专门与原生类型对应的以<code>Q</code>开头的新的操作码（譬如<code>iload</code>对应<code>qload</code>）来支撑。</p>
<h4 id="自动装箱拆箱与遍历循环">2.2 自动装箱、拆箱与遍历循环</h4>
<p><code>自动装箱</code>、<code>自动拆箱</code>与<code>遍历循环</code>（<code>for-each循环</code>）是Java语言里面被使用最多的语法糖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动装箱、拆箱与遍历循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">		sum += i;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动装箱、拆箱与遍历循环编译之后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	List list = Arrays.asList( <span class="keyword">new</span> Integer[] &#123;</span><br><span class="line">		Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">		Integer.valueOf(<span class="number">2</span>),</span><br><span class="line">		Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">		Integer.valueOf(<span class="number">4</span>) &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)localIterator.next()).intValue();</span><br><span class="line">        sum += i;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>自动装箱</code>、<code>拆箱</code>在编译之后被转化成了对应的包装和还原方法，如<code>Integer.valueOf()</code>与<code>Integer.intValue()</code>方法</li>
<li><code>遍历循环</code>则是把代码还原成了迭代器的实现</li>
<li><code>变长参数</code>在调用的时候变成了一个数组类型的参数</li>
</ul>
<p>自动装箱的陷阱</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    Integer b = <span class="number">2</span>;</span><br><span class="line">    Integer c = <span class="number">3</span>;</span><br><span class="line">    Integer d = <span class="number">3</span>;</span><br><span class="line">    Integer e = <span class="number">321</span>;</span><br><span class="line">    Integer f = <span class="number">321</span>;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">    System.out.println(e == f);</span><br><span class="line">    System.out.println(c == (a + b));</span><br><span class="line">    System.out.println(c.equals(a + b));</span><br><span class="line">    System.out.println(g == (a + b));</span><br><span class="line">    System.out.println(g.equals(a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/TrapOfAutoBoxing.PNG" alt="自动装箱的陷阱" /><figcaption aria-hidden="true">自动装箱的陷阱</figcaption>
</figure>
<ul>
<li><p>对于前两个结果，基于<code>==</code>比较，但返回结果不一样，查看Integer内部源码发现，有一个静态内部类的缓存池<code>IntegerCache</code>，缓存范在为<code>-128~127</code>的数，超过这个范围的<code>Integer</code>值都是<code>new</code>出来的新对象。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/IntegerValueOf.PNG" alt="ValueOf" /><figcaption aria-hidden="true">ValueOf</figcaption>
</figure>
<ul>
<li>直接使用<code>==</code>比较符，比较的是引用的堆地址，所以<code>c</code>与<code>d</code>都是同一个堆地址，返回<code>true</code>；<code>e</code>和<code>f</code>是创建的两个不同的对象，返回<code>false</code>。从变量表也可以看出来：</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/JVM/TrapOfAutoBoxingVariable.PNG" alt="变量表" /><figcaption aria-hidden="true">变量表</figcaption>
</figure>
<ul>
<li><code>Integer</code>缓存了<code>-128~127</code>之间的数，这是在类加载期间就完成的。以后需要的时候直接指向它就可以了，省去了构造对象的开支，提高了效率。</li>
</ul></li>
<li><p>包装类的<code>“==”</code>运算在不遇到算术运算的情况下不会自动拆箱，以及它们<code>equals()</code>方法不处理数据转型的关系</p></li>
</ul>
<h4 id="条件编译">2.4 条件编译</h4>
<p>Java语言可以进行条件编译，方法就是使用条件为常量的<code>if</code>语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    	System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   		System.out.println(<span class="string">"block 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反编译结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只能使用条件为常量的<code>if</code>语句才能达到上述效果。根据布尔常量值的真假，编译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段（<code>com.sun.tools.javac.comp.Lower</code>类中）完成。</p>
<blockquote>
<p>条件编译的实现方式使用了<code>if</code>语句，所以它必须遵循最基本的Java语法，只能写在方法体内部，因此它只能实现语句<code>基本块（Block）</code>级别的条件编译，而没有办法实现根据条件调整整个Java类的结构。</p>
</blockquote>
<h3 id="实战插入式注解处理器">3. 实战：插入式注解处理器</h3>
<h4 id="实战目标">3.1 实战目标</h4>
<p>使用<code>注解处理器API</code>来编写一款拥有自己编码风格的校验工具：<code>NameCheckProcessor</code>。<code>NameCheckProcessor</code>的目标定为对Java程序命名进行检查，Java程序命名推荐（而不是强制）应当符合下列格式的书写规范：</p>
<ul>
<li><strong>类（或接口）</strong>：符合<u>驼式命名法</u>，<u>首字母大写</u>。</li>
<li><strong>方法</strong>：符合<u>驼式命名法</u>，<u>首字母小写</u>。</li>
<li><strong>字段</strong>：
<ul>
<li><strong>类或实例变量</strong>。符合驼式命名法，首字母小写。</li>
<li><strong>常量</strong>。要求<strong>全部由大写字母或下划线</strong>构成，并且<u>第一个字符不能是下划线</u>。</li>
</ul></li>
</ul>
<h4 id="代码实现">3.2 代码实现</h4>
<p>实现<code>注解处理器</code>的代码需要继承抽象类<code>javax.annotation.processing.AbstractProcessor</code>。</p>
<ul>
<li>这个抽象类中只有一个子类必须实现的抽象方法：<code>“process()”</code>，它是Javac编译器在执行注解处理器代码时要调用的过程。
<ul>
<li>从这个方法的第一个参数<code>“annotations”</code>中获取到此<code>注解处理器</code>所要处理的<code>注解集合</code>。</li>
<li>从第二个参数<code>“roundEnv”</code>中访问到当前这个<code>轮次（Round）</code>中的抽象语法树节点，每个语法树节点在这里都表示为一个<code>Element</code>。</li>
</ul></li>
<li>实例变量<code>“processingEnv”</code>是<code>AbstractProcessor</code>中的一个<code>protected</code>变量，在注解处理器初始化的时候（<code>init()</code>方法执行的时候）创建，继承了<code>AbstractProcessor</code>的注解处理器代码可以直接访问它。它代表了注解处理器框架提供的一个<code>上下文环境</code>，要<u>创建新的代码</u>、<u>向编译器输出信息</u>、<u>获取其他工具类</u>等都需要用到这个实例变量。</li>
<li>还有两个经常配合着使用的注解，分别是：
<ul>
<li><code>@SupportedAnnotationTypes</code>，代表了这个注解处理器对哪些注解感兴趣，可以使用星号<code>“*”</code>作为通配符代表对所有的注解都感兴趣</li>
<li><code>@SupportedSourceVersion</code>，指出这个注解处理器可以处理哪些版本的Java代码。</li>
</ul></li>
</ul>
<p>如果不需要改变或添加抽象语法树中的内容，<code>process()</code> 方法可以返回<code>false</code>，通知编译器这个轮次中的代码未发生变化，无须构造新的<code>JavaCompiler</code>实例。</p>
<p>注解处理器<code>NameCheckProcessor</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用"*"表示支持所有Annotations</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"*"</span>)</span><br><span class="line"><span class="comment">// 只支持JDK 6的Java代码</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NameChecker nameChecker;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化名称检查插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        nameChecker = <span class="keyword">new</span> NameChecker(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对输入的语法树的各个节点进行名称检查</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!roundEnv.processingOver()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Element element : roundEnv.getRootElements())</span><br><span class="line">                nameChecker.checkNames(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名检查器<code>NameChecker</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.processing.Messager;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.ProcessingEnvironment;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.util.ElementScanner6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.lang.model.element.ElementKind.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.lang.model.element.Modifier.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.tools.Diagnostic.Kind.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序名称规范的编译器插件：&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 如果程序命名不合规范，将会输出一个编译器的WARNING信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messager messager;</span><br><span class="line"></span><br><span class="line">    NameCheckScanner nameCheckScanner = <span class="keyword">new</span> NameCheckScanner();</span><br><span class="line"></span><br><span class="line">    NameChecker(ProcessingEnvironment processsingEnv) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messager = processsingEnv.getMessager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对Java程序命名进行检查，根据《Java语言规范》第三版第6.8节的要求，Java程序命名应当符合下列格式：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;类或接口：符合驼式命名法，首字母大写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;方法：符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;字段：</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;类、实例变量: 符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;常量: 要求全部大写。</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkNames</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        nameCheckScanner.scan(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称检查器实现类，继承了JDK 6中新提供的ElementScanner6&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 将会以Visitor模式访问抽象语法树中的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckScanner</span> <span class="keyword">extends</span> <span class="title">ElementScanner6</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此方法用于检查Java类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitType</span><span class="params">(TypeElement e, Void p)</span> </span>&#123;</span><br><span class="line">            scan(e.getTypeParameters(), p);</span><br><span class="line">            checkCamelCase(e, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">super</span>.visitType(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查方法命名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitExecutable</span><span class="params">(ExecutableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == METHOD) &#123;</span><br><span class="line">                Name name = e.getSimpleName();</span><br><span class="line">                <span class="keyword">if</span> (name.contentEquals(e.getEnclosingElement().getSimpleName()))</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"一个普通方法 “"</span> + name + <span class="string">"”不应当与类名重复，避免与构造函数产生混淆"</span>, e);</span><br><span class="line">                checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.visitExecutable(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查变量命名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitVariable</span><span class="params">(VariableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果这个Variable是枚举或常量，则按大写命名检查，否则按照驼式命名法规则检查</span></span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == ENUM_CONSTANT || e.getConstantValue() != <span class="keyword">null</span> || heuristicallyConstant(e))</span><br><span class="line">                checkAllCaps(e);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断一个变量是否是常量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">heuristicallyConstant</span><span class="params">(VariableElement e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getEnclosingElement().getKind() == INTERFACE)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e.getKind() == FIELD &amp;&amp; e.getModifiers().containsAll(EnumSet.of(PUBLIC, STATIC, FINAL)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查传入的Element是否符合驼式命名法，如果不符合，则输出警告信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCamelCase</span><span class="params">(Element e, <span class="keyword">boolean</span> initialCaps)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line">            <span class="keyword">boolean</span> previousUpper = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (Character.isUpperCase(firstCodePoint)) &#123;</span><br><span class="line">                previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当以小写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isLowerCase(firstCodePoint)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当以大写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (conventional) &#123;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (Character.isUpperCase(cp)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUpper) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        previousUpper = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!conventional)</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当符合驼式命名法（Camel Case Names）"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 大写命名检查，要求第一个字母必须是大写的英文字母，其余部分可以是下划线或大写字母</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkAllCaps</span><span class="params">(Element e)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isUpperCase(firstCodePoint))</span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (cp == (<span class="keyword">int</span>) <span class="string">'_'</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUnderscore) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        previousUnderscore = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!conventional)</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"常量“"</span> + name + <span class="string">"”应当全部以大写字母或下划线命名，并且以字母开头"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含了多处不规范命名的代码样例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BADLY_NAMED_CODE</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> colors &#123;</span><br><span class="line">        red, blue, green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _FORTY_TWO = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> NOT_A_CONSTANT = _FORTY_TWO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">BADLY_NAMED_CODE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NOTcamelCASEmethodNAME</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>Javac</code>命令的<code>“-processor”</code>参数来执行编译时需要附带的注解处理器，还可以使用<code>-XprintRounds</code>和<code>-XprintProcessorInfo</code>参数来查看注解处理器运作的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac -processor JVMLearning.Complier.NameCheckProcessor JVMLearning\Complier\BADLY_NAMED_CODE.java</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--19. Remove Nth Node From End of List</title>
    <url>/2019/04/11/LeetCode--19-Remove-Nth-Node-From-End-of-List.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given a linked list, remove the n-th node from the end of list and return its head. <a id="more"></a></p>
</blockquote>
<p><strong>Example :</strong> &gt;Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>
<blockquote>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5</p>
</blockquote>
<p><strong>Note :</strong> &gt;Given n will always be valid.</p>
<p><strong>Follow up :</strong> &gt; Could you do this in one pass?</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>题目要求我们找到并删除链表的倒数第n个数。由于链表不支持随机访问，并且链表长度也不容易求，所以题目看似会很麻烦。但是以前经常会碰到这样的问题，比如求链表中间位置的数等等，对这类题目有过一定了解。其实很简单，只需要用两个指针就可实现一次扫描得到结果。 &gt; 首先第一个指针end先前进n，到达第n个结点后，第二个结点pre开始前进遍历； &gt; 两个指针end和pre同步前进，他们之间的距离是n，当end到达链表尾部时，pre指向的就是倒数第n个结点。 &gt; 此时我们可以继续操作，进行要求的插入，删除等等。</p>
<p>在寻找链表中点时，可以使用同样的方法。使用两个指针end,mid，两个指针同时前进，但此时，mid每前进一步，end会前进两步。那么当end到达终点时，mid恰好走过一半的结点，也就找到了链表的中点。</p>
<p>当然还有一种暴力解法，就是先计算出链表的长度L，然后找到第(L-n)个结点，把第 (L−n) 个结点的 next 指针重新链接至第 (L−n+2) 个结点。同样可以完成该算法。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="双指针法">双指针法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *end = head;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) end = end-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(end == <span class="literal">NULL</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(end-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            end = end-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="暴力算法">暴力算法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *count = head;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L++;</span><br><span class="line">            count=count-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> Lmn = L - n;</span><br><span class="line">        <span class="keyword">if</span>(Lmn == <span class="number">0</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Lmn<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode *temp = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--2. Add Two Numbers</title>
    <url>/2019/03/28/LeetCode--2-Add-Two-Numbers.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. <a id="more"></a> You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
</blockquote>
<p><strong>Example:</strong> &gt;Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) &gt;Output: 7 -&gt; 0 -&gt; 8 &gt;Explanation: 342 + 465 = 807.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>题目意思即，两个数是用链表按逆序存储的，现在要求两个数的和。实现算法思想即，模拟一个加法器，按位(这里即每一个链表结点)相加，需要设置一个进位标志位。这里只需要注意几种特殊情况即可： 1.两个数不一样长时，需要额外处理； 2.如果最终计算结果超过两个数的长度时，需要多增加一位。 在实现过程中，用一个新的链表来存储计算结果。 在查看讨论区后，发现算法思路大致相同，但是别人的代码更加精简，可以从中借鉴代码的一些简化方法和思想</p>
<h3 id="三代码">三、代码</h3>
<ol type="1">
<li>解法1</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> CF=<span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>; <span class="comment">//每位计算的中间结果</span></span><br><span class="line">        ListNode* result=<span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//新链表存储结果，头结点</span></span><br><span class="line">        ListNode* present=result; <span class="comment">//结果链表当前节点</span></span><br><span class="line">        <span class="comment">//两个数都有节点还未计算是，循环按位计算</span></span><br><span class="line">		<span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//加法结果</span></span><br><span class="line">            tmp=(l1-&gt;val+l2-&gt;val+CF)%<span class="number">10</span>;</span><br><span class="line">            present-&gt;val=tmp;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//进位</span></span><br><span class="line">            CF=(l1-&gt;val+l2-&gt;val+CF)/<span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//链表指针后移</span></span><br><span class="line">			l1=l1-&gt;next;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//如果其中一个数已经加完，不再new新节点</span></span><br><span class="line">            <span class="keyword">if</span>(l1&amp;&amp;l2)</span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                present=present-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//若其中一个数未加完，即比另外一个数要长，需要结合进位进一步处理</span></span><br><span class="line">		<span class="comment">//两个数的处理方式相同</span></span><br><span class="line">        <span class="keyword">while</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//有进位，需要加上进位继续处理</span></span><br><span class="line">            <span class="keyword">if</span>(CF==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                present=present-&gt;next;</span><br><span class="line"></span><br><span class="line">                tmp=(l1-&gt;val+CF)%<span class="number">10</span>;</span><br><span class="line">                present-&gt;val=tmp;</span><br><span class="line"></span><br><span class="line">                CF=(l1-&gt;val+CF)/<span class="number">10</span>;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//若已经没进位，计算结果后面的数与该数剩下的数相同</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=l1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(CF==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                present=present-&gt;next;</span><br><span class="line"></span><br><span class="line">                tmp=(l2-&gt;val+CF)%<span class="number">10</span>;</span><br><span class="line">                present-&gt;val=tmp;</span><br><span class="line"></span><br><span class="line">                CF=(l2-&gt;val+CF)/<span class="number">10</span>;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                present-&gt;next=l2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果两个数都加完了，还有进位，那么new一个新节点，保存该进位</span></span><br><span class="line">        <span class="keyword">if</span>(CF==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            present-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>精简的解法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode preHead(0), *p = &amp;preHead;</span><br><span class="line">        <span class="keyword">int</span> extra = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || extra) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + extra;</span><br><span class="line">            extra = sum / <span class="number">10</span>;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--20. Valid Parentheses</title>
    <url>/2019/04/14/LeetCode--20-Valid-Parentheses.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given a string containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid. <a id="more"></a> An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order.</p>
</blockquote>
<blockquote>
<p>Note that an empty string is also considered valid.</p>
</blockquote>
<p><strong>Example 1:</strong> &gt; Input: "()" &gt; Output: true</p>
<p><strong>Example 2:</strong> &gt; Input: "()<span></span>" &gt; Output: true</p>
<p><strong>Example 3:</strong> &gt; Input: "(]" &gt; Output: false</p>
<p><strong>Example 4:</strong> &gt; Input: "([)]" &gt; Output: false</p>
<p><strong>Example 5:</strong> &gt; Input: "{[]}" &gt; Output: true</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题很经典，也就是让我们判断给定的括号字符串是不是合法的，考察的应该是栈的运用。通过栈就可以很容易的解决问题，遍历字符串： &gt; 1. 若遍历到是左括号<code>'('</code>, <code>'{'</code>, <code>'['</code>，将其推入栈中； &gt; 2. 若遇到的是右括号，在栈顶找是否有匹配的左括号：若匹配成功，将栈顶弹出，继续遍历；若匹配失败，代表括号不合法，返回false. &gt; 3. 遍历完字符串后，检查栈是否为空，若不空，代表不合法。</p>
<p>评论区有一种不使用stack的解法，它是直接在原字符串上模拟一个栈，保证只有左括号在栈内。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="使用stack">使用stack</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; brackets;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'('</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        brackets.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">                    <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'&#123;'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        brackets.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">                    <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'['</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        brackets.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    brackets.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(brackets.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不使用stack">不使用stack</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(top&lt;<span class="number">0</span> || !isMatch(s[top], s[i]))&#123;</span><br><span class="line">                ++top;</span><br><span class="line">                s[top] = s[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                --top;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">'('</span> &amp;&amp; c2 == <span class="string">')'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">'['</span> &amp;&amp; c2 == <span class="string">']'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">'&#123;'</span> &amp;&amp; c2 == <span class="string">'&#125;'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--21. Merge Two Sorted Lists</title>
    <url>/2019/04/14/LeetCode--21-Merge-Two-Sorted-Lists.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. <a id="more"></a> An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order.</p>
</blockquote>
<blockquote>
<p>Note that an empty string is also considered valid.</p>
</blockquote>
<p><strong>Example :</strong> &gt; Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4 &gt; Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>要求合并两个有序链表，新链表是由两个链表结点拼接得到，考察的是对链表的操作。思想是，每次从两个链表上取下一个结点，比较值的大小，较小的结点拼接到新链表后，较大的结点继续进行下一次比较。</p>
<p>这里需要注意的是链表边界的处理，比如对链表头结点的处理方式。可以先单独处理两个链表头结点，确定下新链表的头结点后，再继续继续下面的处理。也可以重新定义一个新的头结点，把链表结点都当做普通结点处理。最后可能有一个链表还有剩余的结点，直接将这些结点拼接到新链表末尾即可。</p>
<p>还可以使用递归的方式求解，但是递归的缺点是，若链表过长，可能会溢出。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="普通方法">普通方法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> || l2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1 == <span class="literal">NULL</span>? l2 : l1;</span><br><span class="line">        </span><br><span class="line">        ListNode* resHead = l1-&gt;val &lt; l2-&gt;val?l1 : l2;</span><br><span class="line">        ListNode* cur = resHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val) l1=l1-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> l2=l2-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;next = l1==<span class="literal">NULL</span>?l2:l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> resHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="定义新的头结点dummy">定义新的头结点dummy</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归">递归</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> || l2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1 == <span class="literal">NULL</span>? l2 : l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l2-&gt;next, l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--25. Reverse Nodes in k-Group</title>
    <url>/2019/04/16/LeetCode--25-Reverse-Nodes-in-k-Group.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. <a id="more"></a> k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
</blockquote>
<p><strong>Example :</strong> &gt; Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<blockquote>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
</blockquote>
<blockquote>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
</blockquote>
<p><strong>Note :</strong> - Only constant extra memory is allowed. - You may not alter the values in the list's nodes, only nodes itself may be changed.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题又是对上一题的推广，leetcode这种由简入难的题挺多的。这次是要求对链表的K个结点反转，这里的K可以是任意的。我们可以依旧按照上一题的那种方式，将链表分为若干段：每次从链表上“摘下”k个结点的链表，把这个链表进行反转后，再放回原来的位置。对于链表的反转操作，我们可以利用构建链表时用的头插法来进行。这里在解决时碰到几个问题： &gt; 1. 若剩下链表长度不够K时，我们不需要对这段链表进行反转，所以我们需要提前计算出链表的长度 &gt; 2. 需要记录下反转后的最后一个结点，用于在放回原链表时，可以和下一段连接起来。</p>
<p>还有一种方法，实现如下，这种方法思想上大致相同，这种方法不用单独计算链表长度，而是边计算长度边处理链表，每当数到k个结点时就反转一次。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="解法1">解法1</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.next = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* count = head;</span><br><span class="line">        <span class="keyword">int</span> Len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count)</span><br><span class="line">        &#123;</span><br><span class="line">            count=count-&gt;next;</span><br><span class="line">            Len++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* pre = &amp;dummy;</span><br><span class="line">        ListNode* last = head;</span><br><span class="line">        ListNode* temp = last;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        <span class="keyword">while</span>(Len &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//下一个待取的结点</span></span><br><span class="line">                next = temp-&gt;next;</span><br><span class="line">                <span class="comment">//插入头部</span></span><br><span class="line">                temp-&gt;next = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = temp;</span><br><span class="line">                temp = next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = last;last=next;</span><br><span class="line">            Len-=k;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = last;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法2">解法2</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *pre = dummy, *cur = head;</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; cur; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % k == <span class="number">0</span>) &#123;</span><br><span class="line">                pre = reverseOneGroup(pre, cur-&gt;next);</span><br><span class="line">                cur = pre-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseOneGroup</span><span class="params">(ListNode* pre, ListNode* next)</span> </span>&#123;</span><br><span class="line">        ListNode *last = pre-&gt;next, *cur = last-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur != next) &#123;</span><br><span class="line">            last-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            cur = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--26. Remove Duplicates from Sorted Array</title>
    <url>/2019/04/17/LeetCode--26-Remove-Duplicates-from-Sorted-Array.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given a sorted array nums, remove the duplicates <strong>in-place</strong> such that each element appear only once and return the new length. <a id="more"></a> Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
</blockquote>
<p><strong>Example 1:</strong> &gt; Given nums = [1,1,2],</p>
<blockquote>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p>
</blockquote>
<blockquote>
<p>It doesn't matter what you leave beyond the returned length.</p>
</blockquote>
<p><strong>Example 2:</strong> &gt; Given nums = [0,0,1,1,1,2,2,3,3,4],</p>
<blockquote>
<p>Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</p>
</blockquote>
<blockquote>
<p>It doesn't matter what values are set beyond the returned length.</p>
</blockquote>
<p><strong>Clarification :</strong></p>
<blockquote>
<p>Confused why the returned value is an integer but your answer is an array?</p>
</blockquote>
<blockquote>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
</blockquote>
<blockquote>
<p>Internally you can think of this:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题要求去除数字中的冗余项，而且只能使用O(1)的空间复杂度。看题目说明得知，我们返回的是处理后数组的长度，我们只需要保证数组前面有效部分的值，至于超出有效部分的值我们无需关心。</p>
<p>那么就可以很好处理，我们继续下当前最后一个有效位的位置，等到下一次遇到不重复的数时，将该数字移动到下一个有效位，然后更新有效位继续扫描数组。当完成一遍扫描后，所有不重复的值都移动到了数组的前端有效部分。</p>
<h3 id="三代码">三、代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[last<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[last] = nums[i];</span><br><span class="line">                last++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--24. Swap Nodes in Pairs</title>
    <url>/2019/04/16/LeetCode--24-Swap-Nodes-in-Pairs.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head. <a id="more"></a> You may not modify the values in the list's nodes, only nodes itself may be changed.</p>
</blockquote>
<p><strong>Example :</strong> &gt; Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>要求交换链表中相邻两个结点的位置，并且要求不能修改结点的值，也就是只能将结点整个交换过去。我的思路很简单，从链表上依次“摘下”两个结点，交换其位置后再将得到的结果拼接回链表，题目并不难，主要是对链表的操作。可以按下面的图来表示(图参考自<a href="https://leetcode.com/problems/swap-nodes-in-pairs/discuss/11183/C%2B%2B-solution-with-graph-explanation." target="_blank" rel="noopener" title="C++ solution with graph explanation.">C++ solution with graph explanation.</a>) /*</p>
<pre><code>   node1 = pre-&gt;next;node2 = node1-&gt;next
   #----&gt;@----&gt;@----&gt;@----&gt;@----&gt;@----&gt;@
               ^     ^     ^
               pre   node1 node2

  1. pre-&gt;next = node2
                __________
               /          \
   #----&gt;@----&gt;@     @----&gt;@----&gt;@----&gt;@
               ^     ^     ^
               pre   node1 node2

  2. node1-&gt;next = node2-&gt;next
                __________
               /          \
   #----&gt;@----&gt;@     @     @----&gt;@----&gt;@
                      \_________/
               ^     ^     ^
               pre   node1 node2

  3. node2-&gt;next = node1
               __________
              /          \
  #----&gt;@----&gt;@     @&lt;----@     @----&gt;@
                     \_________/
              ^     ^     ^
              pre   node1 node2

  4. pre = node1;
               __________
              /          \
  #----&gt;@----&gt;@     @&lt;----@     @----&gt;@
                     \_________/
                    ^
                    pre</code></pre>
<p>*/</p>
<p>同样的思想也可以用递归来实现</p>
<h3 id="三代码">三、代码</h3>
<h4 id="迭代">迭代</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode *pre = &amp;dummy;</span><br><span class="line">        ListNode *node1,*node2;</span><br><span class="line">        <span class="keyword">while</span>(pre)</span><br><span class="line">        &#123;</span><br><span class="line">            node1 = pre-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(node1&amp;&amp;node1-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                node2 = node1-&gt;next;</span><br><span class="line">                pre-&gt;next = node2;</span><br><span class="line">                node1-&gt;next = node2-&gt;next;</span><br><span class="line">                node2-&gt;next = node1;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归">递归</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !(head-&gt;next))</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *res = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(res-&gt;next);</span><br><span class="line">        res-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--22. Generate Parentheses</title>
    <url>/2019/04/14/LeetCode--22-Generate-Parentheses.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. <a id="more"></a> For example, given n = 3, a solution set is: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &quot;((()))&quot;,</span><br><span class="line">    &quot;(()())&quot;,</span><br><span class="line">    &quot;(())()&quot;,</span><br><span class="line">    &quot;()(())&quot;,</span><br><span class="line">    &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="二解题思路">二、解题思路</h3>
<p>以前做过类似的题，也就是求一组数字可以通过栈得到的所有合法排序。当时的做法是，先求出所有可能的排序，然后判断每一种排序的合法性。获取全排序可以通过函数next_permutation()做到： &gt;C++ STL中提供了std::next_permutation与std::prev_permutation可以获取数字或者是字符的全排列，其中std::next_permutation提供升序、std::prev_permutation提供降序。</p>
<p>所以结合前面有一题判断括号是否有效。最开始的想法是将括号全排序后，找到有效的括号排列，放入结果集。遍历完所有可能后，就可以找到最终的结果了。</p>
<p>但是这种方法效率很低。另一种方法是，使用递归回溯，每次生成合法的括号序列加入结果集中，这种方法避免了生成无效排序。 &gt; 长度为 n 的序列就是 '(' 加上所有长度为 n-1 的序列，以及 ')' 加上所有长度为 n-1 的序列。只有在保证序列仍然保持有效时才添加 '(' or ')'，我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号。</p>
<p>还有一种方法，LeetCode上称之为Closure number，但感觉很像分治。我们可以把一个合法的括号字符串看做一个闭包，它必然起于左括号止于右括号，且每个合法括号串都可以从某个位置分为两个同样合法的括号串（包括空串），因此对于给定的n所可能构造的所有括号串都可以一步步划分为两个子闭包并解构（去掉头尾的一对左右括号）直到最小闭包——空串为止。基于以上分析，我们就可以从空串开始逆向一步步对两个子闭包之一构造新的闭包（在头尾各添加一个左/右括号）然后合并。这种方法还不是特别懂，只是跟着算法用c++重写了一遍。</p>
<p>参考文献： [1] <a href="https://www.cnblogs.com/aiguona/p/7304945.html" target="_blank" rel="noopener" title="C++ STL 全排列函数详解">C++ STL 全排列函数详解</a> [2] <a href="https://blog.csdn.net/weixin_34216107/article/details/86906251" target="_blank" rel="noopener" title="LeetCode Record C++">LeetCode Record C++</a></p>
<h3 id="三代码">三、代码</h3>
<h4 id="全排序后筛选">全排序后筛选</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; brackets;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!brackets.empty() &amp;&amp; brackets.top()==<span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    brackets.pop();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> brackets.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(brackets.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> parentheses = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) parentheses+=<span class="string">"()"</span>;</span><br><span class="line">        </span><br><span class="line">        sort(parentheses.begin(), parentheses.end());</span><br><span class="line">        result.push_back(parentheses);</span><br><span class="line">        <span class="keyword">while</span>(next_permutation(parentheses.begin(), parentheses.end()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(parentheses)) result.push_back(parentheses);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="回溯法">回溯法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result, <span class="built_in">string</span> cur, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.length() == max*<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(open &lt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrack(result, cur+<span class="string">"("</span>, open+<span class="number">1</span>, close, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(close &lt; open)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrack(result, cur+<span class="string">")"</span>, open, close+<span class="number">1</span>, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        backtrack(result, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="闭包数">闭包数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> left:generateParenthesis(c))</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> right:generateParenthesis(n<span class="number">-1</span>-c))</span><br><span class="line">                        result.push_back(<span class="string">"("</span>+left+<span class="string">")"</span>+right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--28. Implement strStr()</title>
    <url>/2019/04/17/LeetCode--28-Implement-strStr.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Implement strStr(). <a id="more"></a> Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
</blockquote>
<p><strong>Example 1:</strong> &gt; Input: haystack = "hello", needle = "ll" &gt; Output: 2</p>
<p><strong>Example 2:</strong> &gt; Input: haystack = "aaaaa", needle = "bba" &gt; Output: -1</p>
<p><strong>Clarification :</strong></p>
<blockquote>
<p>What should we return when needle is an empty string? This is a great question to ask during an interview.</p>
</blockquote>
<blockquote>
<p>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().</p>
</blockquote>
<h3 id="二解题思路">二、解题思路</h3>
<p>这个题要求实现strStr()函数。实际上就是个字符串匹配过程，要求从haystack中寻找子串needle，若找到，返回子串开始位置；否知返回-1.</p>
<p>想到的有两种解法，一种是直接暴力求解，另一种是用KMP算法。</p>
<p>首先实现了暴力求解的算法。将haystack所有与needle一样长的子串进行比较，若成功找到，就返回当前子串其实位置；若最终未找到，返回-1.这种方法实现后，发现效果还算不错，没有想象的那么差。</p>
<p>之后实现了KMP算法，KMP算法可以利用next数组加速匹配过程。 &gt;假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 &gt; - 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； &gt; - 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值.</p>
<p>这里重点是构造next数组，next数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next[j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀。</p>
<p>参考文献： [1] <a href="https://www.cnblogs.com/yjiyjige/p/3263858.html" target="_blank" rel="noopener">（原创）详解KMP算法</a> [2] <a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" target="_blank" rel="noopener">很详尽KMP算法</a></p>
<h3 id="三代码">三、代码</h3>
<h4 id="暴力算法1">暴力算法1</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.size(), n = needle.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m - n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="暴力算法2">暴力算法2</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.size(), n = needle.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m - n; i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> substr = haystack.substr(i, n);</span><br><span class="line">            <span class="keyword">if</span> (substr == needle) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="kmp算法">KMP算法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_KMP_Next(<span class="built_in">string</span> s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(s.length());</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>, k=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; s.length()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">-1</span> || s[j] == s[k])</span><br><span class="line">            &#123;</span><br><span class="line">                next[++j] = ++k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = haystack.length(), n = needle.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = get_KMP_Next(needle);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || haystack[i] == needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j == needle.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--3. Longest Substring Without Repeating Characters</title>
    <url>/2019/03/28/LeetCode--3-Longest-Substring-Without-Repeating-Characters.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters. <a id="more"></a></p>
</blockquote>
<p><strong>Example1:</strong> &gt;Input: "abcabcbb" &gt;Output: 3 &gt;Explanation: The answer is "abc", with the length of 3.</p>
<p><strong>Example2:</strong> &gt;Input: "bbbbb" &gt;Output: 1 &gt;Explanation: The answer is "b", with the length of 1.</p>
<p><strong>Example3:</strong> &gt;Input: "pwwkew" &gt;Output: 3 &gt;Explanation: The answer is "wke", with the length of 3. - Note that the answer must be a substring, "pwke" is a subsequence and not a substring.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>题目要求的是，最长不含重复元素的字串。 最开始的想法是，用一个向量数组，存储以每一个位置为终点，包含该位置字符在内的最长不含重复元素的字串的长度，相当于一个dp的算法。数组更新方式是：用一个二重循环，外循环是从第一个字符到最后一个字符一次遍历；内循环用于判断，以该位置字符为终点，可以得到的最长不重复字串有多长。该算法成功解决了问题。 后来继续分析程序，发现可以不使用向量数组，因为数组内的每一个元素的值只需要访问一次，直接用一个变量保存即可。用此方法改进后，速度和空间都得到了优化。 &gt;讨论区有另外一种更优化的解法，代码中用vector生成256个-1，用来存储每个字符上一次出现的下标。代码比较抽象，理解如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v(<span class="number">256</span>,<span class="number">-1</span>); <span class="comment">//构造字符串的容器。初始化为-1，意思是暂时不存在这个字符。</span></span><br><span class="line">start=<span class="number">-1</span>; <span class="comment">//start用来记录子串开始的位置，初始化为-1，表示没有开始构造子字符串。</span></span><br><span class="line"><span class="keyword">if</span>(v[s[i]]&gt;start)<span class="comment">//已经在该字符出现之前出现过相同的字符了，那么就将start也就是开始位置标记为上次该字符的出现位置。</span></span><br><span class="line">	start=v[s[i]]; </span><br><span class="line">v[s[i]]=i; <span class="comment">//更新字符在容器中对应的下标</span></span><br><span class="line">ans=max(ans,i-start); <span class="comment">//i-start的意思是，当前for循环的i（也就是子字符串的结束字符）减去子字符串结束的字符的下标位置，结果就是子字符串的长度。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="三代码">三、代码</h3>
<ol type="1">
<li>解法1(使用了向量数组)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="comment">//空字符串，直接返回0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>; <span class="comment">//非空字符串，最短为1</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; longestsub; <span class="comment">//每个位置的最长不重复字串长度</span></span><br><span class="line">        longestsub.push_back(<span class="number">1</span>); <span class="comment">//初始化第一个位置</span></span><br><span class="line">		<span class="comment">//遍历每一个位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            longestsub.push_back(<span class="number">1</span>);</span><br><span class="line">			<span class="comment">//从上一个位置的最长不重复字串为起点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-longestsub[i<span class="number">-1</span>];j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="comment">//没有重复，继续计算</span></span><br><span class="line">                <span class="keyword">if</span>(s[j]!=s[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    longestsub[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//有重复，从1开始重新计数</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    longestsub[i]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//记录最长长度</span></span><br><span class="line">            <span class="keyword">if</span>(longestsub[i]&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                max=longestsub[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>不使用数组</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> Longest=<span class="number">1</span>,Last=<span class="number">1</span>;<span class="comment">//记录最长长度和上一字符的最长不重复字串长度</span></span><br><span class="line">        <span class="comment">//vector&lt;int&gt; longestsub;</span></span><br><span class="line">        <span class="comment">//longestsub.push_back(1);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//longestsub.push_back(1);</span></span><br><span class="line">            <span class="keyword">int</span> present=<span class="number">1</span>;<span class="comment">//计算当前位置最长不重复字串长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-Last;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j]!=s[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    present++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    present=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Longest=max(Longest,present);</span><br><span class="line">            Last=present;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.解法3</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict[s[i]] &gt; start)</span><br><span class="line">                start = dict[s[i]];</span><br><span class="line">            dict[s[i]] = i;</span><br><span class="line">            maxLen = max(maxLen, i - start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--23. Merge k Sorted Lists</title>
    <url>/2019/04/16/LeetCode--23-Merge-k-Sorted-Lists.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. <a id="more"></a></p>
</blockquote>
<p><strong>Example :</strong> &gt; Input: &gt;[ &gt; 1-&gt;4-&gt;5, &gt; 1-&gt;3-&gt;4, &gt; 2-&gt;6 &gt;] &gt;Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>前面有一题是合并两个有序的链表，这道题就相当于进一步泛化。</p>
<p>考虑到我们已经有了合并两个链表的方法，那么我们就可以把这个问题分解。每次把链表数组中的两个链表合并，直到只剩下一个链表为之。这时这个剩下的链表就是我们需要的结果。实现后的确解决了问题，但是效率不高。</p>
<p>进一步思考，既然合并链表的过程都是类似的，那么是不是可以用分治来做，将合并K个链表分解为合并两个子问题的结果——合并K/2个链表。这样逐步分解下去，可以划分为许多更容易解决的子问题。结合递归实现后，效率得到了极大提升，分治算法的思想果然厉害。细想起来，归并排序的思想似乎也是这样。</p>
<p>在题解中发现还有一种有意思的解法，使用priority_queue求解。由priority_queue的特性，我们可以设置在队列头部总是一个值最小的结点，那么我们就可以把所有链表第一个结点输入这个队列中。每次从队列得到最小的结点放入新链表，将该节点对应链表的下一个结点放入队列。这个重复不断进行，最终可以得到一个新的有序链表。这时候的priority_queue其实相当于一个小顶堆。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="逐一合并">逐一合并</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode* newList = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(lists.size() &gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists.size() == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                newList = lists.back();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* list1 = lists.back();</span><br><span class="line">                lists.pop_back();</span><br><span class="line">                ListNode* list2 = lists.back();</span><br><span class="line">                lists.pop_back();</span><br><span class="line">                newList = mergeTwoLists(list1,list2);</span><br><span class="line">                lists.push_back(newList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="分治">分治</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKL</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end - begin == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(lists[begin],lists[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(end == begin) <span class="keyword">return</span> lists[begin];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(end &lt; begin) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (begin+end)/<span class="number">2</span>;</span><br><span class="line">            ListNode* list1 = mergeKL(lists, begin, mid);</span><br><span class="line">            ListNode* list2 = mergeKL(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(list1, list2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeKL(lists, <span class="number">0</span>, lists.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="priority_queue解法">priority_queue解法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp=[](ListNode* a, ListNode* b) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;ListNode*,<span class="built_in">vector</span>&lt;ListNode*&gt;,<span class="keyword">decltype</span>(cmp)&gt; pq(cmp);</span><br><span class="line">        ListNode dummy(0),*p=&amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (ListNode *node:lists) <span class="keyword">if</span> (node) pq.push(node);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.top()-&gt;next) pq.push(pq.top()-&gt;next);</span><br><span class="line">            p-&gt;next=pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--27. Remove Element</title>
    <url>/2019/04/17/LeetCode--27-Remove-Element.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given an array <strong>nums</strong> and a value <strong>val</strong>, remove all instances of that value in-place and return the new length. <a id="more"></a> Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
</blockquote>
<blockquote>
<p>The order of elements can be changed. It doesn't matter what you leave beyond the new length.</p>
</blockquote>
<p><strong>Example 1:</strong> &gt; Given nums = [3,2,2,3], val = 3,</p>
<blockquote>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
</blockquote>
<blockquote>
<p>It doesn't matter what you leave beyond the returned length.</p>
</blockquote>
<p><strong>Example 2:</strong> &gt; Given nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<blockquote>
<p>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</p>
</blockquote>
<blockquote>
<p>Note that the order of those five elements can be arbitrary.</p>
</blockquote>
<blockquote>
<p>It doesn't matter what values are set beyond the returned length.</p>
</blockquote>
<p><strong>Clarification :</strong></p>
<blockquote>
<p>Confused why the returned value is an integer but your answer is an array?</p>
</blockquote>
<blockquote>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
</blockquote>
<blockquote>
<p>Internally you can think of this:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题与上一题类似，不够这次要求删除数组中指定的值。思想还是一样的： &gt; 设置一个有效位last，遍历数组，遇到不等于val的值，就将它移动到last+1，然后更新last &gt; 当遍历完数组后，不等于val的值就都移动到了数组前端有效部分。</p>
<p>但是这样会移动大量的元素，考虑是不是可以只移动值等于val的元素，由于数组的顺序可以改变，那么我们可以: &gt; 将等于val的元素与最后一个值不等于val的元素交换</p>
<p>这样当遍历完成后，所有等于val的值都被移动到了数组末尾无效部分。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="解1">解1</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=val)    nums[last++]=nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解2">解2</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, end=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = nums[end--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--31. Next Permutation</title>
    <url>/2019/04/22/LeetCode--31-Next-Permutation.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers. <a id="more"></a> If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
</blockquote>
<blockquote>
<p>The replacement must be in-place and use only constant extra memory.</p>
</blockquote>
<blockquote>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
</blockquote>
<pre><code>1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1</code></pre>
<h3 id="二解题思路">二、解题思路</h3>
<p>前不久好像刚在一道题用过这个函数，现在就遇到实现这个函数了。对于全排列的具体实行过程不是很熟悉，没有什么思路。在查看题解后，发现对于这个问题，14世纪就有人已经提出了简单的解法——<a href="https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order" target="_blank" rel="noopener" title="Generation in lexicographic order">Generation in lexicographic order</a>，算法思路如下： &gt; 1. 从右到左，找到第一对连续的数a[i]和a[i-1]，使得满足a[i] &gt; a[i-1];这样a[i]右边的序列就是一个降序的排列（这个序列理论上没有下一个排列，题目中让这种情况的下一个变成了第一个）。如果这一步没有找到上述连续数对，直接将数列反转即可得到最终结果。 &gt; 2. 从 a[i] 开始的降序排序中找到刚好大于a[i-1]的数 a[k]，将两个数进行交换。 &gt; 3. 将降序的数列a[i:]反转，得到下一个排列。</p>
<p><a href="https://imgchr.com/i/EkLSDe" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/22/EkLSDe.gif" alt="EkLSDe.gif" /></a></p>
<p>讨论区有一种调用库实现上述算法的代码。代码很短，从里面学到了一些STL的函数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = is_sorted_until(nums.rbegin(), nums.rend());</span><br><span class="line">    <span class="keyword">if</span> (i != nums.rend())</span><br><span class="line">        swap(*i, *upper_bound(nums.rbegin(), i, *i));</span><br><span class="line">    reverse(nums.rbegin(), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> &gt; is_sorted_until(), 它返回序列中“失序”的元素。 如果整个序列被排序（根据谓词），那么它将返回最后一个。</p>
<blockquote>
<p>rbegin 和 rend, 反向迭代器, 分别返回指向容器尾元素和首元素前一位置的反向迭代器。</p>
</blockquote>
<blockquote>
<p>upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的<strong>地址</strong>，不存在则返回end。lower_bound( begin,end,num)类似，不过它找的是第一个小于等于num的数。</p>
</blockquote>
<h3 id="三代码">三、代码</h3>
<h4 id="解法1">解法1</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), i, k;</span><br><span class="line">        <span class="keyword">for</span>(i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reverse(nums.begin(), nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(k = n - <span class="number">1</span>; k &gt; i; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            swap(nums[i<span class="number">-1</span>], nums[k]);</span><br><span class="line">            reverse(nums.begin() + i, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法2">解法2</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = is_sorted_until(nums.rbegin(), nums.rend());</span><br><span class="line">    <span class="keyword">if</span> (i != nums.rend())</span><br><span class="line">        swap(*i, *upper_bound(nums.rbegin(), i, *i));</span><br><span class="line">    reverse(nums.rbegin(), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--33. Search in Rotated Sorted Array</title>
    <url>/2019/04/23/LeetCode--33-Search-in-Rotated-Sorted-Array.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. <a id="more"></a> (i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>
</blockquote>
<blockquote>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
</blockquote>
<blockquote>
<p>You may assume no duplicate exists in the array.</p>
</blockquote>
<blockquote>
<p>Your algorithm's runtime complexity must be in the order of O(log n).</p>
</blockquote>
<p><strong>Example 1:</strong> &gt; Input: nums = [4,5,6,7,0,1,2], target = 0 &gt; Output: 4</p>
<p><strong>Example 2:</strong> &gt; Input: nums = [4,5,6,7,0,1,2], target = 3 &gt; Output: -1</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>看见要求算法复杂度O(log n)，并且数组有序（轮转有序），最先想到的是，用二分查找。</p>
<p>但是二分法需要进行修改，不能直接使用。第一中方法是，对二分查早进行改进，使它符合这道题： &gt; 二分搜索法的关键在于获得了中间数后，判断下面要搜索左半段还是右半段，我们可以观察到一种规律，如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了。</p>
<p>另一种方法是，我们还是使用原来的二分查找算法。不过我们需要先找到数组轮转的位置。如对于数组 <code>[4,5,6,7,0,1,2]</code>，可以找到轮转pivot是7，下标是3。根据pivot，可以把数组分为真正有序的两部分，判断target可能出现在哪部分，再继续用原来的二分查找就可以得到结果了。这里寻找pivot也可以用二分查找实现，复杂度依旧是O(log n)。</p>
<p>可以用异或来编写判断语句使代码更精简，代码如下。</p>
<p>参考： <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14419/" target="_blank" rel="noopener">Pretty short C++/Java/Ruby/Python</a> <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14435/Clever-idea-making-it-simple" target="_blank" rel="noopener">Clever idea making it simple</a></p>
<h3 id="三代码">三、代码</h3>
<h4 id="修改后的二分查找">修改后的二分查找</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="寻找pivot">寻找pivot</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPivot</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])</span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low == high &amp;&amp; nums[low] == target) <span class="keyword">return</span> low;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = findPivot(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target &lt;= nums[pivot] &amp;&amp; target &gt;= nums[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(nums, <span class="number">0</span>, pivot, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(nums, pivot+<span class="number">1</span>, nums.size()<span class="number">-1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用异或">使用异或</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="keyword">int</span>(nums.size()) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((nums[<span class="number">0</span>] &gt; target) ^ (nums[<span class="number">0</span>] &gt; nums[mid]) ^ (target &gt; nums[mid]))</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hi = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo == hi &amp;&amp; nums[lo] == target ? lo : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--32. Longest Valid Parentheses</title>
    <url>/2019/04/23/LeetCode--32-Longest-Valid-Parentheses.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given a string containing just the characters <code>'('</code> and <code>')'</code>, find the length of the longest valid (well-formed) parentheses substring. <a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong> &gt; Input: "(()" &gt; Output: 2 &gt; Explanation: The longest valid parentheses substring is "()"</p>
<p><strong>Example 2:</strong> &gt; Input: ")()())" &gt; Output: 4 &gt; Explanation: The longest valid parentheses substring is "()()"</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>给定了一个括号的字符串，求最长有效子串的长度。</p>
<p>首先就是暴力解法，逐个字符遍历字符串，判断从当前字符开始的最大有效括号长度，若大于已经找到的最大有效长度，则更新最大有效长度。遍历完成后，也就找到了最长有效长度。这种方法思路简单而且没有超时，但是效率很低。</p>
<p>主要是因为整个过程会有许多重复的判断。这个问题可以用动态规划来求解：定义一个数组dp，保存以字符串中第i个字符为结尾的最长有效子串的长度。由于有效字符串是以 ')' 结束的，所以 '(' 必定不构成有效子串。所以我们将dp初始化为全0，当遇到 ')' 时才更新dp数组，更新规则如下： &gt; 1. 若s[i] == ')' 且 s[i-1] == '('，即形如“......()”，更新dp[i] = dp[i - 2] + 2 &gt; 2. 若s[i] == ')' 且 s[i-1] == ')'，即形如"......))"，此时若s[i - dp[i-1] - 1] == '('，更新dp[i] = dp[i - 1] + dp[i - dp[i-1] - 2] + 2</p>
<p>每次更新dp后，判断当前更新后的值是否比已经找到的最长有效长度大，若是则更新最长有效长度。当dp更新完成后，也就找到了最长有效长度。这种方法只需要扫描一遍字符串，避免了重复的判断。</p>
<p>除了这两种方法外，还有两种算法： &gt; 1. 使用栈 &gt; 初始化一个栈，先在栈中存入-1。之后遍历给定的字符串，判断当前扫描的字符串是不是有效的，同时更新最长有效长度。 &gt; 1) 若遇到 '('，将其下标推入栈内 &gt; 2) 若遇到 ')'，从栈顶弹出一个元素后，用当前元素下标减去剩下栈顶的元素，得到一个当前元素的有效子串长度。若从栈顶弹出元素后，栈空，就将当前元素的下标放入栈内继续遍历。 &gt; 遍历完字符串后，找到最长有效长度。</p>
<blockquote>
<ol start="2" type="1">
<li>不使用额外空间 用两个计数器 left 和 right ，记录当前遇到的有效左括号数和右括号数。分两遍扫描字符串：
<ol type="1">
<li>先从左向右扫描，遇到 "(" 就增加left，遇到 ')' 就增加right，当left和right相等时，得到一个有效子串，计算该有效子串长度并更新最长有效长度。若right大于left，将left和right都置0，继续扫描。</li>
<li>用相同的步骤，从右向左再扫描一编。</li>
</ol></li>
</ol>
</blockquote>
<h3 id="三代码">三、代码</h3>
<h4 id="暴力解法">暴力解法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur = <span class="number">0</span>; cur &lt; s.length(); cur++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> open = <span class="number">0</span>, close = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=cur; i&lt;s.length(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    open++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ++close;</span><br><span class="line">                    <span class="keyword">if</span>(close == open)</span><br><span class="line">                        longest = max(longest, i-cur+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(close &gt; open)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(longest &gt;= (s.length() - cur))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="dp算法">DP算法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.length(), <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = i<span class="number">-2</span> &gt;= <span class="number">0</span> ? dp[i<span class="number">-2</span>]+<span class="number">2</span> : <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i - dp[i<span class="number">-1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i - dp[i<span class="number">-1</span>] - <span class="number">1</span>] == <span class="string">'('</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>] + <span class="number">2</span> + ((i-dp[i<span class="number">-1</span>]<span class="number">-2</span> &gt;= <span class="number">0</span>)?dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]:<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                longest = max(dp[i], longest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用栈">使用栈</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">stack</span>.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> curlen = i - <span class="built_in">stack</span>.top();</span><br><span class="line">                    longest = max(longest, curlen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不使用额外空间两遍扫描">不使用额外空间，两遍扫描</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>, close = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>) open++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++close;</span><br><span class="line">                <span class="keyword">if</span>(close == open)</span><br><span class="line">                    longest = max(longest, <span class="number">2</span>* open);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(close &gt; open)</span><br><span class="line">                &#123;</span><br><span class="line">                    open = close = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        open = close = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (<span class="keyword">int</span>)s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) close++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++open;</span><br><span class="line">                <span class="keyword">if</span>(close == open)</span><br><span class="line">                    longest = max(longest, <span class="number">2</span>* open);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(open &gt; close)</span><br><span class="line">                &#123;</span><br><span class="line">                    open = close = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--30. Substring with Concatenation of All Words</title>
    <url>/2019/04/22/LeetCode--30-Substring-with-Concatenation-of-All-Words.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in <strong>s</strong> that is a concatenation of each word in <strong>words</strong> exactly once and without any intervening characters. <a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong> &gt; Input:      s = "barfoothefoobarman",      words = ["foo","bar"] &gt; Output: [0,9] &gt; Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively. &gt; The output order does not matter, returning [9,0] is fine too.</p>
<p><strong>Example 2:</strong> &gt; Input:      s = "wordgoodgoodgoodbestword",      words = ["word","good","best","word"] &gt; Output: []</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题让我们求串联所有单词的子串，就是说给定一个长字符串，再给定几个长度相同的单词，让从长字符串中找出串联给定所有单词的子串的起始位置。</p>
<p>最开始以为单词不重复，所以最初的想法是。用一个map来记录每次单词上一次出现的位置，以及用indexStart记录当前子串开始位置。之后不断检查，若检测到单词不在words内或者单词上次出现在indexStart之后即重复了，就重新进行下一次检查。但是words内单词是可以重复的，所以这种方法行不通，需要记录单词出现的次数。</p>
<p>所以要用到两个map，第一个map内存入words内每个单词可以出现的次数，第二个map存储当前扫描的子串内，单词已经出现的次数。从头开始扫描字符串，每次得到一个单词，看其是否在word内以及出现次数是否在要求范围内，如果不满足，则进行下一次扫描。如果正好匹配完给定单词集里所有的单词，则把开始地址存入结果中。</p>
<p>算法可以继续优化，我们不必每次都从头开始判断每个单词。可以设置一个单词组成字符串大小的滑动窗口。 &gt; 若当前判断的单词超过限制的出现次数时导致匹配失败，将窗口后移到该子串中该单词第一个出现的位置之后； &gt; 若当前判断的单词不在words中导致匹配失败，将窗口完全移动到该单词之后。 &gt; 若判断到窗口最后的位置且匹配成功，记录下当前窗口的开始位置，将窗口后移一个单词长度，继续下一次判断。</p>
<p>我们同时也可以减少到只使用一个map，map记录单词可以出现的次数，没出现一次就减一。在窗口移动时，我们可以同时恢复现场。这种使用滑动窗口的方法，省去了大量重复的或者不必要的判断，所以算法性能得到极大提升。</p>
<p>查看评论区发现还有一种解法，这种解法思想很巧妙，有些复杂也不是特别懂，在这写下大致思想： &gt; 1. 定义一个hash函数，将每个单词映射到一个唯一的值上 &gt; 2. 用定义好的hash函数，计算出words总的hash值words_hashsum &gt; 3. 还是使用一个窗口，先计算第一个窗口内对应字符串的hashsum,与words的hash_sum比较，若相等则把窗口开始位置记录下来。 &gt; 4. 窗口后移一个位置，继续计算其hashsum进行判断。</p>
<p>这种方法尽管最后能求解ac，但感觉可能存在问题，比如两个单词 a, c的hash值分别为1 3, b的hash值为2, 那么可能(a,c)的组合和(b,b)的组合hashsum相等，所以是有可能会出错的。</p>
<p>参考： <a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/13791/" target="_blank" rel="noopener">My 24ms C++ solution (O(N) time, using an unordered_map)</a> <a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/192123/" target="_blank" rel="noopener">O(n) C++ solution, 8ms, beats 100%</a> <a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/13700/" target="_blank" rel="noopener">My AC c++ code, O(n) complexity, 26ms</a></p>
<h3 id="三代码">三、代码</h3>
<h4 id="两个哈希表">两个哈希表</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordfound,counts;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.empty() || words.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> wordsize = words.size(), wordlen = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> slen = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words) counts[word]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= slen - wordsize * wordlen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; wordsize; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> temp = s.substr(i + j*wordlen, wordlen);</span><br><span class="line">                <span class="keyword">if</span>(counts[temp] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                wordfound[temp]++;</span><br><span class="line">                <span class="keyword">if</span>(wordfound[temp] &gt; counts[temp]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == wordsize) res.push_back(i);</span><br><span class="line">            wordfound.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="滑动窗口的方法">滑动窗口的方法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; counts;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.empty() || words.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> wordsize = words.size(), wordlen = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> slen = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(slen &lt; wordsize * wordlen) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start, cur, founded;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:words) counts[word]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordlen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            start = cur = i;</span><br><span class="line">            founded = wordsize;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(start &lt;= slen - wordsize * wordlen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//单词不在words内,整个窗口后移到后一个单词</span></span><br><span class="line">                <span class="keyword">if</span>(counts.count(s.substr(cur,wordlen)) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    founded = wordsize;</span><br><span class="line">                    <span class="keyword">for</span>(;start != cur; start += wordlen)</span><br><span class="line">                        counts[s.substr(start,wordlen)]++;</span><br><span class="line">                    start += wordlen;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(counts[s.substr(cur,wordlen)] == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//单词出现次数超过限制,窗口移动到该单词第一次出现的下一个位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(;s.substr(start,wordlen) != s.substr(cur,wordlen);start += wordlen)</span><br><span class="line">                    &#123;</span><br><span class="line">                        counts[s.substr(start,wordlen)]++;</span><br><span class="line">                        founded++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    start += wordlen;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    counts[s.substr(cur,wordlen)]--;</span><br><span class="line">                    <span class="keyword">if</span>(--founded == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(start);</span><br><span class="line">                        counts[s.substr(start,wordlen)]++;</span><br><span class="line">                        start += wordlen;</span><br><span class="line">                        founded++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += wordlen;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(;start&lt;cur;start+=wordlen)</span><br><span class="line">                counts[s.substr(start,wordlen)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="hash函数">hash函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; retVal;</span><br><span class="line">        <span class="keyword">if</span> (words.size()&lt;<span class="number">1</span> || s.size()&lt;<span class="number">1</span>) <span class="keyword">return</span> retVal;</span><br><span class="line">        <span class="comment">// Hash all the words seperately then add them together to get a magic number</span></span><br><span class="line">        <span class="built_in">std</span>::hash&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; hash_fn;</span><br><span class="line">        <span class="keyword">size_t</span> magicNumber = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.size(); i++) &#123;</span><br><span class="line">            magicNumber += hash_fn(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> wordLength = words[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// Concatenated substring will be a given length</span></span><br><span class="line">        <span class="keyword">int</span> minimumSize = words.size()*wordLength;</span><br><span class="line">        <span class="comment">// We do a sliding window calculation for each 'offset' a pattern might have</span></span><br><span class="line">        <span class="comment">// This is faster than re-hashing the entire window because we can just drop the least recently hashed value</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> startOffset=<span class="number">0</span>; startOffset&lt;wordLength; startOffset++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">size_t</span> hashSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> minimum = <span class="number">0L</span>L-minimumSize-startOffset+s.size();</span><br><span class="line">            <span class="comment">// This means that the requested offset does not leave us with enough characters in the string!</span></span><br><span class="line">            <span class="keyword">if</span> (minimum &lt; <span class="number">0</span>) <span class="keyword">return</span> retVal;</span><br><span class="line">            <span class="keyword">for</span> (i=s.size()-startOffset-wordLength; i&gt;=minimum; i-=wordLength) &#123;</span><br><span class="line">                hashSum+=hash_fn(s.substr(i,wordLength));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hashSum==magicNumber) retVal.push_back(i+wordLength);</span><br><span class="line">            <span class="keyword">for</span> (;i&gt;=<span class="number">0</span>; i-=wordLength) &#123;</span><br><span class="line">                hashSum-=hash_fn(s.substr(i+minimumSize,wordLength));</span><br><span class="line">                hashSum+=hash_fn(s.substr(i,wordLength));</span><br><span class="line">                <span class="keyword">if</span> (hashSum==magicNumber) retVal.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--35. Search Insert Position</title>
    <url>/2019/04/24/LeetCode--35-Search-Insert-Position.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. <a id="more"></a> You may assume no duplicates in the array.</p>
</blockquote>
<p><strong>Example 1:</strong> &gt; Input: [1,3,5,6], 5 &gt; Output: 2</p>
<p><strong>Example 2:</strong> &gt; Input: [1,3,5,6], 2 &gt; Output: 1</p>
<p><strong>Example 3:</strong> &gt; Input: [1,3,5,6], 7 &gt; Output: 4</p>
<p><strong>Example 4:</strong> &gt; Input: [1,3,5,6], 0 &gt; Output: 0</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>显然，这道题还是可以使用二分查找求解。使用二分搜索查找target，若找到了，直接返回找到的下标。若target不存在，二分搜索结束后，low所指向的位置就是target插入的位置。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="二分查找">二分查找</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法2">解法2</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--4. Median of Two Sorted Arrays</title>
    <url>/2019/03/31/LeetCode--4-Median-of-Two-Sorted-Arrays.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively. <a id="more"></a> Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
</blockquote>
<blockquote>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
</blockquote>
<p><strong>Example1:</strong> &gt;nums1 = [1, 3] &gt;nums2 = [2]</p>
<blockquote>
<p>The median is 2.0</p>
</blockquote>
<p><strong>Example2:</strong> &gt;nums1 = [1, 2] &gt;nums2 = [3, 4]</p>
<blockquote>
<p>The median is (2 + 3)/2 = 2.5</p>
</blockquote>
<h3 id="二解题思路">二、解题思路</h3>
<p>最先想到的方法是，既然两个数组是有序的，可以直接归并两个数组，之后可以直接找到中位数。但题目对时间有要求，这种方法的时间复杂度是O(m+n)，比要求的O(log(m+n))显然要大，所以不能用这种暴力的方法。</p>
<p>仔细分析问题，既然两个数组都是有序的，那么可以不必将数组归并，可以直接挨个比较两个数组，找到中间的那两个数(数组为奇数长度下，找中间一个数)，就可以停止下来，不必继续比较后面的值，可以节省大量时间。事实证明这种方法可行，速度也够快。</p>
<p><strong>二分求解</strong> 题目解析给出了另外一种方法，即基于二分搜索的方法。大致思想如下 &gt;将数组A,B分别分成两部分，将 left_A 和 left_B 放入一个集合，并将 right_A 和 right_B 放入另一个集合。 再把这两个新的集合分别命名为 left_part 和 right_part：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">left_part</th>
<th style="text-align: center;">right_part</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A[0], A[1], ..., A[i-1]</td>
<td style="text-align: center;">A[i], A[i+1], ..., A[m-1]</td>
</tr>
<tr class="even">
<td style="text-align: center;">B[0], B[1], ..., B[j-1]</td>
<td style="text-align: center;">B[j], B[j+1], ..., B[n-1]</td>
</tr>
</tbody>
</table>
<p>如果我们可以确认： &gt;1. len(left_part) = len(right_part) &gt;2. max(left_part) ≤ min(right_part)</p>
<p>那么，我们已经将 {A,B} 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。这时可以很容易求出<strong>median</strong>: &gt;median= (max(left_part) + min(right_part)) / 2</p>
<p>要确保这两个条件，我们只需要保证：</p>
<blockquote>
<ol type="1">
<li>i + j = m − i + n − j（或：m - i + n - j + 1） 如果 n ≥ m，只需要使 i = 0 ~ m, j = (m + n + 1) / 2 - i</li>
<li>B[j−1] ≤ A[i] 以及 A[i−1] ≤ B[j]</li>
</ol>
</blockquote>
<p>接下来，按照以下步骤进行二叉树搜索，找到合适的i： &gt; 1. 设 imin = 0，imax = m, 然后开始在 [imin,imax] 中进行搜索。 2. 令i = (imin+imax)/2, j = (m+n+1)/2-i 3. 现在有len(left_part)=len(right_part)。会遇到三种情况： - B[j−1] ≤ A[i] 且 A[i−1] ≤ B[j]：这意味着我们找到了目标对象 i，所以可以停止搜索。 - B[j−1] &gt; A[i]：这意味着 A[i] 太小，我们必须增大 i 以使 B[j−1] ≤ A[i]。也就是说，我们必须将搜索范围调整为[i+1,imax]。因此，设 imin=i+1，并转到步骤 2。 - A[i−1] &gt; B[j]：这意味着 A[i−1] 太大，我们必须减小 i 以使 A[i−1] ≤ B[j]。也就是说，我们必须将搜索范围调整为[imin,i−1]。因此，设 imax=i−1，并转到步骤 2。</p>
<p>当找到目标对象 i 时，中位数为： &gt; - max(A[i−1],B[j−1]), 当 m+n 为奇数时 - (max(A[i−1],B[j−1])+min(A[i],B[j]))/2, 当 m+n 为偶数时</p>
<p>接下来只需要对一些边界条件进行处理就可以了，这种方法实现了O(log(m+n))的复杂度</p>
<h3 id="三代码">三、代码</h3>
<h4 id="解法1">1.解法1</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//只有单个数组有值的情况，只需要处理单个数组</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findSingleArrayMedian</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> isOdd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isOdd) <span class="keyword">return</span> nums[nums.size()/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[nums.size()/<span class="number">2</span><span class="number">-1</span>] + nums[nums.size()/<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//vector&lt;int&gt; nums;</span></span><br><span class="line">        <span class="keyword">int</span> totalLen=nums1.size() + nums2.size();</span><br><span class="line">        <span class="keyword">int</span> isOdd = (totalLen&amp;<span class="number">1</span>); <span class="comment">//判断数组长度奇偶性</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(totalLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums1.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findSingleArrayMedian(nums2,isOdd);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums2.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> findSingleArrayMedian(nums1,isOdd);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> last1=<span class="number">0</span>,last2=<span class="number">0</span>; <span class="comment">//记录最后两个值</span></span><br><span class="line">        <span class="keyword">int</span> index1=<span class="number">0</span>,index2=<span class="number">0</span>; <span class="comment">//记录两个数组当前的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=totalLen/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数组1已经没有值时</span></span><br><span class="line">            <span class="keyword">if</span>(index1 == nums1.size())</span><br><span class="line">            &#123;</span><br><span class="line">                last1=last2;</span><br><span class="line">                last2=nums2[index2];</span><br><span class="line">                <span class="comment">//nums.push_back(nums2[index2]);</span></span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数组2已经没有值时</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index2 == nums2.size())</span><br><span class="line">            &#123;</span><br><span class="line">                last1=last2;</span><br><span class="line">                last2=nums1[index1];</span><br><span class="line">                <span class="comment">//nums.push_back(nums1[index1]);</span></span><br><span class="line">                index1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[index1]&lt;nums2[index2])</span><br><span class="line">                &#123;</span><br><span class="line">                    last1=last2;</span><br><span class="line">                    last2=nums1[index1];</span><br><span class="line">                    <span class="comment">//nums.push_back(nums1[index1]);</span></span><br><span class="line">                    index1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    last1=last2;</span><br><span class="line">                    last2=nums2[index2];</span><br><span class="line">                    <span class="comment">//nums.push_back(nums2[index2]);</span></span><br><span class="line">                    index2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(isOdd) <span class="keyword">return</span> last2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (last1+last2) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法2二分法">2.解法2（二分法）</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> len2 = nums2.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//确保数组1长度不大于数组2小</span></span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp=nums1;nums1=nums2;nums2=tmp;</span><br><span class="line">            <span class="keyword">int</span> temp = len1;len1=len2;len2=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> iMin=<span class="number">0</span>,iMax=len1,halfLen=(len1+len2+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(iMin&lt;=iMax)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i=(iMin+iMax)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j=halfLen-i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//i过小</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;iMax &amp;&amp; nums2[j<span class="number">-1</span>]&gt;nums1[i])</span><br><span class="line">            &#123; </span><br><span class="line">                iMin=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i过大</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;iMin &amp;&amp; nums1[i<span class="number">-1</span>]&gt;nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                iMax=i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//成功找到i</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> maxLeft=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) maxLeft=nums2[j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) maxLeft=nums1[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> maxLeft=max(nums1[i<span class="number">-1</span>],nums2[j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>((len1+len2)%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> maxLeft;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> minRight=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==len1) minRight = nums2[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==len2) minRight = nums1[i];</span><br><span class="line">                <span class="keyword">else</span> minRight=min(nums1[i],nums2[j]);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--34. Find First and Last Position of Element in Sorted Array</title>
    <url>/2019/04/23/LeetCode--34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given <strong>target</strong> value. <a id="more"></a> Your algorithm's runtime complexity must be in the order of O(log n).</p>
</blockquote>
<blockquote>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
</blockquote>
<p><strong>Example 1:</strong> &gt; Input: nums = [5,7,7,8,8,10], target = 8 &gt; Output: [3,4]</p>
<p><strong>Example 2:</strong> &gt; Input: nums = [5,7,7,8,8,10], target = 6 &gt; Output: [-1,-1]</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>依旧是以O(log n)复杂度查找一个数。这道题给出的数组是有序的而且可以有重复元素，要求给出target出现的范围。</p>
<p>因为数组完全有序，所以思路依旧是使用二分查找。首先用二分查找，查找一个等于target的元素的位置，然后从该位置开始左右拓展，从而找到target出现的范围。若没有找到该数，直接返回<code>{-1, -1}</code>即可。可以看出，算法思路很简单。</p>
<p>但是这可能不是严格意义上的O(logn)的算法，因为在最坏的情况下会变成O(n)，比如当数组里的数全是目标值的话，从中间向两边找边界就会一直遍历完整个数组。一种真正意义上的O(logn)的算法是，使用两次二分查找法，第一次找到左边界，第二次调用找到右边界即可。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="二分查找">二分查找</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[low] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> start = low, end = low;</span><br><span class="line">            <span class="keyword">while</span>(start &gt; <span class="number">0</span> &amp;&amp; nums[start<span class="number">-1</span>] == nums[start]) start--;</span><br><span class="line">            <span class="keyword">while</span>(end &lt; nums.size()<span class="number">-1</span> &amp;&amp; nums[end+<span class="number">1</span>] == nums[end]) end++;</span><br><span class="line">            <span class="keyword">return</span> &#123;start,end&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="两遍二分查找">两遍二分查找</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(high &lt; <span class="number">0</span> || nums[high] != target) <span class="keyword">return</span> res;</span><br><span class="line">        res[<span class="number">0</span>] = high;high = nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>] = high - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--37. Sudoku Solver</title>
    <url>/2019/04/25/LeetCode--37-Sudoku-Solver.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Write a program to solve a Sudoku puzzle by filling the empty cells. <a id="more"></a> A sudoku solution must satisfy <strong>all of the following rules:</strong> 1. Each row must contain the digits 1-9 without repetition. 2. Each column must contain the digits 1-9 without repetition. 3. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</p>
</blockquote>
<blockquote>
<p>Empty cells are indicated by the character <code>'.'</code>.</p>
</blockquote>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" title="A sudoku puzzle..." alt="A sudoku puzzle..." /><figcaption aria-hidden="true">A sudoku puzzle...</figcaption>
</figure>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" title="...and its solution numbers marked in red." alt="...and its solution numbers marked in red." /><figcaption aria-hidden="true">...and its solution numbers marked in red.</figcaption>
</figure>
<p><strong>Note :</strong> - The given board contain only digits <code>1-9</code> and the character <code>'.'</code>. - You may assume that the given Sudoku puzzle will have a single unique solution. - The given board size is always <code>9x9</code>.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>还是遇到这道题了，解数独。有了上一道题的经验，对于解数独的问题也不是毫无头绪了。</p>
<p>既然我们已经有了判断当前棋盘是否符合数独规则的算法，那么一种直观的方法就是利用递归回溯法，将所有可能的合法数字都尝试一遍，判断哪种方法最终可以将整个棋盘填满并且符合数独的规则。尽管思路是有了，但是实现起来还是有点磕磕碰碰，对于递归回溯的使用还是不熟悉呀。实现后不出所料，性能不够好，耗时太多了，暴力解法的缺点就是思路简单，但一般复杂度不会太好。</p>
<p>对这个方法的一种优化是，每次填入一个数的时候，不必要对整个棋盘都判断一遍是不是有效的，只需要判断加入的这个数有没有违反规则。若每次加入的数都没有违反规则，那么到最后填满整个棋盘的数，所有的数也就都是有效的。这样就省去大量重复的比较时间，使得效率得到了提升。</p>
<p>除此之外还有一些比较高深复杂的解法，暂时还没看懂，后面补充。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="暴力解法">暴力解法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        solveSudo(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solveSudo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">9</span>) <span class="keyword">return</span> solveSudo(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; ++k) </span><br><span class="line">            &#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>)(k + <span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span> (isValidSudoku(board)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (solveSudo(board, i, j + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> solveSudo(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; col(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; block(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; row(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = <span class="number">1</span> &lt;&lt; (board[i][j] - <span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">if</span> (row[i] &amp; idx || col[j] &amp; idx || block[i/<span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>] &amp; idx)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    </span><br><span class="line">                    row[i] |= idx;</span><br><span class="line">                    col[j] |= idx;</span><br><span class="line">                    block[i/<span class="number">3</span> * <span class="number">3</span> + j/<span class="number">3</span>] |= idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="优化">优化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        solveSudo(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solveSudo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">9</span>) <span class="keyword">return</span> solveSudo(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; ++k) </span><br><span class="line">            &#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>)(k + <span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span> (isValidSudoku(board, i, j)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (solveSudo(board, i, j + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> solveSudo(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; ++col) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (col != j &amp;&amp; board[i][j] == board[i][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; ++row) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (row != i &amp;&amp; board[i][j] == board[row][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = i / <span class="number">3</span> * <span class="number">3</span>; row &lt; i / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; ++row) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = j / <span class="number">3</span> * <span class="number">3</span>; col &lt; j / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; ++col) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((row != i || col != j) &amp;&amp; board[i][j] == board[row][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--6. ZigZag Conversion</title>
    <url>/2019/04/01/LeetCode--6-ZigZag-Conversion.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>The string <code>"PAYPALISHIRING"</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) <a id="more"></a> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure> And then read line by line: <code>"PAHNAPLSIIGYIR"</code> Write the code that will take a string and make this conversion given a number of rows: <code>string convert(string s, int numRows);</code></p>
</blockquote>
<p><strong>Example1:</strong> &gt;Input: s = "PAYPALISHIRING", numRows = 3 &gt;Output: "PAHNAPLSIIGYIR"</p>
<p><strong>Example1:</strong> &gt;Input: s = "PAYPALISHIRING", numRows = 4 &gt; Output: "PINALSIGYAHRPI" &gt;Explanation: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题可以直接通过找规律实现。找到每行 Z 字形图案字符在原字符串中对于的位置即可，然后逐行访问。规律如下： &gt;对于所有整数"k", &gt;1. 第0行中的字符位于原字符串 k*(2⋅numRows−2) 处; &gt;2. 第(numRows−1)行中的字符位于原字符串 k*(2⋅numRows−2)+numRows−1 处; &gt;3. 其他行中字符位于原字符串 k*(2⋅numRows−2)+i 以及 (k+1)*(2⋅numRows−2)−i处；</p>
<p>找到规律后，就很容易实现了。</p>
<p>另外一种方法是，通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。所以可以分别构建每行的字符串，最后再将这些字符串连接起来即可，算法如下 &gt;1. 使用 min(numRows,len(s)) 个列表来表示 Z 字形图案中的非空行。 &gt;2. 从左到右迭代 s，将每个字符添加到合适的行。 &gt;3. 合并所有行</p>
<p>但是这种方法效率要低一些。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="找规律的方法">1. 找规律的方法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一行，无需处理直接输出</span></span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> cvStr;</span><br><span class="line">        <span class="keyword">int</span> step=numRows*<span class="number">2</span><span class="number">-2</span>;<span class="comment">//每次前进的步伐</span></span><br><span class="line">        <span class="comment">//逐行生成每行的序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;s.length();j+=step)</span><br><span class="line">            &#123;</span><br><span class="line">                cvStr+=s[j+i];</span><br><span class="line">                <span class="comment">//若是内部行，需要加上((k+1)(2⋅numRows−2)−i)处的字符</span></span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;i!=numRows<span class="number">-1</span>&amp;&amp;j+step-i&lt;s.length())</span><br><span class="line">                &#123;</span><br><span class="line">                    cvStr+=s[j+step-i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cvStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="逐行构造的方法">2. 逐行构造的方法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一行，无需处理直接输出</span></span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = min(numRows,<span class="keyword">int</span>(s.length()));</span><br><span class="line">        <span class="built_in">string</span> cvStr; <span class="comment">//结果字符串</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; rows(len); <span class="comment">//每行字符串</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> curRow=<span class="number">0</span>; <span class="comment">//当前行</span></span><br><span class="line">        <span class="keyword">bool</span> curDirect=<span class="literal">false</span>; <span class="comment">//当前方向</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逐个字符串构建每行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            rows[curRow]+=s[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//边界时，确定当前方向</span></span><br><span class="line">            <span class="keyword">if</span>(curRow==<span class="number">0</span> || curRow == numRows<span class="number">-1</span>) curDirect=!curDirect;</span><br><span class="line">            </span><br><span class="line">            curRow+=curDirect?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//合成字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> row : rows) cvStr+=row;</span><br><span class="line">        <span class="keyword">return</span> cvStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--709. To Lower Case</title>
    <url>/2019/03/28/LeetCode--709-To-Lower-Case.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase. <a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong> &gt; Input: "Hello" &gt; Output: "hello"</p>
<p><strong>Example 2:</strong> &gt; Input: "here" &gt; Output: "here"</p>
<p><strong>Example 3:</strong> &gt; Input: "LOVELY" &gt; Output: "lovely"</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题主要用来熟悉下transform(STL transform)函数</p>
<blockquote>
<p>transform() 可以将函数应用到序列的元素上，并将这个函数返回的值保存到另一个序列中，它返回的迭代器指向输出序列所保存的最后一个元素的下一个位置。调用方法如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryOperator</span> &gt; </span></span><br><span class="line"><span class="class">	<span class="title">OutputIterator</span> <span class="title">transform</span> ( <span class="title">InputIterator</span> <span class="title">first1</span>,  // 源容器的起始地址 </span></span><br><span class="line"><span class="class">							  <span class="title">InputIterator</span> <span class="title">last1</span>,    // 源容器的终止地址 </span></span><br><span class="line"><span class="class">							  <span class="title">OutputIterator</span> <span class="title">result</span>,  // 目标容器的起始地址 </span></span><br><span class="line"><span class="class">							  <span class="title">UnaryOperator</span> <span class="title">op</span> );</span>     <span class="comment">// 函数指针 </span></span><br><span class="line"><span class="comment">// typedef 目标容器元素类型 (*UnaryOperator)(源容器元素类型); </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">BinaryOperator</span> &gt; </span></span><br><span class="line"><span class="class">	<span class="title">OutputIterator</span> <span class="title">transform</span> ( <span class="title">InputIterator1</span> <span class="title">first1</span>,     // 源容器1的起始地址 </span></span><br><span class="line"><span class="class">							  <span class="title">InputIterator1</span> <span class="title">last1</span>,       // 源容器1的终止地址 </span></span><br><span class="line"><span class="class">							  <span class="title">InputIterator2</span> <span class="title">first2</span>,      // 源容器2的起始地址，元素个数与1相同 </span></span><br><span class="line"><span class="class">							  <span class="title">OutputIterator</span> <span class="title">result</span>,      // 目标容器的起始地址，元素个数与1相同 </span></span><br><span class="line"><span class="class">							  <span class="title">BinaryOperator</span> <span class="title">binary_op</span> );</span> <span class="comment">// 函数指针 </span></span><br><span class="line"><span class="comment">// typedef 目标容器元素类型 (*BinaryOperator)(源容器1元素类型，源容器2元素类型);</span></span><br></pre></td></tr></table></figure>
<p>所以transform结合大小写转换函数tolower，只需要一行即可完成任务</p>
<h3 id="三代码">三、代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toLowerCase</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        transform(str.begin(),str.end(),str.begin(),::<span class="built_in">tolower</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--5. Longest Palindromic Substring</title>
    <url>/2019/03/28/LeetCode--5-Longest-Palindromic-Substring.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000. <a id="more"></a></p>
</blockquote>
<p><strong>Example1:</strong> &gt;Input: "babad" &gt;Output: "bab" &gt;Note: "aba" is also a valid answer.</p>
<p><strong>Example2:</strong> &gt;Input: "cbbd" &gt;Output: "bb"</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>最开始想到的当然还是暴力算法，想法是先用暴力算法把题目做出来理解题目，然后尝试着对实现的算法进行改进，或者再想想有没有其他思路。最开始的想法是</p>
<blockquote>
<p>设置两个游标i、j，i从前往后遍历字符串，j从后往前遍历字符串；先将i固定住，然后j从后往前遍历，依次判断从当前j到i的字符串是不是一个回文，其长度是不是最大，若满足条件，就将该字符串的位置信息记录下来，遍历完后最终输出即可。</p>
</blockquote>
<p>显然这个方法的效果不会太好，选择尝试对其进行优化。想要的优化思路如下</p>
<blockquote>
<p>若当前要判断的子串比已经找到的最长回文子串要短，那么该子串以及比它短的子串都没必要在判断了，可以通过跳过这些不必要的比较过程节省大量时间</p>
</blockquote>
<p>修改过后，时间上果然有了很大提升，但结果告诉我显然这种方法还是不好，肯定存在更优化的方法。仔细分析后发现，其实这种方法就相当于将字符串反转后找最大公共子串，它存在一些问题：</p>
<blockquote>
<p>这种方法是从两端往内部收缩的算法，如果一个字符串恰好只是最内部的一部分不是子串，那么两端的整个判断过程都是无意义的，而且很费时。我们需要能够更早发现这不是一个回文。若我们把判断过程换一个方向就可以做到，即收缩改为扩展。由内而外的判断子串是不是回文，可以在不是回文的地方及时停止，并且保证之前判断的子串的确是回文，不是无意义的判断。</p>
</blockquote>
<p>实现后发现，这种扩展的算法效率比最开始的算法效率要好太多了，因为避免了许多无意义的计算过程。总结起来就是，有时候换一个方向想问题，可以得到更加优化的结果。 查看解题的文档后发现还有以下几种比较巧妙的方式：</p>
<blockquote>
<p>1.最长公共子串暴力算法 反转 S，使之变成 S'。找到 S 和 S'之间最长的公共子串,每当我们找到最长的公共子串的候选项时，都需要检查子串的索引是否与反向子串的原始索引相同。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。我所用到的第一种方法思路根这种方法一致。</p>
</blockquote>
<blockquote>
<p>2.动态规划 考虑 "ababa" 这个示例。如果我们已经知道 "bab" 是回文，那么很明显，"ababa" 一定是回文，因为它的左首字母和右尾字母是相同的。可以给出P(i,j)的定义如下</p>
</blockquote>
<blockquote>
<ul>
<li>P(i,j) = true, 如果子串Si,...,Sj是回文子串</li>
<li>P(i,j) = false, 其他情况</li>
</ul>
</blockquote>
<blockquote>
<p>因此P(i,j)更新公式如下： - P(i,j) = (P(i+1,j−1) and Si == Sj)</p>
</blockquote>
<blockquote>
<p>这是一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推</p>
</blockquote>
<blockquote>
<p>3.Manacher 算法 也叫“马拉松”算法，这个算法可以将时间复杂度提升为<strong>O(n)</strong>。</p>
</blockquote>
<blockquote>
<ol type="1">
<li>首先对字符串进行预处理，处理原因是防止偶数问题。比如，有一个偶回文<strong>abba</strong>和一个奇回文<strong>opxpo</strong>，转换为<strong>#a#b#b#a#</strong>和<strong>#o#p#x#p#o#</strong>，长度都转换成了奇数。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2" type="1">
<li>定义一个辅助数组p[]，其中p[i]表示以 <strong>i</strong> 为中心的最长回文的半径</li>
</ol>
</blockquote>
<blockquote>
<ol start="3" type="1">
<li>接下来的重点就是求解 p 数组。参考下图 <img src="https://image-static.segmentfault.com/105/998/1059982876-58b966b759200" /> 设置两个变量，mx 和 id。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么： <code>if (i &lt; mx) p[i]=min(p[2 * id - i], mx - i);</code> <strong>(2 * id - i)</strong>为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快更新数组。</li>
</ol>
</blockquote>
<p>参考文献：https://subetter.com/algorithm/manacher-algorithm.html</p>
<h3 id="三代码">三、代码</h3>
<h4 id="改进的收缩算法最长字符串匹配">1. 改进的收缩算法(最长字符串匹配)</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> begin=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> LongestLength=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=s.length()<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> forward=i;</span><br><span class="line">                <span class="keyword">int</span> backward=j;</span><br><span class="line">                <span class="keyword">while</span>(s[forward]==s[backward]&amp;&amp;forward&lt;backward)</span><br><span class="line">                &#123;</span><br><span class="line">                    forward++;</span><br><span class="line">                    backward--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(forward&gt;=backward)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(LongestLength&lt;(j-i+<span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        begin=i;</span><br><span class="line">                        LongestLength=(j-i+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(LongestLength&gt;=(j-i+<span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(LongestLength&gt;=(s.length()-i+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> s.substr(begin, LongestLength); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="扩展算法">2. 扩展算法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> r_ptr = i; </span><br><span class="line">        <span class="keyword">int</span> l_ptr = i;</span><br><span class="line">        <span class="comment">//找到回文中心</span></span><br><span class="line">        <span class="keyword">while</span>(r_ptr &lt; s.size()<span class="number">-1</span> &amp;&amp; s[r_ptr] == s[r_ptr + <span class="number">1</span>]) r_ptr++;</span><br><span class="line">        i = r_ptr+<span class="number">1</span>;<span class="comment">//记录下次启示位置，防止重复计算</span></span><br><span class="line">        <span class="comment">//从中心开始扩展</span></span><br><span class="line">        <span class="keyword">while</span>(r_ptr &lt; s.size()<span class="number">-1</span> &amp;&amp; l_ptr &gt; <span class="number">0</span> &amp;&amp; s[r_ptr + <span class="number">1</span>] == s[l_ptr - <span class="number">1</span>]) &#123;</span><br><span class="line">            r_ptr++;</span><br><span class="line">            l_ptr--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新最长回文子串信息</span></span><br><span class="line">        <span class="keyword">int</span> new_len = r_ptr - l_ptr + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(new_len &gt; max_len) &#123;</span><br><span class="line">            start_idx = l_ptr;</span><br><span class="line">            max_len = new_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(start_idx, max_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划算法">3. 动态规划算法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> LongestLength = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(len,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dist = <span class="number">1</span>;dist &lt; len - i;dist++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = dist + i;</span><br><span class="line">                dp[i][j] = (dist == <span class="number">1</span>)? s[i] == s[j] : s[i] == s[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; LongestLength)</span><br><span class="line">                &#123;</span><br><span class="line">                    LongestLength = j-i+<span class="number">1</span>;</span><br><span class="line">                    begin=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substr(begin, LongestLength); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="manacher算法">4. Manacher算法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字符串预处理，插入 '#'</span></span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">"$#"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            t += s[i];</span><br><span class="line">            t += <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理t</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(t.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, resLen = <span class="number">0</span>, resCenter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.size(); ++i) &#123;</span><br><span class="line">            p[i] = i &lt; mx ? min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++p[i]; <span class="comment">//// 不需边界判断，因为左有'$',右有'\0'</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//希望 mx 尽可能的远</span></span><br><span class="line">            <span class="keyword">if</span> (mx &lt; i + p[i]) &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</span><br><span class="line">                resLen = p[i];</span><br><span class="line">                resCenter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr((resCenter - resLen) / <span class="number">2</span>, resLen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--7. Reverse Integer</title>
    <url>/2019/03/28/LeetCode--7-Reverse-Integer.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given a 32-bit signed integer, reverse digits of an integer.. <a id="more"></a></p>
</blockquote>
<p><strong>Example1:</strong> &gt;Input: 123 &gt;Output: 321</p>
<p><strong>Example2:</strong> &gt;Input: -123 &gt;Output: -321</p>
<p><strong>Example3:</strong> &gt;Input: 120 &gt;Output: 21</p>
<p><strong>Note:</strong> &gt;Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>问题很简单，即将一个int型整数逆序。这里需要注意的是，int的表示范围是[−2^31, 2^31 − 1]，所以若逆序后的数在这个范围之外，即溢出的时候，直接输出0。 我的想法是，用一个更大的类型，即<strong>long</strong>来存储转化结果，然后判断结果在不在int的表示范围内，对计算结果进行处理。对比评论区，发现思路大致相同，这貌似就是最优的方法，还以为又会有啥逻辑上的转换。</p>
<h3 id="三代码">三、代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> MAX=<span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">long</span> MIN=<span class="number">-2147483648</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result=result*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(result&gt;MAX||result&lt;MIN)</span><br><span class="line">        &#123;</span><br><span class="line">            result=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr />
<p>据说出题人想考的是溢出判断，不能用long，只用Int的实现如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> MAX=<span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">long</span> MIN=<span class="number">-2147483648</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(result&gt;MAX/<span class="number">10</span>||result&lt;MIN/<span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            result=result*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>也就是计算结果的时候，先判断这次计算会不会溢出，溢出就直接返回0</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--771. Jewels and Stones</title>
    <url>/2019/03/28/LeetCode--771-Jewels-and-Stones.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>You're given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. <a id="more"></a> The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A".</p>
</blockquote>
<p><strong>Example 1:</strong> &gt;Input: J = "aA", S = "aAAbbbb" &gt;Output: 3</p>
<p><strong>Example 2:</strong> &gt;Input: J = "z", S = "ZZ" &gt;Output: 0</p>
<p><strong>Note:</strong> &gt; - S and J will consist of letters and have length at most 50. &gt; - The characters in J are distinct.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>1.这是一道很简单的题，只需要逐个判断字符串 <strong>S</strong> 中的每个字符,是否在字符串 <strong>J</strong> 中出现过。设置一个计数器count，每次判断后更新该计数器，带遍历完整个字符串，即可得出最终结果。比较字符串的过程中，应用了string库里的find()函数。 2.在看别人提交的解法中，看见了另外一种比较有趣的方法，建立了一个与字符ASCII码大小相同的数组，每次判断字符是否存在，只需直接在数组内查看该字符ASCII码对应的位置是否为1，这是一种空间换时间的方法。</p>
<h3 id="三代码">三、代码</h3>
<ol type="1">
<li>解法1</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(J.find(S[i]) != J.npos)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>解法2</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> exist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; J.length();i++) &#123;</span><br><span class="line">            exist[J.at(i)] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exist[S.at(i)]) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--9. Palindrome Number</title>
    <url>/2019/04/02/LeetCode--9-Palindrome-Number.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. <a id="more"></a></p>
</blockquote>
<p><strong>Example 1:</strong> &gt;Input: 121 &gt;Output: true</p>
<p><strong>Example 2:</strong> &gt;Input: -121 &gt;Output: false &gt;Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</p>
<p><strong>Example 3:</strong> &gt;Input: 10 &gt;Output: false &gt;Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>题目让判断一个数整数是不是一个回文，其中定义所有负数都不是回文。解题想法是 &gt;1. 首先判断这个数是不是负数，或者是不是0~9的数(只有一位肯定是回文)。 &gt;2. 然后将数字转化为一个字符串，从中心开始向两边扩展判断是不是回文。</p>
<p>这里判断回文的思路和前面做到的一道题很类似，但是这个题要更简单一点。后来才发现题目要求里面有，<strong>不能使用把数转化为字符串</strong>。 前面有道题是可以把一个数反转，那么可以直接把数反转后，看看两个数是否相等即可判断。但是把数反转后有可能导致数字大于int表示范围，还需要额外处理溢出的情况。一种优化的方法是，可以<strong>只反转int数字的一半</strong>，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。例如，输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 1221 是回文。这里还需要对一些特殊情况进行处理，比如数字是奇数长，或者10^n时，需要额外判断。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="转化为字符串的解法">转化为字符串的解法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToStr</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = (x%<span class="number">10</span>)+<span class="string">'0'</span>;</span><br><span class="line">            res = tmp + res;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;<span class="number">10</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> num = intToStr(x);</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">if</span>(num.length()%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i=num.length()/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            j=num.length()/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i=num.length()/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            j=num.length()/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;=num.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]!=num[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i--;j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不转化解法">不转化解法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span> || (x!=<span class="number">0</span> &amp;&amp; x%<span class="number">10</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; revertedNumber)</span><br><span class="line">        &#123;</span><br><span class="line">            revertedNumber = revertedNumber*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x==(revertedNumber/<span class="number">10</span>) || x==revertedNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>My new Post</title>
    <url>/2017/09/21/My-new-Post.html</url>
    <content><![CDATA[<blockquote>
<p>a test</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>LeetCode--8. String to Integer (atoi)</title>
    <url>/2019/03/31/LeetCode--8-String-to-Integer-atoi.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Implement <strong>atoi</strong> which converts a string to an integer. <a id="more"></a> The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
</blockquote>
<blockquote>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
</blockquote>
<blockquote>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
</blockquote>
<blockquote>
<p>If no valid conversion could be performed, a zero value is returned.</p>
</blockquote>
<p><strong>Note:</strong> - Only the space character ' ' is considered as whitespace character. - Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</p>
<p><strong>Example1:</strong> &gt;Input: "42" &gt;Output: 42</p>
<p><strong>Example2:</strong> &gt;Input: " -42" &gt;Output: -42 &gt;Explanation: The first non-whitespace character is '-', which is the minus sign.Then take as many numerical digits as possible, which gets 42.</p>
<p><strong>Example3:</strong> &gt;Input: "4193 with words" &gt;Output: 4193 &gt;Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.</p>
<p><strong>Example4:</strong> &gt;Input: "words and 987" &gt;Output: 0 &gt;Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.</p>
<p><strong>Example5:</strong> &gt;Input: "-91283472332" &gt;Output: -2147483648 &gt;Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>题目大致意思是：将一个字符串转换成一个数，这个字符串有很多种情况需要考虑： 1. 忽略字符串头部的空白(只把" "当做空白) 2. 数字可能带正负号 3. 若数字超过INT表示范围，则若上溢，返回INT最大值；若下溢，返回INT最小值 4. 如果除1,2情况外，第一个字符不是数字，视为无效值，返回0 5. 如果数字后出现非数字，则截断，不考虑后面的字符。</p>
<p>所以，只需要将这些情况考虑进来，把字符串进行直接处理即可。判断溢出时，可以用long来保存结果，最后再判断值是否溢出；也可以直接计算过程中对INT进行判断。这里用的后一种方法。这道题在判断溢出时，思路类似于[7.Reverse Integer]这道题。</p>
<h3 id="三代码">三、代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,sign=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//去空格</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;str[i]==<span class="string">' '</span>;i++);</span><br><span class="line">        <span class="comment">//取符号</span></span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sign=<span class="number">1</span>;i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">'+'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="number">0</span>&amp;&amp;(INT_MAX-(str[i]-<span class="string">'0'</span>))/<span class="number">10</span>&lt;result) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            <span class="keyword">if</span>(sign==<span class="number">1</span>&amp;&amp;(INT_MAX-(str[i]-<span class="string">'0'</span>))/<span class="number">10</span>&lt;result) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            </span><br><span class="line">            result=result*<span class="number">10</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sign) result=-result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--929. Unique Email Addresses</title>
    <url>/2019/03/28/LeetCode--929-Unique-Email-Addresses.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Every email consists of a local name and a domain name, separated by the @ sign.</p>
</blockquote>
<blockquote>
<p>For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. <a id="more"></a> Besides lowercase letters, these emails may contain '.'s or '+'s.</p>
</blockquote>
<blockquote>
<p>If you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. For example, "alice.z@leetcode.com" and "alicez@leetcode.com" forward to the same email address. (Note that this rule does not apply for domain names.)</p>
</blockquote>
<blockquote>
<p>If you add a plus ('+') in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com. (Again, this rule does not apply for domain names.)</p>
</blockquote>
<blockquote>
<p>It is possible to use both of these rules at the same time.</p>
</blockquote>
<blockquote>
<p>Given a list of emails, we send one email to each address in the list. How many different addresses actually receive mails?</p>
</blockquote>
<p><strong>Example 1:</strong> &gt;Input: <code>{"test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"}</code> &gt;Output: <strong>2</strong></p>
<p>Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails</p>
<p><strong>Note:</strong> - 1 &lt;= emails[i].length &lt;= 100 - 1 &lt;= emails.length &lt;= 100 - Each emails[i] contains exactly one '@' character.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>题目的意思是，邮箱作为一个字符串，在字符"@"前面的部分：</p>
<blockquote>
<p>1.若出现字符'.'，则可以去掉该'.'; 2.若出现'+'，则从'+'到'@'的字符串都可去掉。</p>
</blockquote>
<p>根据这样的规则，判断总共有多少个不同的邮箱。思路很明确，只需要将每一个邮箱转换为其最简单的形式，然后去除其中重复的字符串，计算最终剩下的字符串个数即可。 首先联想到的是在每次处理完字符串后，将处理过的字符串放入一个set中，由于set内不含重复元素，所以自然就可以去重。但是vector有没有什么直接去重的方法呢？查阅资料后发现还真有，在vector类型中，有一种去重的方法是：先在vector内对向量进行排序，然后用erase加unique函数即可实现去除重复元素。</p>
<blockquote>
<ul>
<li>unique函数是一个去重函数，去除相邻中的重复元素（只留一个）。其中，最关键的是：并不是把重复的元素删除，而是全部放倒数组的后面。</li>
<li>由于unique只是去除（相邻）的重复元素，因此，为了去除重复的元素，应该，首先对数组Vector进行排序，这样保证重复元素在相邻的位置。</li>
<li>unique函数，返回的是去重后的尾地址。因此对于一个内容为{2, 2, 5, 5, 6}的vector，执行unique函数以后，vector大小并没有改变，只不过顺序变成了{2, 5, 6, 2, 5}，并且函数的返回值为:3。此时需要删除重复元素，只需要将后面的数据全部删除即可。</li>
</ul>
</blockquote>
<h3 id="三代码">三、代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numUniqueEmails</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; emails)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator email=emails.begin();email&lt;emails.end();email++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(*email).find(<span class="string">'@'</span>);i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((*email)[i]==<span class="string">'.'</span>)  (*email).erase(i,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((*email)[i]==<span class="string">'+'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    (*email).erase(i,(*email).find(<span class="string">'@'</span>)-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(emails.begin(),emails.end());</span><br><span class="line">        emails.erase(unique(emails.begin(), emails.end()), emails.end());</span><br><span class="line">        <span class="keyword">return</span> emails.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--36. Valid Sudoku</title>
    <url>/2019/04/24/LeetCode--36-Valid-Sudoku.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated <strong>according to the following</strong> . <a id="more"></a> <strong>rules :</strong> 1. Each row must contain the digits 1-9 without repetition. 2. Each column must contain the digits 1-9 without repetition. 3. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</p>
</blockquote>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" title="A partially filled sudoku which is valid." alt="A partially filled sudoku which is valid." /><figcaption aria-hidden="true">A partially filled sudoku which is valid.</figcaption>
</figure>
<blockquote>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>'.'</code>.</p>
</blockquote>
<p><strong>Example 1:</strong> &gt; Input: [   ["5","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"]] &gt; Output: true</p>
<p><strong>Example 2:</strong> &gt; Input: [   ["8","3",".",".","7",".",".",".","."],   ["6",".",".","1","9","5",".",".","."],   [".","9","8",".",".",".",".","6","."],   ["8",".",".",".","6",".",".",".","3"],   ["4",".",".","8",".","3",".",".","1"],   ["7",".",".",".","2",".",".",".","6"],   [".","6",".",".",".",".","2","8","."],   [".",".",".","4","1","9",".",".","5"],   [".",".",".",".","8",".",".","7","9"]] &gt; Output: false &gt; Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.</p>
<p><strong>Note :</strong> - A Sudoku board (partially filled) could be valid but is not necessarily solvable. - Only the filled cells need to be validated according to the mentioned rules. - The given board contain only digits 1-9 and the character <code>'.'</code>. - The given board size is always <code>9x9</code>.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>咋一看以为是解数独，会很复杂。读完题目后，发现只要求判断当前的棋盘上的数字是不是有效的，不需要考虑最终这个数独是不是可以解。所以相当于只需要判断当前这个已经存在的棋盘是否满足数独规则的要求。</p>
<p>数独的规则要求，每行，每列，以及每个<code>3x3</code>的子棋盘上，是否包括<code>1-9</code>这9个数字且不重复。现在考虑，肯定是需要把整个棋盘扫描一遍的，那么我们可以设置三个状态数组，来分别记录下以及扫描过的 <code>行/列/子棋盘</code> 中已经出现过的数，如果扫描到某 <code>行/列/子棋盘</code> 中有重复的元素前面已经出现过，直接返回false；若直到扫描结束，也为发现重复元素，说明棋盘有效，返回true。但是由于要记录每 <code>行/列/子棋盘</code> 的状态，需要声明三个较大的数组，所以对空间的消耗较高，应该还有更优化的解法。</p>
<p>评论区解题的大致思路都差不多，区别主要再求如何存储状态数组。有一种很优化的方法是利用位操作实现的，这种方法只使用一个short就存储了一行的状态，节省了很多空间，效率也得到了提升。 &gt; 1. 每行的状态初始化为0； &gt; 2. 遇到一个数字num，就将1左移num位与状态数进行与操作，若结果不为0，说明有重复，返回false；否则，无重复，更新状态，即两数进行或操作。</p>
<p>参考： <a href="https://leetcode.com/problems/valid-sudoku/discuss/15452" target="_blank" rel="noopener">C++ very simple and easy understand. using bit operation</a> <a href="https://leetcode.com/problems/valid-sudoku/discuss/15705/" target="_blank" rel="noopener">My C++ code (O(n2) time and space)</a></p>
<h3 id="三代码">三、代码</h3>
<h4 id="解法1">解法1</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; rows(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; columns(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; sub_box(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="number">9</span>, <span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> sub_box_index = (i/<span class="number">3</span>)*<span class="number">3</span> + (j/<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">int</span> num = board[i][j] - <span class="string">'1'</span>;</span><br><span class="line">                <span class="keyword">if</span>(rows[i][num] || columns[j][num] || sub_box[sub_box_index][num])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                rows[i][num] = columns[j][num] = sub_box[sub_box_index][num] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="利用位操作">利用位操作</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; col(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; block(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; row(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = <span class="number">1</span> &lt;&lt; (board[i][j] - <span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">if</span> (row[i] &amp; idx || col[j] &amp; idx || block[i/<span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>] &amp; idx)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    </span><br><span class="line">                    row[i] |= idx;</span><br><span class="line">                    col[j] |= idx;</span><br><span class="line">                    block[i/<span class="number">3</span> * <span class="number">3</span> + j/<span class="number">3</span>] |= idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法3">解法3</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> existNum[<span class="number">10</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!=<span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(existNum[i][board[i][j] - <span class="string">'0'</span>] &amp; <span class="number">0x1</span>)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// check if the i-row already has such number, LSB</span></span><br><span class="line">                    <span class="keyword">if</span>(existNum[j][board[i][j] - <span class="string">'0'</span>] &amp; <span class="number">0x2</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// check if the j-col already has such number, 2-LSB</span></span><br><span class="line">                    <span class="keyword">if</span>(existNum[(i/<span class="number">3</span>) *<span class="number">3</span> + j/<span class="number">3</span>][board[i][j] - <span class="string">'0'</span>] &amp; <span class="number">0x4</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// check if the k-subblock already has such number, 3-LSB</span></span><br><span class="line">                    existNum[i][board[i][j] - <span class="string">'0'</span>] ^=<span class="number">0x1</span>;</span><br><span class="line">                    existNum[j][board[i][j] - <span class="string">'0'</span>] ^=<span class="number">0x2</span>;</span><br><span class="line">                    existNum[(i/<span class="number">3</span>) *<span class="number">3</span> + j/<span class="number">3</span>][board[i][j] - <span class="string">'0'</span>] ^=<span class="number">0x4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark学习-Spark程序基本运行流程</title>
    <url>/2019/11/16/Spark-learning-record--program-running-process.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>刚好最近学习大数据需要运行简单的Spark算法，就顺便记录一下Spark程序基本上是怎么运行的，这里就不涉及那些理论或者API的用法了。只是说怎么把程序跑起来 <a id="more"></a></p>
<h3 id="基本步骤">基本步骤</h3>
<p>以做的线性回归算法为例(只做了线性回归<code>-_-||</code>)，主要步骤如下： &gt; 1. 编写 Spark 程序，这里涉及到一些 Spark 语法，暂时没看懂，以后系统学习的时候再慢慢深入 &gt; &gt; 2. 将实验数据传到 HDFS 上，配置的 Spark 基于 Hadoop 的 HDFS 运行，所以 Spark 直接访问的是 HDFS 上的数据，不能访问到本地。 &gt; &gt; 3. 将程序(调用<code>pyspark</code>的<code>.py</code>代码)提交到集群执行： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">spark-submit --master spark://host:port program.py</span><br></pre></td></tr></table></figure> 查阅资料 Spark 还有多种运行模式，以后好好学一学(拖延症，不知道啥时候能开始学了) HDFS 的主要操作有以下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">指令</th>
<th style="text-align: left;">功能说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">hdfs dfs -help</td>
<td style="text-align: left;">--查看hdfs帮助</td>
</tr>
<tr class="even">
<td style="text-align: left;">hdfs dfs -ls folder</td>
<td style="text-align: left;">--查看目录文件</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hdfs dfs -put sourcepath savepath</td>
<td style="text-align: left;">--hdfs上传文件，-f 覆盖已有文件；-p 保留原文件属性</td>
</tr>
<tr class="even">
<td style="text-align: left;">hdfs dfs -get sourcepath savepath</td>
<td style="text-align: left;">--hdfs下载文件</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hdfs dfs -mkdir -p /output/dirname</td>
<td style="text-align: left;">--创建多级目录</td>
</tr>
<tr class="even">
<td style="text-align: left;">hdfs dfs -touchz /input/filename</td>
<td style="text-align: left;">--创建文件filename</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hdfs dfs -cat /input/filename</td>
<td style="text-align: left;">--查看文件filename内容</td>
</tr>
<tr class="even">
<td style="text-align: left;">hdfs dfs -du -s /input</td>
<td style="text-align: left;">--查看所有文件大小和字节大小</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hdfs dfs -cp /sourcefile /targetfile</td>
<td style="text-align: left;">--复制文件</td>
</tr>
<tr class="even">
<td style="text-align: left;">hdfs dfs -rm -R /directory</td>
<td style="text-align: left;">--删除文件夹，-R循环删除文件夹里面的文件</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hdfs dfs -mv /user/root/.Trash/Current/filename /filename</td>
<td style="text-align: left;">--找回删除文件</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这是一些较为常用的命令，具体其它指令可以查看<code>hdfs dfs -help</code>可以发现和<code>Linux</code>下文件系统的指令很相似，大部分指令的功能基本相同，只是增加了一些有分布式系统特性的指令，比如<code>-put</code>等。</p>
</blockquote>
<p>参考： &gt; - <a href="https://www.cnblogs.com/zengming/p/10306706.html" target="_blank" rel="noopener">常用HDFS操作命令</a> &gt; - <a href="https://www.cnblogs.com/qiuhong10/p/8476635.html" target="_blank" rel="noopener">Spark多种运行模式</a> &gt; - <a href="https://blog.csdn.net/roguesir/article/details/83317059" target="_blank" rel="noopener">【PySpark学习笔记三】spark-submit命令详解</a></p>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.NULL(一) Course overview + the shell</title>
    <url>/2020/05/27/MIT-6-NULL-one-Course-overview-plus-the-shell.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p><a href="https://missing-semester-cn.github.io/2020/course-shell/" target="_blank" rel="noopener">第一章</a>主要介绍课程概览，shell的一些基础知识。 <a id="more"></a> 课程分为11个时长一小时的讲座，每次围绕一个特定主题。第一次课程主要介绍了shell的使用，这是计算机的一个对外接口，这次课程介绍的许多工具都要通过shell来操作。</p>
<h3 id="主题-1-the-shell">主题 1: The Shell</h3>
<h4 id="shell简介">shell简介</h4>
<p>图形界面等交互式接口会限制我们对计算机的操作，比如无法在GUI上点击一个不存在的按钮。所以需要用到最根本的文字接口：<strong>Shell</strong>。大部分<strong>Shell</strong>的核心功能都是：<code>它允许你执行程序，输入并获取某种半结构化都输出。</code>课程中使用<code>Bourne Again SHell</code>, 简称 <code>“bash”</code>。</p>
<h4 id="shell使用">shell使用</h4>
<p>这里我通过虚拟机安装的ubuntu系统完成课程中的各个实验。首先打开终端，有提示符 &gt; <code>wuyunjie@ubuntu:~$</code></p>
<p>这是shell最主要的文本接口。它告诉你，当前登陆用户是<code>wuyunjie</code>，主机名是 <code>missing</code> 并且当前的工作目录（”current working directory”）或者说当前所在的位置是<code>~</code> (表示 “home”)。 <code>$</code>符号表示您现在的身份不是<code>root</code>用户。可以在其中输入 <em>命令</em> ，命令最终会被shell解析。课程用到的例子如下：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_introduction.png" alt="Shell Introduction" /><figcaption aria-hidden="true">Shell Introduction</figcaption>
</figure>
<p>首先执行了 <code>date</code> 程序，打印出当前的日前和时间。然后，shell等待输入其他命令。</p>
<p>可以在执行命令的同时向程序传递 <code>参数</code>，比如<code>echo hello</code>中，<code>hello</code>是指定输入给<code>echo</code>程序的参数。shell基于<strong>空格</strong>分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），要么用使用单引号，双引号将<code>包含空格的参数</code>包裹起来，要么使用转义符号<code>\</code>进行处理(My Photos)。</p>
<p>shell其实也是一个编程环境，它具备<code>变量、条件、循环和函数</code>。当在shell中执行命令时，实际上是在<code>执行一段shell可以解释执行的简短代码</code>。如果要求shell执行某个指令，但是该指令并不是shell所了解的编程关键字，那么它会去查询 <em>环境变量</em> <code>$PATH</code>，它会列出当shell接到某条指令时，进行程序搜索的路径。要确定某个程序名代表的是哪个具体的程序(程序的路径)，可以使用 <code>which</code> 命令。</p>
<h4 id="shell中的路径">shell中的路径</h4>
<p>shell中的路径是一组<em>被分割的目录</em>，在 Linux 和 macOS 上使用 <code>/</code> 分割，而在Windows上是 <code>\</code> 。路径 <code>/</code> 代表的是系统的根目录，在Windows上每个盘都有一个根目录（例如： C:）。</p>
<p>Linux文件系统中如果某个路径以 <code>/</code> 开头，那么它是一个 <em>绝对路径</em>，其他的都术语 <em>相对路径</em>。相对路径是指相对于<em>当前工作目录</em>的路径，当前工作目录可以使用 <code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code> 命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录。</p>
<p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令。大多数的命令接受<em>标记和选项</em>，它们以 <code>-</code> 开头。通常，在执行程序时使用 <code>-h</code> 或 <code>--help</code> 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_path.png" alt="Shell Path" /><figcaption aria-hidden="true">Shell Path</figcaption>
</figure>
<p><code>ls -l</code>命令可以打印出更加详细地列出目录下文件或文件夹的信息。 1. 首先，本行第一个字符 <code>d</code> 表示是一个目录。 2. 然后接下来的九个字符，每三个字符 (<code>rwx</code>).构成一组。它们分别代表了<code>文件所有者</code>，<code>用户组</code>以及<code>其他所有人</code>具有的权限。其中 <code>-</code> 表示该用户不具备相应的权限，<code>w</code>表示"<em>可修改</em>"，<code>x</code>表示“<em>可执行</em>”，<code>r</code>表示”<code>可读</code>“。</p>
<p>还有一些比较常用的命令：<code>mv</code> （用于重命名或移动文件）、 <code>cp</code> (拷贝文件)以及 <code>mkdir</code> (新建文件夹)。可以使用 <code>man</code> 查阅某条命令的文档（用户手册），比如<code>man ls</code>。</p>
<h4 id="流和管道">"流"和"管道"</h4>
<h5 id="流">流</h5>
<p>在shell中，程序有两个主要的“流”：<strong>输入流</strong>和<strong>输出流</strong>。 1. 当程序尝试读取信息时，它们会从输入流中进行读取； 2. 当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是终端。我们也可以重定向这些流！</p>
<p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件。还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_stream.png" alt="Shell Stream" /><figcaption aria-hidden="true">Shell Stream</figcaption>
</figure>
<h5 id="管道">管道</h5>
<p>使用管道（ <em>pipes</em>），能够更好的利用文件重定向。<code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_pipe.png" alt="Shell Pipe" /><figcaption aria-hidden="true">Shell Pipe</figcaption>
</figure>
<p>可以发现 <code>&gt;</code> 会将之后的单词视为文件名导致，是文件上的重定向。而 <code>|</code> 可以是不同程序之间的重定向。之前总感觉这个地方很混乱，也没仔细深究，现在也算补了一个坑。</p>
<h4 id="功能全面又强大的工具">功能全面又强大的工具</h4>
<p>对于大多数的类Unix系统，<code>根用户</code>（<code>root</code>用户）是非常特殊的。根用户<strong>几乎不受任何限制</strong>，他可以创建、读取、更新和删除系统中的任何文件。当遇到<code>拒绝访问（permission denied）</code>的错误时，通常是因为必须是根用户才能操作。 &gt; 通常在我们并不会以根用户的身份直接登陆系统，因为这样可能会因为某些错误的操作而破坏系统。取而代之的是我们会在需要的时候使用 <code>sudo</code> 命令。顾名思义，它的作用是可以以 <code>su</code>（<code>super user</code> 或 <code>root</code>的简写）的身份 <strong>do</strong> 一些事情。</p>
<p>比如有一件事情是必须作为根用户才能做的，那就是<strong>Linux</strong>下向 <code>sysfs</code> 文件写入内容。系统被挂在在 <code>/sys</code> 下，<code>sysfs</code> 文件则暴露了一些内核（kernel）参数。 因此不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。</p>
<p>课程里那个改屏幕亮度的例子没实现，不知道是不是由于虚拟机配置的关系，这里直接把他的内容摘过来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo find -L /sys/class/backlight -maxdepth 2 -name <span class="string">'*brightness*'</span></span></span><br><span class="line">/sys/class/backlight/thinkpad_screen/brightness</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /sys/class/backlight/thinkpad_screen</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo <span class="built_in">echo</span> 3 &gt; brightness</span></span><br><span class="line">An error occurred while redirecting file 'brightness'</span><br><span class="line">open: Permission denied</span><br></pre></td></tr></table></figure>
<p>尽管用了<code>sudo</code>，但仍然报错了。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过shell执行的，而不是被各个程序单独执行。 <code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， shell在设置 <code>sudo echo</code> 前尝试打开 <code>brightness</code> 文件并写入，但是系统拒绝了shell的操作因为此时shell不是根用户。可以将上述操作修改为 <code>echo 3 | sudo tee brightness</code>，打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。</p>
<h3 id="课后练习">课后练习</h3>
<ol type="1">
<li>前面1-7还好，是对shell的一个熟悉。</li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_exercise.png" alt="Shell exercise1" /><figcaption aria-hidden="true">Shell exercise1</figcaption>
</figure>
<p>主要简单了解了一下<code>shebang</code>，即在脚本开头由字符数字符号和感叹号（<code>＃!</code>）组成的字符序列。当使用带有<code>Shebang</code>的文本文件时，程序加载机制会将文件的其余行解析为解释器指令。加载程序执行指定的解释程序，将尝试运行脚本时最初使用的路径作为参数传递给它，以便程序可以将文件用作输入数据。</p>
<p><code>shebang</code> 解释器指令的形式如下： &gt; <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!interpreter [optional-arg]</span></span><br></pre></td></tr></table></figure></p>
<p><code>interpreter</code>是解释器的绝对路径，<code>optional-arg</code>是表示单个参数的字符串，可选。</p>
<ol start="2" type="1">
<li>8题需要查到<em>最后更改日期信息</em>，并且将其写入文件，这里主要就是如何找到<code>last-modified</code>这一行。刚开始使用<code>find</code>，但它适用于查找文件，查找文本更多用的<code>grep</code>。</li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/MIT_Learning/MIT-6-NULL/shell_exercise2.png" alt="Shell exercise2" /><figcaption aria-hidden="true">Shell exercise2</figcaption>
</figure>
]]></content>
      <categories>
        <category>MIT课程</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>MIT</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.NULL: The Missing Semester of Your CS Education 学习</title>
    <url>/2020/05/27/MIT-6-NULL-The-Missing-Semester-of-Your-CS-Education-Learning.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>最近开始学习一下<code>MIT</code>的一门课程：<a href="https://missing.csail.mit.edu/" target="_blank" rel="noopener">6.NULL: The Missing Semester of Your CS Education</a>。主要是讲了一些Linux上常用的工具。在这个系列课程中，<code>讲授命令行、强大的文本编辑器的使用、使用版本控制系统提供的多种特性等等</code>。 <a id="more"></a> 最初是在知乎上一篇博客<a href="https://zhuanlan.zhihu.com/p/139361685" target="_blank" rel="noopener">6.NULL：恨不相逢“未嫁时”</a>上看见的，确实有许多Linux的工具在编程时可以让起到事半功倍的效果，刚好MIT有这样一门课程可以统一的学习了解一下。写这系列博客，一方面做一个学习笔记，另一方面也督促一下我的学习进度，实在太懒了，又有一些乱七八糟的事情，就慢慢开始学习吧。</p>
<h3 id="课程介绍">课程介绍</h3>
<p>课程内容并不算多，看课程日常表总共有十一章，每天一章。借用知乎博客上的介绍，这门课程内容主要涉及了<code>一些好用（能大大提高生产力）的工具，如terminal、编辑器editor、tmux、profiler、数据处理工具(如awk, sed, grep, perl）等等</code>，都是一些很实用的工具，经常会被用到。课程上主要是告诉你这些工具是做什么的、能实现什么样的事情，并给了一些简单的使用示例，而如果你想要去深入地了解这些工具，课程的notes则提供了一些资料供你阅读。而且这是一门需要结合实际操作的课程，因为都是工具嘛，不用的话也就没啥用了。好了，开始了！！</p>
<h3 id="笔记索引">笔记索引</h3>
<p>下面是学习过程中，每次课程的一些笔记和实战演练，不过其实官网上的介绍已经有许多了。 &gt; 1. <a href="../../../2020/05/27/MIT-6-NULL-one-Course-overview-plus-the-shell.html">MIT 6.NULL(一) Course overview + the shell</a> &gt; 2. <a href=".">MIT 6.NULL(一) Course overview + the shell</a> &gt; 3. <a href=".">MIT 6.NULL(一) Course overview + the shell</a> &gt; 4. <a href=".">MIT 6.NULL(一) Course overview + the shell</a> &gt; 5. <a href=".">MIT 6.NULL(一) Course overview + the shell</a> &gt; 6. <a href=".">MIT 6.NULL(一) Course overview + the shell</a> &gt; 7. <a href=".">MIT 6.NULL(一) Course overview + the shell</a> &gt; 8. <a href=".">MIT 6.NULL(一) Course overview + the shell</a> &gt; 9. <a href=".">MIT 6.NULL(一) Course overview + the shell</a> &gt; 10. <a href=".">MIT 6.NULL(一) Course overview + the shell</a> &gt; 11. <a href=".">MIT 6.NULL(一) Course overview + the shell</a></p>
]]></content>
      <categories>
        <category>MIT课程</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>MIT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/09/20/Hello-World.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<a id="more"></a>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Hexo</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy爬虫-基础使用</title>
    <url>/2019/11/16/scrapy-crawler--basic-use.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>最近大数据课需要用到爬虫爬数据，发现<code>scrapy</code>这个爬虫库还蛮好用的，记录一下它的基本用法。 <a id="more"></a></p>
<h3 id="scrapy框架"><code>scrapy</code>框架</h3>
<p>如下是<code>scrapy</code>架构图，绿色箭头表示组件及在系统中发生的数据流。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/scrapy_architecture.png" alt="scrapy architecture" /><figcaption aria-hidden="true">scrapy architecture</figcaption>
</figure>
<blockquote>
<ul>
<li><strong>Scrapy Engine</strong> 控制数据流在组件中的流动，并在相应动作发生时触发事件</li>
<li><strong>调度器(Scheduler)</strong> 从引擎接受request并将他们入队，以便之后引擎请求他们时提供给引擎</li>
<li><strong>下载器(Downloader)</strong> 负责获取页面数据并提供给引擎，而后提供给spider</li>
<li><strong>Spiders</strong> 用户编写用于分析response并提取item(即获取到的item)或额外跟进的URL的类</li>
<li><strong>Item Pipeline</strong> Item Pipeline负责处理被spider提取出来的item，清理、 验证及持久化等</li>
<li><strong>下载器中间件(Downloader middlewares)</strong> 可以自定义扩展下载功能的组件(比如将滑动条拉到底部)</li>
</ul>
</blockquote>
<p>具体可以参考官网<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/architecture.html" target="_blank" rel="noopener">架构概览</a></p>
<h3 id="简单使用">简单使用</h3>
<p>可以通过<code>scrapy</code>命令直接生成一个框架模板，主要有以下命令： &gt; - 创建项目：scrapy startproject xxx &gt; - 创建爬虫：scrapy genspider xxx（爬虫名） xxx.com （爬取域） &gt; - 生成文件：scrapy crawl xxx -o xxx.type (生成 <code>type</code> 类型的文件) &gt; - 运行爬虫：scrapy crawl XXX &gt; - 列出所有爬虫：scrapy list &gt; - 获得配置信息：scrapy settings [options]</p>
<p>如下是生成的一个爬虫项目的目录信息：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/scrapy_folder.png" alt="project folder" /><figcaption aria-hidden="true">project folder</figcaption>
</figure>
<p>简单的爬虫主要需要修改的就是 <code>items.py</code> 和 <code>example.py</code> 文件。其它比较高端的功能暂时也没用上： &gt; <code>items.py</code> 创建容器的地方，爬取的信息分别放到不同容器里。item是保存爬取数据的容器，使用的方法和字典差不多, 将需要提取的信息在这里定义以下就可以了 &gt; <code>example.py</code> 爬虫文件。负责解析start_url下载的Response 对象，根据item提取数据; 如果有新的url则加入爬取队列，负责进一步处理，URL的Request 对象</p>
<h3 id="数据解析">数据解析</h3>
<p>我这里主要是用的 <code>Xpath</code> 来解析文件, 语法还是比较简单的, 而且容易使用, 可以在 <code>chrome</code> 内使用插件 <code>XPath Helper</code> 来在网页内调试。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/xpath.png" alt="Xpath" /><figcaption aria-hidden="true">Xpath</figcaption>
</figure>
<p>但是有时候 <code>XPath Helper</code> 的解析语句在 <code>scrapy</code> 得到的结果不太兼容, 可以用 <code>scrapy</code> 命令行进一步调试 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy shell &lt;url&gt;</span><br></pre></td></tr></table></figure> 两者结合起来, 基本上就可以写出合理的爬虫解析语句了。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/scrapy/scrapy_shell.png" alt="scrapy shell" /><figcaption aria-hidden="true">scrapy shell</figcaption>
</figure>
<p>xpath具体语法可以参考<a href="https://www.w3school.com.cn/xpath/index.asp" target="_blank" rel="noopener">XPath 教程</a>, 基本上跟着调试调试就懂了。</p>
<h3 id="参考文献">参考文献</h3>
<blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/7dee0837b3d2" target="_blank" rel="noopener">scrapy学习</a></li>
<li><a href="https://www.jianshu.com/p/cecb29c04cd2" target="_blank" rel="noopener">爬虫框架Scrapy个人总结（详细）熟悉</a></li>
<li><a href="https://www.jianshu.com/p/6bc5a4641629" target="_blank" rel="noopener">爬虫框架Scrapy的安装与基本使用</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-1-二维数组中的查找</title>
    <url>/2021/04/02/JZ1-Lookup-in-a-two-dimensional-array.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 <a id="more"></a></p>
<blockquote>
<p>[ [1,2,8,9], [2,4,9,12], [4,7,10,13], [6,8,11,15]]</p>
</blockquote>
<p>给定 target = 7，返回 true。 给定 target = 3，返回 false。</p>
<p><strong>示例1:</strong> &gt; 输入: 7, [[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]] &gt; 返回值: true &gt; 说明: 存在7，返回true</p>
<p><strong>示例2:</strong> &gt; 输入: 3, [[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]] &gt; 返回值: false &gt; 说明: 不存在3，返回false</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题考察的应该是二维数组上的二分查找，因为数组是按从顺序排列的，所有很容易想到将一维数组的思想扩展到二维数组上。但这种思想似乎并不可行，在实现过程中遇到了难度。</p>
<h4 id="方法1-暴力求解">方法1: 暴力求解</h4>
<p>暴力求解法思路很直接，直接将数组中所有数据都遍历一遍，自然可以判断<code>target</code>是否存在于数组中。但该方法复杂度为<code>O(n^2)</code>，即最坏情况下所有元素都需要访问一次。</p>
<h4 id="方法2-二分查找">方法2: 二分查找</h4>
<p>暴力求解方法未用到数组有序这一信息，针对数组有序自然想到二分查找的方法。这里基于题解[1]复习一下二分查找的思想。假设目标tar在arr[1]处，那么二分过程就是：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ1/Binary_Search.png" alt="Binary Search" /><figcaption aria-hidden="true">Binary Search</figcaption>
</figure>
<blockquote>
<p>1）设初始值：定义一个二分的开始下标为l，结束下标为r; 2）二分一半，中间位置为 <code>mid = l + （（r - l) &gt;&gt; 1)</code>(val&gt;&gt;1表示<code>val</code>右移一位相当于<code>val／2</code>)，相当于 <code>l+(r-l)/2</code>，这样的写法是<strong>防止溢出</strong>。如果写成 <code>mid = （l+r)/2;</code> l+r可能会溢出; 3) 如果 <code>tar == arr[mid]</code>，说明找到tar; 4）如果 <code>tar &gt; arr[mid]</code>, 说明tar在区间 <code>[mid+1, r]</code> 中，<code>l = mid + 1</code>; 5）如果 <code>tar &lt; arr[mid]</code>, 说明tar在区间 <code>[l, mid-1]</code> 中, <code>r = mid - 1</code>;</p>
</blockquote>
<p>最初的思想是依样在右上角开始，实现二分查找，思路稍微接近正确的求解，但二分后仍然存在问题，实现上不简洁。如果从左上位置开始二分，每次二分之后，难以确定下一次二分的走向，整个二维数组上顺序被打乱。最开始我的思路是按行从大到小二分，按列从小到大二分，每次将范围固定到某一个片段区域，但实际实现时逻辑不够清晰，代码越写越乱。当然可能仍然是可以按这样的思想实现的，只是我太菜了写不出来。</p>
<p>按照最终答案的思想，也是将二分值固定到右上或者左下的元素上，实现从两个方向不断缩小值所在的范围，这种思想实现上比我之前想的简洁太多了。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ1/Binary_Search_BinArr.png" alt="Binary Search" /><figcaption aria-hidden="true">Binary Search</figcaption>
</figure>
<blockquote>
<p>1）设初始值为右上角元素; 2）二分一半，中间位置为 <code>mid = l + （（r - l) &gt;&gt; 1)</code>(val&gt;&gt;1表示<code>val</code>右移一位相当于<code>val／2</code>)，相当于 <code>l+(r-l)/2</code>，这样的写法是<strong>防止溢出</strong>。如果写成 <code>mid = （l+r)/2;</code> l+r可能会溢出; 3) 如果 <code>val == target</code>, 直接返回; 4）如果 <code>tar &gt; val</code>, 说明 <code>target</code> 在更大的位置，val左边的元素显然都是 <code>&lt; val &lt; tar</code>，说明第 0 行都是无效的，所以val下移到arr[1][5]; 5）如果 <code>tar &lt; val</code>, 说明 <code>target</code> 在更小的位置，val下边的元素显然都是 <code>&gt; val &gt; tar</code>，说明第 5 列都是无效的，所以val左移到arr[0][4];</p>
</blockquote>
<p>时间复杂度：<code>O(m+n)</code> ，其中m为行数，n为列数，最坏情况下，需要遍历m+n次。</p>
<h4 id="方法3-双折半查找法">方法3: 双折半查找法</h4>
<p>参考自题解[2]，该思路与我最开始的思路很相似，看了之后发现还是可以实现的，果然是我太菜了。最坏情况下时间复杂度为<code>O(M * logN)</code> &gt; 1）在二维数组分为上下左右四个边界top，bottom，left，right; &gt; 2）对上边界<code>top</code>进行折半查找，假设终止点为 <code>E</code>，则可以将二维数组位于终止点<code>E</code>右边的矩形<code>Rr</code>排除，因为终止点<code>E</code>小于其右边相邻的元素<code>E+1</code>，而<code>E+1</code>是右边矩形Rr的最小元素(左上元素); &gt; 3) 对下边界<code>bottom</code>折半，可以排除二维数组位于终止点<code>E</code>左边的矩形<code>Rl</code>排除; &gt; 4）对左边界<code>left</code>折半，可以排除二维数组位于终止点<code>E</code>下边的矩形<code>Rb</code>排除; &gt; 5）对右边界<code>right</code>折半，可以排除二维数组位于终止点<code>E</code>上边的矩形<code>Rt</code>排除; &gt; 6) 对由新边界组成的矩形重复以上操作，直到范围缩小为只有一个元素</p>
<h3 id="三代码">三、代码</h3>
<ol type="1">
<li><p>解法1 暴力求法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] vec: array)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: vec)&#123;</span><br><span class="line">                <span class="keyword">if</span> (num == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>解法2 两遍哈希表 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt; array.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target == array[row][col])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[row][col])&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>解法3 双折半查找法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, bottom = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sLeft = <span class="number">0</span>, sRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sTop = <span class="number">0</span>, sBottom = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt; right || top &lt; bottom)&#123;</span><br><span class="line">            <span class="comment">// 在上边界查找，缩小右边界</span></span><br><span class="line">            sLeft = left; sRight = right;</span><br><span class="line">            <span class="keyword">while</span> (sLeft &lt;= sRight) &#123;</span><br><span class="line">                mid = (sLeft + sRight) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[top][mid] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[top][mid] &lt; target)</span><br><span class="line">                    sLeft = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sRight = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; right) right = mid;</span><br><span class="line">            top++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在下边界查找，缩小左边界</span></span><br><span class="line">            sLeft = left; sRight = right;</span><br><span class="line">            <span class="keyword">while</span> (sLeft &lt;= sRight) &#123;</span><br><span class="line">                mid = (sLeft + sRight) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[bottom][mid] == target) </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[bottom][mid] &lt; target) </span><br><span class="line">                    sLeft = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    sRight = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; mid) left = mid; <span class="comment">//利用终止点缩小左边界</span></span><br><span class="line">            bottom--;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对左边界进行折半，可以缩小下边界</span></span><br><span class="line">            sTop = top; sBottom = bottom;</span><br><span class="line">            <span class="keyword">while</span> (sTop &lt;= sBottom) &#123;</span><br><span class="line">                mid = (sTop + sBottom) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[mid][left] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[mid][left] &lt; target)</span><br><span class="line">                    sTop = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sBottom = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; bottom) bottom = mid; <span class="comment">//利用终止点缩小下边界</span></span><br><span class="line">            left++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//对右边界进行折半，可以缩小上边界</span></span><br><span class="line">            sTop = top; sBottom = bottom;</span><br><span class="line">            <span class="keyword">while</span> (sTop &lt;= sBottom) &#123;</span><br><span class="line">                mid = (sTop + sBottom) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[mid][right] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (array[mid][right] &lt; target)</span><br><span class="line">                    sTop = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sBottom = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top&lt;mid) top = mid; <span class="comment">//利用终止点缩小上边界</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (top &lt; array.length &amp;&amp; left &lt; array[<span class="number">0</span>].length &amp;&amp; array[top][left] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<hr />
<h3 id="java学习">Java学习</h3>
<ol type="1">
<li>For-Each循环 <code>For-Each</code>语句(也叫增强型的for循环)是<code>java5</code>的新特征之一，在遍历数组、集合方面，<code>foreach</code>为开发人员提供了极大的方便。但是<code>foreach</code>语句并不能完全取代<code>for</code>语句，任何的<code>foreach</code>语句都可以改写为<code>for</code>语句。值得注意的是，<code>foreach</code>并不是一个关键字，语法如下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(type element: array)&#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其缺点是丢掉了索引信息，foreach只能挨个遍历数组或者集合一遍。但在可以使用foreach的地方，其简化了编程，<em>提高了代码的可读性和安全性（不用怕数组越界）</em>。foreach一般结合泛型使用。</li>
</ol>
<h3 id="参考文献">参考文献</h3>
<p>[1] <a href="https://blog.nowcoder.net/n/f146364d1331407080adbbb5a062e067" target="_blank" rel="noopener">二维数组中的查找</a> [2] <a href="https://blog.nowcoder.net/n/d332492753844d18aa4edc484e3c1318" target="_blank" rel="noopener">《剑指Offer》二维数组中的查找</a> [3] <a href="https://blog.csdn.net/qq_32671287/article/details/79420736" target="_blank" rel="noopener">java中foreach循环</a> [4] <a href="https://www.cnblogs.com/mengdd/archive/2013/01/21/2870019.html" target="_blank" rel="noopener">Java 增强型的for循环 for each</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-10-矩形覆盖</title>
    <url>/2021/05/26/JZ10_Rectangular_coverage.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用<code>n</code>个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，从同一个方向看总共有多少种不同的方法？ <a id="more"></a></p>
<p>比如<code>n=3</code>时，<code>2*3</code>的矩形块有<code>3</code>种不同的覆盖方法(从同一个方向看)：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ10/JZ10.png" alt="矩形覆盖" /><figcaption aria-hidden="true">矩形覆盖</figcaption>
</figure>
<p><strong>示例1</strong></p>
<blockquote>
<p>输入：0 返回值：0</p>
</blockquote>
<p><strong>示例2</strong></p>
<blockquote>
<p>输入：1 返回值：1</p>
</blockquote>
<p><strong>示例3</strong></p>
<blockquote>
<p>输入：4 返回值：5</p>
</blockquote>
<h3 id="二解题思路">二、解题思路</h3>
<p>实际上还是一个类似于斐波那契数列的问题(连续好几个题了)，初始化两个基本的组合，<code>1</code>个<code>2*1</code>的小矩形只有<code>1</code>种组合方式，<code>2</code>个这样的矩阵有两种组合方式，然后是这两个基本组合之上的不断叠加的组合方法。所以可以写为： <span class="math display">\[
F(1)=1\\
F(2)=2\\
F(n) = F(n-1) + F(n-2) (n \geq 3, n \in N^*)
\]</span> 剩下的就是利用之前的递归法，迭代法来实现该算法。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="递归法">1. 递归法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;=<span class="number">2</span>) <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rectCover(target-<span class="number">1</span>) + rectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代法">2. 迭代法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;=<span class="number">2</span>) <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum = sum + one;</span><br><span class="line">            one = sum - one;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo学习记录--基本操作</title>
    <url>/2019/11/11/hexo-learning-record--basic-operation.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>终于决定重新开始写博客了。这次一定得坚持下来，写写学习进度，定期自我总结。太久没写博客了，基本操作又给忘了，这次就索性先从怎么写博客开始，把基本指令都记录下来，省得下次半途而废回来的时候又全忘了到处查。</p>
</blockquote>
<a id="more"></a>
<h3 id="hexo写博客的基本操作">Hexo写博客的基本操作</h3>
<h4 id="写文章">写文章</h4>
<blockquote>
<p>最重要的就是写文章部分了，首先了解如何新建一篇文章。Hexo博客建立开始，就自带一篇 <a href="http://wuyunjie.top/2017/09/20/hello-world/">Hello World</a> 简易教程。新建文章主要用下面这条命令：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里可以指定文章的布局(layout)，默认为 <code>post</code>。这样所有的文章都会以<code>md</code>形式在<code>source</code>文件夹下的<code>_post</code>文件夹中被创建，之后我们就可以愉快的编辑文章了，这是一个<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">markdown的学习文档</a>。</p>
</blockquote>
<h4 id="添加分类页">添加分类页</h4>
<blockquote>
<p>新建一个分类页面，命名为 <code>categories</code>。命令如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page [categories]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以将 <code>categories</code> 改为自己需要的新页面，会在 <code>source</code> 文件夹下新建一个对应名为<code>categories</code>的文件夹。然后编辑主题的 <code>_config.yml</code>，即<code>themes/next</code>下的配置文件，区别于网站根目录下的配置文件，将 <code>menu</code> 中的 <code>categories: /categories || th</code> 注释去掉，在菜单中添加链接。</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure>
<h4 id="文章分类归档">文章分类归档</h4>
<blockquote>
<p>当然也可以个文章进行分类归档，在编辑文章时，为文章添加 <code>tags</code> 和 <code>categories</code>即可。 <figure class="highlight mkdown"><table><tr><td class="code"><pre><span class="line">title: a title</span><br><span class="line">date: a date</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">    - </span>tag1</span><br><span class="line"><span class="bullet">    - </span>tag2</span><br><span class="line"><span class="bullet">    - </span>tag3</span><br><span class="line">categories: a category</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="编辑工具">编辑工具</h4>
<blockquote>
<p>为了方便，感觉又两个在线编辑<code>markdown</code>文档的工具挺好用的。</p>
</blockquote>
<pre><code>&gt; &gt; 1. [小书匠](http://markdown.xiaoshujiang.com/)
&gt; &gt; 2. [MdEditor](https://www.mdeditor.com/)</code></pre>
<blockquote>
<p>当然也可以配置离线工具，但是不太熟。我配了个<code>sublime</code>的，感觉不好看，也不怎么好用。</p>
</blockquote>
<h3 id="生成和部署">生成和部署</h3>
<blockquote>
<p>当编辑完一个博客页面后，我们需要生成静态页面。可以用如下指令。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g #生成</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们不需要急于将页面提交到<code>github</code>，可以先在本地预览效果进行调整，等到达到满意后，再部署到<code>github</code>。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s #启动服务, 通过 `localhost:4000`访问本地页面</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一切准备就绪后，就可以提交了。然后通过自己的域名就可以成功访问博客。不过这一步可能会存在延迟，不会立即看到效果。应该是由于缓存的关系。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d #上传部署到github</span><br></pre></td></tr></table></figure>
<h3 id="常用命令和缩写">常用命令和缩写</h3>
<blockquote>
<p>常用命令有以下几个</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new "postName" #新建文章</span><br><span class="line">hexo new page "pageName" #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一些缩写形式</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>
<blockquote>
<p>至此我们可以开始愉快的玩耍了。</p>
</blockquote>
<h3 id="参考">参考</h3>
<blockquote>
<p>[1] <a href="https://www.jianshu.com/p/1bcad7700c46" target="_blank" rel="noopener">使用hexo搭建github博客</a> [2] <a href="https://www.cnblogs.com/fengzheng/p/8031518.html" target="_blank" rel="noopener">Hexo + github 打造个人博客</a> [3] <a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">使用hexo+github搭建免费个人博客详细教程</a> [4] <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo 指令</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Hexo</tag>
        <tag>写博客</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-12-数值的整数次方</title>
    <url>/2021/05/26/JZ12_Integer_power.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>给定一个<code>double</code>类型的浮点数<code>base</code>和<code>int</code>类型的整数<code>exponent</code>。求<code>base</code>的<code>exponent</code>次方。</p>
<p>保证<code>base</code>和<code>exponent</code>不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面<code>0</code>的位数。 <a id="more"></a></p>
<p><strong>示例1</strong></p>
<blockquote>
<p>输入：2.00000, 3 返回值：8.00000</p>
</blockquote>
<p><strong>示例2</strong></p>
<blockquote>
<p>输入：2.10000, 3 返回值：9.26100</p>
</blockquote>
<p><strong>示例3</strong></p>
<blockquote>
<p>输入：2.00000,-2 返回值：0.25000</p>
</blockquote>
<h3 id="二解题思路">二、解题思路</h3>
<p>根据题意，不需要考虑大数情况，并且<code>exponent</code>是整数，那么直接的方法就是先对<code>exponent</code>的正负判断：</p>
<ul>
<li>若为正整数，直接循环<code>exponent</code>次乘法求出结果</li>
<li>若为负整数，循环<code>-exponent</code>次乘法求出结果，然后对结果求倒数</li>
</ul>
<h4 id="快速幂">快速幂</h4>
<p>假设我们求<span class="math inline">\(x^{8}\)</span>，如果我们知道<span class="math inline">\(x^{4}\)</span>，那么<span class="math inline">\(x^{8} = (x^{4})^{2}\)</span>，<span class="math inline">\(x^{n} = (x^{\frac{n}{2}})^{2}\)</span>。但是还有个小问题，如果n是偶数，那么上述没问题。如果<span class="math inline">\(n\)</span>是奇数，<span class="math inline">\(x^{n} = (x^{\frac{n}{2}})^{2}*x\)</span>，比如<span class="math inline">\(x^{7} = (x^{3})^{2} * x\)</span>。</p>
<h4 id="非递归的快速幂">非递归的快速幂</h4>
<p>假设求<span class="math inline">\(x^{6}\)</span>,已知<code>6</code>可以表示成二进制<code>110</code> 可以表示成<span class="math inline">\(6 = 0*2^{0} + 1 * 2^{1} + 1 * 2^{2}\)</span>, 所以<span class="math inline">\(x^{6}\)</span>可以表示成<span class="math inline">\(x^{6} = x^ {0*2^{0} + 1*2^{1} + 1*2^{2}} = x^{0} * x^{1*2^{1}}*x^{1*2^{2}}\)</span>所以，对于二进制数，遇到位数是<code>1</code>的就乘到答案中。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="直接法">1. 直接法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exponent; i++)</span><br><span class="line">                result *= base;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; -exponent; i++)</span><br><span class="line">                result *= base;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/result;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速幂递归法">2. 快速幂(递归法)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickPower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> res = quickPower(base, exponent/<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res * res * base;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res * res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quickPower(base, exponent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速幂非递归法">3. 快速幂(非递归法)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">            base = <span class="number">1</span>/base;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> x = base;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (exponent != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res *= x; <span class="comment">// 二进制位数是1的，乘进答案。</span></span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            exponent &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-11-二进制中1的个数</title>
    <url>/2021/05/26/JZ11_Number_of_1s_in_binary.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>输入一个整数，输出该数<code>32</code>位二进制表示中<code>1</code>的个数。其中负数用补码表示。 <a id="more"></a></p>
<p><strong>示例1</strong></p>
<blockquote>
<p>输入：10 返回值：2</p>
</blockquote>
<h3 id="二解题思路">二、解题思路</h3>
<h4 id="位运算">1. 位运算</h4>
<p>考查的应该就是位操作吧。实际上要统计<code>1</code>的个数很简单，只需要将整数逐位右移，统计最低位<code>1</code>的出现次数。判断最低为是否为<code>1</code>可以使用等式：<code>n &amp; 1</code>，结果为<code>1</code>即为<code>1</code>，否则为<code>0</code>。</p>
<p>这里有一个需要注意的点是，由于整数是补码表示，所以在右移的时候，若数字为负数会将高位自动补<code>1</code>。这里刚好之前学到<code>Java</code>里有一个无符号右移的运算符: <code>&gt;&gt;&gt;</code>，可以直接解决这个问题。</p>
<ul>
<li><a href="https://wuyunjie.top/2021/05/20/JavaLearning_Head_First_Java_The_Top_Ten_Topics.html">[Java学习|Head_First_Java]--十大遗珠之憾</a></li>
</ul>
<h4 id="技巧法">2. 技巧法</h4>
<p>考虑二进制数：<code>val :1101000</code>, <code>val-1: 1100111</code> 那么<code>val &amp; （val-1） : 1100000</code>。即：</p>
<blockquote>
<p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p>
</blockquote>
<p>把一个整数减去<code>1</code>，再和原整数做与运算，会把该整数最右边一个<code>1</code>变成<code>0</code>.那么一个整数的二进制有多少个<code>1</code>，就可以进行多少次这样的操作。</p>
<h3 id="三代码">三、代码</h3>
<h4 id="位运算-1">1. 位运算</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfOnes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            numOfOnes += (n &amp; <span class="number">1</span>);</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numOfOnes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="技巧法-1">2. 技巧法：</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfOnes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            numOfOnes++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numOfOnes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text3 删除 Markdown Editing 插件后启动报错</title>
    <url>/2019/11/16/Sublime-Text3-removes-the-Markdown-Editing-plugin-leads-to-an-error.html</url>
    <content><![CDATA[<h3 id="sublime-text3启动报错">Sublime Text3启动报错</h3>
<p><code>Sublime Text3</code> 之前装了 <code>Markdown Editing</code> 插件，由于嫌弃界面太难看把他卸载了，之后再次打开<code>.md</code>格式的文件，一直报下面这个错误。 <a id="more"></a> <figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>Error loading colour scheme Packages/MarkdownEditing/MarkdownEditor.tmTheme: Error parsing plist xml: Failed to open file In file "Packages/MarkdownEditing/MarkdownEditor.tmTheme"</span><br></pre></td></tr></table></figure></p>
<p>查阅网上有方法说<code>set syntax:html</code> 可以解决，但这好像不能根本解决问题，依旧会弹出报错弹窗。后面找到文件夹 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Usersname\AppData\Roaming\Sublime Text 3\Packages\User</span><br></pre></td></tr></table></figure> 发现存在卸载残留文件，即 <code>Markdown Editing</code> 的配置文件，将其删除后文集解决，<code>Sublime Text3</code>正常工作。类似的还有一个<code>Error trying to parse settings</code>的报错，也是配置文件的原因，找到报错显示的对应配置文件修改一下就解决了。</p>
]]></content>
      <categories>
        <category>Sublime Text3</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>Sublime Text3</tag>
      </tags>
  </entry>
  <entry>
    <title>pip/conda install 由于目标计算机积极拒绝，无法连接</title>
    <url>/2019/11/23/Pip-conda-install-unable-to-connect-bug.html</url>
    <content><![CDATA[<h3 id="问题">问题</h3>
<p>之前遇到一个困扰已久的问题, 使用 <code>conda/pip install</code> 安装库时一直显示代理有问题, <code>由于目标计算机积极拒绝，无法连接</code>。<a id="more"></a> 一开始一直以为是我的代理设置出现了问题，改了很多次系统代理设置，但一直没有效果。而且这个问题也使得我的谷歌浏览器无法实现科学上网。</p>
<h3 id="解决">解决</h3>
<p>最后终于通过修改注册表解决了这个问题，主要操作如下： &gt; 1. 通过<code>Win+R</code>快捷键，输入<code>regedit</code>，打开注册表编辑器 &gt; 2. 找到<code>HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Internet Settings</code> &gt; 3. 将以 <strong>Proxy</strong> 开头的条目都删除</p>
<p>之后一切就都回复正常了。这个改注册表的方法还挺万用的，有时候会出现无法连上网但是无法访问百度的问题，也可通过删除<code>HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Internet Settings/Connections</code>下的相关条目来解决。</p>
<p>应该是由于科学上网后系统代理出现啥Bug，通过删除注册表可以实现初始化吧。</p>
<h3 id="查看文献">查看文献</h3>
<blockquote>
<ul>
<li><a href="https://blog.csdn.net/lezeqe/article/details/94913345" target="_blank" rel="noopener">解决：pip install 由于目标计算机积极拒绝，无法连接</a></li>
<li><a href="https://blog.csdn.net/weixin_43323092/article/details/82962023" target="_blank" rel="noopener">解决系统代理被篡改/pip提示“目标计算机积极拒绝，无法连接”的方法</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-2-替换空格</title>
    <url>/2021/04/20/JZ2-replace-spaces.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>请实现一个函数，将一个字符串中的每个空格替换成<code>"%20"</code>。例如，当字符串为<code>We Are Happy</code>，则经过替换之后的字符串为<code>We%20Are%20Happy</code>。 <a id="more"></a></p>
<p><strong>示例:</strong> &gt; 输入: "We Are Happy" &gt; 返回值: "We%20Are%20Happy"</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题挺简单的，就是逐个判断String数组的字符，然后基于拼接构建出要求的字符串。也有方法直接调用内置的替换函数，不知道为何难度为<strong>较难</strong>，可能还有特殊的优化解。</p>
<h3 id="三代码">三、代码</h3>
<ol type="1">
<li><p>解法1 暴力求法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">                result += <span class="string">"%20"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>解法2 调用 <code>String.replaceAll()</code> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">   <span class="keyword">return</span> s.replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>解法3 调用 <code>Spring.split()</code> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        String[] strs = s.split(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">" "</span>.equals(str))</span><br><span class="line">                sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            sb.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<hr />
<h3 id="java学习">Java学习</h3>
<ol type="1">
<li>String、StringBuffer和StringBuilder</li>
</ol>
<ul>
<li>String <code>String</code>类是<strong>不可变</strong>类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。通过一个字符串对象a的内存存储空间图对String类的不可变性理解。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ2/String.png" alt="String类不可变" /><figcaption aria-hidden="true"><code>String</code>类不可变</figcaption>
</figure>
<p>再次给a赋值时，并不是对原来堆中实例对象进行重新赋值，而是生成一个新的实例对象，并且指向“456”这个字符串，a则指向最新生成的实例对象，<em>之前的实例对象仍然存在，如果没有被再次引用，则会被垃圾回收</em>。</p>
<ul>
<li>StringBuffer <code>StringBuffer</code>对象则代表一个字符序列<strong>可变</strong>的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的<code>append()</code>、<code>insert()</code>、<code>reverse()</code>、<code>setCharAt()</code>、<code>setLength()</code>等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的<code>toString()</code>方法将其转换为一个String对象。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ2/StringBuffer.png" alt="StringBuffer类" /><figcaption aria-hidden="true"><code>StringBuffer</code>类</figcaption>
</figure>
<p>字符串连接的情况，方便和直接的方式是通过"+"符号来实现，但是这种方式达到目的的效率比较低，且<em>每执行一次都会创建一个String对象</em>，<strong>即耗时，又浪费空间</strong>。使用StringBuilder类就可以避免这种问题的发生</p>
<ul>
<li>StringBuilder <code>StringBuilder</code>类也代表<strong>可变</strong>字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：<strong>StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高</strong>。StringBuffer类中的方法都添加了<code>synchronized</code>关键字，也就是给这个方法添加了一个锁，用来保证线程安全。</li>
</ul>
<p><strong>Java9改进了字符串</strong>（包括String、StringBuffer、StringBuilder）的实现。在Java9以前字符串采用<code>char[]</code>数组来保存字符，因此字符串的每个字符占<code>2</code>字节；而Java9的字符串采用<code>byte[]</code>数组再加一个<code>encoding-flag</code>字段来保存字符，因此字符串的每个字符只占<code>1</code>字节。所以Java9的字符串更加节省空间，字符串的功能方法也没有受到影响。</p>
<h3 id="参考文献">参考文献</h3>
<p>[1] <a href="https://blog.csdn.net/csxypr/article/details/92378336" target="_blank" rel="noopener">String、StringBuffer和StringBuilder的区别</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-13-调整数组顺序使奇数位于偶数前面</title>
    <url>/2021/05/26/JZ13_the_odd_numbers_come_before_the_even_numbers.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 <a id="more"></a></p>
<p><strong>示例1</strong></p>
<blockquote>
<p>输入：[1,2,3,4] 返回值：[1,3,2,4]</p>
</blockquote>
<p><strong>示例2</strong></p>
<blockquote>
<p>输入：[2,4,6,5,7] 返回值：[5,7,2,4,6]</p>
</blockquote>
<h3 id="二解题思路">二、解题思路</h3>
<p>这个题还有一个简单版本，即只需要保证奇数在偶数之前，不需要保证相对位置不变，先考虑这种情况下的解法。主要有两种方法：<strong>首尾双指针</strong>和<strong>快慢双指针</strong>。都是利用<code>双指针</code>求解，只是方向不一样：</p>
<h4 id="首尾双指针">1. 首尾双指针</h4>
<p>定义头指针<code>low</code>，尾指针<code>high</code>。</p>
<ul>
<li><code>low</code>向右移动，直到指向的值为偶数，<code>high</code>一直往左移， 直到指向的值为奇数。交换 <code>nums[low]</code>和<code>nums[high]</code>。</li>
<li>重复上述操作，直到<code>low == high</code> .</li>
</ul>
<h4 id="快慢双指针">2. 快慢双指针</h4>
<p>思路与首尾双指针大致相同，只是此时两个指针向同一个方向移动。定义快慢双指针<code>fast</code>和<code>slow</code>，<code>fast</code>在前，<code>slow</code>在后。</p>
<ul>
<li><code>fast</code>向前搜索奇数位置，slow指向下一个奇数应当存放的位置。<code>fast</code>搜索到奇数时，将它和<code>nums[slow]</code>交换，此时<code>slow</code>向前移动一个位置。</li>
<li>重复上述操作，直到<code>fast</code>指向数组末尾。</li>
</ul>
<p>但是基于首位指针的方法会改变奇数和奇数，偶数和偶数之间的相对位置，所以并不适合于本题。主要有两种思路：</p>
<h4 id="基于插入排序的思想">3. 基于插入排序的思想</h4>
<p>第一种方法基于插入排序的思想，记录已经满足奇数在前面的位置（视为排序中的已经有序部分），然后向前搜索发现奇数进行插入。这种方法只需要少量的额外空间，但时间复杂度较高。</p>
<h4 id="开辟新空间存储排序数组">4. 开辟新空间存储排序数组</h4>
<p>另一种方法事声明一个与原数组相同大小的新数组，用来存储排序后的数组，同时保持相对位置。可以利用首尾双指针的思想，对数组进行一次遍历，头指针处理奇数，尾指针处理偶数。头指针将奇数按顺序放到新数组前，尾指针将偶数按顺序放到新数组后。</p>
<p>为了对空间进一步优化，可以使用一个队列，将偶数放入队列中，按顺序放在原数组中，最后将队列中数据放入剩余的原数组空间，这时只需要额外开辟偶数大小的空间用于存放数据。</p>
<h3 id="三代码实现">三、代码实现</h3>
<h4 id="首尾双指针-1">1. 首尾双指针</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( low &lt; nums.length &amp;&amp; (nums[low] &amp; <span class="number">1</span>) == <span class="number">1</span>) low++;</span><br><span class="line">            <span class="keyword">while</span> ( high &gt;= <span class="number">0</span> &amp;&amp; (nums[high] &amp; <span class="number">1</span>) == <span class="number">0</span>) high--;</span><br><span class="line">            <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">                nums[low] ^= nums[high];</span><br><span class="line">                nums[high] ^= nums[low];</span><br><span class="line">                nums[low] ^= nums[high];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快慢双指针-1">2. 快慢双指针</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (nums[fast] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[slow];</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                nums[fast] = temp;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于插入排序的思想-1">3. 基于插入排序的思想</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>( array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span> array;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> oddIndex = <span class="number">0</span>;<span class="comment">//记录已经是奇数的位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (array[i] &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> k = i;</span><br><span class="line">                temp = array[k];</span><br><span class="line">                <span class="keyword">while</span>(k &gt; oddIndex)&#123;</span><br><span class="line">                    array[k] = array[k-<span class="number">1</span>];<span class="comment">//这区间整体向后移动一位</span></span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                array[k] = temp;</span><br><span class="line">                oddIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="开辟原数组大小的额外空间">4.1 开辟原数组大小的额外空间</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index_head = head;</span><br><span class="line">        <span class="keyword">int</span> index_tail = tail;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; array.length &amp;&amp; tail &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[head] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//奇数，放前面</span></span><br><span class="line">                nums[index_head] = array[head];</span><br><span class="line">                index_head++;</span><br><span class="line">            &#125;</span><br><span class="line">            head++;</span><br><span class="line">            <span class="keyword">if</span>(array[tail] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//从后到前，如果为偶数，则从后开始填</span></span><br><span class="line">                nums[index_tail] = array[tail];</span><br><span class="line">                index_tail--;</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="开辟数组中偶数数量大小的额外空间">4.2 开辟数组中偶数数量大小的额外空间</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index_head = head;</span><br><span class="line">        <span class="keyword">int</span> index_tail = tail;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; array.length &amp;&amp; tail &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[head] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//奇数，放前面</span></span><br><span class="line">                nums[index_head] = array[head];</span><br><span class="line">                index_head++;</span><br><span class="line">            &#125;</span><br><span class="line">            head++;</span><br><span class="line">            <span class="keyword">if</span>(array[tail] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//从后到前，如果为偶数，则从后开始填</span></span><br><span class="line">                nums[index_tail] = array[tail];</span><br><span class="line">                index_tail--;</span><br><span class="line">            &#125;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考文献">参考文献</h3>
<ol type="1">
<li><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/solution/ti-jie-shou-wei-shuang-zhi-zhen-kuai-man-shuang-zh/" target="_blank" rel="noopener">【题解】：首尾双指针，快慢双指针</a></li>
</ol>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-5-用两个栈实现队列</title>
    <url>/2021/05/24/JZ5_implement_the_queue_with_two_stacks.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 <a id="more"></a></p>
<h3 id="二解题思路">二、解题思路</h3>
<p>队列的特性是先进先出(<code>FIFO</code>)，栈的特点是先进后出(<code>FILO</code>)。很容易想到一个直观的方法：</p>
<ol type="1">
<li>将队列数据先存入一个栈；</li>
<li>当需要<code>pop</code>出队列的元素时，将该栈元素逐个弹出存入另一个栈，然后弹出栈顶。</li>
</ol>
<p>但这样会有冗余操作，比如连续的<code>push</code>和连续的<code>pop</code>可以只在其中一个栈中操作，所以可以优化为：</p>
<ol type="1">
<li>需要插入时，直接<code>push</code>到<code>stack1</code>；</li>
<li>需要弹出时，若<code>stack2</code>不为空，弹出<code>stack2</code>的栈顶元素；若<code>stack2</code>为空，将 <code>stack1</code> 中的全部数逐个出栈入栈 <code>stack2</code>，再弹出 <code>stack2</code> 栈顶元素</li>
</ol>
<h3 id="三代码">三、代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-7-斐波那契数列</title>
    <url>/2021/05/25/JZ7_Fibonacci_sequence.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。（<code>n≤39</code>） <a id="more"></a></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 4 返回值: 3</p>
</blockquote>
<h3 id="二解题思路">二、解题思路</h3>
<p>斐波那契数列的标准公式为： <span class="math display">\[
F(1)=1\\F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)
\]</span></p>
<h4 id="递归">1. 递归</h4>
<p>可以发现很符合递归的定义，所以递归是一种直接的思路。但递归法的时间复杂度过高(<span class="math inline">\(O(2^n)\)</span>)。</p>
<h4 id="迭代">2. 迭代</h4>
<ul>
<li><p>另一种方法是直接利用循环，将<span class="math inline">\(F(n), F(n-1), F(n-2)\)</span>保存在三个临时变量内，不断迭代计算出最终值。时间复杂度位(<span class="math inline">\(O(n)\)</span>)。</p></li>
<li><p>继续对空间进行优化，因为<span class="math inline">\(F(n)\)</span>只在计算第<span class="math inline">\(n\)</span>项的时候使用，所以可以只存储<span class="math inline">\(F(n)\)</span>和<span class="math inline">\(F(n-2)\)</span>，<span class="math inline">\(F(n-1)\)</span>可以由<span class="math inline">\(F(n)-F(n-2)\)</span>计算得到</p></li>
</ul>
<h3 id="三代码">三、代码</h3>
<h4 id="递归法">1. 递归法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代法">2. 迭代法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            FibArray_n = FibArray_n_1 + FibArray_n_2;</span><br><span class="line">            FibArray_n_2 = FibArray_n_1;</span><br><span class="line">            FibArray_n_1 = FibArray_n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FibArray_n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化的迭代法只使用两个变量">3. 优化的迭代法(只使用两个变量)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> FibArray_n_1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            FibArray_n = FibArray_n + FibArray_n_1;</span><br><span class="line">            FibArray_n_1 = FibArray_n - FibArray_n_1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FibArray_n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-4-重建二叉树</title>
    <url>/2021/04/26/JZ4-rebuild-binaryTree.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 <a id="more"></a></p>
<p><strong>示例:</strong> &gt; 输入: [1,2,3,4,5,6,7],[3,2,4,1,6,5,7] &gt; 返回值: {1,2,5,3,4,6,7}</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>考察二叉树很经典的题，需要理解前序遍历、中序遍历的方法，然后据此重建二叉树。</p>
<h4 id="二叉树的遍历方法">二叉树的遍历方法</h4>
<blockquote>
<ol type="1">
<li>前序遍历：根左右</li>
<li>中序遍历：左根右</li>
<li>后序遍历：左右根</li>
</ol>
</blockquote>
<p>一般使用递归方法实现遍历，在遍历过程中每个子树都可当作一颗新树递归处理。此外也可以利用栈实现非递归的遍历方法。</p>
<h4 id="方法1-递归方法">方法1: 递归方法</h4>
<p>对于任意一棵树，前序遍历的形式总是：</p>
<blockquote>
<p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</p>
</blockquote>
<p>中序遍历的形式总是：</p>
<blockquote>
<p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p>
</blockquote>
<p>所以在中序遍历中定位到根节点，就可以得到左子树和右子树的节点及节点数目。由此可以进一步在前序遍历结果中，分别得到左右子树。依次类推可以递归构造出子树的左右子树，知道最终左右子树都只剩一个节点，得到一颗完整的树。</p>
<blockquote>
<ol type="1">
<li><p>在中序遍历中对根节点进行定位时，一种简单的方法是<strong>直接扫描整个中序遍历的结果并找出根节点</strong>，但这样做的时间复杂度较高。</p></li>
<li><p>考虑使用<code>哈希表</code>来快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，对中序遍历列表进行一遍扫描，构造出这个哈希映射。在此后构造二叉树的过程中，只需要 <code>O(1)</code> 的时间对根节点进行定位。</p></li>
</ol>
</blockquote>
<h4 id="方法2-非递归迭代方法">方法2: 非递归(迭代)方法</h4>
<p>根据前序遍历原理，对于前序遍历中的任意两个连续节点 <em>u</em> 和 <em>v</em>，只有两种可能的关系：</p>
<blockquote>
<ul>
<li><em>v</em> 是 <em>u</em> 的左儿子。因为在遍历到 <em>u</em> 之后，下一个遍历的节点就是 <em>u</em> 的左儿子，即 <em>v</em>；</li>
<li><em>u</em> 没有左儿子，并且 <em>v</em> 是 <em>u</em> 的某个祖先节点（或者 <em>u</em> 本身）的右儿子。
<ul>
<li>如果 <em>u</em> 没有左儿子，那么下一个遍历的节点就是 <em>u</em> 的右儿子。</li>
<li>如果 <em>u</em> 没有右儿子，就会向上回溯，直到遇到第一个有右儿子（且 <em>u</em> 不在它的右儿子的子树中）的节点 <em>a</em>，那么 <em>v</em> 就是 <em>a</em> 的右儿子。</li>
</ul></li>
</ul>
</blockquote>
<p>用一个<code>栈 stack</code> 来维护<code>「当前节点的所有还没有考虑过右儿子的祖先节点」</code>，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，用一个<code>指针 index</code> 指向<strong>中序遍历</strong>的某个位置，初始值为 <code>0</code>。<code>index</code> 对应的节点是<code>「当前节点不断往左走达到的最终节点」</code>，这也是符合中序遍历。算法流程如下：</p>
<blockquote>
<ol type="1">
<li><p>用一个<code>栈</code>和一个<code>指针</code>辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p></li>
<li><p>依次枚举前序遍历中除了第一个节点以外的每个节点。</p>
<ul>
<li>如果 <code>index</code> 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 <code>index</code>，并将当前节点作为最后一个弹出的节点的右儿子；</li>
<li>如果 <code>index</code> 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</li>
</ul></li>
<li><p>无论是哪一种情况，最后都将当前的节点入栈。</p></li>
</ol>
</blockquote>
<h3 id="三代码">三、代码</h3>
<ol type="1">
<li><p>解法1 递归方法(<strong>直接扫描</strong>) <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> [] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startPre &gt; endPre) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == pre[startPre])&#123;</span><br><span class="line">                root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + i - startIn, in, startIn, startIn + i - <span class="number">1</span>);</span><br><span class="line">                root.right = reConstructBinaryTree(pre, startPre + i - startIn + <span class="number">1</span>, endPre, in, i + <span class="number">1</span>, endIn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>解法1 递归方法(<strong>哈希表</strong>)</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            indexMap.put(in[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> [] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startPre &gt; endPre) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> inRoot = indexMap.get(pre[startPre]);</span><br><span class="line">        root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + inRoot - startIn, in, startIn, startIn + inRoot - <span class="number">1</span>);</span><br><span class="line">        root.right = reConstructBinaryTree(pre, startPre + inRoot - startIn + <span class="number">1</span>, endPre, in, inRoot + <span class="number">1</span>, endIn);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>解法2 迭代法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span> || pre.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> inIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> preVal = pre[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="comment">// 左子树</span></span><br><span class="line">            <span class="keyword">if</span> (node.val != in[inIndex]) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(preVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右子树</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == in[inIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(preVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="java学习">Java学习</h3>
<ol type="1">
<li>思考：如果给你中序遍历序列和后序遍历序列 思路类似于中序遍历和前序遍历的情况，只是在从后续遍历找根节点时，从后序遍历数组末端元素开始。后序遍历的形式总是：</li>
</ol>
<blockquote>
<p>[ [左子树的前序遍历结果], [右子树的前序遍历结果] ,根节点]</p>
</blockquote>
<p>伪代码表示为：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设元素在数组v中，并且尾结点的下标为 root_index, first &lt; root_index &lt; last,</span></span><br><span class="line">TreeNode* build(<span class="keyword">int</span> first, <span class="keyword">int</span> last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt; last) <span class="keyword">return</span> nullptr;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(v[root_index]);</span><br><span class="line">    root-&gt;left = build(first, root_index - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = build(root_index + <span class="number">1</span>, last);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>需要注意的是，这里中序遍历起到很重要的作用，基于中序遍历可以分隔开左右子树。而仅仅给定前序遍历和后序遍历时，是无法得到唯一子树的。比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">树1：</span><br><span class="line">        3</span><br><span class="line">       /</span><br><span class="line">      9</span><br><span class="line">     /</span><br><span class="line">    8</span><br><span class="line">   / </span><br><span class="line">  5</span><br><span class="line"> /</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">树2：</span><br><span class="line">        3</span><br><span class="line">         \</span><br><span class="line">          9</span><br><span class="line">           \</span><br><span class="line">            8</span><br><span class="line">             \</span><br><span class="line">              5</span><br><span class="line">               \</span><br><span class="line">                4</span><br></pre></td></tr></table></figure>
<p>以上这两棵特殊的树，其前序遍历，后续遍历结果都是：[3, 9, 8, 5, 4]，[4, 5, 8, 9, 3]。难以构造出唯一的树。 ### 参考文献 [1] <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">力扣官方题解——重建二叉树</a></p>
</blockquote>
<p>[2] <a href="https://blog.nowcoder.net/n/c56eeb5b1845432a903db1c3c0cbc80a" target="_blank" rel="noopener">[编程题]重建二叉树</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-6-旋转数组的最小数字</title>
    <url>/2021/05/24/JZ6_rotate_the_smallest_number_of_the_array.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 <strong>NOTE</strong>：给出的所有元素都大于0，若数组大小为0，请返回0。 <a id="more"></a></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [3,4,5,1,2] 返回值: 1</p>
</blockquote>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题应该是类似于查找的问题，其中数组为非递减序列是一个很关键的信息。</p>
<h4 id="暴力方法">1. 暴力方法</h4>
<p>对于查找类型的问题，都存在暴力方法，即将整个数组都遍历一遍，总会找到最小值。</p>
<h4 id="二分查找">2. 二分查找</h4>
<p>可以发现，选择数组中要找到的最小元素，即为分界线处的元素。即需要通过二分查找的方法，找到数组中的分界线。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ6/JZ61.png" alt="旋转数组" /><figcaption aria-hidden="true">旋转数组</figcaption>
</figure>
<p>在分界线左边的元素一定是要比分界线右边元素大的。所以可以基于二分查找方法，设定<code>low</code>和<code>high</code>的位置，然后判断<code>mid</code>位置是在数组的<code>左半部分</code>还是<code>右半部分</code>，逐渐缩小范围找到最小值。</p>
<ul>
<li>处于左半部分，<code>low</code>移到<code>mid</code>处</li>
<li>处于右半部分，<code>high</code>移到<code>mid</code>处</li>
<li>其他情况<code>low++</code></li>
</ul>
<p>但后来检测发现一个<code>bug</code>，遇到<code>[1, 0, 1, 1, 1]</code>这样的情况会出错：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ6/JZ62.png" alt="错过了最小值0" /><figcaption aria-hidden="true">错过了最小值<code>0</code></figcaption>
</figure>
<p>为了解决该问题，只需要在提前检查数列，如果是非递减数列，返回最低位<code>low</code>的值。</p>
<h3 id="三代码">三、代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">1</span>) <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[low] &lt; array[high])</span><br><span class="line">                <span class="keyword">return</span> array[low];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((mid + <span class="number">1</span>) &lt; array.length &amp;&amp; array[mid] &gt; array[mid + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> array[mid + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>((mid - <span class="number">1</span>) &gt; -<span class="number">1</span> &amp;&amp; array[mid] &lt; array[mid - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> array[mid];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[low])</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; array[high])</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更简单的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rotateArray.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = rotateArray.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="comment">// 子数组是非递减的数组，10111</span></span><br><span class="line">        <span class="keyword">if</span> (rotateArray[low] &lt; rotateArray[high]) </span><br><span class="line">            <span class="keyword">return</span> rotateArray[low];</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[low])</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[high])</span><br><span class="line">            high = mid; <span class="comment">// 如果是mid-1，则可能会错过最小值，因为找的就是最小值</span></span><br><span class="line">        <span class="keyword">else</span> low++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rotateArray[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考文献">参考文献</h3>
<p>[1] <a href="https://blog.nowcoder.net/n/dcb0f2e6ffd44e1895b7a5297e362778" target="_blank" rel="noopener">【剑指offer T11】旋转数组的最小数字</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-9-跳台阶扩展问题</title>
    <url>/2021/05/26/JZ9_Jumping_expanding.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 <a id="more"></a> &gt; 输入：3 &gt; 返回值：4</p>
<h3 id="二解题思路">二、解题思路</h3>
<h4 id="迭代递归法">1. 迭代递归法</h4>
<p>还是可以转换为递归的形式，只是这里递归的计算需要改进为遍历所有小于等于n的台阶数： <span class="math display">\[
F(0)=1\\
F(1)=1\\
F(n) = F(n-1) + F(n-2) + \cdots + F(n-n) (n \geq 2, n \in N^*)
\]</span> 那么将最后的递归改进为一个循环，就可以继续利用递归算法来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">	sum += jumpFloorII(target-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="等式推导">2. 等式推导</h4>
<p>可以将该等式化简成一个简单的形式： <span class="math display">\[
F(n) = F(n-1) + F(n-2) + \cdots + F(n-n) (n \geq 2, n \in N^*)
\]</span> 那么可以继续得到<span class="math inline">\(F(n-1)\)</span>的计算等式： <span class="math display">\[
F(n-1) = F(n-2) + F(n-3) + \cdots + F(n-n) (n \geq 3, n \in N^*)
\]</span> 可以把上述两式合并得到： <span class="math display">\[
F(n) = F(n-1) \times 2
\]</span> 利用改等式，可以写出递归，迭代的算法。进一步优化可以将其简化为： <span class="math display">\[
F(n) = 2^{(n-1)}
\]</span></p>
<h3 id="三代码">三、代码</h3>
<h4 id="递归方法">1. 递归方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum += jumpFloorII(target-i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代方法">2. 迭代方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i ; j++)&#123;</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="等式推导递归">3. 等式推导(递归)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> jumpFloorII(target-<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="等式推导迭代法">4. 等式推导(迭代法)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="等式推导最简化形式">5. 等式推导(最简化形式)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-8-跳台阶</title>
    <url>/2021/05/26/JZ8_Step_up.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 <a id="more"></a></p>
<h3 id="二解题思路">二、解题思路</h3>
<p>转换一下思路，其实就是在一颗树上不断搜索，其实可以很容易转化位斐波那契数列的形式，依靠递归算法求解： <span class="math display">\[
F(1)=1\\F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)
\]</span> 那么进一步就可以利用斐波那契数列的优化方法，对该算法从时间复杂度和空间复杂度的角度，不断优化。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ8/JZ8.png" alt="递归树结构" /><figcaption aria-hidden="true">递归树结构</figcaption>
</figure>
<h3 id="三代码">三、代码</h3>
<h4 id="递归方法">1. 递归方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> jumpFloor(target-<span class="number">1</span>) + jumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代方法">2. 迭代方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            sum = sum + one;</span><br><span class="line">            one = sum - one;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-3-从尾到头打印链表</title>
    <url>/2021/04/20/JZ3-print-LinkList-reverse.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<p>输入一个链表，按链表从尾到头的顺序返回一个<code>ArrayList</code>。 <a id="more"></a></p>
<p><strong>示例:</strong> &gt; 输入: {67,0,24,58} &gt; 返回值: [58,24,0,67]</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>这道题也挺简单的，感觉都是考察基础啊，怎么都标为较难。思路很简单，就是遍历链表元素，存入新建的ArrayList对象，最后通过一个反转函数对ArrayList反转。此外还有基于递归的方法，或者先对链表反转，再存入ArrayList。</p>
<p>这里对反转链表操作简单复习一下，可以总结为先存储当前节点的下一节点，再反转当前节点的pnext指针，最后重置head头部。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ3/reverse_linklist.gif" alt="反转链表" /><figcaption aria-hidden="true">反转链表</figcaption>
</figure>
<h3 id="三代码">三、代码</h3>
<ol type="1">
<li>解法1 存入ArrayList后反转 1.1. 直接加入到ArrayList第一个位置实现反转 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; List = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            List.add(<span class="number">0</span>, listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> List;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>1.2. 调用<code>Collections.reverse()</code> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; List = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            List.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(List);</span><br><span class="line">        <span class="keyword">return</span> List;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p>解法2 反转链表 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = listNode;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(pre.val);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>解法3 递归方法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<hr />
<h3 id="java学习">Java学习</h3>
<ol type="1">
<li><p>Java <code>ArrayList</code>类 ArrayList 类是一个<strong>可以动态修改</strong>的数组，与普通数组的区别就是它是<strong>没有固定大小的限制</strong>，我们可以添加或删除元素。ArrayList 类位于<code>java.util</code>包中，使用前需要引入它，语法格式如下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 引入 ArrayList 类</span></span><br><span class="line">ArrayList&lt;E&gt; objectName =<span class="keyword">new</span> ArrayList&lt;&gt;();　 <span class="comment">// 初始化</span></span><br></pre></td></tr></table></figure> ArrayList 是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p></li>
<li><p>Collections <code>Collections</code>是JDK提供的工具类，同样位于<code>java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。</p></li>
</ol>
<h3 id="参考文献">参考文献</h3>
<p>[1] <a href="https://www.runoob.com/java/java-arraylist.html" target="_blank" rel="noopener">String、StringBuffer和StringBuilder的区别</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>面试复习</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>[大数据技术原理|第三篇 大数据处理与分析(2)]</title>
    <url>/2021/08/04/Big_Data_3_process-and-analyze-2.html</url>
    <content><![CDATA[<h3 id="简介">简介</h3>
<p><code>Spark</code>最初的设计目标是使数据分析更快——不仅运行速度快，也要能快速、容易地编写程序。为了使程序运行更快， <code>Spark</code>提供了内存计算，减少了迭代计算时的<code>IO开销</code>；而为了使编写程序更为容易， <code>Spark</code>使用简练、优雅的<code>Scala</code>语言编写，基于<code>Scala</code>提供了交互式的编程体验。</p>
<a id="more"></a>
<h3 id="spark概述">1. Spark概述</h3>
<h4 id="spark简介">1.1 Spark简介</h4>
<p><code>Spark</code>具有如下4个主要特点：</p>
<ol type="1">
<li><strong>运行速度快</strong>。<code>Spark</code>使用先进的<code>DAG（ Directed Acyclic Graph，有向无环图）</code>执行引擎，以支持循环数据流与内存计算，基于内存的执行速度可比 Hadoop MapReduce快上百倍。</li>
<li><strong>容易使用</strong>。<code>Spark</code>支持使用<code>Scala、Java、Python</code>和<code>R</code>语言进行编程，简洁的API设计有助于用户轻松构建并行程序，并且可以通过<code>Spark Shell</code>进行交互式编程。</li>
<li><strong>通用性</strong>。<code>Spark</code>提供了完整而强大的技术栈，包括<strong>SQL查询、流式计算、机器学习和图算法</strong>组件，这些组件可以无缝整合在同一个应用中，足以应对复杂的计算。</li>
<li><strong>运行模式多样</strong>。 <code>Spark</code>可运行于独立的集群模式中，或者运行于<code>Hadoop</code>中，也可运行于<code>Amazon EC2</code>等云环境中，并且可以访问<code>HDFS</code>、<code>Cassandra</code>、<code>HBase</code>、<code>Hive</code>等多种数据源。</li>
</ol>
<h4 id="scala简介">1.2 Scala简介</h4>
<p><code>Scala</code>是一门现代的多范式编程语言，平滑地集成了面向对象和函数式语言的特性，旨在以简练、优雅的方式来表达常用编程模式。<code>Scala</code>语言的名称来自于<code>“可扩展的语言（ A Scalable Language）"</code>，从写个小脚本到建立个大系统的编程任务均可胜任。<code>Scala</code>运行于<code>JVM</code>上，兼容现有的<code>Java</code>程序。总体而言，<code>Scala</code>具有以下突出的优点。</p>
<ul>
<li><code>Scala</code>具备强大的并发性，支持函数式编程，可以更好地支持分布式系统。</li>
<li><code>Scala</code>语法简洁，能提供优雅的API。</li>
<li><code>Scala</code>兼容<code>Java</code>，运行速度快，且能融合到 Hadoop生态圈中。</li>
</ul>
<h4 id="spark与hadoop的对比">1.3 <code>Spark</code>与<code>Hadoop</code>的对比</h4>
<p><code>Hadoop</code>最主要的缺陷是其MapReduce计算模型延迟过高，无法胜任实吋、快速计算的需求，因而只适用于离线批处理的应用场景。<code>Hadoop</code>主要存在以下缺点：</p>
<ul>
<li><strong>表达能力有限</strong>。计算都必须要转化成<code>Map</code>和<code>Reduce</code>两个操作，难以描述复杂的数据处理过程。</li>
<li><strong>磁盘IO开销大</strong>。每次执行时都需要从磁盘读取数据，并且在计算完成后需要将中间结果写入到磁盘中。</li>
<li><strong>延迟高</strong>。一次计算可能需要分解成一系列按顺序执行的<code>MapReduce</code>任务，任务之间的衔接由于涉及到<code>IO</code>开销，会产生较高延迟。在前一个任务执行完成之前，其他任务无法开始。</li>
</ul>
<p><code>Spark</code>在借鉴<code>Hadoop MapReduce</code>优点的同时，很好地解决了<code>MapReduce</code>所面临的问题。<code>Spark</code>主要具有如下优点：</p>
<ul>
<li><strong><u>编程模型比<code>MapReduce</code>更灵活</u></strong>。<code>Spark</code>的计算模式也属于<code>MapReduce</code>，但不局限于<code>Map</code>和<code>Reduce</code>操作，还提供了多种数据集操作类型。</li>
<li><code>Spark</code>提供了<strong>内存计算</strong>，中间结果直接放到内存中，带来了更高的迭代运算效率。</li>
<li><code>Spark</code>基于<code>DAG</code>的任务调度执行机制，要优于<code>MapReduce</code>的迭代执行机制。</li>
</ul>
<p><code>Spark</code>最大的特点就是<strong><u>将计算数据、中间结果都存储在内存中，大大减少了IO开销</u></strong>，因而<code>Spark</code>更适合于<strong><u>迭代运算比较多的数据挖掘与机器学习运算</u></strong>。</p>
<p><code>Spark</code>并不能完全替代<code>Hadoop</code>，主要用于替代<code>Hadoop</code>中的<code>MapReduce</code>计算模型，它可以借助于<code>YARN</code>实现资源调度管理，借助于<code>HDFS</code>实现分布式存储。<code>Spak</code>对硬件的要求稍高，对内存喝CPU有一定要求。</p>
<h3 id="spark生态系统">2. Spark生态系统</h3>
<p><code>Spark</code>的设计遵循<code>“一个软件栈满足不同应用场景”</code>的理念，逐渐形成了一套完整的生态系统，既能够提供内存计算框架，也可以支持<code>SQL</code>即席査询、实时流式计算、机器学习和图计算等。<code>Spark</code>可以部署在资源管理器<code>YARN</code>之上，提供一站式的大数据解决方案。</p>
<p><code>Spark</code>生态系统已经成为<strong>伯克利数据分析软件栈</strong><code>BDAS（Berkeley Data Analytics Stack）</code>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/BDAS.png" alt="伯克利数据分析软件栈BDAS" /><figcaption aria-hidden="true">伯克利数据分析软件栈BDAS</figcaption>
</figure>
<p><code>Spak</code>生态系统主要包含了<code>Spark Core</code>、<code>Spark SQL</code>、<code>Spark Streaming</code>、<code>MLlib</code>和<code>GraphX</code>等组件，各个组件的具体功能如下。</p>
<ol type="1">
<li><strong>Spark Core</strong>。Spark Core包含<code>Spark</code>的基本功能，如内存计算、任务调度、部署模式、故障恢复、存储管理等，主要面向批数据处理。<code>Spark</code>建立在统一的抽象<code>RDD</code>之上，使其可以<strong><u>以基本一致的方式应对不同的大数据处理场景</u></strong>。</li>
<li><strong>Spark SQL</strong>。Spark SQL允许开发人员直接处理<code>RDD</code>，同时也可查询Hive、HBase等外部数据源。Spark SQL的一个重要特点是其<strong><u>能够统一处理关系表和<code>RDD</code></u></strong>，开发人员可以轻松地使用SQL命令进行查询，进行更复杂的数据分析。</li>
<li><strong>Spark Streaming</strong>。Spark Streaming支持高吞吐量、可容错处理的实时流数据处理，其核心思路是<strong><u>将流数据分解成一系列短小的批处理作业</u></strong>，每个短小的批处理作业都可以使用Spark Core进行快速处理。Spark Streaming支持多种数据输入源，如 <code>Kafka</code>、<code>Flume</code>和<code>TCP</code>套接字等。</li>
<li><strong>MLlib（机器学习）</strong>。<code>MLlib</code>提供了常用机器学习算法的实现，包括聚类、分类、回归、协同过滤等。</li>
<li><code>GraphX（图计算）</code>。GraphX是<code>Spark</code>中用于图计算的API，可认为是<code>Pregel</code>在<code>Spark</code>上的重写及优化，<code>GraphX</code>性能良好，拥有丰富的功能和运算符，能在海量数据上自如地运行复杂的图算法。</li>
</ol>
<h3 id="spark-运行架构">3. Spark 运行架构</h3>
<h4 id="基本概念">3.1 基本概念</h4>
<ul>
<li><code>RDD</code>：即<code>弹性分布式数据集（ Resilient Distributed dataset）</code>，是分布式内存的一个抽象概念，提供了一种高度受限的<strong>共享内存模型</strong>；</li>
<li><code>DAG</code>：即<code>Directed Acyclic Graph（有向无环图）</code>，反映<code>RDD</code>之间的依赖关系</li>
<li><code>Executor</code>：运行在工作节点（Worker Node）上的一个进程，负责运行任务，并为应用程序存储数据。</li>
<li><code>Application</code>：用户编写的<code>Spark</code>应用程序。</li>
<li><code>Driver</code>：<code>Spark</code>中的<code>Driver</code>运行<code>Application</code>的<code>main</code>函数，并创建<code>SparkContext</code>准备<code>Spark</code>应用程序的运行环境。在<code>Spark</code>中由<code>SparkContext</code>负责与<code>ClusterManager</code>通信，进行资源申请、任务的分配和监控等，当<code>Executor</code>部分运行完毕后，<code>Driver</code>同时负责将<code>SparkContext</code>关闭。</li>
<li><code>Task</code>：运行在<code>Executor</code>上的工作单元。</li>
<li><code>Job</code>：一个作业包含多个<code>RDD</code>及作用于相应<code>RDD</code>上的各种操作。</li>
<li><code>Stage</code>：是作业的基本调度单位，一个作业会分为多组任务，每组任务被称为“阶段”，或者也被称为“任务集”。</li>
<li><code>CluterManager</code>：指集群上获取资源的外部服务。目前有三种类型
<ol type="1">
<li><code>Standalon</code> ：<code>Spark</code>原生的资源管理，由<code>Master</code>负责资源的分配</li>
<li><code>Apache Mesos</code>：与<code>Hadoop MR</code>兼容性良好的一种资源调度框架</li>
<li><code>Hadoop Yarn</code>：主要是指<code>Yarn</code>中的<code>ResourceManager</code></li>
</ol></li>
</ul>
<h4 id="架构设计">3.2 架构设计</h4>
<p>Spark运行架构，包括<code>集群资源管理器（Cluster Manager）</code>，运行作业任务的<code>工作节点（Worker Node）</code>、每个应用的<code>任务控制节点（Driver）</code>和每个工作节点上负责具体任务的<code>执行进程（Executor）</code>。集群资源管理器可以是<code>Spak</code>自带的资源管理器，也可以是<code>YARN</code>或<code>Mesos</code>等资源管理框架。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/Spark.png" alt="Spark运行架构" /><figcaption aria-hidden="true">Spark运行架构</figcaption>
</figure>
<p><code>Spark</code>所采用的<code>Executor</code>有两个优点：</p>
<ul>
<li>利用多线程来执行具体的任务（Hadoop MapReduce采用的是进程模型），减少任务的启动开销；</li>
<li><code>Executor</code>中有一个<code>BlockManager</code>存储模块，会将内存和磁盘共同作为存储设备，当需要多轮迭代计算时，可以将中间结果存储到这个存储模块里，减少IO开销。</li>
</ul>
<p><code>Spark</code>中各个概念的关系为：</p>
<ul>
<li><code>Spark</code>中一个<code>应用（Application）</code>由一个<code>任务控制节点（Driver）</code>和若干个<code>作业（Job）</code>构成；</li>
<li>一个作业由多个<code>阶段（Stage）</code>构成；</li>
<li>一个阶段由多个<code>任务（Task）</code>组成。</li>
</ul>
<p>当执行一个应用时，任务控制节点会向集群管理器（Cluster Manager）申请资源，启动 Executor，并向Executor发送应用程序代码和文件，然后在Executor上执行任务，运行结束后执行结果会返回给任务控制节点，或者写到HDFS或者其他数据库中。</p>
<h4 id="spark运行基本流程">3.3 Spark运行基本流程</h4>
<p><code>Spark</code>运行基本流程如下：</p>
<ol type="1">
<li>当一个<code>Spak</code>应用被提交时，首先为这个应用构建<strong><u>基本运行环境</u></strong>，即由<code>任务控制节点（Driver）</code>创建一个<code>Spark Context</code>，由<code>Spark Context</code>负责和Cluster Manager的通信以及进行资源的申请、任务的分配和监控等。<code>Spark Context</code>会向资源管理器注册并申请运行Executor的资源。</li>
<li>资源管理器为Executor分配资源，并启动Executor进程，Executor运行情况将随着“心跳”发送到资源管理器上。</li>
<li><code>Spark Context</code>根据<code>RDD</code>的依赖关系构建<code>DAG</code>图，<code>DAG</code>图提交给<code>DAG调度器（DAG Scheduler）</code>进行解析，将DAG图分解成多个“阶段”，并且计算出各个阶段之间的依赖关系，然后把“任务集”提交给底层的<code>任务调度器（Task Scheduler）</code>进行处理；<code>Executor</code>向<code>Spark Context</code>申请任务，任务调度器将任务分发给<code>Executor</code>运行，同时<code>Spark Context</code>将应用程序代码发放给<code>Executor</code>；</li>
<li>任务在Executor运行，把执行结果反馈给任务调度器，然后反馈给DAG调度器，运行完毕后写入数据并释放所有资源。</li>
</ol>
<p><code>Spark</code>运行架构具有以下特点。</p>
<ul>
<li>每个应用都有自己专属的<code>Executor</code>进程，并且该进程在应用运行期间一直驻留。<code>Executor</code>进程以多线程的方式运行任务，减少了多进程任务频繁的启动开销。</li>
<li><code>Spark</code>运行过程与资源管理器无关，只要能够获取<code>Executor</code>进程并保持通信即可。</li>
<li><code>Executor</code>上有一个<code>BlockManager</code>存储模块，会将内存和磁盘共同作为存储设备，提高读写IO性能。</li>
<li>任务采用了<strong>数据本地性</strong>和<strong>推测执行</strong>等优化机制。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/SparkWork.png" alt="Spark运行基本流程" /><figcaption aria-hidden="true">Spark运行基本流程</figcaption>
</figure>
<h4 id="rdd的设计与运行原理">3.4 RDD的设计与运行原理</h4>
<h5 id="rdd的概念">3.4.1 RDD的概念</h5>
<p>一个<code>RDD</code>就是一个分布式对象集合，本质上是一个<strong><u>只读的分区记录集合</u></strong>。</p>
<ul>
<li><p>每个<code>RDD</code>可分成多个分区，每个分区就是一个<strong><u>数据集片段</u></strong>，并且一个<code>RDD</code>的不同分区可以被保存到集群中不同的节点上，从而<u><strong>可以在集群的不同节点上进行并行计算</strong></u>。</p></li>
<li><p><code>RDD</code>提供了一种高度受限的共享内存模型，即<code>RDD</code>是<strong><u>只读的记录分区的集合，不能直接修改</u></strong>。只能基于稳定的物理存储中的数据集创建<code>RDD</code>，或者通过在其他<code>RDD</code>上执行确定的转换操作（如<code>map</code>，<code>join</code>和<code>groupBy</code>）而创建得到新的<code>RDD</code>。</p></li>
</ul>
<p><code>RDD</code>提供了一组丰富的操作以支持常见的数据运算</p>
<ul>
<li><code>“行动”（Action）</code>。用于执行计算并指定输出的形式，行动操作（如<code>count</code>、<code>collect</code>等）<strong><u>接受<code>RDD</code>但是返回非<code>RDD</code></u></strong>（即输出一个值或结果）。</li>
<li><code>转换”（Transformation）</code>。指定<code>RDD</code>之间的相互依赖关系，转换操作（如<code>map</code>、<code>filter</code>、<code>groupBy</code>、<code>join</code>等）<strong><u>接受<code>RDD</code>并返回<code>RDD</code></u></strong>。</li>
</ul>
<p><code>RDD</code>执行过程：</p>
<ol type="1">
<li><code>RDD</code>读入外部数据源进行创建；</li>
<li><code>RDD</code>经过一系列的<code>转换（Transformation）</code>操作，每一次都会产生不同的<code>RDD</code>供下一个转换操作使用；</li>
<li>最后一个<code>RDD</code>经过<code>“动作”</code>操作进行处理，并输出到外部数据源。</li>
</ol>
<p><code>RDD</code>使用<strong>惰性调用</strong>：</p>
<ul>
<li>即在<code>RDD</code>的执行过程中，真正的计算发生在<code>RDD</code>的<code>“行动”</code>操作，对于<code>“行动”</code>之前的所有<code>“转换”</code>操作，<code>Spark</code>只记录<code>“转换”</code>操作应用的基础数据集以及<code>RDD</code>生成的轨迹，而不会触发真正的计算。</li>
<li><code>RDD</code>生成的轨迹称为一个<code>“血缘关系(Lineage)"</code>，即<code>DAG</code>拓扑排序的结果。</li>
<li>采用惰性调用，通过血缘关系连接起来的一系列<code>RDD</code>操作就可以实现<code>管道化（Pipeline）</code>，<strong><u>避免了多次转换操作之间数据同步的等待，而且不必担心有过多的中间数据</u></strong>。</li>
</ul>
<h5 id="rdd特性">3.4.2 RDD特性</h5>
<p><code>Spark</code>采用<code>RDD</code>以后能够实现高效计算的主要原因是：</p>
<ul>
<li><strong>高效的容错性</strong>。<code>RDD</code>是一种天生具有容错机制的特殊集合，只需通过<code>RDD</code>父子依赖（血缘）关系重新计算得到丢失的分区来实现容错，无需回滚整个系统，避免了数据复制的高开销。重算过程可以在不同节点之间并行进行，实现了高效的容错。</li>
<li><strong>中间结果持久化到内存</strong>。数据在内存中的多个<code>RDD</code>操作之间进行传递，避免了不必要的IO开销。</li>
<li>存放的数据可以是<code>Java对象</code>，避免了不必要的对象序列化和反序列化开销。</li>
</ul>
<h5 id="rdd之间的依赖关系">3.4.3 RDD之间的依赖关系</h5>
<p><code>RDD</code>中不同的操作会使得不同<code>RDD</code>中的分区产生不同的依赖。<code>RDD</code>中的依赖关系分为<code>窄依赖（Narrow Dependency）</code>与<code>宽依赖（Wide Dependency）</code>。</p>
<ul>
<li>窄依赖表现为一个或多个父<code>RDD</code>的分区对应于一个子<code>RDD</code>的分区。</li>
<li>宽依赖表现为存在一个父<code>RDD</code>的一个分区对应一个子<code>RDD</code>的多个分区。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/SparkDependency.png" alt="窄依赖与宽依赖" /><figcaption aria-hidden="true">窄依赖与宽依赖</figcaption>
</figure>
<p>如果<code>父RDD</code>的一个分区只被一个<code>子RDD</code>的一个分区所使用就是窄依赖，否则就是宽依赖。窄依赖典型的操作包括<code>map</code>、 <code>filter</code>、<code>union</code>等，宽依赖典型的操作包括 <code>groupByKey</code>、<code>sortByKey</code>等。</p>
<ul>
<li>对于窄依赖的RDD，可以以流水线的方式计算所有父分区，不会造成网络之间的数据混合。</li>
<li>对于宽依赖的RDD，则通常伴随着<code>Shuffle</code>操作，即<strong><u>首先需要计算好所有父分区数据，然后在节点之间进行 <code>Shuffle</code></u></strong>。</li>
</ul>
<p>相对而言，在两种依赖关系中，窄依赖的失败恢复更为高效，它只需要根据父RDD分区重新计算丢失的分区即可<strong>（不需要重新计算所有分区）</strong>，而且可以并行地在不同节点上进行重新计算。而对于宽依赖而言，单个节点失效通常意味着重新计算过程会涉及多个父RDD分区，开销较大。</p>
<p>在进行故障恢复时，<code>Spark</code>会对数据检查点开销和重新计算<code>RDD</code>分区的开销进行比较，从而自动选择最优的恢复策略。</p>
<h5 id="阶段的划分">3.4.4 阶段的划分</h5>
<p><code>Spark</code>通过分析各个RDD的依赖关系生成了<code>DAG</code>，再<strong><u>通过分析各个RDD中的分区之间的依赖关系来决定如何划分阶段</u></strong>，具体划分方法是：</p>
<ul>
<li>在<code>DAG</code>中进行反向解析，<strong><u>遇到宽依赖就断开，遇到窄依赖就把当前的<code>RDD</code>加入到当前的阶段中</u></strong>；</li>
<li>将窄依赖尽量划分在同一个阶段中可以实现流水线计算。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/SparkStage.png" alt="阶段的划分" /><figcaption aria-hidden="true">阶段的划分</figcaption>
</figure>
<p>这样划分的主要原因是：由于<code>shuffle</code>依赖必须等<code>RDD</code>的<code>父RDD</code>分区数据<strong><u>全部可读之后</u></strong>才能开始计算，因此<code>Spark</code>的设计是<strong><u>让父RDD将结果写在本地，完全写完之后，通知后面的RDD</u></strong>。后面的RDD则首先去读之前RDD的本地数据作为输入，然后进行运算。</p>
<ul>
<li>写入本地的原因是，后面的RDD多个分区都要去读这个信息，如果放到内存，假如出现数据丢失，后面所有的步骤全部不能进行，违背需要父RDD分区数据全部ready的原则。</li>
</ul>
<p>把一个DAG图划分成多个阶段以后，每个阶段都代表了一组<strong><u>关联的、相互之间没有<code>Shuffle</code>依赖关系的任务</u></strong>组成的任务集合。每个任务集合会被提交给任务调度器进行处理，由任务调度器将任务分发给Executor运行。</p>
<h5 id="rdd运行过程">3.4.5 RDD运行过程</h5>
<ul>
<li>创建RDD对象；</li>
<li><code>Spark Context</code>负责计算RDD之间的依赖关系，构建<code>DAG</code>；</li>
<li><code>DAGScheduler</code>负责把<code>DAG</code>图分解成多个阶段，每个阶段中包含了多个任务；</li>
<li>每个任务会被任务调度器分发给各个工作节点（ Worker Node）上的 Executor去执行。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/SparkRunProcess.png" alt="RDD运行过程" /><figcaption aria-hidden="true">RDD运行过程</figcaption>
</figure>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>[大数据技术原理|第三篇 大数据处理与分析(1)]</title>
    <url>/2021/08/04/Big_Data_3_process-and-analyze-1.html</url>
    <content><![CDATA[<h3 id="简介">简介</h3>
<p>介绍大数据处理与分析相关技术的概念与原理。</p>
<a id="more"></a>
<h3 id="mapreduce">1. MapReduce</h3>
<h4 id="概述">1.1 概述</h4>
<h5 id="简介-1">1.1.1 简介</h5>
<p>分布式并行程序可以运行在由大量计算机构成的集群上，从而可以充分利用集群的并行处理能力，同时通过向集群中增加新的计算节点，就可以很容易地实现集群计算能力的扩充。</p>
<p>在<code>MapReduce</code>中，一个存储在分布式文件系统中的大规模数据集会被切分成许多<strong><u>独立的小数据块</u></strong>，这些小数据块可以被多个<code>Map</code>任务并行处理。<code>MapReduce</code>框架会为每个<code>Map</code>任务输入一个数据子集，<code>Map</code>任务生成的结果会继续作为 <code>Reduce</code>任务的输入，最终由<code>Reduce</code>任务输出最后结果，并写入分布式文件系统。</p>
<p>适合用<code>MapReduce</code>来处理的数据集需要满足一个前提条件：<strong><u>待处理的数据集可以分解成许多小的数据集，而且每一个小数据集都可以完全并行地进行处理</u></strong>。</p>
<p><code>MapReduce</code>设计的一个理念就是<code>“计算向数据靠拢”</code>，因为移动数据需要大量的网络传输开销，所以移动计算要比移动数据更加经济。在一个集群中，只要有可能，<code>MapReduce</code>框架就会将<code>Map</code>程序就近地在<code>HDFS</code>数据所在的节点运行，即<u><strong>将计算节点和存储节点放在一起运行，从而减少了节点间的数据移动开销</strong></u>。</p>
<h5 id="map和reduce函数">1.1.2 Map和Reduce函数</h5>
<p><code>MapReduce</code>模型的核心是<code>Map</code>函数和<code>Reduce</code>函数，二者都是由应用程序开发者负责具体实现的，程序员只要关注如何实现<code>Map</code>和<code>Reduce</code>函数而不需要处理并行编程中的其他各种复杂问题，如分布式存储、工作调度、负载均衡、容错处理、网络通信等，这些问题都会由<code>MapReduce</code>框架负责处理。</p>
<p><code>Map</code>函数和<code>Reduce</code>函数都是以<code>&lt;key, value&gt;</code>作为输入，按一定的映射规则转换成另一个或一批<code>&lt;key, value&gt;</code>进行输出。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">输入</th>
<th style="text-align: center;">输出</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Map</td>
<td style="text-align: center;"><span class="math inline">\(&lt;k_1, v_1&gt;\)</span></td>
<td style="text-align: center;"><span class="math inline">\(List(&lt;k_2,v_2&gt;)\)</span></td>
<td style="text-align: left;">1. 将小数据集进一步解析成一批<code>&lt;key, value&gt;</code>对，输入<code>Map</code>函数中进行处理；<br />2. 每一个输入的<span class="math inline">\(&lt;k_1,v_1&gt;\)</span>​会输出一批<span class="math inline">\(&lt;k_2,v_2&gt;\)</span>​，<span class="math inline">\(&lt;k_2, v_2&gt;\)</span>​是计算的中间结果</td>
</tr>
<tr class="even">
<td style="text-align: center;">Reduce</td>
<td style="text-align: center;"><span class="math inline">\(&lt;k_2,List(v_2)&gt;\)</span></td>
<td style="text-align: center;"><span class="math inline">\(&lt;k_3,v_3&gt;\)</span></td>
<td style="text-align: left;">输入的中间结果<span class="math inline">\(&lt;k_2，List(v_2)&gt;\)</span>中的<span class="math inline">\(List(v_2)\)</span>表示是一批属于同一个<span class="math inline">\(k_2\)</span>的<span class="math inline">\(value\)</span></td>
</tr>
</tbody>
</table>
<ul>
<li><code>Map</code>函数的输入来自于分布式文件系统的<strong><u>文件块</u></strong>，这些文件块的格式是任意的。文件块是一系列元素的集合，这些元素也是任意类型的，<strong><u>同一个元素不能跨文件块存储</u></strong>。<code>Map</code>函数将输入的元素转换成<code>&lt;key, value&gt;</code>形式的键值对，键和值的类型也是任意的。键没有唯一性，不能作为输出的身份标识，即使是同一输入元素，也可通过一个<code>Map</code>任务生成具有相同键的多个<code>&lt;key,vaue&gt;</code>。</li>
<li><code>Reduce</code>函数的任务就是将输入的一系列具有相同键的键值对以某种方式组合起来，输出处理后的键值对，输出结果会合并成一个文件。用户可以指定<code>Reduce</code>任务的个数，并通知实现系统，然后主控进程通常会选择一个<code>Hash</code>函数，<code>Map</code>任务输出的每个键都会经过<code>Hash</code>函数计算，并根据哈希结果将该键值对输入相应的<code>Reduce</code>任务来处理。</li>
</ul>
<h4 id="mapreduce的工作流程">1.2 MapReduce的工作流程</h4>
<h5 id="工作流程概述">1.2.1 工作流程概述</h5>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/MapReduce.PNG" alt="MapReduce" /><figcaption aria-hidden="true">MapReduce</figcaption>
</figure>
<p><code>MapReduce</code>的核心思想可以用<code>“分而治之”</code>来描述，即把一个大的数据集拆分成多个小数据块在多台机器上并行处理。</p>
<ul>
<li>一个大的<code>MapReduce</code>作业，首先会被拆分成许多个<code>Map</code>任务在多台机器上并行执行，每个<code>Map</code>任务通常运行在数据存储的节点上，计算和数据就可以放在一起运行，不需要额外的数据传输开销。</li>
<li>当<code>Map</code>任务结束后，会生成以<code>&lt;key,vaue&gt;</code>形式表示的许多中间结果。这些中间结果会被分发到多个<code>Reduce</code>任务在多台机器上并行执行，具有相同<code>key</code>的<code>&lt;key, value&gt;</code>会被发送到同一个<code>Reduce</code>任务，<code>Reduce</code>任务会对中间结果进行汇总计算得到最后结果，并输出到分布式文件系统中。</li>
</ul>
<p>不同的<code>Map</code>任务之间不会进行通信，不同的<code>Reduce</code>任务之间也不会发生任何信息交换；用户不能显式地从一台机器向另一台机器发送消息，所有的数据交换都是通过<code>MapReduce</code>框架自身去实现的。</p>
<p><code>Map</code>任务的输入文件、<code>Reduce</code>任务的处理结果<strong><u>都是保存在分布式文件系统中的</u></strong>，而<code>Map</code>任务处理得到的<strong><u>中间结果则保存在本地有储中</u></strong>。只有当<code>Map</code>处理全部结束后，<code>Reduce</code>过程才能开始。</p>
<h5 id="mapreduce的各个执行阶段">1.2.2 MapReduce的各个执行阶段</h5>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/MapReduceStage.PNG" alt="MapReduce的各个执行阶段" /><figcaption aria-hidden="true">MapReduce的各个执行阶段</figcaption>
</figure>
<p><code>MapReduce</code>算法的执行过程。</p>
<ol type="1">
<li><code>MapReduce</code>框架使用<code>InputFormat</code>模块做<code>Map</code>前的<strong><u>预处理</u></strong>，比如验证输入的格式是否符合输入定义；然后，将输入文件切分为逻辑上的多个<code>InputSplit</code>
<ul>
<li><strong><u><code>InputSplit</code>是<code>MapReduce</code>对文件进行处理和运算的输入单位</u></strong>，只是一个逻辑概念，每个<code>InputSplit</code>并没有对文件进行实际切割，只是记录了要处理的数据的位置和长度。</li>
</ul></li>
<li>通过<code>RecordReader（RR）</code>根据<code>Inputsplit</code>中的信息来处理<code>InputSplit</code>中的具体记录，加载数据并转换为适合<code>Map</code>任务读取的键值对，输入给Map任务。</li>
<li><code>Map</code>任务会根据用户自定义的映射规则，输出一系列的<code>&lt;key, value&gt;</code>作为中间结果。</li>
<li>对<code>Map</code>的输出进行一定的<code>分区（Portation）</code>、<code>排序（Sort）</code>、<code>合并（Combine）</code>、<code>归并（Merge）</code>等操作，得到<code>&lt;key, value-list&gt;</code>形式的中间结果，再交给对应的<code>Reduce</code>进行处理，这个过程称为<code>Shuffle</code>。从无序的<code>&lt; key, value&gt;</code>到有序的<code>&lt;key value-list&gt;</code>。</li>
<li><code>Reduce</code>以一系列<code>&lt;key, value-list&gt;</code>中间结果作为输入，执行用户定义的逻辑，输出结果给<code>OutputFormat</code>模块。</li>
<li><code>OutputFormat</code>模块验证输出目录是否已经存在以及输出结果类型是否符合配置文件中的配置类型，如果都满足，就输出<code>Reduce</code>的结果到分布式文件系统。</li>
</ol>
<h5 id="shuffle过程">1.2.3 Shuffle过程</h5>
<h6 id="简介-2">1. 简介</h6>
<p><code>Shuffle</code>，是指对<code>Map</code>输出结果进行<strong>分区、排序、合并</strong>等处理并交绐<code>Reduce</code>的过程。</p>
<h6 id="map端的shuffle过程">2. Map端的Shuffle过程</h6>
<p><code>Map</code>的输出结果首先被写入缓存，当缓存满时启动溢写操作，把缓存中的数据写人磁盘文件，并清空缓存。当启动溢写操作时，首先需要把缓存中的数据进行分区，然后对每个分区的数据进行<code>排序（Sort）</code>和<code>合并（Combine）</code>，之后再写入磁盘文件。每次溢写操作会生成一个新的磁盘文件，在<code>Map</code>任务全部结束之前，这些溢写文件会被<code>归并（Merge）</code>成一个大的磁盘文件，然后通知相应的<code>Reduce</code>任务来领取属于自己处理的数据。</p>
<ol type="1">
<li><p>输入数据和执行<code>Map</code>任务</p>
<p><code>Map</code>任务的输入数据一般保存在分布式文件系统的文件块中。<code>Map</code>任务接受<code>&lt;key, vale&gt;</code>作为输入后，按一定的映射规则转换成一批<code>&lt;key, value&gt;</code>进行输出。</p></li>
<li><p>写入缓存</p>
<p>每个<code>Map</code>任务都会被分配一个缓存，<strong><u><code>Map</code>的输出结果不是立即写入磁盘，而是首先写入缓存</u></strong>。在缓存中积累一定数量的<code>Map</code>输出结果以后，再一次性批量写入磁盘。</p></li>
<li><p>溢写（分区、排序和合并）</p>
<ul>
<li><p><code>Map</code>任务结果占满缓存后，必须启动<code>溢写（Spill）</code>操作，把缓存中的内容一次性写入磁盘，并清空缓存。溢写的过程通常是由另外一个单独的后台线程来完成的，不会影响<code>Map</code>结果往缓存写入，为了保证<code>Map</code>结果能够不停地持续写入缓存，不受溢写过程的影响，就必须让缓存中一直有可用的空间，不能等到全部占满才启动溢写过程，一般会设置一个<strong><u>溢写比例</u></strong>。</p></li>
<li><p>在溢写到磁盘之前，缓存中的数据首先会被<code>分区（Partition）</code>。<code>MapReduce</code>通过<code>Partitioner</code>接口对这些键值对进行分区，默认采用的分区方式是采用<code>Hash</code>函数对<code>key</code>进行哈希后再用<code>Reduce</code>任务的数量进行取模。 也可以通过重载<code>Partitioner</code>接口来自定义分区方式。</p></li>
<li><p>对于每个分区内的所有键值对，后台线程会根据<code>key</code>对它们进行<code>内存排序（Sort）</code>，排序是<code>MapReduce</code>的<strong>默认操作</strong>。</p></li>
<li><p>排序结束后，有一个可选的<code>合并（Combine）</code>操作。如果未定义<code>Combiner</code>函数，就不用进行合并操作。如果事先定义了<code>Combiner</code>函数，则这个时候会执行合并操作，从而减少需要溢写到磁盘的数据量。<code>“合并”</code>，是指将那些具有相同<code>key</code>的<code>&lt;key, value&gt;</code>的<code>value</code>加起来，减少了键值对的数量。</p></li>
</ul>
<p>经过分区、排序以及可能发生的合并操作之后，这些缓存中的键值对就可以被写入磁盘，并清空缓存。</p></li>
<li><p>文件归并</p>
<p>在<code>Map</code>任务全部结束之前，系统会对所有溢写文件中的数据进行<code>归并（Merge）</code>，生成一个大的溢写文件，这个大的溢写文件中的所有键值对也是经过分区和排序的。所谓<code>“归并”</code>，是指对于具有相同<code>key</code>的键值对会被归并成一个新的键值对。即对于若干个具有相同<code>key</code>的键值对<code>&lt;k,v1&gt;，&lt;k,v2&gt;...&lt;k,vn&gt;</code>会被归并成一个新的键值对<code>&lt;k, &lt;v1, v2, ..., vn&gt;&gt;</code>。</p>
<p>进行文件归并时，如果磁盘中已经生成的溢写文件的数量超过参数<code>min.num.spills. for.combine</code>的值时，可以再次运行<code>Combiner</code>，对数据进行合并操作，从而减少写入磁盘的数据量。</p></li>
</ol>
<p><code>JobTracker</code>会一直监测<code>Map</code>任务的执行，当监测到一个<code>Map</code>任务完成后，就会立即通知相关的<code>Reduce</code>任务来<code>“领取”</code>数据，然后开始<code>Reduce</code>端的<code>Shuffle</code>过程。</p>
<h6 id="reduce端的shuffle过程">3. Reduce端的Shuffle过程</h6>
<ol type="1">
<li><p><code>“领取”</code>数据</p>
<p><code>Map</code>端的<code>Shuffle</code>过程结束后，所有<code>Map</code>输出结果都保存在<code>Map</code>机器的本地磁盘上，<code>Reduce</code>任务需要把这些数据<strong><u><code>“领取”（Fetch）</code>回来存放到自己所在机器的本地磁盘上</u></strong>。</p>
<ul>
<li>每个<code>Reduce</code>任务会不断地通过<code>RPC</code>向<code>JobTracker</code>询问Map任务是否已经完成；</li>
<li><code>JobTracker</code>监测到一个<code>Map</code>任务完成后，就会通知相关的<code>Reduce</code>任务来<code>“领取”</code>数据；</li>
<li>一旦一个<code>Reduce</code>任务收到<code>JobTracker</code>的通知，它就会到该<code>Map</code>任务所在机器上把属于自己处理的分区数据领取到本地磁盘中。</li>
</ul></li>
<li><p>归并数据</p>
<p>从<code>Map</code>端领回的数据会<strong><u>首先被存放在<code>Reduce</code>任务所在机器的缓存中</u></strong>，如果缓存被占满，就会像<code>Map</code>端一样被溢写到磁盘中。由于在<code>Shuffle</code>阶段<code>Reduce</code>任务还没有真正开始执行，可以把内存的大部分空间分配给<code>Shuffle</code>过程作为缓存。</p>
<p>当溢写过程启动时，具有相同<code>key</code>的键值对会被<code>归并（Merge）</code>，如果用户定义了<code>Combiner</code>，则归并后的数据还可以执行合并操作，减少写入磁盘的数据量。当所有的<code>Map</code>端数据都已经被领回时，多个溢写文件会被归并成一个大文件，归并时还会对键值对进行排序，使得最终大文件中的键值对都是有序的。</p>
<p>在数据很少的情形下，缓存可以存储所有数据，可以直接在内存中执行归并操作，然后直接输出给<code>Reduce</code>任务。</p></li>
<li><p>把数据输入给<code>Reduce</code>任务</p>
<p>磁盘中经过多轮归并后得到的若干个大文件，直接输入给<code>Reduce</code>任务，这样可以减少磁盘读写开销。<code>Reduce</code>任务会执行<code>Reduce</code>函数中定义的各种映射，输出最终结果，并保存到分布式文件系统中。</p></li>
</ol>
<h4 id="mapreduce体系结构">1.3 MapReduce体系结构</h4>
<p><code>MapReduce</code>体系结构主要由四个部分组成，分别是：<code>Client</code>、<code>JobTracker</code>、<code>TaskTracker</code>以及<code>Task</code></p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/MapReduceStructure.PNG" alt="MapReduce体系结构" /><figcaption aria-hidden="true">MapReduce体系结构</figcaption>
</figure>
<ul>
<li><code>Client</code>。用户编写的<code>MapReduce</code>程序通过<code>Client</code>提交到<code>JobTracker</code>端；用户可通过<code>Client</code>提供的一些接口查看作业运行状态</li>
<li><code>JobTracker</code>。<code>JobTracker</code>负责资源监控和作业调度；<code>JobTracker</code> 监控所有<code>TaskTracker</code>与<code>Job</code>的健康状况，一旦发现失败，就将相应的任务转移到其他节点；<code>JobTracker</code> 会跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器（<code>TaskScheduler</code>），而调度器会在资源出现空闲时，选择合适的任务去使用这些资源。</li>
<li><code>TaskTracker</code>。<code>TaskTracker</code>会周期性地通过“心跳”将本节点上资源的使用情况和任务的运行进度汇报给<code>JobTracker</code>，同时接收<code>JobTracker</code> 发送过来的命令并执行相应的操作；<code>TaskTracker</code> 使用<code>“slot”</code>等量划分本节点上的资源量。一个<code>Task</code> 获取到一个<code>slot</code> 后才有机会运行，而<code>Hadoop</code>调度器的作用就是将各个<code>TaskTracker</code>上的空闲<code>slot</code>分配给<code>Task</code>使用。<code>slot</code> 分为<code>Map slot</code> 和<code>Reduce slot</code> 两种，分别供<code>Map Task</code> 和<code>Reduce Task</code> 使用。</li>
<li><code>Task</code>。<code>Task</code> 分为<code>Map Task</code> 和<code>Reduce Task</code> 两种，均由<code>TaskTracker</code> 启动。</li>
</ul>
<h4 id="mapreduce-具体应用">1.4 MapReduce 具体应用</h4>
<h5 id="mapreduce在关系代数中应用">1.4.1 MapReduce在关系代数中应用</h5>
<h6 id="关系的选择运算">1. 关系的选择运算</h6>
<p>对于关系的选择运算，只需要<code>Map</code>过程就能实现，对于关系<code>R</code>中的每个元组<code>t</code>，检测是否是满足条件的所需元组，如果满足条件，则输出键值对<code>&lt;t, t&gt;</code>，即键和值都是<code>t</code>。<code>Reduce</code>函数对输入不作任何变换就直接输出。</p>
<h6 id="关系的投影运算">2. 关系的投影运算</h6>
<p>假设对关系<code>R</code>投影后的属性集为<code>S</code>，在<code>Map</code>函数中，对于<code>R</code>中的每个元组<code>t</code>，剔除<code>t</code>中不属于<code>S</code>的字段得到元组<code>t'</code>，输出键值对<code>&lt;t', t'&gt;</code>。</p>
<p>对于<code>Map</code>任务产生的每个键<code>t'</code>，可能存在一个或多个键值对<code>&lt;t', t'&gt;</code>，通过<code>Reduce</code>函数来剔除冗余，把属性值完全相同的元组合并。</p>
<h6 id="关系的并交差运算">3. 关系的并、交、差运算</h6>
<ul>
<li><p>对两个关系求<strong>并集</strong>时，<code>Map</code>任务将两个关系的元组转换成键值对<code>&lt;t, t&gt;</code>，<code>Reduce</code>任务则是剔除冗余数据的过程。</p></li>
<li><p>对两个关系求<strong>交集</strong>时，使用与并集相同的<code>Map</code>过程，在<code>Reduce</code>过程中，如果键<code>t</code>有两个相同值与它关联，则输出一个元组<code>&lt;t, t&gt;</code>，如果与键关联的只有一个值，则输出空值（<code>NULL</code>）。</p></li>
<li><p>对两个关系求<strong>差</strong>时，<code>Map</code>过程产生的<strong>键值</strong>对不仅要记录元组的信息，还要记录该元组来自于哪个关系（<code>R</code>或<code>S</code>），<code>Reduce</code>过程中按键值相同的<code>t</code>合并后，与键<code>t</code>相关联的值如果只有<code>R</code>（说明该元组只属于<code>R</code>，不属于<code>S</code>），就输出元组，其他情况均输出空值。</p></li>
</ul>
<h6 id="关系的自然连接运算">4. 关系的自然连接运算</h6>
<p>在<code>MapReduce</code>环境下执行两个关系的连接操作的方法如下：</p>
<ul>
<li>假设关系<code>R（A,B）</code>和<code>S（B,C）</code>都存储在一个文件中，为了连接这些关系，必须把来自每个关系的各个元组都和一个键关联，这个键就是属性<code>B</code>的值。</li>
<li>使用<code>Map</code>过程把来自<code>R</code>的每个元组<code>&lt;a, b&gt;</code>转换成一个键值对<code>&lt;b, &lt;R, a&gt;&gt;</code>。这里把关系<code>R</code>包含到值中，使得可以在<code>Reduce</code>阶段只把来自<code>R</code>的元组和来自<code>S</code>的元组进行匹配。</li>
<li>使用<code>Map</code>过程把来自<code>S</code>的每个元组<code>&lt;b, c&gt;</code>转换成一个键值对<code>&lt;b, &lt;S, c&gt;&gt;</code>。</li>
<li><code>Reduce</code>进程把来自关系<code>R</code>和<code>S</code>的具有共同属性<code>B</code>值的元组进行合并。</li>
</ul>
<h5 id="分组与聚合运算">1.4.2 分组与聚合运算</h5>
<ul>
<li><code>Map</code>过程，选择关系的某一字段（也可以是某些属性构成的属性表）的值作为键，其他字段的值作为与键相关联的值。</li>
<li><code>Reduce</code>过程，对相同键相关联的值施加某种聚合运算，如<code>SUM（求和）</code>、 <code>COUNT（计数）</code>、<code>AVG（求平均值）</code>、 <code>MIN</code>和<code>MAX</code>（求最小最大值）等，输出则为<code>&lt;键，聚合运算结果&gt;</code>。</li>
</ul>
<h5 id="矩阵-向量乘法">1.4.3 矩阵-向量乘法</h5>
<p>假定一个<span class="math inline">\(n\)</span>维向量<span class="math inline">\(V\)</span>，其第<span class="math inline">\(j\)</span>个元素记为<span class="math inline">\(v_j\)</span>，假定一个<span class="math inline">\(n \times n\)</span>的矩阵<span class="math inline">\(M\)</span>，其第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列元素记为<span class="math inline">\(m_{ij}\)</span>，则矩阵<span class="math inline">\(M\)</span>和向量<span class="math inline">\(V\)</span>的乘积是一个<span class="math inline">\(n\)</span>维向量<span class="math inline">\(X\)</span>，其第<span class="math inline">\(i\)</span>个元素<span class="math inline">\(x_i = \sum^n_{j=1}{m_{ij}v_j}\)</span>。</p>
<p>矩阵<span class="math inline">\(M\)</span>和向量<span class="math inline">\(V\)</span>各自在分布式文件系统中存成一个文件。假定可以获得矩阵元素的行列下标，计算矩阵和向量乘法的<code>MapReduce</code>函数可以设计为：</p>
<ul>
<li><code>Map</code>函数。每个<code>Map</code>任务将整个向量<span class="math inline">\(V\)</span>​和矩阵<span class="math inline">\(M\)</span>​的一个文件块作为输人。对每个矩阵元素<span class="math inline">\(m_{ij}\)</span>​，<code>Map</code>任务会产生键值对<span class="math inline">\(&lt;i，m_{ij}v_j&gt;\)</span>​。计算<span class="math inline">\(x_i\)</span>​的所有<span class="math inline">\(n\)</span>​个求和项<span class="math inline">\(m_{ij}v_j\)</span>​的键都相同，即都是<span class="math inline">\(i\)</span>​。</li>
<li><code>Reduce</code>函数。<code>Reduce</code>任务将所有与给定键<span class="math inline">\(i\)</span>关联的值相加即可得到<span class="math inline">\(&lt;i, x_i&gt;\)</span>。</li>
</ul>
<h5 id="矩阵乘法">1.4.4 矩阵乘法</h5>
<p>矩阵<span class="math inline">\(M\)</span>第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列元素记为<span class="math inline">\(m_{ij}\)</span>，矩阵<span class="math inline">\(N\)</span>第<span class="math inline">\(j\)</span>行第<span class="math inline">\(k\)</span>列元素记为<span class="math inline">\(n_{jk}\)</span>，则矩阵<span class="math inline">\(P=M \times N\)</span>，其第<span class="math inline">\(i\)</span>行第<span class="math inline">\(k\)</span>列元素为<span class="math inline">\(p_{ik} = \sum^n_{j=1}{m_{ij}n_{jk}}\)</span>。</p>
<p>可以把矩阵看成一个带有3个属性的关系：行下标、列下标和值。因此，矩阵<code>M</code>可以看成关系<code>M</code>，记为<code>M(I, J, V)</code>，元组为<span class="math inline">\(&lt;i, j, m_{ij}&gt;\)</span>，矩阵<code>N</code>可以看作关系<code>N</code>，记为<code>N(J, K, W)</code>，元组为<span class="math inline">\(&lt;j, k, n_{jk}&gt;\)</span>。</p>
<p>矩阵乘法可以看作是一个自然连接运算再加上分组聚合运算。关系<code>M</code>和<code>N</code>根据公共属性<code>J</code>将每个元组连接得到元组<span class="math inline">\(&lt;i,j,k,v,w&gt;\)</span>​​，这个五字段元组代表了两个矩阵的元素对<span class="math inline">\(&lt;m_{ij},n_{jk}&gt;\)</span>​​，对矩阵元素进行求积运算后可以得到四字段元组<span class="math inline">\(&lt;i,j,k,ν \times w&gt;\)</span>​​​，然后可以进行分组聚合运算。矩阵乘法可以通过两个<code>MapReduce</code>运算的串联实现：</p>
<h6 id="自然连接阶段">1. 自然连接阶段</h6>
<ul>
<li><code>Map</code>函数：对每个矩阵元素<span class="math inline">\(m_{ij}\)</span>产生一个键值对<span class="math inline">\(&lt;j, &lt;M, i, m_{ij}&gt;&gt;\)</span>，对每个矩阵元素<span class="math inline">\(n_{jk}\)</span>产生一个键值对<span class="math inline">\(&lt;j，&lt;N,k,n_{jk}&gt;&gt;\)</span>。</li>
<li><code>Reduce</code>函数：对每个相同键<span class="math inline">\(j\)</span>，输出所有满足形式<span class="math inline">\(&lt;j, &lt;i, k, m_{ij}n_{jk}&gt;&gt;\)</span>的元组。</li>
</ul>
<h6 id="分组聚合阶段">2. 分组聚合阶段</h6>
<ul>
<li><code>Map</code>函数：对自然连接阶段产生的键值对<span class="math inline">\(&lt;j, &lt;&lt;i_1, k_1, v_1&gt;,..., &lt;i_p, k_p, v_p&gt;&gt;&gt;\)</span>，产生键值对<span class="math inline">\(&lt;&lt;&lt;i_1, l_1&gt;, v1&gt;,..., &lt;&lt;i_p,k_p&gt;,v_p&gt;&gt;\)</span>；</li>
<li><code>Reduce</code>函数：对每个键<span class="math inline">\(&lt;i,k&gt;\)</span>​，计算与此键关联的所有值的和，结果记为<span class="math inline">\(&lt;&lt;i,k&gt;,v&gt;\)</span>​。</li>
</ul>
<h3 id="hadoop的优化与发展">2. Hadoop的优化与发展</h3>
<h4 id="hdfs-ha">2.1 HDFS HA</h4>
<p>对于分布式文件系统<code>HDFS</code>而言，名称节点（<code>Name Node</code>）是系统的核心节点，存储了各类元数据信息，并负责管理文件系统的命名空间和客户端对文件的访问。</p>
<p>在<code>HDFS1.0</code>中，只存在一个名称节点，一旦这个唯一的名称节点发生故障，就会导致整个集群变得不可用，这就是常说的<code>“单点故障问题”</code>。虽然<code>HDFS1.0</code>中存在一个<code>“第二名称节点（Secondary Name Node）</code>，但是第二名称节点并不是名称节点的备用节点，其<strong><u>主要功能是周期性地从名称节点获取命名空间镜像文件（Fslmage）和修改日志（EditLog），进行合并后再发送给名称节点，替换掉原来的Fslmage，以防止日志文件EditLog过大，导致名称节点失败恢复时消耗过多时间</u></strong>。</p>
<p>第二名称节点无法提供<code>“热备份”</code>功能，即在名称节点发生故障的时候，系统无法实时切换到第二名称节点立即对外提供服务，仍然需要进行停机恢复，因此<code>HDFS1.0</code>的设计是存在单点故障问题的。为了解决单点故障问题，<code>HDFS2.0</code>采用了<code>HA（High Availability）</code>架构。在一个典型的<code>HA</code>集群中，一般设置两个名称节点，其中一个名称节点处于<code>“活跃（Active）”</code>状态，另一个处于<code>“待命（Standby）”</code>状态。</p>
<ul>
<li>处于活跃状态的名称节点负责对外处理所有客户端的请求；</li>
<li>处于待命状态的名称节点则作为备用节点，保存了足够多的系统元数据，当名称节点出现故障时提供快速恢复能力。处于待命状态的名称节点提供了<code>“热备份”</code>，一旦活跃名称节点出现故障，就可以立即切换到待命名称节点，不会影响到系统的正常对外服务。</li>
</ul>
<p>活跃名称节点的状态信息必须实时同步到待命名称节点。两种名称节点的状态同步，可以借助于一个共享存储系统来实现，比如<code>NFS（Network File System）</code>、<code>QJM（Quorum Journal Manager）</code>或者<code>Zookeeper</code>。</p>
<h4 id="hdfs-联邦">2.2 HDFS 联邦</h4>
<p><code>HDFS1.0</code>采用单名称节点的设计，不仅会带来单点故障问题，还存在<strong>可扩展性</strong>、<strong>性能</strong>和<strong>隔离性</strong>等问题。</p>
<p><code>HDFS联邦</code>可以很好地解决上述三个方面的问题。在HDFS联邦中，设计了多个相互独立的名称节点，使得HDFS的命名服务能够水平扩展，这些名称节点分别进行各自命名空间和块的管理，相互之间是联邦关系，不需要彼此协调。<code>HDFS联邦</code>并不是真正的分布式设计，但是采用这种简单的<code>“联合”</code>设计方式。</p>
<p>在<code>HDFS联邦</code>中，所有名称节点会共享底层的数据节点存储资源，每个数据节点要向集群中所有的名称节点注册，并周期性地向名称节点发送“心跳”和块信息，报告自己的状态，同时也会处理来自名称节点的指令。<code>HDFS联邦</code>拥有多个独立的命名空间，每一个命名空间管理属于自己的一组块，这些属于同一个命名空间的块构成一个<code>“块池”（Block pool）</code>。每个数据节点会为多个块池提供块的存储。<strong><u>数据节点是一个物理概念，而块池则属于逻辑概念</u></strong>，一个块池是一组块的逻辑集合，块池中的各个块实际上是存储在各个不同的数据节点中的。因此，HDFS联邦中的一个名称节点失效，也不会影响到与它相关的数据节点继续为其他名称节点提供服务。</p>
<p>对于<code>HDFS</code>联邦中的多个命名空间，可以采用<code>客户端挂载表（Client Side Mount Table）</code>方式进行数据共享和访问，客户可以<strong><u>访问不同的挂载点来访问不同的子命名空间</u></strong>。这就是<code>HDFS联邦</code>中命名空间管理的基本原理，即把各个命名空间挂载到全局<code>“挂载表”（Mount-table）</code>中，实现数据全局共享；同样地，命名空间挂载到个人的挂载表中，就成为应用程序可见的命名空间。</p>
<p>需要注意的是，<code>HDFS联邦</code><u><strong>并不能解决单点故障问题，每个名称节点都存在单点故障问题</strong></u>，需要为每个名称节点部署一个后备名称节点，以应对名称节点宕机后对业务产生的影响。</p>
<h4 id="新一代资源管理调度框架yarn">2.3 新一代资源管理调度框架YARN</h4>
<h5 id="yarn设计思路">2.3.1 <code>YARN</code>设计思路</h5>
<p><code>YARN（ Yet Another Resource Negotiator）</code>架构设计基本思路就是<strong>“放权”</strong>，把原<code>JobTracker</code>三大功能（资源管理、任务调度和任务监控）进行拆分，分别交给不同的新组件去处理。重新设计后得到的<code>YARN</code>包括<code>ResourceManager</code>、 <code>Application Master</code>和<code>NodeManager</code>：</p>
<ul>
<li><code>ResourceManager</code>负责资源管理</li>
<li><code>ApplicationMaster</code>负责任务调度和监控</li>
<li><code>NodeManager</code>负责执行原<code>TaskTracker</code>的任务。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/YARNDesign.PNG" alt="YARN设计思路" /><figcaption aria-hidden="true"><code>YARN</code>设计思路</figcaption>
</figure>
<ul>
<li><p>在<code>Hadoop1.0</code>中，其核心子项目<code>MapReduce1.0</code>既是一个计算框架，也是一个资源管理调度框架。</p></li>
<li><p>到了<code>Hadoop2.0</code>以后，<code>MapReduce2.0</code>中的资源管理调度功能被单独分离出来形成<code>YARN</code>，它是一个纯粹的资源管理调度框架，而不是一个计算框架；被剥离了资源管理调度功能的<code>MapReduce</code>框架就变成了<code>MapReduce2.0</code>，它是运行在<code>YARN</code>之上的一个纯粹的计算框架，不再自己负责资源调度管理服务，而是由<code>YARN</code>为其提供资源管理调度服务。</p></li>
</ul>
<h5 id="yarn体系结构">2.3.2 YARN体系结构</h5>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/YARNStructure.PNG" alt="YARN体系结构" /><figcaption aria-hidden="true">YARN体系结构</figcaption>
</figure>
<h6 id="resource-manager">1. Resource Manager</h6>
<p><code>ResourceManager（RM）</code>是一个全局的资源管理器，负责整个系统的资源管理和分配，主要包括两个组件：</p>
<ul>
<li><code>调度器（ Scheduler）</code>。主要负责资源管理和分配。调度器接收来自<code>ApplicationMaster</code>的应用程序资源请求，并根据容量、队列等限制条件，把集群中的资源以<code>“容器”</code>的形式分配给提出申请的应用程序，容器的选择通常会考虑应用程序所要处理的数据的位置，进行就近选择，实现<strong>“计算向数据靠拢”</strong>。</li>
<li><code>应用程序管理器（Applications Manager）</code>。应用程序管理器负责系统中所有应用程序的管理工作，主要包括应用程序提交、与调度器协商资源以启动<code>ApplicationMaster</code>、监控<code>ApplicationMaster</code>运行状态并在失败时重新启动等。</li>
</ul>
<p>在<code>YARN</code>中是以<code>容器（Container）</code>作为动态资源分配单位，每个容器中都封装了一定数量的CPU、内存、磁盘等资源，从而限定每个应用程序可以使用的资源量。同时，在<code>YARN</code>中调度器被设计成是一个可插拔的组件，<code>YARN</code>不仅自身提供了许多种直接可用的调度器，也允许用户根据自己的需求重新设计调度器。</p>
<p>主要功能包括：</p>
<ul>
<li>处理客户端请求</li>
<li>启动监控<code>ApplicationMaster</code></li>
<li>监控<code>NodeManager</code></li>
<li>资源分配与调度</li>
</ul>
<h6 id="applicationmaster">2. ApplicationMaster</h6>
<p>在Hadoop平台上，用户的应用程序是以<code>作业（Job）</code>的形式提交的，然后一个作业会被分解成多个任务进行分布式执行。<code>ResourceManager</code>接收用户提交的作业，按照作业的上下文信息以及从<code>NodeManager</code>收集来的容器状态信息，启动调度过程，为用户作业启动一个<code>ApplicationMaster</code>。<code>ApplicationMaster</code>的主要功能是：</p>
<ul>
<li>当用户作业提交时， <code>ApplicationMaster</code>与<code>ResourceManager</code>协商获取资源，<code>ResourceManager</code>会以容器的形式为<code>ApplicationMaster</code>分配资源；</li>
<li>把获得的资源进一步分配给内部的各个任务，实现资源的<code>“二次分配”</code>；</li>
<li>与<code>NodeManager</code>保持交互通信进行应用程序的启动、运行监控和停止，监控申请到的资源的使用情况，对所有任务的执行进度和状态进行监控，并在任务发生失败时执行失败恢复；</li>
<li>定时向<code>ResourceManager</code>发送“心跳”消息，报告资源的使用情况和应用的进度信息；</li>
<li>当作业完成时，<code>ApplicationMaster</code>向<code>ResourceManager</code>注销容器，执行周期完成。</li>
</ul>
<h6 id="nodemanager">3. NodeManager</h6>
<p><code>NodeManager</code>是驻留在一个<code>YARN</code>集群中的每个节点上的代理，主要负责：</p>
<ul>
<li>容器生命周期管理，监控每个容器的资源使用情况，跟踪节点健康状况；</li>
<li>以“心跳”的方式与<code>ResourceManager</code>保持通信，向<code>ResourceManager</code> 汇报作业的资源使用情况和每个容器的运行状态；</li>
<li>接收来自<code>ApplicationMaster</code>的启动/停止容器的各种请求。</li>
</ul>
<p><code>NodeManager</code>主要负责管理抽象的容器，只处理与容器相关的事情，而不具体负责每个任务自身状态的管理。</p>
<p><code>YARN</code>的各个组件是和<code>Hadoop</code>集群中的其他组件进行统一部署的。</p>
<ul>
<li><code>YARN</code>的<code>ResourceManager</code>组件和<code>HDFS</code>的<code>名称节点（NameNode）</code>部署在一个节点上；</li>
<li><code>YARN</code>的<code>ApplicationMaster</code>及<code>NodeManager</code>是和HDFS的<code>数据节点（DataNode）</code>部署在一起的；</li>
<li><code>YARN</code>中的容器代表了CPU、内存、网络等计算资源，也是和HDFS的数据节点一起的。</li>
</ul>
<h5 id="yarn工作流程">2.3.3 YARN工作流程</h5>
<p>在<code>YARN</code>框架中执行一个<code>MapReduce</code>程序时，从提交到完成需要经历如下8个步骤：</p>
<ol type="1">
<li>用户编写客户端应用程序，向<code>YARN</code>提交应用程序，提交的内容包括<code>ApplicationMaster</code>程序、启动 <code>ApplicationMaster</code>的命令、用户程序等。</li>
<li><code>YARN</code>中的<code>ResourceManager</code>负责接收和处理来自客户端的请求。接到客户端应用程序请求后， <code>ResourceManager</code>里面的调度器会为应用程序分配一个容器。<code>ResourceManager</code>的应用程序管理器会与该容器所在的<code>NodeManager</code>通信，为该应用程序在该容器中启动一个<code>ApplicationMaster</code>。</li>
<li><code>ApplicationMaster</code>被创建后会首先向<code>ResourceManager</code>注册，从而使得用户可以通过<code>ResourceManager</code>来直接查看应用程序的运行状态。</li>
<li><code>ApplicationMaster</code>用轮询的方式通过<code>RPC</code>协议向<code>ResourceManager</code>申请资源。</li>
<li><code>ResourceManager</code>以<code>“容器”</code>的形式向提出申请的<code>ApplicationMaster</code>分配资源，一旦<code>ApplicationMaster</code>申请到资源后，就会与该容器所在的<code>NodeManager</code>进行通信，要求它启动任务。</li>
<li>当<code>ApplicationMaster</code>要求容器启动任务时，它会为任务设置好运行环境（包括环境变量、 JAR包、二进制程序等），然后将任务启动命令写到一个脚本中，最后通过在容器中运行该脚本来启动任务。</li>
<li>各个任务通过某个RRC协议向<code>ApplicationMaster</code>汇报自己的状态和进度，让<code>ApplicationMaster</code>可以随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。</li>
<li>应用程序运行完成后，<code>ApplicationMaster</code>向<code>ResourceManager</code>的应用程序管理器注销并关闭自己。若<code>ApplicationMaster</code>因故失败，<code>ResourceManager</code>中的应用程序管理器会监测到失败的情形，然后将其重新启动，直到所有的任务执行完毕。</li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter3/YARNWorkFlow.PNG" alt="YARN工作流程" /><figcaption aria-hidden="true">YARN工作流程</figcaption>
</figure>
<h5 id="总结">2.3.4 总结</h5>
<p><code>YARN</code>的目标是实现<code>“一个集群多个框架”</code>，即在一个集群上部署一个统一的资源调度管理框架<code>YARN</code>，在<code>YARN</code>之上可以部署其他各种计算框架，比如 Mapreduce、Tez、 HBase、 Storm、Giraph、Spark、OpenMPI等，由<code>YARN</code>为这些计算框架提供统一的资源调度管理服务，并且能够根据各种计算框架的负载需求，调整各自占用的资源，实现集群资源共享和资源弹性收缩。</p>
<ul>
<li>可以实现一个集群上的不同应用负载混搭，有效提高了集群的利用率；</li>
<li>不同计算框架可以共享底层存储，在一个集群上集成多个数据集，使用多个计算框架来访问这些数据集，从而避免了数据集跨集群移动</li>
<li>这种部署方式也大大降低了企业运维成本</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>[大数据技术原理|第一篇 大数据基础]</title>
    <url>/2021/07/30/Big_Data_1_basic.html</url>
    <content><![CDATA[<h3 id="简介">简介</h3>
<p>《大数据技术原理与应用》的学习笔记，这本书推荐的学习路线如下：</p>
<a id="more"></a>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/learningPath.PNG" alt="推荐的学习路线参考书籍" /><figcaption aria-hidden="true">推荐的学习路线参考书籍</figcaption>
</figure>
<h3 id="大数据概述">1. 大数据概述</h3>
<h4 id="大数据的概念">1.1 大数据的概念</h4>
<p>大数据的 <code>"4v"</code> 指的是大数据的4个特点：</p>
<ul>
<li>数据量大（<code>Volume</code>）</li>
<li>数据类型繁多（<code>Variety</code>）</li>
<li>处理速度快（<code>Velocity</code>）</li>
<li>价值密度低（<code>Value</code>）</li>
</ul>
<h4 id="大数据的思维方式">1.2 大数据的思维方式</h4>
<p>大数据时代思维方式的3种转变：</p>
<ul>
<li>全样而非抽样</li>
<li>效率而非精确</li>
<li>相关而非因果</li>
</ul>
<h4 id="大数据计算模式">1.3 大数据计算模式</h4>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/ComputeSchema.PNG" alt="大数据计算模式" /><figcaption aria-hidden="true">大数据计算模式</figcaption>
</figure>
<h5 id="批处理计算">1.3.1 批处理计算</h5>
<p>批处理计算主要解决针对大规模数据的批量处理：</p>
<ul>
<li><code>MapReduce</code>。将并行计算过程高度抽象为两个函数——<code>Map</code>和<code>Reduce</code>。</li>
<li><code>Spark</code>。针对超大数据集合的低延迟集群分布式计算系统，启用内存分布数据集，除可以交互式查询外，还可以优化迭代工作复杂。</li>
<li><code>MapReduce</code>数据流从一个稳定的来源加工处理后，流出到一个稳定的文件系统（如<code>HDFS</code>）；而<code>Spark</code>使用内存代替<code>HDFS</code>来存储中间结果。</li>
</ul>
<h5 id="流计算">1.3.2 流计算</h5>
<p>流数据是指在时间分布和数量上无限的一系列动态数据集合体，需要采用实时计算的方式给出秒级响应。</p>
<ul>
<li>商业级流计算平台。<code>IBM InfoSphere Streams</code> 和 <code>IBM StreamBase</code>等</li>
<li>开源流计算框架。包括 <code>Twitter Storm</code>、 <code>Yahoo！s4（ Simple Scalable Streaming System）</code>、 <code>Spark Streaming</code>等；</li>
<li>公司为支持自身业务开发的流计算框架。</li>
</ul>
<h5 id="图计算">1.3.3 图计算</h5>
<p>针对大型图的计算，需要采用图计算模式。</p>
<ul>
<li><code>Pregel</code>是一种基于<code>BSP</code>（ <code>Bulk Synchronous Parallel</code>）模型实现的并行图处理系统。<code>Pregel</code>主要用于图遍历、最短路径、 <code>PageRank</code>计算等。</li>
</ul>
<h5 id="查询分析计算">1.3.4 查询分析计算</h5>
<p>针对超大规模数据的存储管理和查询分析，需要提供实时或准实时的响应。</p>
<ul>
<li>谷歌公司开发的 <code>Dremel</code> 是一种可扩展的、交互式的实时查询系统，用于只读嵌套数据的分析。通过结合多级树状执行过程和列式数据结构，它能做到几秒内完成对万亿张表的聚合查询。</li>
<li><code>Cloudera</code>公司参考 <code>Dremel</code> 系统开发了实时查询引擎 <code>Impala</code>，它提供<code>SoL</code>语义，能快速查询存储在 <code>Hadoop</code> 的<code>HDFS</code>和 <code>HBase</code>中的PB级大数据。</li>
</ul>
<h4 id="大数据与云计算">1.4 大数据与云计算</h4>
<h5 id="云计算">1.4.1 云计算</h5>
<p>云计算实现了<strong><u>通过网络</u></strong>提供<strong>可伸缩的</strong>、<strong>廉价</strong>的分布式计算能力，用户只需要在具备网络接入条件的地方，就可以随时随地获得所需的各种<code>IT</code>资源。云计算代表了<strong><u>以虚拟化技术为核心、以低成本为目标的、动态可扩展的</u></strong>网络应用基础设施，是近年来最有代表性的网络计算技术与模式。</p>
<p>云计算包括3种典型的服务模式：</p>
<ul>
<li><code>IaaS</code>（基础设施即服务）</li>
<li><code>PaaS</code>（平台即服务）</li>
<li><code>SaaS</code>（软件即服务）</li>
</ul>
<p><code>Iaas</code>将基础设施（计算资源和存储）作为服务出租，<code>PaaS</code>把平台作为服务出租，<code>SaaS</code>把软件作为服务出租。</p>
<h5 id="云计算关键技术">1.4.2 云计算关键技术</h5>
<p>云计算的关键技术包括<strong>虚拟化</strong>、<strong>分布式存储</strong>、<strong>分布式计算</strong>、<strong>多租户</strong>等。</p>
<h6 id="虚拟化">1.4.2.1 <strong>虚拟化</strong></h6>
<p>虚拟化技术是指将一台计算机虚拟为多台逻辑计算机，在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。虚拟化的资源可以是硬件（如服务器、磁盘和网络），也可以是软件。</p>
<p><code>Hyper-V</code>、 <code>VMware</code>、<code>KWM</code>、 <code>Virtualbox</code>、<code>Xen</code>、<code>Qemu</code>等都是非常典型的虚拟化技术。</p>
<h6 id="分布式存储">1.4.2.2 <strong>分布式存储</strong></h6>
<ul>
<li><p><code>GFS</code>（ <code>Google File System</code>）是谷歌公司推出的一款分布式文件系统，可以满足大型、分布式、对大量数据进行访问的应用的需求。</p></li>
<li><p><code>HDFS</code>（ <code>Hadoop Distributed File System</code>）是对GFS的开源实现，它采用了更加简单的<code>“一次写入、多次读取”</code>文件模型，文件一旦创建、写入并关闭了，之后就只能对它执行读取操作，而不能执行任何修改操作；同时，HDFS是基于Java实现的，具有强大的跨平台兼容性。</p></li>
<li><p>谷歌公司后来以GFS为基础开发了分布式数据管理系统 <code>Big Table</code>，它是一个<strong>稀疏、分布、持续多维度的排序映射数组</strong>，适合于非结构化数据存储的数据库，具有高可靠性、高性能、可伸缩等特点。<code>HBase</code>是针对 <code>Big Table</code> 的开源实现。</p></li>
</ul>
<h6 id="分布式计算">1.4.2.3 分布式计算</h6>
<p>谷歌公司提出了并行编程模型 <code>MapReduce</code>，<code>MapReduce</code>将复杂的、运行于大规模集群上的并行计算过程抽象为两个函数——<code>Map</code>和 <code>Reduce</code>，并把一个大数据集切分成多个小的数据集，分布到不同的机器上进行并行处理，极大提高了数据处理速度，可以有效满足许多应用对海量数据的批量处理需求。 <code>Hadoop</code> 开源实现了 <code>MapReduce</code> 编程框架，被广泛应用于分布式计算。</p>
<h6 id="多租户">1.4.2.4 多租户</h6>
<p>多租户技术目的在于<u>使大量用户能够共享同一堆栈的软硬件资源，每个用户按需使用资源能够对软件服务进行客户化配置，而不影响其他用户的使用</u>。多租户技术的核心包括<strong>数据隔离</strong>、<strong>客户化配置</strong>、<strong>架构扩展</strong>和<strong>性能定制</strong>。</p>
<h3 id="大数据处理框架hadoop">2. 大数据处理框架<code>Hadoop</code></h3>
<p><code>Hadoop</code>是一个开源的、可运行于大规模集群上的分布式计算平台，它实现了 <code>MapReduce</code> 计算模型和分布式文件系统<code>HDFS</code>等功能。</p>
<h4 id="概述">2.1 概述</h4>
<h5 id="hadoop简介">2.1.1 Hadoop简介</h5>
<p><code>Hadoop</code>是<code>Apache</code>软件基金会旗下的一个开源分布式计算平台，为用户提供了系统底层细节透明的分布式基础架构。</p>
<ul>
<li><code>Hadoop</code>的<strong>核心</strong>是<code>分布式文件系统（ Hadoop Distributed File System, HDFS）</code>和 <code>MapReduce</code>；</li>
<li><code>HDFS</code>是针对<code>谷歌文件系统（ Google File System, GFS）</code>的开源实现，具有<strong>较高的读写速度</strong>、<strong>很好的容错性</strong>和<strong>可伸缩性</strong>，支持大规模数据的分布式存储，其<u><strong>冗余数据存储的方式很好地保证了数据的安全性</strong></u>。</li>
<li><code>MapReduce</code>是针对谷歌 <code>MapReduce</code>的开源实现，采用 <code>MapReduce</code> 来整合分布式文件系统上的数据，可保证分析和处理数据的高效性。</li>
</ul>
<h5 id="hadoop的特性">2.1.2 Hadoop的特性</h5>
<p><code>Hadoop</code>是一个能够对大量数据进行分布式处理的软件框架，具有以下几个方面的特性。</p>
<ul>
<li><strong>高可靠性</strong>。采用<strong><u>冗余数据存储方式</u></strong>，即使一个副本发生故障，其他副本也可以保证正常对外提供服务。</li>
<li><strong>高效性</strong>。作为并行分布式计算平台，<code>Hadoop</code>采用<strong>分布式存储</strong>和<strong>分布式处理</strong>两大核心技术，能够高效地处理PB级数据。</li>
<li><strong>高可扩展性</strong>。<code>Hadoop</code>的设计目标是可以高效稳定地运行在廉价的计算机集群上。</li>
<li><strong>高容错性</strong>。采用冗余数据存储方式，自动保存数据的多个副本，并且能够<strong><u>自动将失败的任务进行重新分配</u></strong>。</li>
<li><strong>成本低</strong>。<code>Hadoop</code>采用廉价的计算机集群，成本比较低。</li>
<li><strong>运行在<code>Linux</code>平台上</strong>。<code>Hadoop</code>是基于<code>Java</code> 语言开发的，可以较好地运行在 <code>Linux</code> 平台上。</li>
<li><strong>支持多种编程语言</strong>。<code>Hadoop</code>上的应用程序也可以使用其他语言编写。</li>
</ul>
<h4 id="hadoop生态系统">2.2 <code>Hadoop</code>生态系统</h4>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/hadoopEcoSys.png" alt="Hadoop生态系统" /><figcaption aria-hidden="true"><code>Hadoop</code>生态系统</figcaption>
</figure>
<p>除了核心的<code>HDFS</code>和<code>MapReduce</code>以外，<code>Hadoop</code>生态系统还包括 <code>Zookeeper</code>、<code>HBase</code>、<code>Hive</code>、<code>Pig</code>、<code>Mahout</code>、<code>Sqoop</code>、<code>Flume</code>、<code>Ambari</code>等功能组件。<code>Hadoop2.0</code>中新增 <code>HDFS HA</code> 和分布式资源调度管理框架<code>YARN</code>等。</p>
<h5 id="hdfs">2.2.1 HDFS</h5>
<p><code>Hadoop</code>分布式文件系统（ <code>Hadoop Distributed File System, HDFS</code>）是 <code>Hadoop</code>项目的两大核心之一。<code>HDFS</code>具有处理超大数据、流式处理、可以运行在廉价商用服务器上等优点。</p>
<p><code>HDFS</code>放宽了一部分<code>POSX（Portable Operating System Interface）</code>约束，从而实现以流的形式访问文件系统中的数据，提供高吞吐量应用程序数据访问功能。</p>
<h5 id="hbase">2.2.2 HBase</h5>
<p><code>HBase</code>是一个提供高可靠性、高性能、可伸缩、实时读写、分布式的<strong><u>列式数据库</u></strong>，一般采用<code>HDFS</code>作为其底层数据存储，具有强大的<strong><u>非结构化数据存储能力</u></strong>。</p>
<p><code>HBase</code>与传统关系数据库的一个重要区别是，前者采用<strong><u>基于列的存储</u></strong>，而后者采用<strong><u>基于行的存储</u></strong>。<code>HBase</code>具有良好的横向扩展能力，可以通过不断增加廉价的商用服务器来增加存储能力。</p>
<h5 id="mapreduce">2.2.3 MapReduce</h5>
<p><code>Hadoop MapReduce</code>是一种<strong><u>编程模型</u></strong>，用于大规模数据集的<strong><u>并行运算</u></strong>，将复杂的、运行于大规模集群上的并行计算过程高度地抽象到了两个函数——<code>Map</code>和<code>Reduce</code>上。</p>
<p><code>MapReduce</code>的<strong>核心思想</strong>就是<code>“分而治之”</code>，把输入的数据集切分为若干独立的数据块，分发给一个主节点管理下的各个分节点来共同并行完成；最后，通过整合各个节点的中间结果得到最终结果。</p>
<h5 id="hive">2.2.4 Hive</h5>
<p><code>Hive</code>是一个基于Hadoop的<strong><u>数据仓库工具</u></strong>，可以用于对<code>Hadoop</code>文件中的数据集进行<strong>数据整理</strong>、<strong>特殊查询</strong>和<strong>分析存储</strong>。<code>Hive</code>提供了类似于关系数据库<code>SQL</code>语言的查询语言——<code>Hive QL</code>，可以通过<code>Hive QL</code>语句快速实现简单的<code>MapReduce</code>统计，<code>Hive</code>自身可以将<code>Hive QL</code>语句转换为 <code>MapReduce</code> 任务进行运行。</p>
<h5 id="pig">2.2.5 Pig</h5>
<p><code>Pig</code>是一种<strong><u>数据流语言和运行环境</u></strong>，适合于使用Hadoop和MapReduce平台来<strong>查询大型半结构化数据集</strong>。</p>
<p><code>Pig</code> 在<code>MapReduce</code>的基础上创建了更简单的过程语言抽象，为<code>Hadoop</code>应用程序提供了一种更加接近<code>结构化查询语言（SQL）</code>的接口。</p>
<h5 id="mahout">2.2.6 Mahout</h5>
<p><code>Mahout</code>是<code>Apache</code>软件基金会旗下的一个开源项目，<strong><u>提供一些可扩展的机器学习领域经典算法的实现</u></strong>。<code>Mahout</code>包含许多实现，包括<strong>聚类、分类、推荐过滤、频繁子项挖掘</strong>。</p>
<h5 id="zookeeper">2.2.7 Zookeeper</h5>
<p><code>Zookeeper</code>是针对谷歌<code>Chubby</code>的一个开源实现，是高效和可靠的<strong><u>协同工作系统</u></strong>，提供分布式锁之类的基本服务（如统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等），用于构建分布式应用，减轻分布式应用程序所承担的协调任务。</p>
<h5 id="fiume">2.2.8 FIume</h5>
<p><code>Flume</code>是<code>Cloudera</code>提供的一个高可用的、高可靠的、分布式的<strong><u>海量日志采集、聚合和传输的系统</u></strong>。<code>Flume</code>支持在日志系统中定制各类数据发送方，用于收集数据；同时，<code>Flume</code>提供对数据进行简单处理并写到各种数据接受方的能力。</p>
<h5 id="sqoop">2.2.9 Sqoop</h5>
<p><code>Sqoop</code>是 <code>SQL-to-Hadoop</code> 的缩写，主要用来在<code>Hadoop</code>和关系数据库之间交换数据，可以改进数据的互操作性。通过 <code>Sqoop</code>可以方便地：</p>
<ul>
<li>将数据从<code>MySQL</code>、<code>Oracle</code>、<code>PostgreSQL</code>等关系数据库中导入<code>Hadoop</code>（可以导入<code>HDFS</code>、<code>HBase</code>或<code>Hive</code>）</li>
<li>将数据从<code>Hadoop</code>导出到关系数据库，使得传统关系数据库和<code>Hadoop</code>之间的数据迁移变得非常方便。</li>
</ul>
<p><code>Sqoop</code>主要通过<code>JDBC（Java DataBase Connectivity）</code>和关系数据库进行交互，理论上支持<code>JDBC</code>的关系数据库都可以使 <code>Sqoop</code>和<code>Hadoop</code>进行数据交互。</p>
<h5 id="ambari">2.2.10 Ambari</h5>
<p><code>Apache Ambari</code>是一种基于<code>web</code>的工具，支持<code>Apache Hadoop</code>集群的安装、部署、配置和管理。</p>
<h5 id="yarn">2.2.11 Yarn</h5>
<p><code>YARN （Yet Another Resource Negotiator，另一种资源协调者）</code>是一种新的 <code>Hadoop</code> 资源管理器，它是一个通用资源管理系统，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。</p>
<p><code>YARN</code>的基本思想是将<code>JobTracker</code>的两个主要功能（<strong>资源管理</strong>和<strong>作业调度/监控</strong>）分离，主要方法是<u>创建一个全局的ResourceManager（RM）</u>和<u>若干个针对应用程序的ApplicationMaster（AM）</u>，应用程序是指传统的<code>MapReduce</code>作业或作业的<code>DAG</code>（有向无环图）。</p>
<h5 id="oozie">2.2.12 Oozie</h5>
<p><code>Oozie</code>是一种<code>Java Web</code>应用程序，它运行在<code>Java servlet</code>容器——即<code>Tomcat</code>中，可以把多个<code>Map/Reduce</code>作业组合到一个逻辑工作单元中，从而完成更大型的任务。使用数据库来存储以下内容：</p>
<ul>
<li>工作流定义</li>
<li>当前运行的工作流实例，包括实例的状态和变量</li>
</ul>
<p><code>Oozie</code>工作流是放置在控制依赖<code>DAG</code>中的一组动作（例如，Hadoop的Map/Reduce作业、Pig作业等），其中指定了动作执行的顺序。</p>
<h5 id="spark">2.2.13 Spark</h5>
<p><code>Spark</code> 是专为大规模数据处理而设计的<strong>快速通用</strong>的<code>计算引擎</code>，拥有<code>Hadoop MapReduce</code>所具有的优点；但不同于<code>MapReduce</code>的是——<code>Job</code>中间输出结果可以保存在内存中，从而不再需要读写<code>HDFS</code>，因此<code>Spark</code>能更好地适用于数据挖掘与机器学习等需要迭代的<code>MapReduce</code>的算法。</p>
<p><code>Spark</code> 是在 <code>Scala</code> 语言中实现的，它将 <code>Scala</code> 用作其应用程序框架，<code>Scala</code> 可以像操作本地集合对象一样轻松地操作分布式数据集。实际上它是对 <code>Hadoop</code> 的补充，可以在 <code>Hadoop</code> 文件系统中并行运行。</p>
<h5 id="tez">2.2.14 Tez</h5>
<p><code>Tez</code>是一个针对<code>Hadoop</code>数据处理应用程序的新分布式执行框架。<code>Tez</code>是<code>Apache</code>最新的支持<code>DAG</code>作业的开源计算框架，它可以将多个有依赖的作业转换为一个作业从而大幅提升<code>DAG</code>作业的性能。</p>
<h5 id="storm">2.2.15 Storm</h5>
<p><code>Storm</code>为分布式实时计算提供了一组通用原语，可被用于<code>“流处理”</code>之中，实时处理消息并更新数据库。这是管理队列及工作者集群的另一种方式。<code>Storm</code>也可被用于<code>“连续计算”（continuous computation）</code>，对数据流做连续查询，在计算时就将结果以流的形式输出给用户。它还可被用于<code>“分布式RPC”</code>，以并行的方式运行昂贵的运算。</p>
<h5 id="kafka">2.2.16 kafka</h5>
<p><code>kafka</code>是由Apache软件基金会开发的一个<strong>开源流处理平台</strong>，由<code>Scala</code>和<code>Java</code>编写。<code>Kafka</code>是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。<code>Kafka</code>的目的是通过<code>Hadoop</code>的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息</p>
<h3 id="hadoop-的安装与使用">3. Hadoop 的安装与使用</h3>
<p><code>Hadoop</code>基本安装配置主要包括以下5个步骤。</p>
<h4 id="创建-hadoop用户">3.1 创建 Hadoop用户</h4>
<p>创建一个名为<code>hadoop</code>的用户运行程序，分离权限方便操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ useradd -s /bin/bash -d /home/hadoop -m hadoop</span><br><span class="line">$ passwd hadoop</span><br></pre></td></tr></table></figure>
<h4 id="安装-java">3.2 安装 Java</h4>
<p>由于 <code>Hadoop</code> 本身是使用<code>Java</code>语言编写的，因此 <code>Hadoop</code> 的开发和运行都需要<code>Java</code>的支持。</p>
<p>对于 <code>Ubuntu</code>本身，系统上可能已经预装了<code>Java</code>，它的<code>JDK</code>版本为 <code>openjdk</code>，路径为<code>“/usr/lib/jvm/default-java”</code>，后文中需要配置的 <code>JAVA_HOME</code> 环境变量就可以设置为这个值。</p>
<p>也可以自行安装<code>Oracle</code>公式的<code>Java</code>版本。</p>
<h4 id="设置ssh登录权限">3.3 设置SSH登录权限</h4>
<p>对于 <code>Hadoop</code> 的伪分布和全分布而言，<code>Hadoop</code>名称节点<code>（Name Node）</code>需要启动集群中所有机器的 <code>Hadoop</code> 守护进程，这个过程可以通过<code>SSH</code>登录来实现。为了能够顺利登录每台机器，需要将所有机器配置为名称节点可以无密码登录。</p>
<p>首先需要让名称节点生成自己的<code>SSH</code>密钥，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -P <span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>按照默认位置，会存放在用户目录的<code>.ssh/</code>路径下。</p>
<p>名称节点生成自己的密钥之后，需要将它的公共密钥发送给集群中的其他机器。可以将<code>id_dsa. pub</code>中的内容添加到需要匿名登录的机器的<code>“~/ssh/authorized_keys”</code>目录下，然后名称节点就可以无密码登录这台机器。</p>
<h4 id="单机安装配置">3.4 单机安装配置</h4>
<p>将<code>hadoop</code>文件夹解压后，放置到任意文件位置如<code>“/usr/local/hadoop”</code>文件夹下。文件夹的用户和组必须都为 <code>hadoop</code>。</p>
<p>在 <code>Hadoop</code>的文件夹中下的<code>“etc/hadoop”</code>目录下面放置了配置文件，对于单机安装，首先需要更改 <code>hadoop-env.sh</code> 文件，以配置<code>Hadoop</code>运行的环境变量，这里只需要将<code>JAVA_HOME</code>环境变量指定到本机的<code>JDK</code>目录就可以了，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$export</span> JAVA_HOME=/usr/lib/jvm/default-java</span><br></pre></td></tr></table></figure>
<p>完成之后，我们可以试着查看<code>Hadoop</code>版本信息，可以运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$./bin/hadoop version</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/hadoopVersion.PNG" alt="hadoop version" /><figcaption aria-hidden="true">hadoop version</figcaption>
</figure>
<p>运行<code>hadoop</code>自带的 <code>WordCount</code>的例子来检测一下<code>Hadoop</code>安装是否成功。</p>
<ul>
<li><p>首先在 <code>hadoop</code>目录下新建 <code>input</code>文件夹，用来存放输入数据；</p></li>
<li><p>然后，将 <code>etc/hadoop</code>文件夹下的配置文件拷贝进 <code>input</code>文件夹中；</p></li>
<li><p>接下来，在<code>hadoop</code>目录下新建<code>output</code>文件夹，用来存放输出数据；</p></li>
<li><p>最后，运行示例程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir ./input</span><br><span class="line">$ cp ./etc/hadoop/*.xml ./input</span><br><span class="line">$ cp ./etc/hadoop/*.xml ./input   <span class="comment"># 将配置文件作为输入文件</span></span><br><span class="line">$ ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep ./input ./output <span class="string">'dfs[a-z.]+'</span></span><br><span class="line">$ cat ./output/*          <span class="comment"># 查看运行结果</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>这意味着，在所有的配置文件中，只有一个符合正则表达式的单词，结果正确。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/hadoopExample.PNG" alt="hadoop example" /><figcaption aria-hidden="true">hadoop example</figcaption>
</figure>
<h4 id="伪分布式安装配置">3.5 伪分布式安装配置</h4>
<p>伪分布式安装是指<strong><u>在一台机器上模拟一个小的集群，但是集群中只有一个节点</u></strong>。当<code>Hadoop</code>应用于集群时，不论是伪分布式还是真正的分布式运行，都需要通过配置文件对各组件的协同工作进行设置，最重要的几个配置文件见表。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/hadoopConfigFile.PNG" alt="hadoop配置文件" /><figcaption aria-hidden="true">hadoop配置文件</figcaption>
</figure>
<p>要修改该目录下的文件<code>core-site.xml</code>和<code>hdfs-site.xml</code>来达到实现伪分布式配置。修改<code>core-site.xml</code>，将<code>&lt;configure&gt;&lt;/configure&gt;</code>修改为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改<code>hdfs-site.xml</code>，将<code>&lt;configure&gt;&lt;/configure&gt;</code>修改为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置完成后初始化文件系统，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hdfs namenode -format</span><br></pre></td></tr></table></figure>
<p>接着使用<code>sbin/start-dfs.sh</code>来开启<code>namenode</code>和<code>datanode</code>，开启后使用命令<code>jps</code>查看是否开启成功，如下图：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter1/startHDFS.PNG" alt="初始化文件系统" /><figcaption aria-hidden="true">初始化文件系统</figcaption>
</figure>
<p>之后可以配置<code>yarn</code>，首先复制<code>mapred-site.xml</code>配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cp etc/hadoop/mapred-site.xml.template etc/hadoop/mapred-site.xml</span><br></pre></td></tr></table></figure>
<p>然后修改<code>etc/hadoop/mapred-site.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改<code>etc/hadoop/yarn-site.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动资源管理器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./sbin/start-yarn.sh</span><br><span class="line">$ ./sbin/mr-jobhistory-daemon.sh start historyserver <span class="comment">#查看历史任务</span></span><br></pre></td></tr></table></figure>
<p>关闭资源管理器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./sbin/stop-yarn.sh</span><br><span class="line">$ ./sbin/mr-jobhistory-daemon.sh stop historyserver</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构和算法|二叉树的构建和相关操作]</title>
    <url>/2021/06/30/Data_structure_and_algorithm_binary_tree.html</url>
    <content><![CDATA[<h3 id="二叉树介绍">1. 二叉树介绍</h3>
<p>树是具有<code>“一对多”</code>关系的数据元素的集合。</p>
<h4 id="树的概念">1.1 树的概念</h4>
<p>如下图是一棵树，包含节点 <code>{A,B,C,D,E,F,G,H,I,J,K,L,M}</code>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/tree/treeExample.PNG" alt="树的示例" /><figcaption aria-hidden="true">树的示例</figcaption>
</figure>
<h5 id="树的结点">1.1.1 树的结点</h5>
<ul>
<li>结点：使用树结构存储的每一个数据元素都被称为“结点”。</li>
<li>父结点（双亲结点）、子结点和兄弟结点。如 <code>A</code> 是 <code>B、C、D</code> 结点的父结点（也称为“双亲结点”），而 <code>B、C、D</code> 都是 <code>A</code> 结点的子结点（也称“孩子结点”）。对于 <code>B、C、D</code> 来说，它们都有相同的父结点，所以它们互为兄弟结点。</li>
<li>根结点。如果一个结点<u>没有父结点</u>，那么这个结点就是整棵树的根结点，结点A就是整棵树的根结点。每一个非空树都<strong><u>有且只有一个</u></strong>被称为根的结点。</li>
<li>叶子结点：如果结点没有任何子结点，那么此结点称为叶子结点（叶结点）。</li>
</ul>
<h5 id="结点的度和层次">1.1.2 结点的度和层次</h5>
<ul>
<li><p>对于一个结点，拥有的<strong>子树数</strong>（结点有多少分支）称为结点的<code>度（Degree）</code>。如结点 <code>A</code> 的度为 <code>3</code>。</p>
<blockquote>
<p>一棵树的度是树内各结点的度的最大值。</p>
</blockquote></li>
<li><p>结点的层次：一棵树的深度（高度）是树中结点所在的最大的层次。</p></li>
</ul>
<h4 id="二叉树及其性质">1.2 二叉树及其性质</h4>
<p>二叉树需要满足两个条件：</p>
<ul>
<li>是有序树。有序树即树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的；</li>
<li>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；</li>
</ul>
<h5 id="二叉树的性质">1.2.1 二叉树的性质</h5>
<p>二叉树具有以下几个性质：</p>
<ul>
<li>二叉树中，第 <span class="math inline">\(i\)</span> 层最多有 <span class="math inline">\(2^{i-1}\)</span> 个结点。</li>
<li>如果二叉树的深度为 <span class="math inline">\(K\)</span>，那么此二叉树最多有 <span class="math inline">\(2^{K}-1\)</span> 个结点。</li>
<li>二叉树中，叶子结点数为 <span class="math inline">\(n_0\)</span>，度为 <span class="math inline">\(2\)</span> 的结点数为 <span class="math inline">\(n_2\)</span>，则 <span class="math inline">\(n_0=n_2+1\)</span>​。
<ul>
<li>一棵二叉树中，总结点树为 <span class="math inline">\(n=n_0+n_1+n_2\)</span>。</li>
<li>假设树中分枝数为 <span class="math inline">\(B\)</span>​，那么总结点数 <span class="math inline">\(n=B+1\)</span>​。而分枝数是可以通过 <span class="math inline">\(n_1\)</span>​ 和 <span class="math inline">\(n_2\)</span>​ 表示的，即 <span class="math inline">\(B=n_1+2 \times n_2\)</span>​​。<span class="math inline">\(n\)</span>​​ 用另外一种方式表示为 <span class="math inline">\(n=n_1+2 \times n_2+1\)</span>​。</li>
<li>联立方程就可以得出 <span class="math inline">\(n_0=n_2+1\)</span>。</li>
</ul></li>
</ul>
<h5 id="二叉树的链式存储结构">1.2.2 二叉树的链式存储结构</h5>
<p>从树的根节点开始，将各个节点及其左右孩子使用链表存储即可：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/tree/treeLinkedStore.PNG" alt="二叉树链式存储" /><figcaption aria-hidden="true">二叉树链式存储</figcaption>
</figure>
<p>采用链式存储二叉树时，其节点结构由 <code>3</code> 部分构成：</p>
<ul>
<li>指向左孩子节点的指针（<code>Lchild</code>）；</li>
<li>节点存储的数据（<code>data</code>）；</li>
<li>指向右孩子节点的指针（<code>Rchild</code>）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiNode</span> </span>&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">    BiNode lchild, rchild;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BiNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="title">BiNode</span><span class="params">(ElemType data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的遍历">2. 二叉树的遍历</h3>
<p><strong>二叉树的遍历</strong>是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。二叉树的访问次序可以分为四种：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
<h4 id="前序遍历">2.1 前序遍历</h4>
<p><strong>前序遍历</strong>的主要步骤是：</p>
<ul>
<li>访问根结点；</li>
<li>先序遍历左子树；</li>
<li>先序遍历右子树。</li>
</ul>
<p>递归实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        process(root);<span class="comment">//调用操作结点数据的函数方法</span></span><br><span class="line">        PreOrderTraverse(root.lchild);<span class="comment">//访问该结点的左孩子</span></span><br><span class="line">        PreOrderTraverse(root.rchild);<span class="comment">//访问该结点的右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果结点为空，返回上一层</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归方法需要依靠<strong>栈</strong>来实现，对于根节点<code>root</code>：</p>
<ol type="1">
<li>处理该根节点<code>root</code>，然后将其入栈，再看<code>root</code>的左孩子是否为空；</li>
<li>若左孩子不为空，则置<code>root</code>的左孩子为当前节点，重复 <code>1</code> 的操作；</li>
<li>若左孩子为空，则将栈顶节点出栈，但不输出，并将出栈节点的右孩子置为当前节点；
<ul>
<li>若不为空，则循环至 <code>1</code> 操作；</li>
<li>如果为空，则继续出栈，同时将出栈节点的右孩子置为当前节点；</li>
</ul></li>
<li>直到当前节点<code>root</code>为<code>NULL</code>并且栈空，遍历结束。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;BiTree&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root); <span class="comment">// 根节点入栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 访问根节点</span></span><br><span class="line">        BiNode cur = stack.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重复访问左孩子，直到左孩子为空</span></span><br><span class="line">        <span class="keyword">while</span> (cur!= <span class="keyword">null</span>) &#123;</span><br><span class="line">            process(cur);</span><br><span class="line">            <span class="comment">// 只存储右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (cur.rchild != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur.rchild);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.lchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node Root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root==<span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"空树"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node tmp=Root;</span><br><span class="line">    Stack&lt;Node&gt; s=<span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    s.push(tmp);  <span class="comment">//根节点入栈</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">        <span class="comment">//1.访问根节点</span></span><br><span class="line">        Node p=s.pop();</span><br><span class="line">        process(p);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.如果根节点存在右孩子，则将右孩子入栈</span></span><br><span class="line">        <span class="keyword">if</span>(p.rightChild!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(p.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.如果根节点存在左孩子，则将左孩子入栈</span></span><br><span class="line">        <span class="keyword">if</span>(p.leftChild!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(p.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历">2.2 中序遍历</h4>
<p>中序遍历流程为：</p>
<ul>
<li>中序遍历左子树；</li>
<li>访问根结点；</li>
<li>中序遍历右子树。</li>
</ul>
<p>递归实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InOrderTraverse(root.lchild);<span class="comment">//访问该结点的左孩子</span></span><br><span class="line">        process(root);<span class="comment">//调用操作结点数据的函数方法</span></span><br><span class="line">        InOrderTraverse(root.rchild);<span class="comment">//访问该结点的右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果结点为空，返回上一层</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归的实现思路为，对于任一节点<code>P</code>：</p>
<ol type="1">
<li>若<code>P</code>的左孩子不为空，则将<code>P</code>入栈并将<code>P</code>的左孩子置为当前节点，然后再对当前节点进行相同的处理；</li>
<li>若<code>P</code>的左孩子为空，则处理<code>P</code>节点，而后将<code>P</code>的右孩子置为当前节点；</li>
<li>若右孩子不为空，设置为当前节点，则重复 <code>1</code> 和 <code>2</code> 的操作；</li>
<li>若右孩子为空，则执行出栈操作，输出栈顶节点，并将出栈的节点的右孩子置为当前节点，重复 <code>3</code> 和 <code>4</code> 的操作；</li>
<li>直到当前节点<code>P</code>为<code>NULL</code>并且栈为空，则遍历结束。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(Node Root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root==<span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"空树"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node tmp=Root;</span><br><span class="line">    Stack&lt;Node&gt; s=<span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( tmp!=<span class="keyword">null</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="comment">//1.将根节点入栈</span></span><br><span class="line">        <span class="comment">//2.将所有左孩子入栈</span></span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(tmp);</span><br><span class="line">            tmp=tmp.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.访问栈顶元素</span></span><br><span class="line">        tmp=s.pop();</span><br><span class="line">        process(tmp);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.如果栈顶元素存在右孩子，则将右孩子赋值给tmp，也就是将右孩子入栈</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.rightChild!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp=tmp.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，将tmp置为null，表示下次要访问的是栈顶元素</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//如果p不为NULL，将其压栈并遍历其左子树</span></span><br><span class="line">        <span class="keyword">if</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="comment">// 如果 p==NULL，表明左子树遍历完成，需要遍历上一层结点的右子树</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = stack.pop();</span><br><span class="line">            process(p.val);</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历">2.3 后序遍历</h4>
<p>后续遍历主要流程如下：</p>
<ul>
<li>后序遍历左子树；</li>
<li>后序遍历右子树；</li>
<li>访问根结点。</li>
</ul>
<p>递归实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InOrderTraverse(root.lchild);<span class="comment">//访问该结点的左孩子</span></span><br><span class="line">        InOrderTraverse(root.rchild);<span class="comment">//访问该结点的右孩子</span></span><br><span class="line">        process(root);<span class="comment">//调用操作结点数据的函数方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果结点为空，返回上一层</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归实现中，对于任一节点<code>P</code>：</p>
<ol type="1">
<li>先将节点<code>P</code>入栈；</li>
<li>若<code>P</code>不存在左孩子和右孩子，或者<code>P</code>存在左孩子或右孩子，但左右孩子已经被处理，则可以处理节点<code>P</code>，并将其出栈，将出栈节点<code>P</code>标记为上一个输出的节点，再将此时的栈顶结点设为当前节点；</li>
<li>若不满足 <code>2</code> 中的条件，则将<code>P</code>的右孩子和左孩子依次入栈，当前节点重新置为栈顶结点，之后重复操作 <code>2</code>；</li>
<li>直到栈空，遍历结束。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(Node Root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node tmp=Root;  <span class="comment">//当前节点</span></span><br><span class="line">    Node prev=<span class="keyword">null</span>; <span class="comment">//上一次访问的节点</span></span><br><span class="line">    Stack&lt;Node&gt; s=<span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(tmp!=<span class="keyword">null</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="comment">// 1.将根节点及其左孩子入栈</span></span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(tmp);</span><br><span class="line">            tmp=tmp.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!s.empty()) &#123;</span><br><span class="line">            <span class="comment">// 2.获取栈顶元素值</span></span><br><span class="line">            tmp=s.peek();</span><br><span class="line">            <span class="comment">// 3.没有右孩子，或者右孩子已经被访问过</span></span><br><span class="line">            <span class="keyword">if</span>(tmp.rightChild == <span class="keyword">null</span> || tmp.rightChild == prev) &#123;</span><br><span class="line">                <span class="comment">//则可以访问栈顶元素</span></span><br><span class="line">                tmp=s.pop();</span><br><span class="line">                process(tmp);</span><br><span class="line">                <span class="comment">//标记上一次访问的节点</span></span><br><span class="line">                prev=tmp;</span><br><span class="line">                tmp=<span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.存在没有被访问的右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp=tmp.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="层序遍历">2.4 层序遍历</h4>
<p>层次遍历就是按照树的层次自上而下的遍历二叉树，基于队列实现：</p>
<ul>
<li>从树的根结点开始，依次将其左孩子和右孩子入队。</li>
<li>每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// current node</span></span><br><span class="line">        TreeNode current = queue.remove();</span><br><span class="line">        process(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(current.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(current.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(current.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的重建">3. 二叉树的重建</h3>
<p>给定一棵二叉树的<strong>前序遍历序列和中序遍历序列</strong>可以唯一确定一棵二叉树（<strong>后序和中序遍历序列</strong>也可以唯一确定一棵二叉树）。</p>
<blockquote>
<ul>
<li><p>已知前序遍历序列和后序遍历序列，不可以唯一确定一棵二叉树。</p></li>
<li><p>二叉树的任意两个结点的值都不相同。</p></li>
</ul>
</blockquote>
<p>主要算法流程如下：</p>
<ol type="1">
<li>用前序序列的第一个结点作为根结点；</li>
<li>在中序序列中查找根结点的位置，并以此为界将中序序列划分为左、右子树；</li>
<li>根据左、右子树的中序序列中的结点个数，将前序序列去掉根结点后的序列划分为左、右两个序列，它们分别是左、右子树的前序序列;</li>
<li>对左、右子树的前序序列和中序序列递归地实施同样方法，直到所得左、右子树为空。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*根据前序遍历和中序遍历确定一棵二叉树*/</span></span><br><span class="line">    <span class="comment">//递归实现</span></span><br><span class="line">    <span class="keyword">if</span>(pre==<span class="keyword">null</span> || in==<span class="keyword">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> reConstructBinaryTree(pre, in, <span class="number">0</span>, pre.length-<span class="number">1</span>, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in,<span class="keyword">int</span> pre_begin,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> pre_end,<span class="keyword">int</span> in_begin,<span class="keyword">int</span> in_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 前序序列：从 pre_begin 到 pre_end,  中序序列：从 in_begin 到 in_end</span></span><br><span class="line">    <span class="comment">// 递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(pre_begin &gt; pre_end || in_begin &gt; in_end)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rootValue=pre[pre_begin];</span><br><span class="line">    TreeNode root=<span class="keyword">new</span> TreeNode(rootValue); <span class="comment">//第一个节点就是根节点</span></span><br><span class="line">    <span class="keyword">if</span> ( pre_begin == pre_end || in_begin == in_end)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在中序序列中，找到root，前面的就是左子树，右边的就是右子树</span></span><br><span class="line">    <span class="keyword">int</span> rootIn=in_begin; <span class="comment">//root在中序序列中的位置</span></span><br><span class="line">    <span class="keyword">while</span>(rootIn&lt;=in_end &amp;&amp; in[rootIn]!=rootValue)</span><br><span class="line">        rootIn++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left_count=rootIn-in_begin; <span class="comment">//左子树节点个数							      	</span></span><br><span class="line">    root.left=reConstructBinaryTree(pre,in,pre_begin+<span class="number">1</span>,pre_begin+left_count,</span><br><span class="line">                                    in_begin,rootIn-<span class="number">1</span>);</span><br><span class="line">    root.right=reConstructBinaryTree(pre,in,pre_begin+left_count+<span class="number">1</span>,</span><br><span class="line">                                     pre_end,rootIn+<span class="number">1</span>,in_end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种非递归的方法。对于前序遍历中的任意两个连续节点 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span>，根据前序遍历的流程可以知道 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 只有两种可能的关系：</p>
<ul>
<li><span class="math inline">\(v\)</span> 是 <span class="math inline">\(u\)</span> 的左儿子。这是因为在遍历到 <span class="math inline">\(u\)</span> 之后，下一个遍历的节点就是 <span class="math inline">\(u\)</span> 的左儿子，即 <span class="math inline">\(v\)</span>；</li>
<li><span class="math inline">\(u\)</span> 没有左儿子，并且 <span class="math inline">\(v\)</span> 是 <span class="math inline">\(u\)</span> 的某个祖先节点（或者 <span class="math inline">\(u\)</span> 本身）的右儿子。因为如果 <span class="math inline">\(u\)</span> 没有左儿子，那么下一个遍历的节点就是 <span class="math inline">\(u\)</span> 的右儿子。如果 <span class="math inline">\(u\)</span> 没有右儿子，就会向上回溯，直到遇到第一个有右儿子（且 <span class="math inline">\(u\)</span> 不在它的右儿子的子树中）的节点 <span class="math inline">\(u_a\)</span> ，那么 <span class="math inline">\(v\)</span> 就是 <span class="math inline">\(u_a\)</span> 的右儿子。</li>
</ul>
<p>算法流程如下：</p>
<ul>
<li>用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针<code>index</code>指向中序遍历的第一个节点；
<ul>
<li>栈 <code>stack</code> 来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点；</li>
<li>指针 <code>index</code> 对应的节点是「当前节点不断往左走达到的最终节点」；</li>
</ul></li>
<li>依次枚举前序遍历中除了第一个节点以外的每个节点。
<ul>
<li>如果 <code>index</code> 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 <code>index</code>，并将当前节点作为最后一个弹出的节点的右儿子；</li>
<li>如果 <code>index</code> 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</li>
</ul></li>
<li>无论是哪一种情况，最后都将当前的节点入栈。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">int</span> inorderIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> preorderVal = preorder[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inorderIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解">4. 题解</h3>
<h4 id="剑指-offer-26.-树的子结构">4.1 <a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">剑指 Offer 26. 树的子结构</a></h4>
<blockquote>
<p>输入两棵二叉树<code>A</code>和<code>B</code>，判断<code>B</code>是不是<code>A</code>的子结构。(约定空树不是任意一个树的子结构)</p>
<p><code>B</code>是<code>A</code>的子结构， 即<code>A</code>中有出现和<code>B</code>相同的结构和节点值。</p>
<p>例如: 给定的树 <code>A</code>:</p>
<pre><code>   3
  / \
  4   5
  / \
 1   2</code></pre>
<p>给定的树 B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>返回 <code>true</code>，因为 <code>B</code> 与 <code>A</code> 的一个子树拥有相同的结构和节点值。</p>
</blockquote>
<p>判断树<code>B</code>是否为<code>A</code>的子树时，主要存在以下情况：</p>
<ul>
<li>根节点相同时，假设从跟节点开始匹配，判断是不是一棵子树；</li>
<li>如果根节点不同或判定子树失败，存在两种情况：
<ul>
<li><code>B</code>是<code>A</code>左子树的一个子树；</li>
<li><code>B</code>是<code>A</code>右子树的一个子树；</li>
</ul></li>
</ul>
<p>递归实现如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (A.val == B.val &amp;&amp; checkSubtree(A, B)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1.val == root2.val) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root2.left == <span class="keyword">null</span> &amp;&amp; root2.right == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">boolean</span> isSub = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (root2.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                isSub = ( isSub &amp;&amp; checkSubtree(root1.left, root2.left));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root2.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                isSub = ( isSub &amp;&amp; checkSubtree(root1.right, root2.right));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> isSub;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-27.-二叉树的镜像">4.2 <a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">剑指 Offer 27. 二叉树的镜像</a></h4>
<blockquote>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<pre><code>   4
  /   \
  2     7
 / \   / \
1   3 6   9</code></pre>
<p>镜像输出：</p>
<pre><code>   4
  /   \
  7     2
 / \   / \
9   6 3   1</code></pre>
</blockquote>
<p>直接递归求解即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode tmp = root.right;</span><br><span class="line">            root.right = mirrorTree(root.left);</span><br><span class="line">            root.left = mirrorTree(tmp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-28.-对称的二叉树">4.3 <a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 28. 对称的二叉树</a></h4>
<blockquote>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
</blockquote>
<p>直接递归求解即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span> &amp;&amp; left.val == right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-36.-二叉搜索树与双向链表">4.4 <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 36. 二叉搜索树与双向链表</a></h4>
<blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
</blockquote>
<p>可以发现二叉搜索树的中序遍历就是排序的链表，只需要按照中序遍历将二叉搜索树构造为一个有序链表后，修改指针指向就可以得到排序链表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Node&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        InOrderTravel(root, arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">            arr.get(i-<span class="number">1</span>).right = arr.get(i);</span><br><span class="line">            arr.get(i).left = arr.get(i-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr.get(<span class="number">0</span>).left = arr.get(arr.size() - <span class="number">1</span>);</span><br><span class="line">        arr.get(arr.size() - <span class="number">1</span>).right = arr.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrderTravel</span><span class="params">(Node root, ArrayList&lt;Node&gt; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            InOrderTravel(root.left, arr);</span><br><span class="line">            arr.add(root);</span><br><span class="line">            InOrderTravel(root.right, arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>, head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        InOrderTravel(root);</span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrderTravel</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            InOrderTravel(root.left);</span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="keyword">null</span>) pre.right = root;</span><br><span class="line">            <span class="keyword">else</span> head = root;</span><br><span class="line">            root.left = pre;</span><br><span class="line">            pre = root;</span><br><span class="line">            InOrderTravel(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Node pre = <span class="keyword">null</span>, head = <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur!= <span class="keyword">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = s.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pre.right = cur;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    head = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.left = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line"></span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-32---i.-从上到下打印二叉树">4.5 <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4>
<blockquote>
<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
</blockquote>
<p>基于队列层次遍历输出即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) q.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  res.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-32---ii.-从上到下打印二叉树-ii">4.6 <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h4>
<blockquote>
<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        q.offer(root);</span><br><span class="line">        q.offer(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; q.peek() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; curLevel = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; q.peek() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                curLevel.add(cur.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) q.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans.add(curLevel);</span><br><span class="line">            q.poll();</span><br><span class="line">            q.offer(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-32---iii.-从上到下打印二叉树-iii">4.7 <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h4>
<blockquote>
<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
</blockquote>
<p>利用双端队列实现：</p>
<ul>
<li>奇数层 添加至 <code>tmp</code> <strong>尾部</strong> ，</li>
<li>偶数层 添加至 <code>tmp</code> <strong>头部</strong> 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">0</span>) tmp.addLast(node.val); <span class="comment">// 偶数层 -&gt; 队列头部</span></span><br><span class="line">                <span class="keyword">else</span> tmp.addFirst(node.val); <span class="comment">// 奇数层 -&gt; 队列尾部</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) q.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) q.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-33.-二叉搜索树的后序遍历序列">4.8 <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<p>由二叉搜索树的特征有：</p>
<ul>
<li>根节点左子树的节点都小于根节点；</li>
<li>根节点右子树的节点都大于根节点。</li>
</ul>
<p>所以基于后序遍历，得到最后一个节点是根节点可以将当前的序列分为两个序列。分别判断其左、右子树是否满足二叉排序树的要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> verifyPostorder(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= end) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> split = end - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (split &gt;= <span class="number">0</span> &amp;&amp; postorder[split] &gt; postorder[end])</span><br><span class="line">            split--;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; split; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postorder[i] &gt; postorder[end]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> verifyPostorder(postorder, begin, split) &amp;&amp; verifyPostorder(postorder, split+<span class="number">1</span>, end - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-34.-二叉树中和为某一值的路径">4.9 <a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径</a></h4>
<blockquote>
<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下<strong><u>一直到叶节点</u></strong>所经过的节点形成一条路径。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; curPath = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        pathSum(root, target, curPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> target, List&lt;Integer&gt; curPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; target - root.val == <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; newPath = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> node : curPath) &#123;</span><br><span class="line">                newPath.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">            newPath.add(root.val);</span><br><span class="line">            res.add(newPath);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curPath.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) pathSum(root.left, target-root.val, curPath);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) pathSum(root.right, target-root.val, curPath);</span><br><span class="line">            curPath.remove(curPath.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-55---i.-二叉树的深度">4.10 <a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - I. 二叉树的深度</a></h4>
<blockquote>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-54.-二叉搜索树的第k大节点">4.11 <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4>
<blockquote>
<p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = s.pop();</span><br><span class="line">                arr.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &lt;= arr.size()) <span class="keyword">return</span> arr.get(arr.size() - k);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = s.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> cur.val;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-55---ii.-平衡二叉树">4.12 <a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - II. 平衡二叉树</a></h4>
<blockquote>
<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    boolean isBalanceFlag = true;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return true;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        return isBalanceFlag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return 0;</span><br><span class="line"></span><br><span class="line">        int leftDepth = maxDepth(root.left);</span><br><span class="line">        int rightDepth = maxDepth(root.right);</span><br><span class="line">        if (Math.abs(leftDepth - rightDepth) &gt; 1) isBalanceFlag = false;</span><br><span class="line">        </span><br><span class="line">        return Math.max(leftDepth, rightDepth) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-68---i.-二叉搜索树的最近公共祖先">4.13 <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4>
<blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 <code>T</code> 的两个结点 <code>p</code>、<code>q</code>，最近公共祖先表示为一个结点 <code>x</code>，满足 <code>x</code> 是 <code>p</code>、<code>q</code> 的祖先且 <code>x</code> 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</blockquote>
<p>注意到题目中给出的是一棵「二叉搜索树」，<span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 的最近公共祖先就是从根节点到它们路径上的「分岔点」，也就是最后一个相同的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        TreeNode ancestor = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &lt; ancestor.val &amp;&amp; q.val &lt; ancestor.val) &#123;</span><br><span class="line">                ancestor = ancestor.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val &gt; ancestor.val &amp;&amp; q.val &gt; ancestor.val) &#123;</span><br><span class="line">                ancestor = ancestor.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-68---ii.-二叉树的最近公共祖先">4.14 <a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h4>
<blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</blockquote>
<p>与上一题不同，现在给出的是一棵普通的树，所有不能直接基于值的比较来寻找最小祖先。若 <span class="math inline">\(root\)</span> 是 <span class="math inline">\(p, q\)</span> 的 <strong>最近公共祖先</strong> ，则只可能为以下情况之一：</p>
<ul>
<li><span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 在 <span class="math inline">\(root\)</span> 的子树中，且分列 <span class="math inline">\(root\)</span> 的 异侧（即分别在左、右子树中）；</li>
<li><span class="math inline">\(p = root\)</span>，且 <span class="math inline">\(q\)</span> 在 <span class="math inline">\(root\)</span> 的左或右子树中；</li>
<li><span class="math inline">\(q = root\)</span>，且 <span class="math inline">\(p\)</span> 在 <span class="math inline">\(root\)</span> 的左或右子树中；</li>
</ul>
<p>递归解析：</p>
<p>终止条件：</p>
<ul>
<li>当越过叶节点，则直接返回 <code>null</code> ；</li>
<li>当 <span class="math inline">\(root\)</span> 等于 <span class="math inline">\(p, q\)</span>，则直接返回 <span class="math inline">\(root\)</span>；</li>
</ul>
<p>递推工作：</p>
<ul>
<li><p>开启递归左子节点，返回值记为 <span class="math inline">\(left\)</span>；</p></li>
<li><p>开启递归右子节点，返回值记为 <span class="math inline">\(right\)</span>；</p></li>
</ul>
<p>返回值： 根据 <span class="math inline">\(left\)</span> 和 <span class="math inline">\(right\)</span>，可展开为四种情况；</p>
<ul>
<li>当 <span class="math inline">\(left\)</span> 和 <span class="math inline">\(right\)</span> 同时为空 ：说明 <span class="math inline">\(root\)</span> 的左 / 右子树中都不包含 <span class="math inline">\(p,q\)</span> ，返回 <code>null</code> ；</li>
<li>当 <span class="math inline">\(left\)</span>​ 和 <span class="math inline">\(right\)</span> 同时不为空 ：说明 <span class="math inline">\(p, q\)</span> 分列在 <span class="math inline">\(root\)</span> 的 异侧 （分别在 左 / 右子树），因此 <span class="math inline">\(root\)</span> 为最近公共祖先，返回 <span class="math inline">\(root\)</span>；</li>
<li>当 <span class="math inline">\(left\)</span> 为空 ，<span class="math inline">\(right\)</span> 不为空 ：<span class="math inline">\(p,q\)</span> 都不在 <span class="math inline">\(root\)</span> 的左子树中，直接返回 <span class="math inline">\(right\)</span>。具体可分为两种情况：
<ul>
<li><span class="math inline">\(p,q\)</span> 其中一个在 <span class="math inline">\(root\)</span> 的 右子树 中，此时 <span class="math inline">\(right\)</span> 指向 <span class="math inline">\(p\)</span>（假设为 <span class="math inline">\(p\)</span> ）；</li>
<li><span class="math inline">\(p,q\)</span> 两节点都在 <span class="math inline">\(root\)</span> 的 右子树 中，此时的 <span class="math inline">\(right\)</span> 指向 最近公共祖先节点 ；</li>
</ul></li>
<li>当 <span class="math inline">\(left\)</span> 不为空 ， <span class="math inline">\(right\)</span> 为空时同理；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>[大数据技术原理|第二篇 大数据存储与管理(1)]</title>
    <url>/2021/07/31/Big_Data_2_store-and-manage.html</url>
    <content><![CDATA[<h3 id="简介">简介</h3>
<p>介绍大数据存储与管理相关技术的概念与原理，包括<code>Hadoop分布式文件系统（HDFS）</code>、<code>分布式数据库（ HBase）</code>、<code>NoSQL数据库</code>和<code>云数据库</code>。</p>
<a id="more"></a>
<h3 id="分布式文件系统hdfs">1. 分布式文件系统<code>HDFS</code></h3>
<h4 id="分布式文件系统">1.1 分布式文件系统</h4>
<p><code>分布式文件系统（ Distributed File System）</code>是一种通过网络实现文件在多台主机上进行分布式存储的文件系统。分布式文件系统的设计一般采用<code>“客户机/服务器”（ Client/Server）模式</code>，客户端以特定的通信协议通过网络与服务器建立连接，提出文件访问请求，客户端和服务器可以通过设置访问权来限制请求方对底层数据存储块的访问。</p>
<h5 id="计算机集群结构">1.1.1 计算机集群结构</h5>
<p>分布式文件系统把文件分布存储到多个计算机节点上，与使用多个处理器和专用高级硬件的并行化处理装置不同的是，分布式文件系统所采用的计算机集群都是由普通硬件构成的。</p>
<p>集群中的计算机节点存放在<code>机架（Rack）</code>上，每个机架可以存放<code>8~64</code>个节点，同一机架上的不同节点之间通过网络互连，多个不同机架之间采用另一级网络或交换机互连。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/clusterStructure.PNG" alt="计算机集群结构" /><figcaption aria-hidden="true">计算机集群结构</figcaption>
</figure>
<h5 id="分布式文件系统的结构">1.1.2 分布式文件系统的结构</h5>
<p>分布式文件系统也采用了<code>块（Block）</code>的概念，文件被分成若干个块进行存储，块是数据读写的基本单元。比如，<code>HDFS</code>默认的一个块的大小是<code>64MB</code>。与普通文件不同的是，在分布式文件系统中，<strong><u>如果一个文件小于一个数据块的大小，它并不占用整个数据块的存储空间</u></strong>。</p>
<p>分布式文件系统在物理结构上是由计算机集群中的多个节点构成的。这些节点分为两类：</p>
<ul>
<li><code>“主节点”（ Master Node）</code>，也被称为<code>“名称节点”（ NameNode）</code>。名称节点负责<u><strong>文件和目录的创建</strong></u>、<strong><u>删除和重命名</u></strong>等，同时<strong><u>管理着数据节点和文件块的映射关系</u></strong>，因此客户端只有访问名称节点才能找到请求的文件块所在的位置，进而到相应位置读取所需文件块。</li>
<li><code>“从节点”（ Slave Node）</code>，也被称为<code>“数据节点”（ DataNode）</code>。数据节点负责<strong><u>数据的存储和读取</u></strong>。
<ul>
<li>在存储时，由名称节点分配存储位置，然后由客户端把数据直接写入相应数据节点；</li>
<li>在读取时，客户端从名称节点获得数据节点和文件块的映射关系，然后就可以到相应位置访问文件块。</li>
<li>数据节点也要根据名称节点的命令创建、删除数据块和冗余复制。</li>
</ul></li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/DFSStructure.PNG" alt="分布式文件系统的结构" /><figcaption aria-hidden="true">分布式文件系统的结构</figcaption>
</figure>
<p>计算机集群中的节点可能发生故障，因此为了保证数据的完整性，分布式文件系统通常采用<code>多副本存储</code>。文件块会被复制为多个副本，存储在不同的节点上，而且存储同一文件块的不同副本的各个节点会分布在不同的机架上。在单个节点出现故障时，可以快速调用副本重启单个节点上的计算过程，而不用重启整个计算过程，整个机架出现故障时也不会丢失所有文件块。</p>
<h5 id="分布式文件系统设计需求">1.1.3 分布式文件系统设计需求</h5>
<p>分布式文件系统的设计目标主要包括以下几点：</p>
<ul>
<li><strong>透明性</strong>。包括<code>访问透明性</code>、<code>位置透明性</code>、<code>性能和伸缩透明性</code>。
<ul>
<li><strong>访问透明性</strong>是指用户能够通过相同的操作来访问本地文件和远程文件资源。</li>
<li><strong>位置透明性</strong>是指在不改变路径名的前提下，不管文件副本数量和实际存储位置发生何种变化，对用户而言都是透明的，只需要<strong><u>使用相同的路径名</u></strong>就始终可以访问同一个文件。</li>
<li><strong>性能和伸缩透明性</strong>是指系统中节点的增加或减少以及性能的变化对用户而言是透明的。</li>
</ul></li>
<li><strong>并发控制</strong>。客户端对于文件的读写不应该影响其他客户端对同一个文件的读写。</li>
<li><strong>文件复制</strong>。文件可以拥有在不同位置的多个副本。</li>
<li><strong>硬件和操作系统的异构性</strong>。可以在不同的操作系统和计算机上实现同样的客户端和服务器端程序。</li>
<li><strong>可伸缩性</strong>。支持节点的动态加入或退出。</li>
<li><strong>容错</strong>。保证文件服务在客户端或者服务端出现问题的时候能正常使用。</li>
<li><strong>安全需求</strong>。保障系统的安全性。</li>
</ul>
<h4 id="hdfs-简介">1.2 HDFS 简介</h4>
<p><code>HDFS</code>在设计之初就充分考虑了实际应用环境的特点，即<strong><u>硬件出错在普通服务器集群中是一种常态，而不是异常</u></strong>。因此，<code>HDFS</code>在设计上采取了多种机制保证在硬件出错的环境中实现数据的完整性。</p>
<ul>
<li><strong>兼容廉价的硬件设备</strong>。<code>HDFS</code>设计了<strong><u>快速检测硬件故障和进行自动恢复的机制</u></strong>，可以实现持续监视、错误检查、容错处理和自动恢复，使得在硬件出错的情况下也能实现数据的完整性。</li>
<li><strong>流数据读写</strong>。<code>HDFS</code>则是为了满足批量数据处理的要求而设计的，因此<strong><u>为了提高数据吞吐率</u></strong>，<code>HDFS</code>放松了一些 <code>POSIX</code>的要求，从而能够以流式方式来访问文件系统数据。</li>
<li><strong>大数据集</strong>。</li>
<li><strong>简单的文件模型</strong>。<code>HDFS</code>采用了<code>“一次写入、多次读取”</code>的简单文件模型，<strong><u>文件一旦完成写入，关闭后就无法再次写入，只能被读取</u></strong>。</li>
<li><strong>强大的跨平台兼容性</strong>。</li>
</ul>
<p><code>HDFS</code>自身也具有应用局限性，主要包括：</p>
<ul>
<li><strong>不适合低延迟数据访问</strong>。对于低延时要求的应用程序而言， <code>HBase</code>是一个更好的选择</li>
<li><strong>无法高效存储大量小文件</strong>。过多小文件会给系统扩展性和性能带来诸多问题。
<ul>
<li><code>HDFS</code>采用<code>名称节点（ NameNode）</code>来管理文件系统的元数据，这些元数据被<strong><u>保存在内存</u></strong>中，从而使客户端可以快速获取文件实际存储位置。通常，每个文件、目录和块大约占<code>150</code>字节。文件数量过多时，名称节点保存元数据所需要的内存空间会大大增加，元数据检索的效率会降低，需要花费较多的时间找到一个文件的实际存储位置。</li>
<li>用<code>MapReduce</code>处理大量小文件时，会产生过多的<code>Map</code>任务，线程管理开销会大大增加。</li>
<li>访问大量小文件，需要不断从一个数据节点跳到另一个数据节点，严重影响性能。</li>
</ul></li>
<li><strong>不支持多用户写入及任意修改文件</strong>。<code>HDFS</code>只允许一个文件有一个写入者，不允许多个用户对同一个文件执行写操作，而且<strong><u>只允许对文件执行追加操作，不能执行随机写操作</u></strong>。</li>
</ul>
<h4 id="hdfs相关概念">1.3 HDFS相关概念</h4>
<h5 id="块">1.3.1 块</h5>
<p><code>HDFS</code>采用了块的概念，默认的一个块大小是<code>64MB</code>。在<code>HDFS</code>中的文件会被拆分成多个块，每个块作为独立的单元进行存储。<code>HDFS</code>这么做的原因，是为了<strong><u>最小化寻址开销</u></strong>。<code>HDFS</code>寻址开销包括<code>磁盘寻道开销</code>和<code>数据块的定位开销</code>。当客户端需要访问一个文件时：</p>
<ul>
<li>首先从名称节点获得组成这个文件的数据块的位置列表；</li>
<li>然后根据位置列表获取实际存储各个数据块的数据节点的位置；</li>
<li>最后数据节点根据数据块信息在本地<code>Linux</code>文件系统中找到对应的文件，并把数据返回给客户端。</li>
</ul>
<p>设计一个比较大的块，可以把上述寻址开销分摊到较多的数据中，降低了单位数据的寻址开销。</p>
<h5 id="名称节点和数据节点">1.3.2 名称节点和数据节点</h5>
<h6 id="名称节点">1.3.2.1 名称节点</h6>
<p><code>名称节点（ Name Node）</code>负责管理分布式文件系统的<code>命名空间（ Namespace）</code>，保存了两个核心的数据结构，即 <code>FsImage</code>和 <code>EditLog</code>：</p>
<ul>
<li><code>FsImage</code>用于维护文件系统树以及文件树中所有的文件和文件夹的元数据；</li>
<li>操作日志文件<code>EditLog</code>中记录了所有针对文件的创建删除、重命名等操作。</li>
</ul>
<p>名称节点记录了每个文件中各个块所在的数据节点的位置信息，但是<strong><u>并不持久化存储这些信息，而是在系统每次启动时扫描所有数据节点重构得到这些信息</u></strong>。</p>
<ul>
<li>名称节点在启动时，会将<code>FsImage</code>的内容加载到内存当中，然后执行<code>EditLog</code>文件中的各项操作，使得内存中的元数据保持最新。</li>
<li>这个操作完成以后，就会创建一个新的<code>FImage</code>文件和一个空的<code>EditLog</code>文件。</li>
<li>名称节点启动成功并进入正常运行状态以后，HDFS中的更新操作都会被写入到<code>EditLog</code>，而不是直接写入 <code>FsImage</code>。因为<code>FsImage</code>文件通常都很庞大，如果所有的更新操作都直接往<code>FsImage</code>文件中添加，那么系统就会变得非常缓慢。<code>EditLog</code>通常都要远远小于<code>FsImage</code>，更新操作写入到 <code>EditLog</code>是非常高效的。</li>
</ul>
<p>名称节点在启动的过程中处于<code>“安全模式”</code>，只能<strong><u>对外提供读操作无法提供写操作</u></strong>。启动过程结束后，系统就会退出安全模式，进入正常运行状态，对外提供读写操作。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/NameNodeDataStructure.PNG" alt="名称节点数据结构" /><figcaption aria-hidden="true">名称节点数据结构</figcaption>
</figure>
<h6 id="数据节点">1.3.2.2 数据节点</h6>
<p><code>数据节点（ DataNode）</code>是分布式文件系统<code>HDFS</code>的工作节点，负责<strong><u>数据的存储和读取</u></strong>，会根据客户端或者名称节点的调度来进行数据的存储和检索，并且向名称节点定期发送自己所存储的块的列表。每个数据节点中的数据会被保存在各自节点的本地<code>Linux</code>文件系统中。</p>
<h5 id="第二名称节点">1.3.3 第二名称节点</h5>
<p>不断变大的<code>EditLog</code>文件通常对于系统性能不会产生显著影响。但是当名称节点重启时，如果<code>EditLog</code>很大，会导致整个过程变得非常缓慢，使得名称节点在启动过程中长期处于<code>“安全模式”</code>。为了有效解决<code>EditLog</code>逐渐变大带来的问题，<code>HDFS</code>在设计中采用了<code>第二名称节点（ Secondary Name Node）</code>，具有两个方面的功能：</p>
<ul>
<li>可以完成<code>EditLog</code>与<code>FsImage</code>的合并操作，减小<code>EditLog</code>文件大小，缩短名称节点重启时间。
<ul>
<li>每隔一段时间，第二名称节点会和名称节点通信，请求其停止使用<code>EditLog</code>文件，暂时将新到达的写操作添加到一个新的文件<code>EditLog.new</code>中；</li>
<li>第二名称节点把名称节点中的<code>FsImage</code>文件和<code>EditLog</code>文件拉回到本地，再加载到内存中；</li>
<li>对二者执行合并操作，即在内存中逐条执行<code>EditLog</code>中的操作，使得<code>FsImage</code>保持最新；</li>
<li>合并结束后，第二名称节点会把合并后得到的最新的<code>FsImage</code>文件发送到名称节点；</li>
<li>名称节点收到后，会用最新的<code>FsImage</code>文件去替换旧的<code>FsImage</code>文件，同时用<code>EditLog.new</code>文件去替换 <code>EditLog</code>文件，从而减小了 EditLog文件的大小。</li>
</ul></li>
<li>可以作为名称节点的<code>“检查点”（checkpoint）</code>，保存名称节点中的元数据信息。
<ul>
<li>第二名称节点会定期和名称节点通信，从名称节点获取<code>FsImage</code>文件和<code>EditLog</code>文件，执行合并操作得到新的<code>FsImage</code>文件。从这个角度来讲，第二名称节点相当于为名称节点设置了一个<code>“检查点”</code>，周期性地备份名称节点中的元数据信息，当名称节点发生故障时，可以用第二名称节点中记录的元数据信息进行系统恢复。</li>
<li>但第二名称节点并不能起到<code>热备份</code>的作用。节点上的<code>FsImage</code>文件是合并操作发生时<code>HDFS</code>记录的元数据信息，系统就会丢失合并操作之后的部分元数据信息。</li>
</ul></li>
</ul>
<h4 id="hdfs体系结构">1.4 HDFS体系结构</h4>
<h5 id="概述">1.4.1 概述</h5>
<p><code>HDFS</code>采用了<code>主从（ Master/Slave）结构模型</code>，一个HDFS集群包括<strong><u>一个名称节点和若干个数据节点</u></strong>。</p>
<ul>
<li>名称节点作为<strong>中心服务器</strong>，负责管理文件系统的命名空间及客户端对文件的访问。</li>
<li>数据节点，负责处理文件系统客户端的读写请求，在名称节点的统一调度下进行数据块的创建、删除和复制等操作，一般是<strong><u>一个节点运行一个数据节点进程</u></strong>。每个数据节点的数据实际上是保存在本地<code>Linux</code>文件系统中的。每个数据节点会<u><strong>周期性地向名称节点发送<code>“心跳”</code>信息</strong></u>，报告自己的状态，没有按时发送心跳信息的数据节点会被标记为<code>“宕机”</code>，不会再给它分配任何IO请求。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HDFS.PNG" alt="HDFS体系结构" /><figcaption aria-hidden="true">HDFS体系结构</figcaption>
</figure>
<p>用户在使用<code>HDFS</code>时，使用文件名去存储和访问文件。</p>
<ul>
<li>当客户端需要访问一个文件时，首先把文件名发送给名称节点，名称节点根据文件名找到对应的数据块；</li>
<li>名称节点再根据每个数据块信息找到实际存储各个数据块的数据节点的位置，并把数据节点位置发送给客户端；</li>
<li>最后客户端直接访问这些数据节点获取数据。在整个访问过程中，名称节点并不参与数据的传输。</li>
</ul>
<h5 id="hdfs命名空间管理">1.4.2 HDFS命名空间管理</h5>
<p><code>HDFS</code>的命名空间包含<strong><u>目录、文件和块</u></strong>。命名空间管理是指<u>命名空间支持对HDFS中的目录、文件和块做类似文件系统的创建、修改、删除等基本操作</u>。在当前的<code>HDFS</code>体系结构中，在整个<code>HDFS</code>集群中<u><strong>只有一个命名空间，并且只有唯一一个名称节点</strong></u>负责对这个命名空间进行管理。</p>
<p>HDFS使用的是传统的<strong><u>分级文件体系</u></strong>，因此用户可以像使用普通文件系统一样，创建、删除目录和文件，在目录间转移文件、重命名文件等。<code>HDFS</code><strong><u>还没有实现磁盘配额和文件访问权限等功能，也不支持文件的硬连接和软连接</u></strong>。</p>
<h5 id="通信协议">1.4.3 通信协议</h5>
<p><code>HDFS</code>通信协议都是构建在<code>TCP/IP</code>协议基础上的。</p>
<ul>
<li>客户端通过一个可配置的端口向名称节点主动发起<code>TCP</code>连接，并使用客户端协议与名称节点进行交互。</li>
<li>名称节点和数据节点之间则使用数据节点协议进行交互。</li>
<li>客户端与数据节点的交互是通过<code>RPC（ Remote Procedure Cal）</code>来实现的。名称节点不会主动发起<code>RPC</code>，而是响应来自客户端和数据节点的<code>RPC</code>请求。</li>
</ul>
<h5 id="客户端">1.4.4 客户端</h5>
<p>客户端是用户操作<code>HDFS</code>最常用的方式，<code>HDFS</code>在部署时都提供了客户端。但客户端并不算是<code>HDFS</code>的一部分。客户端可以支持打开、读取、写入等常见的操作，并且提供了类似<code>shell</code>的命令行方式来访问HDFS中的数据。</p>
<h5 id="hdfs体系结构的局限性">1.4.5 HDFS体系结构的局限性</h5>
<ol type="1">
<li><strong>命名空间的限制</strong>。名称节点是保存在内存中的，因此名称节点能够容纳对象（文件、块）的个数会受到内存空间大小的限制。</li>
<li><strong>性能的瓶颈</strong>。整个分布式文件系统的吞吐量受限于单个名称节点的吞吐量。</li>
<li><strong>隔离问题</strong>。由于集群中只有一个名称节点，只有一个命名空间，因此无法对不同应用程序进行隔离。</li>
<li><strong>集群的可用性</strong>。一旦这个唯一的名称节点发生故障，会导致整个集群变得不可用。</li>
</ol>
<h4 id="hdfs存储原理">1.5 HDFS存储原理</h4>
<h5 id="数据的冗余存储">1.5.1 数据的冗余存储</h5>
<p>为了保证系统的<strong><u>容错性和可用性</u></strong>，<code>HDFS</code>采用了<strong><u>多副本方式</u></strong>对数据进行冗余存储，通常一个数据块的多个副本会被分布到不同的数据节点上。这种多副本方式具有以下优点：</p>
<ul>
<li><strong>加快数据传输速度</strong>。多个客户端需要同时访问同一个文件时，可以让各个客户端分别从不同的数据块副本中读取数据，这就大大加快了数据传输速度。</li>
<li><strong>容易检查数据错误</strong>。<code>HDFS</code>的数据节点之间通过网络传输数据，采用多个副本可以很容易判断数据传输是否出错。</li>
<li><strong>保证数据的可靠性</strong>。即使某个数据节点出现故障失效，也不会造成数据丢失。</li>
</ul>
<h5 id="数据存取策略">1.5.2 数据存取策略</h5>
<h6 id="数据存放">1.5.2.1 数据存放</h6>
<p><code>HDFS</code>采用了<strong>以<code>机架（Rack）</code>为基础的数据存放策略</strong>。<code>HDFS</code>默认每个数据节点都是在不同的机架上：</p>
<ul>
<li>缺点是写入数据的时候<strong><u>不能充分利用同一机架内部机器之间的带宽</u></strong>。</li>
<li>但也带来了更多很显著的优点：
<ul>
<li>可以获得很高的数据可靠性，即使一个机架发生故障，位于其他机架上的数据副本仍然是可用的；</li>
<li>在读取数据的时候，可以在多个机架上并行读取数据，大大提高了数据读取速度；</li>
<li>可以更容易地实现系统内部负载均衡和错误处理。</li>
</ul></li>
</ul>
<p><code>HDFS</code>默认的冗余复制因子是<code>3</code>，每一个文件块会被同时保存到<code>3</code>个地方，有两份副本放在同一个机架的不同机器上面，第三个副本放在不同机架的机器上面，这样既可以保证机架发生异常时的数据恢复，也可以提高数据读写性能。</p>
<ul>
<li>如果是在集群内发起写操作请求，则把第一个副本放置在发起写操作请求的数据节点上，实现就近写入数据。</li>
<li>如果是来自集群外部的写操作请求，则从集群内部挑选一台<strong>磁盘不太满、CPU不太忙</strong>的数据节点，作为第一个副本的存放地。</li>
<li>第二个副本会被放置在<strong><u>与第一个副本不同的机架的数据节点上</u></strong>。</li>
<li>第三个副本会被放置在<strong><u>与第一个副本相同的机架的其他节点上</u></strong>。</li>
<li>如果还有更多的副本，则继续从集群中随机选择数据节点进行存放。</li>
</ul>
<h6 id="数据读取">1.5.2.2 数据读取</h6>
<p><code>HDFS</code>提供了一个<code>API</code>可以确定一个数据节点所属的机架<code>ID</code>，客户端可以调用<code>API</code>获取自己所属的机架。当客户端读取数据时：</p>
<ul>
<li>从名称节点获得数据块<strong><u>不同副本的存放位置列表</u></strong>，列表中包含了副本所在的数据节点，可以调用<code>API</code>来确定客户端和这些数据节点所属的机架<code>ID</code>。</li>
<li>当发现某个数据块副本对应的机架ID和客户端对应的机架ID相同时，就优先选择该副本读取数据，如果没有发现，就随机选择一个副本读取数据。</li>
</ul>
<h6 id="数据复制">1.5.2.3 数据复制</h6>
<p><code>HDFS</code>的数据复制采用了<strong><u>流水线复制的策略</u></strong>，大大提高了数据复制过程的效率。当客户端要往<code>HDFS</code>中写入一个文件时：</p>
<ul>
<li>首先把这个文件写入本地，并被切分成若干个块，每个块的大小是由<code>HDFS</code>的设定值来决定的。每个块都向<code>HDFS</code>集群中的名称节点发起写请求；</li>
<li>名称节点会根据系统中各个数据节点的使用情况，选择一个数据节点列表返回给客户端，然后客户端就把数据首先写入列表中的第一个数据节点，同时把列表传给第一个数据节点；</li>
<li>当第一个数据节点接收到<code>4KB</code>数据的时候，写入本地，并且向列表中的第二个数据节点发起连接请求，把自己已经接收到的<strong><u><code>4KB</code>数据和列表</u></strong>传给第二个数据节点；</li>
<li>当第二个数据节点接收到<code>4KB</code>数据的时候，写入本地，并且向列表中的第三个数据节点发起连接请求，依次类推列表中的多个数据节点形成一条<strong><u>数据复制的流水线</u></strong>。</li>
<li>最后，当文件写完的时候，数据复制也同时完成。</li>
</ul>
<h5 id="数据错误与恢复">1.5.3 数据错误与恢复</h5>
<h6 id="名称节点出错">1.5.3.1.名称节点出错</h6>
<p>名称节点保存了所有的元数据信息，其中最核心的两大数据结构是<code>FsImage</code>和<code>EditLog</code>，如果这两个文件发生损坏，那么整个<code>HDFS</code>实例将失效。<code>Hadoop</code>采用两种机制来确保名称节点的安全：</p>
<ul>
<li>把名称节点上的元数据信息同步存储到其他文件系统中（比如远程挂载的网络文件系统<code>NFS</code>）；</li>
<li>运行一个第二名称节点，当名称节点宕机以后，可以把第二名称节点作为一种弥补措施，利用第二名称节点中的元数据信息进行系统恢复，但这样做仍然会丢失部分数据。</li>
</ul>
<p>一般会把两种方式结合使用，当名称节点发生宕机时，首先到远程挂载的网络文件系统中<u><strong>获取备份的元数据信息</strong></u>，<strong><u>放到第二名称节点上进行恢复，并把第二名称节点作为名称节点来使用</u></strong>。</p>
<h6 id="数据节点出错">1.5.3.2 数据节点出错</h6>
<p>每个数据节点会定期向名称节点发送<code>“心跳”</code>信息，向名称节点报告自己的状态。当数据节点发生故障，或者网络发生断网时，名称节点就无法收到来自一些数据节点的<code>“心跳”</code>信息，这时这些数据节点就会被标记为<code>“宕机”</code>，节点上面的所有数据都会被标记为<code>“不可读”</code>，名称节点不会再给它们发送任何<code>IO</code>请求。</p>
<p>由于一些数据节点的不可用，会导致一些数据块的副本数量小于冗余因子。名称节点会定期检查这种情况，一旦发现某个数据块的副本数量小于冗余因子，就会启动数据冗余复制，为它生成新的副本。</p>
<h6 id="数据出错">1.5.3.3 数据出错</h6>
<p>网络传输和磁盘错误等因素都会造成数据错误。客户端在读取到数据后，会采用<code>md5</code>和<code>sha1</code>对数据块进行校验，以确定读取到正确的数据。如果校验出错，客户端就会请求到另外一个数据节点读取该文件块，并且向名称节点报告这个文件块有错误，名称节点会定期检查并且重新复制这个块。</p>
<h4 id="hdfs的数据读写过程">1.6 HDFS的数据读写过程</h4>
<h5 id="读数据">1.6.1 读数据</h5>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HDFSRead.PNG" alt="HDFS读" /><figcaption aria-hidden="true">HDFS读</figcaption>
</figure>
<p><code>HDFS</code>的内部执行过程如下：</p>
<ol type="1">
<li>客户端通过<code>FileSystem.open()</code>打开文件，在<code>HDFS</code>文件系统中<code>DistributedFileSystem</code>具体实现了<code>FileSystem</code>。调用<code>open()</code>方法后，<code>DistributedFileSystem</code>会创建输入流<code>FSDatalnputstream</code>，对于<code>HDFS</code>而言，<strong><u>具体的输入流就是<code>DFSInputStream</code></u></strong>。</li>
<li>在<code>DFSInputStream</code>的构造函数中，输入流通过<code>ClientProtocal.getBlockLocations()</code>远程调用名称节点，获得文件开始部分数据块的保存位置。
<ul>
<li>名称节点返回保存该数据块的所有数据节点的地址，同时根据距离客户端的远近对数据节点进行排序；</li>
<li><code>DistributedFileSystem</code>利用<code>DFSInputStream</code>来实例化<code>FSDataInputStream</code>，返回给客户端，同时返回数据块的数据节点地址。</li>
</ul></li>
<li>获得输入流<code>FSDataInputStream</code>后，客户端调用<code>read()</code>函数开始读取数据。输入流根据前面的排序结果，选择距离客户端最近的数据节点建立连接并读取数据。</li>
<li>数据从该数据节点读到客户端；当该数据块读取完毕时，<code>FSDataInputStream</code>关闭和该数据节点的连接。</li>
<li>输入流通过<code>getBlockLocations()</code>方法查找下一个数据块。</li>
<li>找到该数据块的最佳数据节点，读取数据。</li>
<li>当客户端读取完毕数据的时候，调用<code>FSDataInputStream</code>的<code>close()</code>函数，关闭输入流。</li>
</ol>
<p>在读取数据的过程中，如果客户端与数据节点通信时出现错误，就会尝试连接包含此数据块的下一个数据节点。</p>
<h5 id="写数据">1.6.2 写数据</h5>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HDFSWrite.PNG" alt="HDFS写" /><figcaption aria-hidden="true">HDFS写</figcaption>
</figure>
<p><code>HDFS</code>的内部执行过程如下：</p>
<ol type="1">
<li>客户端通过<code>FileSystem.create()</code>创建文件，调用<code>create()</code>方法后，<code>DistributedFileSystem</code>会创建输出流 <code>FSDataOutputStream</code>，对于<code>HDFS</code>而言，具体的输出流就是<code>DFSOutputStream</code>；</li>
<li><code>DistributedFileSystem</code>通过<code>RPC</code>远程调用名称节点，在文件系统的命名空间中创建一个新的文件。
<ul>
<li>名称节点会执行一些检查，比如文件是否已经存在、客户端是否有权限创建文件等。检查通过之后，名称节点会构造一个新文件，并添加文件信息。</li>
<li>远程方法调用结束后，<code>DistributedFileSystem</code>会利用<code>DFSOutputStream</code>来实例化 <code>FSDataOutputStream</code>，返回给客户端，客户端使用这个输出流写入数据。</li>
</ul></li>
<li>获得输出流<code>FSDataOutputStream</code>以后，客户端调用输出流的<code>write()</code>方法向<code>HDFS</code>中对应的文件写入数据。</li>
<li>客户端向输出流<code>FSDataOutputStream</code>中写入的数据会首先被分成分包，这些分包被放入<code>DFSOutputStream</code>对象的内部队列。输出流<code>FSDataOutputStream</code>会向名称节点申请保存文件和副本数据块的若干个数据节点，这些数据节点形成一个数据流管道。队列中的分包最后被打包成数据包，数据包会流经管道上的各个数据节点。</li>
<li>为了保证所有数据节点的数据都是准确的，接收到数据的数据节点要向发送者发送<code>“确认包”（ ACK Packet）</code>。确认包沿着数据流管道逆流而上，从数据流管道依次经过各个数据节点并最终发往客户端，当客户端收到应答时，它将对应的分包从内部队列移除。不断执行直到数据全部写完。</li>
<li>客户端调用<code>close()</code>方法关闭输出流，客户端不会再向输出流中写入数据，当<code>DFSOutputStream</code>对象内部队列中的分包都收到应答以后，使用<code>ClientProtocol.complete()</code>方法通知名称节点关闭文件。</li>
</ol>
<h4 id="hdfs实践">1.7 HDFS实践</h4>
<h5 id="hdfs常用命令">1.7.1 HDFS常用命令</h5>
<h6 id="文件夹目录操作">1.7.1.1 文件夹目录操作</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 查看目录</span></span><br><span class="line"><span class="comment"># 显示目录结构</span></span><br><span class="line">hdfs dfs -ls &lt;path&gt;</span><br><span class="line"><span class="comment"># 以人性化的方式递归显示目录结构</span></span><br><span class="line">hdfs dfs -ls  -R -h &lt;path&gt;</span><br><span class="line"><span class="comment"># 显示根目录下内容</span></span><br><span class="line">hdfs dfs -ls /</span><br><span class="line"><span class="comment"># 查看HDFS目录“/tmp/&#123;test&#125;/hdfs_data”的内容。</span></span><br><span class="line">hadoop fs -ls /tmp/&#123;<span class="built_in">test</span>&#125;/hdfs_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建目录</span></span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">hdfs dfs -mkdir &lt;path&gt; </span><br><span class="line"><span class="comment"># 递归创建目录</span></span><br><span class="line">hdfs dfs -mkdir -p &lt;path&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在HDFS上创建目录“/tmp/&#123;test&#125;/hdfs_data”。</span></span><br><span class="line">hadoop fs -mkdir -p /tmp/&#123;<span class="built_in">test</span>&#125;/hdfs_data</span><br><span class="line"><span class="comment"># 一般在hdfs上都有的需要处理的数据目录</span></span><br><span class="line">hdfs dfs -mkdir /input </span><br><span class="line"><span class="comment"># 一般在hdfs上都有的处理的结果数据目录</span></span><br><span class="line">hdfs dfs -mkdir /output</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除目录</span></span><br><span class="line"><span class="comment"># 删除空文件夹</span></span><br><span class="line">hdfs dfs -rmdir &lt;path&gt;</span><br><span class="line"><span class="comment"># 递归删除目录和文件</span></span><br><span class="line">hdfs dfs -rm -r &lt;path&gt;</span><br></pre></td></tr></table></figure>
<h6 id="文件操作">1.7.1.2 文件操作</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 查看文件信息</span></span><br><span class="line"><span class="comment"># 二选一执行即可</span></span><br><span class="line">hdfs dfs -cat &lt;path&gt; </span><br><span class="line"><span class="comment">#将HDFS中文件以文本形式输出（包括zip包，jar包等形式）</span></span><br><span class="line">hdfs dfs -text &lt;path&gt; </span><br><span class="line"></span><br><span class="line">hdfs dfs -tail &lt;path&gt; </span><br><span class="line"><span class="comment">#和Unix中tail -f命令类似，当文件内容更新时，输出将会改变，具有实时性</span></span><br><span class="line">hdfs dfs -tail -f &lt;path&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 修改文件的权限、所有者</span></span><br><span class="line"><span class="comment"># 权限控制和Linux上使用方式一致</span></span><br><span class="line"><span class="comment"># 变更文件或目录的所属群组。 用户必须是文件的所有者或超级用户。</span></span><br><span class="line">hdfs dfs -chgrp [-R] GROUP URI [URI ...]</span><br><span class="line"><span class="comment"># 修改文件或目录的访问权限  用户必须是文件的所有者或超级用户。</span></span><br><span class="line">hdfs dfs -chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; URI [URI ...]</span><br><span class="line"><span class="comment"># 修改文件的拥有者  用户必须是超级用户。</span></span><br><span class="line">hdfs dfs -chown [-R] [OWNER][:[GROUP]] URI [URI ]</span><br><span class="line"><span class="comment">#案例</span></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -chmod -R 774 /tmp</span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -chown -R biubiubiu:hadoopenv /tmp</span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -chgrp -R <span class="built_in">test</span> /tmp</span><br><span class="line"></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -chmod 777 /input/hello.txt</span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -chown 1111:1111  /input/hello.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 统计文件信息</span></span><br><span class="line"><span class="comment"># 统计目录下各文件大小</span></span><br><span class="line">hdfs dfs -du [-s] [-h] URI [URI ...]</span><br><span class="line">-s : 显示所有文件大小总和</span><br><span class="line">-h : 将以更友好的方式显示文件大小（例如 64.0m 而不是 67108864）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计文件系统的可用空间</span></span><br><span class="line">hdfs dfs -df -h /</span><br><span class="line">-h : 将以更友好的方式显示文件大小（例如 64.0m 而不是 67108864）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 修改文件的副本数</span></span><br><span class="line"><span class="comment">#更改文件的复制因子。如果 path 是目录，则更改其下所有文件的复制因子</span></span><br><span class="line">hdfs dfs -setrep [-w] &lt;numReplicas&gt; &lt;path&gt;</span><br><span class="line">-w : 标志的请求，命令等待复制完成。这有可能需要很长的时间。</span><br><span class="line"></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -setrep 2  /input/hello.txt</span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -setrep -w 5 /input/bbb.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 删除文件</span></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">hdfs dfs -rm &lt;path&gt;</span><br><span class="line"></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -rm  /input/hello.txt</span><br></pre></td></tr></table></figure>
<h6 id="本地与集群的操作">1.7.1.3 本地与集群的操作</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 将Linux本地的文件上传到集群</span></span><br><span class="line"><span class="comment"># 二选一执行即可</span></span><br><span class="line">hdfs dfs -put &lt;localsrc&gt; &lt;dst&gt;</span><br><span class="line">hdfs dfs -copyFromLocal &lt;localsrc&gt; &lt;dst&gt;</span><br><span class="line">-f ：当文件存在时，进行覆盖</span><br><span class="line">-p ：将权限、所属组、时间戳、ACL以及XATTR等也进行拷贝</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 将Linux本地的文件剪切到集群</span></span><br><span class="line">hdfs dfs -moveFromLocal &lt;localsrc&gt; &lt;dst&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 将Linux本地的文件追加到集群文件</span></span><br><span class="line">hdfs dfs -appendToFile &lt;localsrc&gt; ... &lt;dst&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#案例</span></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -appendToFile ./test_1.txt /input/aaa.txt</span><br><span class="line"><span class="comment"># 多个文件用空格隔开</span></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -appendToFile ./test_1.txt ./test_2.txt /input/aaa.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 将集群文件下载到Linux本地</span></span><br><span class="line"><span class="comment"># 二选一执行即可</span></span><br><span class="line">hdfs dfs -get &lt;src&gt; &lt;localdst&gt;</span><br><span class="line">hdfs dfs -copyToLocal &lt;src&gt; &lt;localdst&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 合并下载多个文件到本地Linux</span></span><br><span class="line">hdfs dfs -getmerge [-nl] &lt;src&gt; &lt;localdst&gt;</span><br><span class="line"></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -getmerge /input/*  data.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例 将HDFS上的wordcount_input.txt和aaa.txt合并后下载到本地的当前用户家目录的merge.txt</span></span><br><span class="line">[biubiubiu@hadoop01 ~]$ hdfs dfs -getmerge /input/wordcount_input.txt /wordcount/input/aaa.txt ~/merge.txt</span><br><span class="line">-nl: 在每个文件的末尾添加换行符（LineFeed）</span><br><span class="line">-skip-empty-file: 跳过空文件</span><br></pre></td></tr></table></figure>
<p>更多可以参考<a href="https://blog.csdn.net/qq_40246175/article/details/104304193" target="_blank" rel="noopener">【csdn-HDFS常用Shell命令总结】</a>或官方<code>API</code>。</p>
<h5 id="hdfs-web界面">1.7.2 HDFS Web界面</h5>
<p>在配置好<code>Hadoop</code>集群之后，可以通过浏览器登录<code>"http://[NameNodelP]:50070"</code>访问<code>HDFS</code>文件系统，<code>[NameNodeIP]</code>表示名称节点的<code>IP</code>地址。伪分布式安装后，可以登录<code>"http://localhost:50070"</code>来查看文件系统信息。该<code>Web</code>界面的所有功能都能通过<code>Shell</code>命令等价实现。</p>
<h3 id="分布式数据库hbase">2. 分布式数据库<code>HBase</code></h3>
<h4 id="概述-1">2.1 概述</h4>
<p>HBase是一个高可靠、高性能、面向列、可伸缩的<strong><u>分布式数据库</u></strong>，主要用来存储非结构化和半结构化的松散数据。</p>
<ul>
<li><code>HBase</code>利用<code>Hadoop MapReduce</code>来处理<code>HBase</code>中的海量数据，实现高性能计算；</li>
<li>利用<code>Zookeeper</code>作为协同服务，实现稳定服务和失败恢复；</li>
<li>使用<code>HDFS</code>作为高可靠的底层存储，利用廉价集群提供海量数据存储能力。<code>HBase</code>也可以直接使用本地文件系统而不用<code>HDFS</code>作为底层数据存储方式。</li>
<li><code>Sqoop</code>为<code>HBase</code>提供了高效、便捷的<code>RDBMS</code>数据导入功能；</li>
<li><code>Pig</code>和<code>Hive</code>为<code>HBase</code>提供了高层语言支持。</li>
</ul>
<p><code>HBase</code>与传统的关系数据库的区别主要体现在以下几个方面。</p>
<ul>
<li><strong>数据类型</strong>。关系数据库采用<code>关系模型</code>，具有丰富的数据类型和存储方式。<code>HBase</code>则采用了更加简单的数据模型，它<strong><u>把数据存储为未经解释的字符串</u></strong>，用户可以把不同格式的结构化数据和非结构化数据都序列化成字符串保存到 <code>HBase</code>中，需要<strong><u>自己编写程序把字符串解析成不同的数据类型</u></strong>。</li>
<li><strong>数据操作</strong>。关系数据库中包含了丰富的操作，如插入、删除、更新、查询等，其中会涉及复杂的多表连接。<code>HBase</code>操作则不存在复杂的表与表之间的关系，只有简单的<strong><u>插入、查询、删除、清空</u></strong>等，因为<code>HBase</code>在设计上就避免了复杂的表与表之间的关系，通常只采用单表的主键查询。</li>
<li><strong>存储模式</strong>。关系数据库是<strong><u>基于行模式存储的</u></strong>，元组或行会被连续地存储在磁盘页中。<code>HBase</code>是<strong><u>基于列存储的</u></strong>，每个列族都由几个文件保存，不同列族的文件是分离的，优点是：
<ul>
<li>可以降低IO开销，支持大量并发用户查询，因为仅需要处理可以回答这些查询的列，而不需要处理与查询无关的大量数据行；</li>
<li>同一个列族中的数据会被一起进行压缩，由于同一列族内的数据相似度较高，因此可以获得较高的数据压缩比。</li>
</ul></li>
<li><strong>数据索引</strong>。关系数据库通常可以针对不同列构建复杂的多个索引，以提高数据访问性能。<code>HBase</code>只有一个索引——<strong><u>行键</u></strong>，<code>Hase</code>中的所有访问方法，或者通过行键访问，或者通过行键扫描，可以使用<code>Hadoop MapReduce</code>来快速、高效地生成索引表。</li>
<li><strong>数据维护</strong>。在关系数据库中，更新操作会用最新的当前值去替换记录中原来的旧值，旧值被覆盖后就不会存在。而在<code>HBase</code>中执行更新操作时，并不会删除数据旧的版本，而是<strong><u>生成一个新的版本，旧有的版本仍然保留</u></strong>。</li>
<li><strong>可伸缩性</strong>。关系数据库很难实现横向扩展，纵向扩展的空间也比较有限。<code>HBase</code>和<code>Big Table</code>这些分布式数据库能够轻易地通过在集群中增加或者减少硬件数量来实现性能的伸缩。</li>
<li><strong>事务</strong>。<code>HBase</code>不支持事务，因此无法实现跨行的原子性。</li>
</ul>
<h4 id="hbase-数据模型">2.2 HBase 数据模型</h4>
<h5 id="数据模型概述">2.2.1 数据模型概述</h5>
<p><code>HBase</code>是一个<strong><u>稀疏、多维度、排序的映射表</u></strong>，这张表的<strong><u>索引是行键、列族、列限定符和时间戳</u></strong>。每个值是一个未经解释的字符串，没有数据类型。</p>
<ul>
<li><p>用户在表中存储数据，每一行都有一个<strong><u>可排序的行键和任意多的列</u></strong>。表在水平方向由一个或者多个列族组成，一个列族中可以包含任意多个列，同一个列族里面的数据存储在一起。列族支持<strong><u>动态扩展</u></strong>，可以很轻松地添加一个列族或列。由于同一张表里面的每一行数据都可以有截然不同的列，<code>HBase</code>是稀疏的。</p></li>
<li><p>在<code>HBase</code>中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本。客户端可以选择获取距离某个时间最近的版本，或者一次获取所有版本。如果在查询的时候不提供时间戳，那么会返回距离现在最近的那一个版本的数据。<code>HBase</code>提供了两种数据版本回收方式：一是保存数据的最后<code>n</code>个版本；二是保存最近一段时间内的版本。</p></li>
</ul>
<h5 id="数据模型相关概念">2.2.2 数据模型相关概念</h5>
<p><code>HBase</code>实际上就是一个稀疏、多维、持久化存储的映射表，它采用<code>行键（Row Key）</code>、<code>列族（Column Family）</code>、<code>列限定符（Column Qualifier）</code>和<code>时间戳（Timestamp）</code>进行索引，每个值都是未经解释的字节数组<code>byte</code>。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBaseData.PNG" alt="HBase数据模型" /><figcaption aria-hidden="true">HBase数据模型</figcaption>
</figure>
<h6 id="表">1.表</h6>
<p><code>HBase</code>采用表来组织数据，表由行和列组成，列划分为若干个列族。</p>
<h6 id="行">2. 行</h6>
<p>每个<code>HBase</code>表都由若干行组成，每个行由<code>行键（Row Key）</code>来标识。访问表中的行有3种方式：</p>
<ul>
<li>通过单个行键访问；</li>
<li>通过一个行键的区间来访问；</li>
<li>全表扫描。</li>
</ul>
<p>在<code>HBase</code>内部，行键保存为字节数组，数据按照行键的字典序排序存储。</p>
<h6 id="列族">3. 列族</h6>
<p><code>HBase</code>表被分组成许多<code>“列族”</code>的集合，它是基本的<strong><u>访问控制单元</u></strong>，列族需要在表创建时就定义好。</p>
<ul>
<li>存储在一个列族当中的所有数据，通常都属于同一种数据类型，具有更高的压缩率。</li>
<li>表中的每个列都归属于某个列族，数据可以被存放到列族的某个列下面。</li>
<li>在<code>HBase</code>中，访问控制、磁盘和内存的使用统计都是在列族层面进行的。</li>
</ul>
<h6 id="列限定符">4. 列限定符</h6>
<p>列族里的数据通过列限定符（或列）来定位。列限定符不用事先定义，也不需要在不同行之间保持一致。列限定符没有数据类型，总被视为字节数组<code>byte</code>。</p>
<h6 id="单元格">5.单元格</h6>
<p>在<code>HBase</code>表中，通过行、列族和列限定符确定一个<code>“单元格”（cell）</code>。单元格中存储的数据没有数据类型，总被视为字节数组<code>byte[]</code>。每个单元格中可以保存一个数据的多个版本，每个版本对应一个不同的时间戳。</p>
<h6 id="时间戳">6. 时间戳</h6>
<p>每个单元格都保存着同一份数据的多个版本，这些版本采用时间戳进行索引。每次对一个单元格执行操作（新建、修改、删除）时，<code>HBase</code>都会隐式地自动生成并存储一个时间戳。时间戳一般是<code>64</code>位整型，可以由用户自己赋值，也可以由 <code>HBase</code>在数据写入时自动赋值。<strong><u>一个单元格的不同版本是根据时间戳降序的顺序进行存储的</u></strong>。</p>
<h5 id="数据坐标">2.2.3 数据坐标</h5>
<p><code>HBase</code>使用坐标来定位表中的数据，<code>HBase</code>中需要根据<code>行键</code>、<code>列族</code>、<code>列限定符</code>和<code>时间戳</code>来确定一个单元格，因此可以视为一个<strong>“四维坐标”</strong>，即<code>[行键，列族，列限定符，时间戳]</code>。</p>
<p>如果把所有坐标看成一个整体，视为<code>“键”</code>，把四维坐标对应的单元格中的数据视为<code>“值”</code>，<code>HBase</code>也可以看成一个键值数据库。</p>
<h5 id="概念视图">2.2.4 概念视图</h5>
<p>在<code>HBase</code>的概念视图中，一个表可以视为一个稀疏、多维的映射关系。在一个<code>HBase</code>表的概念视图中，每个行都包含相同的列族，不需要在每个列族里存储数据，<code>HBase</code>表里面存在很多空的单元格。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBaseLogicVision.PNG" alt="HBase 概念视图" /><figcaption aria-hidden="true">HBase 概念视图</figcaption>
</figure>
<h5 id="物理视图">2.2.5 物理视图</h5>
<p>在物理存储层面，<code>HBase</code>采用了<strong><u>基于列的存储方式</u></strong>，<code>HBase</code>表会按照列族分别存放，属于同一个列族的数据保存在一起，和每个列族一起存放的还包括行键和时间戳。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBasePyhsicalView.PNG" alt="HBase 概念视图" /><figcaption aria-hidden="true">HBase 概念视图</figcaption>
</figure>
<p>在物理视图中，空列不会被存储成<code>null</code>，而是根本就不会被存储，当请求这些空白的单元格的时候会返回<code>null</code>值。</p>
<h5 id="面向列的存储">2.2.6 面向列的存储</h5>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBaseDataStore.PNG" alt="行式存储和列式存储" /><figcaption aria-hidden="true">行式存储和列式存储</figcaption>
</figure>
<h6 id="行式数据库">1. 行式数据库</h6>
<p>行式数据库使用<code>NSM（N-ary Storage Model）</code>存储模型，一个元组（或行）会被连续地存储在磁盘页中，数据是一行一行被存储的。在从磁盘中读取数据时，需要从磁盘中顺序扫描每个元组的完整内容，然后从每个元组中筛选出查询所需要的属性。如果每个元组只有少量属性的值对于查询是有用的，那么<code>NSM</code>就会浪费许多磁盘空间和内存带宽。</p>
<ul>
<li>行式数据库主要适合于小批量的数据处理，如联机事务型数据处理，<code>Oracle</code>和<code>MySQL</code>等关系数据库都属于行式数据库。</li>
</ul>
<h6 id="列式数据库">2. 列式数据库</h6>
<p>列式数据库采用<code>DSM（Decomposition Storage Model）</code>存储模型，目的是最小化无用的<code>I/O</code>。<code>DSM</code>会对关系进行垂直分解，并为每个属性分配一个子关系。一个具有<code>n</code>个属性的关系会被分解成<code>n</code>个子关系，每个子关系单独存储，每个子关系只有当其相应的属性被请求时才会被访问。也就是说，<code>DSM</code>是以关系数据库中的属性或列为单位进行存储，关系中多个元组的同一属性值（或同一列值）会被存储在一起，而一个元组中不同属性值则通常会被分别存放于不同的磁盘页中。</p>
<ul>
<li><p>列式数据库主要适合于批量数据处理和即席查询（Ad-Hoc Query）。优点是：</p>
<ul>
<li>可以降低<code>I/O</code>开销，支持大量并发用户查询，处理速度快；</li>
<li>具有较高的数据压缩比，较传统的行式数据库更加有效果。</li>
</ul>
<p>列式数据库主要用于数据挖掘、决策支持和地理信息系统等<code>查询密集型系统</code>中。</p></li>
<li><p><code>DSM</code>存储模型的缺陷是：</p>
<ul>
<li>执行连接操作时需要昂贵的元组重构代价，因为一个元组的不同属性被分散到不同磁盘页中存储，当需要一个完整的元组时，就要从多个磁盘页中读取相应字段的值来重新组合得到原来的一个元组。</li>
<li>对于联机事务型数据处理而言，需要频繁对一些元组进行修改，如果采用<code>DSM</code>存储模型，就会带来高昂的开销。</li>
</ul>
<p>对于分析型应用而言，一般数据被存储后不会发生修改（如数据仓库），因此不会涉及昂贵的元组重构代价。</p></li>
</ul>
<h4 id="hbase实现原理">2.3 HBase实现原理</h4>
<h5 id="hbase的功能组件">2.3.1 HBase的功能组件</h5>
<p><code>HBase</code>的实现包括3个主要的功能组件：</p>
<ul>
<li><strong>库函数</strong>，链接到每个客户端；</li>
<li>一个<code>Master</code>主服务器。<code>Master</code>负责<strong><u>管理和维护<code>HBase</code>表的分区信息</u></strong>。</li>
<li>多个<code>Region</code>服务器。<code>Region</code>服务器负责<strong><u>存储和维护分配给自己的<code>Region</code>，处理来自客户端的读写请求</u></strong>。</li>
</ul>
<p><code>Master</code>会实时监测集群中的<code>Region</code>服务器，把特定的<code>Region</code>分配到可用的<code>Region</code>服务器上，并确保整个集群内部不同<code>Region</code>服务器之间的<strong><u>负载均衡</u></strong>，当某个<code>Region</code>服务器因出现故障而失效时，<code>Master</code>会把该故障服务器上存储的<code>Region</code>重新分配给其他可用的<code>Region</code>服务器。<code>Master</code>还处理模式变化，如表和列族的创建。</p>
<p>客户端在获得<code>Region</code>的存储位置信息后，直接从<code>Region</code>服务器上读取数据。<code>HBase</code>客户端并借助于<code>Zookeeper</code>来获得<code>Region</code>的位置信息的，所以<strong><u>大多数客户端从来不和主服务器Master通信，这种设计方式使Master的负载很小</u></strong>。</p>
<h5 id="表和region">2.3.2 表和Region</h5>
<p>对于每个<code>HBase</code>表而言，表中的行是根据行键的值的字典序进行维护的，表中包含的行的数量可能非常庞大，无法存储在一台机器上。因此，需要<strong><u>根据行键的值对表中的行进行分区</u></strong>，每个行区间构成一个分区，被称为<code>“ Region”</code>，包含了位于某个值域区间内的所有数据，这些<code>Region</code>会被分发到不同的<code>Region</code>服务器上。</p>
<ul>
<li>初始时，每个表只包含一个<code>Region</code>，随着数据的不断插入，<code>Region</code>会持续增大，当一个<code>Region</code>中包含的行数量达到一个阈值时，就会被自动等分成两个新的<code>Region</code>。</li>
<li>每个<code>Region</code>的默认大小是<code>100MB</code>到<code>200MB</code>，是HBase中<strong><u>负载均衡和数据分发的基本单位</u></strong>。同一个<code>Region</code>是不会被拆分到多个<code>Region</code>服务器上的。每个<code>Region</code>服务器负责管理一个<code>Region</code>集合。</li>
</ul>
<h5 id="region的定位">2.3.3 Region的定位</h5>
<p>每个<code>Region</code>都有一个<code>RegionID</code>来标识它的唯一性，一个<code>Region</code>标识符就可以表示成<code>"表名+开始主键+RegionID"</code>。</p>
<p>为了定位每个<code>Region</code>所在的位置，可以构建一张映射表，映射表的每个条目（或每行）包含两项内容：</p>
<ul>
<li><code>Region</code>标识符；</li>
<li><code>Region</code>服务器标识。</li>
</ul>
<p>这个条目就表示<code>Region</code>和<code>Region</code>服务器之间的对应关系。这个映射表包含了关于<code>Region</code>的元数据，也被称为<code>“元数据表”</code>，又名<code>“.META.表”</code>。</p>
<p>当一个<code>HBase</code>表中的<code>Region</code>数量非常庞大的时候，<code>.META.表</code>也会被分裂成多个<code>Region</code>，为了定位这些<code>Region</code>，就需要再构建一个新的映射表，记录所有元数据的具体位置，这个新的映射表就是<code>“根数据表”</code>，又名<code>“-ROOT-表”</code>。</p>
<ul>
<li><code>-ROOT-表</code>是不能被分割的，<strong><u>永远只存在一个<code>Region</code>用于存放<code>-ROOT-表</code></u></strong>，<code>Master</code>主服务器永远知道它的位置。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBaseRegion.PNG" alt="Region的定位" /><figcaption aria-hidden="true">Region的定位</figcaption>
</figure>
<ul>
<li><code>Zookeeper</code>文件。记录了<code>-ROOT-表</code>的位置信息；</li>
<li>-<code>ROOT-表</code>。记录了<code>.META.表</code>的<code>Region</code>位置信息，</li>
<li><code>.META.表</code>。记录了用户数据表的<code>Region</code>位置信息，META表可以有多个<code>Region</code>。为了加快访问速度，<code>.META.表</code>的全部<code>Region</code>都会被保存在内存中。</li>
</ul>
<p>客户端访问用户数据时：</p>
<ul>
<li>首先访问<code>Zookeeper</code>，获取-<code>ROOT-表</code>的位置信息；</li>
<li>然后访问-<code>ROOT-表</code>，获得<code>.META.表</code>的信息；</li>
<li>接着访问<code>.META.表</code>，找到所需的<code>Region</code>具体位置；</li>
<li>最后到该<code>Region</code>服务器读取数据。</li>
</ul>
<p>为了加速寻址过程，一般会在客户端做缓存，把查询过的位置信息缓存起来，以后访问相同的数据时，就可以直接从客户端缓存中获取<code>Region</code>的位置信息。</p>
<ul>
<li>随着<code>HBase</code>中表的不断更新，客户端缓存的<code>Region</code>位置信息可能会失效，客户端需要访问数据时，从缓存中获取<code>Region</code>位置信息却发现不存在时，会判断出缓存失效，这时需要再次经历的<code>“三级寻址”</code>过程，重新获取最新的 <code>Region</code>位置信息去访问数据，并用最新的<code>Region</code>位置信息替换缓存中失效的信息。</li>
</ul>
<h4 id="hbase运行机制">2.4 HBase运行机制</h4>
<h5 id="hbase系统架构">2.4.1 HBase系统架构</h5>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBaseStructure.PNG" alt="HBase系统架构" /><figcaption aria-hidden="true">HBase系统架构</figcaption>
</figure>
<h6 id="客户端-1">1. 客户端</h6>
<p><code>HBase</code>客户端使用<code>HBase</code>的<code>RPC</code>机制与<code>Master</code>和<code>Region</code>服务器进行通信。</p>
<ul>
<li>对于管理类操作，客户端与<code>Master</code>进行<code>RPC</code>；</li>
<li>对于数据读写类操作，客户端与<code>Region</code>服务器进行<code>RPC</code>。</li>
</ul>
<h6 id="zookeeper服务器">2. Zookeeper服务器</h6>
<p><code>Zookeeper</code>服务器<strong><u>并非一台单一的机器，可能是由多台机器构成的集群</u></strong>来提供稳定可靠的协同服务。</p>
<ul>
<li>每个<code>Region</code>服务器都需要到<code>Zookeeper</code>中进行注册，<code>Zookeeper</code>会实时监控每个<code>Region</code>服务器的状态并通知给<code>Master</code>，这样<code>Master</code>就可以通过<code>Zookeeper</code>随时感知到各个<code>Region</code>服务器的工作状态。</li>
<li><code>HBase</code>中可以启动多个<code>Master</code>，但是<code>Zookeeper</code>可以<strong><u>帮助选举出一个Master作为集群的总管，并保证在任何时刻总有唯一一个 Master在运行</u></strong>，可以避免Master的<code>“单点失效”</code>问题。</li>
<li><code>Zookeeper</code>中保存了<code>-ROOT-表</code>的地址和<code>Master</code>的地址。当一个客户端从<code>Zookeeper</code>服务器上拿到-<code>ROOT-表</code>的地址后，就可以进行<code>“三级寻址”</code>，不用再连接主服务器<code>Master</code>。</li>
</ul>
<h6 id="master">3. Master</h6>
<p>主服务器<code>Master</code>主要负责<strong><u>表和<code>Region</code>的管理工作</u></strong>。</p>
<ul>
<li>管理用户对表的增加、删除、修改、查询等操作。</li>
<li>实现不同Region服务器之间的负载均衡。</li>
<li>在Region分裂或合并后，负责重新调整Region的分布。</li>
<li>对发生故障失效的<code>Region</code>服务器上的<code>Region</code>进行迁移。</li>
</ul>
<p><code>Master</code>仅仅维护着表和<code>Region</code>的元数据信息，因此负载很低。</p>
<h6 id="region服务器">4. Region服务器</h6>
<p><code>Region</code>服务器是<code>HBase</code>中最核心的模块，负责<strong><u>维护分配给自己的Region，并响应用户的读写请求</u></strong>。<code>HBase</code>一般采用<code>HDFS</code>作为底层存储文件系统，因此<code>Region</code>服务器需要向<code>HDFS</code>文件系统中读写数据。</p>
<h5 id="region服务器的工作原理">2.4.2 Region服务器的工作原理</h5>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/HBaseReadWrite.PNG" alt="Region服务器的工作原理" /><figcaption aria-hidden="true">Region服务器的工作原理</figcaption>
</figure>
<ul>
<li><p><code>Region</code>服务器内部管理了一系列<code>Region</code>对象和一个<code>HLog</code>文件，其中<code>HLog</code>是磁盘上面的记录文件，它记录着所有的更新操作。</p></li>
<li><p>每个<code>Region</code>对象又是由多个<code>Store</code>组成的，每个<code>Store</code>对应了表中的一个列族的存储。</p></li>
<li><p>每个<code>Store</code>又包含一个 <code>MemStore</code>和若干个<code>StoreFile</code>，<code>MemStore</code>是在内存中的缓存，保存最近更新的数据； <code>StoreFile</code>是磁盘中的文件，这些文件都是<strong><u>B树结构</u></strong>的，方便快速读取。</p></li>
<li><p><code>StoreFile</code>在底层的实现方式是<code>HDFS</code>文件系统的<code>Hfile</code>，<code>HFile</code>的数据块通常采用压缩方式存储，压缩之后可以大大减少网络<code>I/O</code>和磁盘<code>I/O</code>。</p></li>
</ul>
<h6 id="用户读写数据的过程">1. 用户读写数据的过程</h6>
<p>当用户写入数据时，会被分配到相应的<code>Region</code>服务器去执行操作。</p>
<ul>
<li>用户数据首先被写入到<code>MemStore</code>和<code>HLog</code>中；</li>
<li>当操作写入<code>HLog</code>之后，<code>commit()</code>调用才会将其返回给客户端。</li>
</ul>
<p>当用户读取数据时：</p>
<ul>
<li><code>Region</code>服务器会首先访问<code>MemStore</code>缓存；</li>
<li>如果数据不在缓存中，才会到磁盘上面的<code>StoreFile</code>中去寻找。</li>
</ul>
<h6 id="缓存的刷新">2.缓存的刷新</h6>
<p><code>MemStore</code>缓存的容量有限，系统会周期性地调用<code>Region.flushcache()</code>把<code>MemStore</code>缓存里面的内容写到磁盘的 <code>StoreFile</code>文件中，清空缓存，并在<code>HLog</code>文件中写入一个标记，用来表示缓存中的内容已经被写入<code>StoreFile</code>文件中。每次缓存刷新操作都会在磁盘上生成一个新的<code>StoreFile</code>文件，因此每个<code>Store</code>会包含多个<code>StoreFile</code>文件。</p>
<p>每个<code>Region</code>服务器在启动时，都会检查自己的<code>HLog</code>文件，确认最近一次执行缓存刷新操作之后是否发生新的写入操作。</p>
<ul>
<li>如果没有更新，说明所有数据已经被永久保存到磁盘的<code>StoreFile</code>文件中；</li>
<li>如果发现更新，就先把这些更新写入<code>MemStore</code>，然后再刷新缓存，写入到磁盘的<code>StoreFile</code>文件中。</li>
<li>最后，删除旧的<code>HLog</code>文件，并开始为用户提供数据访问服务。</li>
</ul>
<h6 id="storefile的合并">3. StoreFile的合并</h6>
<p>系统中的每个<code>Store</code>会存在多个<code>StoreFile</code>文件，当需要访问某个<code>Store</code>中的某个值时，就必须查找所有<code>StoreFile</code>文件，非常耗费时间。为了减少查找时间，系统会调用<code>Store.compact()</code>把多个<code>StoreFile</code>文件合并成一个大文件。</p>
<h5 id="store工作原理">2.4.3 Store工作原理</h5>
<p><code>Store</code>则是<code>Region</code>服务器的核心。每个<code>Store</code>对应了表中的一个列族的存储。每个<code>Store</code>包含一个<code>MemStore</code>缓存和若干个<code>StoreFile</code>文件。</p>
<ul>
<li><code>MemStore</code>是排序的内存缓冲区；</li>
<li>随着<code>StoreFile</code>文件数量的不断增加，到达阈值时就会触发文件合并操作；</li>
<li>当单个<code>StoreFile</code>文件大小超过一定阈值时，就会触发文件分裂操作。</li>
</ul>
<h5 id="hlog工作原理">2.4.4 HLog工作原理</h5>
<p><code>HBase</code>采用<code>HLog</code>来保证系统发生故障时能够恢复到正确的状态。</p>
<p><code>HLog</code>文件是一种<code>预写式日志（ Write Ahead Log）</code>，即<strong><u>用户更新数据必须首先被记入日志后才能写入 MemStore缓存，并且直到MemStore缓存内容对应的日志已经被写入磁盘之后，该缓存内容才会被刷新写入磁盘。</u></strong></p>
<p>当某个<code>Region</code>服务器发生故障时，<code>Zookeeper</code>会通知<code>Master</code>：</p>
<ul>
<li><code>Master</code>首先会处理该故障<code>Region</code>服务器上面遗留的<code>HLog</code>文件，其中包含了来自多个<code>Region</code>对象的日志记录。</li>
<li>系统会根据每条日志记录所属的<code>Region</code>对象对<code>HLog</code>数据进行拆分，分别放到相应<code>Region</code>对象的目录下，然后再将失效的<code>Region</code>重新分配到可用的<code>Region</code>服务器中。</li>
<li><code>Region</code>服务器领取到分配给自己的<code>Region</code>对象以及与之相关的<code>HLog</code>日志记录以后，会重新做一遍日志记录中的各种操作，把日志记录中的数据写入<code>MemStore</code>缓存，然后刷新到磁盘的<code>StoreFile</code>文件中，完成数据恢复。</li>
</ul>
<h4 id="hbase实践">2.5 HBase实践</h4>
<p>需要注意，<code>Hadoop</code>安装以后，只包含<code>HDFS</code>和<code>MapReduce</code>，并不包含<code>HBase</code>。关于<code>HBase</code>的常用<code>shell</code>命令和编程<code>API</code>可以在使用时查看文档。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--29. Divide Two Integers</title>
    <url>/2019/04/22/LeetCode--29-Divide-Two-Integers.html</url>
    <content><![CDATA[<h3 id="一问题描述">一、问题描述</h3>
<blockquote>
<p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. <a id="more"></a> Return the quotient after dividing <strong>dividend</strong> by <strong>divisor</strong>.</p>
</blockquote>
<blockquote>
<p>The integer division should truncate toward zero.</p>
</blockquote>
<p><strong>Example 1:</strong> &gt; Input: dividend = 10, divisor = 3 &gt; Output: 3</p>
<p><strong>Example 2:</strong> &gt; Input: dividend = 7, divisor = -3 &gt; Output: -2</p>
<p><strong>Note :</strong> &gt; - Both dividend and divisor will be 32-bit signed integers. &gt; - The divisor will never be 0. &gt; - Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.</p>
<h3 id="二解题思路">二、解题思路</h3>
<p>题目要求实现除法，并且不能使用乘法、除法和模这些操作。这就意味着我们只能使用加减或者位运算，来实现除法的过程。</p>
<p>第一种思路是，用被除数减去除数，知道被除数小于除数时，返回减法进行的次数。</p>
<p>这需要先对输入的两个数进行处理，若除数或被除数是负数，不能直接进行减法，需要先取他们的绝对值。但这是会出现越界的情况，如-2^31的绝对值就越界了，int不能存储。但是题目要求的是只能用32-bit的环境，所以不能用long来解决了，这里想到的是使用unsigned int来保存绝对值结果。这时又碰到了另一个问题，abs()函数也无法处理越界的数，即求abs(-2^31)时会报错，解决方法是使用labs()函数，或者重写一个abs()，可以实现需要的_abs()如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> temp = value;</span><br><span class="line">    <span class="keyword">return</span> (temp &gt; <span class="number">0x80000000</span>) ? -value : temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 除此之外，还需要单独判断一种结果溢出的情况，也就是<code>dividend = -2^31，divisor = -1</code> 的情况，这时直接输出INT_MAX即可。</p>
<p>这种方法效率太低，最后超时了。在这种方法基础上可以进行优化。可以加入位运算，如果被除数大于除数，找到小于被除数的，且是除数2^n的最大的数，被除数减去该数，结果加上n后，重复上述操作，直到被除数小于除数为止。这里寻找这个符合条件的数时，就可以运用位运算。</p>
<p>还有一种比较有意思的解法，就是运用对数求解。首先分别求出被除数和除数的对数，算出它们的差后，将其作为指数，求 e 的指数结果。公式如下： a/b = e^(log(a) - log(b)) 但是计算对数时，应该使用了除法/，所以可能违反了条件。</p>
<p>参考： <a href="https://blog.csdn.net/zephyr_be_brave/article/details/8722397" target="_blank" rel="noopener" title="C++自己实现abs">C++自己实现abs</a> <a href="https://leetcode.com/problems/divide-two-integers/discuss/13407/C%2B%2B-bit-manipulations" target="_blank" rel="noopener" title="C++ bit manipulations">C++ bit manipulations</a> <a href="https://leetcode.com/problems/divide-two-integers/discuss/13460/6-line-solution-C%2B%2B" target="_blank" rel="noopener" title="6 line solution C++">6 line solution C++</a></p>
<h3 id="三代码">三、代码</h3>
<h4 id="只用加减法超时">只用加减法（超时）</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divd = __abs(dividend);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divr = __abs(divisor);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(divd &gt;= divr)</span><br><span class="line">        &#123;</span><br><span class="line">            divd -= divr;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> copyed_value = value;</span><br><span class="line">        <span class="keyword">return</span> (copyed_value &gt; <span class="number">0x80000000</span>) ? -value : copyed_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="加入位运算">加入位运算</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divd = __abs(dividend);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divr = __abs(divisor);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(divd &gt;= divr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> temp = divr; <span class="keyword">unsigned</span> m = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>((temp &lt;&lt; <span class="number">1</span>) &lt;= divd &amp;&amp; temp != <span class="number">2147483648</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            divd -= temp;</span><br><span class="line">            result += m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> copyed_value = value;</span><br><span class="line">        <span class="keyword">return</span> (copyed_value &gt; <span class="number">0x80000000</span>) ? -value : copyed_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="对数求解">对数求解</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sign = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>)? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divd = __abs(dividend);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divr = __abs(divisor);</span><br><span class="line">        </span><br><span class="line">        result = <span class="built_in">exp</span>(<span class="built_in">log</span>(divd)-<span class="built_in">log</span>(divr));</span><br><span class="line">        <span class="keyword">return</span> sign * result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __abs(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> copyed_value = value;</span><br><span class="line">        <span class="keyword">return</span> (copyed_value &gt; <span class="number">0x80000000</span>) ? -value : copyed_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构和算法|各种排序算法原理及实现]</title>
    <url>/2021/06/30/Data_structure_and_algorithm_sorting_algorithm.html</url>
    <content><![CDATA[<h3 id="排序问题的形式定义">1. 排序问题的形式定义</h3>
<p>可以将<strong>排序问题</strong>形式化定义为如下：</p>
<blockquote>
<p><strong>输入</strong>: <span class="math inline">\(n\)</span> 个数的一个序列 <span class="math inline">\(\left\langle a_{1}, a_{2}, \cdots, a_{n}\right\rangle\)</span>。 <strong>输出</strong>: 输入序列的一个排列 <span class="math inline">\(\left\langle a_{1}^{\prime}, a_{2}^{\prime}, \cdots, a_{n}^{\prime}\right\rangle\)</span>, 满足 <span class="math inline">\(a_{1}^{\prime} \leqslant a_{2}^{\prime} \leqslant \cdots \leqslant a_{n}^{\prime}\)</span> 。</p>
</blockquote>
<p>希望排序的数也称为<strong>关键词</strong>。</p>
<a id="more"></a>
<h3 id="排序算法">2. 排序算法</h3>
<h4 id="插入排序">2.1 插入排序</h4>
<h5 id="插入排序算法介绍">2.1.1 插入排序算法介绍</h5>
<p>对于少量元素的排序，插入排序是一种有效的算法。插入排序的伪代码如下，输入是数组<span class="math inline">\(A[1.. n]\)</span>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line">for j = 2 to A.length</span><br><span class="line">	key = A[j]</span><br><span class="line">	// Insert A[j] into the sorted sequence A[1 .. j-1].</span><br><span class="line">	i = j - 1</span><br><span class="line">	while i &gt; 0 and A[i] &gt; key</span><br><span class="line">		A[ i + i ] = A[i]</span><br><span class="line">		i = i - 1</span><br><span class="line">	A[ i + 1 ] = key</span><br></pre></td></tr></table></figure>
<h5 id="循环不变式与插入排序的正确性">2.1.2 循环不变式与插入排序的正确性</h5>
<p>下图式对数组<span class="math inline">\(A=&lt;5, 2, 4, 6, 1, 3&gt;\)</span>的插入排序：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/sort/insertSortExample.PNG" alt="插入排序示例" /><figcaption aria-hidden="true">插入排序示例</figcaption>
</figure>
<p>在<code>for</code>循环每次迭代开始时，子数组<span class="math inline">\(A[1.. j-1]\)</span>由原来在<span class="math inline">\(A[1.. j-1]\)</span>中的元素组成，但已按顺序排列，即<strong><code>循环不变式</code></strong>。<strong><code>循环不变式</code></strong>用于帮助理解算法地正确性。关于循环不变式需要证明三条性质：</p>
<ul>
<li><strong>初始化</strong>：循环的第一次迭代之前，它为真。</li>
<li><strong>保持</strong>：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。</li>
<li><strong>终止</strong>：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。</li>
</ul>
<h5 id="插入排序算法的分析">2.1.3 插入排序算法的分析</h5>
<p>这里是基于<strong>算法导论</strong>中算法分析给出的计算方法，做一个示例：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/sort/insertSortTimeAnalysis.PNG" alt="插入排序运行时间分析" /><figcaption aria-hidden="true">插入排序运行时间分析</figcaption>
</figure>
<p>算法运行时间是职校每条语句的执行时间之和： <span class="math display">\[
T(n)=c_{1} n+c_{2}(n-1)+c_{4}(n-1)+c_{5} \sum_{j=2}^{n} t_{j}+c_{6} \sum_{j=2}^{n}\left(t_{j}-1\right)+c_{7} \sum_{j=2}^{n}\left(t_{j}-1\right)+c_{8}(n-1)
\]</span> 当输入数组已经排好序时，出现最佳情况，使得<span class="math inline">\(t_j=1\)</span>，则最佳情况下的运行时间为： <span class="math display">\[
\begin{aligned}
T(n) &amp;=c_{1} n+c_{2}(n-1)+c_{4}(n-1)+c_{5}(n-1)+c_{8}(n-1) \\
&amp;=\left(c_{1}+c_{2}+c_{4}+c_{5}+c_{8}\right) n-\left(c_{2}+c_{4}+c_{5}+c_{8}\right)
\end{aligned}
\]</span> 可以将其表示为<span class="math inline">\(an+b\)</span>，因此它是<span class="math inline">\(n\)</span>的<strong>线性函数</strong>。若输出数组是反向排序，即按递减排好序，此时出现最坏情况，有<span class="math inline">\(t_j=j\)</span>，由于有： <span class="math display">\[
\begin{aligned}
&amp;\sum_{j=2}^{n} j=\frac{n(n+1)}{2}-1 \\
&amp;\sum_{j=2}^{n}(j-1)=\frac{n(n-1)}{2}
\end{aligned}
\]</span> 最坏情况下，插入排序运行时间为： <span class="math display">\[
\begin{aligned}
T(n)=&amp; c_{1} n+c_{2}(n-1)+c_{4}(n-1)+c_{5}\left(\frac{n(n+1)}{2}-1\right) \\
&amp;+c_{6}\left(\frac{n(n-1)}{2}\right)+c_{7}\left(\frac{n(n-1)}{2}\right)+c_{8}(n-1) \\
=&amp;\left(\frac{c_{5}}{2}+\frac{c_{6}}{2}+\frac{c_{7}}{2}\right) n^{2}+\left(c_{1}+c_{2}+c_{4}+\frac{c_{5}}{2}-\frac{c_{6}}{2}-\frac{c_{7}}{2}+c_{8}\right) n \\
&amp;-\left(c_{2}+c_{4}+c_{5}+c_{8}\right)
\end{aligned}
\]</span> 可以将其表示为<span class="math inline">\(an^2+bn+c\)</span>，因此它是<span class="math inline">\(n\)</span>的<strong>二次函数</strong>。一般只求<strong>最坏情况运行时间</strong>，记插入排序具有最坏情况运行时间<span class="math inline">\(O(n^2)\)</span>。</p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>数据结构和算法</tag>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构和算法|动态规划]</title>
    <url>/2021/07/22/Data_structure_and_algorithm_dynamic_programming.html</url>
    <content><![CDATA[<h3 id="动态规划概述">1. 动态规划概述</h3>
<h4 id="简介">1.1 简介</h4>
<p>动态规划（<code>dynamic programming</code>）可以理解为是对递归算法的一种优化，是R.E.Bellman等人在研究多阶段决策过程(<code>multistep decision process</code>)的优化问题时，提出的最优化原理(<code>principle of optimality</code>)，即把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系逐个求解。</p>
<blockquote>
<p><code>dynamic programming</code>的名字是为了<a href="https://www.zhihu.com/question/39948290/answer/83920614" target="_blank" rel="noopener">规避军方的厌恶</a></p>
</blockquote>
<a id="more"></a>
<h4 id="基本思想">1.2 基本思想</h4>
<p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。动态规划过程是：</p>
<blockquote>
<p><strong><u>每次决策依赖于当前状态，又随即引起状态的转移</u></strong>。</p>
</blockquote>
<p>动态规划将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。能采用动态规划求解的问题的一般要具有3个性质：</p>
<ul>
<li><strong>最优化原理</strong>：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</li>
<li><strong>无后效性</strong>：即某阶段状态一旦确定，就不受这个状态以后决策的影响。</li>
<li><strong>有重叠子问题</strong>：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。这<strong><u>并非必要条件</u></strong>，但满足这个条件动态规划才能发挥出较大的优势。</li>
</ul>
<h4 id="求解的基本步骤">1.3 求解的基本步骤</h4>
<p>动态规划一般要经历以下几个步骤：</p>
<ul>
<li><strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。</li>
<li><strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的不同的状态表示出来。确定<code>状态</code>需要满足<strong>最优化原理</strong>和<strong>无后效性</strong>。</li>
<li><strong>确定决策并写出状态转移方程</strong>：根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</li>
<li><strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</li>
</ul>
<p>可以看出，动态规划最主要的两个核心部分是：<code>DP 状态</code>和<code>DP 转移方程</code>。整个求解过程可以用一个<strong><u>最优决策表</u></strong>来描述：</p>
<ul>
<li><code>最优决策表</code>是一个<strong>二维表</strong>，其中<strong><u>行表示决策的阶段</u></strong>，列表示<strong><u>问题状态</u></strong>，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值；</li>
<li>填表的过程就是根据递推关系，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</li>
</ul>
<h4 id="动态规划与递归">1.4 动态规划与递归</h4>
<p>动态规划是<strong>自底向上</strong>，递归树是<strong>自顶向下</strong>。</p>
<ul>
<li><p><strong>自顶向下</strong>的递归。从规模较大的原问题比如说 <span class="math inline">\(f(n)\)</span>，向下逐渐分解规模直到边界条件<span class="math inline">\(f(1)\)</span>触底，然后逐层返回答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="keyword">return</span> Fibonacci1(n-<span class="number">1</span>) + Fibonacci1(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>自底向上</strong>的动态规划。从问题规模最小的<span class="math inline">\(f(1)\)</span>，直到推到得到原问题答案<span class="math inline">\(f(n)\)</span>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[N + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="变体">1.4 变体</h4>
<h5 id="数位dp">1.4.1 <code>数位dp</code></h5>
<p>可以看这个视频：<a href="https://www.bilibili.com/video/BV1ip4y1v7zw?from=search&amp;seid=13099671920328002016" target="_blank" rel="noopener">数位DP</a>。数位DP解决的问题是：</p>
<blockquote>
<p>求出在给定区间<span class="math inline">\([A,B]\)</span>内，符合条件<span class="math inline">\(f(i)\)</span>的数<span class="math inline">\(i\)</span>的个数。条件<span class="math inline">\(f(i)\)</span>一般与数的大小无关，而与数的组成有关由于数是按位dp，<strong>数的大小对复杂度的影响很小</strong>。</p>
</blockquote>
<p>暴力解法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=A; i&lt;=B; i++)</span><br><span class="line">	<span class="keyword">if</span>(f(i)) ans++;</span><br></pre></td></tr></table></figure>
<p>引入数位的概念，使得新的枚举方式满足dp的性质，然后记忆化搜索。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/dp/numBitBP.PNG" alt="数位搜索" /><figcaption aria-hidden="true">数位搜索</figcaption>
</figure>
<p>从起点向下搜索，到最底层得到方案数，一层一层向上返回答案并累加，最后从搜索起点得到最终答案。主要涉及以下参数：</p>
<ul>
<li>数位dp基本的量数字位数<code>pos</code>，记录答案的<code>st</code>；</li>
<li>最高位限制<code>limit</code>。</li>
<li>判断<strong>前导0</strong>的标记<code>lead</code>。部分题目中，前导0会影响答案结果，需要进行区分。</li>
<li>经常要比较当前位和前一位或前几位的关系，一般在<code>dfs()</code>中也要记录前一位或前几位数<code>pre</code>。</li>
<li>更多参量以区分状态，视题意而定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">long</span> dp[<span class="number">20</span>][state];<span class="comment">//不同题目状态不同</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="comment">/*其他state变量*/</span>,<span class="keyword">boolean</span> lead<span class="comment">/*前导零*/</span>,<span class="keyword">boolean</span> limit<span class="comment">/*数位上界变量*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归边界，按位枚举最低位是0，pos &lt; 0 说明这个数枚举完了</span></span><br><span class="line">    <span class="comment">// 这里一般返回1，表示枚举的这个数是合法的</span></span><br><span class="line">    <span class="comment">// 也可能返回别的值</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记忆化</span></span><br><span class="line">    <span class="comment">// !limit 代表非边界状态，无需特殊处理</span></span><br><span class="line">    <span class="comment">// dp[pos][state] != -1 代表已经遍历过了</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state] != -<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> dp[pos][state];</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//根据limit判断枚举的上界up</span></span><br><span class="line">    <span class="keyword">int</span> up = limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">long</span> ans=<span class="number">0</span>; <span class="comment">// 开始计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up;i++) &#123; <span class="comment">//枚举，然后把不同情况的个数加到ans就可以了</span></span><br><span class="line">        <span class="keyword">if</span>() ...</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>()...</span><br><span class="line">        ans+=dfs(pos-<span class="number">1</span>,<span class="comment">/*状态转移*/</span>,lead &amp;&amp; i==<span class="number">0</span>,limit &amp;&amp; i==a[pos]) <span class="comment">//最后两个变量传参都是这样写的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算完，记录状态</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead) dp[pos][state]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123; <span class="comment">//把数位都分解出来</span></span><br><span class="line">        a[pos++] = x % <span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// //刚开始最高位都是有限制并且有前导零的</span></span><br><span class="line">    <span class="keyword">return</span> dfs(pos-<span class="number">1</span><span class="comment">/*从最高位开始枚举*/</span>,<span class="comment">/*一系列状态 */</span>,<span class="keyword">true</span>,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="背包问题">1.4.2 <code>0/1</code>背包问题</h5>
<blockquote>
<p>有一个容量有限的背包，总容量为<code>c</code>，有<code>n</code>个可待选择的物品，<strong><u>每个物品只有一件</u></strong>，它们都有各自的重量和价值，需要从中选择合适的组合来使得背包中的物品总价值最大。</p>
</blockquote>
<p>背包问题抽象为寻找组合<span class="math inline">\(\{x_1,x_2,x_3,...,x_n\}\)</span>​​​ （其中<span class="math inline">\(x_i\)</span>​​​取<code>0</code>或<code>1</code>，表示第<span class="math inline">\(i\)</span>个物品取或者不取），<span class="math inline">\(v_i\)</span>代表第<span class="math inline">\(i\)</span>个物品的价值，<span class="math inline">\(w_i\)</span>代表第<span class="math inline">\(i\)</span>个物品的重量，总物品数为<span class="math inline">\(n\)</span>，背包容量为<span class="math inline">\(c\)</span>。问题即求解： <span class="math display">\[
\textbf{目标}：&amp; max\{ x_1v_1 + x_2v_2 + x_3v_3 + ... + x_nv_n \} \\
\textbf{约束条件}：&amp; x_1w_1 + x_2w_2 + x_3w_3 + ... + x_nw_n &lt; c
\]</span> 证明最优化原理：</p>
<blockquote>
<p>假设<span class="math inline">\((x_1，x_2，…，x_n)\)</span>是<span class="math inline">\(0/1\)</span>背包问题的最优解，则有<span class="math inline">\((x_2，x_3，…，x_n)\)</span>是其子问题的最优解，假设<span class="math inline">\((y_2，y_3，…，y_n)\)</span>是上述问题的子问题最优解，则有<span class="math inline">\((v_2y_2+v_3y_3+…+v_ny_n)+v_1x_1 &gt; (v_2x_2+v_3x_3+…+v_nx_n)+v_1x_1\)</span>。说明<span class="math inline">\((X_1，Y_2，Y_3，…，Y_n)\)</span>才是该<span class="math inline">\(0/1\)</span>背包问题的最优解，这与最开始的假设相矛盾，故满足<code>最优性原理</code>。</p>
</blockquote>
<p>用<span class="math inline">\(dp[i][j]\)</span>表示第<span class="math inline">\(i\)</span>件物品放入容量为<span class="math inline">\(j\)</span>的背包所得的最大价值，则状态转移方程可以推出如下： <span class="math display">\[
dp[i][j]=max\{dp[i-1][j-v[i]]+c[i],dp[i-1][j]\};、
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) <span class="comment">//枚举物品  &#123;  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= C; j++) &#123; <span class="comment">//枚举背包容量    </span></span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j];  </span><br><span class="line">        <span class="comment">// 能装下物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= v[i]) &#123;</span><br><span class="line">            <span class="comment">// 选择最优装法</span></span><br><span class="line">            f[i][j] = Max(f[i - <span class="number">1</span>][j],f[i - <span class="number">1</span>][j - v[i]] + c[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数的划分">1.4.2 数的划分</h5>
<p>将整数<code>n</code>分成<code>k</code>份，且每份不能为空，任意两种分法不能相同（不考虑顺序）。</p>
<blockquote>
<p>例如：<code>n=7, k=3</code>，下面三种分法被认为是相同的：<code>5,1,1; 1, 1, 5; 1, 5, 1</code>。</p>
</blockquote>
<p>问有多少种不同的分法。</p>
<p>用<span class="math inline">\(dp[i][j]\)</span>表示将整数 <span class="math inline">\(i\)</span> 划分为 <span class="math inline">\(j\)</span> 份的方案数。由于每份不为空，需要先拿出<span class="math inline">\(j\)</span>个<span class="math inline">\(1\)</span>放到<span class="math inline">\(j\)</span>份上，此时剩下<span class="math inline">\(i-j\)</span>个数，可以将其放到<span class="math inline">\(1 \to j\)</span>份中，将其累加集可得到<span class="math inline">\(dp[i][j]\)</span>。所以<span class="math inline">\(dp[i][j]\)</span>的动态转移方程为： <span class="math display">\[
dp[i][j] = dp[i-j][1]+dp[i-j][2]+...+dp[i-j][j]
\]</span> 可以进行规约： <span class="math display">\[
dp[i-1,j-1]=dp[(i-1)-(j-1)][1]+dp[(i-1)-(j-1)][2]+...+dp[(i-1)-(j-1)][j-1]
\\ = dp[i-j][1]+dp[i-j][2]+...+dp[i-j][j-1]
\]</span> 合并两个公式得到： <span class="math display">\[
dp[i][j] = dp[i-j][j] + dp[i-1][j-1]
\]</span> 也可以将这个转移方程理解为，分割方法可以分为两类：</p>
<ul>
<li>第一类：<code>n</code>份中不包含 <code>1</code> 的分法，为保证每份都 <code>&gt;= 2</code>，可以先拿出 <code>k</code> 个 <code>1</code> 分到每一份，然后再把剩下的 <code>n-k</code> 分成 <code>k</code> 份即可，分法有： <code>dp[n-k][k]</code></li>
<li>第二类: <code>n</code> 份中<strong><u>至少有一份</u></strong>为 <code>1</code> 的分法，可以先那出一个 <code>1</code> 作为单独的<code>1</code>份，剩下的 <code>n-1</code> 再分成 <code>k-1</code> 份即可，分法有：<code>dp[n-1][k-1]</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">spiltNums</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][k+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对于dp[0][0]作特殊处理（为了后面的动态转移方程能够起作用）</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="comment">//j的范围是1~k（不能超过需要划分的份数）</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">			dp[i][j] = dp[i-j][j] + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划题解">2. 动态规划题解</h3>
<h4 id="剑指offer-10-斐波那契数列">2.1 剑指offer-10 斐波那契数列</h4>
<p>斐波那契数列的标准公式为： <span class="math display">\[
F(1)=1;F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)
\]</span></p>
<p>可以看出定义即为转移方程的定义，可以很容易写出其动态规划实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] fibDP = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        fibDP[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        fibDP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            fibDP[i] = (fibDP[i-<span class="number">1</span>] + fibDP[i-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fibDP[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指offer-10-跳台阶">2.2 剑指offer-10 跳台阶</h4>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p>
</blockquote>
<p>实际上是斐波那契数列的变种，求第<span class="math inline">\(n\)</span>个台阶的跳法时，需要之前的两个状态：</p>
<ul>
<li>上一步跳<code>1</code>级台阶，求跳到<code>n-1</code>级台阶的方法；</li>
<li>上一步跳<code>2</code>级台阶，求跳到<code>n-2</code>级台阶的方法；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n== <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] numWays = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        numWays[<span class="number">1</span>] = <span class="number">1</span>; numWays[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            numWays[i] = (numWays[i-<span class="number">1</span>] + numWays[i-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numWays[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指offer-13-机器人的运动范围">2.3 剑指offer-13 机器人的运动范围</h4>
<blockquote>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
</blockquote>
<p>搜索的过程中搜索方向可以缩减为向右和向下，由可达解分析机器人可 <strong>仅通过向右和向下移动，访问所有可达解</strong> 。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ13/Reachable.PNG" alt="可达解分析" /><figcaption aria-hidden="true">可达解分析</figcaption>
</figure>
<p>所以 <code>(i, j)</code> 的格子只会从 <code>(i - 1, j)</code> 或者 <code>(i, j - 1)</code> 两个格子走过来（不考虑边界条件），那么 <code>vis[i][j]</code> 是否可达的状态则可由如下公式计算得到：</p>
<p><span class="math display">\[
vis[i][j]=vis[i−1][j]\ \ or\ \ vis[i][j−1]
\]</span> 因此只要遍历所有格子，递推计算出它们是否可达然后用变量 <code>ans</code> 记录可达的格子数量即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] movingCountDP = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        movingCountDP[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( reachable(i, j, k) ) &#123;</span><br><span class="line">                    <span class="comment">// 转移方程</span></span><br><span class="line">                    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) movingCountDP[i][j] = movingCountDP[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) movingCountDP[i][j] = movingCountDP[i][j-<span class="number">1</span>] &gt; <span class="number">0</span> ? <span class="number">1</span> : movingCountDP[i][j];</span><br><span class="line">                    ans += movingCountDP[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reachable</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> || j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += (i % <span class="number">10</span> + j % <span class="number">10</span>);</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法缺点是，许多不可达的节点也需要进行计算，应该可以进行进一步优化。</p>
<h4 id="剑指-offer-14--i.-剪绳子">2.4 剑指 Offer 14- I. 剪绳子</h4>
<blockquote>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]<em>k[1]</em>...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
</blockquote>
<p>先把绳子剪掉第一段（长度为<code>j</code>），剩下<code>(i - j)</code>长度可以剪也可以不剪。</p>
<ul>
<li>如果不剪，这种分割方法长度乘积即为<code>j * (i - j)</code>；</li>
<li>如果继续剪，这种分割方法长度乘积即为<code>j * dp[i - j]</code>；</li>
<li>取两者最大值<code>max(j * (i - j), j * dp[i - j])</code>。</li>
</ul>
<p>因此<code>dp[i]</code>的转移方程为 <span class="math display">\[
dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++ ) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * (i-j), j * dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题实际上有更优化的解法，需要结合数学推理和贪心算法，具体可以参考对这道题的解析：<a href="">待完善</a>。</p>
<h4 id="剑指-offer-19.-正则表达式匹配">2.5 剑指 Offer 19. 正则表达式匹配</h4>
<blockquote>
<p>请实现一个函数用来匹配包含<code>'. '</code>和<code>'*'</code>的正则表达式。模式中的字符<code>'.'</code>表示任意一个字符，而<code>'*'</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。</p>
</blockquote>
<p>用 <span class="math inline">\(f[i][j]\)</span> 表示 <span class="math inline">\(s\)</span> 的前 <span class="math inline">\(i\)</span> 个字符与 <span class="math inline">\(p\)</span>​ 中的前 <span class="math inline">\(j\)</span> 个字符是否能够匹配。在进行状态转移时，考虑 <span class="math inline">\(p\)</span> 的第 <span class="math inline">\(j\)</span> 个字符的匹配情况：</p>
<ul>
<li><p>如果 <span class="math inline">\(p\)</span>​ 的第 <span class="math inline">\(j\)</span>​​ 个字符是一个<code>正常字符</code>，那么必须在 <span class="math inline">\(s\)</span> 中匹配一个相同的正常字符： <span class="math display">\[
f[i][j] = 
  \begin{cases}
      f[i-1][j-1], &amp; s[i]=p[j] \\ 
      \text { false, } &amp; s[i] \neq p[j]\end{cases}
\]</span></p></li>
<li><p>如果 <span class="math inline">\(p\)</span> 的第 <span class="math inline">\(j\)</span> 个字符是 <code>'*'</code>，那么就表示可以对 <span class="math inline">\(p\)</span> 的第 <span class="math inline">\(j-1\)</span> 个字符匹配任意次数。</p>
<ul>
<li><p>如果匹配 <span class="math inline">\(0\)</span>​ 次： <span class="math display">\[
f[i][j]=f[i][j−2]
\]</span></p></li>
<li><p>匹配 <span class="math inline">\(s\)</span>​ 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；不匹配字符，丢掉带星号的组合，不再继续匹配。 <span class="math display">\[
f[i][j] = f[i-1][j] or f[i][j-2]，s[i] = p[j-1]
\]</span></p></li>
</ul></li>
<li></li>
</ul>
<p>最终的状态转移方程如下： <span class="math display">\[
f[i][j]= 
\begin{cases}
    \text { if }\left(p[j] \neq &#39;*&#39; \right) = 
        \begin{cases}
            f[i-1][j-1], &amp; \text { matches }(s[i], p[j]) \\ 
            \text { false, } &amp; \text { otherwise }
        \end{cases} \\ 
    \text { otherwise }= 
        \begin{cases}
            f[i-1][j] \text { or } f[i][j-2], &amp; \text { matches }(s[i], p[j-1]) \\ 
            f[i][j-2], &amp; \text { otherwise }
        \end{cases}
\end{cases}
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> pLen = p.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第零行表示其中一个为空串时的结果</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sLen+<span class="number">1</span>][pLen+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pLen; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前判断的 第 j 个 p 字符为"*"</span></span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) == <span class="string">'*'</span> ) &#123;</span><br><span class="line">                    <span class="comment">// 匹配 0 次</span></span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    <span class="comment">// 匹配 n 次</span></span><br><span class="line">                    <span class="keyword">if</span> ( matches(s, p, i, j-<span class="number">1</span>) ) &#123;</span><br><span class="line">                        dp[i][j] |= dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 正常字符</span></span><br><span class="line">                    <span class="keyword">if</span> ( matches(s, p, i, j) ) &#123;</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[sLen][pLen];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) == <span class="string">'.'</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="offer-42.-连续子数组的最大和">2.6 Offer 42. 连续子数组的最大和</h4>
<blockquote>
<p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
</blockquote>
<p>我们用 <span class="math inline">\(f(i)\)</span>​​​ 代表以第 <span class="math inline">\(i\)</span>​​​​ 个数结尾的「连续子数组的最大和」。可以考虑 <span class="math inline">\(nums[i]\)</span>​​ 单独成为一段还是加入 <span class="math inline">\(f(i−1)\)</span>​​ 对应的那一段，这取决于 <span class="math inline">\(nums[i]\)</span>​ 和 <span class="math inline">\(f(i−1)+nums[i]\)</span> 的大小，于是可以写出这样的动态规划转移方程： <span class="math display">\[
f(i)=max\{f(i−1)+nums[i],nums[i]\}
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = Math.max(nums[i], nums[i] + nums[i-<span class="number">1</span>]);</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-43.-1n-整数中-1-出现的次数">2.7 剑指 Offer 43. 1～n 整数中 1 出现的次数</h4>
<blockquote>
<p>输入一个整数 <code>n</code> ，求1～n这n个整数的十进制表示中1出现的次数。</p>
</blockquote>
<p>这道题有直接基于规律统计的方法。但还有一种基于动态规划的方法——<code>数位dp</code>，按数位来遍历。状态转移方程为： <span class="math display">\[
dp[pos][count] = 
\left\{
    \begin{array}{lr}
    dp[pos][count] &amp; , pos &lt; up \ \&amp; \ not \ limit \\
    \sum_0^{up}{dfs(pos-1, limit=true)} &amp; , else  \\
    \end{array}
\right.
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] num;</span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>];</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> numLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            num[numLen++] = n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; ++i) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);<span class="comment">//初始化dp数组，用-1表示对应的dfs有没有执行过</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(numLen - <span class="number">1</span> , <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> count, <span class="keyword">boolean</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!limit &amp;&amp; dp[pos][count] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[pos][count];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> up = limit ? num[pos] : <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= up; i++) &#123;</span><br><span class="line">            res += dfs(pos - <span class="number">1</span>, (i == <span class="number">1</span>) ? count+<span class="number">1</span> : count, limit &amp;&amp; i == up);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!limit) dp[pos][count] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-46.-把数字翻译成字符串">2.8 剑指 Offer 46. 把数字翻译成字符串</h4>
<blockquote>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
</blockquote>
<p>用 <span class="math inline">\(f(i)\)</span> 表示以第 <span class="math inline">\(i\)</span>​ 位结尾的前缀串翻译的方案数，这时有两种选择：</p>
<ul>
<li>单独翻译第 <span class="math inline">\(i\)</span>​​ 位，对 <span class="math inline">\(f(i)\)</span> 的贡献为 <span class="math inline">\(f(i - 1)\)</span>；</li>
<li>如果第 <span class="math inline">\(i−1\)</span>​ 位存在，并且第 <span class="math inline">\(i - 1\)</span>​ 位和第 <span class="math inline">\(i\)</span>​ 位形成的数字 <span class="math inline">\(x\)</span>​ 满足 <span class="math inline">\(10 \leq x \leq 25\)</span>，那么就可以把第 <span class="math inline">\(i−1\)</span> 位和第 <span class="math inline">\(i\)</span> 位连起来一起翻译，对 <span class="math inline">\(f(i)\)</span> 的贡献为 <span class="math inline">\(f(i - 2)\)</span>，否则为 0。</li>
</ul>
<p>可以列出动态规划转移方程： <span class="math display">\[
f(i)= 
\left\{
    \begin{array}{lr}
    f(i-1)+f(i-2), num[i-1] \geq 0 \ \&amp; \ 10 \leq x \leq 25 \\
    f(i-1), else  \\
    \end{array}
\right.
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        </span><br><span class="line">        String numStr = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> numLen = numStr.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[numLen];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        dp[<span class="number">1</span>] = numStr.substring(<span class="number">0</span>, <span class="number">2</span>).compareTo(<span class="string">"25"</span>) &lt;= <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; numLen; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            String pre = numStr.substring(i-<span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ( pre.compareTo(<span class="string">"25"</span>) &lt;= <span class="number">0</span> &amp;&amp; pre.compareTo(<span class="string">"10"</span>) &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">                dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[numLen-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-47.-礼物的最大价值">2.9 剑指 Offer 47. 礼物的最大价值</h4>
<blockquote>
<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
</blockquote>
<p>可以看作找连续子数组的最大和的升级版，从一维数组变为了二维数组，但思想上是差不多的。只可能每次向右或者向下移动一格，设 <code>f(i,j)</code> 为从棋盘左上角走至单元格 <code>(i,j)</code> 的礼物最大累计价值，易得到以下递推关系：<code>f(i,j)</code> 等于 <code>f(i,j−1)</code> 和 <code>f(i−1,j)</code> 中的较大值加上当前单元格礼物价值 <code>grid(i,j)</code> 。 <span class="math display">\[
f(i,j) = \max[f(i,j-1), f(i-1,j)] + grid(i,j)
\]</span></p>
<p><span class="math display">\[
dp(i, j) = 
\begin{cases}
    \operatorname{grid}(i, j) &amp; , i=0, j=0 \\ 
    \operatorname{grid}(i, j)+d p(i, j-1) &amp; , i=0, j \neq 0 \\ 
    \operatorname{grid}(i, j)+d p(i-1, j) &amp; , i \neq 0, j=0 \\ 
    \operatorname{grid}(i, j)+\max [d p(i-1, j), d p(i, j-1)] &amp; , i \neq 0, j \neq 0
\end{cases}
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxGift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) dp[i][j] = dp[i][j - <span class="number">1</span>] +  grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[ grid.length - <span class="number">1</span> ][ grid[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-49.-丑数">2.10 剑指 Offer 49. 丑数</h4>
<blockquote>
<p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
</blockquote>
<p>定义数组 <span class="math inline">\(dp\)</span>​​，其中 <span class="math inline">\(dp[i]\)</span> 表示第 <span class="math inline">\(i\)</span> 个丑数，第 <span class="math inline">\(n\)</span> 个丑数即为 <span class="math inline">\(dp[n]\)</span>。最小的丑数是 <span class="math inline">\(1\)</span>，因此 <span class="math inline">\(dp[1]=1\)</span>。</p>
<ul>
<li>定义三个指针 <span class="math inline">\(p_2,p_3,p_5\)</span>，表示下一个丑数是当前指针指向的丑数乘以对应的质因数。初始时，三个指针的值都是 <span class="math inline">\(1\)</span>。</li>
<li>可以定义转移方程：</li>
</ul>
<p><span class="math display">\[
\textit{dp}[i]=\min(\textit{dp}[p_2] \times 2, \textit{dp}[p_3] \times 3, \textit{dp}[p_5] \times 5)
\]</span></p>
<ul>
<li>比较 <span class="math inline">\(\textit{dp}[i]\)</span> 和 <span class="math inline">\(\textit{dp}[p_2],\textit{dp}[p_3],\textit{dp}[p_5]\)</span>，如果相等则将对应的指针加 <code>1</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n ; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur2 = <span class="number">2</span> * dp[p2], cur3 = <span class="number">3</span> * dp[p3], cur5 = <span class="number">5</span> * dp[p5];</span><br><span class="line">            dp[i] = Math.min(cur2, Math.min(cur3, cur5));</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == cur2) p2++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == cur3) p3++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == cur5) p5++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-60.-n个骰子的点数">2.11 剑指 Offer 60. n个骰子的点数</h4>
<blockquote>
<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
</blockquote>
<p>设输入 <span class="math inline">\(n\)</span>​个骰子的解（即概率列表）为 <span class="math inline">\(f(n)\)</span>​，其中「点数和」 <span class="math inline">\(x\)</span>​ 的概率为 <span class="math inline">\(f(n, x)\)</span>​。假设已知 <span class="math inline">\(n - 1\)</span>​ 个骰子的解 <span class="math inline">\(f(n - 1)\)</span>，此时添加一枚骰子，求 <span class="math inline">\(n\)</span> 个骰子的点数和为 <span class="math inline">\(x\)</span> 的概率 <span class="math inline">\(f(n, x)\)</span>。</p>
<ul>
<li>当添加骰子的点数为 <span class="math inline">\(1\)</span> 时，前 <span class="math inline">\(n - 1\)</span> 个骰子的点数和应为 <span class="math inline">\(x - 1\)</span>，方可组成点数和 <span class="math inline">\(x\)</span>；</li>
<li>同理，当此骰子为 <span class="math inline">\(i\)</span> 时，前 <span class="math inline">\(n - 1\)</span> 个骰子应为 <span class="math inline">\(x - i\)</span>；</li>
<li>递推公式如下所示：</li>
</ul>
<p><span class="math display">\[
f(n, x) = \sum_{i=1}^6 f(n - 1, x - i) \times \frac{1}{6}
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] dicesProbability(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] probs = <span class="keyword">new</span> <span class="keyword">double</span>[ <span class="number">6</span> * n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i) probs[i] = <span class="number">1.0</span> / <span class="number">6.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = i*<span class="number">6</span>; x &gt;= i; x--) &#123;</span><br><span class="line">                <span class="comment">// 因为是从后往前逐个累加，在加到当前点数时，必须把原先存放的n-1个骰子的数据置0</span></span><br><span class="line">                probs[x] = <span class="number">0.0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// n-1个骰子的最小值就是n-1</span></span><br><span class="line">                    <span class="keyword">if</span> (x - j  &gt;= i-<span class="number">1</span>) &#123;</span><br><span class="line">                        probs[x] += probs[x-j] / <span class="number">6.0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>*n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= <span class="number">6</span>*n; i++) &#123;</span><br><span class="line">            res[i - n] = probs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<h4 id="剑指-offer-63.-股票的最大利润">2.12 剑指 Offer 63. 股票的最大利润</h4>
<blockquote>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
</blockquote>
<p>感觉应该是个简单题，思路就是找两个数字之间的最大差值。使用动态规划的思想，设 <span class="math inline">\(dp[i]\)</span> 为前 <span class="math inline">\(i\)</span> 天股票的最低价格，<span class="math inline">\(maxProfit\)</span> 是当前已经获取的最大利润，那么有转移方程： <span class="math display">\[
dp[i] = min(prices[i], dp[i-1]) \\
maxProfit = max(maxPtofit, prices[i] - dp[i])
\]</span> 实际上只用两个变量直接遍历数组一遍就可以得到答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            res = Math.max(res, prices[i] - prices[i-<span class="number">1</span>]);</span><br><span class="line">            prices[i] = Math.min(prices[i], prices[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="leetcode-62-不同路径">2.13 leetcode-62 不同路径</h4>
<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
</blockquote>
<p>比起剑指Offer那道题来说，约束条件更加明确。由于只能向下或向右移动，到达 <code>(i, j)</code>单元格的方法数只与 <code>(i-1, j )</code>和 <code>(i, j-1)</code>两个单元格的状态有关。可以得到转移方程： <span class="math display">\[
dp[i][j] = dp[i-1][j] + dp[i][j-1]
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = (i - <span class="number">1</span> &gt;= <span class="number">0</span> ? dp[i - <span class="number">1</span>][j] : <span class="number">0</span>) +  (j - <span class="number">1</span> &gt;= <span class="number">0</span> ? dp[i][j - <span class="number">1</span>] : <span class="number">0</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="leetcode-871.-最低加油次数">2.14 leetcode-871. 最低加油次数</h4>
<blockquote>
<p>汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。</p>
<p>沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1] 升汽油。</p>
<p>假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。</p>
<p>当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。</p>
<p>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。</p>
<p>注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。</p>
</blockquote>
<p>用<span class="math inline">\(dp[i]\)</span>表示只加 <span class="math inline">\(i\)</span>​​​ 次油可以到达的最远距离。那么最后只需要求解<span class="math inline">\(dp\)</span>中可以到达<span class="math inline">\(target\)</span>的最小 <span class="math inline">\(i\)</span>，求解<span class="math inline">\(dp\)</span>的状态转移方程为： <span class="math display">\[
dp[k+1] =
\begin{cases}
    \operatorname{max}(dp[k+1], dp[k]+stations[i][0]) &amp; , stations[i][0] \leq dp[k] \\ 
    dp[k+1] &amp; , else \\ 
\end{cases}
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minRefuelStops</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> startFuel, <span class="keyword">int</span>[][] stations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startFuel &gt;= target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[stations.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = startFuel;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stations.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[k] &gt;= stations[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                    dp[k+<span class="number">1</span>] = Math.max(dp[k+<span class="number">1</span>], dp[k] + stations[i][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= stations.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt;= target) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题也可以用优先队列求解，先求当前能到达的最远距离，然后当不够到达下一个地点时，选择之前路过可选的最大油量，加一次油继续前进，直到到达最终<span class="math inline">\(targer\)</span>，可以得到最小的加油次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minRefuelStops</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> startFuel, <span class="keyword">int</span>[][] stations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startFuel &gt;= target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minRefuel = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; topFuel = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer one, Integer two)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> two - one;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> curStation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curFuel = startFuel;</span><br><span class="line">        <span class="keyword">int</span> N = stations.length;</span><br><span class="line">        <span class="keyword">while</span> (curStation &lt; N) &#123;</span><br><span class="line">            <span class="comment">// 当前可以前进距离</span></span><br><span class="line">            <span class="keyword">while</span> (curStation &lt; N &amp;&amp; curFuel &gt;= stations[curStation][<span class="number">0</span>]) &#123;</span><br><span class="line">                topFuel.offer(stations[curStation++][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(target &lt;= curFuel ) <span class="keyword">return</span> minRefuel;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (curFuel &lt; target &amp;&amp; ! topFuel.isEmpty()) &#123;</span><br><span class="line">                curFuel += topFuel.poll();</span><br><span class="line">                minRefuel++;</span><br><span class="line">                <span class="keyword">if</span> (target &lt;= curFuel) <span class="keyword">return</span> minRefuel;</span><br><span class="line">                <span class="keyword">if</span> (curStation &lt; N &amp;&amp; curFuel &gt;= stations[curStation][<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curStation &lt; N &amp;&amp; curFuel &lt; stations[curStation][<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分苹果">2.15 分苹果</h4>
<blockquote>
<p>M个相同苹果放到N个相同篮子里有多少种放法,<strong><u>允许有篮子不放</u></strong>。</p>
</blockquote>
<p>设<code>dp[m][n]</code>为<code>m</code>个苹果，<code>n</code>个盘子的放法数目：</p>
<ul>
<li>当<code>n &gt; m</code>：必定有<code>n - m</code>个盘子永远空着，它们对摆放苹果方法数目不产生影响。即<code>dp[m][n] = dp[m][m] (n&gt;m)</code></li>
<li>当<code>n &lt;= m</code>：不同的放法可以分成两类：
<ul>
<li>有至少一个盘子空着，即相当于<code>dp[m][n-1]</code>;</li>
<li>所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即<code>dp[m-n,n]</code>。</li>
<li>而总的放苹果的放法数目等于两者的和，即 <code>dp[m][n] = dp[m][n-1] + dp[m-n][n]</code></li>
</ul></li>
</ul>
<h4 id="数的划分-1">2.16 数的划分</h4>
<h5 id="将n划分成不大于m的划分法">2.16.1 将n划分成不大于m的划分法</h5>
<ul>
<li><p>若是划分多个整数可以存在相同的：</p>
<p><code>dp[n][m]= dp[n][m-1]+ dp[n-m][m]</code> ， <code>dp[n][m]</code>表示整数 <code>n</code> 的划分中，每个数不大于 <code>m</code> 的划分数。则划分数可以分为两种情况：</p>
<ul>
<li>划分中每个数都小于 <code>m</code>，相当于每个数不大于 <code>m-1</code>，故划分数为 <code>dp[n][m-1]</code>；</li>
<li>划分中有一个数为 <code>m</code>. 那就在 <code>n</code> 中减去 <code>m</code>，剩下的就相当于把 <code>n-m</code> 进行划分，故划分数为 <code>dp[n-m][m]</code>。</li>
</ul></li>
<li><p>若是划分多个不同的整数：</p>
<p><code>dp[n][m]= dp[n][m-1]+ dp[n-m][m-1]</code>， <code>dp[n][m]</code>表示整数 <code>n</code> 的划分中，每个数不大于 <code>m</code> 的划分数。同样划分情况分为两种情况：</p>
<ul>
<li>划分中每个数都小于<code>m</code>，相当于每个数不大于 <code>m-1</code>，划分数为 <code>dp[n][m-1]</code>；</li>
<li>划分中有一个数为 <code>m</code>，在<code>n</code>中减去<code>m</code>，剩下相当对<code>n-m</code>进行划分，且每一个数不大于<code>m-1</code>，故划分数为 <code>dp[n-m][m-1]</code>。</li>
</ul></li>
</ul>
<h5 id="将n划分成k个数的划分法">2.16.2 将n划分成k个数的划分法</h5>
<p><code>dp[n][k]= dp[n-k][k]+ dp[n-1][k-1]</code>，方法可以分为两类：</p>
<ul>
<li>第一类： <code>n</code> 份中不包含 1 的分法，为保证每份都 <code>&gt;= 2</code>，可以先拿出 <code>k</code> 个 <code>1</code> 分到每一份，然后再把剩下的 <code>n- k</code> 分成 <code>k</code> 份即可，分法有：<code>dp[n-k][k]</code>；</li>
<li>第二类: <code>n</code> 份中至少有一份为 <code>1</code> 的分法，可以先那出一个 <code>1</code> 作为单独的 <code>1</code> 份，剩下的 <code>n-1</code> 再分成 <code>k- 1</code> 份即可，分法有：<code>dp[n-1][k-1]</code></li>
</ul>
<h5 id="将n划分成若干奇数的划分法">2.16.3.将n划分成若干奇数的划分法</h5>
<p><code>g[i][j]</code>：将<code>i</code>划分为<code>j</code>个偶数；<code>f[i][j]</code>：将<code>i</code>划分为<code>j</code>个奇数</p>
<ul>
<li><code>g[i][j] = f[i - j][j]</code></li>
<li><code>f[i][j] = f[i - 1][j - 1] + g[i - j][j]</code></li>
</ul>
<p>方法可以分为两类：</p>
<ul>
<li><p>第一类：<code>i</code>中拿出<code>j</code>个<code>1</code>分到每一份中，将剩余的<code>i-j</code>分成<code>j</code>个奇数；</p></li>
<li><p>第二类：一份包含奇数<code>1</code>，剩余的<code>i-1</code>分成<code>j-1</code>个奇数；另一种，每份至少大于<code>1</code>，将<code>j</code>个<code>1</code>拿出来分到每一份中，其余<code>i-j</code>分成<code>j</code>份偶数。</p></li>
</ul>
<h3 id="参考文献">参考文献：</h3>
<p>[1] <a href="https://houbb.github.io/2020/01/23/data-struct-learn-07-base-dp#" target="_blank" rel="noopener">五大基本算法之动态规划算法 DP</a></p>
<p>[2] <a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html" target="_blank" rel="noopener">五大常用算法之二：动态规划算法</a></p>
<p>[3] <a href="https://www.zhihu.com/question/39948290/answer/1309260344" target="_blank" rel="noopener">如何理解动态规划？ - 力扣（LeetCode）的回答 - 知乎</a></p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>数据结构和算法</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>《最近怎么样?》</title>
    <url>/2021/04/12/how-are-things.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="密码" />
    <label for="hbePass">密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="7a56ff2ce0a5da375178a43ed13f50d29803f2bd906aad87b773b98c6c69b393">1078a00ac6efef4a296ae3dbff2cdbb335c5d38c1443e44f749fa23b2d07f66b0625b6f6c3de706fb45603268858acc1d40aa0989add4f3f58583c81942779f2ed847b63fb8d535791837982cba872a080bc37df73cc34a6269a603231f803229967502b0e7f3c31078db1a47a2d39b8e95c4948905fccfba01a2666d31b0db59eec58fdc9751c60f0b7425271623f6b7c5a81e4c9912b708fd4040e987f77ab971543c8b62dc4cc57cbf26ad2c7ff577fe1cf81ad5cf45a13c9b9dbe225cab3426ec7748aeba2c3d9a36b1292ba711b6f5237f7a3cd7e6545d152d7e8b74427a6e950ff5aa03df1bf526b79154532fbba79d3b2da973b1ee2ef7278006328901fcae41e9ae7d05a6623a57d96c02a5b9af77ca5d195c4c46f5f831ade57bc3fa94492ab2a51fb0c6dfd33ed2943da494876b77ac1e904d239b6004da5955e5e27fda182e6c42d1fb43e40dbec982d636cfef7046887662747194037c99fa3882a75b16c97ff665b61075cdc33c62ae0b7efb2961585d13f4cf699f8f5be864379498a40650a692b736df99d0a476cb3682bb295f6a552a9fd38bd8800fabf484672a52b5a2c69ca8bc44e1717bb5643d1d283a73670d5b1101314bc3b36b19c2b14de9847f92728c10e4ff11110cef3b444d296f4803137290566277da7e07f6644a39eaaa33e9eccf428f9d3750ffc896ee860c44d5f00c2f2e1cbdd0bc8ffb7555cc2b1fa66e45d57a84717ca65f021463d46cfb4dff55b9040d462c2dec7d7dd1d50dda55218a983762d91fa6bbdcf1808eb3dc3b2f2b862457840cb769dbb44e415019be0613eac80754a3fe95833adc511a99fc61d6f717c74e209748579b5c784f7081822f87d811bc3f94170829778ff7328c71ec60ab18159d333a8352f57aa2a99ff695e0d005d7667702246aa7f1b3a4f4bd5a979ca934480990ecd491121ded239416873557a9be6a8747402d4e198fe575ab0dde461139b0a952fdf6734d16edbd69b1a9001d5956d0d6343dfba8680fe075021522bf5c3745d29140bb24efa666a527e093db69bc0eda7f14cf184088512d77d51f250e8f9eeb125afc555c211cc5c195688e86431c38c38c09f171ea698f79346f0e288419911911fadfc590db4b370057f39fecdd690e192b09aaaee3a52693cb7539385e05cfa8f0c1ad3be06323e71f98524283ebcf63033794a4bd8c3b139b157c0e942a22fa32d666bb3853a4949fda35c1273a2b4702a1f1bd8679da10b036289d32eee2da67a639f61c61f263684a97ed76bd0b48d1c3c1e236ccf2d95eda2d534cae204c4d67a5d2f6bebd19f80b3a656bec3d3a33ae44bea4a92bfd8622fc9d9e4e4c58feac81d4e747daea1be44a6c40456d14ae9e67dd3ba954adf0baef65b70c7df897de59d0b4bb99b5f609a07e9fa92cbbbbce53df1daf42adb41b25668f6a8bb90fac3e59fb2e8f2a74473a52e71ae5ac0fe18d958e52076989bf56434a28f4079ea66384ed8f8cec0a2780e31be94717d6504ae9fc607cf57b74e7b2f8c2496bc4aea1fabc5e39faec08f8fba633f5c083e54de6e52b88e019702a08ac9ea93e20ebeb218e0165c7d3c4209122ac0fc269aae99dda39c3e1ec19fe762d2596143a72b7a7a4d35377d927765c921318032cfe720f8ca334dbc4854b909be68b3821605009c86c86f4a26f70925ad01625d0eb3a7e328bafa5c04b502cf72207dbdfb33c0b658c4c112fb1ded11075d13b56e55cd2c6018417eae67d45066884a827154fccd3b7aef7ccacdbab1660fac7a0a8627132be6beff6dd7626b632702499cdfbc583d6152491d85e0a29df0c0e1702638d83c541519c18bd2cbe9fadff5aba65fac0a501d77798714ed5eb07effa7fe96c0c5a518835fa96b773484e63bc5398a16015cdaed121caeb777ad318570a98e34d62f1228d7770fe2ea1a447238f1de0ef4123e1751f49d386a8273a091a62d2379b650131e211e58d6e13feb26aac14bc8a50afc330d3031f682bab9399835cec54ec1d5fd1076e2aab5562aac138c76d20ab08f4ec8c25c96805c42437db71d9eb6f5a789db012438bf5662a89ad24b54275105afde8e7591d4f31889e5c3e7dca6b1eb6daea1a8ce4adf5437524a4bf63835767540b415431d59dcc84f49eac9c8ef8d68488605312c0f1a352a3f9ffd452c238947e98bb72d734e384a6599be0250a40f78e60ecf8879b1aa696ca1453ae750636eaaab1ccda4daad3072d8aa111a391788fb49add8ee18caf4aeb2b639684a50780834014c1f0008182ba0ef9ee181bb63d97f2a816ff2b9700f21a45ccbc4e0f2281bd71694f38ad84a5ec51c274be3f567567c3904905d17429072252838c3e980ae509c2a0cc1e32026df8dfa87c11a5fbf8d0e67090df994c5026691d1fdc59f2fd74accb18867b4bedb615972bb3c0a3ed7ba463cb4917ca27ee5c7ce22d5a416a3a665ea5db596ae1642573c169be968b12f37387a0db36c7e2a20747dadd996a87aa06c1df947f16bd4fb40660353ba22091d9ee00305774e0a406d9c45a39bc6cd2b25feb59f81035664b47f373330fdff92e1953afb44d2a7d82ef6ebb257bf089221ff52ed1e88e48e955a2c35f86b905f44f2ec0847d3d3be6d3fc72f9665e71b4646a72decc1d48a0ed62c8236d1d1bf1f3a0af778ca2b3be6df43c7c14de60927a743552fa9dab451dac9e5eb2b6f069637dbf2551b13ac094231fd308fdef814fb90c9aa203921e12a511e48e57dfb3cb227b50d171f7631e384dc816d7c2f1a1624e36eb8e8c11d0c9df462b66ddf909701d1006e885e18631095aa9df96ee333c2699ea63726e521eb10b05e6685c1f5f7effafc70ef53832fc037d8f5ed8a94ac28d9f7343991132a42f425f336307d4893b4163d8b194abf1cd135e3dd91661113064d5762e039292911f1baf7fb2b513d6c3d95ec2e09df71da2c3b046b3542380997b17d3c095467bc6ed83d3c16cd286253a5bbd73bcfd92cfe31b33e9bf1665a3bb6f788adb230a9f8b580654f0ab555f8d46f9643e8ef94539d8764615e608427fb49af88609c38daf533c5ef011fca3f47c84c77e858e1f1644333c8d310d00b7f13f0abda8c1063fc417f602597137b59d4a2051aa6ba57fda0275b9544716deefd814ceb75d0ccab4973d6a91a887130584eedfa1f695e683436674bf013f5230095a4e5eaa246e5c63ba15a558fa492d0f9fdeb0f66554161650c33df13c56d721b1e3f9ea5130ff925dbad40230a6bb29b392f97529e1a3178e95022c56774b502a449c3960b977b5dae3055165c9a4056d3c3c1888f5fadb620a80bbcda596edfe5aa2448dfdfaa06db407d7c45e3bac71bbd97fd7999c557d574cbbfbc2bb3e2ce5a8388194b4f609fe2144852496364b2632cdef119118452cf304783338e4066ce70fd0bc99f7d0dc002734d207bf85da3310aebf8bfe24cf7e60a55192e14fc03b98b783d30a9995732a54ebb13d45e8a342a293dc314db661dbacea1bde1ad2144f1bcdb737fc4eabd28173afdd0cf22db9322a8a40ddb866c954a4121947d90ebded4d570b574a0c2c469a67c97c84292fb303a1d48805cb70250eb4dec57aa2dbb42e27db7cf22c8205552a252562edcb7e214fcd3dfbbbae3caa8b1249843d7d9221a324b34ce41a271d0c0e5d95796d266a2317f2a749152878da4984cebd0ebb30843d04a46d8814c08e1173c878f00ad13a21f7f76eb0a5415ca2f19b5e1796b18df1f44a5448c1abd0f7dd4c2b64aac889a1adaa1585a043ded9b0cad05d6dd42c9656922496d7cab60e9dc62ab41f285bddcb67073e600dcd67d4db8b72b96f927c63f4f26f4bcc7ce34bd432ec4a41c8d7d4041aa34bdfe9795cf84e035de60b4c66a10b2011b0375a253dad6f7705def245c120b8622d82e221925f5a3437ef0f49343d95d78efd02024d33e793b77a796a0f0f6e7711b2b2b171cb1576123409ac6cb3bf49a9034dd13154de1e350e987b31fa8b32de756909c82cd8c1a0542ab1e968fe9909a96c834deee90c4dcf4d43e92d3091b2c28b55e276b79c3ffc59ddf21bde3865ec81c6abe478dd5bf437d2ddc5e1a052bbc3b72450d78d76fdd2e6d363378c902eaf524010351bb32b1fd8dfa38ce9d0ec0d6662f702aa94c2500dca2da70e0986c62de354a0d277783d39906bad4a8a5698fba4db0975bc9b2136d2334cd0bbf422d1ce817c33045497beb79beaa575a535f54bc1dede22415ebe8d9e2c7a53cb78a37c6b897095e8273a3d8e9eca71bd90d67ed48c7593a40946a20f143ea8f330f1785f6936371caa69dd5739e55784d1b275b2fb963871899fbe64be9ece36a277f62bdaedb03faca1f77ecf261bde251bc54be92e39785633e09fa4f25759e582bdc3b93a6d854575636f3ff6bab1099297ed807374770e651b249af7459b52ec598c3652fe9d9f9cb86532b38b880a763677d871edc5047122e9fa81d0a9fcbe124e344bb79625187df3dd2601c72fcd8acc371f43cbdb4e7fedd0b6615ab85d1849735db849d843e9d69a2d7f149c56b6180373c2da9e9e5e119b7895420b10f41de4bca1c68306656f01ad98a09598434d60efef1677d590f4e320de121af81dbd6bacc120f992ea492058fb923f3cf89de31cdf2fdaafb250fd0099cdf88ce2e92eb25e90465bb05d208f7ad5bac4bc5287ec3f1ebc8b816118d80755f16baa0348344e70603c2833ade3a7b16f2493b70b1ead85da0b4b373b59a587ac52e4ab901993da8eb9c485d742c9dd62c53d181c14f17a63fdd405a9811e739fd39e243c93569b7e7258d45d6417c6f66d859e83902c48ae3fd59ccb295a0def8358c591a1f52ae9911c0b9fdc89403fdaef0fda6bbbf7d4a9568deb1de8ade941566e09f3fa2522351aaf1e3986500f5e60f25640675484f6b78ca280f06780ab9d7ec9ae6c481d0cb5c2400b046247fe729c7d70b2e27ab0e526bbbe238f4b2d6ebacc3b34c19a62ce2ff278b08db9b9e38eac7e5fb6dbbfa5d6711f0911ca94554333aaaeba42596b63dcc98e0a9f31c627c82ed77febc0e2d47907e0efb5504f2ff27a899d2bef8d1a01834c8b1bb60622c31aa4ea30d0e9e88afe134fc9e917099f39129ab63cef1ae9773a9d5146dfa27a46f3c437106cd3b720d92eabb5913f9e24d8fe7b4d4a25e7b99f8ba4a4ce02c76b0108d9512589678fc694e547b20b15ece3f856dccaf2c9ca5d20f85a3591edef5b80e47f50f9764b96cf2ad3cee42580d3b7c9ea12524b166e0a35061254f1d795fa4fa118df7e32421dbd8b9100557b5c28083cf062cb7cf829b935ae60065a037cd433b084a36c15fb5c0c328ab5a6d2fc125e6ce2eb9260ca1be765935ef4265660088d3d628f7507c29383077a6c340a1855aa4bc3a8079a264180d311f73c86d027f506f363814c655ae89f803c594ea9ff5dffaccab1a3a29e8682408b655afe6a16c8d8a55315a8d4f5c18cd8e2cb8379aca317a39b4321a55d8ead9fac335773f6cd37d578f8487bc62b51e31ae4effadad67600a1cb28a0eb30c3e1dd95e1472990be407a7b485f8b878f13f8bd364a9b862c23493ec0cdba33a3ec2cab7e7db6dbadc9dec8bb36f4b493e10814173f92d6da492bffc6923c5a8657634ab4c33621ddcd562bd5981d6567d3f45be474f075da99ccee1bb5b6f8a2bf97707952de4db6ee5bf5710ffaa0b17128dfeb8629facb0711706e604e8c326266f3d36199557e8a2eb8157ae48544dc6677952f49c7fee161d4312b550b30548e82ddf65ba0eca80fedfed40ec5a0c6be17d1c1c5a0ab311bab5af238c5a61df467d309bdaf8ed35c1b245c4fc7c87d98cc78038d8d51c9dd908c48c6eeb1e3e942ac12d1192b08153d9c4d93ba68895788513431ffc5745f7a181929b050aadfb1ee4c752c37e69ea002d587e871bb084911b78a316868497192344a083c76c87a559eed088ea41c5cf533a01f679935e657a91c16c14d528a068dac2a4c4af6d21016239c040c18436d48d2843ce263b508e4ca69754978dcf5ab30d2242ba133c457d7d45faeba1a29b37e013a211719c49f6d675f80eb9f60102ef0798953dcfb5e4774c8fdf224ea13786b5688b381a2b4f7ca0fbd53b7985f7797d265881e4d5531fc53147869472ef6789206a65a00d4217dc60ee3e868542158434db2caff0a4c9c2c34467dc0f11b21045dd1c44ed4a94a016122c2a9d38317e10d605e50d2129ff5ebc3b37d1becb255bff30141b8d319aecbd70602323a071f9823df57d1427541af454b09454f5c080eb2403f3acd6e23cf191684a885d3cb71d8ae4610245158b88baee7042b990321c0b2819cf100beaac85a0f103da722b9a4a683cb9ccacb01a19871971f6d5882fe5051abbcfd209e4b45ef01536d882e4b5d2dd473b239c0e5d5cee10e785c8e358172032a2c063484341204ec06a032e018988122d5f40dd5118d645f82f18a703e048629286375dd6279b68441625b49e52be91b096f996472741226723f4f55ee50e8509fe0e425e6abd2695646a248a0549f7173fbe0e0226dc079533f4cf3b21b4dd99ff15301ff157ebf6828cfbd828f685847fc38d7045989e9a748c90fe35906db4a7d8836a61949558548ededfc1694f95144116d389025dcdf83d62dfea7d909ff378a4af1372f308629b3eb34ec7dae4b12cd51ababea59f3401601011fa9b1be9f83d6587fd58f626ee2777b43f333e0575c5de3780007fdc135a31719bacab48eeab5e57cd823ca7826268146ceb1821e9b06183cdc79c384874f9e0b339c8de5d70dfea179fb4fd6e5b25fddcffb92dbe3e4792f5255bb70970c3ba1e1fa8854445a3cc1b76d39d03eff0b467a738a11e9b573e5639aa82470e040cee25c592253d93476d2733fc3a9559eeef4478a341b58b40c8eb7a16628e2a8c68955f9a8c83ff564ef18deeaf88e0f58623f61d53b996a975f36a5631b11c70d5b08ae5660ec9c37024a41bca0c3fd2629e739d6efb8870743d94ad566adb2a149907a8a550fbd14396b6788bacc449047e05ec517e3fa430c8503df86c0e1bb3ed89e9407cf5843ccbfeb16fedc286f210e7af9aecccba7208f92dc2769664e149966c488b2a7bb38911fa09a89cf096d48566d599a5dd9511d4eae1e86a7ed72bc5a9084dba242538fbc7c6efa363554905f64c3af88c4f04433bcddf21e332fb0400c61ed778b70f39205ab53d15727fb53ae13b2cf2316a9636aa4d6b16547f9c93ce27e7b150deeb83026e71fe26d3ce098a6389e2d01f1ac06142b056b2f0a75b63031df4e5b10ae6ce0a653ee838ec61ce94a1ee73f79a4b08749513b5c85e3e32e816f92fda6ce5b01a016270618abda1d5b0ef76e8000f98062883deea575755b4bc1b2c5ae7bdbf19503342b4ed3dc9712dc0819ed43bb4d4e0023d0abcf3b94e8b6151f97b189945635e0ad0257a238a1559858f62e3a969f73ebae7afc2aaddc7fd73dd86d5d0306c7e2f8c58b65cc47ac1d7f4f308954fb01cdb3916dd8a639981931298de26117a29f5f898d9b605d4057f66412c60147536cf7a66c90a9757ce695a59f73116a8006483a6908872e57bca824dc9094b17b32583c96e5845296a70e23910424398064aa70f2c96272fe3b73edfb36570c622006ae01aad7e6b0f07a1b2306fdb201a0ea8bfb62dee4289f9b708251945b25ac86b59607f61af8c43d086ed2dc1733cf7cb39468558ed5b28fe6b7c8654850d01c0f7e4a8cad4686ddaebf2d05f588737ac672de8703d1baf3d63787a1b429940d18e9667660d8c90240701ac20ffe44319ee53aac02e6c7669fcb8b13198f1a38f82b830ea7ff69a0ff47896eba234412b14b0835da4322cef07c4525597e7b4b9fd0da8be0e5c17367098f248db1e7b2f5926d663aa8d0f5dd2aa54c2cf508560267aaa3fda04cfb4d5ed8a97af87247fdd95a8c2efba400ddfa74a2d25ed30c495951805c4a1868a94474cc40bbf50cef403d663b02a18b98ce5b9cfa734d5d5857fb3ace1e32e43d3908046e3c508bd42cfd111cb5046d54259c6aa03ffcc28964a9b8d794d1087164be74ea5e94abbbae93e37bd32dac687ea5cf8e891d760cabe8e43bfbbabddf4f69d4dcbc8740312315a95d99e3b50350b88701482b90730e2ce4f1bbe5796bf31b9b5074b9e8c7558e3ad9ee03d8cc67b6c2a63baa7b876b2a3e139e3c4c307280dff8ac933bfcad3b9437b79a6feaa937a858e30fc5b1573884d58464b0d434e20f923fb64f82eec7ab4790798e0028a7a904a9171c46264d53f9cd0286f539b8c1b4d350b5d8c9babfc605845f70dc3beeb09cb5d4aebb52fd4baf816625eba62766fd00954b5c202c0e24dab18f157b32e9984c690629afc51fe87cec5a2e197bfd2af9507d57ecfaa1c2350bf0c870c23f8c2b5a8027f547727c8608d84e2974ff52e09d2e78c669cbc7be8691de2a22591b06cf354f09136de94948b8f2e8f2808f4b6b4dd50bec7e24c4381566d3836aabdee75b831c089357d7fa2814b8739b47e5be65ec4497aa056f5d78996c4785de3df0e3e03317f3c8a3f6026cc6ac881189ad8f7e9074444df3e3da91a6220b27ca0ba560aaa594ba8dc4d56bbba8ae2a429ef512e691f1ae1dd62d5fde5ae38bc407ec5311538bccf9dd195c440080ba2a49824d2aeb284f6d420109c78170e3c152a2e0630b3a69e24207a89603b3db868e500b08df0b6259c38297d83203062cdd683d924e4e44d328044aea5befa857ab49b33b91344a7720fbf26055babbe819d5acdd6c95f8f0e8d67b5dbd030f3edcc0f75f1f78859ba3adeb9b91d3a4e575dadf5fdbc78aef4576219621a8d896266a09666f55db3f24597c8324466eab0fc94a94c2ea3428d2fc7715d0c57396173121b1b67a2c3df179bdad6d3d6aee291f15d632eea2b05385b410e9f8786d34e67c4ca405e65fcba05c87f6e1996953bfaf27b32809b5a43d066bbd15d5553cb830a745691eee7d00cfb27a15d91932958ed20dfe5b2c617bc970075e38c70085ed9d49e29d16e7e33ae2c979bc681a75a93d84d78741935ff16207b752208a7efb86247987f03c77832e706bb02a46ae213f45b996457549f8c99ceac5eda2eee037f5e8601935deb6101bbb8731abd5ecabe457a9f4bb7e2cbb48145a64e282b269fbaf7d880bc604ae84a1b11183ad96e9fcf8fb6ba20226558725dda84c7d277068d1be12395cc0231a0434727f17ca1b4d452f2a417311387fef77278c2f88b3ea832a1d1075b998bda30c981dfbfb70a89b7b3e62891b78378e514bad46607d9375912107087e4b71a0b19920ee936833e493df7024fc40c2fcb39df8776f2b0146dc255f94b2c82df8ae1e6286823bacb9ecb47e8bd7d559af0f234e71b53a95ac5e81af2ca03143748254d90a8df7f43e83ac0cbb03bea51dd94a09dafffca8f9f8c35296fba24c32fe41af35d34adc48985ca521fed9ab0cf0428b9e5fbd847341c2f3d3555e6c0e06e9c22744a216bf39e9bc34e595e504310a86a2eba8ff69e313f694c1ee133165540378d15f81a9ab2deb9c34ee1f4dad738112d90dd165267aa1e05412b2959ee67ed4ddac974fb8a1224fe9ef2ee3840a49dee3dae8dee36a2f4fb2353bb10333ce8d6b81ead95322b2e1a1a6b3d81befd8a590faa33192e666ad5b883c7dad6710245c7b6c7a54c547561406ab048abf3f19d82c89ac29090b2964d13246012f2a2c750da1ce0392e4ef360890588198b5c9a753c0dd8bf97533ad2d96e7d0bc11edad57befada39a68673344e8e6868a31ca2157de3fd0693a9271f53e7668dec5595df4cbe0d285114c883f5d8d29399b60ae88a7b68da5726a197becd953c80b98981e2987d9e1e9faa1b67fa93efe8ca77f388a908cb93463fbe56c50caee64cd85e519cd03277b4091fd02710aa8f87b283d5301628bac56f19ce74b5677c37224393c8e1630620055a47fefa37b55bdc4ef1fb08071d8253dc98c148893e1914f5577c17857310c4363fb95d0ba8a1ce763e06bba89fcc5c2160746055b9369fca0fdd5ed362f9bc17f266c6f180b27d5981ef1050ce5baff94fb4651aceb8a56399f9211911ae97d5e3b9584f95790fc81d063d6f7d044acce9a87ae02f754906042336f034465e6cc31b317c1bd65434595c5a2749c4b5c92a1e3988c512ef65de4cf2cd65dd6e86b08ae2c5aa477495e43a9f7a40c5573723848fd03c5a0308ad769657feb688c1aa8432b174ff0330607274898e3ded46012277383169288c19eeb3bb58714bf3399bad4f698ebade417bd9d7a1ae2ee2632ec4aea7292527d73f98e58fc8bcecfd229c4b5355176b1f64dac2f90f0e959540809f40de569e1f90a143d2b58b6acba0e1950766efaf99c5130d8e4b5990d00caa0f5bfdcd6b8e76e4d58910f9f3d84d9347fe7ae2c6aadfad8dfa4d92f371bfed61b39eac497dba957c056f55225aa97af7315da2022a0039164755f590884c22b6aaf302b3c335edeeca986d1e744b164f36aee609910d45c5f495956c3db3ba70d5113405ea17fd3bca3c4ab5e7bff896b5779f7aebad11f0804b2f997b22cac17126780c990097abae77b7dcb5db63a9872d9691cdbfd59bbe2479eba8b60ccf1f891314c2ca50a21f074a65eac01525926b66e557e33ef344d4fb4c0ccdffb32925082a66369f77611e6f0e34f94883b97d59ce5de2c0691e4d290a711d12eea320075e1cd2f7fd04b6bb447b7cd3d48576f5cfe4d4661d5581bd250de41a7bd21e456decbe9bc6806ca2bd20c393221da45762df22a0dc07deca690f9ea562444ec345f0b3f6442ca55eef885e1d627469dc1104cf94ec2458680ca0b999c07565c8bbfd9542a677195d3ecca21518c5f35d1f7edf12b387cd91125a0500a9a30947630699fab66b14ff24b3d512a1f9927c4c6be38150f3c5b8502053d99e0ca24e36e2d068883ca0b8df7c8de1cf9a94a8eb7f01f821564dbd1ae05624f403696f19b66b1a82d5807fd1766b936d3a81fb4a83c276c77927e09d43ba7b7d816619a31cdbe35a349b01687b8e142051c6c0492c1ffef48e91f3f002816bc80be6e6a9b44f384a81a6a35eac335dde595c3e73110d357acc91523649a614f9681eb5090eae0419a2d84b739dbbe8f85cd98901282b5ec97ee4dfa955ba55eb7b52b1ad3d3a96fa0e0ce236654a919f077d982ea9642ce27806689497f86f5c4ce606ddeb1130bc8de17b57daf0d21bfaffeac423e6d5cbda13a7b8a796576ef09aefe5ee4c96123d876b370b31ef42eedc63d467c572a30d21c2f901e24b331e33bb4e799c7a9945482cee149539d7db275d22e5735271396a17bacaa55fbdbbfb22f92c087f8d4bcba44324c3475149e1d3b5b3b2c20b5a0d4423afb72c4bee58d04ec31ac7957b681179a08182da8bed7c82a708ee9dabc20b9a7c605ef821f6aa70aad2f1a469e86ccd7f48feb46c1c5ee72b483ad30f715cedfc63b5b0a56fb8126278db774ee0ac1aff5ffe0e5fad06c2399ee1334766537282d9977a41315533130af309ab0e2ad169b00f21237a4ff66cd3d9cc2c1cec3b013d1957abf984fe3075a1a3d42701803626210dc5090e631e72c59a776359ecde62445c34399777017365b8b93adbca3011828c5f24fb3a6739ed08d1197f743e52ccea1045a9e5e58285f106d168788a51169d13d71a7d4f0ced8f6101aaa67eca8369ed808469b7fd56fbdce0f5fc464e01547540a835458a33071a2b867a2d9a027a3d68d430d37988a7d75219ae4ba1c9362923395e214cb767f7780141d22151ccde4fc54bfc916d4605f9544c0962b3fe261e067660661e6bb236a6fe3ab8857d39261d5593365b54e742643ee8cc433dcc5671b5da5cb7173f66e9314b74e5dd89dc1b087b5ee96ab27124a5285fde93e533ff6966061e7835cda394895f250e6cf39ca681268f46d71e21e6d947116e94c39616a18076309148c756ff32a60aa12be6f3762897b071f88286d4b74219bdce074c6017fc903b39c7312731e42b5633d371091c83eac55558107f03bf07a2b5ce60df2d228d6a000b6f226e81f38212e6ae2a08661ee9a71f297b7e0ab177794cc7a17d355c61fd1fe0c81bcb808a416d91ba218e2b0e952f5330f09677d800f988596c0c39d787e5d3357772875a4681118bd648f73de4b350cb17298fada4f7093fa8e5347cec44e5c051637c016d4a8675426f1efafe5963f2c18843b295835294daa69c33c432e26400ccfa55b2fef656b5a206a43cf2cf85c24cdef098deacdc46148df19b39b5f1355e021f7de4a1dca825e4e70161a604c0a597d00e27d87348cfc43d75e54105c43a80eabfae70321f50d4067505895ab2e511fe3c19fe89f1a0d409c3a6d5c08f79b11bc7db2b74e50376f32fce2f618bb6dc595109d455753b89fead58bc154ea3d88ca17a9d7e2f983505bd5daa936a25b148a9929a316a0e05adc161873e481cae6076a3ca6622d3d528ba3517e1d3bc77d8a7e2fb0f80fc4dce2eae245e6377c5bd617dc397d5910cb1aa4b44f2ea37f3f1fec70e63d0857b9e41da1613a304df3080fcc8b7057c3696c5930476bb9c3ba19e8975b5c6472b657caf3f8dff8a8a65f7ab2622599c99ca19a93605d92dc4b25c596df0c77615f5d3109d8e73ccff3c957d9b7f773db7e2d4d0266d011c08d7d5f9b795794c2bc63b4f7d4449074692b276ff9457c26fdd13621d52d6b503dfc1cb68264747e679e218512efe58a1e4447202f58e51bc285fd3f8501f98ed40dffa92d71723b95b516a04e7397f4f09ce7456665ef11ea5edcae9f880ebfe80b79dc21c55156083023b29134732b145453c1fdc32ef006b6c2a9a47a741efdea295dd57e6689e1537448a0b2b5b134ad4663a075c21dbaf4a373fdb25de16970a081e68f431ae9e4700ffd7d19dd24d9c57f4f1eeac8881c725f430a90e18f0dabed59396cbb7e64e38574a8540d502d5f546dbae4b243b42727dc72c3b021e5953d62f2039a5eb57c78dd74833a6c5f12d3ceb000f1b99cc02ec48b06cf02d9599ccfba95243975e6f627d37e3fad0515eca084363085e91cd1c5ca68ce13b7d07cfb0661256d7c013c7bc53d712317f1f6043090a0c8d5827d9f50d38dcbb8416a99a70477974599a27883a253d0fb646ba638f17805fc3ffd62f2b913d491351b711b9f0c72a70fb86ab4728c9e002c722f38bd9be4e2732b800c43a12c8ff756db5e7203e2d4484bd644ae732bda73c94001472ba22853dd9a15e085d073cdc678c842c8e5bcc71447a9c30fc8438d7c02b7746b10802540f2630f55efdbb7670f04077943d1b210e48aa9ad4a907f9e30482608463c397fb50a47f4bdbe25ea52ae6fe72a1754ccef945852e93599fcc81d4ada6fac1baa68460721484b7734d61813409cd593fde50a25bd725f76c8171262d5b4e999e35401f9628603019c84f126213ff13ffd85c18220de9dd84d14a230ff2423158c32fcdb6e8b8af69cde68955abe856948080134cbcccaa3dec197c72fce54457add34dcdd80e2d86fae200cb6716c840545fab9af78f76b99eafcfe012b5d1df05d2caf438fe0e107d00d8a64ee644869f2f8064d2efcd1ebbbb9c7b6a0e2451b9c80d2bf252550fa822b88522d550e2f49e656ba0b870b9167d25e97b82a09670741e85898d1c74912d4dea8f52c2c2cc70f0705ac8de1df1e9eb681db216686d12afb0e8d1524e9d3d8b9b7d1ce5105736c61feb66c9cee150e19f435713585d9086d50cb3b4d4a083be2eaa54577fc758ea8614e713bba7506ba3348db60139a03864b2638e94d3e9096b1c9c558bc5b2b60eaefb4bfc0c8a95cfee8251bd708366eb59933fc0c835328b48961a416c90b86da4ccc9c73f7f8f809813819ed6045f5e275f230dcb214c3a9c8105adb8d1e4728b08723a799771692317efa4370c88ad8f823d25cd174ade8cf885755de66313c8ad332f6f3ac261540bdbdb404284b0acce70a59dda762bf6f3f6694287a5293de380015491c7e2291bd641ea82f6288357a194afb74418dce1d81ae0d7332b61d4c274eb697d6c3db9f0a9797be16c956d85189e4799b8d39ff6cc9b8d677acdd55514325c7720a4be2e804a4bd1d1afc833e608bb44a2ef7a5065e20d9180a9a6b35fef6c675585719cfd3aed87c4a4b46ec29f50dfd761c58e8af89d52f063a15ca79a9b530263e0db87b24e453d4166978514bb4516d1668578b261e686218844c13a0f482433c0f9c6ae5ae486107e01b8707366e5b5864dbcbd2c0274e66e25d8628a28889009f0cff7fed8d9945f57536a654a04e33728d8b0dc916082e368ce7ca345f8f4d5c0e6f5c4b82aeaf56182b4aebfdfd3cee89f3ba9dc24e0b4553ce7cac18ba91b2bf6d8cbf28fd7f67c33a7afd1042a40c0599cde86b7c9c19b3005d0c73cd77497507fc4929acb4f8357c2c0e74e8b752b1300eb37ff62f5ed00153421105a93c763e9d6c961eef9c947fd93fd4768621de0e1c7c84018db64bb18d86ffb570ed62479428e7d7e49fcf138928bea9213724e5f3b3fb1918a09bc50c8c40ca62ff0f22c6dfc3598b8cd25a1707f4c18b49cd8fa28fe63c51636b59aaaab3fac9d30ba2458f2fdb601a9b9052579ea7edbf9df172a0b66d9139d41d7e7841c140956c6f0a9bbe17a058207b6e1587917808006674c542abe9275221bcfb16048d7b04f2d63041f94ebe938866c494e687b6f6c016972d6caf1403863eb3e5534a85dc0f1cdc1b8948107404ece832906c796747e9377abe9fd5e842a312bca8aa91d2d27801beb2bb08adccf5c9bfae0bf1ecad644391206c47a5f03bfc8d2625c25757f594335de841fe651a7054e57a6c7dd8d879f4d1ef1dedee68a4276de6e3ae66ef257bfe1db00348a7eec99c698fd79c24f225af2268f12b091a91afbb33610405723de5709d9bd8ff47cad5911296392694a8fcb89a665e5f4605cf25cf76390a242815c1d85e5094c711f73ae47db652bd4b6a541c3efd2e88fe245b5a381546062b0197bb56a55e738f4437525f51379667d8b05fa73f90de8d2bb01654a88d0fe293e0b1442bab701fa2136834b05b7f89da5e9e56c7672c3aa791b9730a69420e93f8f2c4ca797d508aa2f783f8321da4ace2e39e3c9181c272af7e68f2f01b26eb0d948f8a31061af4d5324f6f40ea8a281bd8eaf0a382f552f586db55f2716a3e3f48080bc04a553066144add47e3b8f2d06af55cef351cf5b4147ef07c53f11ccca090ec83e9706b255e6eaa241c279e82fd314c7804c26291f97a232d7996fec00293838f1041ea9c0e173e60630b43eb3f75563298bd173abb41527b5082965671dd4ebd38f549d8def6fd58574b307cfa7a328da0cfae8dfc6a3114ad0f6c2bbd74b5d64ac99618ad2c9996c3f6d5738c906e4ad2d2b2b1b8b4ae7ce280042ceb3cdebeca8dbcad6b3332a5a6cbd71ddabbd11647cc84c84d6031b688a03c33ce0af4ebf248f87f18db75f41b04f6f9684bd8f9c61eeb11a5a1b665f9e3efa6238b36146b9a9f6cf31f95a092e7eeaac631f3e912fef82d7f62b5ea8a6d6a915cbc761dc21cd4c5220e570fc29d7e230792cbbd6f8e1141ffedcc6f72c962ec88e839a73017cd6da6209ae0b1d60abc436a03bd3f7320002c1b1fc1a2b2c991ae00a526bacb1562a8e7e32c58052fe33200b1b7475b63f5b14def8c0030aead009bddaf67e7b62fa2a9d63dd81199f561416df3131cb9fa76f003fda4782e2a08b0e5947befe7fd26f20f95e69cd6eb414477c44c87de057608c734c8048ed179ad826934a48808f7574ecd391289f02cd1e482c5513b355b007d0c86d3f1b66f3da6222041c452ef9566ed6b264327ccea046cc7776faadd4ee5f73d505f9540a911ebe2c4ceaf6aedc7ddfdda154389c879a9daeed121184a6d466ccf7587a5d5d7e984977014bce4bca0b99b5f0d77ec785953d89fc0584a9f784b976bb302bc61498bb6f38a3086466a42247506669f32a7550ca380077b41d01c2ec5238b4bf1620b68e9e428402bbb3ff88e91843e7f547e52b24e59746d1140d8af7b5c94286fb029a378dab23cdfed5e8214a7cfc6adce25e65d3515bfec9d124e42541b82c9bab3a9bf51351d45e001f28a89b908eebcb56bc8c209049f270ad6b77448c682c54ff2bfcb47905f30ac5b9f9993e36d66e440100f13911d41a5b4572a5fb45ce80de1912382356eff6a99205be16aea1128cd74c33fb0acab824a544227b3fa9ad9681f68889135952561fcea17ab133e4ad3baab0306641adae1ce808b45cdf665573f2564b111d061370f118d2efeb5aea8fb89bfad83f910b442a16be2bc8160c86ea2fe7ab8fe95bdfbf1da89d4fcab4b69aac1a14398ef463ba56d6cf66aa612dc7972a23c1b94bc67db5d76b6e155dba350871b134c188dbcbfdea44f79b69b47e31a0fdb5eac882511d5b7cf05ea3c17aceaccad7852fb6ba1ff0d0dc983e4da276723ef0e94dc020482aaed2e9f17ec3d700959fccd73bf9166f0b1775253a37a378484407014b2a2ddf3da285960788b4607b0bfd69adf25a274fbb46aed170945e3ee55392ef4722dde984b7cb8726c2293dd9b6a6d98a5acd3d1fa64d306ad94eebb30089825944d4eea12489481c1dffdcd96db9c3590c178d86195fb2de3ff5e46bb697d47146c89a365f656422dff235fd4d8980c0b52d9001b898522c0cd0172888898403ab0f2d47506adec8db0efc67cc63d00752d6d37626f16f2762f756e78ed08433e3e7609202fbac20e6cc3717e5f97fb2d9bf4675f217ccf7d6b203e96ff734d88100fd1651e4a726cf1daea878c177955e3820b8677ddb189851d01b3d1f90c825e40d332b2be0ad7a292ed17519ad44b9a2c3d79881dee4cd9123a2b03242aa8f5435c5ef4076bc13ec2fe470390cd27892d5994f6cbeaa5f7019e6c1ce37cbed49bc693bb23691942629a3778bc7a430fe682b11413f15258dcbeecc1ca566cb5a6c6c31c364e13589217274efc99acbaabdc9c925eec15cce8683c2c8807e2176dcf477d12f116610de230d4d3074388b2fecdb67ff5347604ba0009675703d6deb6d7490b40965346337c28f13a2b1159ee659e3e9add022f47d0cefef4ad6b3a085239cf7dffbe4bfe5ec7d714f67bbc25ed4153934673056162ec75f1db7acffc3a75fc686b16e38cd5d62e78d69492380dac6afa46e27e4c6f7e480a2d2fc6671ea6c5fef7b8b402e147b6a7b0b2d43f85729ac38e59d10d54ba825098c8d20b76a6d7b042dfe59354e70119ca6f890f2580a1ecea81d868b033c00723bc3ed57cc7512df8dc6c968238ae36b3f5b41252e2229cc1746e12d6853c765abbf944c1ae2c06a747e65f70f1dd426e1a6f405d006c3d126c7902751ed061483037e7282ae5bf54d62c1e6cc6ab220d789d7f8ebcdc027d2205894d389dd3a0c09fbbf79e0142c342d08e5096db6e85e16752f3829018118ea09ad462252ec8e960c182b07a8a9f5fcc1d378753e9276169118b0e22da01571bffe39308261d29d64fa56deddcce4e054ac9e7304f2334e8e83c9573f06da0b81fa000443aa7b7cec836dd47bcbd834e97a671e01105c02a9dfa6dd6b1a19f555405bf70e69787bae27901754f876c02d5b19834670f718528fc71987c8232a7e2373db687679237c6eab15b734cf061f20526d3dc94584a13c73f39c2667f1111b1a779abee1fea3ee88bedba9f7ab24c47bebcdcd024a3a83aca6c983bbb43ede7afbdbbfb7e83d168077edbcfce164f61d4423668c3b26c34d94bae274abc905211b2be65c4bc186618b9f01e66f1e55ee411786c79c1544f36cfa6ae4a720a44ea298a46833cbc6fb2b7c896d8e82d4c4e45cdfc44eaa11851a275ab41f71ec26d9d7878324d41394ac9711372db2eeba64be487e9093df49d6f8eeb0ab2e8c40a28e8c656ff2d51745ccc1d2734f14837502470b9a14a7f2373c65f2a9bd42d9dff2100bb16af2fe717271f7e6f0cdec94281fa51fff38a1ecae1b46e217bba41f6bce92c02d39ec361d3f35819210b26747bbe0fe0864cc11d397a9570a1dceea692b23d8da501522862da1f73fa4035389ccf3951f0d9216dd2a98f03c1641d48b8cfcd8b11ec9424fd5c36213cafc04ccc56875710f59b224c103f9331c718c579ddbc5c4a284561fceede5c8244c37b585515da2f068819f396e5d2320f9e1a6720257c22a2bc894e578eae1ca27ea4a52e781699195a9c1654fa544cd6b9acc01b887774fe3f22a4f58e5c966647eb6e919de05f3dd5dfc61ed7d3c934d33529f6132f7bea21bd32aa545d26f968d5bda8db2ac71de07b0b8921506b668e21fcdf8055e681c9c2815b3a3cd25f9619b63417e81d83ca1c721817a3548912aad12016c195ef0ae018807bf8a3014fbd36d7f5d633d7d5f3008feddeb8294a332cd44d9977078d212449d0c0612a9bae0bc38218b0be816a4d411bc6b7af5b0fae37fd273259af51af81c7b7fc3f003d66cade62abb53437a63eee420f31a4784d865d2ca01ff0ffcb37c4ea5fc7aece3212b9b1d44a2c561f566d1766cc62028d47e1b261b7940b1c7234546d1ef7a4c3fda24694e4781a5ecc03b4eb2974c8895cd2b2c1be534d4795b8e33a2e2b2234ee22e533fb97b66150313d553c40dec7ea7a9c3bb83dfb5c16ea1ea8b6333c131f0de9c95dc728d328d3183dd5387a19625ee712692bc8c90efad05e11458bbe7291106db42c0fc3340e2e1890656b483dc7c2794f51c64bca6730517b7c1085d0b439284617028a90041af3348f53eb30c4dc99eda3e6562fb2c0f17e0edfa6e0e473bac1d00a24624a808bd205b925e2f39acfda7fc353b37079ad203366ed7894c9228ef909d04c7969511459fae6480da776db123df829dfff6ef834b6ba5f1b215ea505b3458d2eaf1fb56dd12822086ed8b3b5318fd1a6b8b29e1f7f054d539e6f305841cd6aa631aced6405e2e198797ae93ed65af0f1f42a04f4615e761e541c073175b62ddda71cdf3daf354e620ab7518265f51d09bfb5a61f20c61723be23d596693488a6ffbb224008596afcf36609e84914eb87989c18462f36946a41a690623306a77ff1b96cc66d8120ce8d0e5548781d34592220a4a30adfcd0f1af647c55428a652a83e980cef7eb9a2d2fe5b10c75c638f3745f49b30f78084f8d67e2111428f4db650b55e1b46d86098644b939536e1acaa1e78870fbe39e01d4566d19976294c9053371a368ea3c6db1e493a50bf504294016a05d97268ecf8b4df6117f769b56deedc8a6492a12e39a53c21cb0085e4c16a56dce182a3cb20c5b6b8438ef2096d0f6b0a9bb3a9ea59d751a7b64c57b11a3b7f0f6c0fa63b2a0ef81fe3b7fc037719b8b4edab9b33dadbb1588eb0f363381597b4ee561a25185af040181888bb44340dcd0671eda329f536727aa0aaf38d3009325a6e6faa76b531e52d49f1b9f18c19f0b591ad72a7124dbaf53b140d09e4fb3ee2b533f0e5e610376aa8154abdeb28fbca07417387bca4b4ab1e7d7a4f718567e0aef248ee292c2167aafd3c79a4a3227ed0ae52c6ddcb9ea12187981ee4060b6ca9d1fb7e4b5d96d0cbea4e4590549e3642061d51a65bfc24132574d3ebc331830e3f314dd964b7ca411a5da834cae82fe5d7c119a77dc6163feaf365f03c5436b949a1760f58d03112c2a716b3419eb03b3ea8dfe76fbca0c2b233cec8170639aa6ed5e08ae545f4caabd827b064eb963347e96c34e2de2a77a15327067052895fcb7d26ee55a64efa33332805e9566fa6194bbea812464ccad0a130fc6b54e1712a52463960771cde282ce890ef90bda9c2830e887427f237ad42e8bc6011ba94c883ed6a5d44fb917bc989c671eec9e1ccb2f86c877fb6c9688dd186ad9bc466d57917251999095e98168a4a1a3242dfc3fb24c941edc6a88a21f50439fcf52731336cce04e294d6e53cbd0b5040d96d39882dc68d3f005c215b41555b482f8f3322d67e911d4eed4807dcc7c20808ef73b42777f4ed64eaf72f3dd5e971a2c5b480f0708f945037575882a1158ae0517758d37e14ec8f7e40ea420a385adeaf67b9b4eda131b7637cbf6077d0651c04ac04cd30afe9c72fea9316ee645674948da6dd20a901b9c747e24cfda4b4a20839f1cad7854959320311ebfd5a0af7e1e3ba0ad79f437b67118087dbbfa38ded8d1399c72fd1627bfb7ab4f5b22be307db995d795808b96f0c5ba7f0bd1336f0478b935748f4276cb903bfa34b3a0cb09dbb2fc61b9fcf32a9663387a8a4e8e973f2b42e6e9e598950b7877ab4d937f5fde323f220d55df2cc60e4c41300013ea0ad18e9924a9636aaa8caaafbc609672fc0d7b1c80b4efc7c12558fbe445380357a50ff68adf51c1ac3020ae6aa0ed260eb4c5d8103172c71b8034a81138d5cb2c1d6edb42aa790b16597b447b99f8d3494156833e2fbe3ecb4ec6589bda8b9720f016bd281b1eb1e75b208afd6f944a09b06d6f09638868a138c78d66d06465fdd779c3c2f32824eee4d05d77f1094a75ecfa202ce5969b32642191629ba5500873cf4787397ee84493d193a0b2741c48a2d3c4085884b8883fe00cd187df7ddcb78ad24964f842f290e64d32d59f22d85ab1a05e102168c39d30608da09e656112dc640bb826dcd098d50a25fb1782dbfbc6b66a640276de79cff8c2503a5aaab211e8267076524a6bd4b67afe4f18521baa0a7c91b1770ff617681bf33754dbc277eb1101d557ce88682b187a06c94d56aa7c962459a7e32aa2357a2e3fe93aaff45ba94726a2246afd7970ec5b8616c3cb0060c4bc27ba4b1d3fc295dd83142240bb29b88c1d4952242fd6936f99e4bc40d978dbc0a841e9ba6d9791f8f34cee393f2b3221fb2ef7208adf0168824c6c760f492868960962cc91161dec7d2ecc0e7012586e553b54319bbf1d323620c8343a23177ba7ec2b40bdf75d1f9b9883439a2a5174512c60bf8785480f1f1ff530de9f11de2c36eb47d23531dc495d1999cd43891d23ddf34415d890536cecbbe4da698ec97e6848804b90302f70437523742e4525c1a084e4f27a7d8985184bf318bba2ed9ccc5508656a0971cfc4be22562609712c7607200626c222f190fff97f58f74c0362056dff2e99415f9fe1370f9c710b632347c572a0095ee68aa9487601053b25afda9911d54e2dc02636ce50d4c9155a67a4cc0a53c73e23aa5569c1735c45ecf25c7ab5a22b7d39ce3a57284334dc6efc36b3739c6a0c4f08d67385b0a9fc8cc429dc7b6dd6b33950e4b83f404faf939297aaaa357bd8a750b175542c939c7f8ed97826491b3915eaa901459023655bbbdb2ce0918e59533c31dc3079b57f3f764105e2dcda65f42eccd27478a317041524a260689d158fea5a6663438ce112656f472bbd2d6281785423325c1d8b922a5d382dc9c3bbf818421a2fcbe61d0650595ee8df88601e7f124905b14961c2fcb6426a74ab9b784f749518713a6402b8199028c2748e060ffd089354a122d1adc830b822d5c1f9e9deb34bc10f031dfdb6eeb12e45fa84527a3a236f6aedbc6187c52229c6bbbf0e66af9ba92bbff18322143d432d0d1de1b4a91ae9acea20d32866d39cae0c9a237899a4308d70b12eb6d5cedbff736624a0f0b57b7c795265b19117ffe8f6b72a3fff153953f34c4d5e8283281853266ed5696fe417fb44cf96d23372ebaa3f7893de9c7e4c952089535ca6d55ea8507a9f5ce8993dd142d3d78126baccd875b1b0c9525d8f3da23d9b04c83d6ca6f0ef03204351f924aa2f5aca0a995a581102dfb34c0f97e900062e55ee4e66aa6faab9428ab1dcde3715fb523aeed7ae5ee29b60ff091d8cbdae8113cbeb5be5362ee19b1b90cdce9d5bcaaed11e438a45a34418861cf200961b2f4fbea15a9413fced20dd759fea972984adb08c976bec19d3598b3a11d700d42deec130475a80c44b6504e2ba21a62d7b3df1f3ddd28e4c794624df1de64f10085d10ff33868625e353a4c4aef2f1c39eebb3ab43ee33f540d552ad6144f80d2dfff19cae457702d644999ca7e971c93a9c9b66618be9a4454980abe2024daee51054ff0ac522198db82f7fe49ec50458b17ef56634febd56077cfae8ce0f4d8d7b3e520e93ab1c2cf97e55afc744b351809f364cc40bd9d2cc9fa6a77fee0f4a229e890b70b4a04908ebbbe850e5b595b6b8c925367624a112dd11aa833197ce0616dcc610b3f1d0b65f62d02de8a722d4f52f221c230406ed28faf0b4ce53d83fea6c867a11e6eac13834a253f5d0a8543848230aa7e21d5725f9582fb323fa7c7b2c31cdf4c0c57932ce57e7557cf0ba976ffe64ae216012fd0661f5cd62f8b51a4265eff40712c825d63ddeb8a0bf9900ba1fc4fd9ce44f5aea98910f37f8feb6272de9f7f53fe06dad53855274950c318a21b91561ae1614787db86641889e10d5b3a275b0ff73c10f8f5855a17515e19948ed08e728e6ed9c8c6af50595a64d11429575ae32d5651bb80b9e499ef3d8dc6085831f8f8eccbe38694d9f90a6ba254ea53e4f5abf02caf401eb16c261793495b7307d4b89c200d6032aebdc860f25f771fd7e2912eab37b88908c7944a57ae299198e75f286d05bfc4a8db1c013dd79d77ae45eb0d4e61241acfb69ee17c7d919518a2c71cb2654d635b92bb23064e5544c284d92111ccb75f9a43cf5db40abf81314f57c3620b27551bc8746913d24d60d812805431dede3e62793e965384387eea3e39e6b496e5f0708c6b6a16556a905857f9fe4b1f44c61a65d05ffa2cf8d68ac515c64ee950337f749569af144e89adf3f3cea0b6a9249d8af3de192fbc327452ff7fbe4ed2be556787d3ef743c09a4286679f40fb2166a41ba3e671a02aeb689cd8cfbe316ffad9b62827418acf184eb2dba2ffb6e983c88ed768f4deed6592654abd2e1d4dab85ce85c4f5879be8dfe98aff17976ce0242d950b7b53d86d907cc567aade56528943e4e444ba1893944c503eb02a8ef52b73ff7cdc92f99be23c522df5f1cb80eb0658561be95d3138d91e8ab995f393260bf6e58675f09f04e3971ad0377db29dc60f66d86b0c5ef5a47e400ab75641a6fe270cd70f77cba9aa5f8e45a91aa4ba15d4079c7b1ac30d0ef721de948093e2079d2e233fef54edc7030af57190feca028ef90bf95ddf2f2b0d27627c1169f8011f7c3f672ae0d6b7f6f4ea40208fd18ad1317ee34131fb5cc6c6408be88a52820653c565b2ef6bb37cba9ba86fe66733360afd7674b495c4dcb5ab8a0d00e8df05021461f32978190b561ac197ca06ac12b345eae17901340e3029fcf80c58c8337a3df8593ab186b1b3eda1438c27ffbb30533c6e76ef5307a7ca7305b35ad037183f2b5a8d3d6bee164cf145af3b71488ba296850c3dccdb9c04c69b2444ff9eeb7dfdf0ee576f4b4bfa205283f48704aae94789385a6c80a961b9d345aeca10b6f59aff4b118428bde8f5aa4744ea55a7f8c7cca1fadc426283ad93ac6c02acba6a280b67335ffa4bad90315319dbd85d5505e8618c3540cd466344ec27876bcdbea72f4c1a8ce4449efc616f3d15100dd2cce43be5288481175062ce6143831f6e682c1a62db7d41473df538054ea4cb9100fcc88485620c1e084db3d59511d4f9a5e5b74261e3807b12dcabddd61dc88fb860100843714c25fe71871ca2c95b9131ab35badc8c171795a1214764703160136be3ffbae688dbee84af73ebd497aaecb3c0709e666fca46cc206a291693af1d603a3344db40262f4eaec0786eede1d109a595106ce156e4bfcb3cef2b35671ff6a8d2a6f5d2a7d10ac1dd355d3df78a7e134e75c09648ca458836d2fc43d39d70f382686fbd8cbd714537633caef4c56a7dc92de8a108585c1befba5cf9509fd6eb4532565f3eee4b529d45d5f1a2f7344597f5e8f1414441a9d55cddb97ca93951a1faab437cdd57be5b789c432dff091d10a52a601e776f75c87a022cb84eccdcde54681f7c1888a6ee11b135861086a6f47243056b6e27b51bfdaa8cd9f1e94b0c23f64fc11ce270dc35396ef9257a75a840c8c4e11614637dac776719a8d088641a4f998e6e4b7685f2f344a76b7a4e88ec5150c9366890ce948a7ce4b22a388f3e5e8794ce7ab475342cfcf0e32146bc21db7435b119c6800b0b669696b9c6e63d9469879753ef69e4d4cbf328c50197ae07ba2dcca9ecb05e2bca3260224237f3ee39dfb92caae6a7c4c01d8fe847ccb13456cbb912c79d70e52aadb9cbb0bc97674c870e9a1038ec52fc4e6bf2dce8f7f2a7f77f0f7a20fd73dd9378a1c519178cacdb1442b5c5e8e360ac43b0da9c805f52ac074b8106e626358ae0f4212d27e743fa51a9ed55ae68a84167b38f9eef0c8b120a2e6b40007ecb66c990831dec4ba7ca503ba40fdb313dd4fc5aedbd2092bdf9abb0f4f192f994ff7623568eb77b90eacde78ea45a9c002439c4872ec20b820e6d21e485be8c8b9115cc5c3f4c9eacd13a834befef7fb83d61a7cdc755b2cef53f054e3b2facc01924915f21e137af57abc2dc362a7d28a3638c205845eda0312b2b566637d9cb676e8ead4afa3016f38f29783c27946efae0a124ea081d635319c82104bdb1f53703200c1e24649963f4d895b296e13ab77b7e4ff6bdc00858257a2b68759becb6a762027367d30364c305cff9eb9865d4e2b0de2aa5eb9ddfca39670ccbece741acaee9870e498002a31f8aee80e67f6f0171e7ce5bcec9ff501eb5f1d3192b81529d89f388e207ec669157bb3436a059f0811d63eae0d65ae9580bc5259b0cb7c53ecd39a5b871ebc1e9c7e5f498f0d5e31a2f4f836f188fc9f70723b6395234a45878a1a78007006b45d9cfdd294e0f05df5b115207bd08e84c7ee9ae99b8133ed4653d90f56bf8845d2e9f3a7ce1231ce29c2adb0b4b44c6dd6c9632f14a254dc6c8284e3697e4e0540805bd83495a6c0f99de4fe4dbd9604ed781bb6283eb9fcc1758c5aa77826fe51ad15a5573ecf6069ba95f9f9f6b1b65f4101b3b3a3e52849da44ee999da13de2e5e0cee2acea87cc398359841a0a21ea36b862417fb39f14edd05d1a36b0010926637ebb14ea9bd0a8656b2529e1d7d5e47cbce334a1de9dda5a8010f3a929a3b08d11961a4ec54b317d423cc699658aa69b2356a065e66c6cd6deba0332ec1960aabd570b45255ab6482acad51b8d777944e077aec27ae670f9b4d5c6a79306e5f294ea8bcdaf159cc9eb260839030f2701c90f2e80dcf430cd04582aa79f6fb7c9b066aa906f5b7fa9888683a8e6578f90e8eb3902e70be22b8ce9b8baaf9dc586a3b20ec67180d14e009e5e80da045d68f448d919ab1b56b82eed9c80b4d3d754ba633bbc13da4a88ed73b20ce8fcd8892c2e7a4fd54e94f1fab510ae5c207ef29f3d774142a0c2d8cc36fbfda95547254418753be1d27c7147c664daa558c5d9aa50c6f25d6d6d3067659c53974d41982747be08be48fda48be2f0b52abeb25197b0881322ffbd25db658ea2aace17f8b22d448b14023e7a60ff794aeaf79e51a51f33b553f6bf96fb922b3dc4ec50e0370a1a0a94ac5b501e7f6fefd3e79e73457217befd5b419dd0b7b4dd141f0943d4b86223df59ecfd6d1af0743889e63255e17aa43d244db7b937346e696493256d3df73d61d98b8edcb9873f700285d0064f8225d46b338afb1d2fe44d29488190f5404ec2385ea2fc2ed02cb7672a99fa1f4468efe30a044fe37169b97bafaab8fb943ccd7a18d9a33d4a556b4f568095ae5aaf35012b2a7bbdda73fbecca883b9a29032fea4a9dbf6150d476c68a166c04902ea0631e7c012f956ed3ce8cba6658d433ce46278549613fbb6136eaa0417db0c569756207a7bf6fc260da8bb795dec8c4de5fe03116d6dc27b6fc9696ce7912f2ab7cd0aee2da6270f7cec138d30566571b4e46db3c21c491d991b8ffa79193d260e4ff19df51b5f403f49d4968e74ff4817f7d14f1d8ecbaf663305c3aab6eebb3e108ef10acb347b81107d29768f5c00367119866441f6c5b388214f93793b8eb7142e09997f07b455e20a7ce04de0130d89c49db862ba920e654ee2473ba5274b1e0536303652d9ec20116e9064f122de9edfbbb86e5b5fc505b59ff049bc3533741541f56632dd4fc1f5816ea63e18c98fd066f0e98c30f8ff75c2af8f37d8f2367ea166be3e4fbeec0fbdf5f9ab27f476845ee78798afff85bd8ed1ae5ed03c767e08f5d17a7985745e325007790803b026dc77c5a521bf9ed6e8ec0c9aac19bac77f63a83543b9e64c43435f5492790e2afb2b1ea40b15f00d23638942684abd5931c659676b6ed17b0b8c2ba73181541b77430d1bf95eb66c722791c3857359abc7d7c5d3058c1f555944bdac32dd5846659a566f5a4a3cc5957ee5b5927b33b23906b80a69465bfabb2cadcc1b34faf8bc483e5729d628128a2bd6d099f7d61604e9f0e01ebb2d2690ac6285e9d3137817a072042cdaef2b990cd9f588d721e50cd673eba2f196cb0d553bedcef3c5e0f4349bc6acc777a0ce3da7798c805bd078a52964aab62cfc27896c757d319e0a251379284e193c343fc9fd5e1b3374c78395acadc45e107e221b9c118bcc9302b27c4f0214ae2ad75cec885a2264fd8677007a3aa649d28a26901b5cec209acc406acce1a059966984cb8588cdbb74456900e1e0b3133d01a8d7cd07c8173a62350b66a19979ff499623bf42577ac4d47f5e35021629ab9481a4257fb8cfa01781bb7c6568e0ec79699da83003973c3f9ae5d60e51e35521306f50f31c06a44932f9940ab5f6d17fe27f2e66bcea7735aaa1e79e6b5780a5f2146efca9be976214dc2e886f3b3e9e8eaf174a162f96d2e3c7970548c4abea6d1dfc9481551acf984e403606ba27e61a43e62c6f8e1b9626dcda108f51ffcc7683b833c9ecb00930af87dec2d35f4cca0b094a2c77a0d4dc8750390b49025b10cf54efe8a36efa953b50b0f7654fcc8bb2939dfa7d9866929afd230f86004026bb23ccfb6d86fe5890c230bf2752882910ea8e75a983b6c6036d76488d885995994005b9197c85d798b990008080a5c3c9fbd5aed9f1435c4788441124339b5c55a45c7447f3a38ffec8afdccc94f2c42404db6e809bcf8953fc97e655b5b2a3e3aad1e0cfab65c9be630c99db4f3d1991dc4cd1feb0275870110d42ddbb11b7b761bbea6df8ef154afec07c210bc406e0c944a36d4af5c552e3c8e5c4aaf3f82deab4364680adbac8dd52a5dd33686c454c6b1477ab1f207e702a18bbba5301e122e908e7b6f1c4edfb61c8b286108592783b0f0b2967e60dc326f01951022e51bc1e1f09c3145adcee1b4135b5dafb6dde435c22751c3a16d720f58c18e3495570a9abf815edbe35e13d7718fc5f6b9c65ddf486e0247023d28a15695a0d1210a54d4dd3ab4ca59cbd5f2de191fea65343e29d9c8f803a8f60152bd3805f23d048a7820a2609ebca601f152ca361b2c1ad5489717d91156808773b48a1e1cb4e97cb1bef4e08d3e41bb73d30f17199e0870d3ed0fd3ccb79c6d586891e84e9ed6e8afef3ef84ea83732ff4cdcbc2fc83aea6366df11d3b30125b9fd98dcca07c97ee8785e35a4482a6f3b286362930cd15b130aee2bf529649316ec9e0bfabc9875c3e9286c6c128399120f665042f22e213611a342c961305aaaea466082a8034119dd00492f312b109dc4c2f08b461df7cd7c3e71a798e669247feea1342dd8e48b16a8293a637a10ee9507f686ee82efe2a6b0e94789a0b4e869f38930fc7d1434da4da5312777160169a5b7c863e49357ecfdb5bd85b81433167a33118808cb7ccf2668d4d7dcf0a59b621bc70e328c5c6ffebe7fd1db7160f3484cbf5cd57bcae6d9132ac1955b91a841393ab79a4f50543fdb0973e9f352293411effc022f399e60216be2a9dc7bc9f00c42d6264c653b2f7d2f1183c372e4a1e3e7c6593b1c6de88c5118fad6c6c65e019a8340535f400107abe95d85690a79baa37102e22f3c0e1c913312d274e86e80fccb0c4b3ed2363ee1a4781e6020da62350f01130f6740cf95259738a4ead7f3dadda18c2f0db9a040df52287451fb8be24fe8f10b3850c01e415a96f5b1fda31bfd8cdc725b1d8c5a3d94eef88fbde281859dd889c3d0db95a72bd07595756a50f15dcf33ef319b8e0de59bb665a220d1365ce1faac8e5f5f42e02b7aea5cbe56a7b154a2f5481705ffca0c192ecaab423e4f1aae462afddb4c31ae276a097d8903061bcfff61426036d9d6cc16f3a277cbb3ed543318f0b586584bfb1760ea9c1aabcea66d52133194bcf2c9383442d48d6640d7b3afe575c089fa30e2bb51540739682c3b6ec8efabf7e6b346747f195bee9a110797384a229a6f52b531ec712109f0fe043d9b18bbf9a4c20ace1d529b999aa2f26e4214e92f497370550ae0d4c2c602646a1e1dc41b5ca98e8d315d86468b59c9bfdd5d2e56007fcda50bde5d10ad8bfd2aa377a2cc1e6a5f8e11e8c56820468c3d7daf91ae492c9935f8ed73589f6d73d1ba5e83b32efdd6f3a82c6fa21db00f0faba4f0c6a5d15bb6852a9457d8881f97a9a3b24cc4710e7c4043cba2d536ba5efec23f1f369dfb57c87b77e8cde1d679677a87b047724fa22cd7ee8f034bc6796a7aac50a6769ebd127841ea4db161f6bc3f2e0346f1874e461fb7795062e7364ce2b2c64b828761b6afd56ff5b13c7eb11da21b1cdbf6a4e3b9a7571c7acbdfbc53110a7c5e7a4f83120cbecb6477f5e22f42cc0580eeb698738791324412868859be09599fbe7362c654acfd190a712dcba8595eafcf5910cd1ec59ebff9249814de70a08712e6b4a44b7899381e8fd737252a8683aac07d9914dea440d0102c4b2bbf5c4f0f2fe9ea07a9a0cd7c2b678d99cb9c7604ea444a8bee406f51ca1adf49d4d2488eb02f0a89363f5f89486a6bcc8d72d1c16245c3ce27f42e2a80c75ddb2f274c7ea9233430adeffebd0781a58ab4c365c6d808d4d48b7abeaebc60563d45eb3e4d9c4c6a42d630f715e6f74eb017a80f04386ef0c757a7b261076bdfe40f5288c3571e11af312dc8696f8292078d472a3979257a1ea5c4f08efcf0528673a67feb8d708a965bd4e6135905eb3f1d27f3e71c76f17b84b587278b8af0f8ed540056c718a15b3d057443ab8c3ba8335b49358cb8a55cfb940d98e5fea67f56893ca7a600019af3f3c120727a303eb47d6ca473e7a056f534eeda8c4c3b629baafef772e96ed471cfe7a715fa9afe2f81c730e4f64065b1d3973def93eaeb52163ad3a2b4c83d2d1f7d67dfc9652939ee7851802dd97042839ca6485000e9c208ec57937c122992a4b33c068e9ee5225baef39e300f035fee96f59a995332ad8fefbf6a8aeb1001f8f7a98cb07fbc9ebfa2d4a3feee0762547cdd07c54e0d7299291d9de8dbfc2634821c3e9fe6322c9efbe6b131a39d389b145fa5340b5f4d020da8e4cd18fa6c1213116aeac8482753308280dfe31b3e74ed8133363b5d182924db5190aafb85b8ae2e63d6772fe798038e787a9ed50a483ba78b66bb605a8bc0a81156e84cf34eb8d4cef61abbb8b2891582ab47f261af6d885506b04bc7ffa79100d994ac9d3d8b48426714805dcd0fed888def7f9c5f6c9ddf3c40fb66ef1e3ebc8f3e9805d65f8ad3a5c6af8f6621096450e47d3f7304951ba46f3a0d6bb542c1c8b74192602e484b6b8974ee4ec712332fc405aa873134857cd9f3ab5f1b742a52c25227ad1106b0c87c1146f5c3b0460c83513260d97873bd5d299dd164ba0131e3779ece47226f4987d510119cb666e1b30a30ab07f810d52a76541affa6a497e0f22a33ccba756b8036cca7057a85a5cdd3c20bfbe1e228ad6d178ed155d7034ae222cd5aa3641a6f856edd1769a362e5755763eb1cdfcf3b876bc6cfed3b173e1b02650c3eea57b3b1707e114af7d255b9ba09fd34b88eb336fdd0d60ae7f73af8e0a9c68fbea7c3e018207cc6eb24f9b48580b9cb32263849e88355dc223b0f32363c067b4f460a7f5cf714d652fe65525bb124dd7a5c49a1ec9f97485b92ef5ea212996f2aed01d7dac23b0d5e02e8eb20fd75cdd6c766e49a43d3fd84619194502d094144150bf57d2645fe682eaafb09a1d30a269971a320731bb26842f41212fb12319cf5ad49f4473f0318e60e13a0c9580a1a13657465445406963651df6494d4ad441b8d70cf7f38f07a556cf272bbec6029e16105e271c9ad3798a082e88e2ea810e0f7090821c2af936027092ba82308178e1bc29d5ba8bb8068379b92fc93018da6adb07a3c12656ea2e605dca5bc1b95011f9b605186f06955ca43cabcc6f8007ba046697febbe2e44013341850048b04706b6336c1ce6a430ad65e1b179ecf365f166294d77c1ad0ac79f7f4cdeec32b9fb8da7630f844af25b26b9f95ebf19ffbb5dd0c3b34d764d48b2505f033ac4b1de8f9b1f71180fcb908563592292076c8fee76af881769ca1ea55e8d881bc02132f4d375780e32c7a0e2218ccf82532710db849b964cd3d6b31a2779ac7f996edb4368727dd8073a11ad5e102d90c652de80576469ef537ae26f5747b284f6da2c372bee66ff901dcecc9a8ea9148647fc1679926504e839087c5fc1f77c8ef26e9b7438a1148db0c230c6a7b17b60da7bba33bec39bada6ec48df8128b125c54cf2ba6a3132c4265adaaf957650122de611865645ce3c70206dc3a9f568a96dfba474f711dd19b494a2b1ca89966da6b10ae963ed0e0a28e6122e3cb11bc2fc285056d2253f991205f1877f28220e2b60144442abf26379bb21494546ee71b29ca7be4684086289110c222476ac6670e2fa5e6a78d749f26de6541d61fe7d0cffe4b19efaed24dc6126b52e8040f9d54cd5fe6e1a17de5fa9e8673b69556c5511f1a3af41e42c6ef25fa7e674852f8d67edc937d5fecba7aa32532f7ba64a6f5fcf17614d8b070e8a539aa5ef4483dfa0ee78a8b157a70d8402a04c1e08c97c8cbb0a11e607c43fc41af78cfc27c9f3736bd4e3b6e1c075d73076fd33f6119f29aa43202bbf029bf5787b7eb2c0b95f37f233a62fc23a73be41adf1af0bc180d8a0b67a336ec31beb4eb739e5bcc370b34a5f0e05fb4e51e69fe8326cf21cad9d42e4e3cbc4fa8712a3ecedf7b0320c2005d88bedf809af42f28cc4a940adb6db69de105f80a6164b02965852b62b912997f078999db051edf91fb0a7e81f8875336a9369aedffecc81088dd3cabac9fe14da7b5e779cc2be908b711d45065fecc6d3090e391f80690ac5abf805e752390b1eeb21d3cabe106c33c7b194aa75037f27df219f1bef35bfc114533840a9428aac307b381ec080a8020f3ffacfa5906f34c1f15670e14702a11ddf0c8b5488dc46bde986de5e7911fb57ee26338c5f534147a39cfe0c14bcb1639cb94e60141cd7f534e575045ece8faee53d2107e14163d5f397087ef20a73a9f6730e89cdb7307980fc8e4a51a8b169ec2739347a0a570eac9defa2111b9e79534e7aa8038cff0c4d1faf0cb538077aaa757ac459fafd9cb83ca69913a3fe1fdcc74236b5f981f1f6af9a42764c55b042a6f6bcbfca7b78319f9595deba5e12007cdfcb454e7e84c5b59a346da67d55c53372799224d40ad15d9aef7849dc3348a25ad906b01fd4849e8976a59a38302d7c681900b8c03b78a24069ceb6eb9de1b4e1143ea83bf594dbd4b8414f2299abf1a1be7c98da73a1db1720c03e384d596d0ab1b4eaa7dad8717f4bd995ae04519e58cf9e8615acfb0568175ddbd3bf4b123dd9afb1412fe6577a6266c46f77983b1a33efd2c117fe8e1726368efe0f060894df6c6b1ecacb1d1265f75464e74bde3c8f15c6c8378a12b5b973d2be3d06032d9684c19d75fd94f6298cba4eb8a3a1dd0e19d37576d695a92b53ac41fdfa6bb3cdbf47f01758fec037dfa74732ab6b2f648688cc5f29eb166102b1d378c949372bfa606f665c30d8a2fe20b8d9719b04cd11d507bcc0044ce424d8b312c5ceaa40d67bce9e82a8c8c9ecc0b711c879437f7294740f1fd1c675106f982cad4a285cea453acc1854400bf8aaa063358d127c278ebaae50164e37992a23cc3bee6148d7e78f4727b6f6b2b31c4178fef2f1debab3c8d405efd7739d3ee8ed3717bb9734d216c5d085ace5d977ebca933b7cabd6155926b87a4f3ef4054df553686ecceb1cca64889440f8ebfb793e86fca897016b6565fd28a1aa454e46055932eb483a6800e1c02a1c20fe211b01534db90cd513404a35be30026a099152018167a1572b84ea72630c335cb031768555fdf2b2224826792f5009ac550bbeed799a6e241ed136c24facd9dcd6121824fb8134be310cd9a435808ef047e4faf40358811dfd8f897bf8370b08d406ef981b6c97954178ca24e8021f6a7d3ff1cddb96c3c297221511781c6a30c5d2a5f829db37de214d74d36856a0990f90b2fa7311f222f6ff278bbb6dfcede67faba8d2d5a1d819f8202f148a94f71e7895738422b031e3b6d33c34dbc71ee1627cda16eb00445eea9652c1436c12f79d55d973cb3b72fa08209c910868e917e3e623dcf508a225ef10c6c90f817a7973df64cef1d9285bf5479dbfaad52d73a27a6ac6b1aaddcccc52d1d864b23db690714ccdf0f28bcafaca5162d26469e809abf95574a9decd2eb1f1d4b6bda3aac777dcb2a04cd9793a11192c2b5fdab53549264c508a56cbe896418cb672e70c7892514f019ea825a64f3b9e152f52ab69c54fa839b0149984965d4587be81add5b24e2bd3685141ff12225aca11d713d630e85a6a87dad0dd105079b9aa0e4f2e2903ce1d6b0526ea63c9b2b94890782e91642a6d59577106e6a94c2ea445375b66fb05f8a8b3ebc3c0dde8c2854ff542d77a0473635ffe55e96803d42a80629968ea7885b4cf0fde716650dcef2e28faeb9612db5206d72adbad0ad6d1aefaa0627f935c710186caaee4068b51c0ee5ecbf9e35567b9e919e3d2e1bcca0887db664f998e00fb7ae2bc30e12b19e4f90173d02f9e169074f4f7595a830d99dbe02c25903ff49ba7429974d1c1650b4e991a7c127ff84645e05a7c167fd58faafac46802e50dc7a290bbd446bf2ff5e33698e84d213f8fcdf523469d7d0b859e44c1a5b91b9a39457e6263b090b1e706dc01b2d09e1f348a795ab5acf7f3219fd7445541143252bf30943d5d61f718dfa620daa9f0c209dd60657ec3ce3edd6eb4fff1d1400a9f78dc518fb436ca1c629a1ea343fa6b6291f237ffb39ed68bff655340cdc10397668e983962100811f6b5299e9c5dff137a79eae3901d8c1ed6df80dba15e8a2f7ef4cb069397518d7ab47f3cad857b731f6a7c27142c11d68383343569aac7d03a4a1c1613559403eb39a4c0bbc5c77629b2141c040b1098fb4d55821222dd9b21146cf2381d28f42b068728c67e5b4fac8daff85c486a528eabc22af8e677f6307eea4666c913f8667b3e6118ff4fc825bd27e9c1d10a80ed6a0e30cda5ad1ac57df4fcae4a08f0971192f3473c6e8f04ce7bf88b3c9e8ed5b61bb43421952682eb45537a4a1d896ce4496bbe97342999f8886efca45ad6b36f4a939fa21cd9100a45a49055a2a1ba3061d178bea5dbfbc334d4a5427b45dd751d8365552dadc33fadb77c9d3f4b1e6415503a6faf0941b557f0e596933071b82d6705d003d227f120e3e9b7902f0640a5286aaaac1bfeae92e7397f8a0b9ac5678057fe4113b5268c5870754fada79507ab2d6c7f3eedd4c930975aadc0eec0f3e68a8869d7e74c0b7ae6ea8ca51e43153efa3f34461271f02e5b0ab4fb6fc17c570c6cd0b08f0a8bc0d5071d2fed490e19eb4ad28b07795731078b710b11ca4308407308c724186546128ed839a13ee2717b069cf763d5b910db0c66007b388c63727ba3f5480afb2d089c3bd90857b34ba9b84d45707b81d513ecd673bccfac1c4aba951b70fc1eb1b72837a13cc134825848dd8d068d7589e43054f69a9f6e33427b57f0f71109a10d72c6ee169f80282b4b1f132856368377e24a3e81cc3e228912e534dcd2bc157ba7860421bea8d6b8738535b7dbc23d9cab4979919674bc8edf78ec1aabbaa8468cea7b5440e2bb12b3dd781573da8778926f6a616b0692375a4487822a465fe3e1a2ce0c5c652c5355bf6a1e1ce285c44d22939afc01d7289d0677e56d86abeda698580947f0dc9346af9a8d42cb366b5cc94eb64a233d8586118f5c387bff11146097937a4e759c1fba28b5c78018bcf3a3064ae7dd3deb9c9297defaaaf7db8a9216aa27bce4865bd62db58c9199b34f902a4c665ca492983d47e6e837d04c7cd928c48b158f8513c77e4badff2d703718be374606cd0a12fef21455eef331251cc8b8c1606fcad81fb111521a7ac50f16195a09ee9e09d951c97e8ed2d39fb1eb4ebe9b8984cb5348a3a8ad06ec7331844dbb3c1699589060d47dcc89f555b9a1f0bf8802bbd99a6af38a03f1a6432f86ad03a01d38a2400e5b5457d4d4921256442102e0957ca03239fa1416eab668387f11ce7c1c404e285d8a66ebbdf6d32639c22f50c21f061dff1701f6789326cade14c704b62bbab25b41e73e7af7ae9a14ed6efb83fb0a2386f370909babb2c3c2690b50fc4dfbd86fcdc84370ab809be955dd326ae903e865bff35b8c154affeed6f85023d139722bd9774c8564d993bb860581cdb52b5899453c2825998e52dd6cacb65db37d5202411453564b7b088cbac6b269396ebdd132b6a2e1790ab13d241076b096529d3adf2dc3e86d62006748add77b02799606efc99af2777bfdc2193fd8b8b450b7f95dcdce8209dad5fcccfb071b35d029ab9661a651c47aa851c3f1a8e647bae75ba1cea6b5d1a1ebbd35a3bef077822db13a0f26341566942be1aba93602c2da2cf004b1ceeef5a51ca2f2cf36569515dea8ff57c4f0e64c24eadb6e23e88b8f9c60a3f88c1740c0950bdef88612016e5eceeb2d257682577d9b359955ccfaa2894f20376380e4ef4c1a010593d8f747073193bd578e621273518053d140d91d5e4c9a784016e15bc596a0a99d903ce75c7e222d4ad40816a2f9de4ee489905e5180a2ba1d8e95e7ab0e643486d6547bb9e089151f67db9069418a6bc5acd2e1b31470ff388c848ca76e6562c79901dcfc729158baa80d93e8f50d3752e43574fc3b31408731ac21fe3bf8aa2ee8b5335f85f8ffe155092a4d883f1d53953e66e74e77a32ee31cccd4ddc82ea0dba95e00b0b8f95ba1ded8c76dbfcd90eda50ba39fcff8b72cfdd57b024ed8a4fcd6d44d1107003d681a794db774e6c70291d9c49a33b3e90e09a35143c1e8305d66a391345fd4e96873b37e1e1c71ca8f972b8d4f7136ba0b9cec82f4dabe8ddafea4a6746d8813dc795bb5cc685f4b91f15fdca9fbb6ba8003343255e6eca1d09cf2d9d5e519a1518dace1b4b14f4d1fff39168a49c56f353deda0e6c9242a8dae77ef0c4b0b7c662b2dc2aedc09a7fcdb4ec69de3c726783b88b380275ab141eb77074eb0fdab6703c99029ca5ebd8a3c0c786bb1cf1561f4220e60539f806e5869da23f26b13971a06871f73b6bed197b6e4ec972f9f07644ae2d909ed5176dea62c80f6727df5cc05f2da254399a91e24cf24ad0ee2aef0a38b98481cb97792ba5fdcc34bb79957371e70e342828816c4ea5d1ebd4f5e7eca9b8421d886c5f2fb25a6f38a3ddb8d41ab95a2e07d3681dd588b17bbc6dbb6c215cb0c111e387ef260f561c0493c16a617fec9bcf6131f6e835a5c8630a6386173ea32125bf3ace8a649a366b98873c87f40cacfeb2fd40e02090eed53511ad161c4d4d1febbe64b733ae2259da8c31e189635427a28460b73f47b4fd4581037ee33024abf7da176f16d8af4f8a96dbd4d553f62e8b468627c3a925c7be799933f4fe178339fc7a8de678f26018bd0ed912684d066de1bb8ba9018aef9b9adcfb0af7630a246eb453d7dd64b7d87df4f5682046b8e7b9927c17d89de4f222c07bdcf9d8104c8e32146ec4f98d37d65f15c04b9415118815fa3857e1439e377d4c4b33b52b3b55114ecd51bbcd3c6c63c8af60defe88044cf18bc4ed6dbb75fe0b50fc93c0b7c0a49eec0a70627a7a1fe188bc6208acd767b9cd321cad6394dea17dd7bd0d3047f6c8ecf9fe42705312f76c9cf58dadb6e496a9df8d83f54f6747dfe98841647cca531fc1ba86fb83b372923e136a03eb8a4b19896ecb6f622bda4f72a824f6965c12c42c9962027177825158fa6b66d0afe85f599614ddc8025f4a3871aa6001023ef00caf03c692370033de3dea4288c2f21b00cce232431e6f509795aeb86059785a9835fac87a143f10b97a49960cd1cfda44bc04277e2505d35bf2f55ca0fe455df64bf2f7dda9cffc32ce3c6f48c22c21868ae4b7f83f7957e64cbb6c7ea9c0031bddc4a0d8dd0e12282d8984322c20914279c92f98be16bbc0e9d236be4665d9c537049968dd652c3286fdfbfba97739607026387cd0ba87b3e6e8177a968a00b5e2b00406b235384f804228fecaf0cc0aa86c6b4be742664bac03d39a476bd11ef2bd2c37b1dc7dcac4b621a7e12b7fb5344b91916f07b78308203d803843a753e391e7b0d75bac4756e82eb67874cbf63ff6805a850c4b5527a64befcc7efd899c56deb39ab205ca94662335c052131cfc354f6a68606bbf342398ccaffd39d76deb594962a5f81249b0f61f4465e624a7223c7ba4ae9ba27461d082a3fca3a44e6603399394723ab259188d8a3d56b40b376ab7281f034a2dc0175d1148101443617b5dab24c5cdb185bad2eef3f09fb3fb523b1f95729322d95ac67aa0fe96f9619c9020c178a694a74d7600eeb272941d96f00561ea25c6431b67f434142c4751ad7f5a66312c2378f23a5444b4f062587b1b2fa4355ab62edee6c7532c9700fa942fd782498532060a65a1c71bef953fdb109483957977277d763548466731cf3159826f45d1f53a0468d47394fa65f268e1861cea19f9beed3423e4c6f44adb9d62892c721d83b2b885cadccb9abe71ee1bab7b82082c50b24c9ae0cd5ecbe5b7a947f819ca10d22ee88c7cada0b8276bd4b11af9e281da9db88289b6c2924c573bea484a487807d046cdb2714d8afda2ef32e6c6716f01a04ed9687c83c60242c20ed3aae42d4597c0a05e56e962c5c3423dab44cc176886724ae7fa1285d58f99146b8c1ff47fc82520de76391325b308a69223ff30fff87fabe5aaca1d1e2c16b767cb6f7d1c3d0e702feee9781058d77d9fee8dbca2fa4e0c237e5bdc2ded2345f69f37166363cabaf5d7606fe6fe8c73874df19fe6a407a8e43c470f5352497f38bd5d1bd2b1e6e77d7d0d4e127aa84a90dcd270412854a7a0accac04d945ed90cd9e5d1e5237429c60119c19d7dcece8d439a40629f21f7a355b65f03b482f5517b715460795142969691278f74a3f42ebcfaefb283044f7c13f6db7e3ae1c60ac656d8d5419346aafae4c0dd52dd9e5d732865fdba43f89973e04faec8000d32a5f2df6b387aa3f85065a225569cd2222a7ac7c5f41c7b0c88869b7c567b00f5460ebbd71b84dfd5f5421e535f92c0e0d0f5e536eb36e1e35b6d0d8827765e3675e6bdecba6a8dfdcab68490d6137a3072af8f05612e12aad8868fd56c0f2fe0ba830f2d00f4eec76ca4b4cba12948672baad22514052eaf12617efe9b2784ba594be1dfc8b3b0793bd07ca58340cbb3f0901a48451c428bb34b517728085f692d2f62cbb4811b938aec38f7b9e95e3958c658e9048a466ab5623e8f7b79f24c185a589b55ecf0863d2de41e133d730000137daa3b4da444d6f2e1ff503d8f5ed362f9c20563c1c166d096a70698b28fe5db7ec11049794ffe7f592161d10acf35a12df46f5c0dce377040b63a7b58cdea813f7fb443b44d785df92a6742f0ba91f46fdbe75f7b2df81a9140a37b4f1cb6d9930628cc17c9ee5041c5e7da58ea633dc7e0be7f66d058667bd648489a68569b9086a37daeddbff2fbc308673a73b4bc4a52c5bbe12f34b05cbc24b70c5b198c294589ff7ab303b5d34e9e1044675115bb3ee8d1d034b9e93ce75ff03972f7099ba6c6eedda13c388224c7f561f1bed8cd9abc3349414c8bc19fcbf53b8b6c169fce3be056f8f701f4944774ba73f785bb9b397bcb4055212a3d575e6c7e8a57f49d43dddd53d4efc0e36c951c29aab7ef2f5ed7a801bb5eda844a868b11f209f691175ecc94431b68ed995a85e8b747028bec09f926635602ec72ea074b737a1051778196605f183a59dd9fc00216423ca047a964154a04551a64d8a5b8ebcb7fede2ac3d7b6e3163521ef3e63b55f6974ea16a9d0b545ba0ed10929a0a01f4d6cb9be75c26a9c690ac0e70eb0ba07856b895b64a58247f3e9ba6e4a220053692ef5d479c85c4676b253b189ae19c2e0a3cc20ad3844b4a1565b9c3c7dc280fb03a79a02825a0dfa83bda019a51b851d31abf0f089411a386a1407ec10487d49cd3d30c8945964768ef4cc4149e16380ac5a50af634d0384e49eed51ebc64c37b2e6c68e7a1d1926856840d2513e1fc2974d2727f9c4c5c38617ad0d76c56593d453ca131d6a776cf2b1919387b4758e2301045519e67acb2f9ce633c852e0f20e318f26d874bede90a7263745036a300d0cae8088b95822c22996711240c1950a907254677c0d564de9ed958551ab2d2d6d5b6522fb465b911eeb2348baa8dc319c0bf00dbc19fde917fd3b6cda58c88d1d1239102439cd75f221a9c109680645a1a7fc5c9f9b93b4f50ee501d5d03d4b21660d6ae7a92d7c60c3f9d074022786f09b14899971969c666bbb20212f7c96581ae85da14647b455e33b922eff2034a09e5bdd42b151dd1d43cfbe76b8456f18c34e6a9dfcb0645c4fff6e1db6c9a7ec5aecfc293c186c5ac10768d3ae1052c2f8968920f98849469af206ff4eecca59917304ab9a2490f8c88abd9967e7d81f7cacf5c33bde7ecab3234060e12f7bb07235d9cd132a379a602acebdbdf3f84243b4049c755c8f2e51a07e77f970e9abda460716ea2bb0d828170fba402503b3c3f1af0df8c1ee9f5d3650d92b50deab84e0ebe1e5ca07b87a9d6c9612d0d0883024d33b03a77a052cec3a44c4ee83a845d8ee03f5f7e8477cca9fb6c92a37e0706afff43eb63531116bbd7abaee2fd7d5d41faef704ae5c92b96738d6c0d4674dd110d0b0146b1c5a7c728c072c7a044b89cdea7f5e876a310d53aa06f1be392caabb0e9f5faa7462b4895581b2ef9c4da5d17dcd2e2d427cd70c1785c2094dea1a7d21eafd3be263e92d7448b2dbeeeef8110c64c722005e003f7657d45eeb44290ef8717e83b400f6fc1aa73c11dde669e6397e7fb979c62af8b4049e015350ce4e3c2b473b7d12411cff8877c8117bf5b716f3b2bde9575ec509c162c978cbd7bfbd7ea98f3583ce80567322deebb4193303ce70d1bc1ef4b84641185ddcf3b3953be5be0e3fd5048f4c087ed894e4e80ffeed1cd74d58a3fb0a0d2e4802f136ee40e642a6180713965f94952e30a13ac87d36d4dbda540eed2ab11ea97d44042efbb25030e9b92c949d9f37cf5094206598b35b24be8552ddac10e8e85d3ade57077eb6a59e6a03bb327c0f7937ad6cb3fa8b30eb1625997b7f7d8ad2154295899585c87c4c869cff07e94dd1cd1a8e51a0a81b4be64b58b0fd4892800613ae29663a0ab74f7dd87946535763c232dc4105f95f9b2988bae6fc7fc41aef8f5c1c13f40b83d43d2170a5e3103fb6fc17df538a6438ffb004afa33a105920bde5b22cc707782630c57dd629e7e176a4a41c019b47395d2ece2d56123d92bb190b0a9b287c78298a56f4c1b8121cbb618f05e3ace9f3e4cd5aee31b1d1a81963123ca76c04fe9cb31464218c786ad3d144fd38e07b0de49c9dd350666ba79946e894591572d8740dc8585e16f4206f9ea35a8cdde14fdd4944f014350c3914852a3671313aa7de29c639e7ac9d8bc1f09df98dbfe1e88e242d3cf0c3cda7f798ab59ca5b659b43a463b00e29f3dbd8bd5b456cb115fed975c2d5e4164ed2354a30e297da648d4e2e190e8bd93b1e833f6b3f27db7cdc1572479832fb92d16cc635ba36e31119177348679462abd9fe617a1ea26368b540bf5ade0698e5abef53cf47db555413099a20214e6e45b0639b473ab7d520dc84f1bfb1ab31f7c80a5619752ce8ee89e88ed073d7e298eacb158951f344237015881c6490ea19c008cb9a91e2dcc26d1cf33e20eae993bc4e099668f60b47c50b0b7c37fe1eb440cda1bda6a1255b57a652c659b93983fdff1c2341724f4264ab5ede82551d04e07f5849ba15eb852363a620cba43fcdd384a7afab80d462e8a7b73dc8e6caa7e4c076147dcca63849ae2c11891ae7dbeaddcbba3e62322045636c31d40caa2a10a908880801e472e278179e2621fbf8540667c9c9aeb909ef1d2e6becd4f039011651813315263792c516a6ae59dc899e9af401d7cdd51838e2ce354a590ccbf781d94101c8f770f7c4ac02b7247ebdc3c668ae34f1f861688d9771309a38adaf91a9c229615970c4283826fa144767cb9b48d888c8cfdb5215e2fc50541cebdc99ef66395ab7a609b7a044a018f3c478790fdab85078f5671db25a62ff21fdee2265611aeaf3ec24e04ae7ccc20fd76bd1ea874c895fc12c98ad4376baf89329c62c82671287eca089562a0bc5aa27976c07d88fa2f02161424db8aec4d1e1e3d02a14a8035bbb96adb392bda738796842338ce800d71e6c1eaaef22a4dcc5ca45d186546155347633531b1a6861bad1eacfc745daafa9ace7a5bdcb4875cf24dc9404977d755f63425112afcf2a8b378b4e403c5c3c80aeec76caf45fe8da2af98adb7245fd44d9cf2dedaaadc32c61fa3373775216167449723d7828ea4f435c5317993693768c56167d61a944687f2a93346d12db489c0f6f827e8dc08736b88a7d855f47c0552bb74f2bb41106cd8f41a387e4fa89fec7497e7560769a56ea00d4629c8ed033bf3d8ad61cb90584c242810e21da175faa755f0c690264689d8388467d0753bdd0fe57460b541a6b9416a492e398eee368a6569e5649f78caadbf8e38ef9d9a472a3b0860039d6412206a6ca707b1682c14f629e4d345e35874aeb4490d0d9bf38f4101c007488a2d24d4b26fe93a7fc5b2b49143e35123c2703611df29f1165320914325dc272ac77ce381a5032723f2e6db3b43af46cd5c76b8104afa73aadcb139a6b49977f4af4392f37f05d71e5fc778be40f1bc7bd884263814d334bd1fd701ec9da76ff1f54470fa7df6a8c133c40154c05348fd8c100cfb5dfa2de4e7ef4519be71997ae89adccc1610995853fcf65cbb3c4d8ea8e738ac2ba4e1dabe011cb16d8ecd24e639b83f36bc748df85a8955b473fefc527079df8f0bc2970389a6ea7bda2e7c7dafdbf19b54d809cd7c7e7a54dc2abb9c25381506744a7ea377138e8a9b119e66f436ca06880d0ced4f71bb885b74dfd25bf20d5252e548ee00d1d17065b34199662213a7fe895c1ffb3502a11dd646e2a9888cf155d66b31723d926d6a2a3ae4639086e72d243e6586a52fa6e7578123e33be523e8cedb6df1d806c8e9146b8b596e7f1109e4235b467398df80a85d2d1a6b1c1bd8cb0706c1482ebf64c47e0042bce251c94c570ae9c2ee9e3496ed5ca9cf15bbd439d69ba284f72ef1f659a4e96c9dd362f2a989cc4f431f6d2cf2485ef975228e5d75b5f3e8e718afc16065aba7d7956f71961a1e99feeaf953cda41ea527d25083ec0020bc3f0d8fef94c3a835d6a4488da437bf45820a1aafd5f661cc630633064cab430cd9f640ee07fc5dcf20d8d126d78ed8192d325567880f79901a8375fc843074dd5e28532aac9fe69effa21f7872fab45ac4bd46e16dd20f5086e03a097ee102c08838ba0e44380568c86cb5e9bfbc7a18d105e41d76108207b16ffb368e8ec402c932976a256a94510e12e883838c59b3ffd345874b71140e2c0fb5392441c667439be7bafc7510e14b37424c7a676815b7708f6f1dc31c06d2ab2339117453ab3e3a0ce78aacbb0a06e3c06c7333c88631779615492d71109c08ec5e3f9532b7feca2f3c9d6a7850b0735dc1bca766a257311bfe4d4fd957a418350fe1e0fc58e17adce6748ae785d5263472a390327bdbf1d771aa64dd7c570c03c4aba4e5e42999c974607acb96dcb7a1d7d21911a91db83bfd487447af0c51af116d4502969fdaa3801a8f3443746b3a223762aaf6fc71171fb7cf3038befa3db9bdf2ca853578112cef987393d49087c2a882d41324faf22ca242206ce878795d5e241d030dc377c5a891e3dcfe60174b61fa7b878c8c5c3aecc139d29ce2940b67a0616d406224a1cc887f7b7408baa029b4424426ea4c3aac8be4540c251fbf26167ba972c4557d7684d26924164a926245385611565f720f5878b0a107b8782cc124950f7e133f5bc1361cb57816f488d3e60372647046dac11447ab8fe94fe1102b678c14d48dc0eeaca8623a91ab7aa7321a83f94afbb1d57ff2aad2823182980fd14711ff99713ed9539184bac4536d7176b4d8b474ddd3d0d0a4ea22cc27a962f540156b0f06fca0a2f003e246dd5eebddb80d84119b9056878c97853bb122a5ef8e9c2ac1920041474b5506dde2cd3492aa48d4ecb31a8a1192ff94fe27e95b96f7904b80599db8fd75b968ee7a43f4307cd34cb2b3e54880f2ffdc949b0c3c3d54128917c09737a671fe9aa57448ff844a405a6d65e23ffbacf390086a28a4e375e56b1af3aac993015333064dbccec6168d727e64a8397b8a25ae8bafe70fa97c09be26d39fafb1e32788e1d40aa6456c8ef7074681029662a096929f20933e17a3272b477d1a8400262b9795d4bde0ac5d53506cc5aaa0d4184c7763534a750215e097b330eff8b852e4fe55d5432d982b5ca8b8b4b4fa4b4f091ad96241703f759b1b653897f3380c96c43e2b3c71d4fed3227000bc36753be14f4d3d810c4fba320e98f17d00cd0b4a4924bb9d2456159e5adb7190e7fa0e03b068ead79488721bd5de2d54246e182d0fd36d7b12d381f1b42e4cf4f932990be1f1f3699dceeeec2e18973858a05b3f39f35779072feca0767096294dee32de08af5fd514f534c514d142540af87602bd01594832bc7dffaf62be90e7e0a48c55b38ea95f1667f7f0cf08f44c6c8b31a1bb130b05bb22d908204a251b57506e352d7b51026dc9a25956e385a1b94e2bd36c2d48aa1316abf20392d8401e5763e2dd7b7e16f124c84ebf3b79f29dfc5be32713b33eb933a3a575d79b9ca8fa0485d200536043f88bd73299a5f657c2e094226f04ca0475ed15ddfdc518f2c5f830325a52964c9dd03479a8cdb68af01419fb31c8566872b1a44dc6c0eba89d490985165b619db9cf29c8872752bd2c2f10c05eaa564a45fccb057cbbb34aa6561f7d747b0d842628e25df4efe5e5324e5d2c897fef6e36d6a3a714a51d52b28ecb2924fb7391c965e641b8b66cfeb98bbdb3c964c8cec13becf44b56ff9c3e5c6d6d40fae1eb21a3f2baaa3110c9d79bb5e392c5108d613a9f5de642bef56ab438b367743c349538408c2cc1149c5d88da4ebc398a20401a97dceeaf93599969f680c966b8830b61ad3f0f2d95111de89075b1e75cc3928ff41480a735d56e59460a8f490c38b057b63bcf1a2338337c6f90fd771c36ed1bddd2bc6cc73591ef8bdbcd73dca0b6878f90fa424f5d665da1af6029cabaf13b5676ba2ad241cd407145401a8434fa327f1bed30623fd0cc57388d00afaa0e0331b3a2a72445b578d8e86d768a38c1bbee609d989ed3a488af9eb8f22c9ae68f682226f54be0de87c9454f92e5ee978deda2f16d0af1bc336b628e339e8e288036e4aabda72c021487c0f9f00b47e4c9dd6efa65a8457b5e7eb35d9bbfff687999ad659c89732a7003fc52282ef0e78494dd7b9b0b4f9b5f238062899cf56e145ba0114df220b112ae86a6af77b1a784b30604a2be12cc94043324336039830cd3530c0da3d032523bee933ef7555bff52b93e336f5355df2366db708e61838cf7be7357b4193417d1e2f91dce0e5311f8386beaa3ecc5f782d5f4ca4de1df91a8ba3ae852b8a08e38e4587387981726319da63fcb7e3ef3759823afe3d2cb23ba2f535e543e92eefe92daa72ff85faa4b2d850fc0dbfbc42987dd63adebd1611892be58bfa57a67366a1f359ab8b43cb8e75cc33887ff0e6649bbd40bcf3ac059e1526366c715e586ff00d3aa29452d6e08137405ab0777eb4448cb8564f0d90e659eb35158f0335a6eec646e5d1e34035ec4e0cfd2ce1017e3d0dccfccec4fcd40987ec21529912887b6773702d84fc9a10b0df3430c2a50e596ca8c45e99d922ec9b149bc1e0495d79f207e39283e56f5319cdbaeea8063f6d1b4b5b929322904fced3294e883af9c727488d21e003f288385b349032dc88c53b8eea34a973912338cddce049f56089c412009b35e388221c4c214f7ff4e409868bffd46411f55fd9a12fd5ccde64bea8c975bf1116c4c524359bf74bc943a38edf00e73e6e5ddb3357cbad6ecaf99874cb15813a125121dee5d5d24724e22f4eef506e237de9217479bce0d40cf56a41c505a2018d92ca505219f352b189819672d7f5d053f6b25aae25ed1e24dcb9c52600c55a5e9e37165f07e39a28e9fb7839bd2b0c73193764b96dfa61700c76f494706abae0d944a6bc66590042f8a2f3459ff7309e879964ac408f76531abed258ac535a21c0616c7c2472de253a0f668272d2d0b42448564828ab49d36be09e8ab4cbb3b8c56b608af17655fd9ff92b4b0845c37a8859f4ad0932216d86bd2b454cb7bf365574d41f64c76e34f3b1879aa31e7da2f685df10ba303fd2c7993915fbff7ab10607c1651a9664f8156ba7f70861415154250cb1aff20d95ec5aa5818c4d42eb18b8f010f43364dac20b3aabd875880f5b969a3eb4ecb2ab603d24b123e1b18bba7e4b1424e5b1a2c6c4bb5cab6b35fbe9810f18dd764134caaed3316d4288d5f20733110ce03f9bb0a97c35cd6ac558f30e4fa259c2f67a99c7b64cf8cda0b1cf9def8a791e8c3a98ae9818b7ae5bea10406c86cc6691406901141ffb79afec0ae12cd2f7dbdb9b2c331958e15d60c73537d7c9682a72ea1c5687fc6875e56c19d62d7042058378faa27b6c2fc5d8bc263b7edb968a058f0682ef531b65d7a3b213a68c7fd6dc2ac180e24157d1ea1633bd86b93c96cab2c379f8baec6b00c3e1470f73ca4051b68c9a07f34bcb4da616c3c005eba73dbfd58b35c2be06de16901e3807f0d65a4c4d30681a1cf6f6a24ed3abb7cc5cd23fbe74073566320710886e0b3cfd6575b67c2b4a1a9c2b00d81f80ed06de3924d6c28fd1d27ceecd0a4ca62000df31b18950b6905dda70e0262cde60bed53d204e8b638fc6b652d4371fe8e02706e883c5e8c959806798e1fc2d60bb382a100e686debb45a813ef780a3297db18c2e09d62e54d58ebf2a24decd04f7b431e81d95409fc1e4652273ae6f1ae05af6d140f71a91aa19d6ec8febf423d9fe34cf03c572084be543c09589a25ec594f4527de5c547931b26d7c8a3bf18121fc14f7a501bb51dc4ddf25e57be98a4d0e916cd8ad2fdc23bb76fdfea7a217d95c2a55a0f59ab6c6dc77906edaf85b329cc28994d2cf9d7c371061fdf499a8d6e2c0539ce8f82c81d9a5aa53baf6a139daa2a90bf64407024a659e9098142f92acfa0df5c8f0c940afc1eb4d8c9d083a761b50c42ecd0db89f9a6ae4a94bf1acb9e10c2cf7221fb9c9f94b226e20cb75ab2aa0718c95c7226b20fa055b7d92d4e74f82e8790e7864295d770a71ae1e96d674b3a90b25e14c2981131fbd2e5bf11413d641b3871ec96ae6b953435416ae87ad1367e2c21ba38925444a8ac2f702fdcf4218f173360a7edc608936ecc2789217c03cfa933ee45f9f86acdff9a94b29b7f89568809710cec606418df5b2245bc269d9ae45be35c14778872aefe8d0d225d19d573baae8ffbfbcd91d0fbac3bdfa62538e2fdaabd1e9f102c69b488fd6dab93dfb3331c3228075ba434e12be7520cf6cfbb251c9e1eeb49efd388376e82115ec5dd2625e63c639ed07bfb94bb02545485c4fd7928553aa629aa811d876abb98dfb4fb82eaf649d54f21473998a5ad7ef1b42c5660086684605059fce96a2d424075d22e82d191f487f5546bbd8a774ba58ee7f35da27325dc87da90353b74968f73cc57e1ffe054acc65993340ab3d83848aaca1ef20403c53f9070c25743b3a73cd65cb92cccb4ee969f9586640f19a01e76e060391fdf8bb19f37628e6eefb367691cc811b5aefc488030363bdd8f0524f3b65ce4bf9b42e08bf23d5857c607ca90b00b1606c9439b2d2d1fef44c232bad2f2fa442b537cc458128a2d9dab023053395f6ec735772f703b0ab5cbcfe042b3b608ae5b9d9efa23f6f15daad0b72f328c4e755ca9903e7ce81d6f8bb5e7ffe81050c8368fe57da3c2c5d7b0226cab410d3b1a0f748325c33438c33de2a028cfe4f7867241bd9873e77b3d6afbfc4543a8d0aa93265862c3475a71f5947362d333b038a3eb3472fc045015608c4119a6305d3a6400d2abb9b53aa621fc62461de6d91c6f99e31fb28435d74ebb8f022aa30f1e6300ca47484c142b861a9ba6139b9ac93d3b5fbb74b9bf89a435ced3b4d75c4eaf2ce4c0bdfca40a9e1d7ee013147cdfba88df46d0761691bd493fc66d462a231955837a12aed2f4c95c541fc60edf69166771e5427020ef5509cc242c513a7e55e192c7f1b2a8a81162eb7891bb23e981652fab75ae55902d4c7958aaeb56ed222fcf65abe072c024c3cabaebb362f5fb6fdfbdeebcae693a43bcb5bc854cd031505c0bf55ab82f76a9a5ef315772c9071722847ee95159a6efa6312aba6229e173b598df0859e8624f2bf41788e7da0a07e0b653b3d21593e326afdb44ddea849a705f9062b1202c620751927f8a01876b95776e6e53673945dec3217583f5025d9f85faa776f24eee85aecd782e29370c267f85d2a77a04ec35342456fde6814593151d78829857fb171f9908a2318e5517941565a67ee3b05bee3abc5857ae85b49c07fb2cf312525c2a9a7ca1cc0e19090118d8572aacc9ffb35bb50a8cdf23986dd6a2be0d3a838a699f9aabe579e6657c615f814696305f818135a71566325c38e867e7c47ef4c0041c3a7158b5c10577b0a021d835b99bcfde0cdd0a03d7f924a997b7d272a800b13ccf84c16b07d4847d7e729fa0687853381dbd071de606bc86558276d86e73d9198bdc91939c2c94496a29ecdf8d0842c1973806839bf0b4be2458b780cfc120a659602c732ae11da10e0e2b314b1c213cab3bba633de71ed41533be7025c35ae8cfcff5cb7950d00d66231c105647c24d0a630c462830ca19564f4128318b47deb78e6ab09a3710231e0f021630b1d24d183f0394114ea7e7b16c3dfa84b55fe7a69f9497150bb735733d112a7a06f7eff034c45f73dc9cd71bc1828429ec4142a3c7c115015a486522ac0637e19efba1e11c884e7952ac09cd9210f431a403ce1e919a752bc219895ef17a1d6a504afe619b70c6f847e0d1f7543c4270f275f0bb99b13d967f27d43f9af7a3b1628d1f1c091dcb395b86b9ae25fdd917b4b696059042245d18acd532fe55ba737be0c347538a3492f027af19e74fc65b01b7cbbdcc63f5fcdc974d6e7eaadc1028300b37f8f33b849a3ad69cefa683677977e6d94066d5e5f84b8aad4d21acbd92a188a31967a5817149c712641bb00cf9239c89727ca6508df89e8540dad01746aff75022164b965ec1f2452e70777796d85e5adbb97d9d244b7ea75a584e798fac8c167214b21fa99a7480ca4698cbb9f89a252d6cb41979f18668dd17d9771a9fb90760efd42bdc246c6ef962830bbd64b9aeb3194ce8393126b921da1a01b0f90c9d47eb9227b8bb05f459c208bd188f71de3629aab400d20451f4ee76a7bdeba1141174f2fcc5da9053da88f5178c4af4af8bf4dae1b1a9e1bbd94de6c998540967f5a7fb99e5518b86730686b288b735a78edbbd3f2fdcdb75a90aa762d66b377db0e29efd382a2a9fe0f6314a579a851d198d5d2ef9ef7eb5cc53037927b809adc0f57d519179a29fe272f47508d0b83e335e82fb21bc632d8ad151a137b10a71a99296bfc295b3535a1e9a6119eb3feaa9c0ca1e4d6587c31f135497f131112cb325566a30b3b3bb16d2695902bc2c4abacda6b8c0a1ff26db788e1cb5bea484067eb3d8306de3127f124e3cd0882eccf407041997163c1ad825e26bfdcd0cd88fd2647b582dc4f39ecea1d86fc1542e432216e3a06c30d00c2f99fe89d3b0d7ea7f58777007ed591b351c945c7f32c1b9fac30e58d1ad0d2f3528d62f2579c4f055dc077a791c7a4b060031a8d2ebbdef912b0651bc74150a59c8e1a2a4c534f2c092a39c3f64db76896dffcdc06ceac5faaad9a133962a28149feca59779965c6b47aa764863270c80b684f7eabfe74aa92415587752e5ca9d4d8ca0608a2353f7cd2c80b3b481d0458ecc9a9bb74bacf68ffe727858d3b9a78bb083317d6454d5e24defaafef1d5ad15d3cfd439a824df6585f8bdd6e31b18ca7396454ed6fa62b9b114983ae226edc41c1cb4e021c991c13a99303b38aa15779fa69a398adef879c28385f87bf9c34431480a5cdcca38d21c4df125472a615f16dec693c40982de7463296240c20245fcb635d91434aed20830229505bc5f821cbf627af7655fdf6f118367515ba0126c41cf62d6de1825980f3d4563fda2c685d11162637acb9638aaef6af56be72454df480e21bee3b3c7e96778ff0e3b9e1ad6cae2a4af6df705b55f59044c4d17152fa1ad2e17edf8bab4efce65fd3bf4e8cf1788d71bb810a2fbe7bb1ffd79b12f8cea9c1746ffc2748311f923208e74420f6b0b79298725f1285dc0cd439214cb9cd7161bbb0cd50c3068c05449235707bcaaf44258f806a4e01f9c1b3b8537843248a6b685c5b701b6a6b2caf6c4d361f38cee6be79f233dcbfbc05d06ff99437b9309ebecf1c473c7ce50be0a45a01551b7a93be62a2a601da13c49a586daec6104b304f71a08536ab31fb7d725ae71a0036619938a4f4c7beb31222ba36b451471470c5eb2ad7b618b70426aa49f4bdb20009a030e566ca967b03ad5c2fa05a5b6afdc7c7ad9aa03ac52a3a3fc69fbd28568a6899eac6be64fc97c2381841959313f17070998794d068fd46fe45b2e8cca49f66c652ef653b22301ecd02893f2671a2eb871572a289ce9f14045fe832b0e3a18287fdc9ed3fdd15134944e7b97fa632ef164e838775f8befd7551ed92dffd85b6b13558b81cace44e1c90eeff742e7cdd11b6f9c58e89cc8d4ff9d5274b89cb957f1da17abbfaa3504a7b19065bf37ecd8b0615582849152024bb798a289dadfd9e3256dce1aefe7f4690b6445fd87a0a36cb70d1f662c629a2d69d4386793f317c62a03bee6e2b1d07f580bc46c6a37dd369e1e74b4af9ba6c4555e7f52b733abd7b63f4fcde2cef7b73b0fc4f14472bf4b173fa744cdb4574eeb7b1f3b5ba02314a565e8149ed8b21a8619144696d5a3bf09279167e9592c916e242dbcbdd51ba9efc4007bb5ef26874885194f48479d667878e4f9210aad194a49c43812b2078a923946b359c92fb1341fbcab9e60fd5ce0098c40913e9494a1f133f9384d517440eb701de2a85fc70eb742083e6c4a70c645a51b259334f6426024dda350ffb661147d0f1c6349e6a20e73baeee01f248a77682fe70300369c4bb7b8c97172352544460aee969afe868e3ade8d6527c4abff7f3aa47ced7d81b682848e14f2095fb8693683d3593f290373ce5b247866b734063f8c53a9338d395baba4367ff38b06ffe6e015fcdb69d871db83b31da457ae7f7fe0ba6bed10f516c84a91c13111457db5ec5a7534a2780050d43ac77e67be527d8bc75fce4be5a12fb51cc3e48087f4142ccf2ee0f321481a6ff0c4e84f8a4c9db276ea8328bbe68e34106106f707801a0e151dfc28cf454bb26f33c8fd60d38713a9204b240fa10ded607500fc6247516eed9be17d264308e73f9975ce4a3c46ee84297cf5a640bd93ee0166936abf7b65ba94dcb5b80963728ba9fc4c80db64963773f765741373b604b1cd1a996bddef0203c759654f5e15b4324ccff73b547f824ceab798d7e0c1c695be0c75a397d258b1efb01e40c090141a0eda278fbe3dc977437a7327b36ab7a4d7a5336dae7809f835ea8b1401e1106999f7ed8fbf1285e7d21fff66439092f14f41fb445112934e46e7ebf3a67fbe785456f75b696a048b600dc83f49e3b781a88d55c325415788f646d70b2872b7cb988e757c9a8dcebd5ad3fcdc398a7ab3686725dd4fbd0fbda380c23ad3df5a22ba83177576146c636ee07d0fb6600475f3b26c33ecea062825ebd9e5e8bb0443a852692e94ebd5565f4c3b838ae0fc9eb65f1aaf92eb580f1218b822afb12d06b482485bd077c27663aa92176df03bda5e5cc0fba159604a36f889c800bc39e7b8332702087b74ba34a1bcbd5f22b24501638ba432ccbe7c22703f92018c5c9a6d28873e9a22c1a6661d2cfceff716d1854273bfa6b87d4b63de8c525e5ba81fea399f6f23b34c43ebbd65ebd2fbd84aeea4abe6c129520b996fb14ee0f625fa520d5341d1285b9d7044618e324106fcea7feef49f3792425d5cb59225e7b6b68e6d93014d22a9884612961a2d348dca4a66c65395cd565e7eb766575bd8abb4203799d5971f121f77d0cb080b9ed936c8d6acbaac158ebe8369fa1e628af5c8c28bd78b4b49f0792417d591bd7e102cd7ef47654523dec1d22b85323bf8efcc0da364f7d259bc814a05d65996191f63cbc5ba8cdb8919ca9d6d39003d8bc19dd48b364196259a7a2d49dcc219f50c5da875ac15ddc58f869360b786a29c6015764918c24610d2adce5af228bf96ecba24580b1a263da2f86e2ebc8ba0b564f067028371b2adf6cdbe5b434bbd0ab8902389f4e00edfb7a4cd4e7c7a2f395b6def8fb16e98c56b0c30f31bcf07419efc921cf63083ee64cff4ace14870a9db956222ce4c7453c2aa7bd9e38c60baa55dcb20ca857de769e875c74fff4c6c650384eb6a360f8100513347490fcf691063bd9cedcf58cac120cd6a77bed89e9f010daecc43274779f69a1be2b8da7c3f0fd93743b25581cd01efb73aea113c8de498413e41b82fda50bea7914642451e826ddd47eba6ba964b0e3810b39ea82f39d399a411d43f75aa5a4984463de3b6f4b2f29f9d4323b96b9538dee2a009375891417894c07feac7d3cab6d2406dec6eec2b9671670c6d8b5340726587b9b14fd6d6373c3db74254ff4ce9e276b590ac36c74671c110d535add0417925ccb0e6f182ca7dbd675713c8c120e487e45e809e0d4c09aad31eb354f54b029e174de9b24dcedbfdf5907b12cb5af631b7232e8f6fa60ee5b6c095cecf7f24ea7b817c0eca82b5e26e63fc54c79ef00138b76f053bee87331d6cbafa708b92f553ea4cd2c6a18a988a35449beb47d08beb3641b2da3ac0e58a552327ae599c2e269b33bfba4520f976f9d32fcecfa9ef59ddcff372aad63af8aa4743227d591e6c82d99acb2def71744145f3410af437b9b18b2e476e62115a61d5751aaa3f2c8db684511d3cd3645ff76b32c9e2f9f9d7b68ac651c12ba9fbd29e0be7315da515864d729917b3d994ce30b5d5868c2ada4e73565cd7e2b420e592da5077817b15dc63672525557ebb42d13e4d7405af00e28ac465244071a8ccf263c47532a9a3cf95911cf195c8398b14750e08a02a72d87866f433636805987dc71ce9da8dbfb2c175d4d1d0e9fed566772eef1bf1aa2c4a19387f2e423360846c41ca95452c14785fb2b3b7b6e6aa71db8a1b07d576222091c4e03c4db5a955de4d2ff13100726de11247bbd202c56f6d38acf2ca4821881f7fea2433105a583ee576575be5b83a7970724af97e79ef3a41356a4db930c69e3ad21c402079b2e49fb8163100258a21d9fbce0eedf0255df4520b79f3ab7e73ac9a5b9f83333326abf596b0cf9e676dd6fd755a392cef718526ca132ac269f989c3416c00282930c2c3a712305a703705468a742d0c8833d044f9d58f38707574a7b0605da01f47e1a0847277b0518f12aff7aa4dbdc4f415a5bdeb22bb0a56edd110ea113281b05fc81c5e6304119fce5804358f8dafeb262601a8f4d601b44ec8b987630c7659da4748babcb2dbc5630e5d2706b6ec44104b87379a030cb7faa330d7d5eb0b2ecf66d0e112f5ff42d55cca70232ea5802fa91f961236e2ab891a6d6cdbeeaffe385da5b12585b7eb61f94c16e82e23edd8b55f3027b6e6e85d65d2914621031f6f3cb0c3e0a5b654f28eddb9ec533d73800cb8551992aad07a732b5240cdf628fac2486ca755579ca110c5f92d6c18f85330c0bf3f0ab3d832198d03006a38f08f7727ada11ccf5dee83339baf</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>青春回忆</tag>
        <tag>我与她</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构和算法|并查集]</title>
    <url>/2021/07/23/Data_structure_and_algorithm_union-find.html</url>
    <content><![CDATA[<h3 id="并查集介绍">1. 并查集介绍</h3>
<p>并查集（UnionFindSet）主要用于解决动态连通性问题，判断一个图中两个点是否连同。开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间反复查找一个元素在哪个集合中。</p>
<a id="more"></a>
<p>并查集顾名思义就是有<code>“合并集合”</code>和<code>“查找集合中的元素”</code>两种操作的关于数据结构的一种算法，它的名字中<code>“并”</code>、<code>“査”</code>、<code>“集”</code>分别取自<code>Union</code>(合并)、<code>Find</code>(査找)、<code>Set</code>(集合)这3个单词。</p>
<h4 id="并查集的数据结构">1.1 并查集的数据结构</h4>
<p>并查集在使用中以<strong><u>森林</u></strong>来表示，维护一个数组<code>father[]</code>记录每个结点<code>x</code>的父亲结点<code>father[x]</code>。</p>
<p>初始状态将每个节点看作一棵只有一个节点的数，此时每个节点的父节点都指向它本身，即<code>father[x] = x</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] findSet = <span class="keyword">null</span>; <span class="comment">// 即father</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    findSet = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后通过不断加入边，更新<code>father[]</code>数组将多棵树合并。如下图是一个森林的<code>father</code>数组：</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/algorithm/UnionFind.png" alt="并查集森林" /><figcaption aria-hidden="true">并查集森林</figcaption>
</figure>
<h4 id="并查集的查找">1.2 并查集的查找</h4>
<p>查找元素<code>x</code>所在的集合，即找到<code>x</code>的根节点的标号。同一个集合中<u>只存在一个根结点</u>，因此查找操作就是对给定的结点寻找其根结点的过程。查找方法是：通过反复寻找父亲结点，直到找到根结点(即<code>father[x]=x</code>的结点)。比如要查找节点<code>4</code>的根节点，流程如下：</p>
<ul>
<li>x=4，father[x] = 2，不是根节点(4 != father[4])，继续查找；</li>
<li>x=2，father[x] = 1，不是根节点，继续查找；</li>
<li>x=1，father[x] = 1，满足根节点条件，返回根节点<code>1</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == findSet[cur]) <span class="keyword">return</span> cur;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findSet[cur];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并查集的合并">1.3 并查集的合并</h4>
<p>合并是指把两个集合合并成一个集合，通过两个元素<code>x</code>，<code>y</code>，把这两个元素所在的集合合并<code>Union(x, y)</code>。合并过程只需要把其中一个集合的根结点设置为另一个集合根结点的孩子即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    xRoot = Find(x);</span><br><span class="line">    yRoot = Find(y);</span><br><span class="line">    <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">        findSet[xRoot] = yRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="路径压缩">1.4 路径压缩</h4>
<p>在并查集查找中，查找元素<code>x</code>所在的集合的运算次数=元素<code>x</code>所在的深度。极端情况下，如果整棵树构造成了一个链，元素过多时深度会过深，时间复杂度过大。这里需要对森林中的树进行优化。</p>
<p>可以发现最优化的时候，即每棵树中非根节点都刚好指向跟节点，此时每个孩子节点的深度都为<code>2</code>。复杂度从<code>O(n)</code>降为了<code>O(1)</code>。</p>
<p>该优化过程可以在查找过程中实现，查找到跟节点后，同步更新当前节点的根节点，这个过程即<strong><u>路径压缩</u></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == findSet[cur]) <span class="keyword">return</span> cur;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        findSet[cur] = Find(findSet[cur]);  <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> findSet[cur];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，在合并过程中也可以进行优化，尽量降低树的深度。每次合并中，将深度较小的树作为另一棵树的子树，这时需要一个额外的数组<code>rank</code>来记录当前各树的深度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加权 Quick Union</span></span><br><span class="line"><span class="comment">// 合并x和y所在的集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x); <span class="comment">//找到x所在的集合，即x的根节点</span></span><br><span class="line">    <span class="keyword">int</span> fy = find(y); <span class="comment">//找到y所在集合，即y的根节点</span></span><br><span class="line">    <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rank[fx] &gt; rank[fy]) &#123; <span class="comment">// y 所在的树深度较小，y 合并到 x</span></span><br><span class="line">        father[fy] = fx;</span><br><span class="line">        <span class="keyword">if</span>(rank[fy]+<span class="number">1</span>&gt;rank[fx]) &#123; <span class="comment">//如果挂上fy之后深度增加</span></span><br><span class="line">            rank[fx]=rank[fy]+<span class="number">1</span>; <span class="comment">//这里的秩为深度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;           </span><br><span class="line">        father[fx] = fy;</span><br><span class="line">        <span class="keyword">if</span>(rank[fx]+<span class="number">1</span>&gt;rank[fy]) rank[fy]=rank[fx]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并查集模板">1.5 并查集模板</h4>
<p>一般并查集都比较模板化，实现都差不多，直接并查集模板如下，这里没有用<code>加权 Quick Union</code>，简化模板。太复杂的记不住。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] findSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        findSet = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            findSet[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == findSet[cur]) <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            findSet[cur] = Find(findSet[cur]);</span><br><span class="line">            <span class="keyword">return</span> findSet[cur];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xRoot = Find(x);</span><br><span class="line">        <span class="keyword">int</span> yRoot = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">            findSet[xRoot] = yRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Find(x) == Find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解">2. 题解</h3>
<h4 id="leetcode-1202.-交换字符串中的元素">2.1 leetcode-1202. 交换字符串中的元素</h4>
<blockquote>
<p>给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。</p>
<p>你可以 任意多次交换 在 pairs 中任意一对索引处的字符。</p>
<p>返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]</span><br><span class="line">输出：&quot;bacd&quot;</span><br><span class="line">解释： </span><br><span class="line">交换 s[0] 和 s[3], s = &quot;bcad&quot;</span><br><span class="line">交换 s[1] 和 s[2], s = &quot;bacd&quot;</span><br></pre></td></tr></table></figure>
<p>由于可以交换任意次数，所以存在情况 <code>pairs = [[0, 1], [1, 2]]</code>，这时候<code>0, 1, 2</code>位置上的元素可以任意交换，所以可以看出他们形成了一个集合。可以将其转化为一个图论的问题，需要找出同属于一个连通分量的所有字符，然后把「连在一起」的索引按照字符的 <code>ASCII</code> 值升序排序，可以使用并查集来寻找这些连通分量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] father;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            father = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                father[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (father[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">            father[x] = Find(father[x]);</span><br><span class="line">            <span class="keyword">return</span> father[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> xRoot = Find(x);</span><br><span class="line">            <span class="keyword">int</span> yRoot = Find(y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">                father[xRoot] = yRoot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">smallestStringWithSwaps</span><span class="params">(String s, List&lt;List&lt;Integer&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span> || pairs.size() == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        UnionFind pairUF = <span class="keyword">new</span> UnionFind(sLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; pair : pairs) &#123;</span><br><span class="line">            pairUF.Union(pair.get(<span class="number">0</span>), pair.get(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于每个并查集中的集合, 用优先队列存储字符, 使得字符有序</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        Map&lt;Integer, PriorityQueue&lt;Character&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> root = pairUF.Find(i);</span><br><span class="line">             map.computeIfAbsent(root, key -&gt; <span class="keyword">new</span> PriorityQueue&lt;&gt;()).offer(charArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于每个位置的字符, 用其对应的优先队列中的最小字符替换</span></span><br><span class="line">        StringBuilder newStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> root = pairUF.Find(i);</span><br><span class="line">            newStr.append( map.get(root).poll() );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newStr.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="leetcode-399.-除法求值">2.2 leetcode-399. 除法求值</h4>
<blockquote>
<p>给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p>
<p>另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</p>
<p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。</p>
<p>注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p>
</blockquote>
<p><strong>变量之间的倍数关系具有传递性</strong>，处理有传递性关系的问题，可以使用「并查集」。分析示例 1：</p>
<ul>
<li><p><span class="math inline">\(a / b = 2.0\)</span> 说明 <span class="math inline">\(a = 2b\)</span>， <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 在同一个集合中；</p></li>
<li><p><span class="math inline">\(b / c = 3.0\)</span>​ 说明 <span class="math inline">\(b = 3c\)</span>​ ，<span class="math inline">\(b\)</span> 和 <span class="math inline">\(c\)</span> 在同一个集合中。</p></li>
<li><p>求 <span class="math inline">\(\cfrac{a}{c}\)</span>，可以把 <span class="math inline">\(a = 2b\)</span>，<span class="math inline">\(b = 3c\)</span> 依次代入，得到 <span class="math inline">\(\cfrac{a}{c} = \cfrac{2b} {c} = \cfrac{2 \cdot 3c} {c} = 6.0\)</span>；</p></li>
<li><p>求 <span class="math inline">\(\cfrac{b}{a}\)</span>，可以把 <span class="math inline">\(b\)</span> 和 <span class="math inline">\(a\)</span> 都转换成为 <span class="math inline">\(c\)</span> 的倍数，<span class="math inline">\(\cfrac{b}{a} = \cfrac{b} {2b} = \cfrac{3c} {6c} = \cfrac{1}{2} = 0.5\)</span></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = equations.size();</span><br><span class="line"></span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(len*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++ ) &#123;</span><br><span class="line">            List&lt;String&gt; cur = equations.get(i);</span><br><span class="line">            uf.union(cur.get(<span class="number">0</span>), cur.get(<span class="number">1</span>), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> queriesSize = queries.size();</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queriesSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queriesSize; i++) &#123;</span><br><span class="line">            String val1 = queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String val2 = queries.get(i).get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            res[i] = uf.isConnected(val1, val2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; father;</span><br><span class="line">        HashMap&lt;String, Double&gt; weights;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            father = <span class="keyword">new</span> HashMap&lt;&gt;(len);</span><br><span class="line">            weights = <span class="keyword">new</span> HashMap&lt;&gt;(len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">            String curFather = father.computeIfAbsent(x, key -&gt; x);</span><br><span class="line">            weights.computeIfAbsent(x, key -&gt; <span class="number">1.0</span>d);</span><br><span class="line">            <span class="keyword">if</span> (!curFather.equals(x)) &#123;</span><br><span class="line">                String lastFather = curFather;</span><br><span class="line">                curFather = find(curFather);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">double</span> weight = weights.computeIfAbsent(lastFather, key -&gt; <span class="number">1.0</span>d);</span><br><span class="line">                weights.put(x, weight * weights.computeIfAbsent(x, key -&gt; <span class="number">1.0</span>d));</span><br><span class="line">                father.put(x, curFather);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curFather;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(String x, String y, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">            String rootX = find(x);</span><br><span class="line">            String rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (!rootX.equals(rootY)) &#123;</span><br><span class="line">                father.put(rootX, rootY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 关系式的推导</span></span><br><span class="line">                weights.put(rootX, weights.get(y) * value / weights.get(x));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">isConnected</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!father.containsKey(x) || !father.containsKey(y)) <span class="keyword">return</span> -<span class="number">1.0</span>d;</span><br><span class="line"></span><br><span class="line">            String rootX = find(x);</span><br><span class="line">            String rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX.equals(rootY)) &#123;</span><br><span class="line">                <span class="keyword">return</span> weights.get(x) / weights.get(y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1.0</span>d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="面试题-17.07.-婴儿名字">2.3 <a href="https://leetcode-cn.com/problems/baby-names-lcci/" target="_blank" rel="noopener">面试题 17.07. 婴儿名字</a></h4>
<blockquote>
<p>每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John 和 Jon 本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果 John 和 Jon 是相同的，并且 Jon 和 Johnny 相同，则 John 与 Johnny 也相同，即它们有传递和对称性。</p>
<p>在结果列表中，选择 字典序最小 的名字作为真实名字。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：names = [&quot;John(15)&quot;,&quot;Jon(12)&quot;,&quot;Chris(13)&quot;,&quot;Kris(4)&quot;,&quot;Christopher(19)&quot;], synonyms = [&quot;(Jon,John)&quot;,&quot;(John,Johnny)&quot;,&quot;(Chris,Kris)&quot;,&quot;(Chris,Christopher)&quot;]</span><br><span class="line">输出：[&quot;John(27)&quot;,&quot;Chris(36)&quot;]</span><br></pre></td></tr></table></figure>
<p>分析条件中，强调的传递性和关系，又是一个求连通子图的题，可以使用并查集直接求解。主要是数据处理上很麻烦，需要处理很多字符串的切分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 并查集</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind1</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind1</span><span class="params">(String[] names)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">                map.put(name, name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 并</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(String name1, String name2)</span> </span>&#123;</span><br><span class="line">            String parent1 = find(name1);</span><br><span class="line">            <span class="keyword">if</span> (parent1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent1 = name1;</span><br><span class="line">            &#125;</span><br><span class="line">            String parent2 = find(name2);</span><br><span class="line">            <span class="keyword">if</span> (parent2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent2 = name2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!parent1.equals(parent2)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent2.compareTo(parent1) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    map.put(parent2, parent1);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(parent1, parent2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查</span></span><br><span class="line">        <span class="function">String <span class="title">find</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (name.equals(map.get(name))) &#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> find(map.get(name));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] trulyMostPopular(String[] names, String[] synonyms) &#123;</span><br><span class="line">        <span class="comment">// 初始化并查集</span></span><br><span class="line">        String[] nameArray = Arrays.stream(names).map(ele -&gt; ele.substring(<span class="number">0</span>, ele.indexOf(<span class="string">"("</span>))).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        UnionFind1 uf = <span class="keyword">new</span> UnionFind1(nameArray);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String syn : synonyms) &#123;</span><br><span class="line">            String[] array = syn.replace(<span class="string">'('</span>, <span class="string">' '</span>).replace(<span class="string">')'</span>, <span class="string">' '</span>).trim().split(<span class="string">","</span>);</span><br><span class="line">            uf.union(array[<span class="number">0</span>], array[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算数字</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String item : names) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = item.indexOf(<span class="string">"("</span>);</span><br><span class="line">            String name = item.substring(<span class="number">0</span>, index);</span><br><span class="line">            <span class="keyword">int</span> num = Integer.parseInt(item.substring(index + <span class="number">1</span>, item.length() - <span class="number">1</span>));</span><br><span class="line">            name = uf.find(name);</span><br><span class="line">            map.put(name, map.getOrDefault(name, <span class="number">0</span>) + num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.entrySet().stream().map(ele -&gt; String.format(<span class="string">"%s(%d)"</span>, ele.getKey(), ele.getValue())).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="leetcode-1631.-最小体力消耗路径">2.4 leetcode-1631. 最小体力消耗路径</h4>
<blockquote>
<p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <code>0</code> 开始编号）。你每次可以往 <strong>上，下，左，右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p>
<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>
<p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p>
</blockquote>
<p>可以将本题抽象成如下的一个图论模型：</p>
<ul>
<li><p>将地图中的每一个格子看成图中的一个节点；</p></li>
<li><p>将两个相邻（左右相邻或者上下相邻）的两个格子对应的节点之间连接一条无向边，边的权值为这两个格子的高度差的绝对值；</p></li>
<li><p>需要找到一条从左上角到右下角的最短路径，其中一条路径的长度定义为其经过的所有边权的最大值。</p></li>
</ul>
<p>可以将图中的所有边按照权值从小到大进行排序，并依次加入并查集中。当加入一条权值为 <code>x</code> 的边之后，如果左上角和右下角从非连通状态变为连通状态，那么 <code>x</code> 即为答案。可以参考力扣上的博客：<a href="https://leetcode-cn.com/problems/path-with-minimum-effort/solution/duo-tu-xiang-xi-fen-xi-jie-ti-si-lu-fen-7z89x/" target="_blank" rel="noopener">多图详细分析解题思路，分享刷题心得</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] findSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">            findSet = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                findSet[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == findSet[cur]) <span class="keyword">return</span> cur;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                findSet[cur] = Find(findSet[cur]);</span><br><span class="line">                <span class="keyword">return</span> findSet[cur];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> xRoot = Find(x);</span><br><span class="line">            <span class="keyword">int</span> yRoot = Find(y);</span><br><span class="line">            <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">                findSet[xRoot] = yRoot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Find(x) == Find(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span> <span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.begin = begin;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="keyword">int</span>[][] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = heights.length;</span><br><span class="line">        <span class="keyword">int</span> colunms = heights[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(rows*colunms);</span><br><span class="line">        PriorityQueue&lt;Edge&gt; edgeQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Edge&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge e1, Edge e2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> e1.value - e2.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> curValue;</span><br><span class="line">        Edge curE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colunms; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = i*colunms+j;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; rows-<span class="number">1</span>) &#123;</span><br><span class="line">                    curValue = Math.abs(heights[i+<span class="number">1</span>][j] - heights[i][j]); </span><br><span class="line">                    curE = <span class="keyword">new</span> Edge(id, id + colunms, curValue);</span><br><span class="line">                    edgeQ.offer(curE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(j &lt; colunms-<span class="number">1</span>) &#123;</span><br><span class="line">                    curValue = Math.abs(heights[i][j+<span class="number">1</span>] - heights[i][j]); </span><br><span class="line">                    curE = <span class="keyword">new</span> Edge(id, id + <span class="number">1</span>, curValue);</span><br><span class="line">                    edgeQ.offer(curE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> last = rows*colunms-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!edgeQ.isEmpty()) &#123;</span><br><span class="line">            curE = edgeQ.poll();</span><br><span class="line">            uf.Union(curE.begin, curE.end);</span><br><span class="line">            <span class="keyword">if</span> (uf.Connected(<span class="number">0</span>, last)) <span class="keyword">return</span> curE.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">3. 总结</h3>
<p>总结起来并查集可以解决的问题存在以下性质：</p>
<ul>
<li>可以转化为寻找连通分量；</li>
<li>元素之间的关系具备传递性；</li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>数据结构和算法</tag>
        <tag>算法</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构和算法|二分查找]</title>
    <url>/2021/07/28/Data_structure_and_algorithm_binary_search.html</url>
    <content><![CDATA[<h3 id="二分查找简介">1. 二分查找简介</h3>
<p>二分查找就是从一个有序数组中查找一个<code>key</code>值的方法，通过对数组不断二分减少遍历比较的次数。</p>
<a id="more"></a>
<p>一般二分查找形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (arr[mid] == key) <span class="keyword">return</span> mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; key) right = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>许多时候会遇到一些二分查找的变种，比如小于等于某个数的最大下标，大于等于某个数的最小下标等等，这里进行一些总结。</p>
<h3 id="二分查找变种">2. 二分查找变种</h3>
<h4 id="找出第一个与key相等的元素">2.1 找出第一个与key相等的元素</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(arr[mid] &gt;= key) right = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>( left &lt; n &amp;&amp; arr[left] == key) <span class="keyword">return</span> left;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="找出最后一个与key相等的元素">2.2 找出最后一个与key相等的元素</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(arr[mid] &gt; key) right = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>( right&gt;=<span class="number">0</span> &amp;&amp; arr[right] == key) <span class="keyword">return</span> right;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找第一个等于或者大于key的元素">2.3 查找第一个等于或者大于Key的元素</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(arr[mid] &gt;= key) right = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="找出第一个大于key的元素">2.4 找出第一个大于Key的元素</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(arr[mid] &gt; key) right = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找最后一个等于或者小于key的元素">2.5 查找最后一个等于或者小于key的元素</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(arr[mid] &gt; key) right = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找最后一个小于key的元素">2.6 查找最后一个小于key的元素</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchFirstEqual</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>( left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(arr[mid] &gt;= key) right = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>第一周LeetCode</title>
    <url>/2019/03/28/first-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第一周leetcode刷题记录">第一周LeetCode刷题记录</h2>
<a id="more"></a>
<p>1.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%941-Two-Sum/" title="LeetCode——1. Two Sum">LeetCode——1. Two Sum</a> 2.<a href="http://wuyunjie.top/2019/03/28/LeLeetCode%E2%80%94%E2%80%942-Add-Two-Numbers/" title="LeetCode——2. Add Two Numbers">LeetCode——2. Add Two Numbers</a> 3.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%943-Longest-Substring-Without-Repeating-Characters/" title="LeetCode——3. Longest Substring Without Repeating Characters">LeetCode——3. Longest Substring Without Repeating Characters</a> 4.<a href="http://wuyunjie.top/2019/03/28/LeLeetCode%E2%80%94%E2%80%947-Reverse-Integer/" title="LeetCode——7. Reverse Integer">LeetCode——7. Reverse Integer</a> 5.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94709-To-Lower-Case/" title="LeetCode——709. To Lower Case">LeetCode——709. To Lower Case</a> 6.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94771-Jewels-and-Stones/" title="LeetCode——771. Jewels and Stones">LeetCode——771. Jewels and Stones</a> 7.<a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%94929-Unique-Email-Addresses/" title="LeetCode——929. Unique Email Addresses">LeetCode——929. Unique Email Addresses</a></p>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>第三周LeetCode</title>
    <url>/2019/04/11/third-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第三周leetcode刷题记录">第三周LeetCode刷题记录</h2>
<a id="more"></a>
<ol type="1">
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-10-Regular-Expression-Matching/" title="LeetCode--10. Regular Expression Matching">LeetCode--10. Regular Expression Matching</a></li>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-13-Roman-to-Integer/" title="LeetCode--13. Roman to Integer">LeetCode--13. Roman to Integer</a></li>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-14-Longest-Common-Prefix/" title="LeetCode--14. Longest Common Prefix">LeetCode--14. Longest Common Prefix</a></li>
<li><a href="http://wuyunjie.top/2019/04/07/LeetCode-15-3Sum/" title="LeetCode--15. 3Sum">LeetCode--15. 3Sum</a></li>
<li><a href="http://wuyunjie.top/2019/04/09/LeetCode-16-3Sum-Closest/" title="LeetCode--16. 3Sum Closest">LeetCode--16. 3Sum Closest</a></li>
<li><a href="http://wuyunjie.top/2019/04/10/LeetCode-17-Letter-Combinations-of-a-Phone-Number/" title="LeetCode--17. Letter Combinations of a Phone Number">LeetCode--17. Letter Combinations of a Phone Number</a></li>
<li><a href="http://wuyunjie.top/2019/04/10/LeetCode-18-4Sum/" title="LeetCode--18. 4Sum">LeetCode--18. 4Sum</a></li>
<li><a href="http://wuyunjie.top/2019/04/11/LeetCode-19-Remove-Nth-Node-From-End-of-List/" title="LeetCode--19. Remove Nth Node From End of List">LeetCode--19. Remove Nth Node From End of List</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构和算法|求最长的XXX]</title>
    <url>/2021/07/25/Data_structure_and_algorithm_longest_xxx.html</url>
    <content><![CDATA[<h3 id="介绍">1. 介绍</h3>
<p>经常遇见一类问题，求最长字串，最长递增序列等等，大部分求解的思路都类型，可以用动态规划求解。但遇到一些变种后，问题常常变得很困难，这里对这类问题进行一个归纳。</p>
<a id="more"></a>
<h3 id="题解">2. 题解</h3>
<h4 id="leetcode-1027.-最长等差数列">2.1 leetcode-1027. 最长等差数列</h4>
<blockquote>
<p>给定一个整数数组 <code>A</code>，返回 <code>A</code> 中最长等差子序列的长度。</p>
<p>回想一下，<code>A</code> 的子序列是列表 <code>A[i_1], A[i_2], ..., A[i_k]</code> 其中 <code>0 &lt;= i_1 &lt; i_2 &lt; ... &lt; i_k &lt;= A.length - 1</code>。并且如果 <code>B[i+1] - B[i]( 0 &lt;= i &lt; B.length - 1)</code> 的值都相同，那么序列 <code>B</code> 是等差的。</p>
</blockquote>
<p>可以用<code>dp[i][diff]</code>表示以第<code>i</code>个数为结尾，以<code>diff</code>为差值的最长子序列长度，那么可以写出其状态转移方程： <span class="math display">\[
dp[i][diff] =
\begin{cases}
    \operatorname{max}(dp[i][diff], dp[j][diff] + 1) &amp;, dp[i-1][diff] &gt; 0 \\ 
    \operatorname{max}(dp[i][diff], 2) &amp;, else \\ 
\end{cases}
\\ 1 \leq j &lt; i
\]</span> 即当要加入第<code>i</code>个元素时，考虑将其与之前第<code>j</code>个元素构成一个等差数列的子序列，此时有两种情况：</p>
<ul>
<li><p>之前以 <code>diff = nums[i] - nums[j]</code>组成的最长数列长度为<code>dp[j][diff]</code>（大于<code>0</code>），加入第<code>i</code>个数后，序列长度加<code>1</code>；</p></li>
<li><p>之前不存在以 <code>diff = nums[i] - nums[j]</code>组成的数列，则当前两个数组成新序列，此时最大长度为<code>2</code>。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLen = nums.length, longest = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[numsLen][<span class="number">20002</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span> ; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> diff = nums[j] - nums[i] + <span class="number">10000</span>;</span><br><span class="line">                dp[i][diff] = Math.max(dp[i][diff], dp[j][diff] == <span class="number">0</span> ? <span class="number">2</span> : dp[j][diff] + <span class="number">1</span>);</span><br><span class="line">                longest = Math.max(longest, dp[i][diff]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="墨奇科技笔试-最长的连续的等差子数组的长度">2.2 墨奇科技笔试-最长的连续的等差子数组的长度</h4>
<blockquote>
<p>有一个整数数组，允许替换一个数字，返回替换后数组中最长的连续的等差子数组的长度。例如将8 5 2 0替换为8 5 2 -1，返回4。</p>
</blockquote>
<p>应该也可以用动态规划解决，而且是连续的子序列，应该状态不会太多。初步想法是，需要设置的状态有两个，一个是当前是否修改过数组，另一个是需要处理子序列长度为<code>3</code>时修改的方式：</p>
<ul>
<li>修改第一个节点使得符合之后的序列；</li>
<li>修改最后一个节点使得符合之前的序列。</li>
</ul>
<p>但这样会使得状态更新变得很复杂。使用了同学介绍的快慢指针方法，先固定一个点，遍历从这个点开始往后走可以到达的最大长度，记录下最值。为了解决上面存在两种修改方式的问题，使用了正反两遍的遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSub</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">2</span>, last = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = nums[i] - nums[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (diff == last) <span class="keyword">continue</span>; <span class="comment">// 减枝</span></span><br><span class="line">        <span class="keyword">else</span> last = diff;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] - nums[j-<span class="number">1</span>] == diff) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> oldValue = nums[j];</span><br><span class="line">            <span class="keyword">int</span> oldIndex = j;</span><br><span class="line"></span><br><span class="line">            nums[j] = nums[j-<span class="number">1</span>] + diff;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] - nums[j-<span class="number">1</span>] == diff) j++;</span><br><span class="line">            nums[oldIndex] = oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        longest = Math.max(longest, j - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = nums[i] - nums[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (diff == last) <span class="keyword">continue</span>; <span class="comment">// 减枝</span></span><br><span class="line">        <span class="keyword">else</span> last = diff;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] - nums[j+<span class="number">1</span>] == diff) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> oldValue = nums[j];</span><br><span class="line">            <span class="keyword">int</span> oldIndex = j;</span><br><span class="line"></span><br><span class="line">            nums[j] = nums[j+<span class="number">1</span>] + diff;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] - nums[j+<span class="number">1</span>] == diff) j--;</span><br><span class="line">            nums[oldIndex] = oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        longest = Math.max(longest, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管例子都过了，但提交的时候没过，也没找到问题在哪。</p>
<h4 id="leetcode-674.-最长连续递增序列">2.3 leetcode-674. 最长连续递增序列</h4>
<blockquote>
<p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p>
<p>连续递增的子序列 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>
</blockquote>
<p>这个题很简答，用动态规划解决的经典问题，而且由于要求是连续的，降低了问题的难度。用<code>dp[i]</code>表示以第<code>i</code>个元素结尾的最长递增子序列长度，转移方程可以表示为： <span class="math display">\[
dp[i] =
\begin{cases}
    dp[i-1] + 1 &amp;, nums[i] &gt; nums[i-1] \\ 
    1 &amp;, else \\ 
\end{cases}
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            pre = nums[i] &gt; nums[i-<span class="number">1</span>] ? pre + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            maxLen = Math.max(pre, maxLen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="leetcode-718.-最长重复子数组">2.4 leetcode-718. 最长重复子数组</h4>
<blockquote>
<p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p>
</blockquote>
<p>最长字串问题，用<code>dp[i][j]</code>表示以<code>A</code>的第<code>i</code>个字符串结尾和<code>B</code>的第<code>j</code>个字符串结尾的最长子串长度，可以得到转移方程： <span class="math display">\[
dp[i+1][j+1] =
\begin{cases}
    dp[i][j] + 1 &amp;, nums1[i] == nums2[j] \\ 
    0 &amp;, else \\ 
\end{cases}
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j++) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = nums1[i] == nums2[j]? dp[i][j] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                longest = Math.max(longest, dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="leetcode-1218.-最长定差子序列">2.5 leetcode-1218. 最长定差子序列</h4>
<blockquote>
<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>difference</code>，请你找出并返回 <code>arr</code> 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 <code>difference</code> 。</p>
<p>子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 <code>arr</code> 派生出来的序列。</p>
</blockquote>
<p>一开始想用<code>dp[i]</code>表示以第<code>i</code>个数结尾的最长子序列，但难以找到<code>nums[i]-difference</code>这个数的位置或者是否存在，想到了之前遇到的类似用空间换时间的方法，因为是有序的所以直接存储<code>dp[nums[i]]</code>作为以当前这个数结尾的符合定差的子序列长度，状态转移方程为： <span class="math display">\[
dp[nums[i]] = dp[nums[i]-difference]
\]</span> 实际上也可以用<code>HashMap</code>来实现这个数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">400004</span>];</span><br><span class="line">        <span class="keyword">if</span>(difference!=<span class="number">0</span>) Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = arr[i] + <span class="number">20000</span>;</span><br><span class="line">            dp[cur + difference] = dp[cur] + <span class="number">1</span>;</span><br><span class="line">            longest = Math.max(longest, dp[cur]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = map.getOrDefault(arr[i] - difference, <span class="number">0</span> ) + <span class="number">1</span>;</span><br><span class="line">            map.put(arr[i], curLen);</span><br><span class="line"></span><br><span class="line">            longest = Math.max(longest, curLen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="leetcode-300.-最长递增子序列">2.6 leetcode-300. 最长递增子序列</h4>
<blockquote>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
</blockquote>
<p>用<code>dp[i]</code>表示以第<code>i</code>个元素结尾得到的最长递增子序列，与连续递增子序列类似，状态转移方程相同。不同的是，需要遍历第<code>i</code>个元素之前的所有数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, longest = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                longest = Math.max(dp[i], longest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="leetcode-1143.-最长公共子序列">2.7 leetcode-1143. 最长公共子序列</h4>
<blockquote>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。</li>
</ul>
<p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
</blockquote>
<p>最长字串问题，用<code>dp[i][j]</code>表示以<code>A</code>的第<code>i</code>个字符串结尾和<code>B</code>的第<code>j</code>个字符串结尾的最长子串长度，转移方程与连续子串类似。唯一不同是需要遍历所有<code>i</code>和<code>j</code>的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>数据结构和算法</tag>
        <tag>算法</tag>
        <tag>最值问题</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 GitHub 下载单个文件夹</title>
    <url>/2019/11/16/githun-download-single-folder.html</url>
    <content><![CDATA[<p>在<code>GitHub</code>上浏览开源项目时或者在查看自己的仓库时，<a id="more"></a>我们可能只需要其中单独几个文件夹下的内容，而不需要整个仓库。但一般<code>GitHub</code>只能克隆整个仓库。可以通过一个在线网站<code>DownGit</code>自动打包下载对应文件夹： &gt; <a href="https://www.itsvse.com/downgit/#/home" target="_blank" rel="noopener">DownGit</a></p>
<p>只需要找到仓库中对应文件夹的url，输入之后，点击 download 自动打包下载。 <img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/DownGit.PNG" alt="DownGit" /></p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>第四周LeetCode</title>
    <url>/2019/04/18/forth-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第四周leetcode刷题记录">第四周LeetCode刷题记录</h2>
<a id="more"></a>
<ol type="1">
<li><a href="http://wuyunjie.top/2019/04/14/LeetCode-20-Valid-Parentheses/" title="LeetCode--20. Valid Parentheses">LeetCode--20. Valid Parentheses</a></li>
<li><a href="http://wuyunjie.top/2019/04/14/LeetCode-21-Merge-Two-Sorted-Lists/" title="LeetCode--21. Merge Two Sorted Lists">LeetCode--21. Merge Two Sorted Lists</a></li>
<li><a href="http://wuyunjie.top/2019/04/14/LeetCode-22-Generate-Parentheses/" title="LeetCode--22. Generate Parentheses">LeetCode--22. Generate Parentheses</a></li>
<li><a href="http://wuyunjie.top/2019/04/16/LeetCode-23-Merge-k-Sorted-Lists/" title="LeetCode--23. Merge k Sorted Lists">LeetCode--23. Merge k Sorted Lists</a></li>
<li><a href="http://wuyunjie.top/2019/04/16/LeetCode-24-Swap-Nodes-in-Pairs/" title="LeetCode--24. Swap Nodes in Pairs">LeetCode--24. Swap Nodes in Pairs</a></li>
<li><a href="http://wuyunjie.top/2019/04/16/LeetCode-25-Reverse-Nodes-in-k-Group/" title="LeetCode--25. Reverse Nodes in k-Group">LeetCode--25. Reverse Nodes in k-Group</a></li>
<li><a href="http://wuyunjie.top/2019/04/17/LeetCode-26-Remove-Duplicates-from-Sorted-Array/" title="LeetCode--26. Remove Duplicates from Sorted Array">LeetCode--26. Remove Duplicates from Sorted Array</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>[大数据技术原理|第二篇 大数据存储与管理(2)]</title>
    <url>/2021/08/03/Big_Data_2_store-and-manage-2.html</url>
    <content><![CDATA[<h3 id="简介">简介</h3>
<p>学习<code>NoSQL数据库</code>和<code>云数据库</code>。</p>
<a id="more"></a>
<h3 id="nosql数据库">1. NoSQL数据库</h3>
<h4 id="简介-1">1.1 简介</h4>
<p><code>NoSQL</code>是一种对非关系型数据库的统称，它所采用的数据模型并非传统关系数据库的关系模型，而是类似<code>键/值</code>、<code>列族</code>、<code>文档</code>等非关系模型。<code>NoSQL</code>数据库没有固定的表结构，通常也不存在连接操作，也没有严格遵守<code>ACID</code>约束（原子性、一致性、隔离性和持续性）。<code>NoSQL</code>数据库<u>支持MapReduce风格的编程，可以较好地应用于大数据管理</u>。通常<code>NoSQL</code>数据库具有以下3个特点：</p>
<ol type="1">
<li>灵活的可扩展性</li>
<li>灵活的数据模型</li>
<li>与云计算紧密融合</li>
</ol>
<h4 id="nosql的四大类型">1.2 NoSQL的四大类型</h4>
<h5 id="键值数据库">1.2.1 键值数据库</h5>
<p><code>键值数据库（Key-Value Database）</code>会使用一个哈希表，这个表中有一个特定的<code>Key</code>和一个指针指向特定的<code>Value</code>。<code>Key</code>可以用来定位<code>Value</code>，即存储和检索具体的<code>Value</code>。</p>
<p>键值数据库可以进一步划分：</p>
<ul>
<li><code>内存键值数据库</code>，把数据保存在内存，如Memcached和 Redis；</li>
<li><code>持久化（ Persistent）键值数据库</code>，把数据保存在磁盘，如BerkeleyDB、 Voldmort和Riak。</li>
</ul>
<h5 id="列族数据库">1.2.2 列族数据库</h5>
<p>列族数据库一般采用列族数据模型，数据库由多个行构成，每行数据包含多个列族，不同的行可以具有不同数量的列族，属于同一列族的数据会被存放在一起。</p>
<h5 id="文档数据库">1.2.3 文档数据库</h5>
<p>文档数据库中，<strong>文档</strong>是数据库的最小单位。虽然每一种文档数据库的部署都有所不同，但是大都假定文档以某种标准化格式封装并对数据进行加密，同时用多种格式进行解码，包括XML、YAML、JSON和BSON等，或者也可以使用二进制格式（如PDF、微软 Office文档等）。</p>
<p>文档数据库通过键来定位一个文档，因此可以看成是键值数据库的一个衍生品，而且前者比后者具有更高的查询效率。</p>
<h5 id="图数据库">1.2.4 图数据库</h5>
<p>图数据库以图论为基础，图用来表示一个对象集合，包括顶点以及连接顶点的边。图数据库使用图作为数据模型来存储数据，完全不同于键值、列族和文档数据模型，可以高效地存储不同顶点之间的关系。图数据库专门用于处理具有高度相互关联关系的数据，可以高效地处理实体之间的关系，比较适合于社交网络、模式识别、依赖分析、推荐系统以及路径寻找等问题。</p>
<h4 id="nosql的三大基石">1.3 NoSQL的三大基石</h4>
<p>NoSQL的三大基石包括<code>CAP</code>、<code>BASE</code>和<code>最终一致性</code>。</p>
<h5 id="cap">1.3.1 CAP</h5>
<p><code>CAP</code>指：</p>
<ul>
<li>C（<code>Consistency</code>）：一致性。指何一个读操作总是能够读到之前完成的写操作的结果，即多点的数据是一致的。</li>
<li>A（ <code>Availability</code>）：可用性。指快速获取数据，可以在确定的时间内返回操作结果。</li>
<li>·P（<code>Tolerance of Network Partition</code>）：分区容忍性。指当出现网络分区的情况时，分离的系统也能够正常运行。</li>
</ul>
<p>CAP理论指出，<strong><u>一个分布式系统不可能同时满足一致性、可用性和分区容忍性这3个需求，最多只能同时满足其中2个</u></strong>。</p>
<ul>
<li>如果追求一致性，那么就要牺牲可用性，需要处理因为系统不可用而导致的写操作失败的情况；</li>
<li>如果追求可用性，那么就要预估到可能发生数据不一致的情况，比如，系统的读操作可能不能精确地读取到写操作写入的最新值。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/CAP.PNG" alt="CAP理论" /><figcaption aria-hidden="true">CAP理论</figcaption>
</figure>
<ol type="1">
<li><code>CA</code>。强调<code>一致性（C）</code>和<code>可用性（A）</code>，放弃<code>分区容忍性（P）</code>，最简单的做法是把所有与事务相关的内容都放到同一台机器上。传统的关系数据库都采用了这种设计原则，因此扩展性都比较差。</li>
<li><code>CP</code>。强调<code>一致性（C）</code>和<code>分区容忍性（P）</code>，放弃<code>可用性（A）</code>，当出现网络分区的情况时，受影响的服务需要等待数据一致，因此在等待期间就无法对外提供服务。<code>Neo4J</code>、 <code>BigTable</code>和<code>HBase</code>等<code>NoSQL</code>数据库都采用了<code>CP</code>设计原则。</li>
<li><code>AP</code>。强调<code>可用性（A）</code>和<code>分区容忍性（P）</code>，放弃<code>一致性（C）</code>，允许系统返回不一致的数据。对于<code>Web2.0</code>网站而言，可用性与分区容忍性优先级要高于数据一致性，网站一般会尽量朝着<code>AP</code>的方向设计。在采用<code>AP</code>设计时，也可以不完全放弃一致性，转而采用<strong><u>最终一致性</u></strong>。</li>
</ol>
<h5 id="base">1.3.2 BASE</h5>
<p>一个数据库事务具有<code>ACID</code>四性：</p>
<ul>
<li><code>A（Atomicity）</code>：原子性。指事务必须是原子工作单元，对于其数据修改，要么全都执行，要么全都不执行。</li>
<li><code>C（Consistency）</code>：一致性。指事务在完成时，必须使所有的数据都保持一致状态。</li>
<li><code>I（Isolation）</code>：隔离性。指由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</li>
<li><code>D（Durability）</code>：持久性。指事务完成之后，对于系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持。</li>
</ul>
<p><code>BASE</code>牺牲了<strong>高一致性</strong>，从而获得<strong>可用性</strong>或<strong>可靠性</strong>。<code>BASE</code>（<code>Basically Availble, Soft-state, Eventual consistency</code>）的基本含义是：</p>
<ul>
<li><code>基本可用（Basically Availble）</code>：基本可用是指一个分布式系统的一部分发生问题变得不可用时，其他部分仍然可以正常使用也就是允许分区失败的情形出现。</li>
<li><code>软状态（Soft-state）</code>：指状态可以有一段时间不同步，具有一定的滞后性。当经过短暂延迟后，状态最终一致。</li>
<li><code>最终一致性（Eventual consistency）</code> ：一致性的类型包括<strong>强一致性</strong>和<strong>弱一致性</strong>，二者的主要区别在于<strong><u>高并发的数据访问操作下，后续操作是否能够获取最新的数据</u></strong>。
<ul>
<li>强一致性，指当执行完一次更新操作后，后续的其他读操作就可以保证读到更新后的最新数据；</li>
<li>弱一致性，指不能保证后续访问读到的都是更新后的最新数据。</li>
<li>最终一致性是弱一致性的一种特例，允许后续的访问操作可以暂时读不到更新后的数据，但是经过一段时间之后，必须最终读到更新后的数据。</li>
</ul></li>
</ul>
<h5 id="最终一致性">1.3.3 最终一致性</h5>
<p>最终一致性根据更新数据后各进程访问到数据的时间和方式的不同，又可以进行如下区分。</p>
<ul>
<li><strong>因果一致性</strong>。如果进程<code>A</code>通知进程<code>B</code>已经更新了一个数据项，那么进程<code>B</code>的后续访问将获得进程<code>A</code>写入的最新值。而与进程<code>A</code>无因果关系的进程<code>C</code>的访问，仍然遵守一般的最终一致性规则。</li>
<li><strong>“读己之所写”一致性</strong>。当进程<code>A</code>自己执行一个更新操作之后，它自己总是可以访问到更新过的值，不会看到旧值。</li>
<li><strong>会话一致性</strong>。把访问存储系统的进程放到<code>会话（Session）</code>的上下文中，只要会话还存在，系统就保证<code>“读己之所写”一致性</code>。</li>
<li><strong>单调读一致性</strong>。如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回在那个值之前的值。</li>
<li><strong>单调写一致性</strong>。系统保证来自同一个进程的写操作顺序执行。</li>
</ul>
<h4 id="newsql">1.4 NewSQL</h4>
<p><code>NewSQL</code>是对各种新的可扩展、高性能数据库的简称，这类数据库不仅具有<code>NoSQL</code>对海量数据的存储管理能力，还保持了传统数据库支持<code>ACID</code>和<code>SQL</code>等特性。<code>NewSQL</code>数据库有两个显著的共同特点：</p>
<ul>
<li>都支持关系数据模型；</li>
<li>都使用<code>SQL</code>作为其主要的接口。</li>
</ul>
<h3 id="云数据库">2. 云数据库</h3>
<h4 id="概述">2.1 概述</h4>
<p>云数据库是部署和虚拟化在云计算环境中的数据库，云数据库具有高可扩展性、高可用性、采用多租形式和支持资源有效分发等特点。</p>
<p>在云数据库中，所有数据库功能都是在云端提供的，客户端可以通过网络远程使用云数据库提供的服务。客户端不需要了解云数据库的底层细节，所有的底层硬件都已经被虚拟化，对客户端而言是透明的，就像在使用一个运行在单一服务器上的数据库一样，非常方便容易，同时又可以获得理论上近乎无限的存储和处理能力。</p>
<h4 id="云数据库系统架构">2.2 云数据库系统架构</h4>
<p>以阿里集团核心系统数据库团队开发的<code>UMP（ Unified MySQL Platform）</code>系统为例进行介绍。</p>
<h5 id="ump系统概述">2.2.1 UMP系统概述</h5>
<p><code>UMP</code>系统是低成本和高性能的<code>MySQL</code>云数据库方案，关键模块采用<code>Erlang</code>语言实现。<code>UMP</code>系统把各种服务器资源划分为资源池，并以资源池为单位把资源分配给<code>MySQL</code>实例。</p>
<ul>
<li>系统中包含了一系列组件，这些组件协同工作，以对用户透明的形式提供主从热备、数据备份、迁移、容灾、读写分离、分库分表等一系列服务。</li>
<li>系统内部划分为3种规格的用户：<code>数据量和流量比较小的用户</code>、<code>中等规模用户</code>以及<code>需要分库分表的用户</code>。</li>
</ul>
<p><code>UMP</code>系统架构设计遵循了以下原则。</p>
<ul>
<li>保持单一的系统对外入口，并且为系统内部维护单一的资源池。</li>
<li>消除单点故障，保证服务的高可用性。</li>
<li>保证系统具有良好的可伸缩性，能够动态地增加、删减计算与存储节点。</li>
<li>保证分配给用户的资源也是弹性可伸缩的，资源之间相互隔离，确保应用和数据的安全。</li>
</ul>
<h5 id="ump系统架构">2.2.2 UMP系统架构</h5>
<p><code>UMP</code>系统中的角色包括：Controller服务器、Proxy服务器、Agent服务器、Web控制台、日志分析服务器、信息统计服务器、愚公系统；</p>
<p>依赖的开源组件包括：Mnesia、 LVS、 RabbitMQ和 Zookeeper。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/bigData/chapter2/UMP.PNG" alt="UMP系统架构" /><figcaption aria-hidden="true">UMP系统架构</figcaption>
</figure>
<h6 id="mnesia">1. Mnesia</h6>
<p><code>Mnesia</code>是一个分布式数据库管理系统，适合于电信及其他需要持续运行和具备软实时特性的<code>Erlang</code>应用，是构建电信应用的控制系统平台——<code>开放式电信平台（Open Telecom Platform, OTP）</code>的一部分。</p>
<p><code>Mnesia</code>支持事务，支持透明的数据分片，利用两阶段锁实现分布式事务，可以线性扩展到至少50个节点。</p>
<h6 id="rabbitmq">2. RabbitMQ</h6>
<p><code>RabbitMQ</code>是一个用<code>Erlang</code>开发的工业级的消息队列产品，作为消息传输中间件来使用，可以实现可靠的消息传送。</p>
<h6 id="zookeeper">3. Zookeeper</h6>
<p><code>Zookeeper</code>是高效和可靠的协同工作系统，提供分布式锁之类的基本服务（如统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等），用于构建分布式应用，减轻分布式应用程序所承担的协调任务。在UMP系统中， Zookeeper主要发挥3个作用。</p>
<ul>
<li><strong>作为全局的配置服务器</strong>。</li>
<li><strong>提供分布式锁</strong>。</li>
<li><strong>监控所有MySQL实例</strong>。</li>
</ul>
<h6 id="lvs">4. LVS</h6>
<p><code>LVS（Linux virtual server）</code>即Linux虚拟服务器，是一个虚拟的服务器集群系统。LVS集群采用<code>IP</code>负载均衡技术和基于内容请求分发技术。<code>UMP</code>系统借助于<code>LVS</code>来实现集群内部的负载均衡。</p>
<h6 id="controller服务器">5. Controller服务器</h6>
<p>Controller服务器向UMP集群提供各种管理服务，实现集群成员管理、元数据存储、 MySQL实例管理、故障恢复、备份、迁移、扩容等功能。 Controller服务器上运行了一组Mnesia分布式数据库服务，其中存储了各种系统元数据，主要包括集群成员、用户的配置和状态信息，以及用户名到后端 MySQL实例地址的映射关系（或称为“路由表”）等。</p>
<h6 id="web控制台">6. Web控制台</h6>
<p>Web控制台向用户提供系统管理界面。</p>
<h6 id="proxy服务器">7. Proxy服务器</h6>
<p>Proxy服务器向用户提供访问MySQL数据库的服务，它完全实现了MySQL协议，用户可以使用已有的MySQL客户端连接到 Proxy服务器，Proxy服务器通过用户名获取到用户的认证信息、资源配额的限制以及后台MySQL实例的地址，然后用户的SQL查询请求会被转发到相应的MySQL实例上。</p>
<h6 id="agent服务器">8. Agent服务器</h6>
<p>Agent服务器部署在运行MySQL进程的机器上，用来管理每台物理机上的MySQL实例，执行主从切换、创建、删除、备份、迁移等操作，同时还负责收集和分析 MySQL进程的统计信息、慢查询日志（ Slow Query Log）和 bin-log。</p>
<h6 id="日志分析服务器">9. 日志分析服务器</h6>
<p>日志分析服务器存储和分析Proxy服务器传入的用户访问日志，并支持实时查询一段时间内的慢日志和统计报表。</p>
<h6 id="信息统计服务器">10. 信息统计服务器</h6>
<p>信息统计服务器定期将采集到的用户的连接数、QPS数值以及MySQL实例的进程状态用<code>RRDtool</code>进行统计。</p>
<h6 id="愚公系统">11. 愚公系统</h6>
<p>愚公系统是一个全量复制结合<code>bin-log</code>分析进行增量复制的工具，可以实现在不停机的情况下动态扩容、缩容和迁移。</p>
<h5 id="ump系统功能">2.2.3 UMP系统功能</h5>
<p>UMP系统是构建在一个大的集群之上的，通过多个组件的协同作业，整个系统实现了对用户透明的容灾、读写分离、分库分表、资源管理、资源调度、资源隔离和数据安全功能。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>第二周LeetCode</title>
    <url>/2019/04/03/second-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第二周leetcode刷题记录">第二周LeetCode刷题记录</h2>
<a id="more"></a>
<ol type="1">
<li><a href="http://wuyunjie.top/2019/03/31/LeetCode-4-Median-of-Two-Sorted-Arrays/" title="LeetCode--4. Median of Two Sorted Arrays">LeetCode--4. Median of Two Sorted Arrays</a></li>
<li><a href="http://wuyunjie.top/2019/03/28/LeetCode%E2%80%94%E2%80%945-Longest-Palindromic-Substring/" title="LeetCode——5. Longest Palindromic Substring">LeetCode--5. Longest Palindromic Substring</a></li>
<li><a href="http://wuyunjie.top/2019/04/01/LeetCode%E2%80%94%E2%80%946-ZigZag-Conversion/" title="LeetCode——6. ZigZag Conversion">LeetCode--6. ZigZag Conversion</a></li>
<li><a href="http://wuyunjie.top/2019/03/31/LeetCode-8-String-to-Integer-atoi/" title="LeetCode--8. String to Integer (atoi)">LeetCode--8. String to Integer (atoi)</a></li>
<li><a href="http://wuyunjie.top/2019/04/02/LeetCode-9-Palindrome-Number/" title="LeetCode--9. Palindrome Number">LeetCode--9. Palindrome Number</a></li>
<li><a href="http://wuyunjie.top/2019/04/03/LeetCode-11-Container-With-Most-Water/" title="LeetCode--11. Container With Most Water">LeetCode--11. Container With Most Water</a></li>
<li><a href="http://wuyunjie.top/2019/04/03/LeetCode-12-Integer-to-Roman/" title="LeetCode--12. Integer to Roman">LeetCode--12. Integer to Roman</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构和算法|求素数的方法]</title>
    <url>/2021/07/25/Data_structure_and_algorithm_prime.html</url>
    <content><![CDATA[<h3 id="问题介绍">1. 问题介绍</h3>
<p>求素数（质数）问题很普遍，问题很简单就是求小于某个数的素数。目前看还没有特别优化的方法，基本上都是打表，主要是在优化打表过程。这里总结一下目前求解素数的一些方法。</p>
<a id="more"></a>
<h3 id="题解">2. 题解</h3>
<h4 id="leetcode-204.-计数质数">2.1 leetcode-204. 计数质数</h4>
<blockquote>
<p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p>
</blockquote>
<h5 id="枚举">2.1.1 枚举</h5>
<p>很直观的思路是枚举每个数判断其是不是质数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += isPrime(i) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度过大，为<span class="math inline">\(O(n\sqrt{n})\)</span>。</p>
<h5 id="埃氏筛">2.1.2 埃氏筛</h5>
<p>由希腊数学家厄拉多塞（<code>Eratosthenes</code>）提出，称为厄拉多塞筛法，简称埃氏筛。</p>
<blockquote>
<p>如果 <code>x</code> 是质数，那么大于 <code>x</code> 的 <code>x</code> 的倍数 <span class="math inline">\(2x,3x,\ldots\)</span> 一定不是质数。</p>
</blockquote>
<p>对于一个质数 <code>x</code>，直接从 <span class="math inline">\(x\cdot x\)</span> 开始标记，因为 <span class="math inline">\(2x,3x,\ldots\)</span> 这些数一定在 <span class="math inline">\(x\)</span>之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span>) i * i &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线性筛">2.1.3 线性筛</h5>
<p>埃氏筛还是存在冗余的标记操作，比如对于 45 这个数，它会同时被 3,5 两个数标记为合数。</p>
<p>线性筛需要多维护一个 <span class="math inline">\(\textit{primes}\)</span> 数组表示当前得到的质数集合。「标记过程」不再仅当 <span class="math inline">\(x\)</span> 为质数时才进行，而是对每个整数 <span class="math inline">\(x\)</span> 都进行。对于整数 <span class="math inline">\(x\)</span>，不再标记其所有的倍数 <span class="math inline">\(x\cdot x,x\cdot (x+1),\ldots\)</span>，而是只标记质数集合中的数与 <span class="math inline">\(x\)</span> 相乘的数，即 <span class="math inline">\(x\cdot\textit{primes}_0,x\cdot\textit{primes}_1,\ldots\)</span>且，在发现 <span class="math inline">\(x \bmod \textit{primes}_i=0\)</span> 的时候结束当前标记。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(isPrime, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                primes.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.size() &amp;&amp; i * primes.get(j) &lt; n; ++j) &#123;</span><br><span class="line">                isPrime[i * primes.get(j)] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % primes.get(j) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="奇数筛">2.1.4 奇数筛</h5>
<p>主要用两条规则来优化埃氏筛：</p>
<ul>
<li><code>质数</code>一定是<code>奇数</code>，<code>偶数</code>一定不是<code>质数</code>。只用在<code>奇数</code>范围标记<code>合数</code>，未标记是<code>质数</code></li>
<li><code>奇数</code> 乘以 <code>偶数</code> 一定是 <code>偶数</code>。只用<code>奇数</code> 乘以 <code>奇数</code>，确保在<code>奇数</code>范围内标记</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] isCom = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> b = (<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">    <span class="keyword">int</span> r = n &gt; <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCom[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= b) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; i * j &lt; n; j += <span class="number">2</span>) &#123;</span><br><span class="line">                    isCom[i*j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这种方法更适合用于统计，不适合用于打表，因为尤其是在偶数域上，没有标记。</p>
<blockquote>
<p>不过换个思路，可以直接遍历奇数，找出奇数中的所有质数就可以得到所有质数了。只需要注意使用这个表时特殊处理就可以了。</p>
</blockquote>
<h4 id="求最大公约数">2.2 求最大公约数</h4>
<h5 id="短除法暴力求解">2.2.1 短除法（暴力求解）</h5>
<blockquote>
<p>采用短除法找出2个数的所有公约数，将这些公因子相乘，结果就是2个数的最大公约数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span> ; i&lt;=m &amp;&amp; i&lt;=n; ) &#123;</span><br><span class="line">    <span class="keyword">while</span>(m%i==<span class="number">0</span>&amp;&amp;n%i==<span class="number">0</span>) &#123;</span><br><span class="line">        f*=i;</span><br><span class="line">        m/=i;</span><br><span class="line">        n/=i;</span><br><span class="line">    &#125;</span><br><span class="line">  	i++;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f;</span><br></pre></td></tr></table></figure>
<h5 id="辗转相除法">2.2.2 辗转相除法</h5>
<blockquote>
<p><strong>辗转相除法</strong>， 又名<strong>欧几里德算法</strong>（Euclidean algorithm），是求最大公约数的一种方法。它的具体做法是：</p>
<ul>
<li>用较小数除较大数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是<code>0</code>为止。<strong><u>最后的<code>除数</code>就是这两个数的最大公约数</u></strong>。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(m &lt; n) &#123;</span><br><span class="line">    tmp = m;</span><br><span class="line">    m = n;</span><br><span class="line">    n = tmp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">i = m % n;</span><br><span class="line"><span class="keyword">while</span> (i) &#123;</span><br><span class="line">  m = n;</span><br><span class="line">  n = i;</span><br><span class="line">  i = m % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f=n;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>求互质数可以直接判断最大公约数是否只有<code>1</code>。</p>
</blockquote>
<h3 id="参考文献">参考文献</h3>
<ol type="1">
<li><a href="https://leetcode-cn.com/problems/count-primes/solution/ji-shu-zhi-shu-by-leetcode-solution/" target="_blank" rel="noopener">计数质数-leetcode</a></li>
</ol>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>数据结构和算法</tag>
        <tag>算法</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>第五周LeetCode</title>
    <url>/2019/04/25/fifth-week-LeetCode.html</url>
    <content><![CDATA[<h2 id="第五周leetcode刷题记录">第五周LeetCode刷题记录</h2>
<a id="more"></a>
<ol type="1">
<li><a href="http://wuyunjie.top/2019/04/17/LeetCode-27-Remove-Element/" title="LeetCode--27. Remove Element">LeetCode--27. Remove Element</a></li>
<li><a href="http://wuyunjie.top/2019/04/17/LeetCode-28-Implement-strStr/" title="LeetCode--28. Implement strStr()">LeetCode--28. Implement strStr()</a></li>
<li><a href="http://wuyunjie.top/2019/04/22/LeetCode-29-Divide-Two-Integers/" title="LeetCode--29. Divide Two Integers">LeetCode--29. Divide Two Integers</a></li>
<li><a href="http://wuyunjie.top/2019/04/22/LeetCode-30-Substring-with-Concatenation-of-All-Words/" title="LeetCode--30. Substring with Concatenation of All Words">LeetCode--30. Substring with Concatenation of All Words</a></li>
<li><a href="http://wuyunjie.top/2019/04/22/LeetCode-31-Next-Permutation/" title="LeetCode--31. Next Permutation">LeetCode--31. Next Permutation</a></li>
<li><a href="http://wuyunjie.top/2019/04/23/LeetCode-32-Longest-Valid-Parentheses/" title="LeetCode--32. Longest Valid Parentheses">LeetCode--32. Longest Valid Parentheses</a></li>
<li><a href="http://wuyunjie.top/2019/04/23/LeetCode-33-Search-in-Rotated-Sorted-Array/" title="LeetCode--33. Search in Rotated Sorted Array">LeetCode--33. Search in Rotated Sorted Array</a></li>
</ol>
]]></content>
      <categories>
        <category>LeetCode报告</category>
      </categories>
      <tags>
        <tag>LeetCode报告</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书|2021阅读]--《如何阅读一本书》</title>
    <url>/2021/05/14/Reading_2021--How_to_Read_a_Book.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>如何阅读一本书 <a id="more"></a></p>
</blockquote>
<h3 id="思维导图">思维导图</h3>
<iframe src="https://www.xmind.net/embed/3TzT/" width="750" height="1000" frameborder="0" scrolling="no" allowfullscreen="true">
</iframe>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构和算法|贪心算法]</title>
    <url>/2021/07/24/Data_structure_and_algorithm_greedy_algorithm.html</url>
    <content><![CDATA[<h3 id="简介">1. 简介</h3>
<h4 id="基本概念">1.1 基本概念</h4>
<p><code>贪心算法</code>（又称<code>贪婪算法</code>）是指，总是<u>做出在当前看来是最好的选择</u>，算法得到的是在某种意义上的<strong>局部最优解</strong>。</p>
<a id="more"></a>
<p>贪心算法不是对所有问题都能得到整体最优解，贪心算法设计的关键是贪心策略的选择。利用贪心法求解的问题应具备如下2个特征：</p>
<ul>
<li><p><strong>贪心选择性质</strong>。</p>
<blockquote>
<p>一个问题的整体最优解可通过一系列<strong>局部最优解</strong>的选择达到，并且每次的选择可以<u>依赖以前作出的选择，但不依赖于后面要作出的选择</u>。要确定一个问题是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。</p>
</blockquote>
<p>动态规划算法通常以<strong>自底向上</strong>的方式解各子问题，而贪心算法则通常以<strong>自顶向下</strong>的方式进行，以迭代的方式作出相继的贪心选择，<u>每作一次贪心选择就将所求问题简化为规模更小的子问题</u>。</p></li>
<li><p><strong>最优子结构性质</strong>。</p>
<blockquote>
<p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</p>
</blockquote></li>
</ul>
<p>但该算法存在如下问题：</p>
<ul>
<li>不能保证解是最佳的。因为贪心算法总是从局部出发，并没从整体考虑；</li>
<li>贪心算法一般用来解决求最大或最小解；</li>
<li>贪心算法只能确定某些问题的可行性范围。</li>
</ul>
<h4 id="实现框架">1.2 实现框架</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">从问题的某一初始解出发;</span><br><span class="line"><span class="keyword">while</span> (能朝给定总目标前进一步) &#123;</span><br><span class="line">	利用可行的决策，求出可行解的一个解元素;</span><br><span class="line">&#125;</span><br><span class="line">由所有解元素组合成问题的一个可行解；</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">Greedy(C)&#123;  <span class="comment">//C是问题的输入集合即候选集合</span></span><br><span class="line">    S=&#123; &#125;;  <span class="comment">//初始解集合为空集</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="function">not <span class="title">solution</span><span class="params">(S)</span>) </span>&#123; <span class="comment">//集合S没有构成问题的一个解</span></span><br><span class="line">       x=select(C);    <span class="comment">//在候选集合C中做贪心选择</span></span><br><span class="line">       <span class="function"><span class="keyword">if</span> <span class="title">feasible</span><span class="params">(S, x)</span>  <span class="comment">//判断集合S中加入x后的解是否可行</span></span></span><br><span class="line"><span class="function">          S</span>=S+&#123;x&#125;;</span><br><span class="line">          C=C-&#123;x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="贪心算法与动态规划的区别">1.3 贪心算法与动态规划的区别</h4>
<p>动态规划：</p>
<ul>
<li>态规划就是为了<strong><u>消除其重叠子问题</u></strong>而设计的，其实就是利用最优子结构和重叠子问题性质对穷举法进行优化，通过将中间结果保存在数组中，实现<strong><u>用空间来换取时间交换</u></strong>，实现程序的快速运行；</li>
<li>局最优解中一定包含某个局部最优解，但<strong><u>不一定包含前一个局部最优解</u></strong>，因此需要记录之前的<strong><u>所有的局部最优解</u></strong>。</li>
<li>动态规划自底向上，<u><strong>从叶子向根</strong>构造子问题的解</u>，对每一个子树的根，求出下面每一个叶子的值，最后得到一棵完整的树，并且最终选择其中的最优值作为自身的值；</li>
<li>动态规划本质是穷举法，可以保证结果是最佳的，复杂度高。</li>
</ul>
<p>贪心算法：</p>
<ul>
<li>贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次；</li>
<li>每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留；</li>
<li>贪心<strong>从根出发</strong>，每次<u>向下遍历最优子树</u>即可（通常这个“最优”都是基于当前情况下显而易见的“最优”），不需要知道一个节点的所有子树情况，于是构不成一棵完整的树；</li>
<li>贪心不能保证求得的最后解是最佳的，一般复杂度低。</li>
</ul>
<h3 id="题解">2. 题解</h3>
<h4 id="leetcode-455.-分发饼干">2.1 leetcode-<a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></h4>
<blockquote>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
</blockquote>
<p>根据贪心的思想，每次都把当前最大的饼干，分给它可以满足的孩子中胃口最大的一个，这样使得之后小的饼干可以分配给胃口较小的孩子，得到局部最优解，使得尽可能多的孩子得到满足。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(g); Arrays.sort(s);</span><br><span class="line">        <span class="keyword">int</span> index = g.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (index &gt;= <span class="number">0</span> &amp;&amp; g[index] &gt; s[i]) &#123;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            res++;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="活动安排问题">2.2 活动安排问题</h4>
<blockquote>
<p>设有<code>N</code>个活动时间集合，每个活动都要使用同一个资源，比如说会议场，而且同一时间内只能有一个活动使用这个资源，每个活动<code>i</code>都有一个使用活动的开始<code>si</code>和结束时间<code>fi</code>，即使用区间为<code>[si, fi]</code>，现在要求分配活动占用时间表，要求从所给的活动集合中选出最大的相容活动子集合。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(i\)</span></th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(s[i]\)</span></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">12</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(f[i]\)</span></td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;">13</td>
<td style="text-align: center;">14</td>
</tr>
</tbody>
</table>
</blockquote>
<p>首先将各活动的按结束时间进行排序，每次选择满足条件的最小结束时间活动，使得每次选择的都是耗时尽可能小的活动，达到局部最优。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">arrangeActivity</span><span class="params">(<span class="keyword">int</span>[] s, <span class="keyword">int</span>[] e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = s.length;</span><br><span class="line">    <span class="keyword">int</span> endFlag = e[<span class="number">0</span>];</span><br><span class="line">    List&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    results.add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; endFlag) &#123;</span><br><span class="line">            results.add(i);</span><br><span class="line">            endFlag = e[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="leetcode-435.-无重叠区间">2.3 leetcode-<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a></h4>
<blockquote>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意:</p>
<p>可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p>
</blockquote>
<p>实际上和活动安排的解题思路一致，每次都加入最下可满足的区间，否则就删除这个区间，最后得到的是可以使得填满当前所在序列上的最大区间数，也是最小删除次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[<span class="number">1</span>] - nums2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftFlag = Integer.MIN_VALUE, deleteCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; leftFlag) &#123;</span><br><span class="line">                deleteCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftFlag = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deleteCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="leetcode-1353.-最多可以参加的会议数目">2.4 leetcode-<a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/" target="_blank" rel="noopener">1353. 最多可以参加的会议数目</a></h4>
<blockquote>
<p>给你一个数组 <code>events</code>，其中 <code>events[i] = [startDayi, endDayi]</code> ，表示会议 <code>i</code> 开始于 <code>startDayi</code> ，结束于 <code>endDayi</code> 。</p>
<p>你可以在满足 <code>startDayi &lt;= d &lt;= endDayi</code> 中的任意一天 <code>d</code> 参加会议 <code>i</code> 。注意，一天只能参加一个会议。</p>
<p>请你返回你可以参加的 <strong>最大</strong> 会议数目。</p>
</blockquote>
<p>贪心的思想，对于第 <code>i</code> 天，如果有若干的会议都可以在这一天开，那么肯定是让 <code>endDayendDay</code> 小的会议先在这一天开才会使答案最优，因为 <code>endDayendDay</code> 大的会议可选择的空间是比 <code>endDayendDay</code> 小的多的，所以在满足条件的会议需要让 <code>endDayendDay</code> 小的先开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEvents</span><span class="params">(<span class="keyword">int</span>[][] events)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据开始时间排序</span></span><br><span class="line">        Arrays.sort(events, Comparator.comparingInt(o -&gt; o[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, curDay = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; canJoin = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;events.length||!canJoin.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!canJoin.isEmpty()&amp;&amp;canJoin.peek()&lt;curDay)&#123;<span class="comment">//可能有些已经超过参加时间了，处理一下</span></span><br><span class="line">                canJoin.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;events.length&amp;&amp;events[i][<span class="number">0</span>]&lt;=curDay)&#123;<span class="comment">//把当前能够参加的会议的结束时间都丢进canJoin中，</span></span><br><span class="line">                canJoin.add(events[i++][<span class="number">1</span>]);                <span class="comment">//当前不能参加的表示startDay还没到，之后可能还有机会参加</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!canJoin.isEmpty())&#123;</span><br><span class="line">                canJoin.poll();</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            curDay++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEvents</span><span class="params">(<span class="keyword">int</span>[][] events)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先排序：开始时间小的在前。这样是方便我们顺序遍历，把开始时间一样的都放进堆</span></span><br><span class="line">        Arrays.sort(events, (o1, o2) -&gt; o1[<span class="number">0</span>] - o2[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">//结果、开始时间、events下标、有多少组数据</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, last = <span class="number">1</span>, i = <span class="number">0</span>, n = events.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n || !pq.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//将start相同的会议都放进堆里</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; events[i][<span class="number">0</span>] == last) &#123;</span><br><span class="line">                pq.offer(events[i++][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//pop掉当前天数之前的</span></span><br><span class="line">            <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; pq.peek() &lt; last) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//顶上的就是要参加的</span></span><br><span class="line">            <span class="keyword">if</span> (!pq.isEmpty()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="leetcode-452.-用最少数量的箭引爆气球">2.5 leetcode-<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. 用最少数量的箭引爆气球</a></h4>
<blockquote>
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 <code>x</code> 轴从不同点完全垂直地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>xstart</code>，<code>xend</code>， 且满足 <code>xstart ≤ x ≤ xend</code>，则该气球会被引爆。可以射出的弓箭的数量没有限制。弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 <code>points</code> ，其中 <code>points [i] = [xstart,xend]</code> ，返回引爆所有气球所必须射出的最小弓箭数。</p>
</blockquote>
<p>利用贪心思想，每个气球肯定会被一只箭射中，所以每次都找到在这个气球的范围内，可以引爆最大的气球数量。不断重复直至没有气球为止：</p>
<ul>
<li>首先按开始横坐标进行排序；</li>
<li>然后将当前可以被同时击中的气球放入同一个集合中(双指针实现)</li>
<li>直到无法增加新气球，消耗一只箭，进入下一轮统计</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">1</span>] &lt; o2[<span class="number">1</span>] ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] &lt; o2[<span class="number">0</span>] ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minArrows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; points.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> curLeft = points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j &lt; points.length &amp;&amp; points[j][<span class="number">0</span>] &lt;= points[i][<span class="number">1</span>] &amp;&amp; curLeft &gt;= points[j][<span class="number">0</span>])&#123;</span><br><span class="line">                curLeft = Math.min(curLeft, points[j][<span class="number">1</span>]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            i = j;</span><br><span class="line">            minArrows++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minArrows++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="背包问题">2.6 背包问题</h4>
<blockquote>
<p>有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。 要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</p>
</blockquote>
<ul>
<li>目标函数：<span class="math inline">\(\sum p_i\)</span>最大</li>
<li>约束条件是装入的物品总质量不超过背包容量：<span class="math inline">\(\sum w_i&lt;=M\)</span></li>
</ul>
<p>思考几种贪心策略及其反例：</p>
<ol type="1">
<li><p>根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">W=<span class="number">30</span></span><br><span class="line">物品：A B C</span><br><span class="line">重量：<span class="number">28</span> <span class="number">12</span> <span class="number">12</span></span><br><span class="line">价值：<span class="number">30</span> <span class="number">20</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>根据策略，首先选取物品<code>A</code>，此时无法继续放入其他物品，但最优解为<code>B、C</code>。</p></li>
<li><p>每次挑选所占重量最小的物品装入是否能得到最优解？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">W=<span class="number">30</span></span><br><span class="line">物品：A B C</span><br><span class="line">重量：<span class="number">28</span> <span class="number">20</span> <span class="number">10</span></span><br><span class="line">价值：<span class="number">28</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>根据策略，首先选取物品<code>B、C</code>，此时无法继续放入其他物品，但最优解为<code>A</code>。</p></li>
<li><p>每次选取单位重量价值最大的物品。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W=30</span><br><span class="line">物品：A B C</span><br><span class="line">重量：28 20 10</span><br><span class="line">价值：28 20 10</span><br></pre></td></tr></table></figure>
<p>三种物品单位重量价值一样时，无法得到最优解。可以在此基础上加入策略，遇见单位价值相同的时候，优先装重量小的，这样可以获取最优解。</p></li>
</ol>
<h3 id="总结">3. 总结</h3>
<ul>
<li>注意一般都需要先进行排序，使得当前的序列可以满足我们选择局部最优解；</li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>数据结构和算法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书|2021阅读]--《围城》</title>
    <url>/2021/05/11/Reading_2021--Fortress_Besieged.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>这个时间落伍的计时机无意中包涵对人生的讽刺和感伤，深于一切语言、一切啼笑。</code> <a id="more"></a></p>
</blockquote>
<h4 id="围城">《围城》</h4>
<p>早已听闻过《围城》的鼎鼎大名，尤其是那一句<code>"城外的人想冲进去，城里的人想逃出来"</code>听闻依旧，似乎暗含了人生至理，但对其也似懂非懂。这段时间也总算有些许空余时间，把这本讽刺小说给读完了。</p>
<p>初读第一章头几段就被钱钟书先生的辞藻，比喻给经验到了，有趣而又不失生动。对场景心境的描述都恰到好处，或许要比亲眼看见都更加形象，钟书先生不愧为文学大家，仿佛这些文字都信手拈来一般。这里摘几段对场景的描写：</p>
<blockquote>
<p>"红海早过了，船在印度洋面上开驶着，但是太阳依然不饶人地迟落早起，侵占去大部分的夜。夜仿佛纸浸了油，变成半透明体；它给太阳拥抱住了，分不出身来，也许是给太阳陶醉了，所以夕照晚霞隐褪后的夜色也带着酡红。"</p>
<p>"谁知道从冷盘到咖啡，没有一样东西可口：上来的汤是凉的，冰淇淋倒是热的；鱼像海军陆战队，已登陆了好几天；肉像潜水艇士兵，会长时期伏在水里；除醋以外，面包、牛油、红酒无一不酸。"</p>
<p>"满天的星又密又忙，它们声息全无，而看来只觉得天上热闹。一梳月亮像形容未长成的女孩子，但见人已不羞缩，光明和轮廓都清新刻露，渐渐可烘衬夜景。小园草地里的小虫琐琐屑屑地在夜谈。不知哪里的蛙群齐心协力地干号，像声浪给火煮得发沸。几只萤火虫游来游去，不像飞行，像在厚密的空气里漂浮，月光不到的阴黑处，一点萤火忽明，像夏夜的一只微绿的小眼睛。"</p>
</blockquote>
<p>这样的描述在书中很常见，我这样囫囵吞枣地读完，也不知道是不是能学到几分。除了用词外，钟书先生对人物心境的描写也是活灵活现，很容易引起我的共鸣，尤其是对爱而不得的失恋心态，入夜难眠的困扰，仕途不如意的烦躁......这些心境让人感觉，这好像就是我经历时候的想法，尽管经过百十年的变迁，现在看来这些人之常情的伤心困惑还是如出一辙，或者也可以说历史总是惊人的相似，我们所经历的不过都是历史的重演，并没有什么稀奇事。对自己来说它的确是痛苦万分，感觉难以熬过的坎，确实对每个人来说都是第一次经历。但从全景来看，这也不过是芸芸众生所共通的人生经历，那么平庸平凡，甚至没有一丝波澜。或许人生之事，尤其是感情上的事，无非也就那几分田地，无论多新式的现代自由恋爱观，也逃脱不了冥冥之中的定律。扯远了，来看看钱钟书先生对心理感受的描写吧.</p>
<p>比如对上台时紧张的心理变化，这不正是上台紧张忘词的状态吗。只能着急，但再着急都记不起自己的稿子。</p>
<blockquote>
<p>"拚命追忆，只像把筛子去盛水。一着急，注意力集中不起来，思想的线索要打成结又松散了。隐约还有些事实的影子，但好比在热闹地方等人，瞥眼人堆里像是他，走上去找，又不见了。“</p>
</blockquote>
<p>浑浑噩噩的人生状态：</p>
<blockquote>
<p>"早晨方醒，听见窗外树上鸟叫，无理由地高兴，无目的地期待，心似乎减轻重量，直升上去。可是这欢喜是空的，像小孩子放的气球，上去不到几尺，便爆裂归于乌有，只留下忽忽若失的无名怅惘。他坐立不安地要活动，却颓唐使不出劲来，好比杨花在春风里飘荡，而身轻无力，终飞不远。"</p>
</blockquote>
<p>对失恋后一段时间心态的描写，感觉很相似，真的失去一个人，就是这样感觉世界昏暗，自己也再也融不进去，与一切都格格不入，仿佛置身到了另一个世界。</p>
<blockquote>
<p>”方鸿渐把信还给唐小姐时，痴钝并无感觉。过些时，他才像从昏厥里醒过来，开始不住地心痛，就像因蜷曲而麻木的四肢，到伸直了血脉流通，就觉得刺痛。昨天囫囵吞地忍受的整块痛苦，当时没工夫辨别滋味，现在，牛反刍似的，零星断续，细嚼出深深没底的回味。卧室里的沙发书桌，卧室窗外的树木和草地，天天碰见的人，都跟往常一样，丝毫没变，对自己伤心丢脸这种大事全不理会似的。奇怪的是，他同时又觉得天地惨淡，至少自己的天地变了相。他个人的天地忽然从世人公共生活的天地里分出来，宛如与活人幽明隔绝的孤鬼，瞧着阳世的乐事，自己插不进，瞧着阳世的太阳，自己晒不到。人家的天地里，他进不去，而他的天地里，谁都可以进来。“</p>
</blockquote>
<p>也曾经有个这样的幻想，钱钟书先生倒是把所有可能，所有境遇都给补全了，这就是失恋人心理还存在着的不甘和侥幸吧：</p>
<blockquote>
<p>”每出门，心里总偷偷希望，在路上，在车子里，在电影院门口，会意外碰见唐小姐。碰见了怎样呢？有时理想自己冷淡、骄傲，对她视若无睹，使她受不了。有时理想中的自己是微笑地镇静，挑衅地多礼，对她客气招呼，她倒窘得不知所措。有时他的想像力愈雄厚了，跟一个比唐小姐更美的女人勾手同行，忽与尚无男友的唐小姐劈面相逢；可是，只要唐小姐有伤心绝望的表示，自己立刻甩了那女人来和她言归于好。理想里的唐小姐时而骂自己“残忍”，时而强抑情感，别转了脸，不让睫毛上眼泪给自己看见。“</p>
</blockquote>
<p>思恋与错过，爱而不得地无奈与痛苦:</p>
<blockquote>
<p>”心里仿佛黑牢里的禁锢者摸索着一根火柴，刚划亮，火柴就熄了，眼前没看清的一片又滑回黑暗里。譬如黑夜里两条船相迎擦过，一个在这条船上，瞥见对面船舱的灯光里正是自己梦寐不忘的脸，没来得及叫唤，彼此早距离远了。这一刹那的接近，反见得暌隔的渺茫。无抵抗、无救援地让痛苦蚕食虫蚀着他的心。“</p>
<p>”那种情感，追想起来也可怕，把人扰乱得做事吃饭睡觉都没有心思，一刻都不饶人，简直就是神经病，真要不得！不过，生这种病有它的快乐，有时宁可再生一次病。”</p>
</blockquote>
<p>或许多年以后回想起曾经，遇见故人，也会被时间冲淡，木然无动于衷。把曾经的感情或立碑志墓，或暴尸荒野。只是不知道这个时间对我来说会是多久。</p>
<blockquote>
<p>"等柔嘉睡熟了，他想现在想到重逢唐晓芙的可能性，木然无动于衷，真见了面，准也如此。缘故是一年前爱她的自己早死了，爱她、怕苏文纨、给鲍小姐诱惑这许多自己，一个个全死了。有几个死掉的自己埋葬在记忆里，立碑志墓，偶一凭吊，像对唐晓芙的一番情感。有几个自己，仿佛是路毙的，不去收拾，让它们烂掉化掉，给鸟兽吃掉——不过始终消灭不了，譬如向爱尔兰人买文凭的自己。"</p>
</blockquote>
<p>在文末，鸿渐悲伤到绝望麻木，或许也不过如此吧：</p>
<blockquote>
<p>鸿渐走出门，神经麻木，不感觉冷，意识里只有左颊在发烫。头脑里，情思弥漫纷乱像个北风飘雪片的天空。他信脚走着，彻夜不睡的路灯把他的影子一盏盏彼此递交。他仿佛另外有一个自己在说：“完了！完了！”散杂的心思立刻一撮似的集中，开始觉得伤心。左颊忽然星星作痛，他一摸湿腻腻的，以为是血，吓得心倒定了，腿里发软。走到灯下，瞧手指上没有痕迹，才知道流了眼泪。</p>
<p>不知不觉中黑地昏天合拢、裹紧，像灭尽灯火的夜，他睡着了。最初睡得脆薄，饥饿像镊子要镊破他的昏迷，他潜意识挡住它。渐渐这镊子松子、钝了，他的睡也坚实得镊不破了，没有梦，没有感觉，人生最原始的睡，同时也是死的样品。</p>
</blockquote>
<p>此外，本以为是书中金句应该出现得比较正式，至少是个什么深沉的感叹，隆重地引出这样的人生哲学。没想到确实一次开玩笑般的谈话里引出了，甚至不是主角所言，鸿渐这时候还在旁边插科打诨呢：</p>
<blockquote>
<p>慎明道：“关于Bertie结婚离婚的事，我也和他谈过。他引一句英国古话，说结婚仿佛金漆的鸟笼，笼子外面的鸟想住进去，笼内的鸟想飞出来；所以结而离，离而结，没有了局。”</p>
<p>苏小姐道：“法国也有这么一句话。不过，不说是鸟笼，说是被围困的城堡fortresse assiégée，城外的人想冲进去，城里的人想逃出来。鸿渐，是不？”鸿渐摇头表示不知道。</p>
</blockquote>
<p>各个角色的形象性格也很鲜明，随着故事情节的发展愈发饱满。比较出乎意料的是赵辛楣，最初出场时与方鸿渐争风吃醋的情敌，或许是网络爽文看多了，把这样一个角色初步定位成了一个小反派，为了苏文纨故意刁难不爱苏文纨的方鸿渐，自以为出尽风头，反而弄巧成拙。看着就好像故意为了衬托方鸿渐而设置的一个悲剧角色。但愈到后面愈发感觉到赵辛楣可能是书中最为直率坦诚的人物了，也是我在里面最喜欢的角色。最初开始发生改观是他作为方鸿渐情敌，与之争论时发表的意见，语出惊人：</p>
<blockquote>
<p>“教书是开发民智，板报也是，两者都是精神动员，但论影响，还是教育来的深。”</p>
</blockquote>
<p>这么一看突然肃然起敬，没想法这个反派人物还有这样的思想高度，确实比网络爽文里面的无脑反派立体多了。看起来只是个因为爱情的醋意，冲昏头脑的有志青年。后面当他与方鸿渐和解，成为朋友后，大量的笔墨对他进行了进一步的描写。重情重义，为人坦诚，风趣可爱，这时候反过头看他开始的表现，反而感觉合情合理，衬托出他的深情与坦然直率。当然也并不是个完美人物，但这些已然让他散发出独特的人格魅力，不禁想跟他学习一些东西。说起来，书中看见他在喜欢了二十年的苏文纨结婚后，发表了这样一番话：</p>
<blockquote>
<p>"我没见过曹元朗，最初以为苏小姐赏识他，一定他比我强；我给人家比下去了，心上很难过。那天看见这样一个怪东西，苏小姐竟会看中他！老实说，眼光如此的女人就不配嫁我赵辛楣，我也不希罕她。"</p>
</blockquote>
<p>这时候对他肃然起敬，感觉这个豁达开朗，拿得起放得下。但后面看也不尽然，这里面或许还是有傲娇生气的成分在。后面还是是不是透露出对这份感情的悲伤遗憾，对其的执念，要不然也不会因为汪太太与苏文纨相似而迷了心，这也算是他的一份情深吧。此外，他对朋友的热情体贴，绅士风格也很让人钦佩。比如专门为朋友温牛奶，为鸿渐疏通工作，备厚礼等等，都感觉这是一个值得深交的好友。最后杨绛先生说到这个人物脱胎于一个五六岁男孩，小孩子的直率天真或许是我们逐渐失去，也奋力追求的事物。</p>
<p>不过除了正文部分，杨绛先生写的后记也生动有趣，感觉丝毫不弱于正文。反而看见她描述的带有“痴气”的钱钟书先生，感觉比正文更加精彩，或许正因为钱钟书先生的"顽皮"，才有了围城里面大量幽默风趣的描述。</p>
<p>全书围绕围城这一说法，或许婚姻是并不会如想象中那么美好，挤破头想进入婚姻的殿堂，最后反倒是柴米油盐酱醋茶的争吵，感情逐渐消磨，让人想逃离这样的困境。但尽管如此，我反而对这座围城有种更加的期待，那种点点滴滴的美好甜蜜也令人向往，或许我现在还是被美好冲昏了头脑，因为刚刚失去，反而更加憧憬希望，感觉自己可以妥善经营，将矛盾拒之门外。不过也可能是目前的一厢情愿了，真正面对时，可能又是另一番心态了。</p>
<p>最后全文以老钟的鸣响结束:</p>
<blockquote>
<p>那只祖传的老钟从容自在地打起来，仿佛积蓄了半天的时间，等夜深人静，搬出来一一细数：“当、当、当、当、当、当”响了六下。六点钟是五个钟头以前，那时候鸿渐在回家的路上走，蓄心要待柔嘉好，劝她别再为昨天的事弄得夫妇不欢；那时候，柔嘉在家里等鸿渐回来吃晚饭，希望他会跟姑母和好，到她厂里做事。这个时间落伍的计时机无意中包涵对人生的讽刺和感伤，深于一切语言、一切啼笑。</p>
</blockquote>
<p>生活就是这般讽刺，巧合。但一切却又只能随着老钟的鸣响，滴答滴答的往前行进，无论多么不舍不甘，多么令人啼笑皆非的错过误会，最终都会化为人生长河里的尘土，消散在过去，带不往未来。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/Fortress_Besieged.jpg" alt="围城" /><figcaption aria-hidden="true">围城</figcaption>
</figure>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书]--2020 阅读清单</title>
    <url>/2020/09/11/Reading--2020_Reading_List.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>决定要开始好好读书了，需要一个仪式感来督促自己，写个书单记录一下 <a id="more"></a></p>
</blockquote>
<h4 id="天蓝色的彼岸">1. 天蓝色的彼岸</h4>
<blockquote>
<p>这本书是一个温馨的童话故事，由 <strong><code>梁忆云</code></strong> 小姑娘倾情推荐。从一个小孩子的角度描述了去世后的世界，没有天堂，没有地域，只有<code>天蓝色的彼岸</code>，那是我们的最终归宿。</p>
<p>没有花大量笔墨描述另一个世界是什么，而是回到了原来的世界去弥补遗憾，顺带看看没有了<code>我</code>的世界会不会不一样。遗憾的是，世界照样会正常运转，只有最亲近的人会为<code>我</code>哀思。哈里从不可思议到不留遗憾向世界告别，整个过程穿插着各种人物的小故事，有阿瑟的温馨，也有依旧等待着温斯顿的斯坦。它教导我们: <strong>要珍惜生，但不必畏惧死</strong>。很治愈。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/The_Great_Blue_Yonder.jpg" alt="天蓝色的彼岸" /><figcaption aria-hidden="true">天蓝色的彼岸</figcaption>
</figure>
<h4 id="追风筝的人">2. 追风筝的人</h4>
<blockquote>
<p>这本书还是去年开始读的, 或者准确来说是<code>听</code>的。去年刚上研究生独自留校, 在学校附件租房, 晚上回去的路上十分宁静寻思找点事做。从最最开始听歌听相声后, 开始逐渐喜欢上了听书, 也是这段时间在喜马拉雅上听了<code>追风筝的人</code>。但后来开学后没时间听书了, 也就搁置了, 一年了也没看完最后两章结局(这拖延症也是绝了)。最近两天开始读书, 又把它拿出来读了读。</p>
<p>最开始听说这本书时, 以为是逐梦+友谊的治愈类小说, 但实际上是遗憾、成长, 以及阿富汗的战乱, 二十年后的物是人非。阿米尔和仆人哈桑少年的友谊纯粹而干净, 但在残酷的社会环境现实面前, 懦弱而渐生偏见的阿米尔, 选择了沉默和逃避。他做了最错误的选择，设计赶走了哈桑, 可以<code>“为你，千千万万遍”</code> 的挚友。此后阿富汗战乱, 社会动荡, 哈桑也就此与阿米尔阴阳两隔。之后是寻求救赎的成长, 阿米尔收到拉辛汗来信决定赴约阿富汗并救回了哈桑的儿子, 自己的侄子索拉博。他不再是少年时对哈桑沉默逃避的阿米尔, 是在寻求救赎中勇敢果决, 抛弃偏见挺身而出, 最终坦然接受的阿米尔。阿米尔与哈桑的友谊固然光芒闪耀令人生叹, 但阿米尔的成长却更加打动人心。</p>
<p>在故事结尾, 作者对<code>结局</code>进行了一个简短讨论。 &gt;<code>阿富汗人喜欢说: 生活总会继续。他们不关心开始或结束、成功或失败、危在旦夕或柳暗花明，只顾像游牧部落那样风尘仆仆地缓慢前行</code>。</p>
<p>或许我们有时候并不知道人生的方向, 路的终点, 但也不必知道, 我们在风尘仆仆的路途经历或许更加诱人而回味。</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/kite_runner.jpg" alt="追风筝的人" /><figcaption aria-hidden="true">追风筝的人</figcaption>
</figure>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构和算法|算法分析]</title>
    <url>/2021/06/30/Data_structure_and_algorithm_algorithm_analysis.html</url>
    <content><![CDATA[<h3 id="算法介绍">1. 算法介绍</h3>
<h4 id="算法">1.1. 算法</h4>
<blockquote>
<p>非形式地说，<strong>算法</strong>（algorithm）就说任何<code>良定义</code>地计算过程，该过程取某个值或值的集合作为<strong>输入</strong>，并产生某个值或值的集合作为<strong>输出</strong>。即算法就是<u>把输入转化为输出的计算步骤的一个序列</u>。</p>
</blockquote>
<a id="more"></a>
<p>若对每个输入实例算法都以正确的输出<strong>停机</strong>，则称该算法是<strong>正确的</strong>，并称正确的算法<strong>解决了</strong>给定的计算问题。不正确的算法对某些输入实例可能根本<strong>不停机</strong>，也可能以不正确的回答停机。</p>
<h4 id="数据结构">1.2. 数据结构</h4>
<blockquote>
<p><strong>数据结构</strong>（data structure）是一种存储和组织数据的方式，旨在便于访问和修改。</p>
</blockquote>
<h3 id="分析算法">2. 分析算法</h3>
<p>分析算法的结果意味着预测算法需要的资源，通常度量的是<strong>计算时间</strong>。一般来说，算法需要的时间与<strong>输入规模</strong>同步增长，所以通常把一个程序的运行时间描述为<u>其输入规模的函数</u>。</p>
<h4 id="最坏情况与平均情况分析">2.1. 最坏情况与平均情况分析</h4>
<p>一般只求<strong>最坏情况运行时间</strong>，主要有三个理由：</p>
<ul>
<li>一个算法的最坏情况运行时间给出了任何输入运行时间的一个<strong>上界</strong>。</li>
<li>对某些算法，最坏情况经常出现。</li>
<li>“平均情况”往往与最坏情况大致一样差。</li>
</ul>
<h4 id="增长量级">2.2. 增长量级</h4>
<p>可以将运行时间就行更简化的抽象，即运行时间的<strong>增长率</strong>或<strong>增长量级</strong>。</p>
<ul>
<li><p>只考虑运行时间公式中最重要的项(比如，<span class="math inline">\(an^2+bn+c\)</span>中的<span class="math inline">\(an^2\)</span>)，因为<span class="math inline">\(n\)</span>很大时，低阶项相对来说不太重要。</p></li>
<li><p>同时也忽略最重要项的常系数，因为在确定计算效率时常量因子不如增长率重要。</p></li>
</ul>
<p>比如记插入排序具有最坏情况运行时间<span class="math inline">\(\Theta(n^2)\)</span>。<u>如果一个算法的最坏情况运行时间具有比另一个算法更低的增长量级，那么通常认为前者比后者更有效</u>。</p>
<h3 id="函数的增长">3. 函数的增长</h3>
<h4 id="渐近记号">3.1. 渐近记号</h4>
<p>主要使用渐近记号来描述算法的运行时间，渐近记号实际上应用于函数。</p>
<h5 id="theta记号">3.1.1 <span class="math inline">\(\Theta\)</span>记号</h5>
<p>比如插入排序的最坏情况运行时间为<span class="math inline">\(T(n)=\Theta(n^2)\)</span>，对这个记号定义。对一个给定的函数<span class="math inline">\(g(n)\)</span>，用 <span class="math inline">\(\Theta(g(n))\)</span>来表示以下函数的集合: <span class="math display">\[
\begin{aligned}
\Theta(g(n))=\left\{f(n) \text { :存在正常量 } c_{1}, c_{2} \text { 和 } n_{0}, \text { 使得对所有 } n \geqslant n_{0}, \text { 有 } 0 \leqslant c_{1} g(n) \leqslant f(n) \leqslant c_{2} g(n)\right\}
\end{aligned}
\]</span> 所以 <span class="math inline">\(\Theta(g(n))\)</span>是一个集合，可以记<span class="math inline">\(f(n) \in \Theta(g(n))\)</span>以指出<span class="math inline">\(f(n)\)</span>是<span class="math inline">\(\Theta(g(n))\)</span>的成员。称<span class="math inline">\(g(n)\)</span>是<span class="math inline">\(f(n)\)</span>的一个<strong>渐近紧确界</strong>。</p>
<h5 id="o记号">3.1.2 <span class="math inline">\(O\)</span>记号</h5>
<p>当只有一个<strong>渐近上界</strong>时，使用<span class="math inline">\(O\)</span>记号。对于给定的函数<span class="math inline">\(g(n)\)</span>，用<span class="math inline">\(O(g(n))\)</span>来表示以下函数的集合： <span class="math display">\[
\begin{aligned}
O(g(n))=\left\{f(n): \text { 存在正常量 } c \text { 和 } n_{0}, \text { 使得对所有 } n \geqslant n_{0}, \text { 有 } 0 \leqslant f(n) \leqslant c g(n)\right\}
\end{aligned}
\]</span></p>
<h5 id="omega记号">3.1.3 <span class="math inline">\(\Omega\)</span>记号</h5>
<p>当只有一个<strong>渐近下界</strong>时，使用<span class="math inline">\(\Omega\)</span>记号。对于给定的函数<span class="math inline">\(g(n)\)</span>，用<span class="math inline">\(\Omega(g(n))\)</span>来表示以下函数的集合： <span class="math display">\[
\begin{aligned}
\Omega(g(n))=\left\{f(n): \text { 存在正常量 } c \text { 和 } n_{0}, \text { 使得对所有 } n \geqslant n_{0}, \text { 有 } 0 \leqslant c g(n) \leqslant f(n)\right\}
\end{aligned}
\]</span> <img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/algorithm/algorithmTime.PNG" alt="记号图例" /></p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>数据结构和算法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java学习|Java并发编程的艺术]--7 Java中的13个原子操作类</title>
    <url>/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-7-Java-atomic-class.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p><code>java.util.concurrent.atomic</code>包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。<code>Atomic</code>包里的类基本都是<u>使用<code>Unsafe</code>实现的包装类</u>。 <a id="more"></a></p>
</blockquote>
<h3 id="原子更新基本类型类">1. 原子更新基本类型类</h3>
<p><code>Atomic</code>包提供了3个类更新基本类型：</p>
<ul>
<li><code>AtomicBoolean</code>：原子更新布尔类型。</li>
<li><code>AtomicInteger</code>：原子更新整型。</li>
<li><code>AtomicLong</code>：原子更新长整型。</li>
</ul>
<p>以上3个类提供的方法几乎一模一样，常用方法有：</p>
<ul>
<li><p><code>int addAndGet(int delta)</code>：以原子方式将输入的数值与实例中的值（<code>AtomicInteger</code>里的<code>value</code>）相加，并返回结果。</p></li>
<li><p><code>boolean compareAndSet(int expect，int update)</code>：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>int getAndIncrement()</code>：以原子方式将当前值加<code>1</code>，返回的是自增前的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">        	<span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk 1.8 实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>void lazySet(int newValue)</code>：最终会设置成<code>newValue</code>，使用<code>lazySet</code>设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</p></li>
<li><p><code>int getAndSet(int newValue)</code>：以原子方式设置为<code>newValue</code>的值，并返回旧值。</p></li>
</ul>
<p><code>Atomic</code>包里的类基本都是使用<code>Unsafe</code>实现的。<code>Unsafe</code>只提供了<code>3</code>种<code>CAS</code>方法，<code>AtomicBoolean</code>先把<code>Boolean</code>转换成<strong>整型</strong>，再使用<code>compareAndSwapInt</code>进行<code>CAS</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果当前数值是expected，则原子的将Java变量更新成x</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果更新成功则返回true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object expected, Object x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> expected, <span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="原子更新数组">2. 原子更新数组</h3>
<p>Atomic包提供了4个类更新数组里的某个元素：</p>
<ul>
<li><code>AtomicIntegerArray</code>：原子更新整型数组里的元素。</li>
<li><code>AtomicLongArray</code>：原子更新长整型数组里的元素。</li>
<li><code>AtomicReferenceArray</code>：原子更新引用类型数组里的元素。</li>
<li><code>AtomicBooleanArray</code> ：原子更新布尔类型数组的元素。</li>
</ul>
<p>其常用方法如下：</p>
<ul>
<li><p><code>int addAndGet(int i，int delta)</code>：以原子方式将输入值与数组中索引<code>i</code>的元素相加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getAndAdd(i, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"index "</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> unsafe.getAndAddInt(array, checkedByteOffset(i), delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>boolean compareAndSet(int i，int expect，int update)</code>：如果当前值等于预期值，则以原子方式将数组位置<code>i</code>的元素设置成<code>update</code>值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>基于已有数组创建<code>AtomicIntegerArray</code>对象时，构造函数会将当前数组复制一份，所以当<code>AtomicIntegerArray</code>对内部的数组元素进行修改时，不会影响原数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Visibility guaranteed by final field guarantees</span></span><br><span class="line">    <span class="keyword">this</span>.array = array.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="原子更新引用类型">3. 原子更新引用类型</h3>
<p>Atomic包提供了3个类原子更新引用类型：</p>
<ul>
<li><p><code>AtomicReference</code>：原子更新引用类型。</p></li>
<li><p><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段。</p></li>
<li><p><code>AtomicMarkableReference</code>：原子更新带有标记位的引用类型。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更新的仅仅只是引用，引用的对象并未改变。</p>
</blockquote>
<h3 id="原子更新字段类">4. 原子更新字段类</h3>
<p>Atomic包提供了3个类进行原子字段更新。</p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整型的字段的更新器。</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器。</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。可以解决使用<code>CAS</code>进行原子更新时可能出现的<code>ABA</code>问题。</li>
</ul>
<p>原子地更新字段类需要两步。</p>
<ul>
<li>第一步，必须使用静态方法<code>newUpdater()</code>创建一个更新器，并且需要设置想要更新的类和属性。</li>
<li>第 二步，更新类的字段（属性）必须使用<code>public volatile</code>修饰符。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建原子更新器，并设置需要更新的对象类和对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.</span><br><span class="line">        newUpdater(User.class, "old");</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置柯南的年龄是10岁</span></span><br><span class="line">        User conan = <span class="keyword">new</span> User(<span class="string">"conan"</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 柯南长了一岁，但是仍然会输出旧的年龄</span></span><br><span class="line">        System.out.println(a.getAndIncrement(conan));</span><br><span class="line">        <span class="comment">// 输出柯南现在的年龄</span></span><br><span class="line">        System.out.println(a.get(conan));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> old;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.old = old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Learning</tag>
        <tag>Java</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>[读书|2021阅读]--《月亮与六便士》</title>
    <url>/2021/04/22/Reading_2021--The_Moon_and_Sixpence.html</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<blockquote>
<p>2021阅读开始啦，尽管之前也零零碎碎看了几本书，但我还是适合写写叙事类的小说吧，今年就从《月亮与六便士》开始了。 <a id="more"></a></p>
</blockquote>
<h4 id="月亮与六便士">《月亮与六便士》</h4>
<blockquote>
<p>阅读这本书的动机不大，只是最近失恋了，想多读读书提升自己，恰好这本书名声在外，没看书评和简介就开始读了。好巧不巧，这本书还真就包含了一部分爱情和梦想，跟预想的治愈心灵大相径庭，反而有种雪上加霜的感觉，这是天意吗/(ㄒoㄒ)/。</p>
<p>刚看开头枯燥难懂，讲的都是什么艺术家，什么艺术体系流派。咋一看真被唬住了，以为是一本介绍文艺复兴的纪实史，或者是针对开头介绍的人物的个人传记，会包含各种高深莫测的艺术赏析思想和术语，没想到到后面画风突变，又变成了一段爱恨情仇的小说。有人说这本书是讲追逐梦想的，也有人说这里面是包含了一种不正的爱情三观，只是被出版商的把戏炒成了畅销书。从我的角度来看，还是有收获的吧，这本书的故事并不轻松，甚至可以说有些沉重。结局也不好评判，对生活有不同态度的人会对结局有不同的看法吧。</p>
<p>首先从梦想的角度看吧，斯特里克兰依旧被塑造成为了一个性格怪异的传奇人物。尽管作者在文中提到: &gt; <code>人类天生具有制造神话的特性，对于那些出类拔萃的人物，人们对发生在他们身上的奇闻逸事往往好奇心极强，编造出一个个传奇故事，然后对此深信不疑，达到近乎狂热的地步。这其实是浪漫主义对平庸生活的一种抗议。因此，一些传奇故事顺理成章地成为铸就不朽英雄的通行证。</code></p>
<p>但实际上最后毛姆还是造就了一个与众不同的斯特里克兰，或许这样的大师本就与众不同，才能在芸芸众生之间鹤立鸡群。另一方面也或许正因为他们是大师/天才，业界传奇，所以他们的一切都被放大了，成为解释他们成功的理由。斯特里克兰四十多岁抛家弃子，放弃衣食无忧的生活走上了追逐艺术的道路，而且他很笃定，他不在意别人的看法，这是真的不在意，这是笃定地不断向前，不需要别人地认可，只是表达自己所想，活在自己自由的世界里。从生活环境的角度看，他是不幸的，大多数人都把梦想艺术看作酒足饭饱之后的精神满足，只有保证温饱后才能追求高层次的精神需求，这正式<code>马斯洛需求金字塔</code>，但斯特里克兰不一样，他似乎更看重自我实现上，当然这可能是我的片面理解。从这一点来说对主角很敬佩，但我也绝不大可能像主角一样放弃一切去逐梦，打破精神上的那层枷锁，实现自我。可能我是个大俗人吧。</p>
<p>如果看斯特里克兰的爱情，可以用一塌糊涂来形容吧。抛家弃子，拆散救命恩人的家庭，最后在孤岛上也留下苦命的妻女。可以说他似乎完全不在乎别人，他只在乎他自己还有他的画家梦，或者说是他对一种美，对一种精神上的追求，懵懵懂懂。但从他的绝情上看，确实描述得入木三分，对不爱的人那种绝情的言辞，真的让人很心痛，却又无懈可击，他这样的人活在自己想要的世界就已然足够了，别人的非议无关紧要，别人的生死哀愁痛苦也入不了他们的内心，可能连同情都没有，只有不屑一顾。从这方面来说，尽管敬佩他这样的处事态度，但这样的人却也是无论如何都喜欢不起来。</p>
<p>最后引用两段平常人的平庸爱情吧，感觉这是大多数人的人生： &gt; 我能想象他们的生活，无灾无祸，日子过得踏实、体面，还有两个端庄、可爱的孩子，他们注定会弘扬良好的家风和地位。夫妻两个会在不知不觉中慢慢变老，看到一双儿女长大成人。到了适当的年龄他们的儿女便会结婚生子，漂亮的女儿将来会做个贤妻良母，生出健康活泼的孩子；而帅气的儿子也会成为英气逼人的男子汉，没准会成为一名军人。最后，这对夫妻开枝散叶后就会体面地隐退，子孙承欢膝下，过着充实、幸福的生活，到时寿终正寝，入土为安。</p>
<table style="width:38%;">
<colgroup>
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="odd">
<td>&gt; 爱情需要人们全神贯注，它使人忘掉自己去爱对方。最聪明的人虽然可能知道爱有尽头这道理，在实际中却不愿相信这一点。人们明知爱是虚幻，却还是为其放弃实实在在的东西，于他们而言，爱情胜过现实。爱情使一个人变得更强大，同时也使他变得更渺小。他们不再是自己。他们不再是人，而是成为一个物件、一个工具，要实现对于他们而言十分陌生的目的。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>"上帝的磨盘转得很慢，却也磨得很细。" 碰上这种情况一准会说："魔鬼为达到目的总是会引用《圣经》。"</p>
</blockquote>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/ReadingList/The_Moon_and_Sixpence.jpg" alt="月亮与六便士" /><figcaption aria-hidden="true">月亮与六便士</figcaption>
</figure>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Book</tag>
      </tags>
  </entry>
</search>
