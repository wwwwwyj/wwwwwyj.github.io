<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">
  <link rel="alternate" href="/atom.xml" title="WuYJ's Blog" type="application/atom+xml">
  <meta name="google-site-verification" content="5Qe7cJKUxVbZsElTq6w1brLkQhcYBQXjnRmvHbU4JKo">
  <meta name="baidu-site-verification" content="code-oJllhY8gxe">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"hide","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>
  <meta name="description" content="前言  并发编程大师Doug Lea不遗余力地为Java开发者提供了非常多的并发容器和框架">
<meta property="og:type" content="article">
<meta property="og:title" content="[Java学习|Java并发编程的艺术]--6 Java并发容器和框架">
<meta property="og:url" content="https://wuyunjie.top/2021/07/20/JavaLearning_The_art_of_concurrent_programming_in_Java-6-Java-concurrent-container-and-framework.html">
<meta property="og:site_name" content="WuYJ&#39;s Blog">
<meta property="og:description" content="前言  并发编程大师Doug Lea不遗余力地为Java开发者提供了非常多的并发容器和框架">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentHashMapClass.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentHashMapStructure.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentLinkedQueueClass.PNG">
<meta property="article:published_time" content="2021-07-20T12:56:06.000Z">
<meta property="article:modified_time" content="2021-07-20T12:56:06.000Z">
<meta property="article:author" content="wuyunjie">
<meta property="article:tag" content="Learning">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentHashMapClass.PNG">

<link rel="canonical" href="https://wuyunjie.top/2021/07/20/JavaLearning_The_art_of_concurrent_programming_in_Java-6-Java-concurrent-container-and-framework.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>[Java学习|Java并发编程的艺术]--6 Java并发容器和框架 | WuYJ's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WuYJ's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">wuyunjie的小站</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>书单</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyunjie.top/2021/07/20/JavaLearning_The_art_of_concurrent_programming_in_Java-6-Java-concurrent-container-and-framework.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="wuyunjie">
      <meta itemprop="description" content="这是一个为了有博客而存在的博客。 会在这里记录技术学习，读书感悟，生活日记等等。欢迎呀！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WuYJ's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [Java学习|Java并发编程的艺术]--6 Java并发容器和框架
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-20 20:56:06" itemprop="dateCreated datePublished" datetime="2021-07-20T20:56:06+08:00">2021-07-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">Java并发编程</span>
                  </a>
                </span>
            </span>

          
            <span id="/2021/07/20/JavaLearning_The_art_of_concurrent_programming_in_Java-6-Java-concurrent-container-and-framework.html" class="post-meta-item leancloud_visitors" data-flag-title="[Java学习|Java并发编程的艺术]--6 Java并发容器和框架" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/20/JavaLearning_The_art_of_concurrent_programming_in_Java-6-Java-concurrent-container-and-framework.html#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/20/JavaLearning_The_art_of_concurrent_programming_in_Java-6-Java-concurrent-container-and-framework.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言">前言</h3>
<blockquote>
<p><code>并发编程大师Doug Lea不遗余力地为Java开发者提供了非常多的并发容器和框架</code> <span id="more"></span></p>
</blockquote>
<h3 id="concurrenthashmap的实现原理">1. <code>ConcurrentHashMap</code>的实现原理</h3>
<p>在并发编程中使用<code>HashMap</code>可能导致程序死循环，而使用线程安全的<code>HashTable</code>效率又非常低下。<code>ConcurrentHashMap</code>是线程安全且高效的<code>HashMap</code>。</p>
<ul>
<li><p><strong>线程不安全的<code>HashMap</code></strong>。在多线程环境下，使用<code>HashMap</code>进行<code>put</code>操作会引起死循环。</p></li>
<li><p><strong>效率低下的<code>HashTable</code></strong>。<code>HashTable</code>容器使用<code>synchronized</code>来保证线程安全，但在线程竞争激烈的情况下<code>HashTable</code>的效率非常低下。</p></li>
<li><p><code>ConcurrentHashMap</code>的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p></li>
</ul>
<h4 id="concurrenthashmap的结构">1.1 <code>ConcurrentHashMap</code>的结构</h4>
<p><code>ConcurrentHashMap</code>是由<code>Segment</code>数组结构和<code>HashEntry</code>数组结构组成。</p>
<ul>
<li><code>Segment</code>是一种<strong>可重入锁</strong>（<code>ReentrantLock</code>），一个<code>ConcurrentHashMap</code>里包含一个<code>Segment</code>数组；
<ul>
<li><code>Segment</code>的结构和<code>HashMap</code>类似，是一种<strong>数组和链表结构</strong>；</li>
<li>一个<code>Segment</code>里包含一个<code>HashEntry</code>数组，每个<code>Segment</code>守护着一个<code>HashEntry</code>数组里的元素，当对<code>HashEntry</code>数组的数据进行修改时，必须首先获得与它对应的<code>Segment</code>锁。</li>
</ul></li>
<li><code>HashEntry</code>则用于存储键值对数据，每个<code>HashEntry</code>是一个<strong>链表结构</strong>的元素。</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentHashMapClass.PNG" alt="ConcurrentHashMap类图" /><figcaption aria-hidden="true">ConcurrentHashMap类图</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentHashMapStructure.PNG" alt="ConcurrentHashMap结构" /><figcaption aria-hidden="true">ConcurrentHashMap结构</figcaption>
</figure>
<h4 id="concurrenthashmap的初始化">1.2 <code>ConcurrentHashMap</code>的初始化</h4>
<p><code>ConcurrentHashMap</code>初始化方法是通过<code>initialCapacity</code>、<code>loadFactor</code>和<code>concurrencyLevel</code>等几个参数来初始化<code>segment</code>数组、段偏移量<code>segmentShift</code>、段掩码<code>segmentMask</code>和每个<code>segment</code>里的<code>HashEntry</code>数组来实现的。</p>
<h5 id="初始化segments数组">1.2.1 初始化<code>segments</code>数组</h5>
<p><code>segments</code>数组的长度<code>ssize</code>是通过<code>concurrencyLevel</code>计算得出的：</p>
<ul>
<li>为了能通过<code>按位与的散列算法</code>来定位<code>segments</code>数组的索引，必须保证<code>segments</code>数组的长度是<code>2</code>的<code>N</code>次方，所以必须计算出一个大于或等于<code>concurrencyLevel</code>的最小的2的N次方值来作为<code>segments</code>数组的长度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">	concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure>
<h5 id="初始化segmentshift和segmentmask">1.2.2 初始化<code>segmentShift</code>和<code>segmentMask</code></h5>
<p>这两个全局变量需要在定位<code>segment</code>时的散列算法里使用：</p>
<ul>
<li><code>sshift</code>等于<code>ssize</code>从1向左移位的次数。<code>segmentShift</code>用于<u><strong>定位参与散列运算的位数</strong></u>，<code>segmentShift</code>等于<code>32</code>减<code>sshift</code>，这里之所以用32是因为<code>ConcurrentHashMap</code>里的<code>hash()</code>方法输出的最大数是32位的。</li>
<li><code>segmentMask</code>是散列运算的掩码，等于<code>ssize</code>减<code>1</code>，掩码的二进制各个位的值都是<code>1</code>。</li>
</ul>
<h5 id="初始化每个segment">1.2.3 初始化每个<code>segment</code></h5>
<p>输入参数<code>initialCapacity</code>是<code>ConcurrentHashMap</code>的<strong>初始化容量</strong>，<code>loadfactor</code>是每个<code>segment</code>的<strong>负载因子</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">	initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">	++c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">	cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line">	<span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);</span><br></pre></td></tr></table></figure>
<ul>
<li>变量<code>cap</code>是<code>segment</code>里<code>HashEntry</code>数组的长度，它等于<code>initialCapacity</code>除以<code>ssize</code>的倍数<code>c</code>。</li>
<li><code>segment</code>的容量<code>threshold＝（int）cap*loadFactor</code>。</li>
</ul>
<h4 id="定位segment">1.3 定位<code>Segment</code></h4>
<p>在<strong>插入和获取</strong>元素的时候，必须先通过散列算法定位到<code>Segment</code>。</p>
<ul>
<li><code>ConcurrentHashMap</code>会首先使用<code>Wang/Jenkins hash</code>的变种算法对元素的<code>hashCode</code>进行一次再散列。目的是<strong><u>减少散列冲突</u></strong>，使元素能够均匀地分布在不同的<code>Segment</code>上， 从而提高容器的存取效率。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种再散列能让数字的每一位都参加到散列运算当中，从而减少散列冲突。<code>ConcurrentHashMap</code>通过以下散列算法定位<code>segment</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="concurrenthashmap的操作">1.4 <code>ConcurrentHashMap</code>的操作</h4>
<h5 id="get操作">1.4.1 <code>get</code>操作</h5>
<p><code>Segment</code>的<code>get</code>操作先经过一次再散列，然后使用这个散列值通过散列运算定位到<code>Segment</code>，再通过散列算法定位到元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">	<span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get</code>操作的高效之处在于<u><strong>整个<code>get</code>过程不需要加锁，除非读到的值是空才会加锁重读</strong></u>。</p>
<ul>
<li><p><code>get</code>方法里将要使用的共享变量都定义成<code>volatile</code>类型，如用于统计当前<code>Segement</code>大小的<code>count</code>字段和用于存储值的<code>HashEntry</code>的<code>value</code>。这是用volatile替换锁的经典应用场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">volatile</span> V value;</span><br></pre></td></tr></table></figure></li>
<li><p>定位<code>Segment</code>使用的是元素的<code>hashcode</code>通过再散列后得到的值的高位，而定位<code>HashEntry</code>直接使用的是再散列后的值。其目的是避免两次散列后的值一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask <span class="comment">// 定位Segment所使用的hash算法</span></span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); <span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="put操作">1.4.2 <code>put</code>操作</h5>
<p><code>put</code>方法首先定位到<code>Segment</code>，然后在<code>Segment</code>里进行插入操作。插入操作需要经历两个步骤</p>
<ul>
<li>第一步判断是否需要对<code>Segment</code>里的<code>HashEntry</code>数组进行扩容；
<ul>
<li>在<strong><u>插入元素前</u></strong>先判断<code>Segment</code>里的<code>HashEntry</code>数组是否超过<code>容量（threshold）</code>，如果超过阈值，则对数组进行扩容。扩容的时候首先会创建一个容量是<strong><u>原来容量两倍</u></strong>的数组，然后将原数组里的元素进行<u><strong>再散列后插入</strong></u>到新的数组里。</li>
<li><code>HashMap</code>是在<strong><u>插入元素后</u></strong>判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时<code>HashMap</code>就进行了一次无效的扩容。</li>
</ul></li>
<li>第二步定位添加元素的位置，然后将其放在<code>HashEntry</code>数组里。</li>
</ul>
<h5 id="size操作">1.4.3 <code>size</code>操作</h5>
<p><code>ConcurrentHashMap</code>统计<code>size</code>时，先尝试<code>2</code>次通过<strong>不锁住</strong><code>Segment</code>的方式来统计各个<code>Segment</code>大小，如果统计的过程中，容器的<code>count</code>发生了变化，则再采用<strong>加锁</strong>的方式来统计所有<code>Segment</code>的大小。</p>
<h3 id="concurrentlinkedqueue">2. <code>ConcurrentLinkedQueue</code></h3>
<p>实现一个线程安全的队列有两种方式：</p>
<ul>
<li><strong>使用阻塞算法</strong>。用一个<strong>锁</strong>（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</li>
<li><strong>使用非阻塞算法</strong>。使用循环<code>CAS</code>的方式来实现。</li>
</ul>
<p><code>ConcurrentLinkedQueue</code>是一个基于链接节点的<strong>无界线程安全队列</strong>。它采用了<code>“wait-free”算法</code>（即<code>CAS</code>算法）来实现。</p>
<h4 id="concurrentlinkedqueue的结构">2.1 <code>ConcurrentLinkedQueue</code>的结构</h4>
<p><code>ConcurrentLinkedQueue</code>由<code>head</code>节点和<code>tail</code>节点组成。</p>
<ul>
<li>每个节点（Node）由节点元素（item）和 指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一 张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail = head;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/Concurrency/chapter6/ConcurrentLinkedQueueClass.PNG" alt="ConcurrentLinkedQueue类图" /><figcaption aria-hidden="true">ConcurrentLinkedQueue类图</figcaption>
</figure>
<h4 id="入队列">2.2 入队列</h4>
<h5 id="入队列的过程">2.2.1 入队列的过程</h5>
<p>入队列就是将入队节点添加到队列的尾部。入队主要做两件事情：</p>
<ul>
<li>将<strong>入队节点</strong>设置成当前队列尾节点的下一个节点；</li>
<li>更新<code>tail</code>节点，如果<code>tail</code>节点的<code>next</code>节点不为空，则将入队节点设置成<code>tail</code>节点，如果<code>tail</code>节点的<code>next</code>节点为空，则将入队节点设置成<code>tail</code>的<code>next</code>节点，<u><strong>所以<code>tail</code>节点不总是尾节点</strong></u>。</li>
</ul>
<p>多个线程同时进行入队操作时，使用<code>CAS</code>算法来入队：</p>
<ul>
<li>首先定位出尾节点；</li>
<li>然后使用<code>CAS</code>算法将入队节点设置成尾节点的<code>next</code>节点，如不成功则重试。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 入队前，创建一个入队节点</span></span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    </span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 死循环，入队不成功反复入队。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 创建一个指向tail节点的引用</span></span><br><span class="line">        Node&lt;E&gt; t = tail;</span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class="line">        Node&lt;E&gt; p = t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">            <span class="comment">// 获得p节点的下一个节点。</span></span><br><span class="line">            Node&lt;E&gt; next = succ(p);</span><br><span class="line">            <span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;</span><br><span class="line">                <span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</span></span><br><span class="line"><span class="comment">                  更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt;= HOPS)</span><br><span class="line">                    casTail(t, n); <span class="comment">// 更新tail节点，允许失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = succ(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>入队方法永远返回<code>true</code>，所以不要通过返回值判断入队是否成功。</p>
</blockquote>
<h5 id="定位尾节点">2.2.2 定位尾节点</h5>
<p><code>tail</code>节点并不总是尾节点，所以每次入队都必须先通过<code>tail</code>节点来找到尾节点。</p>
<blockquote>
<p>尾节点可能是<code>tail</code>节点，也可能是<code>tail</code>节点的<code>next</code>节点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">	Node&lt;E&gt; next = p.getNext();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取tail节点的next节点需要注意的是 p 节点等于 p 的 next 节点的情况，</span></span><br><span class="line"><span class="comment">     * 此时p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="设置入队节点为尾节点">2.2.3 设置入队节点为尾节点</h5>
<p><code>p.casNext(null，n)</code>方法用于将入队节点设置为当前队列尾节点的<code>next</code>节点：</p>
<ul>
<li>如果<code>p</code>是<code>null</code>， 表示<code>p</code>是当前队列的尾节点；</li>
<li>如果不为<code>null</code>，表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</li>
</ul>
<h5 id="hops的设计">2.2.4 <code>HOPS</code>的设计</h5>
<p>使用<code>hops</code>变量来<strong><u>控制并减少<code>tail</code>节点的更新频率</u></strong>。</p>
<ul>
<li>不是每次节点入队后都将<code>tail</code>节点更新成尾节点，而是当<code>tail</code>节点和尾节点的距离大于等于常量<code>HOPS</code>的值（默认等于1）时才更新<code>tail</code>节点。<strong><u><code>tail</code>和尾节点的距离越长，使用<code>CAS</code>更新<code>tail</code>节点的次数就会越少</u></strong>；</li>
<li>但是距离越长带来的<strong>负面效果</strong>就是<u>每次入队时定位尾节点的时间就越长</u>，因为循环体需要多循环一次来定位出尾节点。但是这样仍然能提高入队的效率，因为<u><strong>通过增加对<code>volatile</code>变量的读操作来减少对<code>volatile</code>变量的写操作</strong></u>，而对volatile变量的写操作开销要远远大于读操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOPS = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="出队列">2.3 出队列</h4>
<p><strong>出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用</strong>。与入队列类似，<u>不是每次出队时都更新<code>head</code>节点</u>，通过<code>hops</code>变量来减少使用<code>CAS</code>更新<code>head</code>节点的消耗。</p>
<ul>
<li>当<code>head</code>节点里<strong>有元素</strong>时，直接弹出<code>head</code>节点里的元素，而不会更新<code>head</code>节点。</li>
<li>只有当<code>head</code>节点里<strong>没有元素</strong>时，出队操作才会更新<code>head</code> 节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">// p表示头节点，需要出队的节点</span></span><br><span class="line">    Node&lt;E&gt; p = h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">        <span class="comment">// 获取p节点的元素</span></span><br><span class="line">        E item = p.getItem();</span><br><span class="line">        <span class="comment">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</span></span><br><span class="line">        <span class="comment">// 如果成功则返回p节点的元素。</span></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hops &gt;= HOPS) &#123;</span><br><span class="line">                <span class="comment">// 将p节点下一个节点设置成head节点</span></span><br><span class="line">                Node&lt;E&gt; q = p.getNext();</span><br><span class="line">                updateHead(h, (q != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</span></span><br><span class="line">        <span class="comment">// 一个线程修改了。那么获取p节点的下一个节点</span></span><br><span class="line">        Node&lt;E&gt; next = succ(p);</span><br><span class="line">        <span class="comment">// 如果p的下一个节点也为空，说明这个队列已经空了</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 更新头节点。</span></span><br><span class="line">            updateHead(h, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span></span><br><span class="line">        p = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个线程同时进行出队操作时，使用<code>CAS</code>算法来出队：</p>
<ul>
<li>首先获取<strong>头节点的元素</strong>，然后判断<strong>头节点元素</strong>是否为空；</li>
<li>如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走；</li>
<li>如果不为空，则使用<code>CAS</code>的方式将头节点的引用设置成<code>null</code>；
<ul>
<li>如果<code>CAS</code>成功，则直接返回头节点的元素；</li>
<li>如果不成功，表示另外一个线程已经进行了一次出队操作更新了<code>head</code>节点，需要重新获取头节点。</li>
</ul></li>
</ul>
<h3 id="java中的阻塞队列">3. Java中的阻塞队列</h3>
<h4 id="阻塞队列介绍">3.1 阻塞队列介绍</h4>
<p><code>阻塞队列（BlockingQueue）</code>支持阻塞的插入和移除方法。</p>
<ul>
<li><strong>支持阻塞的插入方法</strong>：当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>
<li><strong>支持阻塞的移除方法</strong>：在队列为空时，获取元素的线程会等待队列变为非空。</li>
</ul>
<p>在阻塞队列不可用时，这两个附加操作提供了4种处理方式：</p>
<ul>
<li><strong>抛出异常</strong>：当队列满时，如果再往队列里插入元素，会抛出<code>IllegalStateException("Queue full")</code>异常。当队列空时，从队列里获取元素会抛出<code>NoSuchElementException</code>异常。主要方法有：<code>add(e), remove(), element()</code>。</li>
<li><strong>返回特殊值</strong>：当往队列插入元素时，会返回元素是否插入成功，成功返回<code>true</code>。如果是移除方法，则是从队列里取出一个元素，如果没有则返回<code>null</code>。主要方法有：<code>offer(e), poll(), peek()</code>。</li>
<li><strong>一直阻塞</strong>：当阻塞队列满时，如果生产者线程往队列里<code>put</code>元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里<code>take</code>元素，队列会阻塞住消费者线程，直到队列不为空。主要方法有：<code>put(e), take()</code>。</li>
<li><strong>超时退出</strong>：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。主要方法有：<code>offer(e, time, unit), poll(time, unit)</code>。</li>
</ul>
<blockquote>
<p>无界阻塞队列<strong>不可能会出现满</strong>的情况，所以使用<code>put</code>或<code>offer</code>方法永远不会被阻塞，而且使用<code>offer</code>方法时，该方法永远返回<code>true</code>。</p>
</blockquote>
<h4 id="java里的阻塞队列">3.2 Java里的阻塞队列</h4>
<p><code>JDK 7</code>提供了<code>7</code>个阻塞队列。</p>
<h5 id="arrayblockingqueue">3.2.1 <code>ArrayBlockingQueue</code></h5>
<p>一个由<strong><u>数组结构</u></strong>组成的<strong>有界</strong>阻塞队列，默认情况下不保证线程公平的访问队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="linkedblockingqueue">3.2.2 <code>LinkedBlockingQueue</code></h5>
<p>一个由<strong><u>链表结构</u></strong>组成的<strong>有界</strong>阻塞队列。此队列的默认和最大长度为<code>Integer.MAX_VALUE</code>。</p>
<h5 id="priorityblockingqueue">3.2.3 <code>PriorityBlockingQueue</code></h5>
<p>一个<strong><u>支持优先级排序</u></strong>的<strong>无界</strong>阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现<code>compareTo()</code>方法来指定元素排序规则，或者初始化<code>PriorityBlockingQueue</code>时，指定构造参数<code>Comparator</code>来对元素进行排序。</p>
<blockquote>
<p>不能保证同优先级元素的顺序。</p>
</blockquote>
<h5 id="delayqueue">3.2.4 <code>DelayQueue</code></h5>
<p>一个使用<u><strong>优先级队列(<code>PriorityQueue</code>)</strong></u>实现的<strong>无界</strong>阻塞队列，支持<strong><u>延时获取元素</u></strong>。</p>
<ul>
<li>队列中的元素必须实现<code>Delayed</code>接口，在创建元素时可以指定多久才能从队列中获取当前元素。</li>
<li>只有在延迟期满时才能从队列中提取元素。</li>
</ul>
<h6 id="delayed接口实现">3.2.4.1 <code>Delayed</code>接口实现</h6>
<p>参考<code>ScheduledThreadPoolExecutor</code>里<code>ScheduledFutureTask</code>类的实现。</p>
<ul>
<li>第一步：在对象创建的时候，初始化基本数据。使用<code>time</code>记录当前对象延迟到什么时候可以使用，使用<code>sequenceNumber</code>来标识元素在队列中的先后顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步：实现<code>getDelay</code>方法，该方法返回当前元素还需要延时多长时间，单位是纳秒。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三步：实现<code>compareTo</code>方法来指定元素的顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero ONLY if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;&gt; x = (ScheduledFutureTask&lt;&gt;)other;</span><br><span class="line">        <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// othter 不是 ScheduledFutureTask 对象时</span></span><br><span class="line">    <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) - other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">    <span class="keyword">return</span> (d == <span class="number">0</span>) ? <span class="number">0</span> : ( (d &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实现延时阻塞队列">3.2.4.2 实现延时阻塞队列</h6>
<p>当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> q.poll();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">    available.await();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    Thread thisThread = Thread.currentThread();</span><br><span class="line">    leader = thisThread;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        available.awaitNanos(delay);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>leader</code>是一个<u><strong>等待获取队列头部元素的线程</strong></u>。</p>
<ul>
<li>如果<code>leader</code>不等于空，表示<u>已经有线程在等待获取队列的头元素</u>。使用<code>await()</code>方法让当前线程等待信号；</li>
<li>如果<code>leader</code>等于空，则把当前线程设置成<code>leader</code>，并使用<code>awaitNanos()</code>方法让当前线程等待接收信号或等待<code>delay</code>时间。</li>
</ul>
<h6 id="delayqueue应用场景">3.2.4.3 <code>DelayQueue</code>应用场景</h6>
<ul>
<li><strong>缓存系统的设计</strong>：用<code>DelayQueue</code>保存缓存元素的<u>有效期</u>，使用一个线程循环查询<code>DelayQueue</code>，一旦能从<code>DelayQueue</code>中获取元素时，表示缓存有效期到了。</li>
<li><strong>定时任务调度</strong>：使用<code>DelayQueue</code>保存当天将会执行的任务和执行时间，一旦从<code>DelayQueue</code>中获取到任务就开始执行，比如<code>TimerQueue</code>就是使用<code>DelayQueue</code>实现的。</li>
</ul>
<h5 id="synchronousqueue">3.2.5 <code>SynchronousQueue</code></h5>
<p>一个<strong><u>不存储元素</u></strong>的阻塞队列。每一个<code>put</code>操作<strong><u>必须等待</u></strong>一个<code>take</code>操作， 否则不能继续添加元素。默认情况下线程采用非公平性策略访问队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">	transferer = fair ? <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列本身并不存储任何元素，非常适合传递性场景。</p>
<ul>
<li><code>SynchronousQueue</code>的吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>。</li>
</ul>
<h5 id="linkedtransferqueue">3.2.6 <code>LinkedTransferQueue</code></h5>
<p>一个由<strong><u>链表结构</u></strong>组成的<strong>无界</strong>阻塞队列。<code>LinkedTransferQueue</code>增加了<code>tryTransfer</code>和<code>transfer</code>方法。</p>
<ol type="1">
<li><p><code>transfer</code>方法</p>
<ul>
<li>如果当前有消费者正在等待接收元素，<code>transfer</code>方法可以把生产者传入的元素立刻<code>transfer</code>（传输）给消费者。</li>
<li>如果没有消费者在等待接收元素，<code>transfer</code>方法会将元素存放在队列的<code>tail</code>节点，并等到该元素被消费者消费了才返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试图把存放当前元素的s节点作为tail节点</span></span><br><span class="line">Node pred = tryAppend(s, haveData);</span><br><span class="line"><span class="comment">// 让CPU自旋等待消费者消费元素</span></span><br><span class="line"><span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br></pre></td></tr></table></figure></li>
<li><p><code>tryTransfer</code>方法</p>
<p>用来试探生产者传入的元素是否能直接传给消费者。</p>
<ul>
<li>如果没有消费者等待接收元素，则返回<code>false</code>；</li>
<li><code>tryTransfer</code>方法无论消费者是否接收，方法<u><strong>立即返回</strong></u>；<code>transfer</code>方法是<u><strong>必须等到消费者消费了才返回</strong></u>。</li>
<li>带有时间限制的<code>tryTransfer(E e, long timeout, TimeUnit unit)</code>方法，如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false；如果在超时时间内消费了元素，则返回true。</li>
</ul></li>
</ol>
<h5 id="linkedblockingdeque">3.2.7 <code>LinkedBlockingDeque</code></h5>
<p>一个由<strong><u>链表结构</u></strong>组成的<strong><u>双向</u></strong>阻塞队列。在初始化<code>LinkedBlockingDeque</code>时可以设置容量防止其过度膨胀。</p>
<blockquote>
<p>双向阻塞队列可以运用在<code>“工作窃取”模式</code>中。</p>
</blockquote>
<h4 id="阻塞队列的实现">3.3 阻塞队列的实现</h4>
<p>使用<strong><u>通知模式</u></strong>实现阻塞队列。如<code>ArrayBlockingQueue</code>使用了<code>Condition</code>来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略其他代码</span></span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        insert(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> extract();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    putIndex = inc(putIndex);</span><br><span class="line">    ++count;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阻塞生产者主要通过 <code>LockSupport.park(this)</code>来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程加入等待队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步状态，也就是释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 调用setBlocker先保存一下将要阻塞的线程</span></span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    <span class="comment">// 调用unsafe.park阻塞当前线程</span></span><br><span class="line">    unsafe.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unsafe.park是个native方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>park</code>方法会阻塞当前线程，只有以下4种情况中的一种发生时，该方法才会返回：</p>
<ul>
<li>与<code>park</code>对应的<code>unpark</code>执行或已经执行时。<code>“已经执行”</code>是指<u><code>unpark</code>先执行，然后再执行<code>park</code></u>的情况。</li>
<li>线程被中断时。</li>
<li>等待完<code>time</code>参数指定的毫秒数时。</li>
<li>异常现象发生时，这个异常现象没有任何原因。</li>
</ul>
<p><code>Linux</code>下使用的是系统方法<code>pthread_cond_wait</code>实现<code>park</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> os::PlatformEvent::<span class="built_in">park</span>() &#123;</span><br><span class="line">    <span class="keyword">int</span> v ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        v = _Event ;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg</span> (v<span class="number">-1</span>, &amp;_Event, v) == v) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">guarantee</span> (v &gt;= <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// Do this the hard way by blocking ...</span></span><br><span class="line">        <span class="keyword">int</span> status = <span class="built_in">pthread_mutex_lock</span>(_mutex);</span><br><span class="line">        <span class="built_in">assert_status</span>(status == <span class="number">0</span>, status, <span class="string">&quot;mutex_lock&quot;</span>);</span><br><span class="line">        <span class="built_in">guarantee</span>(_nParked == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        ++ _nParked;</span><br><span class="line">        <span class="keyword">while</span> (_Event &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// pthread_cond_wait是一个多线程的条件变量函数</span></span><br><span class="line">            status = <span class="built_in">pthread_cond_wait</span>(_cond, _mutex);</span><br><span class="line">			<span class="comment">// for some reason, under 2.7 lwp_cond_wait() may return ETIME ...</span></span><br><span class="line">			<span class="comment">// Treat this the same as if the wait was interrupted</span></span><br><span class="line">            <span class="keyword">if</span> (status == ETIME) &#123; status = EINTR; &#125;</span><br><span class="line">            <span class="built_in">assert_status</span>(status == <span class="number">0</span> || status == EINTR, status, <span class="string">&quot;cond_wait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        -- _nParked ;</span><br><span class="line">		<span class="comment">// In theory we could move the ST of 0 into _Event past the unlock(),</span></span><br><span class="line">		<span class="comment">// but then we&#x27;d need a MEMBAR after the ST.</span></span><br><span class="line">        _Event = <span class="number">0</span> ;</span><br><span class="line">        status = <span class="built_in">pthread_mutex_unlock</span>(_mutex);</span><br><span class="line">        <span class="built_in">assert_status</span>(status == <span class="number">0</span>, status, <span class="string">&quot;mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">guarantee</span> (_Event &gt;= <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="forkjoin框架">4. Fork/Join框架</h3>
<h4 id="forkjoin框架介绍">4.1 Fork/Join框架介绍</h4>
<p><code>Fork/Join框架</code>是<code>Java 7</code>提供的一个<strong><u>用于并行执行任务</u></strong>的框架。它<u>把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果</u>。</p>
<ul>
<li><code>Fork</code>就是把一个大任务切分为若干子任务并行的执行；</li>
<li><code>Join</code>就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li>
</ul>
<h4 id="工作窃取算法">4.2 工作窃取算法</h4>
<p><code>工作窃取（work-stealing）</code>算法是指<u><strong>某个线程从其他队列里窃取任务来执行</strong></u>。</p>
<ul>
<li>把大任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。</li>
<li>但某个线程先完成自己队列里的任务，而其他线程对应的队列里还有任务等待处理，它会去其他线程的队列里窃取一个任务来执行。</li>
<li>为了减少窃取任务线程和被窃取任务线程之间的竞争，通常使用<strong><u>双端队列</u></strong>，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</li>
</ul>
<p><strong>工作窃取算法的优点</strong>：充分利用线程进行并行计算，减少了线程间的竞争。</p>
<p><strong>工作窃取算法的缺点</strong>：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。且会消耗更多的系统资源。</p>
<h4 id="forkjoin框架的设计">4.3 Fork/Join框架的设计</h4>
<p>Fork/Join框架主要有两个步骤：</p>
<ul>
<li><strong>步骤1 分割任务</strong>。首先需要一个<code>fork类</code>来把大任务分割成子任务。</li>
<li><strong>步骤2 执行任务并合并结果</strong>。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。<u>子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据</u>。</li>
</ul>
<blockquote>
<p>很像<code>MapReduce</code>算法，都是任务分解(Map)，然后聚合结果(Reduce)</p>
</blockquote>
<p><code>Fork/Join</code>使用两个类来完成以上两件事情：</p>
<ul>
<li><code>ForkJoinTask</code>：首先创建一个<code>ForkJoin</code>任务。它提供在任务中执行<code>fork()</code>和<code>join()</code>操作的机制。一般不需要直接继承<code>ForkJoinTask</code>类，<strong>Fork/Join框架</strong>提供了两个子类。
<ul>
<li><code>RecursiveAction</code>：用于<strong><u>没有返回结果</u></strong>的任务。</li>
<li><code>RecursiveTask</code>：用于<strong><u>有返回结果</u></strong>的任务。</li>
</ul></li>
<li><code>ForkJoinPool</code>：<code>ForkJoinTask</code>需要通过<code>ForkJoinPool</code>来执行。</li>
</ul>
<h4 id="使用forkjoin框架">4.4 使用Fork/Join框架</h4>
<p><code>ForkJoinTask</code>需要实现<code>compute</code>方法，在这个方法里首先需要判断任务是否足够小：</p>
<ul>
<li>如果足够小就直接执行任务。</li>
<li>如果不足够小，就必须分割成两个子任务，每个子任务在调用<code>fork</code>方法时，又会进入<code>compute</code>方法。</li>
</ul>
<p>使用<code>join</code>方法会等待子任务执行完并得到其结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>; <span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="forkjoin框架的异常处理">4.5 Fork/Join框架的异常处理</h4>
<p><code>ForkJoinTask</code>提供了<code>isCompletedAbnormally()</code>方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过<code>ForkJoinTask</code>的<code>getException</code>方法获取异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(task.isCompletedAbnormally()) &#123;</span><br><span class="line">	System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="forkjoin框架的实现">4.6 Fork/Join框架的实现</h4>
<p><code>ForkJoinPool</code>由<code>ForkJoinTask</code>数组和<code>ForkJoinWorkerThread</code>数组组成：</p>
<ul>
<li><code>ForkJoinTask</code>数组负责将存放程序提交给<code>ForkJoinPool</code>的任务；</li>
<li><code>ForkJoinWorkerThread</code>数组负责执行这些任务。</li>
</ul>
<h5 id="forkjointask的fork方法">4.6.1 ForkJoinTask的fork方法</h5>
<p>调用<code>ForkJoinTask</code>的<code>fork</code>方法时</p>
<ul>
<li>首先调用<code>ForkJoinWorkerThread</code>的<code>pushTask</code>方法<strong><u>异步地执行</u></strong>这个任务。</li>
<li><code>pushTask</code>方法把当前任务存放在<code>ForkJoinTask</code>数组队列里。然后再调用<code>ForkJoinPool</code>的<code>signalWork()</code>方法唤醒或创建一个工作线程来执行任务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	((ForkJoinWorkerThread) Thread.currentThread()).pushTask(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pushTask</span><span class="params">(ForkJoinTask&lt;&gt; t)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;&gt;[] q; </span><br><span class="line">    <span class="keyword">int</span> s, m;</span><br><span class="line">    <span class="keyword">if</span> ((q = queue) != <span class="keyword">null</span>) &#123; <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="comment">// 计算t放到队列中的位置，即u</span></span><br><span class="line">        <span class="keyword">long</span> u = (((s = queueTop) &amp; (m = q.length - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="comment">// 加入队列</span></span><br><span class="line">        UNSAFE.putOrderedObject(q, u, t);</span><br><span class="line">        queueTop = s + <span class="number">1</span>; <span class="comment">// or use putOrderedInt</span></span><br><span class="line">        <span class="comment">// 激活或创建工作线程</span></span><br><span class="line">        <span class="keyword">if</span> ((s -= queueBase) &lt;= <span class="number">2</span>)</span><br><span class="line">            pool.signalWork();</span><br><span class="line">        <span class="comment">// 队列已满</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == m)</span><br><span class="line">            growQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="forkjointask的join方法">4.6.2 ForkJoinTask的join方法</h5>
<p><code>Join</code>方法的主要作用是阻塞当前线程并等待获取结果。</p>
<ul>
<li>首先通过<code>doJoin()</code>方法得到当前任务的状态。任务状态有4种：<code>已完成（NORMAL）</code>、<code>被取消（CANCELLED）</code>、<code>信号（SIGNAL）</code>和<code>出现异常（EXCEPTIONAL）</code>。
<ul>
<li>如果任务状态是已完成，则直接返回任务状态；</li>
<li>如果没有执行完，则从任务数组里取出任务并执行；</li>
<li>如果任务顺利执行完成，则设置任务状态为<code>NORMAL</code>；</li>
<li>如果出现异常，则记录异常，并将任务状态设置为<code>EXCEPTIONAL</code>。</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (doJoin() != NORMAL)</span><br><span class="line">        <span class="keyword">return</span> reportResult();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t; ForkJoinWorkerThread w; <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                completed = exec();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (completed)</span><br><span class="line">                <span class="keyword">return</span> setCompletion(NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w.joinTask(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> externalAwaitDone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">reportResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Throwable ex;</span><br><span class="line">    <span class="comment">// 如果任务状态是被取消，则直接抛出CancellationException</span></span><br><span class="line">    <span class="keyword">if</span> ((s = status) == CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="comment">// 如果任务状态是抛出异常，则直接抛出对应的异常</span></span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="keyword">null</span>)</span><br><span class="line">        UNSAFE.throwException(ex);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Learning/" rel="tag"># Learning</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"># Java并发编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2021/07/19/JavaLearning_The_art_of_concurrent_programming_in_Java-5-Java-lock.html" rel="next" title="[Java学习|Java并发编程的艺术]--5 Java中的锁">
                  <i class="fa fa-chevron-left"></i> [Java学习|Java并发编程的艺术]--5 Java中的锁
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2021/07/21/JavaLearning_The_art_of_concurrent_programming_in_Java-7-Java-atomic-class.html" rel="prev" title="[Java学习|Java并发编程的艺术]--7 Java中的13个原子操作类">
                  [Java学习|Java并发编程的艺术]--7 Java中的13个原子操作类 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concurrenthashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">1. ConcurrentHashMap的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#concurrenthashmap%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 ConcurrentHashMap的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#concurrenthashmap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 ConcurrentHashMap的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96segments%E6%95%B0%E7%BB%84"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.2.1 初始化segments数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96segmentshift%E5%92%8Csegmentmask"><span class="nav-number">2.2.2.</span> <span class="nav-text">1.2.2 初始化segmentShift和segmentMask</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AF%8F%E4%B8%AAsegment"><span class="nav-number">2.2.3.</span> <span class="nav-text">1.2.3 初始化每个segment</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8Dsegment"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 定位Segment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#concurrenthashmap%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.</span> <span class="nav-text">1.4 ConcurrentHashMap的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#get%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.1.</span> <span class="nav-text">1.4.1 get操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#put%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.2.</span> <span class="nav-text">1.4.2 put操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#size%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.3.</span> <span class="nav-text">1.4.3 size操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concurrentlinkedqueue"><span class="nav-number">3.</span> <span class="nav-text">2. ConcurrentLinkedQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#concurrentlinkedqueue%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 ConcurrentLinkedQueue的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A5%E9%98%9F%E5%88%97"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 入队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A5%E9%98%9F%E5%88%97%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.2.1 入队列的过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E5%B0%BE%E8%8A%82%E7%82%B9"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2.2 定位尾节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%A5%E9%98%9F%E8%8A%82%E7%82%B9%E4%B8%BA%E5%B0%BE%E8%8A%82%E7%82%B9"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.2.3 设置入队节点为尾节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hops%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.2.4.</span> <span class="nav-text">2.2.4 HOPS的设计</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E9%98%9F%E5%88%97"><span class="nav-number">3.3.</span> <span class="nav-text">2.3 出队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">4.</span> <span class="nav-text">3. Java中的阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 阻塞队列介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java%E9%87%8C%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 Java里的阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#arrayblockingqueue"><span class="nav-number">4.2.1.</span> <span class="nav-text">3.2.1 ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#linkedblockingqueue"><span class="nav-number">4.2.2.</span> <span class="nav-text">3.2.2 LinkedBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#priorityblockingqueue"><span class="nav-number">4.2.3.</span> <span class="nav-text">3.2.3 PriorityBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#delayqueue"><span class="nav-number">4.2.4.</span> <span class="nav-text">3.2.4 DelayQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#delayed%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.4.1.</span> <span class="nav-text">3.2.4.1 Delayed接口实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">4.2.4.2.</span> <span class="nav-text">3.2.4.2 实现延时阻塞队列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#delayqueue%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.2.4.3.</span> <span class="nav-text">3.2.4.3 DelayQueue应用场景</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronousqueue"><span class="nav-number">4.2.5.</span> <span class="nav-text">3.2.5 SynchronousQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#linkedtransferqueue"><span class="nav-number">4.2.6.</span> <span class="nav-text">3.2.6 LinkedTransferQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#linkedblockingdeque"><span class="nav-number">4.2.7.</span> <span class="nav-text">3.2.7 LinkedBlockingDeque</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 阻塞队列的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forkjoin%E6%A1%86%E6%9E%B6"><span class="nav-number">5.</span> <span class="nav-text">4. Fork&#x2F;Join框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#forkjoin%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 Fork&#x2F;Join框架介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 工作窃取算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forkjoin%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.3.</span> <span class="nav-text">4.3 Fork&#x2F;Join框架的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8forkjoin%E6%A1%86%E6%9E%B6"><span class="nav-number">5.4.</span> <span class="nav-text">4.4 使用Fork&#x2F;Join框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forkjoin%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">5.5.</span> <span class="nav-text">4.5 Fork&#x2F;Join框架的异常处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forkjoin%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.6.</span> <span class="nav-text">4.6 Fork&#x2F;Join框架的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#forkjointask%E7%9A%84fork%E6%96%B9%E6%B3%95"><span class="nav-number">5.6.1.</span> <span class="nav-text">4.6.1 ForkJoinTask的fork方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#forkjointask%E7%9A%84join%E6%96%B9%E6%B3%95"><span class="nav-number">5.6.2.</span> <span class="nav-text">4.6.2 ForkJoinTask的join方法</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wuyunjie"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">wuyunjie</p>
  <div class="site-description" itemprop="description">这是一个为了有博客而存在的博客。 会在这里记录技术学习，读书感悟，生活日记等等。欢迎呀！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">135</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wwwwwyj" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wwwwwyj" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wuyunjie.top/loving/happy-birthday" title="Loving → http:&#x2F;&#x2F;wuyunjie.top&#x2F;loving&#x2F;happy-birthday"><i class="fa fa-fw fa-heartbeat"></i>Loving</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wuyunjie</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">575k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:43</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            leancloudSelector(url).innerText = time;
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=xilgdic7Oc4jk1clqctOmHlW-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'xilgdic7Oc4jk1clqctOmHlW-gzGzoHsz',
            'X-LC-Key': '0mJaTLwPvm9HULVEKS5TMolA',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
        if (localhost.test(document.URL)) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>






        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>














  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'fuyVSSepSwnhxBAljzT0Wom8-MdYXbMMI',
    appKey: 'MeBSdvWlNAgNnXhX1HQ1QnA5',
    placeholder: "欢迎评论交流呀！\n输入邮箱可以收到回复通知哦!(昵称输入QQ可以自动识别邮箱和头像)",
    avatar: 'retro',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    enableQQ: true,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
