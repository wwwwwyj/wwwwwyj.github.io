<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">
  <link rel="alternate" href="/atom.xml" title="WuYJ's Blog" type="application/atom+xml">
  <meta name="google-site-verification" content="5Qe7cJKUxVbZsElTq6w1brLkQhcYBQXjnRmvHbU4JKo">
  <meta name="baidu-site-verification" content="code-oJllhY8gxe">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"hide","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>
  <meta name="description" content="1. 动态规划概述 1.1 简介 动态规划（dynamic programming）可以理解为是对递归算法的一种优化，是R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出的最优化原理(principle of optimality)，即把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系逐个求解。  dynamic">
<meta property="og:type" content="article">
<meta property="og:title" content="[数据结构和算法|动态规划]">
<meta property="og:url" content="https://wuyunjie.top/2021/07/22/Data_structure_and_algorithm_dynamic_programming.html">
<meta property="og:site_name" content="WuYJ&#39;s Blog">
<meta property="og:description" content="1. 动态规划概述 1.1 简介 动态规划（dynamic programming）可以理解为是对递归算法的一种优化，是R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出的最优化原理(principle of optimality)，即把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系逐个求解。  dynamic">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/dp/numBitBP.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ13/Reachable.PNG">
<meta property="article:published_time" content="2021-07-22T08:37:30.000Z">
<meta property="article:modified_time" content="2021-07-22T08:37:30.000Z">
<meta property="article:author" content="wuyunjie">
<meta property="article:tag" content="面试复习">
<meta property="article:tag" content="数据结构和算法">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/dp/numBitBP.PNG">

<link rel="canonical" href="https://wuyunjie.top/2021/07/22/Data_structure_and_algorithm_dynamic_programming.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>[数据结构和算法|动态规划] | WuYJ's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WuYJ's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">wuyunjie的小站</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>书单</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wuyunjie.top/2021/07/22/Data_structure_and_algorithm_dynamic_programming.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="wuyunjie">
      <meta itemprop="description" content="这是一个为了有博客而存在的博客。 会在这里记录技术学习，读书感悟，生活日记等等。欢迎呀！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WuYJ's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [数据结构和算法|动态规划]
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-22 16:37:30" itemprop="dateCreated datePublished" datetime="2021-07-22T16:37:30+08:00">2021-07-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构和算法</span>
                  </a>
                </span>
            </span>

          
            <span id="/2021/07/22/Data_structure_and_algorithm_dynamic_programming.html" class="post-meta-item leancloud_visitors" data-flag-title="[数据结构和算法|动态规划]" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/22/Data_structure_and_algorithm_dynamic_programming.html#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/22/Data_structure_and_algorithm_dynamic_programming.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="动态规划概述">1. 动态规划概述</h3>
<h4 id="简介">1.1 简介</h4>
<p>动态规划（<code>dynamic programming</code>）可以理解为是对递归算法的一种优化，是R.E.Bellman等人在研究多阶段决策过程(<code>multistep decision process</code>)的优化问题时，提出的最优化原理(<code>principle of optimality</code>)，即把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系逐个求解。</p>
<blockquote>
<p><code>dynamic programming</code>的名字是为了<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/39948290/answer/83920614">规避军方的厌恶</a></p>
</blockquote>
<span id="more"></span>
<h4 id="基本思想">1.2 基本思想</h4>
<p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。动态规划过程是：</p>
<blockquote>
<p><strong><u>每次决策依赖于当前状态，又随即引起状态的转移</u></strong>。</p>
</blockquote>
<p>动态规划将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。能采用动态规划求解的问题的一般要具有3个性质：</p>
<ul>
<li><strong>最优化原理</strong>：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</li>
<li><strong>无后效性</strong>：即某阶段状态一旦确定，就不受这个状态以后决策的影响。</li>
<li><strong>有重叠子问题</strong>：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。这<strong><u>并非必要条件</u></strong>，但满足这个条件动态规划才能发挥出较大的优势。</li>
</ul>
<h4 id="求解的基本步骤">1.3 求解的基本步骤</h4>
<p>动态规划一般要经历以下几个步骤：</p>
<ul>
<li><strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。</li>
<li><strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的不同的状态表示出来。确定<code>状态</code>需要满足<strong>最优化原理</strong>和<strong>无后效性</strong>。</li>
<li><strong>确定决策并写出状态转移方程</strong>：根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</li>
<li><strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</li>
</ul>
<p>可以看出，动态规划最主要的两个核心部分是：<code>DP 状态</code>和<code>DP 转移方程</code>。整个求解过程可以用一个<strong><u>最优决策表</u></strong>来描述：</p>
<ul>
<li><code>最优决策表</code>是一个<strong>二维表</strong>，其中<strong><u>行表示决策的阶段</u></strong>，列表示<strong><u>问题状态</u></strong>，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值；</li>
<li>填表的过程就是根据递推关系，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</li>
</ul>
<h4 id="动态规划与递归">1.4 动态规划与递归</h4>
<p>动态规划是<strong>自底向上</strong>，递归树是<strong>自顶向下</strong>。</p>
<ul>
<li><p><strong>自顶向下</strong>的递归。从规模较大的原问题比如说 <span class="math inline">\(f(n)\)</span>，向下逐渐分解规模直到边界条件<span class="math inline">\(f(1)\)</span>触底，然后逐层返回答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="keyword">return</span> Fibonacci1(n-<span class="number">1</span>) + Fibonacci1(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>自底向上</strong>的动态规划。从问题规模最小的<span class="math inline">\(f(1)\)</span>，直到推到得到原问题答案<span class="math inline">\(f(n)\)</span>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span>[] dp = <span class="keyword">new</span> dp[N + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="变体">1.4 变体</h4>
<h5 id="数位dp">1.4.1 <code>数位dp</code></h5>
<p>可以看这个视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ip4y1v7zw?from=search&amp;seid=13099671920328002016">数位DP</a>。数位DP解决的问题是：</p>
<blockquote>
<p>求出在给定区间<span class="math inline">\([A,B]\)</span>内，符合条件<span class="math inline">\(f(i)\)</span>的数<span class="math inline">\(i\)</span>的个数。条件<span class="math inline">\(f(i)\)</span>一般与数的大小无关，而与数的组成有关由于数是按位dp，<strong>数的大小对复杂度的影响很小</strong>。</p>
</blockquote>
<p>暴力解法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=A; i&lt;=B; i++)</span><br><span class="line">	<span class="keyword">if</span>(f(i)) ans++;</span><br></pre></td></tr></table></figure>
<p>引入数位的概念，使得新的枚举方式满足dp的性质，然后记忆化搜索。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/JavaLearning/java/dataStructureAndAlgorithm/dp/numBitBP.PNG" alt="数位搜索" /><figcaption aria-hidden="true">数位搜索</figcaption>
</figure>
<p>从起点向下搜索，到最底层得到方案数，一层一层向上返回答案并累加，最后从搜索起点得到最终答案。主要涉及以下参数：</p>
<ul>
<li>数位dp基本的量数字位数<code>pos</code>，记录答案的<code>st</code>；</li>
<li>最高位限制<code>limit</code>。</li>
<li>判断<strong>前导0</strong>的标记<code>lead</code>。部分题目中，前导0会影响答案结果，需要进行区分。</li>
<li>经常要比较当前位和前一位或前几位的关系，一般在<code>dfs()</code>中也要记录前一位或前几位数<code>pre</code>。</li>
<li>更多参量以区分状态，视题意而定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">long</span> dp[<span class="number">20</span>][state];<span class="comment">//不同题目状态不同</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="comment">/*其他state变量*/</span>,<span class="keyword">boolean</span> lead<span class="comment">/*前导零*/</span>,<span class="keyword">boolean</span> limit<span class="comment">/*数位上界变量*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归边界，按位枚举最低位是0，pos &lt; 0 说明这个数枚举完了</span></span><br><span class="line">    <span class="comment">// 这里一般返回1，表示枚举的这个数是合法的</span></span><br><span class="line">    <span class="comment">// 也可能返回别的值</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记忆化</span></span><br><span class="line">    <span class="comment">// !limit 代表非边界状态，无需特殊处理</span></span><br><span class="line">    <span class="comment">// dp[pos][state] != -1 代表已经遍历过了</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state] != -<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> dp[pos][state];</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//根据limit判断枚举的上界up</span></span><br><span class="line">    <span class="keyword">int</span> up = limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">long</span> ans=<span class="number">0</span>; <span class="comment">// 开始计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up;i++) &#123; <span class="comment">//枚举，然后把不同情况的个数加到ans就可以了</span></span><br><span class="line">        <span class="keyword">if</span>() ...</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>()...</span><br><span class="line">        ans+=dfs(pos-<span class="number">1</span>,<span class="comment">/*状态转移*/</span>,lead &amp;&amp; i==<span class="number">0</span>,limit &amp;&amp; i==a[pos]) <span class="comment">//最后两个变量传参都是这样写的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算完，记录状态</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead) dp[pos][state]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123; <span class="comment">//把数位都分解出来</span></span><br><span class="line">        a[pos++] = x % <span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// //刚开始最高位都是有限制并且有前导零的</span></span><br><span class="line">    <span class="keyword">return</span> dfs(pos-<span class="number">1</span><span class="comment">/*从最高位开始枚举*/</span>,<span class="comment">/*一系列状态 */</span>,<span class="keyword">true</span>,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="背包问题">1.4.2 <code>0/1</code>背包问题</h5>
<blockquote>
<p>有一个容量有限的背包，总容量为<code>c</code>，有<code>n</code>个可待选择的物品，<strong><u>每个物品只有一件</u></strong>，它们都有各自的重量和价值，需要从中选择合适的组合来使得背包中的物品总价值最大。</p>
</blockquote>
<p>背包问题抽象为寻找组合<span class="math inline">\(\{x_1,x_2,x_3,...,x_n\}\)</span>​​​ （其中<span class="math inline">\(x_i\)</span>​​​取<code>0</code>或<code>1</code>，表示第<span class="math inline">\(i\)</span>个物品取或者不取），<span class="math inline">\(v_i\)</span>代表第<span class="math inline">\(i\)</span>个物品的价值，<span class="math inline">\(w_i\)</span>代表第<span class="math inline">\(i\)</span>个物品的重量，总物品数为<span class="math inline">\(n\)</span>，背包容量为<span class="math inline">\(c\)</span>。问题即求解： <span class="math display">\[
\textbf{目标}：&amp; max\{ x_1v_1 + x_2v_2 + x_3v_3 + ... + x_nv_n \} \\
\textbf{约束条件}：&amp; x_1w_1 + x_2w_2 + x_3w_3 + ... + x_nw_n &lt; c
\]</span> 证明最优化原理：</p>
<blockquote>
<p>假设<span class="math inline">\((x_1，x_2，…，x_n)\)</span>是<span class="math inline">\(0/1\)</span>背包问题的最优解，则有<span class="math inline">\((x_2，x_3，…，x_n)\)</span>是其子问题的最优解，假设<span class="math inline">\((y_2，y_3，…，y_n)\)</span>是上述问题的子问题最优解，则有<span class="math inline">\((v_2y_2+v_3y_3+…+v_ny_n)+v_1x_1 &gt; (v_2x_2+v_3x_3+…+v_nx_n)+v_1x_1\)</span>。说明<span class="math inline">\((X_1，Y_2，Y_3，…，Y_n)\)</span>才是该<span class="math inline">\(0/1\)</span>背包问题的最优解，这与最开始的假设相矛盾，故满足<code>最优性原理</code>。</p>
</blockquote>
<p>用<span class="math inline">\(dp[i][j]\)</span>表示第<span class="math inline">\(i\)</span>件物品放入容量为<span class="math inline">\(j\)</span>的背包所得的最大价值，则状态转移方程可以推出如下： <span class="math display">\[
dp[i][j]=max\{dp[i-1][j-v[i]]+c[i],dp[i-1][j]\};、
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) <span class="comment">//枚举物品  &#123;  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= C; j++) &#123; <span class="comment">//枚举背包容量    </span></span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j];  </span><br><span class="line">        <span class="comment">// 能装下物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= v[i]) &#123;</span><br><span class="line">            <span class="comment">// 选择最优装法</span></span><br><span class="line">            f[i][j] = Max(f[i - <span class="number">1</span>][j],f[i - <span class="number">1</span>][j - v[i]] + c[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数的划分">1.4.2 数的划分</h5>
<p>将整数<code>n</code>分成<code>k</code>份，且每份不能为空，任意两种分法不能相同（不考虑顺序）。</p>
<blockquote>
<p>例如：<code>n=7, k=3</code>，下面三种分法被认为是相同的：<code>5,1,1; 1, 1, 5; 1, 5, 1</code>。</p>
</blockquote>
<p>问有多少种不同的分法。</p>
<p>用<span class="math inline">\(dp[i][j]\)</span>表示将整数 <span class="math inline">\(i\)</span> 划分为 <span class="math inline">\(j\)</span> 份的方案数。由于每份不为空，需要先拿出<span class="math inline">\(j\)</span>个<span class="math inline">\(1\)</span>放到<span class="math inline">\(j\)</span>份上，此时剩下<span class="math inline">\(i-j\)</span>个数，可以将其放到<span class="math inline">\(1 \to j\)</span>份中，将其累加集可得到<span class="math inline">\(dp[i][j]\)</span>。所以<span class="math inline">\(dp[i][j]\)</span>的动态转移方程为： <span class="math display">\[
dp[i][j] = dp[i-j][1]+dp[i-j][2]+...+dp[i-j][j]
\]</span> 可以进行规约： <span class="math display">\[
dp[i-1,j-1]=dp[(i-1)-(j-1)][1]+dp[(i-1)-(j-1)][2]+...+dp[(i-1)-(j-1)][j-1]
\\ = dp[i-j][1]+dp[i-j][2]+...+dp[i-j][j-1]
\]</span> 合并两个公式得到： <span class="math display">\[
dp[i][j] = dp[i-j][j] + dp[i-1][j-1]
\]</span> 也可以将这个转移方程理解为，分割方法可以分为两类：</p>
<ul>
<li>第一类：<code>n</code>份中不包含 <code>1</code> 的分法，为保证每份都 <code>&gt;= 2</code>，可以先拿出 <code>k</code> 个 <code>1</code> 分到每一份，然后再把剩下的 <code>n-k</code> 分成 <code>k</code> 份即可，分法有： <code>dp[n-k][k]</code></li>
<li>第二类: <code>n</code> 份中<strong><u>至少有一份</u></strong>为 <code>1</code> 的分法，可以先那出一个 <code>1</code> 作为单独的<code>1</code>份，剩下的 <code>n-1</code> 再分成 <code>k-1</code> 份即可，分法有：<code>dp[n-1][k-1]</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">spiltNums</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][k+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对于dp[0][0]作特殊处理（为了后面的动态转移方程能够起作用）</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="comment">//j的范围是1~k（不能超过需要划分的份数）</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">			dp[i][j] = dp[i-j][j] + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划题解">2. 动态规划题解</h3>
<h4 id="剑指offer-10-斐波那契数列">2.1 剑指offer-10 斐波那契数列</h4>
<p>斐波那契数列的标准公式为： <span class="math display">\[
F(1)=1;F(2)=2\\F(n)=F(n-1)+F(n-2)(n \geq 3, n \in N^*)
\]</span></p>
<p>可以看出定义即为转移方程的定义，可以很容易写出其动态规划实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] fibDP = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        fibDP[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        fibDP[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            fibDP[i] = (fibDP[i-<span class="number">1</span>] + fibDP[i-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fibDP[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指offer-10-跳台阶">2.2 剑指offer-10 跳台阶</h4>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p>
</blockquote>
<p>实际上是斐波那契数列的变种，求第<span class="math inline">\(n\)</span>个台阶的跳法时，需要之前的两个状态：</p>
<ul>
<li>上一步跳<code>1</code>级台阶，求跳到<code>n-1</code>级台阶的方法；</li>
<li>上一步跳<code>2</code>级台阶，求跳到<code>n-2</code>级台阶的方法；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n== <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span>[] numWays = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        numWays[<span class="number">1</span>] = <span class="number">1</span>; numWays[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            numWays[i] = (numWays[i-<span class="number">1</span>] + numWays[i-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numWays[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指offer-13-机器人的运动范围">2.3 剑指offer-13 机器人的运动范围</h4>
<blockquote>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
</blockquote>
<p>搜索的过程中搜索方向可以缩减为向右和向下，由可达解分析机器人可 <strong>仅通过向右和向下移动，访问所有可达解</strong> 。</p>
<figure>
<img src="https://raw.githubusercontent.com/wwwwwyj/image_repository/master/img/blog/jzoffer/JZ13/Reachable.PNG" alt="可达解分析" /><figcaption aria-hidden="true">可达解分析</figcaption>
</figure>
<p>所以 <code>(i, j)</code> 的格子只会从 <code>(i - 1, j)</code> 或者 <code>(i, j - 1)</code> 两个格子走过来（不考虑边界条件），那么 <code>vis[i][j]</code> 是否可达的状态则可由如下公式计算得到：</p>
<p><span class="math display">\[
vis[i][j]=vis[i−1][j]\ \ or\ \ vis[i][j−1]
\]</span> 因此只要遍历所有格子，递推计算出它们是否可达然后用变量 <code>ans</code> 记录可达的格子数量即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] movingCountDP = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        movingCountDP[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( reachable(i, j, k) ) &#123;</span><br><span class="line">                    <span class="comment">// 转移方程</span></span><br><span class="line">                    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) movingCountDP[i][j] = movingCountDP[i - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) movingCountDP[i][j] = movingCountDP[i][j-<span class="number">1</span>] &gt; <span class="number">0</span> ? <span class="number">1</span> : movingCountDP[i][j];</span><br><span class="line">                    ans += movingCountDP[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reachable</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> || j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += (i % <span class="number">10</span> + j % <span class="number">10</span>);</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法缺点是，许多不可达的节点也需要进行计算，应该可以进行进一步优化。</p>
<h4 id="剑指-offer-14--i.-剪绳子">2.4 剑指 Offer 14- I. 剪绳子</h4>
<blockquote>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]<em>k[1]</em>...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
</blockquote>
<p>先把绳子剪掉第一段（长度为<code>j</code>），剩下<code>(i - j)</code>长度可以剪也可以不剪。</p>
<ul>
<li>如果不剪，这种分割方法长度乘积即为<code>j * (i - j)</code>；</li>
<li>如果继续剪，这种分割方法长度乘积即为<code>j * dp[i - j]</code>；</li>
<li>取两者最大值<code>max(j * (i - j), j * dp[i - j])</code>。</li>
</ul>
<p>因此<code>dp[i]</code>的转移方程为 <span class="math display">\[
dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++ ) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * (i-j), j * dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题实际上有更优化的解法，需要结合数学推理和贪心算法，具体可以参考对这道题的解析：<a href="">待完善</a>。</p>
<h4 id="剑指-offer-19.-正则表达式匹配">2.5 剑指 Offer 19. 正则表达式匹配</h4>
<blockquote>
<p>请实现一个函数用来匹配包含<code>'. '</code>和<code>'*'</code>的正则表达式。模式中的字符<code>'.'</code>表示任意一个字符，而<code>'*'</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。</p>
</blockquote>
<p>用 <span class="math inline">\(f[i][j]\)</span> 表示 <span class="math inline">\(s\)</span> 的前 <span class="math inline">\(i\)</span> 个字符与 <span class="math inline">\(p\)</span>​ 中的前 <span class="math inline">\(j\)</span> 个字符是否能够匹配。在进行状态转移时，考虑 <span class="math inline">\(p\)</span> 的第 <span class="math inline">\(j\)</span> 个字符的匹配情况：</p>
<ul>
<li><p>如果 <span class="math inline">\(p\)</span>​ 的第 <span class="math inline">\(j\)</span>​​ 个字符是一个<code>正常字符</code>，那么必须在 <span class="math inline">\(s\)</span> 中匹配一个相同的正常字符： <span class="math display">\[
f[i][j] = 
  \begin{cases}
      f[i-1][j-1], &amp; s[i]=p[j] \\ 
      \text { false, } &amp; s[i] \neq p[j]\end{cases}
\]</span></p></li>
<li><p>如果 <span class="math inline">\(p\)</span> 的第 <span class="math inline">\(j\)</span> 个字符是 <code>'*'</code>，那么就表示可以对 <span class="math inline">\(p\)</span> 的第 <span class="math inline">\(j-1\)</span> 个字符匹配任意次数。</p>
<ul>
<li><p>如果匹配 <span class="math inline">\(0\)</span>​ 次： <span class="math display">\[
f[i][j]=f[i][j−2]
\]</span></p></li>
<li><p>匹配 <span class="math inline">\(s\)</span>​ 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；不匹配字符，丢掉带星号的组合，不再继续匹配。 <span class="math display">\[
f[i][j] = f[i-1][j] or f[i][j-2]，s[i] = p[j-1]
\]</span></p></li>
</ul></li>
<li></li>
</ul>
<p>最终的状态转移方程如下： <span class="math display">\[
f[i][j]= 
\begin{cases}
    \text { if }\left(p[j] \neq &#39;*&#39; \right) = 
        \begin{cases}
            f[i-1][j-1], &amp; \text { matches }(s[i], p[j]) \\ 
            \text { false, } &amp; \text { otherwise }
        \end{cases} \\ 
    \text { otherwise }= 
        \begin{cases}
            f[i-1][j] \text { or } f[i][j-2], &amp; \text { matches }(s[i], p[j-1]) \\ 
            f[i][j-2], &amp; \text { otherwise }
        \end{cases}
\end{cases}
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> pLen = p.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第零行表示其中一个为空串时的结果</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sLen+<span class="number">1</span>][pLen+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pLen; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前判断的 第 j 个 p 字符为&quot;*&quot;</span></span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span> ) &#123;</span><br><span class="line">                    <span class="comment">// 匹配 0 次</span></span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    <span class="comment">// 匹配 n 次</span></span><br><span class="line">                    <span class="keyword">if</span> ( matches(s, p, i, j-<span class="number">1</span>) ) &#123;</span><br><span class="line">                        dp[i][j] |= dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 正常字符</span></span><br><span class="line">                    <span class="keyword">if</span> ( matches(s, p, i, j) ) &#123;</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[sLen][pLen];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="offer-42.-连续子数组的最大和">2.6 Offer 42. 连续子数组的最大和</h4>
<blockquote>
<p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
</blockquote>
<p>我们用 <span class="math inline">\(f(i)\)</span>​​​ 代表以第 <span class="math inline">\(i\)</span>​​​​ 个数结尾的「连续子数组的最大和」。可以考虑 <span class="math inline">\(nums[i]\)</span>​​ 单独成为一段还是加入 <span class="math inline">\(f(i−1)\)</span>​​ 对应的那一段，这取决于 <span class="math inline">\(nums[i]\)</span>​ 和 <span class="math inline">\(f(i−1)+nums[i]\)</span> 的大小，于是可以写出这样的动态规划转移方程： <span class="math display">\[
f(i)=max\{f(i−1)+nums[i],nums[i]\}
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = Math.max(nums[i], nums[i] + nums[i-<span class="number">1</span>]);</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-43.-1n-整数中-1-出现的次数">2.7 剑指 Offer 43. 1～n 整数中 1 出现的次数</h4>
<blockquote>
<p>输入一个整数 <code>n</code> ，求1～n这n个整数的十进制表示中1出现的次数。</p>
</blockquote>
<p>这道题有直接基于规律统计的方法。但还有一种基于动态规划的方法——<code>数位dp</code>，按数位来遍历。状态转移方程为： <span class="math display">\[
dp[pos][count] = 
\left\{
    \begin{array}{lr}
    dp[pos][count] &amp; , pos &lt; up \ \&amp; \ not \ limit \\
    \sum_0^{up}{dfs(pos-1, limit=true)} &amp; , else  \\
    \end{array}
\right.
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] num;</span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>];</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> numLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            num[numLen++] = n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; ++i) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);<span class="comment">//初始化dp数组，用-1表示对应的dfs有没有执行过</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(numLen - <span class="number">1</span> , <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> count, <span class="keyword">boolean</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!limit &amp;&amp; dp[pos][count] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[pos][count];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> up = limit ? num[pos] : <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= up; i++) &#123;</span><br><span class="line">            res += dfs(pos - <span class="number">1</span>, (i == <span class="number">1</span>) ? count+<span class="number">1</span> : count, limit &amp;&amp; i == up);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!limit) dp[pos][count] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-46.-把数字翻译成字符串">2.8 剑指 Offer 46. 把数字翻译成字符串</h4>
<blockquote>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
</blockquote>
<p>用 <span class="math inline">\(f(i)\)</span> 表示以第 <span class="math inline">\(i\)</span>​ 位结尾的前缀串翻译的方案数，这时有两种选择：</p>
<ul>
<li>单独翻译第 <span class="math inline">\(i\)</span>​​ 位，对 <span class="math inline">\(f(i)\)</span> 的贡献为 <span class="math inline">\(f(i - 1)\)</span>；</li>
<li>如果第 <span class="math inline">\(i−1\)</span>​ 位存在，并且第 <span class="math inline">\(i - 1\)</span>​ 位和第 <span class="math inline">\(i\)</span>​ 位形成的数字 <span class="math inline">\(x\)</span>​ 满足 <span class="math inline">\(10 \leq x \leq 25\)</span>，那么就可以把第 <span class="math inline">\(i−1\)</span> 位和第 <span class="math inline">\(i\)</span> 位连起来一起翻译，对 <span class="math inline">\(f(i)\)</span> 的贡献为 <span class="math inline">\(f(i - 2)\)</span>，否则为 0。</li>
</ul>
<p>可以列出动态规划转移方程： <span class="math display">\[
f(i)= 
\left\{
    \begin{array}{lr}
    f(i-1)+f(i-2), num[i-1] \geq 0 \ \&amp; \ 10 \leq x \leq 25 \\
    f(i-1), else  \\
    \end{array}
\right.
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        </span><br><span class="line">        String numStr = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> numLen = numStr.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[numLen];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        dp[<span class="number">1</span>] = numStr.substring(<span class="number">0</span>, <span class="number">2</span>).compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; numLen; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            String pre = numStr.substring(i-<span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ( pre.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> &amp;&amp; pre.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">                dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[numLen-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-47.-礼物的最大价值">2.9 剑指 Offer 47. 礼物的最大价值</h4>
<blockquote>
<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
</blockquote>
<p>可以看作找连续子数组的最大和的升级版，从一维数组变为了二维数组，但思想上是差不多的。只可能每次向右或者向下移动一格，设 <code>f(i,j)</code> 为从棋盘左上角走至单元格 <code>(i,j)</code> 的礼物最大累计价值，易得到以下递推关系：<code>f(i,j)</code> 等于 <code>f(i,j−1)</code> 和 <code>f(i−1,j)</code> 中的较大值加上当前单元格礼物价值 <code>grid(i,j)</code> 。 <span class="math display">\[
f(i,j) = \max[f(i,j-1), f(i-1,j)] + grid(i,j)
\]</span></p>
<p><span class="math display">\[
dp(i, j) = 
\begin{cases}
    \operatorname{grid}(i, j) &amp; , i=0, j=0 \\ 
    \operatorname{grid}(i, j)+d p(i, j-1) &amp; , i=0, j \neq 0 \\ 
    \operatorname{grid}(i, j)+d p(i-1, j) &amp; , i \neq 0, j=0 \\ 
    \operatorname{grid}(i, j)+\max [d p(i-1, j), d p(i, j-1)] &amp; , i \neq 0, j \neq 0
\end{cases}
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxGift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) dp[i][j] = dp[i][j - <span class="number">1</span>] +  grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[ grid.length - <span class="number">1</span> ][ grid[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-49.-丑数">2.10 剑指 Offer 49. 丑数</h4>
<blockquote>
<p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
</blockquote>
<p>定义数组 <span class="math inline">\(dp\)</span>​​，其中 <span class="math inline">\(dp[i]\)</span> 表示第 <span class="math inline">\(i\)</span> 个丑数，第 <span class="math inline">\(n\)</span> 个丑数即为 <span class="math inline">\(dp[n]\)</span>。最小的丑数是 <span class="math inline">\(1\)</span>，因此 <span class="math inline">\(dp[1]=1\)</span>。</p>
<ul>
<li>定义三个指针 <span class="math inline">\(p_2,p_3,p_5\)</span>，表示下一个丑数是当前指针指向的丑数乘以对应的质因数。初始时，三个指针的值都是 <span class="math inline">\(1\)</span>。</li>
<li>可以定义转移方程：</li>
</ul>
<p><span class="math display">\[
\textit{dp}[i]=\min(\textit{dp}[p_2] \times 2, \textit{dp}[p_3] \times 3, \textit{dp}[p_5] \times 5)
\]</span></p>
<ul>
<li>比较 <span class="math inline">\(\textit{dp}[i]\)</span> 和 <span class="math inline">\(\textit{dp}[p_2],\textit{dp}[p_3],\textit{dp}[p_5]\)</span>，如果相等则将对应的指针加 <code>1</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n ; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur2 = <span class="number">2</span> * dp[p2], cur3 = <span class="number">3</span> * dp[p3], cur5 = <span class="number">5</span> * dp[p5];</span><br><span class="line">            dp[i] = Math.min(cur2, Math.min(cur3, cur5));</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == cur2) p2++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == cur3) p3++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == cur5) p5++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-offer-60.-n个骰子的点数">2.11 剑指 Offer 60. n个骰子的点数</h4>
<blockquote>
<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
</blockquote>
<p>设输入 <span class="math inline">\(n\)</span>​个骰子的解（即概率列表）为 <span class="math inline">\(f(n)\)</span>​，其中「点数和」 <span class="math inline">\(x\)</span>​ 的概率为 <span class="math inline">\(f(n, x)\)</span>​。假设已知 <span class="math inline">\(n - 1\)</span>​ 个骰子的解 <span class="math inline">\(f(n - 1)\)</span>，此时添加一枚骰子，求 <span class="math inline">\(n\)</span> 个骰子的点数和为 <span class="math inline">\(x\)</span> 的概率 <span class="math inline">\(f(n, x)\)</span>。</p>
<ul>
<li>当添加骰子的点数为 <span class="math inline">\(1\)</span> 时，前 <span class="math inline">\(n - 1\)</span> 个骰子的点数和应为 <span class="math inline">\(x - 1\)</span>，方可组成点数和 <span class="math inline">\(x\)</span>；</li>
<li>同理，当此骰子为 <span class="math inline">\(i\)</span> 时，前 <span class="math inline">\(n - 1\)</span> 个骰子应为 <span class="math inline">\(x - i\)</span>；</li>
<li>递推公式如下所示：</li>
</ul>
<p><span class="math display">\[
f(n, x) = \sum_{i=1}^6 f(n - 1, x - i) \times \frac{1}{6}
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] dicesProbability(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] probs = <span class="keyword">new</span> <span class="keyword">double</span>[ <span class="number">6</span> * n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i) probs[i] = <span class="number">1.0</span> / <span class="number">6.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = i*<span class="number">6</span>; x &gt;= i; x--) &#123;</span><br><span class="line">                <span class="comment">// 因为是从后往前逐个累加，在加到当前点数时，必须把原先存放的n-1个骰子的数据置0</span></span><br><span class="line">                probs[x] = <span class="number">0.0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// n-1个骰子的最小值就是n-1</span></span><br><span class="line">                    <span class="keyword">if</span> (x - j  &gt;= i-<span class="number">1</span>) &#123;</span><br><span class="line">                        probs[x] += probs[x-j] / <span class="number">6.0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>*n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= <span class="number">6</span>*n; i++) &#123;</span><br><span class="line">            res[i - n] = probs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<h4 id="剑指-offer-63.-股票的最大利润">2.12 剑指 Offer 63. 股票的最大利润</h4>
<blockquote>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
</blockquote>
<p>感觉应该是个简单题，思路就是找两个数字之间的最大差值。使用动态规划的思想，设 <span class="math inline">\(dp[i]\)</span> 为前 <span class="math inline">\(i\)</span> 天股票的最低价格，<span class="math inline">\(maxProfit\)</span> 是当前已经获取的最大利润，那么有转移方程： <span class="math display">\[
dp[i] = min(prices[i], dp[i-1]) \\
maxProfit = max(maxPtofit, prices[i] - dp[i])
\]</span> 实际上只用两个变量直接遍历数组一遍就可以得到答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            res = Math.max(res, prices[i] - prices[i-<span class="number">1</span>]);</span><br><span class="line">            prices[i] = Math.min(prices[i], prices[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="leetcode-62-不同路径">2.13 leetcode-62 不同路径</h4>
<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
</blockquote>
<p>比起剑指Offer那道题来说，约束条件更加明确。由于只能向下或向右移动，到达 <code>(i, j)</code>单元格的方法数只与 <code>(i-1, j )</code>和 <code>(i, j-1)</code>两个单元格的状态有关。可以得到转移方程： <span class="math display">\[
dp[i][j] = dp[i-1][j] + dp[i][j-1]
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = (i - <span class="number">1</span> &gt;= <span class="number">0</span> ? dp[i - <span class="number">1</span>][j] : <span class="number">0</span>) +  (j - <span class="number">1</span> &gt;= <span class="number">0</span> ? dp[i][j - <span class="number">1</span>] : <span class="number">0</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="leetcode-871.-最低加油次数">2.14 leetcode-871. 最低加油次数</h4>
<blockquote>
<p>汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。</p>
<p>沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1] 升汽油。</p>
<p>假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。</p>
<p>当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。</p>
<p>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。</p>
<p>注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。</p>
</blockquote>
<p>用<span class="math inline">\(dp[i]\)</span>表示只加 <span class="math inline">\(i\)</span>​​​ 次油可以到达的最远距离。那么最后只需要求解<span class="math inline">\(dp\)</span>中可以到达<span class="math inline">\(target\)</span>的最小 <span class="math inline">\(i\)</span>，求解<span class="math inline">\(dp\)</span>的状态转移方程为： <span class="math display">\[
dp[k+1] =
\begin{cases}
    \operatorname{max}(dp[k+1], dp[k]+stations[i][0]) &amp; , stations[i][0] \leq dp[k] \\ 
    dp[k+1] &amp; , else \\ 
\end{cases}
\]</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minRefuelStops</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> startFuel, <span class="keyword">int</span>[][] stations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startFuel &gt;= target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[stations.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = startFuel;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stations.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[k] &gt;= stations[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                    dp[k+<span class="number">1</span>] = Math.max(dp[k+<span class="number">1</span>], dp[k] + stations[i][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= stations.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt;= target) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题也可以用优先队列求解，先求当前能到达的最远距离，然后当不够到达下一个地点时，选择之前路过可选的最大油量，加一次油继续前进，直到到达最终<span class="math inline">\(targer\)</span>，可以得到最小的加油次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minRefuelStops</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> startFuel, <span class="keyword">int</span>[][] stations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startFuel &gt;= target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minRefuel = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; topFuel = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer one, Integer two)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> two - one;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> curStation = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curFuel = startFuel;</span><br><span class="line">        <span class="keyword">int</span> N = stations.length;</span><br><span class="line">        <span class="keyword">while</span> (curStation &lt; N) &#123;</span><br><span class="line">            <span class="comment">// 当前可以前进距离</span></span><br><span class="line">            <span class="keyword">while</span> (curStation &lt; N &amp;&amp; curFuel &gt;= stations[curStation][<span class="number">0</span>]) &#123;</span><br><span class="line">                topFuel.offer(stations[curStation++][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(target &lt;= curFuel ) <span class="keyword">return</span> minRefuel;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (curFuel &lt; target &amp;&amp; ! topFuel.isEmpty()) &#123;</span><br><span class="line">                curFuel += topFuel.poll();</span><br><span class="line">                minRefuel++;</span><br><span class="line">                <span class="keyword">if</span> (target &lt;= curFuel) <span class="keyword">return</span> minRefuel;</span><br><span class="line">                <span class="keyword">if</span> (curStation &lt; N &amp;&amp; curFuel &gt;= stations[curStation][<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curStation &lt; N &amp;&amp; curFuel &lt; stations[curStation][<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分苹果">2.15 分苹果</h4>
<blockquote>
<p>M个相同苹果放到N个相同篮子里有多少种放法,<strong><u>允许有篮子不放</u></strong>。</p>
</blockquote>
<p>设<code>dp[m][n]</code>为<code>m</code>个苹果，<code>n</code>个盘子的放法数目：</p>
<ul>
<li>当<code>n &gt; m</code>：必定有<code>n - m</code>个盘子永远空着，它们对摆放苹果方法数目不产生影响。即<code>dp[m][n] = dp[m][m] (n&gt;m)</code></li>
<li>当<code>n &lt;= m</code>：不同的放法可以分成两类：
<ul>
<li>有至少一个盘子空着，即相当于<code>dp[m][n-1]</code>;</li>
<li>所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即<code>dp[m-n,n]</code>。</li>
<li>而总的放苹果的放法数目等于两者的和，即 <code>dp[m][n] = dp[m][n-1] + dp[m-n][n]</code></li>
</ul></li>
</ul>
<h4 id="数的划分-1">2.16 数的划分</h4>
<h5 id="将n划分成不大于m的划分法">2.16.1 将n划分成不大于m的划分法</h5>
<ul>
<li><p>若是划分多个整数可以存在相同的：</p>
<p><code>dp[n][m]= dp[n][m-1]+ dp[n-m][m]</code> ， <code>dp[n][m]</code>表示整数 <code>n</code> 的划分中，每个数不大于 <code>m</code> 的划分数。则划分数可以分为两种情况：</p>
<ul>
<li>划分中每个数都小于 <code>m</code>，相当于每个数不大于 <code>m-1</code>，故划分数为 <code>dp[n][m-1]</code>；</li>
<li>划分中有一个数为 <code>m</code>. 那就在 <code>n</code> 中减去 <code>m</code>，剩下的就相当于把 <code>n-m</code> 进行划分，故划分数为 <code>dp[n-m][m]</code>。</li>
</ul></li>
<li><p>若是划分多个不同的整数：</p>
<p><code>dp[n][m]= dp[n][m-1]+ dp[n-m][m-1]</code>， <code>dp[n][m]</code>表示整数 <code>n</code> 的划分中，每个数不大于 <code>m</code> 的划分数。同样划分情况分为两种情况：</p>
<ul>
<li>划分中每个数都小于<code>m</code>，相当于每个数不大于 <code>m-1</code>，划分数为 <code>dp[n][m-1]</code>；</li>
<li>划分中有一个数为 <code>m</code>，在<code>n</code>中减去<code>m</code>，剩下相当对<code>n-m</code>进行划分，且每一个数不大于<code>m-1</code>，故划分数为 <code>dp[n-m][m-1]</code>。</li>
</ul></li>
</ul>
<h5 id="将n划分成k个数的划分法">2.16.2 将n划分成k个数的划分法</h5>
<p><code>dp[n][k]= dp[n-k][k]+ dp[n-1][k-1]</code>，方法可以分为两类：</p>
<ul>
<li>第一类： <code>n</code> 份中不包含 1 的分法，为保证每份都 <code>&gt;= 2</code>，可以先拿出 <code>k</code> 个 <code>1</code> 分到每一份，然后再把剩下的 <code>n- k</code> 分成 <code>k</code> 份即可，分法有：<code>dp[n-k][k]</code>；</li>
<li>第二类: <code>n</code> 份中至少有一份为 <code>1</code> 的分法，可以先那出一个 <code>1</code> 作为单独的 <code>1</code> 份，剩下的 <code>n-1</code> 再分成 <code>k- 1</code> 份即可，分法有：<code>dp[n-1][k-1]</code></li>
</ul>
<h5 id="将n划分成若干奇数的划分法">2.16.3.将n划分成若干奇数的划分法</h5>
<p><code>g[i][j]</code>：将<code>i</code>划分为<code>j</code>个偶数；<code>f[i][j]</code>：将<code>i</code>划分为<code>j</code>个奇数</p>
<ul>
<li><code>g[i][j] = f[i - j][j]</code></li>
<li><code>f[i][j] = f[i - 1][j - 1] + g[i - j][j]</code></li>
</ul>
<p>方法可以分为两类：</p>
<ul>
<li><p>第一类：<code>i</code>中拿出<code>j</code>个<code>1</code>分到每一份中，将剩余的<code>i-j</code>分成<code>j</code>个奇数；</p></li>
<li><p>第二类：一份包含奇数<code>1</code>，剩余的<code>i-1</code>分成<code>j-1</code>个奇数；另一种，每份至少大于<code>1</code>，将<code>j</code>个<code>1</code>拿出来分到每一份中，其余<code>i-j</code>分成<code>j</code>份偶数。</p></li>
</ul>
<h3 id="参考文献">参考文献：</h3>
<p>[1] <a target="_blank" rel="noopener" href="https://houbb.github.io/2020/01/23/data-struct-learn-07-base-dp#">五大基本算法之动态规划算法 DP</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html">五大常用算法之二：动态规划算法</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/39948290/answer/1309260344">如何理解动态规划？ - 力扣（LeetCode）的回答 - 知乎</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/" rel="tag"># 面试复习</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构和算法</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag"># 动态规划</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2021/07/22/JavaLearning_The_art_of_concurrent_programming_in_Java-11-concurrent-programming-practice.html" rel="next" title="[Java学习|Java并发编程的艺术]--11 Java并发编程实践">
                  <i class="fa fa-chevron-left"></i> [Java学习|Java并发编程的艺术]--11 Java并发编程实践
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2021/07/23/Data_structure_and_algorithm_union-find.html" rel="prev" title="[数据结构和算法|并查集]">
                  [数据结构和算法|并查集] <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">1. 动态规划概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 基本思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 求解的基本步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E9%80%92%E5%BD%92"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 动态规划与递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E4%BD%93"><span class="nav-number">1.5.</span> <span class="nav-text">1.4 变体</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E4%BD%8Ddp"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.4.1 数位dp</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.4.2 0&#x2F;1背包问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86"><span class="nav-number">1.5.3.</span> <span class="nav-text">1.4.2 数的划分</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">2. 动态规划题解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer-10-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 剑指offer-10 斐波那契数列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer-10-%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 剑指offer-10 跳台阶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87offer-13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 剑指offer-13 机器人的运动范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-14--i.-%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 剑指 Offer 14- I. 剪绳子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-19.-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 剑指 Offer 19. 正则表达式匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 Offer 42. 连续子数组的最大和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-43.-1n-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 剑指 Offer 43. 1～n 整数中 1 出现的次数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 剑指 Offer 46. 把数字翻译成字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="nav-number">2.9.</span> <span class="nav-text">2.9 剑指 Offer 47. 礼物的最大价值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-49.-%E4%B8%91%E6%95%B0"><span class="nav-number">2.10.</span> <span class="nav-text">2.10 剑指 Offer 49. 丑数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-60.-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0"><span class="nav-number">2.11.</span> <span class="nav-text">2.11 剑指 Offer 60. n个骰子的点数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-offer-63.-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="nav-number">2.12.</span> <span class="nav-text">2.12 剑指 Offer 63. 股票的最大利润</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#leetcode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">2.13.</span> <span class="nav-text">2.13 leetcode-62 不同路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#leetcode-871.-%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0"><span class="nav-number">2.14.</span> <span class="nav-text">2.14 leetcode-871. 最低加油次数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%8B%B9%E6%9E%9C"><span class="nav-number">2.15.</span> <span class="nav-text">2.15 分苹果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86-1"><span class="nav-number">2.16.</span> <span class="nav-text">2.16 数的划分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86n%E5%88%92%E5%88%86%E6%88%90%E4%B8%8D%E5%A4%A7%E4%BA%8Em%E7%9A%84%E5%88%92%E5%88%86%E6%B3%95"><span class="nav-number">2.16.1.</span> <span class="nav-text">2.16.1 将n划分成不大于m的划分法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86n%E5%88%92%E5%88%86%E6%88%90k%E4%B8%AA%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86%E6%B3%95"><span class="nav-number">2.16.2.</span> <span class="nav-text">2.16.2 将n划分成k个数的划分法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86n%E5%88%92%E5%88%86%E6%88%90%E8%8B%A5%E5%B9%B2%E5%A5%87%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86%E6%B3%95"><span class="nav-number">2.16.3.</span> <span class="nav-text">2.16.3.将n划分成若干奇数的划分法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-number">3.</span> <span class="nav-text">参考文献：</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wuyunjie"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">wuyunjie</p>
  <div class="site-description" itemprop="description">这是一个为了有博客而存在的博客。 会在这里记录技术学习，读书感悟，生活日记等等。欢迎呀！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">135</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wwwwwyj" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wwwwwyj" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wuyunjie.top/loving/happy-birthday" title="Loving → http:&#x2F;&#x2F;wuyunjie.top&#x2F;loving&#x2F;happy-birthday"><i class="fa fa-fw fa-heartbeat"></i>Loving</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wuyunjie</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">575k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:43</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            leancloudSelector(url).innerText = time;
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=xilgdic7Oc4jk1clqctOmHlW-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'xilgdic7Oc4jk1clqctOmHlW-gzGzoHsz',
            'X-LC-Key': '0mJaTLwPvm9HULVEKS5TMolA',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
        if (localhost.test(document.URL)) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>






        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>














  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'fuyVSSepSwnhxBAljzT0Wom8-MdYXbMMI',
    appKey: 'MeBSdvWlNAgNnXhX1HQ1QnA5',
    placeholder: "欢迎评论交流呀！\n输入邮箱可以收到回复通知哦!(昵称输入QQ可以自动识别邮箱和头像)",
    avatar: 'retro',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    enableQQ: true,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
